<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:type" content="website">
<meta property="og:title" content="KJHの博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="KJHの博客">
<meta property="og:description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="匡俊桦">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>KJHの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KJHの博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录&回忆</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/21/java%E6%9B%B4%E5%A4%9A%E7%9A%84%E7%B1%BB%E8%B0%9C%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/21/java%E6%9B%B4%E5%A4%9A%E7%9A%84%E7%B1%BB%E8%B0%9C%E9%A2%98/" class="post-title-link" itemprop="url">javag更多的类谜题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-21 21:43:36 / 修改时间：21:47:16" itemprop="dateCreated datePublished" datetime="2021-03-21T21:43:36+08:00">2021-03-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java-谜题-Java-谜题-7——更多的类谜题"><a href="#Java-谜题-Java-谜题-7——更多的类谜题" class="headerlink" title="Java 谜题 Java 谜题 7——更多的类谜题"></a>Java 谜题 Java 谜题 7——更多的类谜题</h1><h2 id="谜题-66：一件私事"><a href="#谜题-66：一件私事" class="headerlink" title="谜题 66：一件私事"></a>谜题 66：一件私事</h2><p>在下面的程序中，子类的一个域具有与超类的一个域相同的名字。那么，这个程序会打印出</p>
<p>什么呢？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> public <span class="type">String</span> className = <span class="string">"Base"</span>; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="type">String</span> className = <span class="string">"Derived"</span>; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PrivateMatter</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> public static void main(<span class="type">String</span>[ ] args) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="type">System</span>.out.println(<span class="keyword">new</span> <span class="type">Derived</span>().className); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对该程序的表面分析可能会认为它应该打印 Derived，因为这正是存储在每一个</p>
<p>Derived 实例的 className 域中的内容。 更深入一点的分析会认为 Derived 类不能编译，因为 Derived 中的 className</p>
<p>变量具有比 Base 中的 className 变量更具限制性的访问权限。 </p>
<p>如果你尝试着编译该程序，就会发现这种分析也不正确。该程序确实不能编译，</p>
<p>但是错误却出在 PrivateMatter 中。 </p>
<p>如果 className 是一个实例方法，而不是一个实例域，那么 Derived.className()</p>
<p>将覆写 Base.className()，而这样的程序是非法的。一个覆写方法的访问修饰</p>
<p>符所提供的访问权限与被覆写方法的访问修饰符所提供的访问权限相比，至少要</p>
<p>一样多[JLS 8.4.8.3]。 </p>
<p>因为 className 是一个域，所以 Derived.className 隐藏（hide）了</p>
<p>Base.className，而不是覆盖了它[JLS 8.3]。对一个域来说，当它要隐藏另一</p>
<p>个域时，如果隐藏域的访问修饰符提供的访问权限比被隐藏域的少，尽管这么做</p>
<p>不可取的，但是它确实是合法的。事实上，对于隐藏域来说，如果它具有与被隐</p>
<p>藏域完全无关的类型，也是合法的：即使 Derived.className 是</p>
<p>GregorianCalendar 类型的，Derived 类也是合法的。 </p>
<p>在我们的程序中的编译错误出现在 PrivateMatter 类试图访问</p>
<p>Derived.className 的时候。尽管 Base 有一个公共域 className，但是这个域没</p>
<p>有被继承到 Derived 类中，因为它被 Derived.className 隐藏了。在 Derived</p>
<p>类内部，域名 className 引用的是私有域 Derived.className。因为这个域被声</p>
<p>明为是 private 的，所以它对于 PrivateMatter 来说是不可访问的。因此，编译</p>
<p>器产生了类似下面这样的一条错误信息： </p>
<p>PrivateMatter.java:11: className has private access in Derived </p>
<p> System.out.println(new Derived().className); </p>
<p> ^</p>
<p>请注意，尽管在 Derived 实例中的公共域 Base.className 被隐藏了，但是我们</p>
<p>还是可以通过将 Derived 实例转型为 Base 来访问到它。下面版本的</p>
<p>PrivateMatter 就可以打印出 Base： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateMatter</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(((Base)<span class="keyword">new</span> Derived()).className); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这说明了覆写与隐藏之间的一个非常大的区别。一旦一个方法在子类中被覆写，</p>
<p>你就不能在子类的实例上调用它了（除了在子类内部，通过使用 super 关键字来</p>
<p>方法）。然而，你可以通过将子类实例转型为某个超类类型来访问到被隐藏的域，</p>
<p>在这个超类中该域未被隐藏。 如果你想让这个程序打印 Derived，也就是说，你想展示覆写行为，那么你可以</p>
<p>用公共方法来替代公共域。在任何情况下，这都是一个好主意，因为它提供了更</p>
<p>好的封装[EJ Item 19]。下面的程序版本就使用了这项技术，并且能够打印出我</p>
<p>们所期望的 Derived： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getClassName</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="string">"Base"</span>; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="title">extends</span> <span class="title">Base</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getClassName</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="string">"Derived"</span>; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateMatter</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="keyword">new</span> Derived().getClassName()); </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>} </p>
<p>请注意，我们将 Derived 类中的 getClassName 方法声明成了 public 的，尽管在</p>
<p>最初的程序中与其相对应的域是私有的。就像前面提到的那样，覆写方法的访问</p>
<p>修饰符与它要覆写的方法的访问修饰符相比，所具有的限制性不能有任何降低。 </p>
<p>本谜题的教训是隐藏通常都不是一个好主意。Java 语言允许你去隐藏变量、嵌</p>
<p>套类型，甚至是静态方法（就像在谜题 48 所展示的那样），但是你不能认为你</p>
<p>就应该去隐藏。隐藏的问题在于它将导致读者头脑的混乱。你正在使用一个被隐</p>
<p>藏实体，或者是正在使用一个执行了隐藏的实体吗？要避免这类混乱，只需避免</p>
<p>隐藏。 </p>
<p>如果一个类要隐藏一个域，而用来隐藏该域的域具有的可访问性比被隐藏域更具</p>
<p>限制性，就像我们最初的程序那样，那么这就违反了包容性（subsumption）原</p>
<p>则，即大家所熟知的 Liskov 置换原则（Liskov Substitution Principle）</p>
<p>[Liskov87]。这项原则叙述道，你能够对基类所作的任何事，都同样能够作用于</p>
<p>其子类。包容性是面向对象编程的自然心理模型的一个不可分割的部分。无论何</p>
<p>时，只要违反了这项原则，就会对程序的理解造成困难。还有其它数种用另一个</p>
<p>域来隐藏某个域的方法也会违反包容性：例如，两个域具有不同的类型；一个域</p>
<p>是静态的而另一个域不是；一个域是 final 的而另一个域不是；一个域是常量而</p>
<p>另一个域不是；以及两个域都是常量但是它们具有不同的值。 对于语言设计者而言，应该考虑消除隐藏的可能性：例如，使所有的域都隐含地</p>
<p>是私有的。如果这样做显得过于严苛，那么至少应该考虑对隐藏进行限制，以使</p>
<p>其遵守包容性原则。 </p>
<p>总之，当你在声明一个域、一个静态方法或一个嵌套类型时，如果其名字与基类</p>
<p>中相对应的某个可访问的域、方法或类型相同，就会发生隐藏。隐藏是容易产生</p>
<p>混乱的：违反包容性的隐藏域在某种意义上是特别有害的。更一般地讲，除了覆</p>
<p>写之外，要避免名字重用。 </p>
<h2 id="谜题-67：对字符串上瘾"><a href="#谜题-67：对字符串上瘾" class="headerlink" title="谜题 67：对字符串上瘾"></a>谜题 67：对字符串上瘾</h2><p>一个名字可以被用来引用位于不同包内的多个类。下面的程序就是在探究当你重用了一个平</p>
<p>台类的名字时，会发生什么。你认为它会做些什么呢？尽管这个程序属于那种让你通常一看</p>
<p>到就会感到尴尬的程序，但是你还是应该继续下去，把门锁上，把百叶窗拉上，然后试试看：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrungOut</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">String</span> s = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"Hello world"</span>); </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(s); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> java.lang.<span class="keyword">String</span> s; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(java.lang.<span class="keyword">String</span> s)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.s = s; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> java.lang.<span class="function"><span class="keyword">String</span> <span class="title">toString</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> s; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果说这个程序有点让人讨厌的话，它看起来还是相当简单的。在未命名包中的</p>
<p>String 类就是一个 java.lang.String 实例的包装器，看起来该程序应该打印</p>
<p>Hello world。如果你尝试着运行该程序，你会发现你运行不了它，VM 将弹出了</p>
<p>一个像下面这样的错误消息： </p>
<p>Exception in thread “main” java.lang.NoSuchMethodError: main </p>
<p>但是它肯定是一个 main 方法的：它就白纸黑字地写在那里。为什么 VM 找不到它</p>
<p>呢？ </p>
<p>VM 不能找到 main 方法是因为它并不在那里。尽管 StrungOut 有一个被命名为</p>
<p>main 的方法，但是它却具有错误的签名。一个 main 方法必须接受一个单一的字</p>
<p>符串数组参数[JVMS 5.2]。VM 努力要告诉我们的是 StrungOut.main 接受的是由我们的 String 类所构成的数组，它无论如何都与 java.lang.String 没有任何关</p>
<p>系。 </p>
<p>如果你确实需要编写自己的字符串类，看在老天爷的份上，千万不要称其为</p>
<p>String。要避免重用平台类的名字，并且千万不要重用 java.lang 中的类名，因</p>
<p>为这些名字会被各处的程序自动加载。程序员习惯于看到这些名字以无限定的形</p>
<p>式出现，并且会很自然地认为这些名字引用的是我们所熟知的 java.lang 中的</p>
<p>类。如果你重用了这些名字的某一个，那么当这个名字在其自己的包内被使用时，</p>
<p>该名字的无限定形式将会引用到新的定义上。 </p>
<p>要订正该程序，只需为这个非标准的字符串类挑选一个合理的名字即可。该程序</p>
<p>下面的这个版本很明显是正确的，而且它比最初的版本要更易于理解。它将打印</p>
<p>出如你所期望的 Hello World:</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrungOut</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[ ] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> MyString s = <span class="keyword">new</span> MyString(<span class="string">"Hello world"</span>); </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(s); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> java.lang.<span class="keyword">String</span> s; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyString</span><span class="params">(java.lang.<span class="keyword">String</span> s)</span> </span>&#123; <span class="keyword">this</span>.s = s;&#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> java.lang.<span class="function"><span class="keyword">String</span> <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s;&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>宽泛地讲，本谜题的教训就是要避免重用类名，尤其是 Java 平台类的类名。千</p>
<p>万不要重用 java.lang 包内的类名，相同的教训也适用于类库的设计者。Java</p>
<p>平台的设计者已经在这个问题上栽过数次了，著名的例子有 java.sql.Date，它</p>
<p>与 java.util.Date 和 org.omg.CORBA.Object 相冲突。与在本章中的许多其他谜</p>
<p>题一样，这个教训是有关你在除了覆写之外的其他情况应该避免名字重用这一原</p>
<p>则的一个具体实例。对平台实现者来说，其教训是诊断信息应该清晰地解释失败</p>
<p>的原因。VM 应该可以很容易地将没有任何具有正确签名的 main 方法的情况与根</p>
<p>本就没有任何 main 方法的情况区分开。 </p>
<h2 id="谜题-68：灰色的阴影"><a href="#谜题-68：灰色的阴影" class="headerlink" title="谜题 68：灰色的阴影"></a>谜题 68：灰色的阴影</h2><p>下面的程序在相同的范围内具有两个名字相同的声明，并且没有任何明显的方式可以在它们</p>
<p>二者之间做选择。这个程序会打印 Black 吗？它会打印 White 吗？甚至，它是合法的吗？</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShadesOfGray</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(X.Y.Z); </span><br><span class="line"></span><br><span class="line"> &#125; &#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Y</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">String</span> Z = <span class="string">"Black"</span>; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> C Y = <span class="keyword">new</span> C(); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">String</span> Z = <span class="string">"White"</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有任何显而易见的方法可以确定该程序应该打印 Black 还是 White。编译器通</p>
<p>常会拒绝模棱两可的程序，而这个程序看起来肯定是模棱两可的。因此，它似乎</p>
<p>应该是非法的。如果你试着运行它，就会发现它是合法的，并且会打印出 White。</p>
<p>你怎样才能事先了解这一切呢？ </p>
<p>可以证明，在这样的上下文环境中，有一条规则决定着程序的行为，即当一个变</p>
<p>量和一个类型具有相同的名字，并且它们位于相同的作用域时，变量名具有优先</p>
<p>权[JLS 6.5.2]。变量名将遮掩（obscure）类型名[JLS 6.3.2]。相似地，变量</p>
<p>名和类型名可以遮掩包名。这条规则真的是相当地晦涩，任何依赖于它的程序都</p>
<p>极有可能使它的读者晕头转向。 </p>
<p>幸运的是，遵守标准的 Java 命名习惯的程序继续从来都不会遇上这个问题。类</p>
<p>应该以一个大写字母开头，以 MixedCase 的形式书写；变量应该以一个小写字母</p>
<p>开头，以 mixedCase 的形式书写；而常量应该以一个大写字母开头，以 ALL_CAPS</p>
<p>的方式书写。单个的大写字母只能用于类型参数，就像在泛型接口 Map&lt;K,V&gt;中</p>
<p>那样。包名应该以 lower.case 的方式命名[JLS 6.8]。 </p>
<p>为了避免常量名与类名的冲突，在类名中应该将首字母缩拼词当作普通的词处理</p>
<p>[EJ Item 38]。例如，一个表示全局唯一标识符的类应该被命名为 Uuid，而不</p>
<p>是 UUID，尽管其首字母缩拼词通常被写为 UUID。（Java 平台库就违反了这项建</p>
<p>议，因为它具有 UUID、URL 和 URI 这样的类名。）为了避免变量名与包名的冲突，</p>
<p>请不要使用顶层的包名或领域名作为变量的名字，特别是不要将一个变量命名为</p>
<p>com、org、net、edu、java 或 javax。 </p>
<p>要想移除 ShadesOfGray 这个程序中的所有不明确性，只需以遵守命名习惯的方</p>
<p>式对其重写即可。很明显，下面的程序将打印 Black。作为一种附加的好处，当</p>
<p>你大声朗读这个程序时，听起来还最初的那个程序是完全一样的。 </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShadesOfGray</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[ ] args)</span></span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(Ex.Why.Z); </span><br><span class="line"></span><br><span class="line"> &#125; &#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ex</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Why</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">String</span> Z = <span class="string">"Black"</span>; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> See y = <span class="keyword">new</span> See(); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">See</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">String</span> Z = <span class="string">"White"</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，应该遵守标准的命名习惯以避免不同的命名空间之间的冲突，还有一个原</p>
<p>因就是如果你违反这些习惯，那么你的程序将让人难以辨认。同样，为了避免变</p>
<p>量名与通用的顶层包名相冲突，请使用 MixedCase 风格的类名，即使其名字是首</p>
<p>字母缩拼词也应如此。通过遵守这些规则，你就可以确保你的程序永远不会遮掩</p>
<p>类名或包名。再次说明一下，这里列举的仍然是你应该在覆写之外的情况中避免</p>
<p>名字重用的一个实例。对语言设计者来说，应该考虑去消除遮掩的可能性。C#</p>
<p>是通过将域和嵌套类置于相同的命名空间来实现这一点的。 </p>
<h2 id="谜题-69：黑色的渐隐"><a href="#谜题-69：黑色的渐隐" class="headerlink" title="谜题 69：黑色的渐隐"></a>谜题 69：黑色的渐隐</h2><p>假设你不能修改前一个谜题（谜题 68）中的 X 和 C 这两个类。你能否编写一个类，其 main</p>
<p>方法将读取 X.Y 类中的 Z 域的值，然后打印它。注意，不能使用反射。 </p>
<p>本谜题初看起来是不可能实现的。毕竟，X.Y 类被具有相同名字的一个域给遮掩</p>
<p>了，因此对其命名的尝试将引用到该域上。 </p>
<p>事实上，我们是可以引用到一个被遮掩的类型名的，其技巧就是在某一种特殊的</p>
<p>语法上下文环境中使用该名字，在该语法上下文环境中允许出现一个类型但是不</p>
<p>允许出现一个变量。在转型表达式的括号中间的部分就是这样一种上下文环境。</p>
<p>下面的程序通过使用这种技术解决了这个谜题，并且将打印出我们所期望的</p>
<p>Black： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FadeToBlack</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(((X.Y)null).Z); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，我们是用一个具有 X.Y 类型的表达式来访问 X.Y 类的 Z 域的。就像我们</p>
<p>在谜题 48 和 54 中所看到的，用一个表达式而不是类型名来访问一个静态成员是</p>
<p>合法的，但却是一种有问题的用法。 不借助这种有问题的用法，而是通过在一个类声明的 extends 子句中使用一个被</p>
<p>遮掩的类这种方式，你也可以解决本谜题。因为基类总是一种类型，出现在</p>
<p>extends 子句中的名字从来都不会被解析为变量名。下面的程序就展示了这项技</p>
<p>术，它也会打印出 Black： </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FadeToBlack</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> static <span class="class"><span class="keyword">class</span> <span class="title">Xy</span> <span class="keyword">extends</span> <span class="title">X</span>.<span class="title">Y</span></span>&#123; &#125; </span><br><span class="line"></span><br><span class="line"> public static void main(<span class="type">String</span>[ ] args)&#123; </span><br><span class="line"></span><br><span class="line"> <span class="type">System</span>.out.println(<span class="type">Xy</span>.<span class="type">Z</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你使用的 5.0 或更新的版本，那么通过在一个类型变量声明的 extends 子句</p>
<p>中使用 X.Y 这种方式，你也可以解决本谜题： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FadeToBlack</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends X.Y&gt; <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(T.Z); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，要解决由类型被变量遮掩而引发的问题，需要按照标准的命名习惯来重命</p>
<p>名类型和变量，就像在谜题 68 中所讨论的那样。如果做不到这一点，那么你应</p>
<p>该在只允许类型名的上下文环境中使用被遮掩的类型名。幸运的话，你将永远不</p>
<p>需要凭借这种对程序的变形来解决问题，因为大多数的类库作者都很明智，他们</p>
<p>都避免了必需使用这种变形的有问题的用法。然而，如果你确实发现自己身处这</p>
<p>种境地，那么你最好是要了解这个问题需要解决。 </p>
<h2 id="谜题-70：一揽子交易"><a href="#谜题-70：一揽子交易" class="headerlink" title="谜题 70：一揽子交易"></a>谜题 70：一揽子交易</h2><p>下面这个程序设计在不同的包中的两个类的交互，main 方法位于 hack.TypeIt 中。那么，这</p>
<p>个程序会打印什么呢？</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package hack; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="built_in">click</span>.CodeTalk; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeIt</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClickIt</span> <span class="title">extends</span> <span class="title">CodeTalk</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">printMessage</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"Hack"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[ ] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> ClickIt clickit = <span class="keyword">new</span> ClickIt(); </span><br><span class="line"></span><br><span class="line"> clickit.doIt(); &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">package <span class="built_in">click</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeTalk</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> printMessage(); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">printMessage</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"Click"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本谜题看起来很直观。Hack.TypeIt 的 main 方法对 TypeIt.ClickIt 类实例化，</p>
<p>然后调用其 doIt 方法，该方法是从 CodeTalk 继承而来。接着，该方法调用</p>
<p>printMessage 方法，它在 TypeIt.ClickIt 中被声明为打印 Hack。然而，如果你</p>
<p>运行该程序，它打印的将是 Click。怎么会这样呢？ </p>
<p>上面的分析做出了一个不正确的假设，即 Hack.TypeIt.ClickIt.printMessage</p>
<p>方法覆写了 click.CodeTalk.printMessage 方法。一个包内私有的方法不能被位</p>
<p>于另一个包中的某个方法直接覆写[JLS 8.4.8]。在程序中的这两个 twoMessage</p>
<p>方法是无关的，它们仅仅是具有相同的名字而已。当程序在 hack 包内调用</p>
<p>printMessage 方法时，运行的是 hack.TypeIt.ClickIt.printMessage 方法。这</p>
<p>个方法将打印 Click，这也就解释了我们所观察到的行为。 </p>
<p>如果你想让 hack.TypeIt.ClickIt 中的 printMessage 方法覆写在</p>
<p>Click.CodeTalk 中的该方法，那么你必须在 Click.CodeTalk 中的该方法声明之</p>
<p>前添加 protected 或 public 修饰符。要使该程序能够编译，你还必须在</p>
<p>hack.TypeIt.ClickIt 的覆写声明的前面添加一个修饰符，该修饰符与你在</p>
<p>Click.CodeTalk 的 printMessage 方法上放置的修饰符相比，所具备的限制性不</p>
<p>能更多[JLS 8.4.8.3]。换句话说，两个 printMessage 方法可以都被声明为是</p>
<p>public 的，也可以都被声明为是 protected 的，或者，超类中的方法被声明为</p>
<p>是 protected，而子类中的方法被声明为是 public 的。无论你执行了上述三种</p>
<p>修改中的任何一种，该程序都将打印 Hack，从而表明确实发生了覆写。 </p>
<p>总之，包内私有的方法不能直接被包外的方法声明所覆写。尽管包内私有的访问</p>
<p>权限和覆写结合到一起会导致某种混乱，但是 Java 当前的行为是允许使用包的，</p>
<p>以支持比单个的类更大的抽象封装。包内私有的方法是它们所属包的实现细节，</p>
<p>在包外重用它们的名字是不会对包内产生任何影响的。 </p>
<h2 id="谜题-71：进口税"><a href="#谜题-71：进口税" class="headerlink" title="谜题 71：进口税"></a>谜题 71：进口税</h2><p>在 5.0 版中，Java 平台引入了大量的可以使操作数组变得更加容易的工具。下面这个谜题使用了变量参数、自动包装、静态导入（请查看 <a href="http://java.sun.com/j2se/5.0/docs/guide/language" target="_blank" rel="noopener">http://java.sun.com/j2se/5.0/docs/guide/language</a> </p>
<p>[Java-5.0]）以及便捷方法 Arrays.toString（请查看谜题 60）。那么，这个程序会打印什么呢？</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> static java.util.Arrays.toString; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">ImportDuty</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> static <span class="built_in">void</span> main(String[ ] args) &#123; </span><br><span class="line"></span><br><span class="line"> printArgs(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> static <span class="built_in">void</span> printArgs(Object... args) &#123; </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println(toString(args)); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能会期望该程序打印[1,2,3,4,5]，实际上它确实会这么做，只要它能编译。</p>
<p>令人沮丧的是，看起来编译器找不到恰当的 toString 方法： </p>
<p>ImportDuty.java:9:Object.toString()can’t be applied to(Object[]) </p>
<p> System.out.println(toString(args)); </p>
<p> ^</p>
<p>是不是编译器的理解力太差了？为什么它会尝试着去应用 Object.toString()</p>
<p>呢？它与调用参数列表并不匹配，而 Arrays.toString(Object[ ])却可以完全</p>
<p>匹配。 </p>
<p>编译器在选择在运行期将被调用的方法时，所作的第一件事就是在肯定能找到该</p>
<p>方法的范围内挑选[JLS 15.12.1]。编译器将在包含了具有恰当名字的方法的最</p>
<p>小闭合范围内进行挑选，在我们的程序中，这个范围就是 ImportDuty 类，它包</p>
<p>含了从 Object 继承而来的 toString 方法。在这个范围中没有任何可以应用于</p>
<p>toString(args)调用的方法，因此编译器必须拒绝该程序。 </p>
<p>换句话说，我们想要的 toString 方法没有在调用点所处的范围内。导入的</p>
<p>toString 方法被 ImportDuty 从 Object 那里继承而来的具有相同名字的方法所</p>
<p>遮蔽（shade）了[JLS 6.3.1]。遮蔽与遮掩（谜题 68）非常相像，二者的关键</p>
<p>区别是一个声明只能遮蔽类型相同的另一个声明：一个类型声明可以遮蔽另一个</p>
<p>类型声明，一个变量声明可以遮蔽另一个变量声明，一个方法声明可以遮蔽另一</p>
<p>个方法声明。与其形成对照的是，变量声明可以遮掩类型和包声明，而类型声明</p>
<p>也可以遮掩包声明。 </p>
<p>当一个声明遮蔽了另一个声明时，简单名将引用到遮蔽声明中的实体。在本例中，</p>
<p>toString 引用的是从 Object 继承而来的 toString 方法。简单地说，本身就属</p>
<p>于某个范围的成员在该范围内与静态导入相比具有优先权。这导致的后果之一就</p>
<p>是与 Object 的方法具有相同名字的静态方法不能通过静态导入工具而得到使</p>
<p>用。 </p>
<p>既然你不能对 Arrays.toString 使用静态导入，那么你就应该用一个普通的导入</p>
<p>声明来代替。下面就是 Arrays.toString 应该被正确使用的方式： </p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ImportDuty &#123; </span><br><span class="line"></span><br><span class="line"> static void print<span class="constructor">Args(Object<span class="operator">...</span> <span class="params">args</span>)</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">args</span>)</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你特别强烈地想避免显式地限定 Arrays.toString 调用，那么你可以编写你</p>
<p>自己的私有静态转发方法： </p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static String <span class="keyword">to</span><span class="constructor">String(Object[] <span class="params">a</span>)</span> &#123; </span><br><span class="line"></span><br><span class="line"> return <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">a</span>)</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态导入工具所专门针对的情况是：程序中会重复地使用另一个类的静态元素，</p>
<p>而每一次用到的时候都进行限定又会使程序变得乱成一锅粥。在这类情况中，静</p>
<p>态导入工具可以显著地提高可读性。这比通过实现接口来继承其常量要安全得</p>
<p>多，而实现接口这种做法是你从来都不应该采用的 [EJ Item 17]。然而，滥用</p>
<p>静态导入工具也会损害可读性，因为这会使得静态成员的类在何处被使用显得非</p>
<p>常不清晰。应该有节制地使用静态导入，只有在非常需要的情况下才应该使用它</p>
<p>们。 </p>
<p>对 API 设计者来说，要意识到当某个方法的名字已经出现在某个作用域内时，静</p>
<p>态导入工具并不能被有效地作用于该方法上。这意味着静态导入不能用于那些与</p>
<p>通用接口中的方法共享方法名的静态方法，而且也从来不能用于那些与 Object</p>
<p>中的方法共享方法名的静态方法。再次说明一下，本谜题所要说明的仍然是你在</p>
<p>覆写之外的情况中使用名字重用通常都会产生混乱。我们通过重载、隐藏和遮掩</p>
<p>看清楚了这一点，现在我们又通过遮蔽看到了同样的问题。 </p>
<h2 id="谜题-72：终极危难"><a href="#谜题-72：终极危难" class="headerlink" title="谜题 72：终极危难"></a>谜题 72：终极危难</h2><p>本谜题旨在检验当你试图隐藏一个 final 域时将要发生的事情。下面的程序将做些什么呢？</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jeopardy</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> PRIZE = <span class="string">"$64,000"</span>; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleJeopardy</span> <span class="title">extends</span> <span class="title">Jeopardy</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> PRIZE = <span class="string">"2 cents"</span>; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[ ] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(DoubleJeopardy.PRIZE); </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>} 因为在 Jeopardy 中的 PRIZE 域被声明为是 public 和 final 的，你可能会认为</p>
<p>Java 语言将阻止你在子类中重用该域名。毕竟，final 类型的方法不能被覆写或</p>
<p>隐藏。如果你尝试着运行该程序，就会发现它可以毫无问题地通过编译，并且将</p>
<p>打印 2 cents。出什么错了呢？ </p>
<p>可以证明，final 修饰符对方法和域而言，意味着某些完全不同的事情。对于方</p>
<p>法，final 意味着该方法不能被覆写（对实例方法而言）或者隐藏（对静态方法</p>
<p>而言）[JLS 8.4.3.3]。对于域，final 意味着该域不能被赋值超过一次[JLS</p>
<p>8.3.1.2]。关键字相同，但是其行为却完全不相关。 </p>
<p>在该程序中，final 域 DoubleJeopardy.PRIZE 隐藏了 final 域 Jeopardy.PRIZE，</p>
<p>其净损失达到了$63,999.98。尽管我们可以隐藏一个域，但是通常这都是一个不</p>
<p>好的念头。就像我们在谜题 66 中所讨论的，隐藏域可能会违反包容性，并且会</p>
<p>混淆我们对类型与其成员之间的关系所产生的直觉。 </p>
<p>如果你想保证在 Jeopardy 类中的奖金可以保留到子类中，那么你应该用一个</p>
<p>final 方法来代替 final 域： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jeopardy</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> PRIZE = <span class="string">"$64,000"</span>; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> <span class="title">prize</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> PRIZE; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对语言设计者来说，其教训是应该避免在不相关的概念之间重用关键字。一个关</p>
<p>键字应该只在密切相关的概念之间重用，这样可以帮助程序员构建关于易混淆的</p>
<p>语言特性之间的关系的印象。在 Java 的 final 关键字这一案例中，重用就导致</p>
<p>了混乱。应该注意的是，作为一种有年头的语言来说，在无关的概念之间重用关</p>
<p>键字是它的一种自然趋势，这样做可以避免引入新的关键字，而引入新的关键字</p>
<p>会对语言的稳定性造成极大的损害。当语言设计者在考虑该怎么做时，总是在两</p>
<p>害相权取其轻。 </p>
<p>总之，要避免在无关的变量或无关的概念之间重用名字。对无关的概念使用有区</p>
<p>别的名字有助于让读者和程序员区分这些概念。 </p>
<h2 id="谜题-73：你的隐私正在公开"><a href="#谜题-73：你的隐私正在公开" class="headerlink" title="谜题 73：你的隐私正在公开"></a>谜题 73：你的隐私正在公开</h2><p>私有成员，即私有方法、域和类型这些概念的幕后思想是它们只是实现细节：一个类的实现</p>
<p>者可以随意地添加一个新的私有成员，或者修改和移除一个旧的私有成员，而不需要担心对</p>
<p>该类的客户造成任何损害。换句话说，私有成员被包含它们的类完全封装了。 </p>
<p>遗憾的是，在这种严密的盔甲保护中仍然存在细小的裂缝。例如，序列化就可以</p>
<p>打破这种封装。如果使一个类成为可序列化的，并且接受缺省的序列化形式，那么该类的私有实例域将成为其导出 API 的一部分[EJ Item 54,55]。当客户正在</p>
<p>使用现有的被序列化对象时，对私有表示的修改将会导致异常或者是错误的行</p>
<p>为。 </p>
<p>但是编译期的错误又会怎么样呢？你能否写出一个 final 的“库”类和“客</p>
<p>户”类，这两者都可以毫无问题地通过编译，然后在库类中添加一个私有成员，</p>
<p>使得库类仍然能够编译，而客户类却再也不能编译了？ </p>
<p>如果你的解谜方案是要对库类添加一个私有构造器，以抑制通过缺省的公共构造</p>
<p>器而创建实例的行为，那么你只是一知半解。本谜题要求你添加一个私有成员，</p>
<p>严格地讲，构造器不是成员[JLS 6.4.3]。 </p>
<p>本谜题有数个解谜方案，其中一个是使用遮蔽： </p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> library; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> final <span class="class"><span class="keyword">class</span> <span class="title">Api</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// private static class String&#123; &#125; </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> <span class="keyword">new</span><span class="type">String</span>() &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">String</span>(); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> client; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> library.Api; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">String</span> s = Api.<span class="keyword">new</span><span class="type">String</span>(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上编写，该程序就可以毫无问题地通过编译。如果我们不注释掉 library.Api</p>
<p>中的局部类 String 的私有声明，那么 Api.newString 方法就再也不会返回</p>
<p>java.lang.String 类型了，因此变量 Client.s 的初始化将不能通过编译： </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">client/Client.java:4</span>: incompatible types </span><br><span class="line"></span><br><span class="line"><span class="attribute">found</span>: library.Api.String, required: java.lang.String</span><br><span class="line"></span><br><span class="line"> String s = Api.newString(); </span><br><span class="line"></span><br><span class="line"> ^</span><br></pre></td></tr></table></figure>

<p>尽管我们所做的文本修改仅仅是添加了一个私有类声明，但是我们间接地修改了</p>
<p>一个现有公共方法的返回类型，而这是一个不兼容的 API 修改，因为我们修改了</p>
<p>一个被导出 API 所使用的名字的含义。 </p>
<p>这种解谜方案的数个变种也都可以实现这个目的。被遮蔽类型也可以来自一个外</p>
<p>围类而不是来自 java.lang；你可以遮蔽一个变量而不是一个类型，而被遮蔽变</p>
<p>量可以来自一个 static import 声明或者是来自一个外围类。 不修改类库的某个被导出成员的类型也可以解决本谜题。下面就是这样的一个解</p>
<p>谜方案，它使用的是隐藏而不是遮蔽： </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> library; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApiBase</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> public static <span class="keyword">final</span> int <span class="type">ANSWER</span> = <span class="number">42</span>; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Api</span> <span class="keyword">extends</span> <span class="title">ApiBase</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// private static final int ANSWER = 6 * 9； </span></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> client; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> library.<span class="type">Api</span>; </span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> int answer = <span class="type">Api</span>.<span class="type">ANSWER</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上编写，该程序就可以毫无问题地通过编译。如果我们不注释掉 library.Api</p>
<p>中的私有声明，那么客户类将不能通过编译： </p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">client/<span class="module-access"><span class="module"><span class="identifier">Client</span>.</span></span>java:<span class="number">4</span>: ANSWER has <span class="keyword">private</span> access <span class="keyword">in</span> library.Api </span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> answer = Api.ANSWER; </span><br><span class="line"></span><br><span class="line"> ^</span><br></pre></td></tr></table></figure>

<p>这个新的私有域 Api.ANSWER 隐藏了公共域 ApiBase.ANSWER，而这个域本来是应</p>
<p>该被继承到 Api 中的。因为新的域被声明为是 private 的，所以它不能被 Client</p>
<p>访问。这种解谜方案的数个变种也都可以实现这个目的。你可以用隐藏一个实例</p>
<p>域去替代隐藏一个静态域，或者用隐藏一个类型去替代隐藏一个域。 </p>
<p>你还可以用遮掩来解决本谜题。所有的解谜方案都是通过重用某个名字来破坏客</p>
<p>户类。重用名字是危险的；应该避免隐藏、遮蔽和遮掩。是不是对此已经耳熟能</p>
<p>详了？很好！ </p>
<h2 id="谜题-74：同一性的危机"><a href="#谜题-74：同一性的危机" class="headerlink" title="谜题 74：同一性的危机"></a>谜题 74：同一性的危机</h2><p>下面的程序是不完整的，它缺乏对 Enigma 的声明，这个类扩展自 java.lang.Object。请为</p>
<p>Enigma 提供一个声明，它可以使该程序打印 false：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Conundrum</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> Enigma e = <span class="keyword">new</span> Enigma(); </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(e.equals(e)); </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>} 噢，还有一件事：你不能覆写 equals 方法。 </p>
<p>乍一看，这似乎不可能实现。因为 Object.equals 方法将测试对象的同一性，通</p>
<p>过 Enigma 传递给 equals 方法的对象肯定是与其自身相同的。如果你不能覆写</p>
<p>Object.equals 方法，那么 main 方法必然打印 true，对吗？ </p>
<p>别那么快下结论，伙计。尽管本谜题禁止你覆写（override）Object.equals 方</p>
<p>法，但是你是可以重载（overload）它的，这也就引出了下面的解谜方案： </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Enigma</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// Don’t do this! </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">Boolean</span> equals(Enigma other)&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管这个声明能够解决本谜题，但是它的做法确实非常不好的。它违反了谜题</p>
<p>58 的建议：如果同一个方法的两个重载版本都可以应用于某些参数，那么它们</p>
<p>应该具有相同的行为。在本例中，e.equals(e)和 e.equals((Object)e)将返回</p>
<p>不同的结果，其潜在的混乱是显而易见的。 </p>
<p>然而，有一种解谜方案是不会违反这项建议的： </p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">final class Enigma &#123; </span><br><span class="line"></span><br><span class="line"> public Enigma() &#123; </span><br><span class="line"></span><br><span class="line"> System.out.println(false); </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">exit</span>(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能会有些争论，这个解谜方案似乎违背了本谜题的精神：能够产生我们想要的</p>
<p>输出的 println 调用出现在了构造器中，而不是在 main 方法中。然而，它确实</p>
<p>解决了这个谜题，你不得不承认它很伶俐。 </p>
<p>这里的教训，可以参阅前面的 8 个谜题和谜题 58。如果你重载了一个方法，那</p>
<p>么一定要确保所有的重载版本行为一致。 </p>
<h2 id="谜题-75：头还是尾？"><a href="#谜题-75：头还是尾？" class="headerlink" title="谜题 75：头还是尾？"></a>谜题 75：头还是尾？</h2><p>这个程序的行为在 1.4 版和 5.0 版的 Java 平台上会有些变化。这个程序在这些版本上会分别</p>
<p>做些什么呢？（如果你只能访问 5.0 版本的平台，那么你可以在编译的时候使用-source 1.4</p>
<p>标记，以此来模拟 1.4 版的行为。）</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoinSide</span> &#123;</span> <span class="keyword">private</span> <span class="keyword">static</span> Random rnd = <span class="keyword">new</span> Random(); </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CoinSide <span class="title">flip</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> rnd.nextBoolean() ? </span><br><span class="line"></span><br><span class="line"> Heads.INSTANCE : Tails.INSTANCE; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[ ] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(flip()); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heads</span> <span class="title">extends</span> <span class="title">CoinSide</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">Heads</span><span class="params">()</span> </span>&#123; &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Heads INSTANCE = <span class="keyword">new</span> Heads(); </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">toString</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="string">"heads"</span>; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tails</span> <span class="title">extends</span> <span class="title">CoinSide</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">Tails</span><span class="params">()</span> </span>&#123; &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Tails INSTANCE = <span class="keyword">new</span> Tails(); </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">toString</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="string">"tails"</span>; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序看起来根本没有使用 5.0 版的任何新特性，因此很难看出来为什么它们在</p>
<p>行为上应该有差异。事实上，该程序在 1.4 或更早版本的平台上是不能编译的： </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CoinSide.java:7</span>: </span><br><span class="line"></span><br><span class="line">incompatible types for ?: neither is a subtype of the other </span><br><span class="line"></span><br><span class="line">second operand: Heads </span><br><span class="line"></span><br><span class="line">third operand : Tails </span><br><span class="line"></span><br><span class="line"> return rnd.nextBoolean() ?</span><br><span class="line"></span><br><span class="line"> ^</span><br></pre></td></tr></table></figure>

<p>条件操作符（？:）的行为在 5.0 版本之前是非常受限的[JLS2 15.25]。当第二</p>
<p>个和第三个操作数是引用类型时，条件操作符要求它们其中的一个必须是另一个</p>
<p>的子类型。Heads 和 Tails 彼此都不是对方的子类型，所以这里就产生了一个错</p>
<p>误。为了让这段代码能够编译，你可以将其中一个操作数转型为二者的公共超类： </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> rnd.nextBooleam() ?</span><br></pre></td></tr></table></figure>

<p>(CoinSide)Heads.INSTANCE : Tails.INSTANCE; 在 5.0 或更新的版本中，Java 语言显得更加宽大了，条件操作符在第二个和第</p>
<p>三个操作数是引用类型时总是合法的。其结果类型是这两种类型的最小公共超</p>
<p>类。公共超类总是存在的，因为 Object 是每一个对象类型的超类型。在实际使</p>
<p>用中，这种变化的主要结果就是条件操作符做正确的事情的情况更多了，而给出</p>
<p>编译期错误的情况更少了。对于我们当中的语言菜鸟来说，作用于引用类型的条</p>
<p>件操作符的结果所具备的编译期类型与在第二个和第三个操作数上调用下面的</p>
<p>方法的结果相同： </p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">T</span> <span class="built_in">choose</span>(<span class="built_in">T</span> a,<span class="built_in">T</span> b) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>本谜题所展示的问题在 1.4 和更早的版本中发生得相当频繁，迫使你必须插入只</p>
<p>是为了遮掩你的代码的真实目的而进行的转型。这就是说，该谜题本身是人为制</p>
<p>造的。在 5.0 版本之前，使用类型安全的枚举模式来编写 CoinSide 对程序员来</p>
<p>说会显得更自然一些[EJ Item 21]： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoinSide</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> CoinSide HEADS = <span class="keyword">new</span> CoinSide(<span class="string">"heads"</span>); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> CoinSide TAILS = <span class="keyword">new</span> CoinSide(<span class="string">"tails"</span>); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">String</span> name; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">CoinSide</span><span class="params">(<span class="keyword">String</span> name)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.name = name; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">toString</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> name; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Random rnd = <span class="keyword">new</span> Random(); </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CoinSide <span class="title">flip</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> rnd.nextBoolean() ? HEADS : TAILS; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(flip()); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 5.0 或更新的版本中，自然会将 CoinSide 当作是一个枚举类型来编写： </p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">CoinSide</span> &#123; </span></span><br><span class="line"></span><br><span class="line"> HEADS, TAILS; </span><br><span class="line"></span><br><span class="line"> public String toString() &#123; <span class="keyword">return</span> name().toLowerCase(); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> /<span class="regexp">/ flip 和 main 与上面的 1.4 版上的实现一样</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>本谜题的教训是：应该升级到最新的 Java 平台版本上。较新的版本都包含许多</p>
<p>让程序员更轻松的改进，你并不需要费力去学习怎样利用所有的新特性，有些新</p>
<p>特性不需要你付出任何努力就可以给你带来实惠。对语言和类库的设计者来说，</p>
<p>得到的教训是：不要让程序员去做那些语言或类库本可以帮他们做的事。 </p>
<p>名字重用的术语表 </p>
<p>覆写（override）</p>
<p>一个实例方法可以覆写（override）在其超类中可访问到的具有相同签名的所有实例方法[JLS </p>
<p>8.4.8.1]，从而使能了动态分派（dynamic dispatch）；换句话说，VM 将基于实例的运行期类</p>
<p>型来选择要调用的覆写方法[JLS 15.12.4.4]。覆写是面向对象编程技术的基础，并且是唯一</p>
<p>没有被普遍劝阻的名字重用形式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> public void f() &#123; &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> public void f() &#123; &#125; <span class="comment">// overrides Base.f() </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>隐藏（hide）</p>
<p>一个域、静态方法或成员类型可以分别隐藏（hide）在其超类中可访问到的具有相同名字（对</p>
<p>方法而言就是相同的方法签名）的所有域、静态方法或成员类型。隐藏一个成员将阻止其被</p>
<p>继承[JLS 8.3, 8.4.8.2, 8.5]：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> public static void f() &#123; &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> static void f() &#123; &#125; <span class="comment">// hides Base.f() </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重载（overload） </p>
<p>在某个类中的方法可以重载（overload）另一个方法，只要它们具有相同的名字和不同的签</p>
<p>名。由调用所指定的重载方法是在编译期选定的[JLS 8.4.9, 15.12.2]：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircuitBreaker</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; &#125; <span class="comment">// int overloading</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">String</span> s)</span> </span>&#123; &#125; <span class="comment">// String overloading</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遮蔽（shadow）</p>
<p>一个变量、方法或类型可以分别遮蔽（shadow）在一个闭合的文本范围内的具有相同名字</p>
<p>的所有变量、方法或类型。如果一个实体被遮蔽了，那么你用它的简单名是无法引用到它的；</p>
<p>根据实体的不同，有时你根本就无法引用到它[JLS 6.3.1]：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WhoKnows</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">String</span> sentence = <span class="string">"I don't know."</span>; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> woid <span class="title">main</span><span class="params">(<span class="keyword">String</span>[ ] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">String</span> sentence = “I know!”; <span class="comment">// shadows static field </span></span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(sentence); <span class="comment">// prints local variable </span></span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管遮蔽通常是被劝阻的，但是有一种通用的惯用法确实涉及遮蔽。构造器经常</p>
<p>将来自其所在类的某个域名重用为一个参数，以传递这个命名域的值。这种惯用</p>
<p>法并不是没有风险，但是大多数 Java 程序员都认为这种风格带来的实惠要超过</p>
<p>其风险： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Belt</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="built_in">size</span>; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Belt</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123; <span class="comment">// Parameter shadows Belt.size </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.<span class="built_in">size</span> = <span class="built_in">size</span>; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遮掩（obscure）</p>
<p>一个变量可以遮掩具有相同名字的一个类型，只要它们都在同一个范围内：如果这个名字被</p>
<p>用于变量与类型都被许可的范围，那么它将引用到变量上。相似地，一个变量或一个类型可</p>
<p>以遮掩一个包。遮掩是唯一一种两个名字位于不同的名字空间的名字重用形式，这些名字空</p>
<p>间包括：变量、包、方法或类型。如果一个类型或一个包被遮掩了，那么你不能通过其简单</p>
<p>名引用到它，除非是在这样一个上下文环境中，即语法只允许在其名字空间中出现一种名字。</p>
<p>遵守命名习惯就可以极大地消除产生遮掩的可能性[JLS 6.3.2, 6.5]：public class Obscure { </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="keyword">String</span> System; <span class="comment">// Obscures type java.lang.System </span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[ ] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// Next line won't compile: System refers to static field </span></span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(“hello, obscure world!”); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/21/java%E5%BA%93%E8%B0%9C%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/21/java%E5%BA%93%E8%B0%9C%E9%A2%98/" class="post-title-link" itemprop="url">java库谜题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-21 21:34:54 / 修改时间：21:38:28" itemprop="dateCreated datePublished" datetime="2021-03-21T21:34:54+08:00">2021-03-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java-谜题-Java-谜题-6——库谜题"><a href="#Java-谜题-Java-谜题-6——库谜题" class="headerlink" title="Java 谜题 Java 谜题 6——库谜题"></a>Java 谜题 Java 谜题 6——库谜题</h1><h2 id="谜题-56：大问题"><a href="#谜题-56：大问题" class="headerlink" title="谜题 56：大问题"></a>谜题 56：大问题</h2><p>作为一项热身活动，我们来测试一下你对 BigInteger 的了解程度。下面这个程</p>
<p>序将打印出什么呢？ </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.math.sBigInteger; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BigProblem</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[ ] args</span>)</span> &#123; </span><br><span class="line"></span><br><span class="line"> BigInteger fiveThousand = <span class="keyword">new</span> BigInteger(<span class="string">"5000"</span>);</span><br><span class="line"></span><br><span class="line"> BigInteger fiftyThousand = <span class="keyword">new</span> BigInteger(<span class="string">"50000"</span>); </span><br><span class="line"></span><br><span class="line"> BigInteger fiveHundredThousand = <span class="keyword">new</span> BigInteger(<span class="string">"500000"</span>); </span><br><span class="line"></span><br><span class="line"> BigInteger total = BigInteger.ZERO; </span><br><span class="line"></span><br><span class="line"> total.<span class="keyword">add</span>(fiveThousand); </span><br><span class="line"></span><br><span class="line"> total.<span class="keyword">add</span>(fiftyThousand); </span><br><span class="line"></span><br><span class="line"> total.<span class="keyword">add</span>(fiveHundredThousand); </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println(total); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能会认为这个程序会打印出 555000。毕竟，它将 total 设置为用 BigInteger</p>
<p>表示的 0，然后将 5,000、50,000 和 500,000 加到了这个变量上。如果你运行该</p>
<p>程序，你就会发现它打印的不是 555000，而是 0。很明显，所有这些加法对 total</p>
<p>没有产生任何影响。 </p>
<p>对此有一个很好理由可以解释：BigInteger 实例是不可变的。String、</p>
<p>BigDecimal 以及包装器类型：Integer、Long、Short、Byte、Character、Boolean、</p>
<p>Float 和 Double 也是如此，你不能修改它们的值。我们不能修改现有实例的值，</p>
<p>对这些类型的操作将返回新的实例。起先，不可变类型看起来可能很不自然，但是它们具有很多胜过与其向对应的可变类型的优势。不可变类型更容易设计、实</p>
<p>现和使用；它们出错的可能性更小，并且更加安全[EJ Item 13]。 </p>
<p>为了在一个包含对不可变对象引用的变量上执行计算，我们需要将计算的结果赋</p>
<p>值给该变量。这样做就会产生下面的程序，它将打印出我们所期望的 555000： </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.math.BigInteger; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BigProblem</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123; </span><br><span class="line"></span><br><span class="line"> BigInteger fiveThousand = <span class="keyword">new</span> BigInteger(<span class="string">"5000"</span>); </span><br><span class="line"></span><br><span class="line"> BigInteger fiftyThousand = <span class="keyword">new</span> BigInteger(<span class="string">"50000"</span>); </span><br><span class="line"></span><br><span class="line"> BigInteger fiveHundredThousand = <span class="keyword">new</span> BigInteger(<span class="string">"500000"</span>); </span><br><span class="line"></span><br><span class="line"> BigInteger total = BigInteger.ZERO; </span><br><span class="line"></span><br><span class="line"> total = total.<span class="keyword">add</span>(fiveThousand); </span><br><span class="line"></span><br><span class="line"> total = total.<span class="keyword">add</span>(fiftyThousand); </span><br><span class="line"></span><br><span class="line"> total = total.<span class="keyword">add</span>(fiveHundredThousand); </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println(total); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本谜题的教训是：不要被误导，认为不可变类型是可变的。这是一个在刚入门的</p>
<p>Java 程序员中很常见的错误。公正地说，Java 不可变类型的某些方法名促使我</p>
<p>们走上了歧途。像 add、subtract 和 negate 之类的名字似乎是在暗示这些方法</p>
<p>将修改它们所调用的实例。也许 plus、minus 和 negation 才是更好的名字。 </p>
<p>对 API 设计来说，其教训是：在命名不可变类型的方法时，应该优选介词和名词，</p>
<p>而不是动词。介词适用于带有参数的方法，而名词适用于不带参数的方法。对语</p>
<p>言设计者而言，其教训与谜题 2 相同，那就是应该考虑对操作符重载提供有限的</p>
<p>支持，这样算数操作符就可以作用于诸如 BigInteger 这样的数值型的引用类型。</p>
<p>由此，即使是初学者也不会认为计算表达式 total + fiveThousand 将会对 total</p>
<p>的值产生任何影响。 </p>
<h2 id="谜题-57：名字里有什么？"><a href="#谜题-57：名字里有什么？" class="headerlink" title="谜题 57：名字里有什么？"></a>谜题 57：名字里有什么？</h2><p>下面的程序包含了一个简单的不可变类，它表示一个名字，其 main 方法将一个</p>
<p>名字置于一个集合中，并检查该集合是否确实包含了该名字。那么，这个程序到</p>
<p>底会打印出什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Name</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">String</span> first, last; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Name</span><span class="params">(<span class="keyword">String</span> first, <span class="keyword">String</span> last)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.first = first; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.last = last; </span><br><span class="line"></span><br><span class="line"> &#125; <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!(o instanceof Name)) </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line"> Name n = (Name)o; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> n.first.equals(first) &amp;&amp; n.last.equals(last); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> Set s = <span class="keyword">new</span> HashSet(); </span><br><span class="line"></span><br><span class="line"> s.add(<span class="keyword">new</span> Name(<span class="string">"Mickey"</span>, <span class="string">"Mouse"</span>));</span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>( </span><br><span class="line"></span><br><span class="line"> s.contains(<span class="keyword">new</span> Name(<span class="string">"Mickey"</span>, <span class="string">"Mouse"</span>))); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个 Name 实例由一个姓和一个名构成。两个 Name 实例在通过 equals 方法进行</p>
<p>计算时，如果它们的姓相等且名也相等，则这两个 Name 实例相等。姓和名是用</p>
<p>在 String 中定义的 equals 方法来比较的，两个字符串如果以相同的顺序包含相</p>
<p>同的若干个字符，那么它们就相等。因此，两个 Name 实例如果表示相同的名字，</p>
<p>那么它们就相等。例如，下面的方法调用将返回 true： </p>
<p>new Name(“Mickey”, “Mouse”).equals(new Name(“Mickey”, “Mouse”)) </p>
<p>该程序的 main 方法创建了两个 Name 实例，它们都表示 Mickey Mouse。该程序</p>
<p>将第一个实例放置到了一个散列集合中，然后检查该集合是否包含第二个实例。</p>
<p>这两个 Name 实例是相等的，因此看起来该程序似乎应该打印 true。如果你运行</p>
<p>它，几乎可以肯定它将打印 false。那么这个程序出了什么问题呢？ </p>
<p>这里的 bug 在于 Name 违反了 hashCode 约定。这看起来有点奇怪，因为 Name 连</p>
<p>hashCode 都没有，但是这确实是问题所在。Name 类覆写了 equals 方法，而</p>
<p>hashCode 约定要求相等的对象要具有相同的散列码。为了遵守这项约定，无论</p>
<p>何时，只要你覆写了 equals 方法，你就必须同时覆写 hashCode 方法[EJ Item 8]。 </p>
<p>因为 Name 类没有覆写 hashCode 方法，所以它从 Object 那里继承了其 hashCode</p>
<p>实现。这个实现返回的是基于标识的散列码。换句话说，不同的对象几乎总是产</p>
<p>生不相等的散列值，即使它们是相等的也是如此。所以说 Name 没有遵守 hashCode</p>
<p>的约定，因此包含 Name 元素的散列集合的行为是不确定的。 </p>
<p>当程序将第一个 Name 实例放置到散列集合中时，该集合就会在某个散列位置上</p>
<p>放置这个实例对应的项。该集合是基于实例的散列值来选择散列位置的，这个散</p>
<p>列值是通过实例的 hashCode 方法计算出来的。 </p>
<p>当该程序在检查第二个 Name 实例是否包含在散列集合中时，它基于第二个实例</p>
<p>的散列值来选择要搜索的散列位置。因为第二个实例有别于第一个实例，因此它</p>
<p>极有可能产生不同的散列值。如果这两个散列值映射到了不同的位置，那么contains 方法将返回 false：我们所喜爱的啮齿动物米老鼠就在这个散列集合</p>
<p>中，但是该集合却找不到他。 </p>
<p>假设两个 Name 实例映射到了相同的位置，那又会怎样呢？我们所了解的所有的</p>
<p>HashSet 实现都进行了一种优化，即每一项在存储元素本身之外，还存储了元素</p>
<p>的散列值。在搜索某个元素时，这种实现通过遍历集合中的项，去拿存储在每一</p>
<p>项中的散列值与我们想要查找的元素的散列值进行比较，从而选取适当的散列位</p>
<p>置。只有在两个元素的散列值相等的情况下，这种实现才会认为这两个元素相等。</p>
<p>这种优化是有实际意义的，因为比较散列码相对于比较元素来说，其代价要小得</p>
<p>多。 </p>
<p>对散列集合来说，这项优化并不足以使其能够搜索到正确的位置；两个 Name 实</p>
<p>例必须具有相同的散列值才能让散列集合能够将它们识别为是相等的。该程序偶</p>
<p>尔也会打印出 true，这是因为被连续创建的两个对象偶尔也会具有相同的标识</p>
<p>散列码。一个粗略的实验表明，这种偶然性出现的概率大约是 25,000,000 分之</p>
<p>一。这个实验的结果可能会因所使用的 Java 实现的不同而有所变化，但是在任</p>
<p>何我们所知的 JRE 上，你基本上是不可能看到该程序打印出 true 的。 </p>
<p>要想订正该程序，只需在 Name 类中添加一个恰当的 hashCode 方法即可。尽管任</p>
<p>何其返回值仅有姓和名来确定的方法都可以满足 hashCode 的约定，但是高质量</p>
<p>的散列函数应该尝试着对不同的名字返回不同的散列值。下面的方法就能够很好</p>
<p>地实现这一点[EJ Item 8]。只要我们把该方法添加到了程序中，那么该程序就</p>
<p>可以打印出我们所期望的 true： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> hashCode() &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">37</span> * first.hashCode() + last.hashCode(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，当你覆写 equals 方法时，一定要记着覆写 hashCode 方法。更一般地讲，</p>
<p>当你在覆写一个方法时，如果它具有一个通用的约定，那么你一定要遵守它。对</p>
<p>于大多数在Object中声明的非final的方法，都需要注意这一点[EJ Chapter 3]。</p>
<p>不采用这项建议就会导致任意的、不确定的行为。 </p>
<h2 id="谜题-58：产生它的散列码-产生它的散列码"><a href="#谜题-58：产生它的散列码-产生它的散列码" class="headerlink" title="谜题 58：产生它的散列码 产生它的散列码"></a>谜题 58：产生它的散列码 产生它的散列码</h2><p>本谜题试图从前一个谜题中吸取教训。下面的程序还是由一个 Name 类和一个</p>
<p>main 方法构成，这个 main 方法还是将一个名字放置到一个散列集合中，然后检</p>
<p>查该集合是否包含了这个名字。然而，这一次 Name 类已经覆写了 hashCode 方法。</p>
<p>那么下面的程序将打印出什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Name</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">String</span> first, last; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Name</span><span class="params">(<span class="keyword">String</span> first, <span class="keyword">String</span> last)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.first = first; <span class="keyword">this</span>.last = last; &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Name n)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> n.first.equals(first) &amp;&amp; n.last.equals(last); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">31</span> * first.hashCode() + last.hashCode();</span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[ ] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> Set s = <span class="keyword">new</span> HashSet(); </span><br><span class="line"></span><br><span class="line"> s.add(<span class="keyword">new</span> Name(<span class="string">"Donald"</span>, <span class="string">"Duck"</span>)); </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>( </span><br><span class="line"></span><br><span class="line"> s.contains(<span class="keyword">new</span> Name(<span class="string">"Donald"</span>, <span class="string">"Duck"</span>))); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与谜题 57 一样，该程序的 main 方法创建了两个 Name 实例，它们表示的是相同</p>
<p>的名字。这一次使用的名字是 Donald Duck 而不是 Mickey Mouse，但是它们不</p>
<p>应该有很大的区别。main 方法同样还是将第一个实例置于一个散列集合中，然</p>
<p>后检查该集合中是否包含了第二个实例。这一次 hashCode 方法明显是正确的，</p>
<p>因此看起来该程序应该打印 true。但是，表象再次欺骗了我们：它总是打印出</p>
<p>false。这一次又是哪里出错了呢？ </p>
<p>这个程序的缺陷与谜题 57 中的缺陷很相似，在谜题 57 中，Name 覆写了 equals</p>
<p>方法，但是没有覆写 hashCode 方法；而在本谜题中，Name 覆写了 hashCode 方</p>
<p>法，但是没有覆写 equals 方法。这并不是说 Name 没有声明一个 equals 方法，</p>
<p>它确实声明了，但是那是个错误的声明。Name 类声明了一个参数类型是 Name 而</p>
<p>不是 Object 的 equals 方法。这个类的作者可能想要覆写 equals 方法，但是却</p>
<p>错误地重载了它[JLS 8.4.8.1, 8.4.9]。 </p>
<p>HashSet 类是使用 equals(Object)方法来测试元素的相等性的；Name 类中声明</p>
<p>一个 equals(Name)方法对 HashSet 不造成任何影响。那么 Name 是从哪里得到了</p>
<p>它的 equals(Object)方法的呢？它是从 Object 哪里继承而来的。这个方法只有</p>
<p>在它的参数与在其上调用该方法的对象完全相同时才返回 true。我们的程序中</p>
<p>的 main 方法将一个 Name 实例插入到了散列集合中，并且测试另一个实例是否存</p>
<p>在于该散列集合中，由此可知该测试一定是返回 false 的。对我们而言，两个实</p>
<p>例可以代表那令人惊奇的水禽唐老鸭，但是对散列映射表而言，它们只是两个不</p>
<p>相等的对象。 </p>
<p>订正该程序只需用可以在谜题 57 中找到的覆写的 equals 方法来替换重载的</p>
<p>equals 方法即可。通过使用这个 equals 方法，该程序就可以打印出我们所期望</p>
<p>的 true： </p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="built_in">boolean</span> <span class="keyword">equals</span>(Object o) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!(o instanceof Name)) </span><br><span class="line"></span><br><span class="line"><span class="built_in"> return</span> <span class="literal">false</span>; Name n = (Name)o; </span><br><span class="line"></span><br><span class="line"><span class="built_in"> return</span> n.<span class="keyword">first</span>.<span class="keyword">equals</span>(<span class="keyword">first</span>) &amp;&amp; n.<span class="keyword">last</span>.<span class="keyword">equals</span>(<span class="keyword">last</span>); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要让该程序可以正常工作，你只需增加一个覆写的 equals 方法即可。你不必剔</p>
<p>除那个重载的版本，但是你最好是删掉它。重载为错误和混乱提供了机会[EJ </p>
<p>Item 26]。如果兼容性要求强制你必须保留一个自身类型的 equals 方法，那么</p>
<p>你应该用自身类型的重载去实现 Object 的重载，以此来确保它们具有相同的行</p>
<p>为： </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">boolean</span> equals(<span class="keyword">Object</span> o) &#123; <span class="keyword">return</span> o instanceof <span class="type">Name</span> &amp;&amp; equals((<span class="type">Name</span>) </span><br><span class="line"></span><br><span class="line">o); &#125;</span><br></pre></td></tr></table></figure>

<p>本谜题的教训是：当你想要进行覆写时，千万不要进行重载。为了避免无意识地</p>
<p>重载，你应该机械地对你想要覆写的每一个超类方法都拷贝其声明，或者更好的</p>
<p>方式是让你的 IDE 帮你去做这些事。这样做除了可以保护你免受无意识的重载之</p>
<p>害，而且还可以保护你免受拼错方法名之害。如果你使用的 5.0 或者更新的版本，</p>
<p>那么对于那些意在覆写超类方法的方法，你可以将@Override 注释应用于每一个</p>
<p>这样的方法的声明上： </p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Override <span class="keyword">public</span> <span class="built_in">Boolean</span> <span class="keyword">equals</span>(Object o) &#123; <span class="params">...</span> &#125;</span><br></pre></td></tr></table></figure>

<p>在使用这个注释时，除非被注释的方法确实覆写了一个超类方法，否则它将不能</p>
<p>编译。对语言设计者来说，值得去考虑在每一个覆写超类方法的方法声明上都添</p>
<p>加一个强制性的修饰符。 </p>
<h2 id="谜题-59：什么是差？"><a href="#谜题-59：什么是差？" class="headerlink" title="谜题 59：什么是差？"></a>谜题 59：什么是差？</h2><p>下面的程序在计算一个 int 数组中的元素两两之间的差，将这些差置于一个集合</p>
<p>中，然后打印该集合的尺寸大小。那么，这个程序将打印出什么呢？ </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Differences</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> static <span class="built_in">void</span> main(String[ ] args) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="built_in">int</span> vals[ ] = &#123; <span class="number">789</span>, <span class="number">678</span>, <span class="number">567</span>, <span class="number">456</span>, <span class="number">345</span>, <span class="number">234</span>, <span class="number">123</span>, <span class="number">012</span> &#125;; </span><br><span class="line"></span><br><span class="line"> Set diffs = new HashSet(); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; vals.length; i++) </span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="built_in">int</span> j = i; j &lt; vals.length; j++) </span><br><span class="line"></span><br><span class="line"> diffs.add(vals[i] - vals[j]); </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println(diffs.size()); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外层循环迭代数组中的每一个元素，而内层循环从外层循环当前迭代到的元素开</p>
<p>始迭代到数组中的最后一个元素。因此，这个嵌套的循环将遍历数组中每一种可能的两两组合。（元素可以与其自身组成一对。）这个嵌套循环中的每一次迭代</p>
<p>都计算了一对元素之间的差（总是正的），并将这个差存储到了集合中，集合是</p>
<p>可以消除重复元素的。因此，本谜题就带来了一个问题，在由 vals 数组中的元</p>
<p>素结成的对中，有多少唯一的正的差存在呢？ </p>
<p>当你仔细观察程序中的数组时，会发现其构成模式非常明显：连续两个元素之间</p>
<p>的差总是 111。因此，两个元素之间的差是它们在数组之间的偏移量之差的函数。</p>
<p>如果两个元素是相同的，那么它们的差就是 0；如果两个元素是相邻的，那么它</p>
<p>们的差就是 111；如果两个元素被另一个元素分割开了，那么它们的差就是 222；</p>
<p>以此类推。看起来不同的差的数量与元素间不同的距离的数量是相等的，也就是</p>
<p>等于数组的尺寸，即 8。如果你运行该程序，就会发现它打印的是 14。怎么回事</p>
<p>呢？ </p>
<p>上面的分析有一个小的漏洞。要想了解清楚这个缺陷，我们可以通过将 println</p>
<p>语句中的.size()这几个字符移除掉，来打印出集合中的内容。这么做会产生下</p>
<p>面的输出： </p>
<p>[111,222,446,557,668,113,335,444,779,224,0,333,555,666]</p>
<p>这些数字并非都是 111 的倍数。在 vals 数组中肯定有两个毗邻的元素的差是</p>
<p>113。如果你观察该数组的声明，不可能很清楚地发现原因所在： </p>
<p>int vals[ ] = { 789, 678, 567, 456, 345, 234, 123, 012 }; </p>
<p>但是如果你打印数组的内容，你就会看见下面的内容： </p>
<p>[789,678,567,456,345,234,123,10]</p>
<p>为什么数组中的最后一个元素是 10 而不是 12 呢？因为以 0 开头的整数类型字面</p>
<p>常量将被解释成为八进制数值[JLS 3.10.1]。这个隐晦的结构是从 C 编程语言那</p>
<p>里遗留下来东西，C 语言产生于 1970 年代，那时八进制比现在要通用得多。 </p>
<p>一旦你知道了 012 == 10，就会很清楚为什么该程序打印出了 14：有 6 个不涉及</p>
<p>最后一个元素的唯一的非 0 差，有 7 个涉及最后一个元素的非 0 差，还有 0，加</p>
<p>在一起正好是 14 个唯一的差。订正该程序的方法更加明显：将八进制整型字面</p>
<p>常量 012 替换为十进制整型字面常量 12。如果你这么做了，该程序将打印出我</p>
<p>们所期望的 8。 </p>
<p>本谜题的教训很简单：千万不要在一个整型字面常量的前面加上一个 0；这会使</p>
<p>它变成一个八进制字面常量。有意识地使用八进制整型字面常量的情况相当少</p>
<p>见，你应该对所有的这种特殊用法增加注释。对语言设计者来说，在决定应该包</p>
<p>含什么特性时，应该考虑到其限制条件。当有所迟疑时，应该将它剔除在外。 </p>
<h2 id="谜题-60：一行的方法-现在该轮到你写一些代码了。下面的谜题每一个都可以用一个方法来解决，这些"><a href="#谜题-60：一行的方法-现在该轮到你写一些代码了。下面的谜题每一个都可以用一个方法来解决，这些" class="headerlink" title="谜题 60：一行的方法 现在该轮到你写一些代码了。下面的谜题每一个都可以用一个方法来解决，这些"></a>谜题 60：一行的方法 现在该轮到你写一些代码了。下面的谜题每一个都可以用一个方法来解决，这些</h2><p>方法的方法体都只包含一行代码。各就各位，预备，编码！ </p>
<p>• A．编写一个方法，它接受一个包含元素的 List，并返回一个新的 List，</p>
<p>它以相同的顺序包含相同的元素，只不过它把第二次以及后续出现的重复</p>
<p>元素都剔除了。例如，如果你传递了一个包</p>
<p>含”spam”,”sausage”,”spam”,”spam”,”bacon”,”spam”,”t</p>
<p>omato”和”spam”的列表，那么你将得到一个包</p>
<p>含”spam”,”sausage”,”bacon”,”tomato”的新列表。 </p>
<p>• B．编写一个方法，它接受一个由 0 个或多个由逗号分隔的标志所组成的</p>
<p>字符串，并返回一个表示这些标志的字符串数组，数组中的元素的顺序与</p>
<p>这些标志在输入字符串中出现的顺序相同。每一个逗号后面都可能会跟随</p>
<p>0 个或多个空格字符，这个方法忽略它们。例如，如果你传递的字符串</p>
<p>是”fear, surprise, ruthless efficiency, an almost fanatical </p>
<p>devotion to the Pope, nice red uniforms”，那么你得到的将是一个</p>
<p>包含 5 个元素的字符串数组，这些元素</p>
<p>是”fear”，”surprise”，”ruthless efficiency”，”an almost </p>
<p>fanatical devotion to the Pope” 和 “nice red uniform”。 </p>
<p>• C．假设你有一个多维数组，出于调试的目的，你想打印它。你不知道这</p>
<p>个数组有多少级，以及在数组的每一级中所存储的对象的类型。编写一个</p>
<p>方法，它可以向你显示出在每一级上的所有元素。 </p>
<p>• D．编写一个方法，它接受两个 int 数值，并在第一个数值与第二个数值</p>
<p>以二进制补码形式进行比较，具有更多的位被置位时，返回 true。 </p>
<p>A．众所周知，你可以通过把集合（collection）中的元素置于一个 Set 中将集</p>
<p>合中的所有重复元素都消除掉。在本谜题中，你还被要求要保持最初的集合中的</p>
<p>元素顺序。幸运的是，有一种 Set 的实现可以维护其元素被插入的顺序，它提供</p>
<p>的导入性能接近 HashMap。它就是 LinkedHashSet，它是在 1.4 版本的 JDK 中被</p>
<p>添加到 Java 平台中的。在内部，它是用一个链接列表来处理的，从而被实现为</p>
<p>一个散列表。它还有一个映射表版本可供你使用，以定制缓存。一旦你了解了</p>
<p>LinkedHashSet，本谜题就很容易解决了。剩下唯一的关键就是你被要求要返回</p>
<p>一个 List，因此你必须用 LinkedHashSet 的内容来初始化一个 List。把它们放</p>
<p>到一块，就形成了下面的解决方案： </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="built_in">List</span>&lt;E&gt; withoutDuplicates(<span class="built_in">List</span>&lt;E&gt; original) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;E&gt;(<span class="keyword">new</span> LinkedHashSet&lt;E&gt;(original)); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B．在将字符串解析成标志时，许多程序员都立刻想到了使用 StringTokenizer。</p>
<p>这是最不幸的事情，自 1.4 版本开始，由于正则表达式被添加到了 Java 平台中</p>
<p>（java.util.regex），StringTokenizer 开始变得过时了。如果你试图通过</p>
<p>StringTokenizer 来解决本谜题，那么你很快就会意识到它不是非常适合。通过</p>
<p>使用正则表达式，它就是小菜一碟。为了在一行代码中解决本谜题，我们要使用</p>
<p>很方便的方法 String.split，它接受一个描述标志分界符的正则表达式作为参</p>
<p>数。如果你以前从来没有使用过正则表达式，那么它们看起来会显得有一点神秘，</p>
<p>但是它们惊人地强大，值得我们好好学习一下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">String</span>[ ] parse(<span class="keyword">String</span> <span class="built_in">string</span>) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">string</span>.split(<span class="string">",\\S*"</span>); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C．这是一个讲究技巧的问题。你甚至不必去编写一个方法。这个方法在 5.0 或</p>
<p>之后的版本中已经提供了，它就是 Arrays.deepToString。如果你传递给它一个</p>
<p>对象引用的数组，它将返回一个精密的字符串表示。它可以处理嵌套数组，甚至</p>
<p>可以处理循环引用，即一个数组元素直接或间接地引用了其嵌套外层的数组。事</p>
<p>实上，5.0 版本中的 Arrays 类提供了一整套的 toString、equals 和 hashCode</p>
<p>方法，使你能够打印、比较或散列任何原始类型数组或对象引用数组的内容。 </p>
<p>D．为了在一行代码中解决该谜题，你需要了解在 5.0 版本中添加到 Java 平台中</p>
<p>的一整套位操作方法。整数类型的包装器类（Integer、Long、Short、Byte 和</p>
<p>Char）现在支持通用的位处理操作，包括 highestOneBit、lowestOneBit、</p>
<p>numberOfLeadingZeros、numberOfTrailingZeros、bitCount、rotateLeft、</p>
<p>rotateRight、reverse、signum 和 reverseBytes。在本例中，你需要的是</p>
<p>Integer.bitCount，它返回的是一个 int 数值中被置位的位数： </p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static Boolean has<span class="constructor">MoreBitsSet(<span class="params">int</span> <span class="params">i</span>, <span class="params">int</span> <span class="params">j</span>)</span> &#123; </span><br><span class="line"></span><br><span class="line"> return (<span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>bit<span class="constructor">Count(<span class="params">i</span>)</span> &gt; <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>bit<span class="constructor">Count(<span class="params">j</span>)</span>); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，Java 平台的每一个主版本都在其类库中隐藏了一些宝藏。本谜题的所有 4</p>
<p>个部分都依赖于这样的宝藏。每当该平台发布一个新版本时，你都应该研究就一</p>
<p>下新特性和提高（new features and enhancements）页面，这样你就不会遗漏</p>
<p>掉新版本提供的任何惊喜[Features-1.4, Features-5.0]。了解类库中有些什么</p>
<p>可以节省你大量的时间和精力，并且可以提高你的程序的速度和质量。 </p>
<h2 id="谜题-61：日期游戏"><a href="#谜题-61：日期游戏" class="headerlink" title="谜题 61：日期游戏"></a>谜题 61：日期游戏</h2><p>下面的程序演练了 Date 和 Calendar 类的某些基本特性，它会打印出什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatingGame</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[ ] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> Calendar cal = Calendar.getInstance(); </span><br><span class="line"></span><br><span class="line"> cal.<span class="built_in">set</span>(<span class="number">1999</span>, <span class="number">12</span>, <span class="number">31</span>); <span class="comment">// Year, Month, Day</span></span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">print</span>(cal.<span class="built_in">get</span>(Calendar.YEAR) + <span class="string">" "</span>); </span><br><span class="line"></span><br><span class="line"> Date d = cal.getTime(); </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(d.getDay()); </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>} 该程序创建了一个 Calendar 实例，它应该表示的是 1999 年的除夕夜，然后该程</p>
<p>序打印年份和日。看起来该程序应该打印 1999 31，但是它没有；它打印的是 2000 </p>
<p>1。难道这是致命的 Y2K(千年虫)问题吗？ </p>
<p>不，事情比我们想象的要糟糕得多：这是致命的 Date/Calendar 问题。在 Java</p>
<p>平台首次发布时，它唯一支持日历计算类的就是 Date 类。这个类在能力方面是</p>
<p>受限的，特别是当需要支持国际化时，它就暴露出了一个基本的设计缺陷：Date</p>
<p>实例是易变的。在 1.1 版中，Calendar 类被添加到了 Java 平台中，以矫正 Date</p>
<p>的缺点，由此大部分的 Date 方法就都被弃用了。遗憾的是，这么做只能使情况</p>
<p>更糟。我们的程序说明 Date 和 Calendar API 有许多问题。 </p>
<p>该程序的第一个 bug 就位于方法调用 cal.set(1999,12,31)中。当月份以数字来</p>
<p>表示时，习惯上我们将第一个月被赋值为 1。遗憾的是，Date 将一月表示为 0，</p>
<p>而 Calendar 延续了这个错误。因此，这个方法调用将日历设置到了 1999 年第</p>
<p>13 个月的第 31 天。但是标准的（西历）日历只有 12 个月，该方法调用肯定应</p>
<p>该抛出一个 IllegalArgumentException 异常，对吗？它是应该这么做，但是它</p>
<p>并没有这么做。Calendar 类直接将其替换为下一年，在本例中即 2000 年的第一</p>
<p>个月。这也就解释了我们的程序为什么打印出的第一个数字是 2000。 </p>
<p>有两种方法可以订正这个问题。你可以将 cal.set 调用的第二个参数由 12 改为</p>
<p>11，但是这么做容易引起混淆，因为数字 11 会让读者误以为是 11 月。更好的方</p>
<p>式是使用 Calendar 专为此目的而定义的常量，即 Calendar.DECEMBER。 </p>
<p>该程序打印出的第二个数字又是怎么回事呢？cal.set 调用很明显是要把日历</p>
<p>设置到这个月的第 31 天，Date 实例 d 表示的是与 Calendar 相同的时间点，因</p>
<p>此它的 getDay 方法应该返回 31，但是程序打印的却是 1，这是怎么搞得呢？ </p>
<p>为了找出原因，你必须先阅读一下文档，它叙述道 Date.getDay 返回的是 Date</p>
<p>实例所表示的星期日期，而不是月份日期。这个返回值是基于 0 的，从星期天开</p>
<p>始计算。因此程序所打印的 1 表示 2000 年 1 月 31 日是星期一。请注意，相应的</p>
<p>Calendar 方法 get(Calendar.DAY_OF_WEEK) 不知为什么返回的是基于 1 的星期</p>
<p>日期值，而不是像 Date 的对应方法那样返回基于 0 的星期日期值。 </p>
<p>有两种方法可以订正这个问题。你可以调用 Date.date 这一名字极易让人混淆的</p>
<p>方法，它返回的是月份日期。然而，与大多数 Date 方法一样，它已经被弃用了，</p>
<p>因此你最好是将 Date 彻底抛弃，直接调用 Calendar 的</p>
<p>get(Calendar.DAY_OF_MONTH)方法。用这两种方法，该程序都可以打印出我们想</p>
<p>要的 1999 31： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatingGame</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> Calendar cal = Calendar.getInstance(); </span><br><span class="line"></span><br><span class="line"> cal.<span class="built_in">set</span>(<span class="number">1999</span>, Calendar.DECEMBER, <span class="number">31</span>); </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">print</span>(cal.<span class="built_in">get</span>(Calendar.YEAR) + <span class="string">" "</span>); </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(cal.<span class="built_in">get</span>(Calendar.DAY_OF_MONTH)); &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本谜题只是掀开了 Calendar 和 Date 缺陷的冰山一角。这些 API 简直就是雷区。</p>
<p>Calendar 其他的严重问题包括弱类型（几乎每样事物都是一个 int）、过于复杂</p>
<p>的状态空间、拙劣的结构、不一致的命名以及不一致的雨衣等。在使用 Calendar</p>
<p>和 Date 的时候一定要当心，千万要记着查阅 API 文档。 </p>
<p>对 API 设计者来说，其教训是：如果你不能在第一次设计时就使它正确，那么至</p>
<p>少应该在第二次设计时应该使它正确，绝对不能留到第三次设计时去处理。如果</p>
<p>你对某个 API 的首次尝试出现了严重问题，那么你的客户可能会原谅你，并且会</p>
<p>再给你一次机会。如果你第二次尝试又有问题，你可能会永远坚持这些错误了。 </p>
<p>谜题 62：名字游戏 </p>
<p>下面的程序将两个映射关系放置到了一个映射表中，然后打印它们的尺寸。那么，</p>
<p>它会打印出什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameGame</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span> args[ ])</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; m = </span><br><span class="line"></span><br><span class="line"> <span class="keyword">new</span> IdentityHashMap&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;(); </span><br><span class="line"></span><br><span class="line"> m.<span class="built_in">put</span>(<span class="string">"Mickey"</span>, <span class="string">"Mouse"</span>); </span><br><span class="line"></span><br><span class="line"> m.<span class="built_in">put</span>(<span class="string">"Mickey"</span>, <span class="string">"Mantle"</span>);</span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(m.<span class="built_in">size</span>()); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对该程序的一种幼稚的分析认为，它应该打印 1。该程序虽然将两个映射关系放</p>
<p>置到了映射表中，但是它们具有相同的键（Mickey）。这是一个映射表，不是一</p>
<p>个多重映射表，所以棒球传奇人物（Mickey Mantle）应该覆盖了啮齿类动画明</p>
<p>星（Mickey Mouse），从而只留下一个映射关系在映射表中。 </p>
<p>更透彻一些的分析会对这个预测产生质疑。IdentityHashMap 的文档中叙述道：</p>
<p>“这个类用一个散列表实现了 Map 接口，它在比较键时，使用的是引用等价性而</p>
<p>不是值等价性”[Java-API]。换句话说，如果第二次出现的字符串字面常量</p>
<p>“Mickey”被计算出来是与第一次出现的“Mickey”字符串不同的 String 实例</p>
<p>的话，那么该程序应该打印 2 而不是 1。如此说来，该程序到底是打印 1，还是</p>
<p>打印 2，抑或是其行为会根据不同的实现而有所变化？ </p>
<p>如果你试着运行该程序，你就会发现，尽管我们那个幼稚的分析是有缺陷的，但</p>
<p>是该程序正如这种分析所指出的一样，打印出来的是 1。这是为什么呢？语言规</p>
<p>范保证了字符串是内存限定的，换句话说，相等的字符串常量同时也是相同的</p>
<p>[JLS 15.28]。这可以确保在我们的程序中第二次出现的字符串字面常量“Mickey”引用到了与第一次相同的 String 实例上，因此尽管我们使用了一个</p>
<p>IdentityHashMap 来代替诸如 HashMap 这样的通用目的的 Map 实现，但是对程序</p>
<p>的行为却不会产生任何影响。我们那个幼稚的分析忽略了两个细节，但是这些细</p>
<p>节造成的影响却彼此有效地抵消了。 </p>
<p>本谜题的一个重要教训是：不要使用 IdentityHashMap，除非你需要其基于标识</p>
<p>的语义；它不是一个通用目的的 Map 实现。这些语义对于实现保持拓扑结构的对</p>
<p>象图转换（topology-preserving object graph transformations）非常有用，</p>
<p>例如序列化和深层复制。我们得到的次要教训是字符串常量是内存限定的。正如</p>
<p>在谜题 13 中所述，在任何时候，程序都应该尽量不依赖于这种行为去保证它们</p>
<p>的操作正确。 </p>
<h2 id="谜题-63：更多同样的问题-更多同样的问题"><a href="#谜题-63：更多同样的问题-更多同样的问题" class="headerlink" title="谜题 63：更多同样的问题 更多同样的问题"></a>谜题 63：更多同样的问题 更多同样的问题</h2><p>下面的程序除了是面向对象的这一点之外，与前一个非常相似。因为从前一个程</p>
<p>序中已经吸取了教训，这个程序使用了一个通用目的的 Map 实现，即一个</p>
<p>HashMap，来替代前一个程序的 IdentityHashMap。那么，这个程序会打印出什</p>
<p>么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoreNames</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Map&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt; m = <span class="keyword">new</span> HashMap&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt;(); </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MoreNames</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> m.<span class="built_in">put</span>(<span class="string">"Mickey"</span>, <span class="string">"Mouse"</span>); </span><br><span class="line"></span><br><span class="line"> m.<span class="built_in">put</span>(<span class="string">"Mickey"</span>, <span class="string">"Mantle"</span>);</span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> m.<span class="built_in">size</span>(); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span> args[ ])</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> MoreNames moreNames = <span class="keyword">new</span> MoreNames(); </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(moreNames.<span class="built_in">size</span>()); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序看起来很直观，其 main 方法通过调用无参数的构造器创建了一个</p>
<p>MoreNames 实例。这个 MoreNames 实例包含一个私有的 Map 域（m），它被初始</p>
<p>化成一个空的 HashMap。该无参数的构造器似乎将两个映射关系放置到了映射表</p>
<p>m 中，这两个映射关系都具有相同的键（Mickey）。我们从前一个谜题已知，棒</p>
<p>球手（Mickey Mantle）应该覆盖啮齿明星（Mickey Mouse），从而只留下一个</p>
<p>映射关系。main 方法之后在 MoreNames 实例上调用了 size 方法，它会调用映射</p>
<p>表 m 上的 size 方法，并返回结果，我们假设其为 1。这种分析还剩下一个问题：</p>
<p>该程序打印的是 0 而不是 1。这种分析出了什么错呢？ 问题在于 MoreNames 没有任何程序员声明的构造器。它拥有的只是一个返回值为</p>
<p>void 的实例方法，即 MoreNames，作者可能是想让它作为构造器的。遗憾的是，</p>
<p>返回类型（void）的出现将想要的构造器声明变成了一个方法声明，而且该方法</p>
<p>永远都不会被调用。因为 MoreNames 没有任何程序员声明的构造器，所以编译器</p>
<p>会帮助（真的是在帮忙吗？）生成一个公共的无参数构造器，它除了初始化它所</p>
<p>创建的域实例之外，不做任何事情。就像前面提到的，m 被初始化成了一个空的</p>
<p>HashMap。当在这个 HashMap 上调用 size 方法时，它将返回 0，这正是该程序打</p>
<p>印出来的内容。 </p>
<p>订正该程序很简单，只需将 void 返回类型从 MoreNames 声明中移除即可，这将</p>
<p>使它从一个实例方法声明变成一个构造器声明。通过这种修改，该程序就可以打</p>
<p>印出我们所期望的 1。 </p>
<p>本谜题的教训是：不要因为偶然地添加了一个返回类型，而将一个构造器声明变</p>
<p>成了一个方法声明。尽管一个方法的名字与声明它的类的名字相同是合法的，但</p>
<p>是你千万不要这么做。更一般地讲，要遵守标准的命名习惯，它强制要求方法名</p>
<p>必须以小写字母开头，而类名应该以大写字母开头。 </p>
<p>对语言设计者来说，在没有任何程序员声明的构造器的情况下，自动生成一个缺</p>
<p>省的构造器这种做法并非是一个很好的主意。如果确实生成了这样的构造器，也</p>
<p>许应该让它们是私有的。有好几种其他的方法可以消除这个陷阱。一种方法是禁</p>
<p>止方法名与类名相同，就像 C#所作的那样，另一种是彻底消灭所有的构造器，</p>
<p>就像 Smalltalk 所作的那样。 </p>
<h2 id="谜题-64：按余数编组"><a href="#谜题-64：按余数编组" class="headerlink" title="谜题 64：按余数编组"></a>谜题 64：按余数编组</h2><p>下面的程序将生成整数对 3 取余的柱状图，那么，它将打印出什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mod</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[ ] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">int</span> MODULUS = <span class="number">3</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span>[] histogram = <span class="keyword">new</span> <span class="keyword">int</span>[MODULUS]; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// Iterate over all ints (Idiom from Puzzle 26) </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> i = Integer.MIN_VALUE; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line"> histogram[Math.<span class="built_in">abs</span>(i) % MODULUS]++; </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">while</span> (i++ != Integer.MAX_VALUE); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; MODULUS; j++) </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(histogram[j] + <span class="string">" "</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序首先初始化 int 数组 histogram，其每一个位置都为对 3 取余的一个数值</p>
<p>而准备（0、1 和 2），所有这三个位置都被初始化为 0。然后，该程序在所有 232</p>
<p>个 int 数值上遍历变量 i，使用的是在谜题 26 中介绍的惯用法。因为整数取余操作（%）在第一个操作数是负数时，可以返回一个负值，就像在谜题 1 中所描</p>
<p>述的那样，所以该程序在计算 i 被 3 整除的余数之前，先取 i 的绝对值。然后用</p>
<p>这个余数来递增数组位置的索引。在循环完成之后，该程序将打印 histogram</p>
<p>数组中的内容，它的元素表示对 3 取余得到 0、1 和 2 的 int 数值的个数。 </p>
<p>该程序所打印的三个数字应该彼此大致相等，它们加起来应该等于 232。如果你</p>
<p>想知道怎样计算出它们的精确值，那么你需要有一点数学气质，并仔细阅读下面</p>
<p>两段话。否则，你可以跳过这两段话。 </p>
<p>该程序打印的三个数字不可能精确地相等，因为它们必须加起来等于 232，这个</p>
<p>数字不能被 3 除尽。如果你仔细观察 2 的连续幂级数对 3 取余的值，就会发现，</p>
<p>它们在 1 和 2 之间交替变化：20 对 3 取余是 1，21 对 3 取余是 2，22 对 3 取余</p>
<p>是 1，23 对 3 取余是 2，以此类推。每一个 2 的偶次幂对 3 取余的值都是 1，每</p>
<p>一个 2 的奇次幂对 3 取余的值都是 2。因为 232 对 3 取余是 1，所以该程序所打</p>
<p>印的三个数字中有一个将比另外两个大 1，但是它是哪一个呢？ </p>
<p>该循环依次递增三个数组元素的数值，因此该循环最后递增的那个数值必然是最</p>
<p>大的数值，它就是表示 Integer.MAX_VALUE 或(232-1)对 3 取余的数值。因为 231</p>
<p>是 2 的奇次幂，所以它对 3 取余应该得到 2，因此(232-1)对 3 取余将得到 1。</p>
<p>该程序打印的三个数字中的第二个表示的就是对 3 取余得到 1 的 int 数值的个</p>
<p>数，因此，我们期望这个值比第一个和最后一个数值大 1。 </p>
<p>由此，该程序应该在运行了相当长的时间之后，打印(232/3)的较小值 (232/3)</p>
<p>的较大值 (232/3)的较小值，即 1431655765 1431655766 1431655765。但是它</p>
<p>真的是这么做的吗？不，它几乎立刻就抛出了下面的异常： </p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Exception</span> <span class="keyword">in</span> thread <span class="string">"main"</span> ArrayIndexOutOfBoundsException: -<span class="number">2</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">at</span> <span class="keyword">Mod</span>.main(<span class="keyword">Mod</span>.java:<span class="number">9</span>)</span><br></pre></td></tr></table></figure>

<p>问题出在哪了呢？ </p>
<p>问题在于该程序对 Math.abs 方法的使用上，它会导致错误的对 3 取余的数值。</p>
<p>考虑一下当 i 为 -2 时所发生的事情，该程序计算 Math.abs(-2) % 3 的数值，</p>
<p>得到 2，但是-2 对 3 取余应该得到 1。这可以解释为什么产生了不正确的统计结</p>
<p>果，但是还有一个问题留待解决，为什么程序抛出了</p>
<p>ArrayIndexOutOfBoundsException 异常呢？这个异常表明该程序使用了一个负</p>
<p>的数组索引，但是这肯定是不可能的：数组索引是通过的接受 i 的绝对值并计算</p>
<p>这个绝对值被 3 整除时的余数而计算出来的。在计算一个非负的 int 数值整除一</p>
<p>个正的 int 数值的余数时，可以保证将产生一个非负的结果[JLS 15.17.3]。我</p>
<p>们又要问了，这里又出了什么问题呢？ </p>
<p>要回答这个问题，我们必须要去看看 Math.abs 的文档。这个方法的名字有一点</p>
<p>带有欺骗性，它几乎总是返回它的参数的绝对值，但是在有一种情况下，它做不</p>
<p>到这一点。文档中叙述道：“如果其参数等于 Integer.MIN_VALUE，那么产生的</p>
<p>结果与该参数相同，它是一个负数。”通过对这条知识的掌握，就可以很清楚地知道为什么该程序立即抛出了 ArrayIndexOutOfBoundsException 异常。循环索</p>
<p>引 i 的初始值是 Integer.MIN_VALUE，由 Math.abs(Integer.MIN_VALUE) % 3 所</p>
<p>产生的数组索引等于 Integer.MIN_VALUE % 3，即 -2。 </p>
<p>为了订正这个程序，我们必须用一个真正的取余操作来替代伪取余计算</p>
<p>(Math.abs(i) % MODULUS)。如果我们将这个表达式替换为对下面这个方法的调</p>
<p>用，那么该程序就可以产生我们做期望的输出 1431655765 1431655766</p>
<p>1431655765： </p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">static</span> <span class="built_in">int</span> <span class="keyword">mod</span>(<span class="built_in">int</span> i, <span class="built_in">int</span> modulus) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="built_in">int</span> <span class="literal">result</span> = i % modulus; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">result</span> &lt; <span class="number">0</span> ? <span class="literal">result</span> + modulus : <span class="literal">result</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本谜题的教训是：Math.abs 不能保证一定会返回非负的结果。如果它的参数是</p>
<p>Integer.MIN_VALUE，或者对于 long 版本的实现传递的是 Long.MIN_VALUE，那</p>
<p>么它将返回它的参数。这个方法在一般情况下是不会这么做的，上述这种行为的</p>
<p>根源在于 2 的补码算数具有不对称性，这在谜题 33 中已经很详细的讨论过了。</p>
<p>简单地讲，没有任何 int 数值可以表示 Integer.MIN_VALUE 的负值，也没有任何</p>
<p>long 数值可以表示 Long.MIN_VALUE 的负值。对类库的设计者来说，也许在将</p>
<p>Integer.MIN_VALUE 和 Long.MIN_VALUE 传递给 Math.abs 时，抛出</p>
<p>IllegalArgumentException 会显得更合理。然而，有人可能会争辩道，该方法</p>
<p>的实际行为应该与 Java 内置的整数算术操作相一致，它们在溢出时并不会抛出</p>
<p>异常。 </p>
<h2 id="谜题-65：一种疑似排序的惊人传奇-一种疑似排序的惊人传奇"><a href="#谜题-65：一种疑似排序的惊人传奇-一种疑似排序的惊人传奇" class="headerlink" title="谜题 65：一种疑似排序的惊人传奇 一种疑似排序的惊人传奇"></a>谜题 65：一种疑似排序的惊人传奇 一种疑似排序的惊人传奇</h2><p>下面的程序使用定制的比较器，对一个由随机挑选的 Integer 实例组成的数组进</p>
<p>行排序，然后打印了一个描述了数组顺序的单词。回忆一下，Comparator 接口</p>
<p>只有一个方法，即 compare，它在第一个参数小于第二个参数时返回一个负数，</p>
<p>在两个参数相等时返回 0，在第一个参数大于第二个参数时返回一个整数。这个</p>
<p>程序是展示 5.0 版特性的一个样例程序。它使用了自动包装和解包、泛型和枚举</p>
<p>类型。那么，它会打印出什么呢？ </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> SuspiciousSort &#123; </span><br><span class="line"></span><br><span class="line"> <span class="built_in">public</span> static <span class="type">void</span> main(String[ ] args) &#123; </span><br><span class="line"></span><br><span class="line"> Random rnd = <span class="built_in">new</span> Random(); </span><br><span class="line"></span><br><span class="line"> <span class="type">Integer</span>[ ] arr = <span class="built_in">new</span> <span class="type">Integer</span>[<span class="number">100</span>]; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) </span><br><span class="line"></span><br><span class="line"> arr[i] = rnd.nextInt(); </span><br><span class="line"></span><br><span class="line"> Comparator&lt;<span class="type">Integer</span>&gt; cmp = <span class="built_in">new</span> Comparator&lt;<span class="type">Integer</span>&gt;() &#123; </span><br><span class="line"></span><br><span class="line"> <span class="built_in">public</span> <span class="type">int</span> compare(<span class="type">Integer</span> i1, <span class="type">Integer</span> i2) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> i2 - i1; </span><br><span class="line"></span><br><span class="line"> &#125; &#125;; </span><br><span class="line"></span><br><span class="line"> Arrays.sort(arr, cmp); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">order</span>(arr)); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> enum <span class="keyword">Order</span> &#123; ASCENDING, DESCENDING, <span class="keyword">CONSTANT</span>, UNORDERED &#125;; </span><br><span class="line"></span><br><span class="line"> static <span class="keyword">Order</span> <span class="keyword">order</span>(<span class="type">Integer</span>[ ] a) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="type">boolean</span> ascending = <span class="keyword">false</span>; </span><br><span class="line"></span><br><span class="line"> <span class="type">boolean</span> descending = <span class="keyword">false</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123; </span><br><span class="line"></span><br><span class="line"> ascending |= a[i] &gt; a[i<span class="number">-1</span>]; </span><br><span class="line"></span><br><span class="line"> descending |= a[i] &lt; a[i<span class="number">-1</span>]; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (ascending &amp;&amp; !descending) </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">Order</span>.ASCENDING; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (descending &amp;&amp; !ascending) </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">Order</span>.DESCENDING; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!ascending) </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">Order</span>.<span class="keyword">CONSTANT</span>; // <span class="keyword">All</span> elements equal </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">Order</span>.UNORDERED; // <span class="keyword">Array</span> <span class="keyword">is</span> <span class="keyword">not</span> sorted</span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序的 main 方法创建了一个 Integer 实例的数组，并用随机数对其进行了初</p>
<p>始化，然后用比较器 cmp 对该数组进行排序。这个比较器的 compare 方法将返回</p>
<p>它的第二个参数减去第一个参数的值，如果第二个参数表示的是比第一个参数大</p>
<p>的数值，其返回值就是正的；如果这两个参数相等，其返回值为 0；如果第二个</p>
<p>参数表示的是比第一个参数小的数值，其返回值就是负的。这种行为正好与</p>
<p>compare 方法通常的做法相反，因此，该比较器应该施加的是降序排列。 </p>
<p>在对数组排序之后，main 方法将该数组传递给了静态方法 order，然后打印由这</p>
<p>个方法返回的结果。该方法在数组中所有的元素都表示相同的数值时，返回</p>
<p>CONSTANT；在数组中每一对毗邻的元素中第二个元素都大于等于第一个元素时，</p>
<p>返回 ASCENDING；在数组中每一对毗邻的元素中第二个元素都小于等于第一个元</p>
<p>素时，返回 DESCENDING；在这些条件都不满足时，返回 UNORDERED。尽管理论上</p>
<p>说，数组中的 100 个随机数有可能彼此都相等，但是这种奇特现象发生的非常小：</p>
<p>232×99 分之一，即大约 5×10953 分之一。因此，该程序看起来应该打印</p>
<p>DESCENDING。如果你运行该程序，几乎可以肯定你将看到它打印的是 UNORDERED。</p>
<p>为什么它会产生如此的行为呢？ </p>
<p>order 方法很直观，它并不会说谎。Arrays.sort 方法已经存在许多年了，它工</p>
<p>作得非常好。现在只有一个地方能够发现 bug 了：比较器。乍一看，这个比较器</p>
<p>似乎不可能出错。毕竟，它使用的是标准的惯用法：如果你有两个数字，你想得</p>
<p>到一个数值，其符号表示它们的顺序，那么你可以计算它们的差。这个惯用法至少从 1970 年代早期就一直存在了，它在早期的 UNIX 里面被广泛地应用。遗憾的</p>
<p>是，这种惯用法从来都没有正确地工作过。本谜题也许应该称为“白痴一般的惯</p>
<p>用法的案例”。这种惯用法的问题在于定长的整数没有大到可以保存任意两个同</p>
<p>等长度的整数之差的程度。当你在做两个 int 或 long 数值的减法时，其结果可</p>
<p>能会溢出，在这种情况下我们就会得到错误的符号。 </p>
<p>例如，请考虑下面的程序： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Overflow</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args)&#123; </span><br><span class="line"></span><br><span class="line"> <span class="built_in">int</span> x = <span class="number">-2000000000</span>; </span><br><span class="line"></span><br><span class="line"> <span class="built_in">int</span> z = <span class="number">2000000000</span>; </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println(x - z); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，x 比 z 小，但是程序打印的是 294967296，它是一个正数。既然这种比</p>
<p>较的惯用法是有问题的，那么为什么它会被如此广泛地应用呢？因为它在大多数</p>
<p>时间里可以正常工作的。它只在用来来进行比较的两个数字的差大于</p>
<p>Integer.MAX_VALUE 的时候才会出问题。这意味着对于许多应用而言，在实际使</p>
<p>用中是不会看到这种错误的。更糟的是，它们被观察到的次数少之又少，以至于</p>
<p>这个 bug 永远都不会被发现和订正。 </p>
<p>那么这对于我们的程序的行为意味着什么呢？如果你查阅一下 Comparator 的文</p>
<p>档，你就会看到它所实现的排序关系必须是可传递的（transitive），换句话说，</p>
<p>(compare(x,y) &gt; 0)&amp;&amp;(compare(y,z) &gt; 0)蕴含着 compare(x,z) &gt; 0。如果我</p>
<p>们取 Overflow 例子中的 x 和 z，并取 y 为 0，那么我们的比较器在这些数值上就</p>
<p>违反了可传递性。事实上，在所有随机选取的 int 数值对中，有四分之一该比较</p>
<p>器都会返回错误的值。用这样的比较器来执行一个搜索或排序，或者用它去排序</p>
<p>一个有序的集合，都会产生不确定的行为，就像我们在运行本谜题的程序时所看</p>
<p>到的那样。出于数学上的倾向性，Comparator.compare 方法的一般约定要求比</p>
<p>较器要产生一个全序（total order），但是这个比较器在数个计算上都未能做</p>
<p>到这一点。 </p>
<p>我们可以通过替换遵守上述一般约定的 Comparator 实现来订正我们的程序。因</p>
<p>为我们只是想要反转自然排序的顺序，所以我们甚至可以不必编写我们自己的比</p>
<p>较器。Collection 类提供了一个可以产生这种顺序的比较器。如果你用</p>
<p>Arrays.sort(arr,Collections.reverseOrder())来替代最初的 Arrays.sort 调</p>
<p>用，该程序就可以打印出我们所期望的 DESCENDING。 </p>
<p>或者，你可以编写你自己的比较器。下面的代码并不“聪明”，但是它可以工作，</p>
<p>从而使该程序可以打印出我们所期望的 DESCENDING： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> compare(Integer i1, Integer i2) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> (i2 &lt; i1 ? <span class="number">-1</span> : (i2 == i1 ? <span class="number">0</span> :<span class="number">1</span>)); &#125;</span><br></pre></td></tr></table></figure>

<p>本谜题有数个教训，最具体的是：不要使用基于减法的比较器，除非你能够确保</p>
<p>要比较的数值之间的差永远不会大于 Integer.MAX_VALUE [EJ Item 11]。更一</p>
<p>般地讲，要意识到 int 的溢出，就像谜题 3、26 和 33 所讨论的那样。另一个教</p>
<p>训是你应该避免“聪明”的代码。应该努力去编写清晰正确的代码，不要对它作</p>
<p>任何优化，除非该优化被证明是必需的[EJ Item 37]。 </p>
<p>对语言设计者来说，得到的教训与谜题 3、26 和 33 相同：也许真的值得去考虑</p>
<p>支持某种形式整数算数运算，它不会在溢出时不抛出异常。还有就是可能应该在</p>
<p>语言中提供一个三值的比较器操作符，就像 Perl 所作的那样（&lt;=&gt;操作符）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/21/javahashmap%E4%B8%AD%E7%9A%84%E6%B7%BB%E5%8A%A0%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/21/javahashmap%E4%B8%AD%E7%9A%84%E6%B7%BB%E5%8A%A0%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">javahashmap添加时遇到的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-21 20:37:34 / 修改时间：20:49:07" itemprop="dateCreated datePublished" datetime="2021-03-21T20:37:34+08:00">2021-03-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>引入：为什么hashmap中添加时用了hashcode()还要用equals()去判断桶内部是否键对象相等，相等时替换旧值，而不相等时用头插法在链表头部插入新对象。</p>
<p><strong>哈希码由于只有2 ^ 32个不同的整数，并且在任何VM实例中都可能有2 ^ 32个以上的活动对象，因此从技术上讲，不可能为每个对象保证唯一的哈希码。</strong></p>
<p><strong>即使默认哈希码可能<em>基于</em>对象的内部地址，也与内部地址不同。</strong></p>
<h1 id="如何保证哈希值的唯一性"><a href="#如何保证哈希值的唯一性" class="headerlink" title="如何保证哈希值的唯一性"></a>如何保证哈希值的唯一性</h1><h2 id="1-哈希表-散列表-概述"><a href="#1-哈希表-散列表-概述" class="headerlink" title="1.哈希表(散列表)概述"></a>1.哈希表(散列表)概述</h2><p>hashCode（）最终返回的是一个int 值，是有范围的，并且不是一个单映射结构。</p>
<p>哈希表结构：<br>对象数组+链表</p>
<p>存储原理：<br>哈希表在存储的时候会调用对象的hashCode值，拿到返回的int值，然后去跟默认数组的长度进行取余运算，得到一个具体的下标，这个下标用来决定这个对象究竟存到什么位置。</p>
<p>优点：<br>这样做的好处是根本不需要对数组进行遍历，通过哈希值取余运算就能很快找到数据存储的位置。</p>
<p>当取余得到的数据一样时，链表会依次往下存储，当哈希桶中的数据量大于8时，从链表转化为红黑二叉树，会更利于查找。当哈希桶中的数据减少到6时，又会从红黑树转化为链表。</p>
<p>补充：<br>问题：</p>
<p>已知我的链表哈希桶里现在有7个数据，它一定会从红黑树转为链表吗？</p>
<p>解答：</p>
<p>这个题的坑在于已知有7个数据，但是他并没有告诉你这时候是已经转成了红黑树，所以得一分为二的看待。</p>
<p>如果是一开始存数据，那么现在本身就还是链表，不存在再次转为链表的问题。</p>
<p>如果是已经转为了红黑树，现在数据减少到7，那么当数据减少到6的时候一定会转化为链表。</p>
<h2 id="二、解决方法"><a href="#二、解决方法" class="headerlink" title="二、解决方法"></a>二、解决方法</h2><p>1.必须重写hashCode()方法<br>解释：<br>每new一个对象就会有一个新的地址值，哈希码值几乎都不相等，那么在放进哈希桶中重复的几率就特别低。</p>
<p>比如：<br>new Person(“张三”，23); 0x123<br>new Person(“张三”，23); 0x124<br>虽然两个对象的值一样，但是，它们两个的地址不一样，所以哈希码值不一样，会放在不同的哈希桶中，不会去重。</p>
<p>作用：<br>1.只有重写了hashCode()方法才能调用equals()方法，因为子类不重写就继承父类，而父类（Object类）就是依据你的地址值进行计算的，但是每new一个对象就会有一个新的地址值，地址值不一样，得到的哈希码值一定不重复，所以一定不会调用equals()方法。因为只有出现同一个索引，才会使用equals()方法去对比。</p>
<p>2.尽可能少调用equals（）方法 如果对象的属性值一样，那么尽可能让他们的哈希码值也一样，那么一定会调用equals（）方法，这样就会去重了。<br>使用系统默认的hashCode（）方法，减少equals（）方法调用次数，提高效率。</p>
<p>2.必须重写equals()方法<br>解释：</p>
<p>equals()用来对比你的属性是否相同。当哈希值相同时调用equals()方法对比属性，如果属性相同，则认为是同一个对象，会去重。</p>
<p>注意：这两个方法只重写其中一个不去重，必须同时重写！</p>
<h2 id="Java中的哈希表："><a href="#Java中的哈希表：" class="headerlink" title="Java中的哈希表："></a>Java中的哈希表：</h2><p>初始桶数量 ： 16</p>
<p>散列因子 ： 0.75 （哈希桶的数量是会变化的，当桶中已经有75%的地方存有数据了，那么对桶进行扩容，桶就会变得更多。扩容大小默认为原长度的两倍）</p>
<h3 id="一、何为加载因子？"><a href="#一、何为加载因子？" class="headerlink" title="一、何为加载因子？"></a>一、何为加载因子？</h3><p>加载因子是表示Hsah表中元素的填满的程度.若:加载因子越大,填满的元素越多,好处是,空间利用率高了,但:冲突的机会加大了.反之,加载因子越小,填满的元素越少,好处是:冲突的机会减小了,但:空间浪费多了.</p>
<p>冲突的机会越大,则查找的成本越高.反之,查找的成本越小.因而,查找时间就越小.  </p>
<p>因此,须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷. 这种平衡与折衷本质上是数据结构中有名的”时-空”矛盾的平衡与折衷.</p>
<h3 id="二、HashMap中的加载因子"><a href="#二、HashMap中的加载因子" class="headerlink" title="二、HashMap中的加载因子"></a>二、HashMap中的加载因子</h3><p>HashMap默认的加载因子是0.75，最大容量是16，因此可以得出HashMap的默认容量是：0.75*16=12。</p>
<p>用户可以自定义最大容量和加载因子。</p>
<p>HashMap 包含如下几个构造器：</p>
<ul>
<li>HashMap()：构建一个初始容量为 16，负载因子为 0.75 的 HashMap。</li>
<li>HashMap(int initialCapacity)：构建一个初始容量为 initialCapacity，负载因子为 0.75 的 HashMap。</li>
<li>HashMap(int initialCapacity, float loadFactor)：以指定初始容量、指定的负载因子创建一个 HashMap。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/21/C%E8%AF%AD%E8%A8%80%E6%B5%8B%E8%AF%95cpu%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/21/C%E8%AF%AD%E8%A8%80%E6%B5%8B%E8%AF%95cpu%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF/" class="post-title-link" itemprop="url">C语言测试CPU大端小端模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-21 19:53:32 / 修改时间：19:55:31" itemprop="dateCreated datePublished" datetime="2021-03-21T19:53:32+08:00">2021-03-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%BB%84/" itemprop="url" rel="index"><span itemprop="name">计组</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>503</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test1</span> &#123;</span></span><br><span class="line">	<span class="comment">//cpu中内存对齐分配</span></span><br><span class="line">	<span class="keyword">char</span> a;<span class="comment">//4个字节 </span></span><br><span class="line">	<span class="keyword">int</span> b;<span class="comment">//4个字节 </span></span><br><span class="line">	<span class="keyword">char</span> c;<span class="comment">//4个字节 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test2</span> &#123;</span></span><br><span class="line">	<span class="comment">//cpu中内存对齐分配 </span></span><br><span class="line">	<span class="keyword">char</span> a;<span class="comment">//2个字节 </span></span><br><span class="line">	<span class="keyword">char</span> b;<span class="comment">//2个字节 </span></span><br><span class="line">	<span class="keyword">int</span> c;<span class="comment">//4个字节 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">&#125; test3;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	test1 a;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(a)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	test2 b;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(b)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	test3.b=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(test3.a==<span class="number">1</span>)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"小端模式"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"大端模式"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/21/%E8%AE%A1%E7%BB%84%E7%AE%80%E8%A6%81%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/21/%E8%AE%A1%E7%BB%84%E7%AE%80%E8%A6%81%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">计算机组成原理简要知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-21 19:47:55 / 修改时间：19:50:56" itemprop="dateCreated datePublished" datetime="2021-03-21T19:47:55+08:00">2021-03-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%BB%84/" itemprop="url" rel="index"><span itemprop="name">计组</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、计算机系统概论"><a href="#一、计算机系统概论" class="headerlink" title="一、计算机系统概论"></a><strong>一、计算机系统概论</strong></h2><p><strong>1. 冯诺依曼计算机组成</strong></p>
<p>主机（cpu+内存），外设（输入设备+输出设备+外存），总线（地址总线+数据总线+控制总线）</p>
<p><strong>2. 计算机层次结构</strong></p>
<p>应用程序-高级语言-汇编语言-操作系统-指令集架构层-微代码层-硬件逻辑层</p>
<p><strong>3. 计算机性能指标</strong></p>
<p><strong>非时间指标</strong></p>
<ul>
<li><ul>
<li>【字长】机器一次能处理的二进制位数 ，常见的有32位或64位</li>
<li>【总线宽度】数据总线一次能并行处理的最大信息位数，一般指运算器与存储器之间的数据总线的位数</li>
<li>【主存容量】主存的大小</li>
<li>【存储带宽】单位时间内与主存交换的二进制位数 B/s</li>
</ul>
</li>
</ul>
<p><strong>时间指标</strong></p>
<ul>
<li><ul>
<li>【主频f】时钟震荡的频率 Hz；【时钟周期T】时钟震荡一次的时间 t</li>
<li>【外频】cpu与主板之间同步的时钟频率，系统总线的工作频率；【倍频】主频与外频的倍数 =主频/外频</li>
<li>【CPI】clock cycles per instruction，执行一条指令需要的周期数（平均）</li>
<li>【MIPS】million instructions per second，每秒执行的指令总条数 MIPS= f / CPI （忽略单位）</li>
</ul>
</li>
</ul>
<h2 id="二、数据表示"><a href="#二、数据表示" class="headerlink" title="二、数据表示"></a><strong>二、数据表示</strong></h2><p><strong>1. 基本概念</strong></p>
<ul>
<li><strong>真值</strong>：+0101，-0100</li>
<li><strong>机器数</strong>： [x]原=0101</li>
</ul>
<p><strong>2. 几种机器数</strong></p>
<ul>
<li><strong>原码</strong>：x = -0101，[x]原 = 1101</li>
<li><strong>反码</strong>：x = -0101，[x]反 = 1010</li>
<li><strong>补码</strong>：x = -0101，[x]补 = 1011</li>
<li><strong>移码</strong>：x = -0101，[x]移 = 2^n + x = 0011</li>
</ul>
<blockquote>
<p>PS：这里说说对补码与移码自己的理解。补码是为了化减法为加法方便计算机设计运算，移码是为了方便比较大小，用在浮点数的阶码中。<br>补码——<strong>任何一个有模的系统中，减法都可以通过加其补码来表示</strong>。最简单的例子就是以12为模的钟表，比如现在是3点，那么<strong>-5个小时</strong>就等于<strong>+7个小时</strong>，都是10点。这里7就是5的补码。<br>移码——数据对应关系一次挪动一下位置，使得看起来小的数真值也小。比如原本0000表示0，现在表示-128，然后0001表示-127，一直到1111表示+127，这样就方便比较了。</p>
</blockquote>
<p><strong>3. 定点数与浮点数</strong></p>
<p><strong>定点数</strong>：小数点固定 x.xxxxxx，表示范围受限，忘掉它吧</p>
<p><strong>浮点数</strong>：数的范围和精度分别表示。</p>
<p><strong>一般格式</strong> ：EEEE……EMMM…….M，E部分是<strong>阶码</strong>（数的范围i），M部分是<strong>尾数</strong>（数的精度）。缺点：阶码和尾数位数不固定，太灵活了</p>
<p><strong>IEEE754格式</strong>：跟我背下来—-</p>
<p>32位的是（单精度）：1位符号位S + 8位偏指数E + 23位有效尾数M，偏移值为127。</p>
<p>64位的是（双精度）：1位符号位S + 11位偏指数E + 52位有效尾数M，偏移值为1023。</p>
<p>真值就是（32位为例） N = (-1)^S * 2^(E-127) * 1.M</p>
<p><strong>浮点数的特殊情况</strong>：</p>
<p>E=0,M=0：机器零</p>
<p>E=255,M=0：无穷大，对应于x/0</p>
<p>E=255,M!=0：非数值NaN，对应0/0</p>
<p>ps：附上一份IEEE754文档：<a href="https://link.zhihu.com/?target=https%3A//files.cnblogs.com/files/flashsun/7542008-2008.pdf">https://files.cnblogs.com/files/flashsun/7542008-2008.pdf</a></p>
<p><strong>4. 数据校验</strong></p>
<p><strong>基本原理</strong>：增加冗余码</p>
<p><strong>码距</strong>：合法编码之间不同二进制位数的最小值</p>
<p><strong>码距与检错、纠错能力</strong>：</p>
<ul>
<li><ul>
<li>码距 d&gt;=e+1：检查e个错误</li>
<li>码距 d&gt;=2t+1：纠正t个错误</li>
<li>码距 d&gt;=e+t+1：同时检查e个错误，并纠正t个错误。（e&gt;=t）</li>
</ul>
</li>
</ul>
<p>PS：这里说下我的理解，增加码距就是增加非法编码的数量，看到非法编码就算<strong>检查出错误了</strong>，而非法编码距离哪个合法编码比较进就认为正确的应该是什么（简单理解，可参考下面的图），也就是可以<strong>纠正错误</strong>。这里看到过一个好的几何理解图，仔细品味下：</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%BB%84%E7%AE%80%E8%A6%81%E7%9F%A5%E8%AF%86/Git/myBlog/source/_posts/%E8%AE%A1%E7%BB%84/v2-53fb11083ce6d4c4039f40497a8abea9_720w.jpg" alt="img"></p>
<p>举个例子：比如一共有8位，码距为1则检查不出任何错误，因为所有编码都是合法编码。如果码距为2，那合法编码应该像 00000000，00000011，00001100，00001111这样，那如果出现00000001这样的非法编码就出错了，可检查一位错，但如果两位同时错了，则有可能又跳到另一个合法编码上了，就检查不出2位错。</p>
<p>那如果码距是3，那合法编码应该像 00000000，00000111，00111000，00111111 这样，那如果出现一位错 00000001，或者两位错00000011，都是非法编码，都能检查出错误，并且此时可以纠正00000001为00000000，纠正00000011为00000111。但是三位同时错就检查不出了。</p>
<p><strong>常见校验策略</strong>：奇偶校验，CRC校验，海明校验</p>
<p>ps：海明编码最强视频演示教程：<a href="https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3D373FUw-2U2k">https://www.youtube.com/watch?v=373FUw-2U2k</a></p>
<h2 id="三、运算方法与运算器"><a href="#三、运算方法与运算器" class="headerlink" title="三、运算方法与运算器"></a><strong>三、运算方法与运算器</strong></h2><p><strong>1. 定点数运算及溢出</strong></p>
<p><strong>定点数加减法</strong>：减法化加法，用补码直接相加，忽略进位</p>
<p><strong>溢出</strong>：运算结果超出了某种数据类型的表示范围</p>
<p><strong>溢出检测方法</strong>：统一思想概括为<strong>正正得负或负负得正则溢出</strong>，正负或负正不可能溢出</p>
<p><strong>方法1</strong>：V = XYS + XYS（XY为两个加数的符号位，S为结果的符号位，_表示非），那么V = 1则为溢出</p>
<p><strong>方法2</strong>：V = C0 ⊕ C1（C0是最高数据位产生的进位，C1是符号位产生的进位），那么V = 1则为溢出</p>
<p><strong>方法3</strong>：V = Xf1 ⊕ Xf2（数据采用变型补码 Xf1Xf2 X0X1X2X3… ）</p>
<p>PS：以上方法都是利用正正得负负负得正则溢出为出发点的电路设计</p>
<p><strong>2. 补码一位乘法——Booth算法</strong></p>
<p>[x·y]补 = [x]补·( -y0＋∑ yi2-i )</p>
<p>　　　= [<em>x</em>]补·[ - <em>y</em>0 + <em>y</em>12-1 + <em>y</em>22-2 + … + <em>yn</em>2-<em>n</em>]</p>
<p>　　　= [<em>x</em>]补·[ - <em>y</em>0 + (<em>y</em>1 - <em>y</em>12-1) + (<em>y</em>22-1 - <em>y</em>22-2) + … + (<em>yn<em>2-(</em>n</em>-1) - <em>yn<em>2-</em>n</em>)]</p>
<p>　　　= [<em>x</em>]补·[(<em>y</em>1 - <em>y</em>0) + (<em>y</em>2 - <em>y</em>1) 2-1 + … + (<em>yn</em> - <em>yn</em>-1) 2-(<em>n</em>-1) + (0 - <em>yn</em>)2-<em>n</em>]</p>
<p>总结起来设计数字电路的规则就是：</p>
<ul>
<li>为00或者为11的时候，直接右移一位</li>
<li>为01的时候，加x的补，然后右移一位</li>
<li>为10的时候，加-x的补，然后右移一位</li>
</ul>
<p>PS：其实第一行和最后一行都能设计数字电路，为什么要从第一个式子推到最后一个式子呢？原因有两点：</p>
<p>1）二进制中如果有0，可以不进行运算</p>
<p>2）如果有连续的1可以减少计算次数，比如 a * 001111100 = a * (010000000 - 0000000100)</p>
<p>所以每次判断 yn+1 - yn就可以减少计算次数了</p>
<p>参考：<a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/xisheng/p/9260861.html">https://www.cnblogs.com/xisheng/p/9260861.html</a></p>
<p><strong>3. 定点数除法</strong> — 略，没找到好的资料</p>
<p><strong>4. 浮点数加减法</strong></p>
<p>（1）求阶差，阶码小的对齐大的</p>
<p>（2）尾数加减</p>
<p>（3）结果规格化</p>
<h2 id="四、存储系统"><a href="#四、存储系统" class="headerlink" title="四、存储系统"></a><strong>四、存储系统</strong></h2><p><strong>1. 存储系统层次结构</strong></p>
<p><strong>主存速度缓慢的原因</strong>：主存增速与CPU不同步，执行指令期间多次访问主存</p>
<p><strong>主存容量不足的原因</strong>：</p>
<ul>
<li>存在制约主存容量的技术因素：如由CPU、主板等相关技术指标规定了主存容量</li>
<li>应用对主存容量需求不断扩大：window98 – 8M，windows 8 – 1G</li>
</ul>
<p>—–&gt; <strong>存储体系结构化层次</strong>： CPU – Cache1 – Cache2（解决速度） – 主存 – 辅存（解决容量）</p>
<p><strong>存储体系结构化层次理论基础</strong>：</p>
<ul>
<li><strong>时间局部性</strong>：程序体现为循环结构</li>
<li><strong>空间局部性</strong>：程序体现为顺序结构</li>
</ul>
<p><strong>2. 主存中的数据组织</strong></p>
<p><strong>存储字长</strong>：主存的一个存储单元所包含的二进制位数，目前大多数计算机主存按字节编址，主要由32为和64位</p>
<p><strong>数据存储与边界的关系</strong>：</p>
<ul>
<li>按边界对齐的数据存储，未按边界对齐的数据存储</li>
<li>边界对齐与存储地址的关系：（32位为例）</li>
</ul>
<ol>
<li><strong>双字长</strong>边界对齐：起始地址最末三位为000（8字节整数倍）</li>
<li><strong>单字长</strong>边界对齐：起始地址最末二位为00（4字节整数倍）</li>
<li><strong>半字长</strong>边界对齐：起始地址最末一位为0（2字节整数倍）</li>
</ol>
<p><strong>大端与小端存储方式</strong>：</p>
<ul>
<li><strong>大端</strong>：最高字节地址是数据地址（0123存成0123）</li>
<li><strong>小端</strong>：最低字节地址是数据地址（0123存成3210）</li>
</ul>
<p><strong>3. 存储器分类</strong></p>
<ul>
<li><strong>SRAM存储器</strong>：存取速度快，但集成度低，功耗大，做缓存</li>
<li><strong>DRAM存储器</strong>：存取速度慢，但集成度高，功耗低，做主存</li>
</ul>
<p>DRAM刷新方式：集中刷新、分散刷新、异步刷新</p>
<p><strong>4. 主存容量的扩展</strong></p>
<ul>
<li><strong>位扩展法</strong>：8K * 8位 –&gt; 8K * 32位</li>
<li><strong>字扩展法</strong>：8K * 8位 –&gt; 32K * 8位</li>
<li><strong>字位同时扩展法</strong>：8K * 8位 –&gt; 32K * 32位</li>
</ul>
<p><strong>5. Cache的基本原理</strong></p>
<p><strong>cache的工作过程</strong></p>
<ul>
<li><ul>
<li><strong>数据</strong>：cpu与cache交换字，cache与内存交换块</li>
<li><strong>读</strong>：命中，不命中</li>
<li><strong>写</strong>：写穿策略，写回策略</li>
</ul>
</li>
</ul>
<p><strong>写策略</strong></p>
<ul>
<li><ul>
<li><strong>写穿策略</strong>（write through）：同时写缓存和内存，好像<strong>穿过缓存</strong>一样。若不命中，先写到主存中，并选择性地同时分配到缓存中（写分配/非写分配）</li>
<li><strong>写回策略</strong>（write back）：写到缓存后不管了，只有当缓存的内容替换回主存时再管，需有脏位。好像<strong>隔段时间后再写回</strong>到主存中一样</li>
</ul>
</li>
</ul>
<p><strong>地址映射机制</strong></p>
<ul>
<li><p><strong>相联存储器</strong>：地址本身包含着位置啊可比较的信息啊等内容信息，可根据区分地址内容进行寻址</p>
</li>
<li><p><strong>主存地址</strong> = 块地址 + 块内偏移地址 = （Tag + Index） + 块内偏移地址</p>
</li>
<li><p><strong>cache结构</strong></p>
</li>
<li><ul>
<li>好多行，每行与主存块大小相等</li>
<li>每行 = tag + data + valid + dirty</li>
</ul>
</li>
<li><p><strong>三种映射方式</strong></p>
</li>
<li><ul>
<li><strong>全相联：</strong>cache行号 = random（内存块号）</li>
<li><strong>直接相联：</strong>cache行号 = 内存块号 % cache行数</li>
<li><strong>组相联：</strong>两者结合。8行1路组相联就是全相联，8行8路组相联就是直接相联</li>
</ul>
</li>
</ul>
<p><strong>替换算法</strong></p>
<ul>
<li><ul>
<li>先进先出法-FIFO</li>
<li>最近最不经常使用法-LFU</li>
<li>近期最少使用法-LRU</li>
<li>随机替换法</li>
</ul>
</li>
</ul>
<p><strong>6. 虚拟存储器</strong></p>
<p><strong>解决问题</strong>：主存容量不足。希望向程序员提供更大（比主存大）的编程空间</p>
<p><strong>分类</strong>：页式，段式，段页式</p>
<p><strong>页式实现方式</strong>：MMU（Memory Management Unit） + 页表 + TLB（Transaction Lookaside Buffer：地址转换后备缓冲器）</p>
<p><strong>页式转换过程</strong>：虚拟地址 = 虚拟页号 + 页内偏移 ==&gt; 物理页号 + 页内偏移</p>
<p><strong>7. RAID</strong></p>
<p><strong>概念</strong>：独立磁盘构成的具有冗余能力的阵列（Redundant Arrays Independent Disks）</p>
<p><strong>核心技术</strong>：使用异或运算恢复数据 （x⊕y = z –&gt; x = y⊕z）</p>
<p><strong>分类</strong>：</p>
<ul>
<li><ul>
<li><ul>
<li><strong>RAID0</strong>：条带均匀分布</li>
<li><strong>RAID1</strong>：以镜像为冗余方式</li>
<li><strong>RAID3/4</strong>：有校验盘</li>
<li><strong>RAID5</strong>：校验信息分布式</li>
<li><strong>RAID10/01</strong>：10是先镜像再条带化，01是先条带化再镜像</li>
<li><strong>RAID50</strong>：先RAID5，再条带化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="五、指令系统"><a href="#五、指令系统" class="headerlink" title="五、指令系统"></a><strong>五、指令系统</strong></h2><p><strong>1. 指令系统基本概念</strong></p>
<p><strong>指令集</strong>：一台机器所有指令的集合。<strong>系列机</strong>（同一公司不同时期生产）；<strong>兼容机</strong>（不同公司生产）</p>
<p><strong>指令字长</strong>：指令中包含的二进制位数，有<strong>等长指令</strong>、<strong>变长指令</strong>。</p>
<p><strong>指令分类</strong></p>
<ul>
<li><ul>
<li><p><strong>根据层次结构</strong>：高级、汇编、机器、微指令</p>
</li>
<li><p><strong>根据地址码字段个数</strong>：零、一、二、三地址指令</p>
</li>
<li><p><strong>根据操作数物理位置</strong></p>
</li>
<li><ul>
<li>存储器-存储器（SS）</li>
<li>寄存器-寄存器（RR）</li>
<li>寄存器-存储器（RS）</li>
</ul>
</li>
<li><p><strong>根据指令功能</strong>：传送、算术运算、位运算、控制转移</p>
</li>
</ul>
</li>
</ul>
<p><strong>指令格式</strong>：操作码+数据源+寻址方式</p>
<p><strong>2. 寻址方式</strong></p>
<p><strong>指令寻址方式：</strong>顺序寻址，跳跃寻址</p>
<p><strong>操作数寻址方式</strong>：</p>
<ul>
<li><ul>
<li><strong>立即数寻址</strong>：地址码字段是操作数本身 MOV AX, 200H</li>
<li><strong>寄存器寻址</strong>：地址码字段是寄存器地址 MOV AX, BX</li>
<li><strong>直接寻址</strong>：地址码字段是内存地址 MOV AX, [200H]</li>
<li><strong>间接寻址</strong>：地址码字段是内存地址的地址 MOV AX, I[200H]</li>
<li><strong>寄存器间接寻址</strong>：地址码字段是存内存地址的寄存器地址 MOV AX, [BX]</li>
<li><strong>相对寻址</strong>：操作数地址 + 当前PC的值</li>
<li><strong>基址寻址</strong>：操作数地址 + 基址寄存器的值（一段程序中不变） MOV AX, 32[B]</li>
<li><strong>变址寻址</strong>：操作数地址 + 变址寄存器的值（随程序不断变化） MOV AX, 32[SI]</li>
</ul>
</li>
</ul>
<p><strong>3. MIPS</strong></p>
<p><strong>三种指令格式</strong></p>
<ul>
<li><ul>
<li><strong>R型指令</strong></li>
<li><strong>I型指令</strong></li>
<li><strong>J型指令</strong></li>
</ul>
</li>
</ul>
<h2 id="六、中央处理器"><a href="#六、中央处理器" class="headerlink" title="六、中央处理器"></a><strong>六、中央处理器</strong></h2><p><strong>1. CPU的组成与功能</strong></p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%BB%84%E7%AE%80%E8%A6%81%E7%9F%A5%E8%AF%86/Git/myBlog/source/_posts/%E8%AE%A1%E7%BB%84/v2-a91d9377c5c8a88a47f197c706da156d_720w.jpg" alt="img"></p>
<p><strong>2. 数据通路</strong></p>
<p><strong>概念</strong>：执行部件间传送信息的路径，分共享通路（总线）和专用通路</p>
<p><strong>抽象模型</strong>：时钟驱动下，A –&gt; 组合逻辑 –&gt; B</p>
<p><strong>D触发器定时模型</strong>：</p>
<ul>
<li><ul>
<li><p>时钟触发前要稳定一段时间：建立时间（Setup Time）</p>
</li>
<li><p>时钟触发后要稳定一段时间：保持时间（Hold Time）</p>
</li>
<li><p>时钟触发到输出稳定的时间：触发器延迟（Clk_to_Q）</p>
</li>
<li><p><strong>与时钟周期的关系</strong>：</p>
</li>
<li><ul>
<li>时钟周期 &gt; Clk_to_Q + 关键路径时延 + Setup Time</li>
<li>Clk_to_Q + 最短路径时延 &gt; Hold Time</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>3. 指令周期</strong></p>
<p><strong>指令执行的一般流程</strong></p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%BB%84%E7%AE%80%E8%A6%81%E7%9F%A5%E8%AF%86/Git/myBlog/source/_posts/%E8%AE%A1%E7%BB%84/v2-8e4f8e5decc4c25d9304f12b7774af0e_720w.jpg" alt="img"></p>
<p><strong>基本概念</strong></p>
<ul>
<li><ul>
<li><strong>时钟周期</strong> = 节拍脉冲 = 震荡周期</li>
<li><strong>机器周期</strong> = CPU周期 = 从主存读取一条指令的最短时间</li>
<li><strong>指令周期</strong> = 从主存读指令并执行指令的时间</li>
</ul>
</li>
</ul>
<p><img src="/2021/03/21/%E8%AE%A1%E7%BB%84%E7%AE%80%E8%A6%81%E7%9F%A5%E8%AF%86/Git/myBlog/source/_posts/%E8%AE%A1%E7%BB%84/v2-2568da28e5180607b641ca3082b3c7a6_720w.jpg" alt="img"></p>
<p><strong>指令时间控制</strong>：</p>
<p><strong>机器周期数节拍数同步方式实践定长指令周期</strong>不变不变按机器周期mips单周期<strong>变长指令周期</strong>变变按时钟周期mips多周期</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%BB%84%E7%AE%80%E8%A6%81%E7%9F%A5%E8%AF%86/Git/myBlog/source/_posts/%E8%AE%A1%E7%BB%84/v2-c3a55fc6829a4e5f840568818775e60a_720w.jpg" alt="img"></p>
<p><strong>4. CPU设计</strong></p>
<p>略，详情请参见<a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/flashsun/p/9507089.html">《自制CPU系列》</a></p>
<h2 id="七、总线"><a href="#七、总线" class="headerlink" title="七、总线"></a><strong>七、总线</strong></h2><p><strong>1. 系统总线的特性及应用</strong></p>
<p><strong>总线概念</strong>：将计算机系统中各部件连接起来</p>
<p><strong>总线分类</strong>：（外部/内部，系统/非系统，串行/并行，同步/异步…）</p>
<p><strong>①. 按用途分类：</strong></p>
<ul>
<li><ul>
<li><ul>
<li><strong>存储总线</strong>：cpu与存储器</li>
<li><strong>系统总线</strong>：连接存储总线和IO总线的中间总线</li>
<li><strong>IO总线</strong>：连接外部设备</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>②. 按位置分类：</strong></p>
<ul>
<li><ul>
<li><ul>
<li><strong>外部总线</strong>：USB，火线（IEEE1394）</li>
<li><strong>内部总线</strong>：PCI（连网卡），AGB（连显卡）</li>
<li>（芯）<strong>片内总线</strong>：AMBA（ARM处理器）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>③. 按组成分类</strong></p>
<ul>
<li><ul>
<li><ul>
<li><strong>数据总线</strong>：传数据，双向三态</li>
<li><strong>地址总线</strong>：传地址，单向三态</li>
<li><strong>控制总线</strong>：控制信号和时序信号</li>
<li><strong>电源线和地线</strong>：略</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>2. 总线性能和总线事物</strong></p>
<p><strong>总线的性能参数</strong></p>
<ul>
<li><ul>
<li><strong>总线频率</strong>：总线工作速率f，单位是MHz</li>
<li><strong>总线宽度</strong>：数据总线的宽度w，单位是bit</li>
<li><strong>总线传输速率</strong>：总线传输数据量BW，单位是MB/s。BW = w / 8 * f</li>
</ul>
</li>
</ul>
<p><strong>总线事务</strong></p>
<ul>
<li><ul>
<li><strong>概念</strong>：从请求总线到完成使用的操作序列（请求 - 裁决 - 地址传输 - 数据传输 - 总线释放）</li>
<li><strong>角色</strong>：主设备（CPU，DMA）和从设备</li>
<li><strong>四个阶段</strong>：请求与仲裁 - 传输 - 寻址 - 结束</li>
<li><strong>常见总线操作</strong>：读，写，读修改写，写后读，块操作</li>
</ul>
</li>
</ul>
<p><strong>3. 总线连接方式</strong></p>
<ul>
<li><strong>单总线结构</strong></li>
</ul>
<p><img src="/2021/03/21/%E8%AE%A1%E7%BB%84%E7%AE%80%E8%A6%81%E7%9F%A5%E8%AF%86/Git/myBlog/source/_posts/%E8%AE%A1%E7%BB%84/v2-a390f5de9ad30f5c55a598b3fd31dfae_720w.jpg" alt="img"></p>
<ul>
<li><strong>双总线结构</strong></li>
</ul>
<p><img src="/2021/03/21/%E8%AE%A1%E7%BB%84%E7%AE%80%E8%A6%81%E7%9F%A5%E8%AF%86/Git/myBlog/source/_posts/%E8%AE%A1%E7%BB%84/v2-69ad6afdd2f15d203a7069dc6c5ae923_720w.jpg" alt="img"></p>
<ul>
<li><strong>多总线结构</strong></li>
</ul>
<p><img src="/2021/03/21/%E8%AE%A1%E7%BB%84%E7%AE%80%E8%A6%81%E7%9F%A5%E8%AF%86/Git/myBlog/source/_posts/%E8%AE%A1%E7%BB%84/v2-3e88cbaffc457a89d19c3754a604db0b_720w.jpg" alt="img"></p>
<ul>
<li><p><strong>总线桥</strong>：不同速率总线之间的连接，起速度缓冲、电平转换、控制协议转换的作用</p>
</li>
<li><ul>
<li>多级总线结构（南北桥）</li>
</ul>
</li>
</ul>
<p><img src="/2021/03/21/%E8%AE%A1%E7%BB%84%E7%AE%80%E8%A6%81%E7%9F%A5%E8%AF%86/Git/myBlog/source/_posts/%E8%AE%A1%E7%BB%84/v2-f3f51de1f54ffe72fcc3ce9b0a1fc9cf_720w.jpg" alt="img"></p>
<ul>
<li><ul>
<li>单总线结构</li>
</ul>
</li>
</ul>
<p><img src="/2021/03/21/%E8%AE%A1%E7%BB%84%E7%AE%80%E8%A6%81%E7%9F%A5%E8%AF%86/Git/myBlog/source/_posts/%E8%AE%A1%E7%BB%84/v2-6371aa4c70f70d95669776d5ceac0d3b_720w.jpg" alt="img"></p>
<ul>
<li><strong>总线结构对系统性能的影响</strong></li>
</ul>
<p><strong>多总线单总线对最大存储容量</strong>不影响因要与io共享内存，影响<strong>对指令系统</strong>增加IO指令无IO指令<strong>对吞吐量</strong>大小</p>
<p><strong>4. 总线仲裁和数据传输方式</strong></p>
<p><strong>菊花链式串行总线仲裁</strong>：简单，只要有一个主设备占用总线，其他就占不了</p>
<p><strong>集中式并行总线仲裁</strong>：</p>
<ul>
<li><ul>
<li><strong>固定优先级策略</strong>：优先级高的主设备，总会优先控制总线权</li>
<li><strong>轮叫式策略</strong>：皇帝轮流做</li>
<li><strong>LRG策略</strong>：最近获得控制权的，再获得控制权的优先级高（经常用的就更容易获得总线控制权）</li>
</ul>
</li>
</ul>
<p><strong>5. 总线标准</strong></p>
<p><strong>概念</strong>：计算机各部件之间利用总线传输信息应遵守的协议和规范，包括硬件和软件两部分</p>
<p><strong>常见的总线标准</strong></p>
<ul>
<li><ul>
<li><ul>
<li><p><strong>机箱内部总线：</strong></p>
</li>
<li><ul>
<li><p><strong>ISA - EISA - VESA</strong></p>
</li>
<li><ul>
<li><strong>ISA（Industrial Standard Architecture）</strong>：最早指定的总线技术标准，总线宽度8/16位，频率5-8MHz，带宽5-8MB/s</li>
<li><strong>EISA</strong>：宽度变成32位</li>
<li><strong>VESA</strong>：宽度变成64位</li>
</ul>
</li>
<li><p><strong>PCI（PCIe） - AGP</strong></p>
</li>
<li><ul>
<li>主要用于系统总线和IO总线，取代ISA</li>
<li>地址总线和数据总线分时复用，支持即插即用（自动寻找驱动程序）</li>
<li>32/64位，133/264MB/s</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>机箱外部总线：</strong></p>
</li>
<li><ul>
<li>USB等…</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="八、输入输出系统"><a href="#八、输入输出系统" class="headerlink" title="八、输入输出系统"></a><strong>八、输入输出系统</strong></h2><p><strong>1. 输入输出系统概述</strong></p>
<p><strong>组成</strong>：外设、接口、总线、管理软件</p>
<p><strong>基本功能</strong></p>
<ul>
<li><ul>
<li>完成计算机内外的信息传递</li>
<li>保证CPU正确选择输出设备</li>
<li>利用缓冲等，实现主机与外设的速度匹配</li>
</ul>
</li>
</ul>
<p><strong>特点：</strong>异步性、实时性、设备无关性</p>
<p><strong>输入过程：</strong>CPU把地址值放入总线 –&gt; CPU等候设备数据有效 –&gt; CPU从总线读入数据存入寄存器</p>
<p><strong>输出过程：</strong>CPU把地址值放入总线 –&gt; CPU把数据值放入总线 –&gt; 设备等数据有效取走数据</p>
<p><strong>IO系统性能</strong>：存储IO、通信IO</p>
<ul>
<li><ul>
<li><strong>连接特性</strong>：哪些设备可以和IO相连</li>
<li><strong>IO系统容量</strong>：IO系统可以容纳的设备数</li>
<li><strong>响应时间</strong>：从用户输入命令到得到结果所花的时间（s）</li>
<li><strong>吞吐率</strong>：单位时间完成的IO操作次数（用IOP表示）</li>
</ul>
</li>
</ul>
<p><strong>2. 输入输出方式</strong></p>
<p><strong>无条件IO方式</strong>：执行IO指令时，CPU默认外设已经准备就绪，外设很难满足这一点</p>
<p><strong>程序控制IO方式</strong>：执行IO指令时，先获取设备状态（设备状态寄存器），决定下一步操作（程序决定）</p>
<ul>
<li><ul>
<li>数据要经过CPU，CPU还要浪费大量时间查询设备状态</li>
</ul>
</li>
</ul>
<p><strong>中断IO方式</strong>：外设主动通知CPU接收或输出数据，有实时性</p>
<p><strong>DMA方式</strong>：由硬件执行IO，外设准备好后通知DMA，DMA接管总线，完成数据交换</p>
<ul>
<li><ul>
<li>既有中断的优点，又降低了服务的开销</li>
</ul>
</li>
</ul>
<p><strong>通道和IO处理机方式</strong>：外设种类很多速度差别很大，将外设管理工作从CPU总分离出来</p>
<ul>
<li><ul>
<li>通道本身就是个简单的CPU，执行IO指令的处理机</li>
<li>IO处理机是通道的进一步发展，更像一个CPU了</li>
</ul>
</li>
</ul>
<p><strong>3. 中断请求与响应</strong></p>
<p><strong>概念</strong>：CPU由内部外部事件引起CPU中断正在运行的程序，具有随机性（符合输入输出系统特性）</p>
<p><strong>作用</strong>：主机与外设并行；故障处理；实时处理</p>
<p><strong>类型</strong>：</p>
<ul>
<li><ul>
<li><strong>内部中断</strong>（软件、异常）</li>
<li><strong>外部中断</strong>（可屏蔽中断INTR、不可屏蔽中断NMI）</li>
</ul>
</li>
</ul>
<p><strong>基本功能</strong>：</p>
<ul>
<li><ul>
<li><p><strong>中断信号的保持与清除</strong>：通过寄存器存起来，处理完清零</p>
</li>
<li><p><strong>中断优先级</strong>：硬件响应优先序、软件服务优先序（中断服务程序开头，设置自己的中断屏蔽位）</p>
</li>
<li><p><strong>中断源识别</strong>：系统分配给每个中断源的代号（中断号），中断号获取可以用硬件或软件方式</p>
</li>
<li><p><strong>中断处理</strong>：</p>
</li>
<li><ul>
<li><strong>响应</strong>：每执行完一条指令，就会判断是否有中断请求</li>
<li><strong>处理</strong>：保存断点（返回地址）、执行中断程序、返回断点</li>
</ul>
</li>
<li><p><strong>中断控制</strong>：</p>
</li>
<li><ul>
<li><strong>中断触发方式</strong>：指外设以什么逻辑信号去申请中断（边沿触发、电平触发）</li>
<li><strong>中断排队方式</strong>：按优先级、循环轮流排队</li>
<li><strong>中断嵌套</strong>：中断正在执行的中断程序，不可屏蔽中断不能嵌套</li>
<li><strong>中断屏蔽</strong>：处理器内部有个触发器，“1”时才会响应外部中断</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2021/03/21/%E8%AE%A1%E7%BB%84%E7%AE%80%E8%A6%81%E7%9F%A5%E8%AF%86/Git/myBlog/source/_posts/%E8%AE%A1%E7%BB%84/v2-4271c728b057a63072e7b6f25dcb35e4_720w.jpg" alt="img"></p>
<p><strong>4. DMA方式</strong></p>
<p><strong>原理</strong>：数据传送不经过CPU，由DMA控制器实现内存和外设、外设和外设之间的直接快速传递</p>
<p><strong>系统构成</strong>：</p>
<ul>
<li><ul>
<li><strong>DMA作为主设备之一</strong></li>
</ul>
</li>
</ul>
<p><img src="/2021/03/21/%E8%AE%A1%E7%BB%84%E7%AE%80%E8%A6%81%E7%9F%A5%E8%AF%86/Git/myBlog/source/_posts/%E8%AE%A1%E7%BB%84/v2-34773de68815131c23a88d9b71465e0f_720w.jpg" alt="img"></p>
<ul>
<li><ul>
<li><strong>DMA与IO接口集成</strong></li>
</ul>
</li>
</ul>
<p><img src="/2021/03/21/%E8%AE%A1%E7%BB%84%E7%AE%80%E8%A6%81%E7%9F%A5%E8%AF%86/Git/myBlog/source/_posts/%E8%AE%A1%E7%BB%84/v2-d409136646e365a3ff783958ef9d4b28_720w.jpg" alt="img"></p>
<ul>
<li><ul>
<li><strong>DMA提供专门IO总线</strong></li>
</ul>
</li>
</ul>
<p><img src="/2021/03/21/%E8%AE%A1%E7%BB%84%E7%AE%80%E8%A6%81%E7%9F%A5%E8%AF%86/Git/myBlog/source/_posts/%E8%AE%A1%E7%BB%84/v2-31350dada7dd881313879ac4f226303c_720w.jpg" alt="img"></p>
<p><strong>DMA的两种工作状态</strong>：被动态（未获得总线控制权，受CPU控制）、主动态（获得总线控制权）</p>
<p><strong>传输步骤</strong>：</p>
<ul>
<li><ul>
<li><strong>申请</strong>：一个设备接口试图通过总线向另一个设备发送数据，先向CPU发送DMA信号</li>
<li><strong>响应</strong>：CPU收到DMA信号，当前总线周期结束后，按DMA信号优先级响应相应的DMA控制器</li>
<li><strong>数据传送</strong>：DMA收到CPU响应，获得总线控制权，开始直接数据传送</li>
<li><strong>传送结束</strong>：设备向CPU发送DMA结束信号，交换总线控制权</li>
</ul>
</li>
</ul>
<p><strong>DMA操作类型</strong>：</p>
<ul>
<li><ul>
<li><strong>数据传送</strong>：源地址数据传到目的地址</li>
<li><strong>数据校验</strong>：不传输，只校验某数据块内部的每个字节</li>
<li><strong>数据检索</strong>：不传输，只在制定内存区域内查找某个关键字或某几个数据位是否存在</li>
</ul>
</li>
</ul>
<p><strong>DMA操作方式</strong>：</p>
<ul>
<li><ul>
<li><strong>单字节传输模式</strong>：每次DMA操作传送一个字节</li>
<li><strong>块传输模式</strong>：每次传送多个字节，有个当前字节计数器，+1 +1 +1</li>
<li><strong>请求传输模式</strong>：DMA控制器询问外设，当外设请求信号无效时，暂停传输（不释放总线）；再次有效再继续传输</li>
<li><strong>级联传输模式</strong>：多个DMA级联，分布式</li>
</ul>
</li>
</ul>
<p><strong>DMA传输模式</strong>：</p>
<ul>
<li><ul>
<li><strong>停止CPU访问内存</strong>：传输速率高的设备传输时有优势</li>
<li><strong>周期挪用</strong>：DMA挪用一个或几个内存周期。若此时CPU不需要访存则不冲突，若冲突则DMA优先</li>
<li><strong>DMA与CPU交替访存</strong>：直接交替访存，不需要浪费时间</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/48/">48</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">匡俊桦</p>
  <div class="site-description" itemprop="description">回忆的沙漏将曾经屈指可数的日子渐渐淡去</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">238</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">匡俊桦</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">29:11</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
