<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:type" content="website">
<meta property="og:title" content="KJHの博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="KJHの博客">
<meta property="og:description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="匡俊桦">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>KJHの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KJHの博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录&回忆</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/20/java%E7%B1%BB%E8%B0%9C%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/20/java%E7%B1%BB%E8%B0%9C%E9%A2%98/" class="post-title-link" itemprop="url">java类谜题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-20 22:41:03" itemprop="dateCreated datePublished" datetime="2021-03-20T22:41:03+08:00">2021-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-21 10:46:39" itemprop="dateModified" datetime="2021-03-21T10:46:39+08:00">2021-03-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java-谜题-Java-谜题-5——类谜题"><a href="#Java-谜题-Java-谜题-5——类谜题" class="headerlink" title="Java 谜题 Java 谜题 5——类谜题"></a>Java 谜题 Java 谜题 5——类谜题</h1><h2 id="谜题-46：令人混淆的构造器案例-令人混淆的构造器案例"><a href="#谜题-46：令人混淆的构造器案例-令人混淆的构造器案例" class="headerlink" title="谜题 46：令人混淆的构造器案例 令人混淆的构造器案例"></a>谜题 46：令人混淆的构造器案例 令人混淆的构造器案例</h2><p>本谜题呈现给你了两个容易令人混淆的构造器。main 方法调用了一个构造器，</p>
<p>但是它调用的到底是哪一个呢？该程序的输出取决于这个问题的答案。那么它到</p>
<p>底会打印出什么呢？甚至它是否是合法的呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Confusing</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">Confusing</span><span class="params">(Object o)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"Object"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">Confusing</span><span class="params">(<span class="keyword">double</span>[] dArray)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"double array"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">new</span> Confusing(null); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传递给构造器的参数是一个空的对象引用，因此，初看起来，该程序好像应该调</p>
<p>用参数类型为 Object 的重载版本，并且将打印出 Object。另一方面，数组也是</p>
<p>引用类型，因此 null 也可以应用于类型为 double[ ]的重载版本。你由此可能</p>
<p>会得出结论：这个调用是模棱两可的，该程序应该不能编译。如果你试着去运行</p>
<p>该程序，就会发现这些直观感觉都是不对的：该程序打印的是 double array。</p>
<p>这种行为可能显得有悖常理，但是有一个很好的理由可以解释它。 </p>
<p>Java 的重载解析过程是以两阶段运行的。第一阶段选取所有可获得并且可应用</p>
<p>的方法或构造器。第二阶段在第一阶段选取的方法或构造器中选取最精确的一</p>
<p>个。如果一个方法或构造器可以接受传递给另一个方法或构造器的任何参数，那</p>
<p>么我们就说第一个方法比第二个方法缺乏精确性[JLS 15.12.2.5]。 在我们的程序中，两个构造器都是可获得并且可应用的。构造器</p>
<p>Confusing(Object)可以接受任何传递给 Confusing(double[ ])的参数，因此</p>
<p>Confusing(Object)相对缺乏精确性。（每一个 double 数组都是一个 Object，</p>
<p>但是每一个 Object 并不一定是一个 double 数组。）因此，最精确的构造器就是</p>
<p>Confusing(double[ ])，这也就解释了为什么程序会产生这样的输出。 </p>
<p>如果你传递的是一个 double[ ]类型的值，那么这种行为是有意义的；但是如果</p>
<p>你传递的是 null，这种行为就有违直觉了。理解本谜题的关键在于在测试哪一</p>
<p>个方法或构造器最精确时，这些测试没有使用实际的参数：即出现在调用中的参</p>
<p>数。这些参数只是被用来确定哪一个重载版本是可应用的。一旦编译器确定了哪</p>
<p>些重载版本是可获得且可应用的，它就会选择最精确的一个重载版本，而此时使</p>
<p>用的仅仅是形式参数：即出现在声明中的参数。 </p>
<p>要想用一个 null 参数来调用 Confusing(Object)构造器，你需要这样写代码：</p>
<p>new Confusing((Object)null)。这可以确保只有 Confusing(Object)是可应用</p>
<p>的。更一般地讲，要想强制要求编译器选择一个精确的重载版本，需要将实际的</p>
<p>参数转型为形式参数所声明的类型。 </p>
<p>以这种方式来在多个重载版本中进行选择是相当令人不快的。在你的 API 中，应</p>
<p>该确保不会让客户端走这种极端。理想状态下，你应该避免使用重载：为不同的</p>
<p>方法取不同的名称。当然，有时候这无法实现，例如，构造器就没有名称，因而</p>
<p>也就无法被赋予不同的名称。然而，你可以通过将构造器设置为私有的并提供公</p>
<p>有的静态工厂，以此来缓解这个问题[EJ Item 1]。如果构造器有许多参数，你</p>
<p>可以用 Builder 模式[Gamma95]来减少对重载版本的需求量。 </p>
<p>如果你确实进行了重载，那么请确保所有的重载版本所接受的参数类型都互不兼</p>
<p>容，这样，任何两个重载版本都不会同时是可应用的。如果做不到这一点，那么</p>
<p>就请确保所有可应用的重载版本都具有相同的行为[EJ Item 26]。 </p>
<p>总之，重载版本的解析可能会产生混淆。应该尽可能地避免重载，如果你必须进</p>
<p>行重载，那么你必须遵守上述方针，以最小化这种混淆。如果一个设计糟糕的</p>
<p>API 强制你在不同的重载版本之间进行选择，那么请将实际的参数转型为你希望</p>
<p>调用的重载版本的形式参数所具有的类型。 </p>
<h2 id="谜题-47：啊呀！我的猫变成狗了-！我的猫变成狗了"><a href="#谜题-47：啊呀！我的猫变成狗了-！我的猫变成狗了" class="headerlink" title="谜题 47：啊呀！我的猫变成狗了 ！我的猫变成狗了"></a>谜题 47：啊呀！我的猫变成狗了 ！我的猫变成狗了</h2><p>下面的程序使用了一个 Counter 类来跟踪每一种家庭宠物叫唤的次数。那么该程</p>
<p>序会打印出什么呢？ </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> count++; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Counter</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123; &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">woof</span><span class="params">()</span> </span>&#123; increment(); &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Counter</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123; &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meow</span><span class="params">()</span> </span>&#123; increment(); &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ruckus</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> Dog dogs[] = &#123; <span class="keyword">new</span> Dog(), <span class="keyword">new</span> Dog() &#125;; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dogs.length; i++) </span><br><span class="line"></span><br><span class="line"> dogs[i].woof(); </span><br><span class="line"></span><br><span class="line"> Cat cats[] = &#123; <span class="keyword">new</span> Cat(), <span class="keyword">new</span> Cat(), <span class="keyword">new</span> Cat() &#125;; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cats.length; i++) </span><br><span class="line"></span><br><span class="line"> cats[i].meow(); </span><br><span class="line"></span><br><span class="line"> System.out.print(Dog.getCount() + <span class="string">" woofs and "</span>); </span><br><span class="line"></span><br><span class="line"> System.out.println(Cat.getCount() + <span class="string">" meows"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们听到两声狗叫和三声猫叫——肯定是好一阵喧闹——因此，程序应该打印 2 </p>
<p>woofs and 3 meows，不是吗？不：它打印的是 5 woofs and 5 meows。所有这</p>
<p>些多出来的吵闹声是从哪里来的？我们做些什么才能够阻止它？ </p>
<p>该程序打印出的犬吠声和猫叫声的数量之和是 10，它是实际总数的两倍。问题</p>
<p>在于 Dog 和 Cat 都从其共同的超类那里继承了 count 域，而 count 又是一个静态</p>
<p>域。每一个静态域在声明它的类及其所有子类中共享一份单一的拷贝，因此 Dog</p>
<p>和 Cat 使用的是相同的 count 域。每一个对 woof 或 meow 的调用都在递增这个域，</p>
<p>因此它被递增了 5 次。该程序分别通过调用 Dog.getCount 和 Cat.getCount 读取</p>
<p>了这个域两次，在每一次读取时，都返回并打印了 5。 </p>
<p>在设计一个类的时候，如果该类构建于另一个类的行为之上，那么你有两种选择：</p>
<p>一种是继承，即一个类扩展另一个类；另一种是组合，即在一个类中包含另一个</p>
<p>类的一个实例。选择的依据是，一个类的每一个实例都是另一个类的一个实例，</p>
<p>还是都有另一个类的一个实例。在第一种情况应该使用继承，而第二种情况应该</p>
<p>使用组合。当你拿不准时，优选组合而不是继承[EJ Item 14]。 </p>
<p>一条狗或是一只猫都不是一种计数器，因此使用继承是错误的。Dog 和 Cat 不应</p>
<p>该扩展 Counter，而是应该都包含一个计数器域。每一种宠物都需要有一个计数器，但并非每一只宠物都需要有一个计数器，因此，这些计数器域应该是静态的。</p>
<p>我们不必为 Counter 类而感到烦恼；一个 int 域就足够了。 </p>
<p>下面是我们重新设计过的程序，它会打印出我们所期望的 2 woofs, 3 meows： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> woofCounter; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123; &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">woofCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> woofCounter; &#125;; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">woof</span><span class="params">()</span> </span>&#123; woofCounter++; &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> meowCounter; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123; &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">meowCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> meowCounter; &#125;; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meow</span><span class="params">()</span> </span>&#123; meowCounter++; &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Ruckus 类除了两行语句之外没有其它的变化，这两行语句被修改为使用新的方</p>
<p>法名来访问计数器： </p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print(<span class="module-access"><span class="module"><span class="identifier">Dog</span>.</span></span>woof<span class="constructor">Count()</span> + <span class="string">" woofs and "</span>); </span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Cat</span>.</span></span>meow<span class="constructor">Count()</span> + <span class="string">" meows"</span>);</span><br></pre></td></tr></table></figure>

<p>总之，静态域由声明它的类及其所有子类所共享。如果你需要让每一个子类都具</p>
<p>有某个域的单独拷贝，那么你必须在每一个子类中声明一个单独的静态域。如果</p>
<p>每一个实例都需要一个单独的拷贝，那么你可以在基类中声明一个非静态域。还</p>
<p>有就是，要优选组合而不是继承，除非导出类真的需要被当作是某一种基类来看</p>
<p>待。 </p>
<h2 id="谜题-48：我所得到的都是静态的-我所得到的都是静态的"><a href="#谜题-48：我所得到的都是静态的-我所得到的都是静态的" class="headerlink" title="谜题 48：我所得到的都是静态的 我所得到的都是静态的"></a>谜题 48：我所得到的都是静态的 我所得到的都是静态的</h2><p>下面的程序对巴辛吉小鬣狗和其它狗之间的行为差异进行了建模。如果你不知道</p>
<p>什么是巴辛吉小鬣狗，那么我告诉你，这是一种产自非洲的小型卷尾狗，它们从</p>
<p>来都不叫唤。那么，这个程序将打印出什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">print</span>(<span class="string">"woof "</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basenji</span> <span class="title">extends</span> <span class="title">Dog</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123; &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bark</span> &#123;</span> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span> args[])</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> Dog woofer = <span class="keyword">new</span> Dog(); </span><br><span class="line"></span><br><span class="line"> Dog nipper = <span class="keyword">new</span> Basenji(); </span><br><span class="line"></span><br><span class="line"> woofer.bark(); </span><br><span class="line"></span><br><span class="line"> nipper.bark(); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随意地看一看，好像该程序应该只打印一个 woof。毕竟，Basenji 扩展自 Dog，</p>
<p>并且它的 bark 方法定义为什么也不做。main 方法调用了 bark 方法，第一次是</p>
<p>在 Dog 类型的 woofer 上调用，第二次是在 Basenji 类型的 nipper 上调用。巴辛</p>
<p>吉小鬣狗并不会叫唤，但是很显然，这一只会。如果你运行该程序，就会发现它</p>
<p>打印的是 woof woof。这只可怜的小家伙到底出什么问题了？ </p>
<p>问题在于 bark 是一个静态方法，而对静态方法的调用不存在任何动态的分派机</p>
<p>制[JLS 15.12.4.4]。当一个程序调用了一个静态方法时，要被调用的方法都是</p>
<p>在编译时刻被选定的，而这种选定是基于修饰符的编译期类型而做出的，修饰符</p>
<p>的编译期类型就是我们给出的方法调用表达式中圆点左边部分的名字。在本案</p>
<p>中，两个方法调用的修饰符分别是变量 woofer 和 nipper，它们都被声明为 Dog</p>
<p>类型。因为它们具有相同的编译期类型，所以编译器使得它们调用的是相同的方</p>
<p>法：Dog.bark。这也就解释了为什么程序打印出 woof woof。尽管 nipper 的运</p>
<p>行期类型是 Basenji，但是编译器只会考虑其编译器类型。 </p>
<p>要订正这个程序，直接从两个 bark 方法定义中移除掉 static 修饰符即可。这样，</p>
<p>Basenji 中的 bark 方法将覆写而不是隐藏 Dog 中的 bark 方法，而该程序也将会</p>
<p>打印出 woof，而不是 woof woof。通过覆写，你可以获得动态的分派；而通过隐</p>
<p>藏，你却得不到这种特性。 </p>
<p>当你调用了一个静态方法时，通常都是用一个类而不是表达式来标识它：例如，</p>
<p>Dog.bark 或 Basenji.bark。当你在阅读一个 Java 程序时，你会期望类被用作为</p>
<p>静态方法的修饰符，这些静态方法都是被静态分派的，而表达式被用作为实例方</p>
<p>法的修饰符，这些实例方法都是被动态分派的。通过耦合类和变量的不同的命名</p>
<p>规范，我们可以提供一个很强的可视化线索，用来表明一个给定的方法调用是动</p>
<p>态的还是静态的。本谜题的程序使用了一个表达式作为静态方法调用的修饰符，</p>
<p>这就误导了我们。千万不要用一个表达式来标识一个静态方法调用。 </p>
<p>覆写的使用与上述的混乱局面搅到了一起。Basenji 中的 bark 方法与 Dog 中的</p>
<p>bark 方法具有相同的方法签名，这正是覆写的惯用方式，预示着要进行动态的</p>
<p>分派。然而在本案中，该方法被声明为是 static 的，而静态方法是不能被覆写</p>
<p>的；它们只能被隐藏，而这仅仅是因为你没有表达出你应该表达的意思。为了避</p>
<p>免这样的混乱，千万不要隐藏静态方法。即便在子类中重用了超类中的静态方法</p>
<p>的名称，也不会给你带来任何新的东西，但是却会丧失很多东西。 </p>
<p>对语言设计者的教训是：对类和实例方法的调用彼此之间看起来应该具有明显的</p>
<p>差异。第一种实现此目标的方式是不允许使用表达式作为静态方法的修饰符；第</p>
<p>二种区分静态方法和实例方法调用的方式是使用不同的操作符，就像 C++那样；第三种方式是通过完全抛弃静态方法这一概念来解决此问题，就像 Smalltalk</p>
<p>那样。 </p>
<p>总之，要用类名来修饰静态方法的调用，或者当你在静态方法所属的类中去调用</p>
<p>它们时，压根不去修饰这些方法，但是千万不要用一个表达式去修饰它们。还有</p>
<p>就是要避免隐藏静态方法。所有这些原则合起来就可以帮助我们去消除那些容易</p>
<p>令人误解的覆写，这些覆写需要对静态方法进行动态分派。 </p>
<h2 id="谜题-49：比生命更大"><a href="#谜题-49：比生命更大" class="headerlink" title="谜题 49：比生命更大"></a>谜题 49：比生命更大</h2><p>假如小报是可信的，那么摇滚之王“猫王”就会直到今天仍然在世。下面的程序</p>
<p>用来估算猫王当前的腰带尺寸，方法是根据在公开演出中所观察到的他的体态发</p>
<p>展趋势来进行投射。该程序中使用了</p>
<p>Calendar.getInstance().get(Calendar.YEAR)这个惯用法，它返回当前的日历</p>
<p>年份。那么，该程序会打印出什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis(); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> beltSize; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CURRENT_YEAR = </span><br><span class="line"></span><br><span class="line"> Calendar.getInstance().<span class="built_in">get</span>(Calendar.YEAR); </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> beltSize = CURRENT_YEAR - <span class="number">1930</span>; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">beltSize</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> beltSize; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"Elvis wears a size "</span> + </span><br><span class="line"></span><br><span class="line"> INSTANCE.beltSize() + <span class="string">" belt."</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一眼看去，这个程序是在计算当前的年份减去 1930 的值。如果它是正确的，</p>
<p>那么在 2006 年，该程序将打印出 Elvis wears a size 76 belt。如果你尝试着</p>
<p>去运行该程序，你就会了解到小报是错误的，这证明你不能相信在报纸到读到的</p>
<p>任何东西。该程序将打印出 Elvis wears a size -1930 belt。也许猫王已经在</p>
<p>反物质的宇宙中定居了。 </p>
<p>该程序所遇到的问题是由类初始化顺序中的循环而引起的[JLS 12.4]。让我们来</p>
<p>看看其细节。Elvis 类的初始化是由虚拟机对其 main 方法的调用而触发的。首</p>
<p>先，其静态域被设置为缺省值[JLS 4.12.5]，其中 INSTANCE 域被设置为 null，</p>
<p>CURRENT_YEAR 被设置为 0。接下来，静态域初始器按照其出现的顺序执行。第一</p>
<p>个静态域是 INSTANCE，它的值是通过调用 Elvis()构造器而计算出来的。 这个构造器会用一个涉及静态域 CURRENT_YEAR 的表达式来初始化 beltSize。通</p>
<p>常，读取一个静态域是会引起一个类被初始化的事件之一，但是我们已经在初始</p>
<p>化 Elvis 类了。递归的初始化尝试会直接被忽略掉[JLS 12.4.2, 第 3 步]。因此，</p>
<p>CURRENT_YEAR 的值仍旧是其缺省值 0。这就是为什么 Elvis 的腰带尺寸变成了</p>
<p>-1930 的原因。 </p>
<p>最后，从构造器返回以完成 Elvis 类的初始化，假设我们是在 2006 年运行该程</p>
<p>序，那么我们就将静态域 CURRENT_YEAR 初始化成了 2006。遗憾的是，这个域现</p>
<p>在所具有的正确值对于向 Elvis.INSTANCE.beltSize 的计算施加影响来说已经</p>
<p>太晚了，beltSize 的值已经是-1930 了。这正是后续所有对</p>
<p>Elvis.INSTANCE.beltSize()的调用将返回的值。 </p>
<p>该程序表明，在 final 类型的静态域被初始化之前，存在着读取它的值的可能，</p>
<p>而此时该静态域包含的还只是其所属类型的缺省值。这是与直觉相违背的，因为</p>
<p>我们通常会将 final 类型的域看作是常量。final 类型的域只有在其初始化表达</p>
<p>式是常量表达式时才是常量[JLS 15.28]。 </p>
<p>由类初始化中的循环所引发的问题是难以诊断的，但是一旦被诊断到，通常是很</p>
<p>容易订正的。要想订正一个类初始化循环，需要重新对静态域的初始器进行排序，</p>
<p>使得每一个初始器都出现在任何依赖于它的初始器之前。在这个程序中，</p>
<p>CURRENT_YEAR 的声明属于在 INSTANCE 声明之前的情况，因为 Elvis 实例的创建</p>
<p>需要 CURRENT_YEAR 被初始化。一旦 CURRENT_YEAR 的声明被移走，Elvis 就真的</p>
<p>比生命更大了。 </p>
<p>某些通用的设计模式本质上就是初始化循环的，特别是本谜题所展示的单例模式</p>
<p>（Singleton）[Gamma95]和服务提供者框架（Service Provider Framework）[EJ </p>
<p>Item 1]。类型安全的枚举模式（Typesafe Enum pattern）[EJ Item 21]也会引</p>
<p>起类初始化的循环。5.0 版本添加了对这种使用枚举类型的模式的语言级支持。</p>
<p>为了减少问题发生的可能性，对枚举类型的静态初始器做了一些限制[JLS 16.5,</p>
<p>8.9]。 </p>
<p>总之，要当心类初始化循环。最简单的循环只涉及到一个单一的类，但是它们也</p>
<p>可能涉及多个类。类初始化循环也并非总是坏事，但是它们可能会导致在静态域</p>
<p>被初始化之前就调用构造器。静态域，甚至是 final 类型的静态域，可能会在它</p>
<p>们被初始化之前，被读走其缺省值。 </p>
<h2 id="谜题-50：不是你的类型"><a href="#谜题-50：不是你的类型" class="headerlink" title="谜题 50：不是你的类型"></a>谜题 50：不是你的类型</h2><p>本谜题要测试你对 Java 的两个最经典的操作符：instanceof 和转型的理解程度。</p>
<p>下面的三个程序每一个都会做些什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Type1</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">String</span> s = null; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(s instanceof <span class="keyword">String</span>); &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Type2</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="keyword">new</span> Type2() instanceof <span class="keyword">String</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Type3</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span> args[])</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> Type3 t3 = (Type3) <span class="keyword">new</span> Object(); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个程序，Type1，展示了 instanceof 操作符应用于一个空对象引用时的行为。</p>
<p>尽管 null 对于每一个引用类型来说都是其子类型，但是 instanceof 操作符被定</p>
<p>义为在其左操作数为 null 时返回 false。因此，Type1 将打印 false。这被证明</p>
<p>是实践中非常有用的行为。如果 instanceof 告诉你一个对象引用是某个特定类</p>
<p>型的实例，那么你就可以将其转型为该类型，并调用该类型的方法，而不用担心</p>
<p>会抛出 ClassCastException 或 NullPointerException 异常。 </p>
<p>第二个程序，Type2，展示了 instanceof 操作符在测试一个类的实例，以查看它</p>
<p>是否是某个不相关的类的实例时所表现出来的行为。你可能会期望该程序打印出</p>
<p>false。毕竟，Type2 的实例不是 String 的实例，因此该测试应该失败，对吗？</p>
<p>不，instanceof 测试在编译时刻就失败了，我们只能得到下面这样的出错消息： </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Type2.java:3</span>: inconvertible types </span><br><span class="line"></span><br><span class="line">found : Type2, required: java.lang.String</span><br><span class="line"></span><br><span class="line"> System.out.println(new Type2() instanceof String); </span><br><span class="line"></span><br><span class="line"> ^</span><br></pre></td></tr></table></figure>

<p>该程序编译失败是因为 instanceof 操作符有这样的要求：如果两个操作数的类</p>
<p>型都是类，其中一个必须是另一个的子类型[JLS 15.20.2, 15.16, 5.5]。Type2</p>
<p>和 String 彼此都不是对方的子类型，所以 instanceof 测试将导致编译期错误。</p>
<p>这个错误有助于让你警惕 instanceof 测试，它们可能并没有去做你希望它们做</p>
<p>的事情。 </p>
<p>第三个程序，Type3，展示了当要被转型的表达式的静态类型是转型类型的超类</p>
<p>时，转型操作符的行为。与 instanceof 操作相同，如果在一个转型操作中的两</p>
<p>种类型都是类，那么其中一个必须是另一个的子类型。尽管对我们来说，这个转</p>
<p>型很显然会失败，但是类型系统还没有强大到能够洞悉表达式 new Object()的</p>
<p>运行期类型不可能是 Type3 的一个子类型。因此，该程序将在运行期抛出</p>
<p>ClassCastException 异常。这有一点违背直觉：第二个程序完全具有实际意义，</p>
<p>但是却不能编译；而这个程序没有任何实际意义，但是却可以编译。 总之，第一个程序展示了 instanceof 运行期行为的一个很有用的冷僻案例。第</p>
<p>二个程序展示了其编译期行为的一个很有用的冷僻案例。第三个程序展示了转型</p>
<p>操作符的行为的一个冷僻案例，在此案例中，编译器并不能将你从你所做荒唐的</p>
<p>事中搭救出来，只能靠 VM 在运行期来帮你绷紧这根弦。</p>
<h2 id="谜题-51：那个点是什么？"><a href="#谜题-51：那个点是什么？" class="headerlink" title="谜题 51：那个点是什么？"></a>谜题 51：那个点是什么？</h2><p>下面这个程序有两个不可变的值类（value class），值类即其实例表示值的类。</p>
<p>第一个类用整数坐标来表示平面上的一个点，第二个类在此基础上添加了一点颜</p>
<p>色。主程序将创建和打印第二个类的一个实例。那么，下面的程序将打印出什么</p>
<p>呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> x, y; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">String</span> name; <span class="comment">// Cached at construction time </span></span><br><span class="line"></span><br><span class="line"> Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.x = x; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.y = y; </span><br><span class="line"></span><br><span class="line"> name = makeName(); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">String</span> <span class="title">makeName</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="string">"["</span> + x + <span class="string">","</span> + y + <span class="string">"]"</span>; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">String</span> <span class="title">toString</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> name; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="title">extends</span> <span class="title">Point</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">String</span> color; </span><br><span class="line"></span><br><span class="line"> ColorPoint(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">String</span> color) &#123; </span><br><span class="line"></span><br><span class="line"> super(x, y); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.color = color; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">String</span> <span class="title">makeName</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> super.makeName() + <span class="string">":"</span> + color; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="keyword">new</span> ColorPoint(<span class="number">4</span>, <span class="number">2</span>, <span class="string">"purple"</span>)); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main 方法创建并打印了一个 ColorPoint 实例。println 方法调用了该</p>
<p>ColorPoint 实例的 toString 方法，这个方法是在 Point 中定义的。toString方法将直接返回 name 域的值，这个值是通过调用 makeName 方法在 Point 的构造</p>
<p>器中被初始化的。对于一个 Point 实例来说，makeName 方法将返回[x,y]形式的</p>
<p>字符串。对于一个 ColorPoint 实例来说，makeName 方法被覆写为返回</p>
<p>[x,y]:color 形式的字符串。在本例中，x 是 4，y 是 2，color 的 purple，因此</p>
<p>程序将打印<a href="null。这个程序出什么问题了呢？">4,2</a>:purple，对吗？不，如果你运行该程序，就会发现它打印的是</p>
<p>这个程序遭遇了实例初始化顺序这一问题。要理解该程序，我们就需要详细跟踪</p>
<p>该程序的执行过程。下面是该程序注释过的版本的列表，用来引导我们了解其执</p>
<p>行顺序： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> x, y; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">String</span> name; <span class="comment">// Cached at construction time </span></span><br><span class="line"></span><br><span class="line"> Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.x = x; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.y = y; </span><br><span class="line"></span><br><span class="line"> name = makeName(); <span class="comment">// 3. Invoke subclass method </span></span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">String</span> <span class="title">makeName</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="string">"["</span> + x + <span class="string">","</span> + y + <span class="string">"]"</span>; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">String</span> <span class="title">toString</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> name; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="title">extends</span> <span class="title">Point</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">String</span> color; </span><br><span class="line"></span><br><span class="line"> ColorPoint(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">String</span> color) &#123; </span><br><span class="line"></span><br><span class="line"> super(x, y); <span class="comment">// 2. Chain to Point constructor </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.color = color; <span class="comment">// 5. Initialize blank final-Too late </span></span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">String</span> <span class="title">makeName</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 4. Executes before subclass constructor body! </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> super.makeName() + <span class="string">":"</span> + color; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 1. Invoke subclass constructor </span></span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="keyword">new</span> ColorPoint(<span class="number">4</span>, <span class="number">2</span>, <span class="string">"purple"</span>)); </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>} 在下面的解释中，括号中的数字引用的就是在上述注释版本的列表中的注释标</p>
<p>号。首先，程序通过调用 ColorPoint 构造器创建了一个 ColorPoint 实例（1）。</p>
<p>这个构造器以链接调用其超类构造器开始，就像所有构造器所做的那样（2）。</p>
<p>超类构造器在构造过程中对该对象的 x 域赋值为 4，对 y 域赋值为 2。然后该超</p>
<p>类构造器调用 makeName，该方法被子类覆写了（3）。 </p>
<p>ColorPoint 中的 makeName 方法（4）是在 ColorPoint 构造器的程序体之前执行</p>
<p>的，这就是问题的核心所在。makeName 方法首先调用 super.makeName，它将返</p>
<p>回我们所期望的<a href="null。这个程序出什么问题了呢？">4,2</a>，然后该方法在此基础上追加字符串“：”和由 color 域</p>
<p>的值所转换成的字符串。但是此刻 color 域的值是什么呢？由于它仍处于待初始</p>
<p>化状态，所以它的值仍旧是缺省值 null。因此，makeName 方法返回的是字符串</p>
<p>“<a href="null。这个程序出什么问题了呢？">4,2</a>:null”。超类构造器将这个值赋给 name 域（3），然后将控制流返回给</p>
<p>子类的构造器。 </p>
<p>这之后子类构造器才将“purple”赋予 color 域（5），但是此刻已经为时过晚</p>
<p>了。color 域已经在超类中被用来初始化 name 域了，并且产生了不正确的值。</p>
<p>之后，子类构造器返回，新创建的 ColorPoint 实例被传递给 println 方法，它</p>
<p>适时地调用了该实例的 toString 方法，这个方法返回的是该实例的 name 域的内</p>
<p>容，即“<a href="null。这个程序出什么问题了呢？">4,2</a>:null”，这也就成为了程序要打印的东西。 </p>
<p>本谜题说明：在一个 final 类型的实例域被赋值之前，存在着取用其值的可能，</p>
<p>而此时它包含的仍旧是其所属类型的缺省值。在某种意义上，本谜题是谜题 49</p>
<p>在实例方面的相似物，谜题 49 是在 final 类型的静态域被赋值之前，取用了它</p>
<p>的值。在这两种情况中，谜题都是因初始化的循环而产生的，在谜题 49 中，是</p>
<p>类的初始化；而在本谜题中，是实例初始化。两种情况都存在着产生极大的混乱</p>
<p>的可能性，但是它们之间有一个重要的差别：循环的类初始化是无法避免的灾难，</p>
<p>但是循环的实例初始化总是可以且总是应该避免的。 </p>
<p>无论何时，只要一个构造器调用了一个已经被其子类覆写了的方法，那么该问题</p>
<p>就会出现，因为以这种方式被调用的方法总是在实例被初始化之前执行。要想避</p>
<p>免这个问题，就千万不要在构造器中调用可覆写的方法，直接调用或间接调用都</p>
<p>不行[EJ Item 15]。这项禁令应该扩展至实例初始器和伪构造器</p>
<p>（pseudoconstructors）readObject 与 clone。（这些方法之所以被称为伪构造</p>
<p>器，是因为它们可以在不调用构造器的情况下创建对象。） </p>
<p>你可以通过惰性初始化 name 域来订正该问题，即当它第一次被使用时初始化，</p>
<p>以此取代积极初始化，即当 Point 实例被创建时初始化。 </p>
<p>通过这种修改，该程序就可以打印出我们期望的<a href="null。这个程序出什么问题了呢？">4,2</a>:purple。 </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> x, y; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">String</span> name; <span class="comment">// Lazily initialized </span></span><br><span class="line"></span><br><span class="line"> Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>.x = x; <span class="keyword">this</span>.y = y; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// name initialization removed </span></span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">String</span> <span class="title">makeName</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="string">"["</span> + x + <span class="string">","</span> + y + <span class="string">"]"</span>; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// Lazily computers and caches name on first use </span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> synchronized <span class="keyword">String</span> <span class="title">toString</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (name == null) </span><br><span class="line"></span><br><span class="line"> name = makeName(); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> name; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管惰性加载可以订正这个问题，但是对于让一个值类去扩展另一个值类，并且</p>
<p>在其中添加一个会对 euqals 比较方法产生影响的域的这种做法仍旧不是一个好</p>
<p>主意。你无法在超类和子类上都提供一个基于值的 equals 方法，而同时又不违</p>
<p>反 Object.equals 方法的通用约定，或者是不消除在超类和子类之间进行有实际</p>
<p>意义的比较操作的可能性[EJ Item 7]。 </p>
<p>循环实例初始化问题对语言设计者来说是问题成堆的地方。C++是通过在构造阶</p>
<p>段将对象的类型从超类类型改变为子类类型来解决这个问题的。如果采用这种解</p>
<p>决方法，本谜题中最开始的程序将打印<a href="null。这个程序出什么问题了呢？">4,2</a>。我们发现没有任何一种流行的语</p>
<p>言能够令人满意地解决这个问题。也许，我们值得去考虑，当超类构造器调用子</p>
<p>类方法时，通过抛出一个不受检查的异常使循环实例初始化非法。 </p>
<p>总之，在任何情况下，你都务必要记住：不要在构造器中调用可覆 写的方法。</p>
<p>在实例初始化中产生的循环将是致命的。该问题的解决方案就是惰性初始化[EJ </p>
<p>Items 13,48]。 </p>
<h2 id="谜题-52：合计数的玩笑"><a href="#谜题-52：合计数的玩笑" class="headerlink" title="谜题 52：合计数的玩笑"></a>谜题 52：合计数的玩笑</h2><p>下面的程序在一个类中计算并缓存了一个合计数，并且在另一个类中打印了这个</p>
<p>合计数。那么，这个程序将打印出什么呢？这里给一点提示：你可能已经回忆起</p>
<p>来了，在代数学中我们曾经学到过，从 1 到 n 的整数总和是 n(n+1)/2。 </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> &#123; </span><br><span class="line"></span><br><span class="line"> initializeIfNecessary(); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sum; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> initializeIfNecessary(); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> sum; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> initialized = <span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> synchronized <span class="keyword">void</span> <span class="title">initializeIfNecessary</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!initialized) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) </span><br><span class="line"></span><br><span class="line"> sum += i; </span><br><span class="line"></span><br><span class="line"> initialized = <span class="literal">true</span>; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(Cache.getSum()); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>草草地看一遍，你可能会认为这个程序从 1 加到了 100，但实际上它并没有这么</p>
<p>做。再稍微仔细地看一看那个循环，它是一个典型的半开循环，因此它将从 0</p>
<p>循环到 99。有了这个印象之后，你可能会认为这个程序打印的是从 0 到 99 的整</p>
<p>数总和。用前面提示中给出的公式，我们知道这个总和是 99×100/2，即 4,950。</p>
<p>但是，这个程序可不这么想，它打印的是 9900，是我们所预期值的整整两倍。</p>
<p>是什么导致它如此热情地翻倍计算了这个总和呢？ </p>
<p>该程序的作者显然在确保 sum 在被使用前就已经在初始化这个问题上，经历了众</p>
<p>多的麻烦。该程序结合了惰性初始化和积极初始化，甚至还用上了同步，以确保</p>
<p>缓存在多线程环境下也能工作。看起来这个程序已经把所有的问题都考虑到了，</p>
<p>但是它仍然不能正常工作。它到底出了什么问题呢？ </p>
<p>与谜题 49 中的程序一样，该程序受到了类初始化顺序问题的影响。为了理解其</p>
<p>行为，我们来跟踪其执行过程。在可以调用 Client.main 之前，VM 必须初始化</p>
<p>Client 类。这项初始化工作异常简单，我们就不多说什么了。Client.main 方法</p>
<p>调用了 Cache.getsum 方法，在 getsum 方法可以被执行之前，VM 必须初始化 Cache</p>
<p>类。 </p>
<p>回想一下，类初始化是按照静态初始器在源代码中出现的顺序去执行这些初始器</p>
<p>的。Cache 类有两个静态初始器：在类顶端的一个 static 语句块，以及静态域</p>
<p>initialized 的初始化。静态语句块是先出现的，它调用了方法</p>
<p>initializeIfNecessary，该方法将测试 initialized 域。因为该域还没有被赋</p>
<p>予任何值，所以它具有缺省的布尔值 false。与此类似，sum 具有缺省的 int 值</p>
<p>0。因此，initializeIfNecessary 方法执行的正是你所期望的行为，将 4,950</p>
<p>添加到了 sum 上，并将 initialized 设置为 true。 </p>
<p>在静态语句块执行之后，initialized 域的静态初始器将其设置回 false，从而</p>
<p>完成 Cache 的类初始化。遗憾的是，sum 现在包含的是正确的缓存值，但是</p>
<p>initialized 包含的却是 false：Cache 类的两个关键状态并未同步。 此后，Client 类的 main 方法调用 Cache.getSum 方法，它将再次调用</p>
<p>initializeIfNecessary 方法。因为 initialized 标志是 false，所以</p>
<p>initializeIfNecessary方法将进入其循环，该循环将把另一个4,950添加到sum</p>
<p>上，从而使其值增加到了 9,900。getSum 方法返回的就是这个值，而程序打印的</p>
<p>也是它。 </p>
<p>很明显，该程序的作者认为 Cache 类的初始化不会以这种顺序发生。由于不能在</p>
<p>惰性初始化和积极初始化之间作出抉择，所以作者同时运用这二者，结果产生了</p>
<p>大麻烦。要么使用积极初始化，要么使用惰性初始化，但是千万不要同时使用二</p>
<p>者。 </p>
<p>如果初始化一个域的时间和空间代价比较低，或者该域在程序的每一次执行中都</p>
<p>需要用到时，那么使用积极初始化是恰当的。如果其代价比较高，或者该域在某</p>
<p>些执行中并不会被用到，那么惰性初始化可能是更好的选择[EJ Item 48]。另外，</p>
<p>惰性初始化对于打破类或实例初始化中的循环也可能是必需的（谜题 51）。 </p>
<p>通过重排静态初始化的顺序，使得 initialized 域在 sum 被初始化之后不被复位</p>
<p>到 false，或者通过移除 initialized 域的显式静态初始化操作，Cache 类就可</p>
<p>以得到修复。尽管这样所产生的程序可以工作，但是它们仍旧是混乱的和病构的。</p>
<p>Cache 类应该被重写为使用积极初始化，这样产生的版本很明显是正确的，而且</p>
<p>比最初的版本更加简单。 </p>
<p>使用这个版本的 Cache 类，程序就可以打印出我们所期望的 4950： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> sum = computeSum(); </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">computeSum</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> result = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) </span><br><span class="line"></span><br><span class="line"> result += i; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> result; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> sum; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，我们使用了一个助手方法来初始化 sum。助手方法通常都优于静态语句</p>
<p>块，因为它让你可以对计算命名。只有在极少的情况下，你才必须使用一个静态</p>
<p>语句块来初始化一个静态域，此时请将该语句块紧随该域声明之后放置。这提高</p>
<p>了程序的清晰度，并且消除了像最初的程序中出现的静态初始化与静态语句块互</p>
<p>相竞争的可能性。 </p>
<p>总之，请考虑类初始化的顺序，特别是当初始化显得很重要时更是如此。请你执</p>
<p>行测试，以确保类初始化序列的简洁。请使用积极初始化，除非你有某种很好的</p>
<p>理由要使用惰性初始化，例如性能方面的因素，或者需要打破初始化循环。</p>
<h2 id="谜题-53：按你的意愿行事-按你的意愿行事"><a href="#谜题-53：按你的意愿行事-按你的意愿行事" class="headerlink" title="谜题 53：按你的意愿行事 按你的意愿行事"></a>谜题 53：按你的意愿行事 按你的意愿行事</h2><p>现在该轮到你写一些代码了。假设你有一个称为 Thing 的库类，它唯一的构造器</p>
<p>将接受一个 int 参数： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Thing</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> Thing(<span class="built_in">int</span> i) &#123; ... &#125; </span><br><span class="line"></span><br><span class="line"> ... </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thing 实例没有提供任何可以获取其构造器参数的值的途径。因为 Thing 是一个</p>
<p>库类，所以你不具有访问其内部的权限，因此你不能修改它。 </p>
<p>假设你想编写一个称为 MyThing 的子类，其构造器将通过调用</p>
<p>SomeOtherClass.func()方法来计算超类构造器的参数。这个方法返回的值被一</p>
<p>个个的调用以不可预知的方式所修改。最后，假设你想将这个曾经传递给超类构</p>
<p>造器的值存储到子类的一个 final 实例域中，以供将来使用。那么下面就是你自</p>
<p>然会写出的代码： </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyThing</span> <span class="keyword">extends</span> <span class="title">Thing</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> int arg; </span><br><span class="line"></span><br><span class="line"> public <span class="type">MyThing</span>() &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">super</span>(arg = <span class="type">SomeOtherClass</span>.func()); </span><br><span class="line"></span><br><span class="line"> ... </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遗憾的是，这个程序是非法的。如果你尝试着去编译它，那么你将得到一条像下</p>
<p>面这样的错误消息： </p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">MyThing</span>.</span></span>java:</span><br><span class="line"></span><br><span class="line">can't reference arg before supertype constructor has been called </span><br><span class="line"></span><br><span class="line"> super(arg = <span class="module-access"><span class="module"><span class="identifier">SomeOtherClass</span>.</span></span>func<span class="literal">()</span>); </span><br><span class="line"></span><br><span class="line"> ^</span><br></pre></td></tr></table></figure>

<p>你怎样才能重写 MyThing 以实现想要的效果呢？MyThing()构造器必须是线程安</p>
<p>全的：多个线程可能会并发地调用它。 </p>
<p>这个解决方案内在地就是线程安全的和优雅的，它涉及对 MyThing 中第二个私有</p>
<p>的构造器的运用： </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyThing</span> <span class="keyword">extends</span> <span class="title">Thing</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> int arg; </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> public <span class="type">MyThing</span>() &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">this</span>(<span class="type">SomeOtherClass</span>.func()); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="type">MyThing</span>(int i) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">super</span>(i); arg = i; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个解决方案使用了交替构造器调用机制（alternate constructor invocation）</p>
<p>[JLS 8.8.7.1]。这个特征允许一个类中的某个构造器链接调用同一个类中的另</p>
<p>一个构造器。在本例中，MyThing()链接调用了私有构造器 MyThing(int)，它执</p>
<p>行了所需的实例初始化。在这个私有构造器中，表达式 SomeOtherClass.func()</p>
<p>的值已经被捕获到了变量 i 中，并且它可以在超类构造器返回之后存储到 final</p>
<p>类型的域 param 中。 </p>
<p>通过本谜题所展示的私有构造器捕获（Private Constructor Capture）惯用法</p>
<p>是一种非常有用的模式，你应该把它添加到你的技巧库中。我们已经看到了某些</p>
<p>真的是很丑陋的代码，它们本来是可以通过使用本模式而避免如此丑陋的。 </p>
<h2 id="谜题-54：Null-与-Void"><a href="#谜题-54：Null-与-Void" class="headerlink" title="谜题 54：Null 与 Void"></a>谜题 54：Null 与 Void</h2><p>下面仍然是经典的 Hello World 程序的另一个变种。那么，这个变种将打印什么</p>
<p>呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Null</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"Hello world!"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> ((Null) null).greet(); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序看起来似乎应该抛出 NullPointerExceptioin 异常，因为其 main 方法</p>
<p>是在常量 null 上调用 greet 方法，而你是不可以在 null 上调用方法的，对吗？</p>
<p>嗯，某些时候是可以的。如果你运次该程序，就会发现它打印出了“Hello </p>
<p>World!” </p>
<p>理解本谜题的关键是 Null.greet是一个静态方法。正如你在谜题48中所看到的，</p>
<p>在静态方法的调用中，使用表达式作为其限定符并非是一个好主意，而这也正是</p>
<p>问题之所在。不仅表达式的值所引用的对象的运行期类型在确定哪一个方法将被</p>
<p>调用时并不起任何作用，而且如果对象有标识的话，其标识也不起任何作用。在</p>
<p>本例中，没有任何对象，但是这并不会造成任何区别。静态方法调用的限定表达</p>
<p>式是可以计算的，但是它的值将被忽略。没有任何要求其值为非空的限制。 </p>
<p>要想消除该程序中的混乱，你可以用它的类作为限定符来调用 greet 方法： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> Null.greet(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而更好的方式是完全消除限定符： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> greet(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，本谜题的教训与谜题 48 的完全相同：要么用某种类型来限定静态方法调</p>
<p>用，要么就压根不要限定它们。对语言设计者来说，应该不允许用表达式来污染</p>
<p>静态方法调用的可能性存在，因为它们只会产生混乱。 </p>
<h2 id="谜题-55：特创论"><a href="#谜题-55：特创论" class="headerlink" title="谜题 55：特创论"></a>谜题 55：特创论</h2><p>某些时候，对于一个类来说，跟踪其创建出来的实例个数会非常用有，其典型实</p>
<p>现是通过让它的构造器递增一个私有静态域来完成的。在下面的程序中，</p>
<p>Creature 类展示了这种技巧，而 Creator 类对其进行了操练，将打印出已经创</p>
<p>建的 Creature 实例的数量。那么，这个程序会打印出什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Creator</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) </span><br><span class="line"></span><br><span class="line"> Creature creature = <span class="keyword">new</span> Creature(); </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(Creature.numCreated()); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creature</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> numCreated = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Creature</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> numCreated++; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">numCreated</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> numCreated; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个捉弄人的问题。该程序看起来似乎应该打印 100，但是它没有打印任何</p>
<p>东西，因为它根本就不能编译。如果你尝试着去编译它，你就会发现编译器的诊</p>
<p>断信息基本没什么用处。下面就是 javac 打印的东西： </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Creator.java:4</span>: not a statement </span><br><span class="line"></span><br><span class="line"> Creature creature = new Creature(); </span><br><span class="line"></span><br><span class="line"> ^</span><br><span class="line"></span><br><span class="line"><span class="attribute">Creator.java:4</span>: ';' expected </span><br><span class="line"></span><br><span class="line"> Creature creature = new Creature(); </span><br><span class="line"></span><br><span class="line"> ^</span><br></pre></td></tr></table></figure>

<p>一个本地变量声明看起来像是一条语句，但是从技术上说，它不是；它应该是一</p>
<p>个本地变量声明语句（local variable declaration statement）[JLS 14.4]。</p>
<p>Java 语言规范不允许一个本地变量声明语句作为一条语句在 for、while 或 do</p>
<p>循环中重复执行[JLS 14.12-14]。一个本地变量声明作为一条语句只能直接出现在一个语句块中。（一个语句块是由一对花括号以及包含在这对花括展中的语句</p>
<p>和声明构成的。） </p>
<p>有两种方式可以订正这个问题。最显而易见的方式是将这个声明至于一个语句块</p>
<p>中： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123; </span><br><span class="line"></span><br><span class="line"> Creature creature = new Creature(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，请注意，该程序没有使用本地变量 creature。因此，将该声明用一个无</p>
<p>任何修饰的构造器调用来替代将更具实际意义，这样可以强调对新创建对象的引</p>
<p>用正在被丢弃： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) </span><br><span class="line"></span><br><span class="line"> new Creature();</span><br></pre></td></tr></table></figure>

<p>无论我们做出了上面的哪种修改，该程序都将打印出我们所期望的 100。 </p>
<p>请注意，用于跟踪 Creature 实例个数的变量（numCreated）是 long 类型而不是</p>
<p>int 类型的。我们很容易想象到，一个程序创建出的某个类的实例可能会多余 int</p>
<p>数值的最大值，但是它不会多于 long 数值的最大值。 </p>
<p>int 数值的最大值是 231-1，即大约 2.1×109，而 long 数值的最大值是 263-1，</p>
<p>即大约 9.2×1018。当前，每秒钟创建 108 个对象是可能的，这意味着一个程序</p>
<p>在 long 类型的对象计数器溢出之前，不得不运行大约三千年。即使是面对硬件</p>
<p>速度的提升，long 类型的对象计数器也应该足以应付可预见的未来。 </p>
<p>还要注意的是，本谜题中的创建计数策略并不是线程安全的。如果多个线程可以</p>
<p>并行地创建对象，那么递增计数器的代码和读取计数器的代码都应该被同步： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread-safe creation counter </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creature</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> numCreated; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Creature</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">synchronized</span> (Creature<span class="class">.<span class="keyword">class</span>) </span>&#123; </span><br><span class="line"></span><br><span class="line"> numCreated++; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">numCreated</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> numCreated; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，如果你使用的是 5.0 或更新的版本，你可以使用一个 AtomicLong 实例，</p>
<p>它在面临并发时可以绕过对同步的需求。 </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread-safe creation counter using AtomicLong; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creature</span> &#123;</span> <span class="keyword">private</span> <span class="keyword">static</span> AtomicLong numCreated = <span class="keyword">new</span> AtomicLong(); </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Creature</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> numCreated.incrementAndGet(); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">numCreated</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> numCreated.<span class="built_in">get</span>(); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，把 numCreated 声明为瞬时的是不足以解决问题的，因为 volatile 修饰</p>
<p>符可以保证其他线程将看到最近赋予该域的值，但是它不能进行原子性的递增操</p>
<p>作。 </p>
<p>总之，一个本地变量声明不能被用作 for、while 或 do 循环中的重复执行语句，</p>
<p>它作为一条语句只能出现在一个语句块中。另外，在使用一个变量来对实例的创</p>
<p>建进行计数时，要使用 long 类型而不是 int 类型的变量，以防止溢出。最后，</p>
<p>如果你打算在多线程中创建实例，要么将对实例计数器的访问进行同步，要么使</p>
<p>用一个 AtomicLong 类型的计数器。 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/20/java%E5%BC%82%E5%B8%B8%E8%B0%9C%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/20/java%E5%BC%82%E5%B8%B8%E8%B0%9C%E9%A2%98/" class="post-title-link" itemprop="url">java异常谜题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-20 22:36:01 / 修改时间：22:45:04" itemprop="dateCreated datePublished" datetime="2021-03-20T22:36:01+08:00">2021-03-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java-谜题-Java-谜题-4——异常谜题"><a href="#Java-谜题-Java-谜题-4——异常谜题" class="headerlink" title="Java 谜题 Java 谜题 4——异常谜题"></a>Java 谜题 Java 谜题 4——异常谜题</h1><h2 id="谜题-36：优柔寡断"><a href="#谜题-36：优柔寡断" class="headerlink" title="谜题 36：优柔寡断"></a>谜题 36：优柔寡断</h2><p>下面这个可怜的小程序并不能很好地做出其自己的决定。它的 decision 方法将</p>
<p>返回 true，但是它还返回了 false。那么，它到底打印的是什么呢？甚至，它是</p>
<p>合法的吗？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Indecisive</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(decision()); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">decision</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line"></span><br><span class="line"> &#125; finally &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能会认为这个程序是不合法的。毕竟，decision 方法不能同时返回 true 和</p>
<p>false。如果你尝试一下，就会发现它编译时没有任何错误，并且它所打印的是</p>
<p>false。为什么呢？ </p>
<p>原因就是在一个 try-finally 语句中，finally 语句块总是在控制权离开 try 语</p>
<p>句块时执行的[JLS 14.20.2]。无论 try 语句块是正常结束的，还是意外结束的，</p>
<p>情况都是如此。一条语句或一个语句块在它抛出了一个异常，或者对某个封闭型</p>
<p>语句执行了一个 break 或 continue，或是象这个程序一样在方法中执行了一个</p>
<p>return 时，将发生意外结束。它们之所以被称为意外结束，是因为它们阻止程</p>
<p>序去按顺序执行下面的语句。 当 try 语句块和 finally 语句块都意外结束时，在 try 语句块中引发意外结束的</p>
<p>原因将被丢弃，而整个 try-finally 语句意外结束的原因将于 finally 语句块意</p>
<p>外结束的原因相同。在这个程序中，在 try 语句块中的 return 语句所引发的意</p>
<p>外结束将被丢弃，而 try-finally 语句意外结束是由 finally 语句块中的 return</p>
<p>造成的。简单地讲，程序尝试着（try）返回（return）true，但是它最终（finally）</p>
<p>返回（return）的是 false。 </p>
<p>丢弃意外结束的原因几乎永远都不是你想要的行为，因为意外结束的最初原因可</p>
<p>能对程序的行为来说会显得更重要。对于那些在 try 语句块中执行 break、</p>
<p>continue 或 return 语句，只是为了使其行为被 finally 语句块所否决掉的程序，</p>
<p>要理解其行为是特别困难的。 </p>
<p>总之，每一个 finally 语句块都应该正常结束，除非抛出的是不受检查的异常。</p>
<p>千万不要用一个 return、break、continue 或 throw 来退出一个 finally 语句块，</p>
<p>并且千万不要允许将一个受检查的异常传播到一个 finally 语句块之外去。 </p>
<p>对于语言设计者，也许应该要求 finally 语句块在未出现不受检查的异常时必须</p>
<p>正常结束。朝着这个目标，try-finally 结构将要求 finally 语句块可以正常结</p>
<p>束[JLS 14.21]。return、break 或 continue 语句把控制权传递到 finally 语句</p>
<p>块之外应该是被禁止的，任何可以引发将被检查异常传播到 finally 语句块之外</p>
<p>的语句也同样应该是被禁止的。 </p>
<h2 id="谜题-37：极端不可思议"><a href="#谜题-37：极端不可思议" class="headerlink" title="谜题 37：极端不可思议"></a>谜题 37：极端不可思议</h2><p>本谜题测试的是你对某些规则的掌握程度，这些规则用于声明从方法中抛出并被</p>
<p>catch 语句块所捕获的异常。下面的三个程序每一个都会打印些什么？不要假设</p>
<p>它们都可以通过编译： </p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Arcane1 &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println(<span class="string">"Hello world"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span>(IOException e) &#123; </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println(<span class="string">"I've never seen </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> println fail!"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Arcane2 &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// If you have nothing nice to say, say nothing</span></span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span>(Exception e) &#123; System.<span class="keyword">out</span>.println(<span class="string">"This can't </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> happen"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Type1 &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> f() throws CloneNotSupportedException; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Type2 &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> f() throws InterruptedException; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Type3 extends Type1, Type2 &#123; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Arcane3 implements Type3 &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> f() &#123; </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println(<span class="string">"Hello world"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123; </span><br><span class="line"></span><br><span class="line"> Type3 t3 = <span class="keyword">new</span> Arcane3(); </span><br><span class="line"></span><br><span class="line"> t3.f(); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个程序，Arcane1，展示了被检查异常的一个基本原则。它看起来应该是可</p>
<p>以编译的：try 子句执行 I/O，并且 catch 子句捕获 IOException 异常。但是这</p>
<p>个程序不能编译，因为 println 方法没有声明会抛出任何被检查异常，而</p>
<p>IOException 却正是一个被检查异常。语言规范中描述道：如果一个 catch 子句</p>
<p>要捕获一个类型为 E 的被检查异常，而其相对应的 try 子句不能抛出 E 的某种子</p>
<p>类型的异常，那么这就是一个编译期错误[JLS 11.2.3]。 </p>
<p>基于同样的理由，第二个程序，Arcane2，看起来应该是不可以编译的，但是它</p>
<p>却可以。它之所以可以编译，是因为它唯一的 catch 子句检查了 Exception。尽</p>
<p>管 JLS 在这一点上十分含混不清，但是捕获 Exception 或 Throwble 的 catch 子</p>
<p>句是合法的，不管与其相对应的 try 子句的内容为何。尽管 Arcane2 是一个合法</p>
<p>的程序，但是 catch 子句的内容永远的不会被执行，这个程序什么都不会打印。 </p>
<p>第三个程序，Arcane3，看起来它也不能编译。方法 f 在 Type1 接口中声明要抛</p>
<p>出被检查异常 CloneNotSupportedException，并且在 Type2 接口中声明要抛出</p>
<p>被检查异常 InterruptedException。Type3 接口继承了 Type1 和 Type2，因此，</p>
<p>看起来在静态类型为Type3的对象上调用方法f时，有潜在可能会抛出这些异常。</p>
<p>一个方法必须要么捕获其方法体可以抛出的所有被检查异常，要么声明它将抛出这些异常。Arcane3 的 main 方法在静态类型为 Type3 的对象上调用了方法 f，但</p>
<p>它对 CloneNotSupportedException 和 InterruptedExceptioin 并没有作这些处</p>
<p>理。那么，为什么这个程序可以编译呢？ </p>
<p>上述分析的缺陷在于对“Type3.f 可以抛出在 Type1.f 上声明的异常和在</p>
<p>Type2.f 上声明的异常”所做的假设。这并不正确，因为每一个接口都限制了方</p>
<p>法 f 可以抛出的被检查异常集合。一个方法可以抛出的被检查异常集合是它所适</p>
<p>用的所有类型声明要抛出的被检查异常集合的交集，而不是合集。因此，静态类</p>
<p>型为 Type3 的对象上的 f 方法根本就不能抛出任何被检查异常。因此，Arcane3</p>
<p>可以毫无错误地通过编译，并且打印 Hello world。 </p>
<p>总之，第一个程序说明了一项基本要求，即对于捕获被检查异常的 catch 子句，</p>
<p>只有在相应的 try 子句可以抛出这些异常时才被允许。第二个程序说明了这项要</p>
<p>求不会应用到的冷僻案例。第三个程序说明了多个继承而来的 throws 子句的交</p>
<p>集，将减少而不是增加方法允许抛出的异常数量。本谜题所说明的行为一般不会</p>
<p>引发难以捉摸的 bug，但是你第一次看到它们时，可能会有点吃惊。 </p>
<h2 id="谜题-38：不受欢迎的宾客-不受欢迎的宾客"><a href="#谜题-38：不受欢迎的宾客-不受欢迎的宾客" class="headerlink" title="谜题 38：不受欢迎的宾客 不受欢迎的宾客"></a>谜题 38：不受欢迎的宾客 不受欢迎的宾客</h2><p>本谜题中的程序所建模的系统，将尝试着从其环境中读取一个用户 ID，如果这</p>
<p>种尝试失败了，则缺省地认为它是一个来宾用户。该程序的作者将面对有一个静</p>
<p>态域的初始化表达式可能会抛出异常的情况。因为 Java 不允许静态初始化操作</p>
<p>抛出被检查异常，所以初始化必须包装在 try-finally 语句块中。那么，下面的</p>
<p>程序会打印出什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnwelcomeGuest</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> GUEST_USER_ID = <span class="number">-1</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> USER_ID; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> USER_ID = getUserIdFromEnvironment(); </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (IdUnavailableException e) &#123; </span><br><span class="line"></span><br><span class="line"> USER_ID = GUEST_USER_ID; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"Logging in as guest"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getUserIdFromEnvironment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> throws IdUnavailableException </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> IdUnavailableException(); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"User ID: "</span> + USER_ID); </span><br><span class="line"></span><br><span class="line"> &#125; &#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IdUnavailableException</span> <span class="title">extends</span> <span class="title">Exception</span> &#123;</span> </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序看起来很直观。对 getUserIdFromEnvironment 的调用将抛出一个异常，</p>
<p>从而使程序将 GUEST_USER_ID(-1L)赋值给 USER_ID，并打印 Loggin in as guest。</p>
<p>然后 main 方法执行，使程序打印 User ID: -1。表象再次欺骗了我们，该程序</p>
<p>并不能编译。如果你尝试着去编译它，你将看到和下面内容类似的一条错误信息： </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">UnwelcomeGuest.java:10</span>: </span><br><span class="line"></span><br><span class="line">variable USER_ID might already have been assigned </span><br><span class="line"></span><br><span class="line"> USER_ID = GUEST_USER_ID; </span><br><span class="line"></span><br><span class="line"> ^</span><br></pre></td></tr></table></figure>

<p>问题出在哪里了？USER_ID 域是一个空 final（blank final），它是一个在声明</p>
<p>中没有进行初始化操作的 final 域[JLS 4.12.4]。很明显，只有在对 USER_ID</p>
<p>赋值失败时，才会在 try 语句块中抛出异常，因此，在 catch 语句块中赋值是相</p>
<p>当安全的。不管怎样执行静态初始化操作语句块，只会对 USER_ID 赋值一次，这</p>
<p>正是空 final 所要求的。为什么编译器不知道这些呢？ </p>
<p>要确定一个程序是否可以不止一次地对一个空 final 进行赋值是一个很困难的</p>
<p>问题。事实上，这是不可能的。这等价于经典的停机问题，它通常被认为是不可</p>
<p>能解决的[Turing 36]。为了能够编写出一个编译器，语言规范在这一点上采用</p>
<p>了保守的方式。在程序中，一个空 final 域只有在它是明确未赋过值的地方才可</p>
<p>以被赋值。规范长篇大论，对此术语提供了一个准确的但保守的定义[JLS 16]。</p>
<p>因为它是保守的，所以编译器必须拒绝某些可以证明是安全的程序。这个谜题就</p>
<p>展示了这样的一个程序。 </p>
<p>幸运的是，你不必为了编写 Java 程序而去学习那些骇人的用于明确赋值的细节。</p>
<p>通常明确赋值规则不会有任何妨碍。如果碰巧你编写了一个真的可能会对一个空</p>
<p>final 赋值超过一次的程序，编译器会帮你指出的。只有在极少的情况下，就像</p>
<p>本谜题一样，你才会编写出一个安全的程序，但是它并不满足规范的形式化要求。</p>
<p>编译器的抱怨就好像是你编写了一个不安全的程序一样，而且你必须修改你的程</p>
<p>序以满足它。 </p>
<p>解决这类问题的最好方式就是将这个烦人的域从空 final 类型改变为普通的</p>
<p>final 类型，用一个静态域的初始化操作替换掉静态的初始化语句块。实现这一</p>
<p>点的最佳方式是重构静态语句块中的代码为一个助手方法： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnwelcomeGuest</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> GUEST_USER_ID = <span class="number">-1</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> USER_ID = getUserIdOrGuest; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> getUserIdOrGuest &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> getUserIdFromEnvironment(); &#125; <span class="keyword">catch</span> (IdUnavailableException e) &#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"Logging in as guest"</span>); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> GUEST_USER_ID; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> ...<span class="comment">// The rest of the program is unchanged </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的这个版本很显然是正确的，而且比最初的版本根据可读性，因为它为了域</p>
<p>值的计算而增加了一个描述性的名字，而最初的版本只有一个匿名的静态初始化</p>
<p>操作语句块。将这样的修改作用于程序，它就可以如我们的期望来运行了。 </p>
<p>总之，大多数程序员都不需要学习明确赋值规则的细节。该规则的作为通常都是</p>
<p>正确的。如果你必须重构一个程序，以消除由明确赋值规则所引发的错误，那么</p>
<p>你应该考虑添加一个新方法。这样做除了可以解决明确赋值问题，还可以使程序</p>
<p>的可读性提高。 </p>
<h2 id="谜题-39：您好，再见！"><a href="#谜题-39：您好，再见！" class="headerlink" title="谜题 39：您好，再见！"></a>谜题 39：您好，再见！</h2><p>下面的程序在寻常的 Hello world 程序中添加了一段不寻常的曲折操作。那么，</p>
<p>它将会打印出什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloGoodbye</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"Hello world"</span>); </span><br><span class="line"></span><br><span class="line"> System.<span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"> &#125; finally &#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"Goodbye world"</span>);</span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序包含两个 println 语句：一个在 try 语句块中，另一个在相应的 finally</p>
<p>语句块中。try 语句块执行它的 println 语句，并且通过调用 System.exit 来提</p>
<p>前结束执行。在此时，你可能希望控制权会转交给 finally 语句块。然而，如果</p>
<p>你运行该程序，就会发现它永远不会说再见：它只打印了 Hello world。这是否</p>
<p>违背了谜题 36 中所解释的原则呢？ </p>
<p>不论 try 语句块的执行是正常地还是意外地结束，finally 语句块确实都会执行。</p>
<p>然而在这个程序中，try 语句块根本就没有结束其执行过程。System.exit 方法</p>
<p>将停止当前线程和所有其他当场死亡的线程。finally 子句的出现并不能给予线</p>
<p>程继续去执行的特殊权限。 当 System.exit 被调用时，虚拟机在关闭前要执行两项清理工作。首先，它执行</p>
<p>所有的关闭挂钩操作，这些挂钩已经注册到了 Runtime.addShutdownHook 上。这</p>
<p>对于释放 VM 之外的资源将很有帮助。务必要为那些必须在 VM 退出之前发生的行</p>
<p>为关闭挂钩。下面的程序版本示范了这种技术，它可以如我们所期望地打印出</p>
<p>Hello world 和 Goodbye world： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloGoodbye1</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"Hello world"</span>); </span><br><span class="line"></span><br><span class="line"> Runtime.getRuntime().addShutdownHook( </span><br><span class="line"></span><br><span class="line"> <span class="keyword">new</span> Thread() &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"Goodbye world"</span>);</span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125;); </span><br><span class="line"></span><br><span class="line"> System.<span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VM 执行在 System.exit 被调用时执行的第二个清理任务与终结器有关。如果</p>
<p>System.runFinalizerOnExit 或它的魔鬼双胞胎 Runtime.runFinalizersOnExit</p>
<p>被调用了，那么 VM 将在所有还未终结的对象上面调用终结器。这些方法很久以</p>
<p>前就已经过时了，而且其原因也很合理。无论什么原因，永远不要调用</p>
<p>System.runFinalizersOnExit 和 Runtime.runFinalizersOnExit：它们属于 Java</p>
<p>类库中最危险的方法之一[ThreadStop]。调用这些方法导致的结果是，终结器会</p>
<p>在那些其他线程正在并发操作的对象上面运行，从而导致不确定的行为或导致死</p>
<p>锁。 </p>
<p>总之，System.exit 将立即停止所有的程序线程，它并不会使 finally 语句块得</p>
<p>到调用，但是它在停止 VM 之前会执行关闭挂钩操作。当 VM 被关闭时，请使用关</p>
<p>闭挂钩来终止外部资源。通过调用 System.halt 可以在不执行关闭挂钩的情况下</p>
<p>停止 VM，但是这个方法很少使用。 </p>
<h2 id="谜题-40：不情愿的构造器-不情愿的构造器"><a href="#谜题-40：不情愿的构造器-不情愿的构造器" class="headerlink" title="谜题 40：不情愿的构造器 不情愿的构造器"></a>谜题 40：不情愿的构造器 不情愿的构造器</h2><p>尽管在一个方法声明中看到一个 throws 子句是很常见的，但是在构造器的声明</p>
<p>中看到一个 throws 子句就很少见了。下面的程序就有这样的一个声明。那么，</p>
<p>它将打印出什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reluctant</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Reluctant internalInstance = <span class="keyword">new</span> Reluctant(); </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Reluctant</span><span class="params">()</span> throws Exception </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"I'm not coming out"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; Reluctant b = <span class="keyword">new</span> Reluctant(); </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"Surprise!"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (Exception ex) &#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"I told you so"</span>);</span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main 方法调用了 Reluctant 构造器，它将抛出一个异常。你可能期望 catch 子</p>
<p>句能够捕获这个异常，并且打印 I told you so。凑近仔细看看这个程序就会发</p>
<p>现，Reluctant 实例还包含第二个内部实例，它的构造器也会抛出一个异常。无</p>
<p>论抛出哪一个异常，看起来 main 中的 catch 子句都应该捕获它，因此预测该程</p>
<p>序将打印 I told you 应该是一个安全的赌注。但是当你尝试着去运行它时，就</p>
<p>会发现它压根没有去做这类的事情：它抛出了 StackOverflowError 异常，为什</p>
<p>么呢？ </p>
<p>与大多数抛出 StackOverflowError 异常的程序一样，本程序也包含了一个无限</p>
<p>递归。当你调用一个构造器时，实例变量的初始化操作将先于构造器的程序体而</p>
<p>运行[JLS 12.5]。在本谜题中， internalInstance 变量的初始化操作递归调用</p>
<p>了构造器，而该构造器通过再次调用 Reluctant 构造器而初始化该变量自己的</p>
<p>internalInstance 域，如此无限递归下去。这些递归调用在构造器程序体获得</p>
<p>执行机会之前就会抛出 StackOverflowError 异常，因为 StackOverflowError</p>
<p>是 Error 的子类型而不是 Exception 的子类型，所以 catch 子句无法捕获它。 </p>
<p>对于一个对象包含与它自己类型相同的实例的情况，并不少见。例如，链接列表</p>
<p>节点、树节点和图节点都属于这种情况。你必须非常小心地初始化这样的包含实</p>
<p>例，以避免 StackOverflowError 异常。 </p>
<p>至于本谜题名义上的题目：声明将抛出异常的构造器，你需要注意，构造器必须</p>
<p>声明其实例初始化操作会抛出的所有被检查异常。下面这个展示了常见的“服务</p>
<p>提供商”模式的程序，将不能编译，因为它违反了这条规则： </p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Class engineClass = ...; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Engine engine = </span><br><span class="line"></span><br><span class="line"> (Engine)enginClass.<span class="keyword">new</span><span class="type">Instance</span>(); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> Car()&#123; &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管其构造器没有任何程序体，但是它将抛出两个被检查异常，</p>
<p>InstantiationException 和 IllegalAccessException。它们是 Class.Instance</p>
<p>抛出的，该方法是在初始化 engine 域的时候被调用的。订正该程序的最好方式</p>
<p>是创建一个私有的、静态的助手方法，它负责计算域的初始值，并恰当地处理异</p>
<p>常。在本案中，我们假设选择 engineClass 所引用的 Class 对象，保证它是可访</p>
<p>问的并且是可实例化的。 </p>
<p>下面的 Car 版本将可以毫无错误地通过编译： //Fixed - instance initializers don’t throw checked exceptions </p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Class engineClass = ...; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Engine engine = <span class="keyword">new</span><span class="type">Engine</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Engine <span class="keyword">new</span><span class="type">Engine</span>() &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> (Engine)engineClass.<span class="keyword">new</span><span class="type">Instance</span>(); </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">AssertionError</span>(e); </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (InstantiationException e) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">AssertionError</span>(e); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> Car()&#123; &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，实例初始化操作是先于构造器的程序体而运行的。实例初始化操作抛出的</p>
<p>任何异常都会传播给构造器。如果初始化操作抛出的是被检查异常，那么构造器</p>
<p>必须声明也会抛出这些异常，但是应该避免这样做，因为它会造成混乱。最后，</p>
<p>对于我们所设计的类，如果其实例包含同样属于这个类的其他实例，那么对这种</p>
<p>无限递归要格外当心。 </p>
<h2 id="谜题-41：域和流"><a href="#谜题-41：域和流" class="headerlink" title="谜题 41：域和流"></a>谜题 41：域和流</h2><p>下面的方法将一个文件拷贝到另一个文件，并且被设计为要关闭它所创建的每一</p>
<p>个流，即使它碰到 I/O 错误也要如此。遗憾的是，它并非总是能够做到这一点。</p>
<p>为什么不能呢，你如何才能订正它呢？ </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span>(<span class="params">String src, String dest</span>) throws IOException</span> &#123; </span><br><span class="line"></span><br><span class="line"> InputStream <span class="keyword">in</span> = <span class="literal">null</span>; </span><br><span class="line"></span><br><span class="line"> OutputStream <span class="keyword">out</span> = <span class="literal">null</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">in</span> = <span class="keyword">new</span> FileInputStream(src); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">out</span> = <span class="keyword">new</span> FileOutputStream(dest); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>]; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> n; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> ((n = <span class="keyword">in</span>.read(buf)) &gt; <span class="number">0</span>) </span><br><span class="line"></span><br><span class="line"> <span class="keyword">out</span>.write(buf, <span class="number">0</span>, n); </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">in</span> != <span class="literal">null</span>) <span class="keyword">in</span>.close(); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">out</span> != <span class="literal">null</span>) <span class="keyword">out</span>.close(); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序看起来已经面面俱到了。其流域（in 和 out）被初始化为 null，并且</p>
<p>新的流一旦被创建，它们马上就被设置为这些流域的新值。对于这些域所引用的流，如果不为空，则 finally 语句块会将其关闭。即便在拷贝操作引发了一个</p>
<p>IOException 的情况下，finally 语句块也会在方法返回之前执行。出什么错了</p>
<p>呢？ </p>
<p>问题在 finally 语句块自身中。close 方法也可能会抛出 IOException 异常。如</p>
<p>果这正好发生在 in.close 被调用之时，那么这个异常就会阻止 out.close 被调</p>
<p>用，从而使输出流仍保持在开放状态。 </p>
<p>请注意，该程序违反了谜题 36 的建议：对 close 的调用可能会导致 finally 语</p>
<p>句块意外结束。遗憾的是，编译器并不能帮助你发现此问题，因为 close 方法抛</p>
<p>出的异常与 read 和 write 抛出的异常类型相同，而其外围方法（copy）声明将</p>
<p>传播该异常。 </p>
<p>解决方式是将每一个 close 都包装在一个嵌套的 try 语句块中。下面的 finally</p>
<p>语句块的版本可以保证在两个流上都会调用 close： </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#125; finally &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">in</span> != <span class="keyword">null</span>) &#123; </span><br><span class="line"></span><br><span class="line"> try &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">in</span>.<span class="keyword">close</span>(); </span><br><span class="line"></span><br><span class="line"> &#125; catch (IOException ex) &#123; </span><br><span class="line"></span><br><span class="line"> // There <span class="keyword">is</span> <span class="keyword">nothing</span> we can <span class="keyword">do</span> <span class="keyword">if</span> <span class="keyword">close</span> fails </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">out</span> != <span class="keyword">null</span>) </span><br><span class="line"></span><br><span class="line"> try &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">out</span>.<span class="keyword">close</span>(); </span><br><span class="line"></span><br><span class="line"> &#125; catch (IOException ex) &#123; </span><br><span class="line"></span><br><span class="line"> // There <span class="keyword">is</span> <span class="keyword">nothing</span> we can <span class="keyword">do</span> <span class="keyword">if</span> <span class="keyword">close</span> fails </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">从 <span class="number">5.0</span> 版本开始，你可以对代码进行重构，以利用 Closeable 接口： </span><br><span class="line"></span><br><span class="line">&#125; finally &#123; </span><br><span class="line"></span><br><span class="line"> closeIgnoringException(<span class="keyword">in</span>); </span><br><span class="line"></span><br><span class="line"> closeIgnoringEcception(<span class="keyword">out</span>); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeIgnoringException</span><span class="params">(Closeable c)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (c != null) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> c.<span class="built_in">close</span>(); </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (IOException ex) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// There is nothing we can do if close fails </span></span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，当你在 finally 语句块中调用 close 方法时，要用一个嵌套的 try-catch</p>
<p>语句来保护它，以防止 IOException 的传播。更一般地讲，对于任何在 finally</p>
<p>语句块中可能会抛出的被检查异常都要进行处理，而不是任其传播。这是谜题</p>
<p>36 中的教训的一种特例，而对语言设计着的教训情况也相同。 </p>
<h2 id="谜题-42：异常为循环而抛-异常为循环而抛"><a href="#谜题-42：异常为循环而抛-异常为循环而抛" class="headerlink" title="谜题 42：异常为循环而抛 异常为循环而抛"></a>谜题 42：异常为循环而抛 异常为循环而抛</h2><p>下面的程序循环遍历了一个 int 类型的数组序列，并且记录了满足某个特定属性</p>
<p>的数组个数。那么，该程序会打印出什么呢？ </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Loop</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="built_in">int</span>[][] tests = &#123; &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">2</span> &#125;,</span><br><span class="line"></span><br><span class="line"> &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;, &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="number">1</span> &#125; &#125;; </span><br><span class="line"></span><br><span class="line"> <span class="built_in">int</span> successCount = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="built_in">int</span> i = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (thirdElementIsThree(tests[i++])) </span><br><span class="line"></span><br><span class="line"> successCount ++; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// No more tests to process </span></span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println(successCount); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> static <span class="built_in">bool</span>ean thirdElementIsThree(<span class="built_in">int</span>[] a) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> a.length &gt;= <span class="number">3</span> &amp; a[<span class="number">2</span>] == <span class="number">3</span>; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序用 thirdElementIsThree 方法测试了 tests 数组中的每一个元素。遍历这</p>
<p>个数组的循环显然是非传统的循环：它不是在循环变量等于数组长度的时候终</p>
<p>止，而是在它试图访问一个并不在数组中的元素时终止。尽管它是非传统的，但</p>
<p>是这个循环应该可以工作。如果传递给 thirdElementIsThree 的参数具有 3 个或</p>
<p>更多的元素，并且其第三个元素等于 3，那么该方法将返回 true。对于 tests</p>
<p>中的 5 个元素来说，有 2 个将返回 true，因此看起来该程序应该打印 2。如果你</p>
<p>运行它，就会发现它打印的时 0。肯定是哪里出了问题，你能确定吗？ </p>
<p>事实上，这个程序犯了两个错误。第一个错误是该程序使用了一种可怕的循环惯</p>
<p>用法，该惯用法依赖的是对数组的访问会抛出异常。这种惯用法不仅难以阅读，</p>
<p>而且运行速度还非常地慢。不要使用异常来进行循环控制；应该只为异常条件而使用异常[EJ Item 39]。为了纠正这个错误，可以将整个 try-finally 语句块替</p>
<p>换为循环遍历数组的标准惯用法： </p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (<span class="name">int</span> i = <span class="number">0</span><span class="comment">; i &lt; test.length; i++) </span></span><br><span class="line"></span><br><span class="line"> if (<span class="name">thirdElementIsThree</span>(<span class="name">tests</span>[i])) </span><br><span class="line"></span><br><span class="line"> successCount++<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>如果你使用的是 5.0 或者是更新的版本，那么你可以用 for 循环结构来代替： </p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (<span class="name">int</span>[] test : tests) </span><br><span class="line"></span><br><span class="line"> if(<span class="name">thirdElementIsThree</span>(<span class="name">test</span>)) </span><br><span class="line"></span><br><span class="line"> successCount++<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>就第一个错误的糟糕情况来说，只有它自己还不足以产生我们所观察到的行为。</p>
<p>然而，订正该错误可以帮助我们找到真正的 bug，它更加深奥： </p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> </span><br><span class="line"></span><br><span class="line">java.lang.ArrayIndexOutOfBoundsException: <span class="number">2</span></span><br><span class="line"></span><br><span class="line"> at <span class="module-access"><span class="module"><span class="identifier">Loop1</span>.</span></span>third<span class="constructor">ElementIsThree(Loop1.<span class="params">java</span>:19)</span> </span><br><span class="line"></span><br><span class="line"> at <span class="module-access"><span class="module"><span class="identifier">Loop1</span>.</span></span>main(<span class="module-access"><span class="module"><span class="identifier">Loop1</span>.</span></span>java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure>

<p>很明显，在 thirdElementIsThree 方法中有一个 bug：它抛出了一个</p>
<p>ArrayIndexOutOfBoundsException 异常。这个异常先前伪装成了那个可怕的基</p>
<p>于异常的循环的终止条件。 </p>
<p>如果传递给 thirdElementIsThree 的参数具有 3 个或更多的元素，并且其第三个</p>
<p>元素等于 3，那么该方法将返回 true。问题是在这些条件不满足时它会做些什么</p>
<p>呢。如果你仔细观察其值将会被返回的那个布尔表达式，你就会发现它与大多数</p>
<p>布尔 AND 操作有一点不一样。这个表达式是 a.length &gt;= 3 &amp; a[2] == 3。通常，</p>
<p>你在这种情况下看到的是 &amp;&amp; 操作符，而这个表达式使用的是 &amp; 操作符。那是</p>
<p>一个位 AND 操作符吗？ </p>
<p>事实证明 &amp; 操作符有其他的含义。除了常见的被当作整型操作数的位 AND 操作</p>
<p>符之外，当被用于布尔操作数时，它的功能被重载为逻辑 AND 操作符[JLS</p>
<p>15.22.2]。这个操作符与更经常被使用的条件 AND 操作符有所不同，&amp; 操作符总</p>
<p>是要计算它的两个操作数，而 &amp;&amp; 操作符在其左边的操作数被计算为 false 时，</p>
<p>就不再计算右边的操作数了[JLS 15.23]。因此，thirdElementIsThree 方法总</p>
<p>是要试图访问其数组参数的第三个元素，即使该数组参数的元素不足 3 个也是如</p>
<p>此。订正这个方法只需将 &amp; 操作符替换为 &amp;&amp; 操作符即可。通过这样的修改，</p>
<p>这个程序就可以打印出我们所期望的 2 了： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="built_in">bool</span>ean thirdElementIsThree(<span class="built_in">int</span>[] a) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> a.length &gt;= <span class="number">3</span> &amp;&amp; a[<span class="number">2</span>] == <span class="number">3</span>; </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>正像有一个逻辑 AND 操作符伴随着更经常被使用的条件 AND 操作符一样，还有一</p>
<p>个逻辑 OR 操作符(|)也伴随着条件 OR 操作符(||)[JLS 15.22.2，15.24]。| 操</p>
<p>作符总是要计算它的两个操作数，而 || 操作符在其左边的操作数被计算为</p>
<p>true 时，就不再计算右边的操作数了。我们一不注意，就很容易使用了逻辑操</p>
<p>作符而不是条件操作符。遗憾的是，编译器并不能帮助你发现这种错误。有意识</p>
<p>地使用逻辑操作符的情形非常少见，少到了我们对所有这样使用的程序都应该持怀疑态度的地步。如果你真的想使用这样的操作符，为了是你的意图清楚起见，</p>
<p>请加上注释。 </p>
<p>总之，不要去用那些可怕的使用异常而不是使用显式的终止测试的循环惯用法，</p>
<p>因为这种惯用法非常不清晰，而且会掩盖 bug。要意识到逻辑 AND 和 OR 操作符</p>
<p>的存在，并且不要因无意识的误用而受害。对语言设计者来说，这又是一个操作</p>
<p>符重载会导致混乱的明证。对于在条件 AND 和 OR 操作符之外还要提供逻辑 AND</p>
<p>和 OR 操作符这一点，并没有很明显的理由。如果这些操作符确实要得到支持的</p>
<p>话，它们应该与其相对应的条件操作符存在着视觉上的明显差异。 </p>
<h2 id="谜题-43：异常地危险"><a href="#谜题-43：异常地危险" class="headerlink" title="谜题 43：异常地危险"></a>谜题 43：异常地危险</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在 JDK1.<span class="number">2</span> 中，<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>stop、<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>suspend 以及其他许多线程相关的方法都</span><br><span class="line"></span><br><span class="line">因为它们不安全而不推荐使用了<span class="literal">[T<span class="identifier">hreadStop</span>]</span>。下面的方法展示了你用</span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>stop 可以实现的可怕事情之一。 </span><br><span class="line"></span><br><span class="line"> <span class="comment">// Don’t do this - circumvents exception checking! </span></span><br><span class="line"></span><br><span class="line"> public static void sneaky<span class="constructor">Throw(Throwable <span class="params">t</span>)</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.stop(t); <span class="comment">// Deprecated!! </span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这个讨厌的小方法所做的事情正是 throw 语句要做的事情，但是它绕过了编译器</p>
<p>的所有异常检查操作。你可以（卑鄙地）在你的代码的任意一点上抛出任何受检</p>
<p>查的或不受检查的异常，而编译器对此连眉头都不会皱一下。 </p>
<p>不使用任何不推荐的方法，你也可以编写出在功能上等价于 sneakyThrow 的方</p>
<p>法。事实上，至少有两种方式可以这么实现这一点，其中一种只能在 5.0 或更新</p>
<p>的版本中运行。你能够编写出这样的方法吗？它必须是用 Java 而不是用 JVM 字</p>
<p>节码编写的，你不能在其客户对它编译完之后再去修改它。你的方法不必是完美</p>
<p>无瑕的：如果它不能抛出一两个 Exception 的子类，也是可以接受的。 </p>
<p>本谜题的一种解决之道是利用 Class.newInstance 方法中的设计缺陷，该方法通</p>
<p>过反射来对一个类进行实例化。引用有关该方法的文档中的话[Java-API]：“请</p>
<p>注意，该方法将传播从空的[换句话说，就是无参数的]构造器所抛出的任何异常，</p>
<p>包括受检查的异常。使用这个方法可以有效地绕开在其他情况下都会执行的编译</p>
<p>期异常检查。”一旦你了解了这一点，编写一个 sneakyThrow 的等价方法就不是</p>
<p>太难了。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thrower</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Throwable t; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">Thrower</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> t; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sneakyThrow</span><span class="params">(Throwable t)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> Thrower.t = t; <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> Thrower<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>; </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (InstantiationException e) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(); </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(); </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line"></span><br><span class="line"> Thrower.t = <span class="keyword">null</span>; <span class="comment">// Avoid memory leak</span></span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个解决方案中将会发生许多微妙的事情。我们想要在构造器执行期间所抛出</p>
<p>的异常不能作为一个参数传递给该构造器，因为 Class.newInstance 调用的是一</p>
<p>个类的无参数构造器。因此，sneakyThrow 方法将这个异常藏匿于一个静态变量</p>
<p>中。为了使该方法是线程安全的，它必须被同步，这使得对其的并发调用将顺序</p>
<p>地使用静态域 t。 </p>
<p>要注意的是，t 这个域在从 finally 语句块中出来时是被赋为空的：这只是因为</p>
<p>该方法虽然是卑鄙的，但这并不意味着它还应该是内存泄漏的。如果这个域不是</p>
<p>被赋为空出来的，那么它阻止该异常被垃圾回收。最后，请注意，如果你让该方</p>
<p>法抛出一个 InstantiationException 或是一个 IllegalAccessException 异常，</p>
<p>它将以抛出一个 IllegalArgumentException 而失败。这是这项技术的一个内在</p>
<p>限制。 </p>
<p>Class.newInstance 的文档继续描述道“Constructor.newInstance 方法通过将</p>
<p>构造器抛出的任何异常都包装在一个（受检查的）InvocationTargetException</p>
<p>异常中而避免了这个问题。”很明显，Class.newInstance 应该是做了相同的处</p>
<p>理，但是纠正这个缺陷已经为时过晚，因为这么做将引入源代码级别的不兼容性，</p>
<p>这将使许多依赖于 Class.newInstance 的程序崩溃。而弃用这个方法也不切实</p>
<p>际，因为它太常用了。当你在使用它时，一定要意识到 Class.newInstance 可以</p>
<p>抛出它没有声明过的受检查异常。 </p>
<p>被添加到 5.0 版本中的“通用类型（generics）”可以为本谜题提供一个完全不</p>
<p>同的解决方案。为了实现最大的兼容性，通用类型是通过类型擦除（type </p>
<p>erasure）来实现的：通用类型信息是在编译期而非运行期检查的[JLS 4.7]。 </p>
<p>下面的解决方案就利用了这项技术： </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Don't do this either - circumvents exception checking! </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TigerThrower&lt;T</span> <span class="keyword">extends</span> <span class="title">Throwable&gt;</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> public static void sneakyThrow(<span class="type">Throwable</span> t) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">new</span> <span class="type">TigerThrower</span>&lt;<span class="type">Error</span>&gt;().sneakyThrow2(t); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> void sneakyThrow2(<span class="type">Throwable</span> t) <span class="keyword">throws</span> <span class="type">T</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> (<span class="type">T</span>) t; &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序在编译时将产生一条警告信息： </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">TigerThrower</span><span class="selector-class">.java</span><span class="selector-pseudo">:7</span><span class="selector-pseudo">:warning</span>: <span class="selector-attr">[unchecked]</span> <span class="selector-tag">unchecked</span> <span class="selector-tag">cast</span> </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">found</span> : <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Throwable</span>, <span class="selector-tag">required</span>: <span class="selector-tag">T</span> </span><br><span class="line"></span><br><span class="line"> <span class="selector-tag">throw</span> (<span class="selector-tag">T</span>) <span class="selector-tag">t</span>; </span><br><span class="line"></span><br><span class="line"> ^</span><br></pre></td></tr></table></figure>

<p>警告信息是编译器所采用的一种手段，用来告诉你：你可能正在搬起石头砸自己</p>
<p>的脚，而且事实也正是如此。“不受检查的转型”警告告诉你这个有问题的转型</p>
<p>将不会在运行时刻受到检查。当你获得了一个不受检查的转型警告时，你应该修</p>
<p>改你的程序以消除它，或者你可以确信这个转型不会失败。如果你不这么做，那</p>
<p>么某个其他的转型可能会在未来不确定的某个时刻失败，而你也就很难跟踪此错</p>
<p>误到其源头了。对于本谜题所示的情况，其情况更糟糕：在运行期抛出的异常可</p>
<p>能与方法的签名不一致。sneakyThrow2 方法正是利用了这一点。 </p>
<p>对平台设计者来说，有好几条教训。在设计诸如反射类库之类在语言之外实现的</p>
<p>类库时， 要保留语言所作的所有承诺。当从头设计一个支持通用类型的平台时，</p>
<p>要考虑强制要求其在运行期的正确性。Java 通用类型工具的设计者可没有这么</p>
<p>做，因为他们受制于通用类库必须能够与现有客户进行互操作的要求。对于违反</p>
<p>方法签名的异常，为了消除其产生的可能性，应该考虑强制在运行期进行异常检</p>
<p>查。 </p>
<p>总之，Java 的异常检查机制并不是虚拟机强制执行的。它只是一个编译期工具，</p>
<p>被设计用来帮助我们更加容易地编写正确的程序，但是在运行期可以绕过它。要</p>
<p>想减少你因为这类问题而被曝光的次数，就不要忽视编译器给出的警告信息。 </p>
<h2 id="谜题-44：切掉类"><a href="#谜题-44：切掉类" class="headerlink" title="谜题 44：切掉类"></a>谜题 44：切掉类</h2><p>请考虑下面的两个类： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Strange1</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> Missing m = <span class="keyword">new</span> Missing(); </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (java.lang.NoClassDefFoundError ex) &#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"Got it!"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Strange2</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> Missing m; <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> m = <span class="keyword">new</span> Missing(); </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (java.lang.NoClassDefFoundError ex) &#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"Got it!"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Strange1 和 Strange2 都用到了下面这个类： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Missing</span> &#123; </span><br><span class="line"></span><br><span class="line"> Missing() &#123; &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你编译所有这三个类，然后在运行 Strange1 和 Strange2 之前删除</p>
<p>Missing.class 文件，你就会发现这两个程序的行为有所不同。其中一个抛出了</p>
<p>一个未被捕获的 NoClassDefFoundError 异常，而另一个却打印出了 Got it! 到</p>
<p>底哪一个程序具有哪一种行为，你又如何去解释这种行为上的差异呢？ </p>
<p>程序 Strange1 只在其 try 语句块中提及 Missing 类型，因此你可能会认为它捕</p>
<p>获 NoClassDefFoundError 异常，并打印 Got it！另一方面，程序 Strange2 在</p>
<p>try 语句块之外声明了一个 Missing 类型的变量，因此你可能会认为所产生的</p>
<p>NoClassDefFoundError 异常不会被捕获。如果你试着运行这些程序，就会看到</p>
<p>它们的行为正好相反：Strange1 抛出了未被捕获的 NoClassDefFoundError 异常，</p>
<p>而 Strange2 却打印出了 Got it！怎样才能解释这些奇怪的行为呢？ </p>
<p>如果你去查看 Java 规范以找出应该抛出 NoClassDefFoundError 异常的地方，那</p>
<p>么你不会得到很多的指导信息。该规范描述道，这个错误可以“在（直接或间接）</p>
<p>使用某个类的程序中的任何地方”抛出[JLS 12.2.1]。当 VM 调用 Strange1 和</p>
<p>Strange2 的 main 方法时，这些程序都间接使用了 Missing 类，因此，它们都在</p>
<p>其权利范围内于这一点上抛出了该错误。 </p>
<p>于是，本谜题的答案就是这两个程序可以依据其实现而展示出各自不同的行为。</p>
<p>但是这并不能解释为什么这些程序在所有我们所知的 Java 实现上的实际行为，</p>
<p>与你所认为的必然行为都正好相反。要查明为什么会是这样，我们需要研究一下</p>
<p>由编译器生成的这些程序的字节码。 </p>
<p>如果你去比较 Strange1 和 Strange2 的字节码，就会发现几乎是一样的。除了类</p>
<p>名之外，唯一的差异就是 catch 语句块所捕获的参数 ex 与 VM 本地变量之间的映</p>
<p>射关系不同。尽管哪一个程序变量被指派给了哪一个 VM 变量的具体细节会因编</p>
<p>译器的不同而有所差异，但是对于和上述程序一样简单的程序来说，这些细节不</p>
<p>太可能会差异很大。下面是通过执行 javap -c Strange1 命令而显示的</p>
<p>Strange1.main 的字节码： </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0</span>: new</span><br><span class="line"></span><br><span class="line"><span class="attribute">3</span>: dup </span><br><span class="line"></span><br><span class="line"><span class="attribute">4</span>: invokespecial #3; //Method Missing."&lt;init&gt;":()V</span><br><span class="line"></span><br><span class="line"><span class="attribute">7</span>: astore_1 8: goto 20 </span><br><span class="line"></span><br><span class="line"><span class="attribute">11</span>: astore_1 </span><br><span class="line"></span><br><span class="line"><span class="attribute">12</span>: getstatic #5; // Field System.out:Ljava/io/PrintStream; </span><br><span class="line"></span><br><span class="line"><span class="attribute">15</span>: ldc #6; // String "Got it!"</span><br><span class="line"></span><br><span class="line"><span class="attribute">17</span>: invokevirtual #7;//Method PrintStream.println: (String); V</span><br><span class="line"></span><br><span class="line"><span class="attribute">20</span>: return </span><br><span class="line"></span><br><span class="line">Exception table:</span><br><span class="line"></span><br><span class="line">from to target type </span><br><span class="line"></span><br><span class="line"> 0 8 11 Class java/lang/NoClassDefFoundError</span><br></pre></td></tr></table></figure>

<p>Strange2.main 相对应的字节码与其只有一条指令不同： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>: astore_2</span><br></pre></td></tr></table></figure>

<p>这是一条将 catch 语句块中的捕获异常存储到捕获参数 ex 中的指令。在</p>
<p>Strange1 中，这个参数是存储在 VM 变量 1 中的，而在 Strange2 中，它是存储</p>
<p>在 VM 变量 2 中的。这就是两个类之间唯一的差异，但是它所造成的程序行为上</p>
<p>的差异是多么地大呀！ </p>
<p>为了运行一个程序，VM 要加载和初始化包含 main 方法的类。在加载和初始化之</p>
<p>间，VM 必须链接（link）类[JLS 12.3]。链接的第一阶段是校验，校验要确保</p>
<p>一个类是良构的，并且遵循语言的语法要求。校验非常关键，它维护着可以将像</p>
<p>Java 这样的安全语言与像 C 或 C++这样的不安全语言区分开的各种承诺。 </p>
<p>在 Strange1 和 Strange2 这两个类中，本地变量 m 碰巧都被存储在 VM 变量 1 中。</p>
<p>两个版本的 main 都有一个连接点，从两个不同位置而来的控制流汇聚于此。该</p>
<p>连接点就是指令 20，即从 main 返回的指令。在正常结束 try 语句块的情况下，</p>
<p>我们执行到指令 8，即 goto 20，从而可以到达指令 20；而对于在 catch 语句块</p>
<p>中结束的情况，我们将执行指令 17，并按顺序执行下去，到达指令 20。 </p>
<p>连接点的存在使得在校验 Strange1 类时产生异常，而在校验 Strange2 类时并不</p>
<p>会产生异常。当校验去执行对 Strange1.main 的流分析（flow analysis）[JLS</p>
<p>12.3.1]时，由于指令 20 可以通过两条不同的路径到达，因此校验器必须合并在</p>
<p>变量 1 中的类型。两种类型是通过计算它们的首个公共超类（first common </p>
<p>superclass）[JVMS 4.9.2]而合并的。两个类的首个公共超类是它们所共有的最</p>
<p>详细而精确的超类。 </p>
<p>在 Strange1.main 方法中，当从指令 8 到达指令 20 时，VM 变量 1 的状态包含了</p>
<p>一个 Missing 类的实例。当从指令 17 到达时，它包含了一个</p>
<p>NoClassDefFoundError 类的实例。为了计算首个公共超类，校验器必须加载</p>
<p>Missing 类以确定其超类。因为 Missing.class 文件已经被删除了，所以校验器</p>
<p>不能加载它，因而抛出了一个 NoClassDefFoundError 异常。请注意，这个异常</p>
<p>是在校验期间、在类被初始化之前，并且在 main 方法开始执行之前很早就抛出</p>
<p>的。这就解释了为什么没有打印出任何关于这个未被捕获异常的跟踪栈信息。 </p>
<p>要想编写一个能够探测出某个类是否丢失的程序，请使用反射来引用类而不要使</p>
<p>用通常的语言结构[EJ Item35]。 下面展示了用这种技巧重写的程序： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Strange</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> Exception</span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> Object m = Class.forName(<span class="string">"Missing"</span>).</span><br><span class="line"></span><br><span class="line"> newInstance(); </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123; </span><br><span class="line"></span><br><span class="line"> System.err.<span class="built_in">println</span>(<span class="string">"Got it!"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，不要对捕获 NoClassDefFoundError 形成依赖。语言规范非常仔细地描述</p>
<p>了类初始化是在何时发生的[JLS 12.4.1]，但是类被加载的时机却显得更加不可</p>
<p>预测。更一般地讲，捕获 Error 及其子类型几乎是完全不恰当的。这些异常是为</p>
<p>那些不能被恢复的错误而保留的。 </p>
<h2 id="谜题-45：令人疲惫不堪的测验"><a href="#谜题-45：令人疲惫不堪的测验" class="headerlink" title="谜题 45：令人疲惫不堪的测验"></a>谜题 45：令人疲惫不堪的测验</h2><p>本谜题将测试你对递归的了解程度。下面的程序将做些什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Workout</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> workHard(); </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"It's nap time."</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">workHard</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> workHard(); </span><br><span class="line"></span><br><span class="line"> &#125; finally &#123; </span><br><span class="line"></span><br><span class="line"> workHard(); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要不是有 try-finally 语句，该程序的行为将非常明显：workHard 方法递归地</p>
<p>调用它自身，直到程序抛出 StackOverflowError，在此刻它以这个未捕获的异</p>
<p>常而终止。但是，try-finally 语句把事情搞得复杂了。当它试图抛出</p>
<p>StackOverflowError 时，程序将会在 finally 语句块的 workHard 方法中终止，</p>
<p>这样，它就递归调用了自己。这看起来确实就像是一个无限循环的秘方，但是这</p>
<p>个程序真的会无限循环下去吗？如果你运行它，它似乎确实是这么做的，但是要</p>
<p>想确认的唯一方式就是分析它的行为。 Java 虚拟机对栈的深度限制到了某个预设的水平。当超过这个水平时，VM 就抛</p>
<p>出 StackOverflowError。为了让我们能够更方便地考虑程序的行为，我们假设</p>
<p>栈的深度为 3，这比它实际的深度要小得多。现在让我们来跟踪其执行过程。 </p>
<p>main 方法调用 workHard，而它又从其 try 语句块中递归地调用了自己，然后它</p>
<p>再一次从其 try 语句块中调用了自己。在此时，栈的深度是 3。当 workHard 方</p>
<p>法试图从其 try 语句块中再次调用自己时，该调用立即就会以</p>
<p>StackOverflowError 而失败。这个错误是在最内部的 finally 语句块中被捕获</p>
<p>的，在此处栈的深度已经达到了 3。在那里，workHard 方法试图递归地调用它自</p>
<p>己，但是该调用却以 StackOverflowError 而失败。这个错误将在上一级的</p>
<p>finally 语句块中被捕获，在此处站的深度是 2。该 finally 中的调用将与相对</p>
<p>应的 try 语句块具有相同的行为：最终都会产生一个 StackOverflowError。这</p>
<p>似乎形成了一种模式，而事实也确实如此。 </p>
<p>WorkOut 的运行过程如左面的图所示。在这张图中，对 workHard 的调用用</p>
<p>箭头表示，workHard 的执行用圆圈表示。所有的调用除了一个之外，都是递归</p>
<p>的。会立即产生 StackOverflowError 异常的调用用由灰色圆圈前导的箭头表示，</p>
<p>try 语句块中的调用用向左边的向下箭头表示，finally 语句块中的调用用向右</p>
<p>边的向下箭头表示。箭头上的数字描述了调用的顺序。 </p>
<p>这张图展示了一个深度为 0 的调用（即 main 中的调用），两个深度为 1 的调用，</p>
<p>四个深度为 2 的调用，和八个深度为 3 的调用，总共是 15 个调用。那八个深度</p>
<p>为 3 的调用每一个都会立即产生 StackOverflowError。至少在把栈的深度限制</p>
<p>为 3 的 VM 上，该程序不会是一个无限循环：它在 15 个调用和 8 个异常之后就会</p>
<p>终止。但是对于真实的 VM 又会怎样呢？它仍然不会是一个无限循环。其调用图</p>
<p>与前面的图相似，只不过要大得多得多而已。 </p>
<p>那么，究竟大到什么程度呢？有一个快速的试验表明许多 VM 都将栈的深度限制</p>
<p>为 1024，因此，调用的数量就是 1+2+4+8…+21,024=21,025-1，而抛出的异常的</p>
<p>数量是 21,024。假设我们的机器可以在每秒钟内执行 1010 个调用，并产生 1010</p>
<p>个异常，按照当前的标准，这个假设的数量已经相当高了。在这样的假设条件下，</p>
<p>程序将在大约 1.7×10291 年后终止。为了让你对这个时间有直观的概念，我告</p>
<p>诉你，我们的太阳的生命周期大约是 1010 年，所以我们可以很确定，我们中没</p>
<p>有任何人能够看到这个程序终止的时刻。尽管它不是一个无限循环，但是它也就</p>
<p>算是一个无限循环吧。 </p>
<p>从技术角度讲，调用图是一棵完全二叉树，它的深度就是 VM 的栈深度的上限。</p>
<p>WorkOut 程序的执行过程等于是在先序遍历这棵树。在先序遍历中，程序先访问</p>
<p>一个节点，然后递归地访问它的左子树和右子树。对于树中的每一条边，都会产</p>
<p>生一个调用，而对于树中的每一个节点，都会抛出一个异常。 </p>
<p>本谜题没有很多关于教训方面的东西。它证明了指数算法对于除了最小输入之外</p>
<p>的所有情况都是不可行的，它还表明了你甚至可以不费什么劲就可以编写出一个</p>
<p>指数算法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/20/java%E5%BE%AA%E7%8E%AF%E8%B0%9C%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/20/java%E5%BE%AA%E7%8E%AF%E8%B0%9C%E9%A2%98/" class="post-title-link" itemprop="url">java循环谜题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-20 22:27:03 / 修改时间：22:32:02" itemprop="dateCreated datePublished" datetime="2021-03-20T22:27:03+08:00">2021-03-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java-谜题-Java-谜题-3——循环谜题"><a href="#Java-谜题-Java-谜题-3——循环谜题" class="headerlink" title="Java 谜题 Java 谜题 3——循环谜题"></a>Java 谜题 Java 谜题 3——循环谜题</h1><h2 id="谜题-24：尽情享受每一个字节-尽情享受每一个字节"><a href="#谜题-24：尽情享受每一个字节-尽情享受每一个字节" class="headerlink" title="谜题 24：尽情享受每一个字节 尽情享受每一个字节"></a>谜题 24：尽情享受每一个字节 尽情享受每一个字节</h2><p>下面的程序循环遍历 byte 数值，以查找某个特定值。这个程序会打印出什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDelight</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">byte</span> b = Byte.MIN_VALUE; b &lt; Byte.MAX_VALUE; b++) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (b == <span class="number">0x90</span>) </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">print</span>(<span class="string">"Joy!"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个循环在除了 Byte.MAX_VALUE 之外所有的 byte 数值中进行迭代，以查找</p>
<p>0x90。这个数值适合用 byte 表示，并且不等于 Byte.MAX_VALUE，因此你可能会</p>
<p>想这个循环在该迭代会找到它一次，并将打印出 Joy!。但是，所见为虚。如果</p>
<p>你运行该程序，就会发现它没有打印任何东西。怎么回事？ </p>
<p>简单地说，0x90 是一个 int 常量，它超出了 byte 数值的范围。这与直觉是相悖</p>
<p>的，因为 0x90 是一个两位的十六进制字面常量，每一个十六进制位都占据 4 个</p>
<p>比特的位置，所以整个数值也只占据 8 个比特，即 1 个 byte。问题在于 byte 是</p>
<p>有符号类型。常量 0x90 是一个正的最高位被置位的 8 位 int 数值。合法的 byte</p>
<p>数值是从-128 到+127，但是 int 常量 0x90 等于+144。 </p>
<p>拿一个 byte 与一个 int 进行的比较是一个混合类型比较（mixed-type </p>
<p>comparison）。如果你把 byte 数值想象为苹果，把 int 数值想象成为桔子，那</p>
<p>么该程序就是在拿苹果与桔子比较。请考虑表达式((byte)0x90 == 0x90)，尽管</p>
<p>外表看起来是成立的，但是它却等于 false。 </p>
<p>为了比较 byte 数值(byte)0x90 和 int 数值 0x90，Java 通过拓宽原始类型转换</p>
<p>将 byte 提升为一个 int[JLS 5.1.2]，然后比较这两个 int 数值。因为 byte 是</p>
<p>一个有符号类型，所以这个转换执行的是符号扩展，将负的 byte 数值提升为了</p>
<p>在数字上相等的 int 数值。在本例中，该转换将(byte)0x90 提升为 int 数值-112，</p>
<p>它不等于 int 数值 0x90，即+144。 </p>
<p>由于系统总是强制地将一个操作数提升到与另一个操作数相匹配的类型，所以混</p>
<p>合类型比较总是容易把人搞糊涂。这种转换是不可视的，而且可能不会产生你所</p>
<p>期望的结果。有若干种方法可以避免混合类型比较。我们继续有关水果的比喻，你可以选择拿苹果与苹果比较，或者是拿桔子与桔子比较。你可以将 int 转型为</p>
<p>byte，之后你就可以拿一个 byte 与另一个 byte 进行比较了： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (b == (<span class="keyword">byte</span>)<span class="number">0x90</span>) </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"Joy!"</span>);</span><br></pre></td></tr></table></figure>

<p>或者，你可以用一个屏蔽码来消除符号扩展的影响，从而将 byte 转型为 int，</p>
<p>之后你就可以拿一个 int 与另一个 int 进行比较了： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((b &amp; <span class="number">0xff</span>) == <span class="number">0x90</span>) </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.print(<span class="string">"Joy!"</span>);</span><br></pre></td></tr></table></figure>

<p>上面的两个解决方案都可以正常运行，但是避免这类问题的最佳方法还是将常量</p>
<p>值移出到循环的外面，并将其在一个常量声明中定义它。下面是我们对此作出的</p>
<p>第一个尝试： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDelight</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> TARGET = <span class="number">0x90</span>; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">byte</span> b = Byte.MIN_VALUE; b &lt; </span><br><span class="line"></span><br><span class="line"> Byte.MAX_VALUE; b++) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (b == TARGET) </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">print</span>(<span class="string">"Joy!"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遗憾的是，它根本就通不过编译。常量声明有问题，编译器会告诉你问题所在：</p>
<p>0x90 对于 byte 类型来说不是一个有效的数值。如果你想下面这样订正该声明，</p>
<p>那么程序将运行得非常好： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> TARGET = (<span class="keyword">byte</span>)<span class="number">0x90</span>;</span><br></pre></td></tr></table></figure>

<p>总之，要避免混合类型比较，因为它们内在地容易引起混乱（谜题 5）。为了帮</p>
<p>助实现这个目标，请使用声明的常量替代“魔幻数字”。你已经了解了这确实是</p>
<p>一个好主意：它说明了常量的含义，集中了常量的定义，并且根除了重复的定义。</p>
<p>现在你知道它还可以强制你去为每一个常量赋予适合其用途的类型，从而消除了</p>
<p>产生混合类型比较的一种根源。 </p>
<p>对语言设计的教训是 byte 数值的符号扩展是产生 bug 和混乱的一种常见根源。</p>
<p>而用来抵销符号扩展效果所需的屏蔽机制会使得程序显得混乱无序，从而降低了</p>
<p>程序的可读性。因此，byte 类型应该是无符号的。还可以考虑为所有的原始类</p>
<p>型提供定义字面常量的机制，这可以减少对易于产生错误的类型转换的需求（谜</p>
<p>题 27）。 </p>
<h2 id="谜题-25：无情的增量操作-无情的增量操作"><a href="#谜题-25：无情的增量操作-无情的增量操作" class="headerlink" title="谜题 25：无情的增量操作 无情的增量操作"></a>谜题 25：无情的增量操作 无情的增量操作</h2><p>下面的程序对一个变量重复地进行增量操作，然后打印它的值。那么这个值是什</p>
<p>么呢？ </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Increment</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123; <span class="built_in">int</span> j = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) </span><br><span class="line"></span><br><span class="line"> j = j++; </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println(j); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乍一看，这个程序可能会打印 100。毕竟，它对 j 做了 100 次增量操作。可能会</p>
<p>令你感到有些震惊，它打印的不是 100 而是 0。所有的增量操作都无影无踪了，</p>
<p>为什么？ </p>
<p>就像本谜题的题目所暗示的，问题出在了执行增量操作的语句上： </p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">j</span> = j++<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>大概该语句的作者是想让它执行对 j 的值加 1 的操作，也就是表达式 j++所做的</p>
<p>操作。遗憾的是，作者大咧咧地将这个表达式的值有赋回给了 j。 </p>
<p>当++操作符被置于一个变量值之后时，其作用就是一个后缀增量操作符（postfix</p>
<p>increment operator）[JLS 15.14.2]：表达式 j++的值等于 j 在执行增量操作</p>
<p>之前的初始值。因此，前面提到的赋值语句首先保存 j 的值，然后将 j 设置为其</p>
<p>值加 1，最后将 j 复位到它的初始值。换句话说，这个赋值操作等价于下面的语</p>
<p>句序列： </p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int tmp</span> = j; </span><br><span class="line"></span><br><span class="line"><span class="attribute">j</span> = j + 1; </span><br><span class="line"></span><br><span class="line"><span class="attribute">j</span> = tmp?;</span><br></pre></td></tr></table></figure>

<p>程序重复该过程 100 次，之后 j 的值还是等于它在循环开始之前的值，即 0。 </p>
<p>订正该程序非常简单，只需从循环中移除无关的赋值操作，只留下： </p>
<p>for (int i = 0; i &lt; 100; i++) </p>
<p> j++;</p>
<p>经过这样的修改，程序就可以打印出我们所期望的 100 了。 </p>
<p>这与谜题 7 中的教训相同：不要在单个的表达式中对相同的变量赋值超过一次。</p>
<p>对相同的变量进行多次赋值的表达式会产生混淆，并且很少能够产生你希望的行</p>
<p>为。 </p>
<h2 id="谜题-26：在循环中"><a href="#谜题-26：在循环中" class="headerlink" title="谜题 26：在循环中"></a>谜题 26：在循环中</h2><p>下面的程序计算了一个循环的迭代次数，并且在该循环终止时将这个计数值打印</p>
<p>了出来。那么，它打印的是什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InTheLoop</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> END = Integer.MAX_VALUE; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> START = END - <span class="number">100</span>; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = START; i &lt;= END; i++) </span><br><span class="line"></span><br><span class="line"> count++; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(count); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你没有非常仔细地查看这个程序，你可能会认为它将打印 100，因为 END 比</p>
<p>START 大 100。如果你稍微仔细一点，你可能会发现该程序没有使用典型的循环</p>
<p>惯用法。大多数的循环会在循环索引小于终止值时持续运行，而这个循环则是在</p>
<p>循环索引小于或等于终止值时持续运行。所以它会打印 101，对吗？ </p>
<p>嗯，根本不对。如果你运行该程序，就会发现它压根就什么都没有打印。更糟的</p>
<p>是，它会持续运行直到你撤销它为止。它从来都没有机会去打印 count，因为在</p>
<p>打印它的语句之前插入的是一个无限循环。 </p>
<p>问题在于这个循环会在循环索引（i）小于或等于 Integer.MAX_VALUE 时持续运</p>
<p>行，但是所有的 int 变量都是小于或等于 Integer.MAX_VALUE 的。因为它被定义</p>
<p>为所有 int 数值中的最大值。当 i 达到 Integer.MAX_VALUE，并且再次被执行增</p>
<p>量操作时，它就有绕回到了 Integer.MIN_VALUE。 </p>
<p>如果你需要的循环会迭代到 int 数值的边界附近时，你最好是使用一个 long 变</p>
<p>量作为循环索引。只需将循环索引的类型从 int 改变为 long 就可以解决该问题，</p>
<p>从而使程序打印出我们所期望的 101： </p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (long <span class="built_in">i</span> = START; <span class="built_in">i</span> &lt;= END; <span class="built_in">i</span>++)</span><br></pre></td></tr></table></figure>

<p>更一般地讲，这里的教训就是 int 不能表示所有的整数。无论你在何时使用了一</p>
<p>个整数类型，都要意识到其边界条件。如果其数值下溢或是上溢了，会怎么样呢？</p>
<p>所以通常最好是使用一个取之范围更大的类型。（整数类型包括 byte、char、</p>
<p>short、int 和 long。） </p>
<p>不使用 long 类型的循环索引变量也可以解决该问题，但是它看起来并不那么漂</p>
<p>亮： </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="keyword">START</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line"></span><br><span class="line"> count++; </span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span> (i++ != <span class="keyword">END</span>);</span><br></pre></td></tr></table></figure>

<p>如果清晰性和简洁性占据了极其重要的地位，那么在这种情况下使用一个 long</p>
<p>类型的循环索引几乎总是最佳方案。 </p>
<p>但是有一个例外：如果你在所有的（或者几乎所有的）int 数值上迭代，那么使</p>
<p>用 int 类型的循环索引的速度大约可以提高一倍。下面是将 f 函数作用于所有</p>
<p>40 亿个 int 数值上的惯用法： //Apply the function f to all four billion int values </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="type">Integer</span>.MIN_VALUE; </span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line"></span><br><span class="line"> f(i); </span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span> (i++ != <span class="type">Integer</span>.MAX_VALUE);</span><br></pre></td></tr></table></figure>

<p>该谜题对语言设计者的教训与谜题 3 相同：可能真的值得去考虑，应该对那些不</p>
<p>会在产生溢出时而不抛出异常的算术运算提供支持。同时，可能还值得去考虑，</p>
<p>应该对那些在整数值范围之上进行迭代的循环进行特殊设计，就像许多其他语言</p>
<p>所做的那样。 </p>
<h2 id="谜题-27：变幻莫测的-i-值"><a href="#谜题-27：变幻莫测的-i-值" class="headerlink" title="谜题 27：变幻莫测的 i 值"></a>谜题 27：变幻莫测的 i 值</h2><p>与谜题 26 中的程序一样，下面的程序也包含了一个记录在终止前有多少次迭代</p>
<p>的循环。与那个程序不同的是，这个程序使用的是左移操作符（&lt;&lt;）。你的任务</p>
<p>照旧是要指出这个程序将打印什么。当你阅读这个程序时，请记住 Java 使用的</p>
<p>是基于 2 的补码的二进制算术运算，因此-1 在任何有符号的整数类型中（byte、</p>
<p>short、int 或 long）的表示都是所有的位被置位： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Shifty</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="built_in">int</span> i = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (<span class="number">-1</span> &lt;&lt; i != <span class="number">0</span>) </span><br><span class="line"></span><br><span class="line"> i++;</span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println(i); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常量-1 是所有 32 位都被置位的 int 数值（0xffffffff）。左移操作符将 0 移入</p>
<p>到由移位所空出的右边的最低位，因此表达式（-1 &lt;&lt; i）将 i 最右边的位设置</p>
<p>为 0，并保持其余的 32 - i 位为 1。很明显，这个循环将完成 32 次迭代，因为</p>
<p>-1 &lt;&lt; i 对任何小于 32 的 i 来说都不等于 0。你可能期望终止条件测试在 i 等于</p>
<p>32 时返回 false，从而使程序打印 32，但是它打印的并不是 32。实际上，它不</p>
<p>会打印任何东西，而是进入了一个无限循环。 </p>
<p>问题在于（-1 &lt;&lt; 32）等于-1 而不是 0，因为移位操作符之使用其右操作数的低</p>
<p>5 位作为移位长度。或者是低 6 位，如果其左操作数是一个 long 类数值[JLS</p>
<p>15.19]。 </p>
<p>这条规则作用于全部的三个移位操作符：&lt;&lt;、&gt;&gt;和&gt;&gt;&gt;。移位长度总是介于 0 到</p>
<p>31 之间，如果左操作数是 long 类型的，则介于 0 到 63 之间。这个长度是对 32</p>
<p>取余的，如果左操作数是 long 类型的，则对 64 取余。如果试图对一个 int 数值</p>
<p>移位 32 位，或者是对一个 long 数值移位 64 位，都只能返回这个数值自身的值。</p>
<p>没有任何移位长度可以让一个 int 数值丢弃其所有的 32 位，或者是让一个 long</p>
<p>数值丢弃其所有的 64 位。 幸运的是，有一个非常容易的方式能够订正该问题。我们不是让-1 重复地移位</p>
<p>不同的移位长度，而是将前一次移位操作的结果保存起来，并且让它在每一次迭</p>
<p>代时都向左再移 1 位。下面这个版本的程序就可以打印出我们所期望的 32： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Shifty</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="built_in">int</span> distance = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="built_in">int</span> val = <span class="number">-1</span>; val != <span class="number">0</span>; val &lt;&lt;= <span class="number">1</span>) </span><br><span class="line"></span><br><span class="line"> distance++; </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println(distance); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个订正过的程序说明了一条普遍的原则：如果可能的话，移位长度应该是常量。</p>
<p>如果移位长度紧盯着你不放，那么你让其值超过 31，或者如果左操作数是 long</p>
<p>类型的，让其值超过 63 的可能性就会大大降低。当然，你并不可能总是可以使</p>
<p>用常量的移位长度。当你必须使用一个非常量的移位长度时，请确保你的程序可</p>
<p>以应付这种容易产生问题的情况，或者压根就不会碰到这种情况。 </p>
<p>前面提到的移位操作符的行为还有另外一个令人震惊的结果。很多程序员都希望</p>
<p>具有负的移位长度的右移操作符可以起到左移操作符的作用，反之亦然。但是情</p>
<p>况并非如此。右移操作符总是起到右移的作用，而左移操作符也总是起到左移的</p>
<p>作用。负的移位长度通过只保留低 5 位而剔除其他位的方式被转换成了正的移位</p>
<p>长度——如果左操作数是 long 类型的，则保留低 6 位。因此，如果要将一个 int</p>
<p>数值左移，其移位长度为-1，那么移位的效果是它被左移了 31 位。 </p>
<p>总之，移位长度是对 32 取余的，或者如果左操作数是 long 类型的，则对 64 取</p>
<p>余。因此，使用任何移位操作符和移位长度，都不可能将一个数值的所有位全部</p>
<p>移走。同时，我们也不可能用右移操作符来执行左移操作，反之亦然。如果可能</p>
<p>的话，请使用常量的移位长度，如果移位长度不能设为常量，那么就要千万当心。 </p>
<p>语言设计者可能应该考虑将移位长度限制在从 0 到以位为单位的类型尺寸的范</p>
<p>围内，并且修改移位长度为类型尺寸时的语义，让其返回 0。尽管这可以避免在</p>
<p>本谜题中所展示的混乱情况，但是它可能会带来负面的执行结果，因为 Java 的</p>
<p>移位操作符的语义正是许多处理器上的移位指令的语义。 </p>
<h2 id="谜题-28：循环者"><a href="#谜题-28：循环者" class="headerlink" title="谜题 28：循环者"></a>谜题 28：循环者</h2><p>下面的谜题以及随后的五个谜题对你来说是扭转了局面，它们不是向你展示某些</p>
<p>代码，然后询问你这些代码将做些什么，它们要让你去写代码，但是数量会很少。</p>
<p>这些谜题被称为“循环者（looper）”。你眼前会展示出一个循环，它看起来应</p>
<p>该很快就终止的，而你的任务就是写一个变量声明，在将它作用于该循环之上时，</p>
<p>使得该循环无限循环下去。例如，考虑下面的 for 循环： </p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int <span class="built_in">i</span> = start; <span class="built_in">i</span> &lt;= start + <span class="number">1</span>; <span class="built_in">i</span>++) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>看起来它好像应该只迭代两次，但是通过利用在谜题 26 中所展示的溢出行为，</p>
<p>可以使它无限循环下去。下面的的声明就采用了这项技巧： </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> start = <span class="type">Integer</span>.MAX_VALUE - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>现在该轮到你了。什么样的声明能够让下面的循环变成一个无限循环？ </p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">While</span> (i == i + <span class="number">1</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>仔细查看这个 while 循环，它真的好像应该立即终止。一个数字永远不会等于它</p>
<p>自己加 1，对吗？嗯，如果这个数字是无穷大的，又会怎样呢？Java 强制要求使</p>
<p>用 IEEE 754 浮点数算术运算[IEEE 754]，它可以让你用一个 double 或 float</p>
<p>来表示无穷大。正如我们在学校里面学到的，无穷大加 1 还是无穷大。如果 i</p>
<p>在循环开始之前被初始化为无穷大，那么终止条件测试(i == i + 1)就会被计算</p>
<p>为 true，从而使循环永远都不会终止。 </p>
<p>你可以用任何被计算为无穷大的浮点算术表达式来初始化 i，例如： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> i = <span class="number">1.0</span> / <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>

<p>不过，你最好是能够利用标准类库为你提供的常量： </p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> i = <span class="keyword">Double</span>.POSITIVE_INFINITY;</span><br></pre></td></tr></table></figure>

<p>事实上，你不必将 i 初始化为无穷大以确保循环永远执行。任何足够大的浮点数</p>
<p>都可以实现这一目的，例如： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> i = <span class="number">1.0e40</span>;</span><br></pre></td></tr></table></figure>

<p>这样做之所以可以起作用，是因为一个浮点数值越大，它和其后继数值之间的间</p>
<p>隔就越大。浮点数的这种分布是用固定数量的有效位来表示它们的必然结果。对</p>
<p>一个足够大的浮点数加 1 不会改变它的值，因为 1 是不足以“填补它与其后继者</p>
<p>之间的空隙”。 </p>
<p>浮点数操作返回的是最接近其精确的数学结果的浮点数值。一旦毗邻的浮点数值</p>
<p>之间的距离大于 2，那么对其中的一个浮点数值加 1 将不会产生任何效果，因为</p>
<p>其结果没有达到两个数值之间的一半。对于 float 类型，加 1 不会产生任何效果</p>
<p>的最小级数是 2</p>
<p>25，即 33,554,432；而对于 double 类型，最小级数是 2</p>
<p>54，大约</p>
<p>是 1.8 × 1016。 </p>
<p>毗邻的浮点数值之间的距离被称为一个 ulp，它是“最小单位（unit in the last </p>
<p>place）”的首字母缩写词。在 5.0 版中，引入了 Math.ulp 方法来计算 float</p>
<p>或 double 数值的 ulp。 </p>
<p>总之，用一个 double 或一个 float 数值来表示无穷大是可以的。大多数人在第</p>
<p>一次听到这句话时，多少都会有一点吃惊，可能是因为我们无法用任何整数类型</p>
<p>来表示无穷大的原因。第二点，将一个很小的浮点数加到一个很大的浮点数上时，</p>
<p>将不会改变大的浮点数的值。这过于违背直觉了，因为对实际的数字来说这是不</p>
<p>成立的。我们应该记住二进制浮点算术只是对实际算术的一种近似。 </p>
<h2 id="谜题-29：循环者的新娘"><a href="#谜题-29：循环者的新娘" class="headerlink" title="谜题 29：循环者的新娘"></a>谜题 29：循环者的新娘</h2><p>请提供一个对 i 的声明，将下面的循环转变为一个无限循环： while (i != i) { </p>
<p>} </p>
<p>这个循环可能比前一个还要使人感到困惑。不管在它前面作何种声明，它看起来</p>
<p>确实应该立即终止。一个数字总是等于它自己，对吗？ </p>
<p>对，但是 IEEE 754 浮点算术保留了一个特殊的值用来表示一个不是数字的数量</p>
<p>[IEEE 754]。这个值就是 NaN（“不是一个数字（Not a Number）”的缩写），</p>
<p>对于所有没有良好的数字定义的浮点计算，例如 0.0/0.0，其值都是它。规范中</p>
<p>描述道，NaN 不等于任何浮点数值，包括它自身在内[JLS 15.21.1]。因此，如</p>
<p>果 i 在循环开始之前被初始化为 NaN，那么终止条件测试(i != i)的计算结果就</p>
<p>是 true，循环就永远不会终止。很奇怪但却是事实。 </p>
<p>你可以用任何计算结果为 NaN 的浮点算术表达式来初始化 i，例如： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> i = <span class="number">0.0</span> / <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>

<p>同样，为了表达清晰，你可以使用标准类库提供的常量： </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> i = <span class="type">Double</span>.<span class="keyword">NaN</span>;</span><br></pre></td></tr></table></figure>

<p>NaN 还有其他的惊人之处。任何浮点操作，只要它的一个或多个操作数为 NaN，</p>
<p>那么其结果为 NaN。这条规则是非常合理的，但是它却具有奇怪的结果。例如，</p>
<p>下面的程序将打印 false： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Test</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="built_in">double</span> i = <span class="number">0.0</span> / <span class="number">0.0</span>; </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println(i - i == <span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这条计算 NaN 的规则所基于的原理是：一旦一个计算产生了 NaN，它就被损坏了，</p>
<p>没有任何更进一步的计算可以修复这样的损坏。NaN 值意图使受损的计算继续执</p>
<p>行下去，直到方便处理这种情况的地方为止。 </p>
<p>总之，float 和 double 类型都有一个特殊的 NaN 值，用来表示不是数字的数量。</p>
<p>对于涉及 NaN 值的计算，其规则很简单也很明智，但是这些规则的结果可能是违</p>
<p>背直觉的。 </p>
<h2 id="谜题-30：循环者的爱子"><a href="#谜题-30：循环者的爱子" class="headerlink" title="谜题 30：循环者的爱子"></a>谜题 30：循环者的爱子</h2><p>请提供一个对 i 的声明，将下面的循环转变为一个无限循环： </p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">i</span> != <span class="built_in">i</span> + <span class="number">0</span>) &#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与前一个谜题不同，你必须在你的答案中不使用浮点数。换句话说，你不能把 i</p>
<p>声明为 double 或 float 类型的。 与前一个谜题一样，这个谜题初看起来是不可能实现的。毕竟，一个数字总是等</p>
<p>于它自身加上 0，你被禁止使用浮点数，因此不能使用 NaN，而在整数类型中没</p>
<p>有 NaN 的等价物。那么，你能给出什么呢？ </p>
<p>我们必然可以得出这样的结论，即 i 的类型必须是非数值类型的，并且这其中存</p>
<p>在着解谜方案。唯一的 + 操作符有定义的非数值类型就是 String。+ 操作符被</p>
<p>重载了：对于 String 类型，它执行的不是加法而是字符串连接。如果在连接中</p>
<p>的某个操作数具有非 String 的类型，那么这个操作书就会在连接之前转换成字</p>
<p>符串[JLS 15.18.1]。 </p>
<p>事实上，i 可以被初始化为任何值，只要它是 String 类型的即可，例如： </p>
<p>String i = “Buy seventeen copies of Effective Java”; </p>
<p>int 类型的数值 0 被转换成 String 类型的数值”0”，并且被追加到了感叹号之</p>
<p>后，所产生的字符串在用 equals 方法计算时就不等于最初的字符串了，这样它</p>
<p>们在使用==操作符进行计算时，当然就不是相等的。因此，计算布尔表达式(i != </p>
<p>i + 0)得到的值就是 true，循环也就永远不会被终止了。 </p>
<p>总之，操作符重载是很容易令人误解的。在本谜题中的加号看起来是表示一个加</p>
<p>法，但是通过为变量 i 选择合适的类型，即 String，我们让它执行了字符串连</p>
<p>接操作。甚至是因为变量被命名为 i，都使得本谜题更加容易令人误解，因为 i</p>
<p>通常被当作整型变量名而被保留的。对于程序的可读性来说，好的变量名、方法</p>
<p>名和类名至少与好的注释同等重要。 </p>
<p>对语言设计者的教训与谜题 11 和 13 中的教训相同。操作符重载是很容易引起混</p>
<p>乱的，也许 + 操作符就不应该被重载用来进行字符串连接操作。有充分的理由</p>
<p>证明提供一个字符串连接操作符是多么必要，但是它不应该是 + 。 </p>
<h2 id="谜题-31：循环者的鬼魂"><a href="#谜题-31：循环者的鬼魂" class="headerlink" title="谜题 31：循环者的鬼魂"></a>谜题 31：循环者的鬼魂</h2><p>请提供一个对 i 的声明，将下面的循环转变为一个无限循环： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i != <span class="number">0</span>) &#123; </span><br><span class="line"></span><br><span class="line"> i &gt;&gt;&gt;= <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回想一下，&gt;&gt;&gt;=是对应于无符号右移操作符的赋值操作符。0 被从左移入到由移</p>
<p>位操作而空出来的位上，即使被移位的负数也是如此。 </p>
<p>这个循环比前面三个循环要稍微复杂一点，因为其循环体非空。在其循环题中，</p>
<p>i 的值由它右移一位之后的值所替代。为了使移位合法，i 必须是一个整数类型</p>
<p>（byte、char、short、int 或 long）。无符号右移操作符把 0 从左边移入，因</p>
<p>此看起来这个循环执行迭代的次数与最大的整数类型所占据的位数相同，即 64</p>
<p>次。如果你在循环的前面放置如下的声明，那么这确实就是将要发生的事情： </p>
<p>long i = -1; // -1L has all 64 bits set 你怎样才能将它转变为一个无限循环呢？解决本谜题的关键在于&gt;&gt;&gt;=是一个复</p>
<p>合赋值操作符。（复合赋值操作符包括*=、/=、%=、+=、-=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=、</p>
<p>&amp;=、^=和|=。）有关混合操作符的一个不幸的事实是，它们可能会自动地执行窄</p>
<p>化原始类型转换[JLS 15.26.2]，这种转换把一种数字类型转换成了另一种更缺</p>
<p>乏表示能力的类型。窄化原始类型转换可能会丢失级数的信息，或者是数值的精</p>
<p>度[JLS 5.1.3]。 </p>
<p>让我们更具体一些，假设你在循环的前面放置了下面的声明： </p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">short i</span> = -1;</span><br></pre></td></tr></table></figure>

<p>因为 i 的初始值（(short)0xffff）是非 0 的，所以循环体会被执行。在执行移</p>
<p>位操作时，第一步是将 i 提升为 int 类型。所有算数操作都会对 short、byte</p>
<p>和 char 类型的操作数执行这样的提升。这种提升是一个拓宽原始类型转换，因</p>
<p>此没有任何信息会丢失。这种提升执行的是符号扩展，因此所产生的 int 数值是</p>
<p>0xffffffff。然后，这个数值右移 1 位，但不使用符号扩展，因此产生了 int</p>
<p>数值 0x7fffffff。最后，这个数值被存回到 i 中。为了将 int 数值存入 short</p>
<p>变量，Java 执行的是可怕的窄化原始类型转换，它直接将高 16 位截掉。这样就</p>
<p>只剩下(short)oxffff 了，我们又回到了开始处。循环的第二次以及后续的迭代</p>
<p>行为都是一样的，因此循环将永远不会终止。 </p>
<p>如果你将 i 声明为一个 short 或 byte 变量，并且初始化为任何负数，那么这种</p>
<p>行为也会发生。如果你声明 i 为一个 char，那么你将无法得到无限循环，因为</p>
<p>char 是无符号的，所以发生在移位之前的拓宽原始类型转换不会执行符号扩展。 </p>
<p>总之，不要在 short、byte 或 char 类型的变量之上使用复合赋值操作符。因为</p>
<p>这样的表达式执行的是混合类型算术运算，它容易造成混乱。更糟的是，它们执</p>
<p>行将隐式地执行会丢失信息的窄化转型，其结果是灾难性的。 </p>
<p>对语言设计者的教训是语言不应该自动地执行窄化转换。还有一点值得好好争论</p>
<p>的是，Java 是否应该禁止在 short、byte 和 char 变量上使用复合赋值操作符。 </p>
<h2 id="谜题-32：循环者的诅咒"><a href="#谜题-32：循环者的诅咒" class="headerlink" title="谜题 32：循环者的诅咒"></a>谜题 32：循环者的诅咒</h2><p>请提供一个对 i 的声明，将下面的循环转变为一个无限循环： </p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">i</span> &lt;= <span class="built_in">j</span> &amp;&amp; <span class="built_in">j</span> &lt;= <span class="built_in">i</span> &amp;&amp; <span class="built_in">i</span> != <span class="built_in">j</span>) &#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>噢，不，不要再给我看起来不可能的循环了！如果 i &lt;= j 并且 j &lt;= i，i 不是</p>
<p>肯定等于 j 吗？这一属性对实数肯定有效。事实上，它是如此地重要，以至于它</p>
<p>有这样的定义：实数上的≤关系是反对称的。Java 的&lt;=操作符在 5.0 版之前是</p>
<p>反对称的，但是这从 5.0 版之后就不再是了。 </p>
<p>直到 5.0 版之前，Java 的数字比较操作符（&lt;、&lt;=、&gt;和&gt;=）要求它们的两个操</p>
<p>作数都是原始数字类型的（byte、char、short、int、long、float 和 double）</p>
<p>[JLS 15.20.1]。但是在 5.0 版中，规范作出了修改，新规范描述道：每一个操作数的类型必须可以转换成原始数字类型[JLS 15.20.1，5.1.8]。问题难就难在</p>
<p>这里了。 </p>
<p>在 5.0 版中，自动包装（autoboxing）和自动反包装（auto-unboxing）被添加</p>
<p>到了 Java 语言中。如果你对它们并不了解，请查看：</p>
<p><a href="http://java.sun.com/j2se/5.0/docs/guide/language/autoboxing.html" target="_blank" rel="noopener">http://java.sun.com/j2se/5.0/docs/guide/language/autoboxing.html</a></p>
<p>[Boxing]。&lt;=操作符在原始数字类型集上仍然是反对称的，但是现在它还被应用</p>
<p>到了被包装的数字类型上。（被包装的数字类型有：Byte、Character、Short、</p>
<p>Integer、Long、Float 和 Double。）&lt;=操作符在这些类型的操作数上不是反对</p>
<p>称的，因为 Java 的判等操作符（==和!=）在作用于对象引用时，执行的是引用</p>
<p>ID 的比较，而不是值的比较。 </p>
<p>让我们更具体一些，下面的声明赋予表达式(i &lt;= j &amp;&amp; j &lt;= i &amp;&amp; i != j)的值</p>
<p>为 true，从而将这个循环变成了一个无限循环： </p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Integer</span> i = <span class="literal">new</span> <span class="built_in">Integer</span>(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="built_in">Integer</span> j = <span class="literal">new</span> <span class="built_in">Integer</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>前两个子表达式（i &lt;= j 和 j &lt;= i）在 i 和 j 上执行解包转换[JLS 5.1.8]，</p>
<p>并且在数字上比较所产生的 int 数值。i 和 j 都表示 0，所以这两个子表达式都</p>
<p>被计算为 true。第三个子表达式（i != j）在对象引用 i 和 j 上执行标识比较，</p>
<p>因为它们都初始化为一个新的 Integer 实例，因此，第三个子表达式同样也被计</p>
<p>算为 true，循环也就永远地环绕下去了。 </p>
<p>你可能会感到奇怪，为什么语言规范没有修改为：当判等操作符作用于被包装的</p>
<p>数字类型时，它们执行的是值比较。答案很简单：兼容性。当一种语言被广泛使</p>
<p>用之后，以违反现有规范的方式去改变现有程序的行为是让人无法接受的。下面</p>
<p>的程序过去总是保证可以打印 false，因此它必须继续保持此特征： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceComparison</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>( </span><br><span class="line"></span><br><span class="line"> <span class="keyword">new</span> Integer(<span class="number">0</span>) == <span class="keyword">new</span> Integer(<span class="number">0</span>)); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判等操作符在其两个操作数中只有一个是被包装的数字类型，而另一个是原始类</p>
<p>型时，执行的确实是数值比较。因为这在 5.0 版之前是非法的，所有在这里没有</p>
<p>任何兼容性的问题。让我们更具体一些，下面的程序在 1.4 版中是非法的，而在</p>
<p>5.0 版中将打印 true： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueComparison</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>( </span><br><span class="line"></span><br><span class="line"> <span class="keyword">new</span> Integer(<span class="number">0</span>) == <span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>} 总之，当两个操作数都是被包装的数字类型时，数值比较操作符和判等操作符的</p>
<p>行为存在着根本的差异：数值比较操作符执行的是值比较，而判等操作符执行的</p>
<p>是引用标识的比较。 </p>
<p>对语言设计者来说，如果判等操作符一直执行的都是数值比较（谜题 13），那</p>
<p>么生活可能就要简单得多、快乐得多。也许真正的教训应该是：语言设计者应该</p>
<p>拥有高质量的水晶球，以预测语言的未来，并且做出相应的设计决策。严肃一点</p>
<p>地讲，语言设计者应该考虑语言可能会如何演化，并且应该努力去最小化在演化</p>
<p>之路上的各种制约影响。 </p>
<h2 id="谜题-33：循环者遇到了狼人-循环者遇到了狼人"><a href="#谜题-33：循环者遇到了狼人-循环者遇到了狼人" class="headerlink" title="谜题 33：循环者遇到了狼人 循环者遇到了狼人"></a>谜题 33：循环者遇到了狼人 循环者遇到了狼人</h2><p>请提供一个对 i 的声明，将下面的循环转变为一个无限循环。这个循环不需要使</p>
<p>用任何 5.0 版的特性： </p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">i</span> != <span class="number">0</span> &amp;&amp; <span class="built_in">i</span> == -<span class="built_in">i</span>) &#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这仍然是一个循环。在布尔表达式(i != 0 &amp;&amp; i == -i)中，一元减号操作符作</p>
<p>用于 i，这意味着它的类型必须是数字型的：一元减号操作符作用于一个非数字</p>
<p>型操作数是非法的。因此，我们要寻找一个非 0 的数字型数值，它等于它自己的</p>
<p>负值。NaN 不能满足这个属性，因为它不等于任何数值，因此，i 必须表示一个</p>
<p>实际的数字。肯定没有任何数字满足这样的属性吗？ </p>
<p>嗯，没有任何实数具有这种属性，但是没有任何一种 Java 数值类型能够对实数</p>
<p>进行完美建模。浮点数值是用一个符号位、一个被通俗地称为尾数（mantissa）</p>
<p>的有效数字以及一个指数来表示的。除了 0 之外，没有任何浮点数等于其符号位</p>
<p>反转之后的值，因此 i 的类型必然是整数型的。 </p>
<p>有符号的整数类型使用的是 2 的补码算术运算：为了对一个数值取其负值，你要</p>
<p>反转其每一位，然后加 1，从而得到结果[JLS 15.15.4]。2 的补码算术运算的一</p>
<p>个很大的优势是，0 具有唯一的表示形式。如果你要对 int 数值 0 取负值，你将</p>
<p>得到 0xffffffff+1，它仍然是 0。 </p>
<p>但是，这也有一个相应的不利之处，总共存在偶数个 int 数值——准确地说有</p>
<p>2</p>
<p>32个——其中一个用来表示 0，这样就剩些奇数个 int 数值来表示正整数和负整</p>
<p>数，这意味着正的和负的 int 数值的数量必然不相等。这暗示着至少有一个 int</p>
<p>数值，其负值不能正确地表示成为一个 int 数值。 </p>
<p>事实上，恰恰就有一个这样的 int 数值，它就是 Integer.MIN_VALUE，即-231。</p>
<p>他的十六进制表示是 0x80000000。其符号位为 1，其余所有的位都是 0。如果我</p>
<p>们对这个值取负值，那么我们将得到 0x7fffffff+1，也就是 0x80000000，即</p>
<p>Integer.MIN_VALUE！换句话说，Integer.MIN_VALUE 是它自己的负值，</p>
<p>Long.MIN_VALUE 也是一样。对这两个值取负值将会产生溢出，但是 Java 在整数</p>
<p>计算中忽略了溢出。其结果已经阐述清楚了，即使它们并不总是你所期望的。 下面的声明将使得布尔表达式(i != 0 &amp;&amp; i == -i)的计算结果为 true，从而使</p>
<p>循环无限环绕下去： </p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="keyword">Integer</span>.MIN_VALUE;</span><br></pre></td></tr></table></figure>

<p>下面这个也可以： </p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> i = <span class="keyword">Long</span>.MIN_VALUE;</span><br></pre></td></tr></table></figure>

<p>如果你对取模运算很熟悉，那么很有必要指出，这个谜题也可以用代数方法解决。</p>
<p>Java 的 int 算术运算是实际的算术运算对 2</p>
<p>32取模的运算，因此本谜题需要一个</p>
<p>对这种线性全等的非 0 解决方案： </p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">i</span> ≡ -<span class="built_in">i</span>(<span class="built_in">mod</span> <span class="number">232</span>)</span><br></pre></td></tr></table></figure>

<p>将 i 加到恒等式的两边，我们可以得到： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>i ≡ <span class="number">0</span>(mod <span class="number">32</span>)</span><br></pre></td></tr></table></figure>

<p>对这种全等的非 0 解决方案就是 i = 231。尽管这个值不能表示成为一个 int，</p>
<p>但是它是和-231全等的，即与 Integer.MIN_VALUE 全等。 </p>
<p>总之，Java 使用 2 的补码的算术运算，它是非对称的。对于每一种有符号的整</p>
<p>数类型（int、long、byte 和 short），负的数值总是比正的数值多一个，这个</p>
<p>多出来的值总是这种类型所能表示的最小数值。对 Integer.MIN_VALUE 取负值得</p>
<p>到的还是它没有改变过的值，Long.MIN_VALUE 也是如此。对 Short.MIN_VALUE</p>
<p>取负值并将所产生的 int 数值转型回 short，返回的同样是最初的值</p>
<p>（Short.MIN_VALUE）。对 Byte.MIN_VALUE 来说，也会产生相似的结果。更一般</p>
<p>地讲，千万要当心溢出：就像狼人一样，它是个杀手。 </p>
<p>对语言设计者的教训与谜题 26 中的教训一样。应该对某种溢出不会悄悄发生的</p>
<p>整数算术运算形式提供语言级的支持。 </p>
<h2 id="谜题-34：被计数击倒了"><a href="#谜题-34：被计数击倒了" class="headerlink" title="谜题 34：被计数击倒了"></a>谜题 34：被计数击倒了</h2><p>与谜题 26 和 27 中的程序一样，下面的程序有一个单重的循环，它记录迭代的次</p>
<p>数，并在循环终止时打印这个数。那么，这个程序会打印出什么呢？ </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Count</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> <span class="built_in">int</span> START = <span class="number">2000000000</span>; </span><br><span class="line"></span><br><span class="line"> <span class="built_in">int</span> count = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="built_in">float</span> f = START; f &lt; START + <span class="number">50</span>; f++) </span><br><span class="line"></span><br><span class="line"> count++; </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println(count); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表面的分析也许会认为这个程序将打印 50，毕竟，循环变量（f）被初始化为</p>
<p>2,000,000,000，而终止值比初始值大 50，并且这个循环具有传统的“半开”形</p>
<p>式：它使用的是 &lt; 操作符，这是的它包括初始值但是不包括终止值。 然而，这种分析遗漏了关键的一点：循环变量是 float 类型的，而非 int 类型的。</p>
<p>回想一下谜题 28，很明显，增量操作（f++）不能正常工作。F 的初始值接近于</p>
<p>Integer.MAX_VALUE，因此它需要用 31 位来精确表示，而 float 类型只能提供</p>
<p>24 位的精度。对如此巨大的一个 float 数值进行增量操作将不会改变其值。因</p>
<p>此，这个程序看起来应该无限地循环下去，因为 f 永远也不可能解决其终止值。</p>
<p>但是，如果你运行该程序，就会发现它并没有无限循环下去，事实上，它立即就</p>
<p>终止了，并打印出 0。怎么回事呢？ </p>
<p>问题在于终止条件测试失败了，其方式与增量操作失败的方式非常相似。这个循</p>
<p>环只有在循环索引 f 比(float)(START + 50)小的情况下才运行。在将一个 int</p>
<p>与一个 float 进行比较时，会自动执行从 int 到 float 的提升[JLS 15.20.1]。</p>
<p>遗憾的是，这种提升是会导致精度丢失的三种拓宽原始类型转换的一种[JLS</p>
<p>5.1.2]。（另外两个是从 long 到 float 和从 long 到 double。） </p>
<p>f 的初始值太大了，以至于在对其加上 50，然后将结果转型为 float 时，所产生</p>
<p>的数值等于直接将 f 转换成 float 的数值。换句话说，(float)2000000000 == </p>
<p>2000000050，因此表达式 f &lt; START + 50 即使是在循环体第一次执行之前就是</p>
<p>false，所以，循环体也就永远的不到机会去运行。 </p>
<p>订正这个程序非常简单，只需将循环变量的类型从 float 修改为 int 即可。这样</p>
<p>就避免了所有与浮点数计算有关的不精确性： </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> f = <span class="keyword">START</span>; f &lt; <span class="keyword">START</span> + <span class="number">50</span>; f++)</span><br><span class="line"></span><br><span class="line"> count++;</span><br></pre></td></tr></table></figure>

<p>如果不使用计算机，你如何才能知道 2,000,000,050 与 2,000,000,000 有相同的</p>
<p>float 表示呢？关键是要观察到 2,000,000,000 有 10 个因子都是 2：它是一个 2</p>
<p>乘以 9 个 10，而每个 10 都是 5×2。这意味着 2,000,000,000 的二进制表示是以</p>
<p>10 个 0 结尾的。50 的二进制表示只需要 6 位，所以将 50 加到 2,000,000,000</p>
<p>上不会对右边 6 位之外的其他为产生影响。特别是，从右边数过来的第 7 位和第</p>
<p>8 位仍旧是 0。提升这个 31 位的 int 到具有 24 位精度的 float 会在第 7 位和第</p>
<p>8 位之间四舍五入，从而直接丢弃最右边的 7 位。而最右边的 6 位是</p>
<p>2,000,000,000 与 2,000,000,050 位以不同之处，因此它们的 float 表示是相同</p>
<p>的。 </p>
<p>这个谜题寓意很简单：不要使用浮点数作为循环索引，因为它会导致无法预测的</p>
<p>行为。如果你在循环体内需要一个浮点数，那么请使用 int 或 long 循环索引，</p>
<p>并将其转换为float或 double。在将一个int或 long转换成一个float或 double</p>
<p>时，你可能会丢失精度，但是至少它不会影响到循环本身。当你使用浮点数时，</p>
<p>要使用 double 而不是 float，除非你肯定 float 提供了足够的精度，并且存在</p>
<p>强制性的性能需求迫使你使用 float。适合使用 float 而不是 double 的时刻是</p>
<p>非常非常少的。 </p>
<p>对语言设计者的教训，仍然是悄悄地丢失精度对程序员来说是非常令人迷惑的。</p>
<p>请查看谜题 31 有关这一点的深入讨论。 谜题 35：一分钟又一分钟 一分钟又一分钟 </p>
<p>下面的程序在模仿一个简单的时钟。它的循环变量表示一个毫秒计数器，其计数</p>
<p>值从 0 开始直至一小时中包含的毫秒数。循环体以定期的时间间隔对一个分钟计</p>
<p>数器执行增量操作。最后，该程序将打印分钟计数器。那么它会打印出什么呢？ </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Clock</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="built_in">int</span> minutes = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="built_in">int</span> ms = <span class="number">0</span>; ms &lt; <span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>; ms++) </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (ms % <span class="number">60</span>*<span class="number">1000</span> == <span class="number">0</span>) </span><br><span class="line"></span><br><span class="line"> minutes++; </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println(minutes); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个程序中的循环是一个标准的惯用 for 循环。它步进毫秒计数器（ms），从</p>
<p>0 到一小时中的毫秒数，即 3,600,000，包括前者但是不包括后者。循环体看起</p>
<p>来是在每当毫秒计数器的计数值是 60,000（一分钟内所包含毫秒数）的倍数时，</p>
<p>对分钟计数器（minutes）执行增量操作。这在循环的生命周期内总共发生了</p>
<p>3,600,000/60,000 次，即 60 次，因此你可能期望程序打印出 60，毕竟，这就是</p>
<p>一小时所包含的分钟数。但是，该程序的运行却会告诉你另外一番景象：它打印</p>
<p>的是 60000。为什么它会如此频繁地对 minutes 执行了增量操作呢？ </p>
<p>问题在于那个布尔表达式(ms % 60*1000 == 0)。你可能会认为这个表达式等价</p>
<p>于(ms % 60000 == 0)，但是它们并不等价。取余和乘法操作符具有相同的优先</p>
<p>级[JLS 15.17]，因此表达式 ms % 60<em>1000 等价于(ms % 60)</em>1000。如果(ms % </p>
<p>60)等于 0 的话，这个表达式就等于 0，因此循环每 60 次迭代就对 minutes 执行</p>
<p>增量操作。这使得最终的结果相差 1000 倍。 </p>
<p>订正该程序的最简单的方式就是在布尔表达式中插入一对括号，以强制规定计算</p>
<p>的正确顺序： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ms % (<span class="number">60</span> * <span class="number">1000</span>) == <span class="number">0</span>) </span><br><span class="line"></span><br><span class="line"> minutes++;</span><br></pre></td></tr></table></figure>

<p>然而，有一个更好的方法可以订正该程序。用被恰当命名的常量来替代所有的魔</p>
<p>幻数字： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Clock</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> static <span class="keyword">final</span> <span class="built_in">int</span> MS_PER_HOUR = <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> static <span class="keyword">final</span> <span class="built_in">int</span> MS_PER_MINUTE = <span class="number">60</span> * <span class="number">1000</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="built_in">int</span> minutes = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="built_in">int</span> ms = <span class="number">0</span>; ms &lt; MS_PER_HOUR; ms++) </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (ms % MS_PER_MINUTE == <span class="number">0</span>) </span><br><span class="line"></span><br><span class="line"> minutes++; </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println(minutes);  &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之所以要在最初的程序中展现表达式 ms % 60*1000，是为了诱使你去认为乘法</p>
<p>比取余有更高的优先级。然而，编译器是忽略空格的，所以千万不要使用空格来</p>
<p>表示分组，要使用括号。空格是靠不住的，而括号是从来不说谎的。 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/20/java%E4%B8%AD%E7%BA%A7%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/20/java%E4%B8%AD%E7%BA%A7%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">java中级知识点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-20 19:29:16" itemprop="dateCreated datePublished" datetime="2021-03-20T19:29:16+08:00">2021-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-21 17:12:18" itemprop="dateModified" datetime="2021-03-21T17:12:18+08:00">2021-03-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>91k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:23</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><h2 id="Java-基本类型哪些，所占字节"><a href="#Java-基本类型哪些，所占字节" class="headerlink" title="Java 基本类型哪些，所占字节"></a>Java 基本类型哪些，所占字节</h2><p>byte ：1 个字节</p>
<p>short ：2 个字节</p>
<p>char ：2 个字节</p>
<p>int ：4 个字节</p>
<p>long ：8 个字节</p>
<p>float ：4 个字节</p>
<p>double ：8 个字节</p>
<h2 id="java-集合以及底层原理"><a href="#java-集合以及底层原理" class="headerlink" title="java 集合以及底层原理"></a>java 集合以及底层原理</h2><p>Java 集合框架的根接口有 Collection 和 Map。Collection 根接口包含 List 和 Set 二个子接口。</p>
<h3 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h3><p>它的特点是：元素有序、且可重复，主要包含三个实现类：ArrayList，vector，LinkedList</p>
<p>ArrayList 的特点：底层是数组，线程不安全，查找快，增删慢（数组的特点）。</p>
<p>ArrayList 的底层实现原理：通过 ArrrayList 空参构造器创建对象。</p>
<p>底层创建一个长度为 10 的数组，当我们向数组中添加 11 个元素时，底层会进行扩容，扩容为原来的 1.5 倍</p>
<p>(创建一个新的数组，长度为原数组长度的 1.5 倍，将原数组复制到新数组中)。</p>
<p>vector 的特点：古老的实现类,底层是数组,线程安全的,JDK1.0 就有了,Vector 总是比 ArrayList 慢,所以尽量</p>
<p>避免使用。</p>
<p>LinkedList 的特点：底层是使用双向链表。增删快，查找慢。</p>
<h3 id="Set-接口"><a href="#Set-接口" class="headerlink" title="Set 接口"></a>Set 接口</h3><p>它的特点：</p>
<p>无序性：通过 HashCode 方法算出的值来决定在数组中存放的位置；</p>
<p>不可重复性：进行 equals 方法比较，结果为 true 则两个数据相同，若为 false 则不同。</p>
<p>主要包含三个实现类：HashSet，LinkedHashSet，TreeSet</p>
<p>HashSet 特点：线程不安全，集合元素可以为 null，不能保证元素的排列顺序</p>
<p>HashSet 的底层实现原理：</p>
<p>当向 HashSet 添加数据时，首先调用 HashCode 方法决定数据存放在数组中的位置，该位置上没有其他元素，</p>
<p>则将数据直接存放，若该位置上有其他元素，调用 equals 方法进行比较。若返回 true 则认为两个数据相同，</p>
<p>若返回 false，则以链表的形式将该数据存在该位置上，(jdk1.8)如果数量达到 8 则将链表换成红黑树。HashSet 的底层就是一个 HashMap,向 HashSet 中添加的数据实际上添加到了 HashMap 中的 key 里。</p>
<p>所以 HashMap 的 key 可以看成是 Set 的集合。</p>
<p>LinkedHashSet 特点：继承了 HashSet，底层实现原理和 HashSet 一样,可以安照元素添加的顺序进行遍历</p>
<p>根据元素的 hashCode 值来决定元素的存储位置，它维护了一张链表该链表记录了元素添加的顺序。</p>
<p>底层就是一个 LinkedHashMap。</p>
<p>TreeSet 特点：底层为红黑树；可以安照指定的元素进行排序；TreeSet 中的元素类型必须保持一致，</p>
<p>底层就是 TreeMap。TreeSet 必须（自然排序）实现 Comparable 接口，重写 compareTo()方法，</p>
<p>按照某个属性进行排序，相结合添加元素或（定制排序）创建一个 Comparator 实现类的对象，</p>
<p>并传入到 TreeSet 的构造器中，按照某个属性进行排序，向集合添加元素。定制排序比自然排序灵活。</p>
<p>如果即有自然排序又有定制排序谁起作用？ 定制排序</p>
<h3 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h3><p>Map 的特点：</p>
<p>Map 存储的是键值对(key,value)，Map 中的 key 是无序的且不可重复的，所有的 key 可以看成是一个 set 集合。</p>
<p>Map 中的 key 如果是自定义类的对象必须重写 hashCode 和 equals 方法，Map 中的 value 是无序的可重复的，</p>
<p>所有的 value 可以看成是 Collection 集合，Map 中的 value 如果是自定义类的对象必须重写 equals 方法，</p>
<p>Map 中的键值对可以看成是一个一个的 Entry.Entry 所存放的位置是由 key 来决定的。</p>
<p>Entry 是无序的不可重复的。主要的实现类：HashMap，LinkedHashMap，TreeMap，HashTable.</p>
<h3 id="HashMap-特点"><a href="#HashMap-特点" class="headerlink" title="HashMap 特点"></a>HashMap 特点</h3><p>1.底层是一个数组 + 链表 + 红黑树(jdk1.8)</p>
<p>2.数组的类型是一个 Node 类型</p>
<p>3.Node 中有 key 和 value 的属性</p>
<p>4.根据 key 的 hashCode 方法来决定 Node 存放的位置</p>
<p>5.线程不安全的 ,可以存放 null</p>
<p>HashMap 的底层实现原理：</p>
<p>当我们向 HashMap 中存放一个元素(k1,v1),先根据 k1 的 hashCode 方法来决定在数组中存放的位置。</p>
<p>如果该位置没有其它元素则将(k1,v1)直接放入数组中,如果该位置已经有其它元素(k2,v2),调用k1 的equals方</p>
<p>法和 k2 进行比较。</p>
<p>如果结果为 true 则用 v1 替换 v2,如果返回值为 false 则以链表的形式将(k1,v1)存放, 当元素达到 8 时则会将链表替换成红黑树以提高查找效率。</p>
<p>HashMap 的构造器：new HashMap() :创建一个容量为 16 的数组，加载因子为 0.75。</p>
<p>当我们添加的数据超过 12 时底层会进行扩容，扩容为原来的 2 倍。</p>
<p>LinkedHashMap：继承了 HashMap 底层实现和 HashMap 一样. 可以安照元素添加的顺序进行遍历底层维护了一张链表用来记录元素添加的顺序。</p>
<p>TreeMap 特点：可以对 Key 中的元素安照指定的顺序进行排序 （ 不能对 value 进行排序）</p>
<p>HashTable 特点：线程安全的 ,不可以存放 null，map 中的 key 不能重复，如果有重复的，后者的 value 覆盖前</p>
<p>者的 value</p>
<h2 id="四大作用域和九大内置对象四大作用域："><a href="#四大作用域和九大内置对象四大作用域：" class="headerlink" title="四大作用域和九大内置对象四大作用域："></a>四大作用域和九大内置对象四大作用域：</h2><p>page ：当前页面有效时间最短（页面执行期）</p>
<p>request ：HTTP 请求开始到结束这段时间</p>
<p>session ：HTTP 会话开始到结束这段时间</p>
<p>application ：服务器启动到停止这段时间</p>
<p>九大内置对象：</p>
<p>request ：请求对象 作用域 Request</p>
<p>response ：响应对象 作用域 Page</p>
<p>pageContext ：页面上下文对象 作用域 Page</p>
<p>session ：会话对象 作用域 Session</p>
<p>application ：应用程序对象 作用域 Application</p>
<p>out ：输出对象 作用域 Page</p>
<p>config ：配置对象 作用域 Page</p>
<p>page ：页面对象 作用域 Page</p>
<p>exception ：例外对象 作用域 page</p>
<h2 id="jsp-和-servlet-的区别"><a href="#jsp-和-servlet-的区别" class="headerlink" title="jsp 和 servlet 的区别"></a>jsp 和 servlet 的区别</h2><p>1.jsp 经编译后就变成了 Servlet.(JSP 的本质就是 Servlet，JVM 只能识别 java 的类，</p>
<p>不能识别 JSP 的代码,Web 容器将 JSP 的代码编译成 JVM 能够识别的 java 类)</p>
<p>2.jsp 更擅长表现于页面显示,servlet 更擅长于逻辑控制.</p>
<p>3.Servlet 中没有内置对象，Jsp 中的内置对象都是必须通过 HttpServletRequest 象，</p>
<p>HttpServletResponse 对象以及 HttpServlet 对象得到.</p>
<p>Jsp 是 Servlet 的一种简化，使用 Jsp 只需要完成程序员需要输出到客户端的内容，Jsp 中的 Java 脚本如何镶嵌</p>
<p>到一个类中，由 Jsp 容器完成。</p>
<p>而 Servlet 则是个完整的 Java 类，这个类的 Service 方法用于生成对客户端的响应。</p>
<p>servlet 生命周期</p>
<p>1.加载和实例化</p>
<p>2.初始化</p>
<p>3.请求处理</p>
<p>4.服务终止</p>
<p>加载(服务器启动时,会到 web.xml 文件中去找到 Servlet 文件的配置并创建 servlet 的实例) →初始化(init()此方法只执行一次) →执行(service(),doGet(),doPost()) →销毁(销毁 destory())</p>
<p>service(): 方法本身包含了 doGet()和 doPost().如果服务器发现了 service()方法,则不再执行 doGet(),doPost(). 一般不建议去重写父类的 service 方法.因为重写了此方法 doGet 方法和 doPost 方法将得不到利用. 没有 service()方法默认执行 doGet()方法.cookie 和 session 区别以及 JWT 与 Session 的差异</p>
<p>1、cookie 数据存放在客户的浏览器上，session 数据放在服务器上。</p>
<p>2、cookie 不是很安全，别人可以分析存放在本地的 cookie 并进行 cookie 欺骗，考虑到安全应当使用 session。</p>
<p>3、session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方</p>
<p>面，应当使用 cookie。</p>
<p>4、单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。</p>
<p>5、可以考虑将登陆信息等重要信息存放为 session，其他信息如果需要保留，可以放在 cookie 中。</p>
<p>1.Session 是在服务器端的，而 JWT 是在客户端的。</p>
<p>2.Session 方式存储用户信息的最大问题在于要占用大量服务器内存，增加服务器的开销。</p>
<p>3.JWT 方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力。</p>
<p>4.Session 的状态是存储在服务器端，客户端只有 session id；而 Token 的状态是存储在客户端。</p>
<h2 id="JWT-与-OAuth-的区别"><a href="#JWT-与-OAuth-的区别" class="headerlink" title="JWT 与 OAuth 的区别"></a>JWT 与 OAuth 的区别</h2><p>OAuth2 是一种授权框架 ，JWT 是一种认证协议。</p>
<p>无论使用哪种方式切记用 HTTPS 来保证数据的安全性</p>
<p>OAuth2 用在使用第三方账号登录的情况(比如使用 weibo, qq, github 登录某个 app)</p>
<p>JWT 是用在前后端分离, 需要简单的对后台 API 进行保护时使用。</p>
<h2 id="Cookie-和-LocalStorage-和-sessionStorage-的区别"><a href="#Cookie-和-LocalStorage-和-sessionStorage-的区别" class="headerlink" title="Cookie 和 LocalStorage 和 sessionStorage 的区别"></a>Cookie 和 LocalStorage 和 sessionStorage 的区别</h2><p><img src="/2021/03/20/java%E4%B8%AD%E7%BA%A7%E7%9F%A5%E8%AF%86/Git/myBlog/source/_posts/java%E4%B8%AD%E7%BA%A7%E7%9F%A5%E8%AF%86/clip_image002.jpg" alt="img"></p>
<h2 id="转发和重定向的区别"><a href="#转发和重定向的区别" class="headerlink" title="转发和重定向的区别"></a>转发和重定向的区别</h2><p>转发：浏览器地址栏不变，1 次请求，request 请求，可以访问 web-inf，可以共享 request 请求域</p>
<p>数据，只能跳转工程内的资源重定向：浏览器变化，2 次请求，response 响应，不能访问 web-inf，不可以共享 request 请求域数</p>
<p>据，可以跳转任意资源</p>
<h2 id="饿汉于懒汉单例模式"><a href="#饿汉于懒汉单例模式" class="headerlink" title="饿汉于懒汉单例模式"></a>饿汉于懒汉单例模式</h2><p>单例模式设计：</p>
<p>第一步：私有化构造器</p>
<p>第二步：提供一个公共静态返回该类实例对象的方法</p>
<p>饿汉式：先初始化对象，Single 类一进内存，就已经创建好了对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Single s=<span class="keyword">new</span> Single();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式：对象是方法被调用时，才初始化，也叫做对象的延时加载。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Single</span>&#123; <span class="comment">//Single 类进内存，对象还没存在，只有调用了 getInstance 方法时，才建立对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Single</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Single s=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> synchronize Single <span class="title">getInstance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s==<span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">s=<span class="keyword">new</span> single();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作共享的数据有多条，会出现线程安全问题，在方法加一个同步</p>
<h2 id="过滤器和拦截器的区别"><a href="#过滤器和拦截器的区别" class="headerlink" title="过滤器和拦截器的区别"></a>过滤器和拦截器的区别</h2><p>①拦截器是基于 java 的反射机制的，而过滤器是基于函数回调。</p>
<p>②拦截器不依赖与 servlet 容器，过滤器依赖与 servlet 容器。</p>
<p>③拦截器只能对 action 请求起作用，而过滤器则可以对几乎所有的请求起作用。</p>
<p>④拦截器可以访问 action 上下文、值栈里的对象，而过滤器不能访问。</p>
<p>⑤在 action 的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。</p>
<p>⑥拦截器可以获取 IOC 容器中的各个 bean，而过滤器就不行，这点很重要，在拦截器里注入一个 service，可以调</p>
<p>用业务逻辑。</p>
<h2 id="和-的区别-和-的区别"><a href="#和-的区别-和-的区别" class="headerlink" title="#和$的区别#{}和${}的区别"></a>#和$的区别#{}和${}的区别</h2><p>#{} 在 mapper 的配置文件的 sql 语句中，它是占位符， 相当于 ? 号。</p>
<p>${} 在 mapper 的配置文件的 sql 语句中，它是原样输出变量的值，然后以字符串拼接的功能进行操作。</p>
<p>${} 中只能写 value，或者是@Param 命名参数后的参数名称</p>
<p>在输出参数的时候，我们并不推荐使用 ${} 来输出。因为可能会导至 sql 注入问题的存在。</p>
<h2 id="什么是-SQL-注入？"><a href="#什么是-SQL-注入？" class="headerlink" title="什么是 SQL 注入？"></a>什么是 SQL 注入？</h2><p>如果 SQL 是根据用户输入拼出来，如果用户故意输入可以让后台解析失败的字符串，这就是 SQL 注入</p>
<p>例如，用户在输入密码的时候，输入’ or 1=1’, 这样，后台的程序在解析的时候，拼成的 SQL 语句，可能是这样</p>
<p>的：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(1) <span class="keyword">from</span> tab where <span class="attribute">user</span>=userinput <span class="keyword">and</span> <span class="attribute">pass</span>=<span class="string">''</span> <span class="keyword">or</span> <span class="attribute">1</span>=1;</span><br></pre></td></tr></table></figure>

<p>看这条语句，可以知道，在解析之后，用户没有输入密码，加了一个恒等的条件 1=1，这样，这段 SQL 执行的时候，</p>
<p>返回的 count 值肯定大于 1 的，如果程序的逻辑没加过多的判断，这样就能够使用用户名 userinput 登陆，而不</p>
<p>需要密码。</p>
<p>防止 SQL 注入，首先要对密码输入中的单引号进行过滤，再在后面加其它的逻辑判断，或者不用这样的动态 SQL 拼。</p>
<h2 id="amp-amp-和-amp-与-和-的区别？"><a href="#amp-amp-和-amp-与-和-的区别？" class="headerlink" title="&amp;&amp;和&amp;与|和||的区别？"></a>&amp;&amp;和&amp;与|和||的区别？</h2><p>&amp;和&amp;&amp;的区别？</p>
<p>&amp;和&amp;&amp;左边的式子为 true 的时候，右边的式子都会执行。</p>
<p>左边的式子为 false 的时候。&amp;右边的式子仍然会执行。&amp;&amp;右边的式子将不再执行。</p>
<p>|和||的区别？</p>
<p>|和||左边的式子为 false 的时候，右边的式子都会执行。</p>
<p>左边的式子为 true 的时候。|右边的式子仍然会执行。||右边的式子将不再执行。</p>
<h2 id="final-finally-finalize-区别？"><a href="#final-finally-finalize-区别？" class="headerlink" title="final finally finalize 区别？"></a>final finally finalize 区别？</h2><p>final 修饰符,用来修饰变量,方法和类,分别表示属性不可变,方法不可被重写,类不可被继承,finally 是异常语</p>
<p>句中处理语句, 表示总是执行;finalize 表示在垃圾回收机制时使该对象状态恢复的方法</p>
<h2 id="int-和-Integer-的区别？"><a href="#int-和-Integer-的区别？" class="headerlink" title="int 和 Integer 的区别？"></a>int 和 Integer 的区别？</h2><p>1、Integer 是 int 的包装类，int 则是 java 的一种基本数据类型</p>
<p>2、Integer 变量必须实例化后才能使用，而 int 变量不需要</p>
<p>3、Integer 实际是对象的引用，当 new 一个 Integer 时，实际上是生成一个指针指向此对象；而 int 则是直接存</p>
<p>储数据值</p>
<p>4、Integer 的默认值是 null，int 的默认值是 0</p>
<h2 id="equals-与“等于号”-的区别？-：如果-两边是基本数据类型，那么比较的是具体的值。如果-两边是引用数据类型，那么比较的是地址值。"><a href="#equals-与“等于号”-的区别？-：如果-两边是基本数据类型，那么比较的是具体的值。如果-两边是引用数据类型，那么比较的是地址值。" class="headerlink" title="equals 与“等于号”==的区别？==：如果==两边是基本数据类型，那么比较的是具体的值。如果==两边是引用数据类型，那么比较的是地址值。"></a>equals 与“等于号”==的区别？==：如果==两边是基本数据类型，那么比较的是具体的值。如果==两边是引用数据类型，那么比较的是地址值。</h2><p>(两个对象是否指向同一块内存)</p>
<p>equals：如果没有重写 equals 方法那么调用的是 Object 中的 equals 方法，比较的是地址值。</p>
<p>如果重写了 euqlas 方法(比属性内容)那么就比较的是对象中属性的内容。</p>
<h2 id="StringBuff-和-StringBuilder-及-String-区别？"><a href="#StringBuff-和-StringBuilder-及-String-区别？" class="headerlink" title="StringBuff 和 StringBuilder 及 String 区别？"></a>StringBuff 和 StringBuilder 及 String 区别？</h2><p>String 类是不可变类，任何对 String 的改变都会引发新的 String 对象的生成；</p>
<p>StringBuffer 是可变类，任何对它所指代的字符串的改变都不会产生新的对象，线程安全的。</p>
<p>StringBuilder 是可变类，线性不安全的，不支持并发操作，不适合多线程中使用，但其在单线程中的性能比</p>
<p>StringBuffer 高。</p>
<h2 id="Override-和-Overload-的含义去区别？"><a href="#Override-和-Overload-的含义去区别？" class="headerlink" title="Override 和 Overload 的含义去区别？"></a>Override 和 Overload 的含义去区别？</h2><p>\1. Override 特点</p>
<p>1、覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；</p>
<p>2、覆盖的方法的返回值必须和被覆盖的方法的返回一致；</p>
<p>3、覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；</p>
<p>4、方法被定义为 final 不能被重写。</p>
<p>5、对于继承来说，如果某一方法在父类中是访问权限是 private，那么就不能在子类对其进行重写覆盖，如果定义</p>
<p>的话，</p>
<p>也只是定义了一个新方法，而不会达到重写覆盖的效果。（通常存在于父类和子类之间。）</p>
<p>2.Overload 特点</p>
<p>1、在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序</p>
<p>当然，同一方法内的几个参数类型必须不一样，例如可以是 fun(int, float)， 但是不能为 fun(int, int)</p>
<p>2、不能通过访问权限、返回类型、抛出的异常进行重载；</p>
<p>3、方法的异常类型和数目不会对重载造成影响；</p>
<p>4、重载事件通常发生在同一个类中，不同方法之间的现象。</p>
<p>5、存在于同一类中，但是只有虚方法和抽象方法才能被覆写。 </p>
<h2 id="抽象类和接口及普通类的区别？"><a href="#抽象类和接口及普通类的区别？" class="headerlink" title="抽象类和接口及普通类的区别？"></a>抽象类和接口及普通类的区别？</h2><p>1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，</p>
<p>接口变量必须指向实现所有接口方法的类对象。</p>
<p>2、抽象类要被子类继承，接口要被类实现。</p>
<p>3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现</p>
<p>4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。</p>
<p>5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。</p>
<p>同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。</p>
<p>6、抽象方法只能申明，不能实现，接口是设计的结果 ，抽象类是重构的结果</p>
<p>7、抽象类里可以没有抽象方法8、如果一个类里有抽象方法，那么这个类只能是抽象类</p>
<p>9、抽象方法要被实现，所以不能是静态的，也不能是私有的。</p>
<p>10、接口可继承接口，并可多继承接口，但类只能单根继承。 堆和栈的区别？</p>
<h2 id="一-堆栈空间分配区别："><a href="#一-堆栈空间分配区别：" class="headerlink" title="一.堆栈空间分配区别："></a>一.堆栈空间分配区别：</h2><p>1.栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构</p>
<p>中的栈；</p>
<p>2.堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收，分配方式倒是类似于</p>
<p>链表。</p>
<h2 id="二-堆栈缓存方式区别："><a href="#二-堆栈缓存方式区别：" class="headerlink" title="二.堆栈缓存方式区别："></a>二.堆栈缓存方式区别：</h2><p>1.栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；</p>
<p>2.堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。</p>
<p>所以调用这些对象的速度要相对来得低一些。</p>
<h2 id="三-堆栈数据结构区别："><a href="#三-堆栈数据结构区别：" class="headerlink" title="三.堆栈数据结构区别："></a>三.堆栈数据结构区别：</h2><p>堆（数据结构）：堆可以被看成是一棵树，如：堆排序；</p>
<p>栈（数据结构）：一种先进后出的数据结构。</p>
<p>Spring Bean 生命周期</p>
<p> 实例化 bean 对象</p>
<p> 设置对象属性</p>
<p> 检查 Aware 相关接口并设置相关依赖</p>
<p> BeanPostPreocessor 前置处理</p>
<p> 检查是否是 InitialliziingBean 以决定是否调用 afterPropertesSet 方法</p>
<p> 检查是否配置有自定义的 init-method</p>
<p> BeanPostProcessor 后置处理</p>
<p> 注册必要的 Destrunction 相关回调接口</p>
<p> 使用中</p>
<p> 是否实现 DisposableBean 接口</p>
<p> 是否配置有自定义的 Destory 方法</p>
<h2 id="JDK、JRE、JVM-的区别"><a href="#JDK、JRE、JVM-的区别" class="headerlink" title="JDK、JRE、JVM 的区别?"></a>JDK、JRE、JVM 的区别?</h2><p>JDK （ Java 开发工具包）= JRE（Java 运行环境） + 开发工具集（例如 Javac 编译工具等）</p>
<p>JRE （Java 运行环境）= JVM （Java 虚拟机）+ Java SE 标准类库</p>
<h2 id="值传递和引用传递的区别"><a href="#值传递和引用传递的区别" class="headerlink" title="值传递和引用传递的区别?"></a>值传递和引用传递的区别?</h2><p>值传递：会创建副本，函数中无法改变原始对象</p>
<p>引用传递：不会创建副本，函数中可以改变原始对象</p>
<p>值传递：方法调用时，实际参数把它的值传递给对应的形式参数，方法执行中形式参数值的改变不影响实际参数的值。</p>
<p>引用传递：也称为传地址。方法调用时，实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数，</p>
<p>在方法执行中，对形式参数的操作实际上就是对实际参数的操作，方法执行中形式参数值的改变将会影响实际参数的</p>
<p>值。</p>
<h2 id="4-种访问控制符区别"><a href="#4-种访问控制符区别" class="headerlink" title="4 种访问控制符区别?"></a>4 种访问控制符区别?</h2><p>访问权限 类 包 子类 其他包</p>
<p>public ∨ ∨ ∨ ∨</p>
<p>protect ∨ ∨ ∨ ×</p>
<p>default ∨ ∨ × ×</p>
<p>private ∨ × × ×</p>
<h2 id="装箱和拆箱，类型转换"><a href="#装箱和拆箱，类型转换" class="headerlink" title="装箱和拆箱，类型转换"></a>装箱和拆箱，类型转换</h2><p>装箱：值类型转换为引用对象，一般是转换为 System.Object 类型或值类型实现的接口引用类型；</p>
<p>拆箱：引用类型转换为值类型，注意，这里的引用类型只能是被装箱的引用类型对象；</p>
<p>拆箱与装箱就是值类型与引用类型的转换</p>
<h2 id="throw-和-throws-区别"><a href="#throw-和-throws-区别" class="headerlink" title="throw 和 throws 区别"></a>throw 和 throws 区别</h2><p>throw 代表动作，表示抛出一个异常的动作；</p>
<p>throws 代表一种状态，代表方法可能有异常抛出；</p>
<p>throw 用在方法实现中，而 throws 用在方法声明中；</p>
<p>throw 只能用于抛出一种异常，而 throws 可以抛出多个异常。</p>
<h2 id="PreparedStatement-比-Statement-区别"><a href="#PreparedStatement-比-Statement-区别" class="headerlink" title="PreparedStatement 比 Statement 区别?"></a>PreparedStatement 比 Statement 区别?</h2><p>第一：statement 执行的 SQL 语句必须是一个完整的 SQL，而对于 PreparedStatement 来说，可以使用“？”作为SQL 语句当中的占位符，然后使用 PreparedStatement 的 setXXX 方法来给占位符赋值，最后在执行；</p>
<p>第二：使用 Statement 时，如果 SQL 当中出现了“‘”或者“-”等符号时，需要使用转义字符来进行转义，而在PreparedStatement 当中，如果占位符的值当中有这些符号，PreparedStatement 会自动的进行转义；</p>
<p>第三：PreparedStatement 会讲 SQL 语句进行预编译，每次执行的时候只需要将参数设置给相应的占位符就可以</p>
<p>运行。而使用 Statement 时，SQL 语句时每次都要进行编译，所以 PreparedStatement 的效率相对较高。</p>
<h2 id="doGet-方法和-doPost-方法区别"><a href="#doGet-方法和-doPost-方法区别" class="headerlink" title="doGet()方法和 doPost()方法区别?"></a>doGet()方法和 doPost()方法区别?</h2><p>get 方式 参数在地址栏中显示 通过?name=””&amp;id=””这种形式传递的 不安全 只能传递 2kb 的能容</p>
<p>post 方式 底层是通过流的形式传递 不限制大小 上传的时候必须用 Post 方式</p>
<p>doGet：路径传参。效率高，安全性差</p>
<p>doPOST：实体传参。效率第，安全性好</p>
<h2 id="null-和-undefind-的区别"><a href="#null-和-undefind-的区别" class="headerlink" title="null 和 undefind 的区别?"></a>null 和 undefind 的区别?</h2><p>undefined 是访问一个未初始化的变量时返回的值，而 null 是访问一个尚未存在的对象时所返回的</p>
<p>值。</p>
<h2 id="Error-和-Exception-的区别"><a href="#Error-和-Exception-的区别" class="headerlink" title="Error 和 Exception 的区别?"></a>Error 和 Exception 的区别?</h2><p>Error（错误）是系统中的错误，程序员是不能改变的和处理的，是在程序编译时出现的错误，只能通过修改程序才能修正。</p>
<p>一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。</p>
<p>对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。</p>
<p>Exception（异常）表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序</p>
<p>恢复运行，</p>
<p>而不应该随意终止异常。 阻塞和非阻塞以及同步和异步的区别?</p>
<p>\1. 同步，就是我调用一个功能，该功能没有结束前，我死等结果。</p>
<p>\2. 异步，就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）</p>
<p>\3. 阻塞，就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。</p>
<p>\4. 非阻塞，就是调用我（函数），我（函数）立即返回，通过 select 通知调用者</p>
<p>同步 IO 和异步 IO 的区别就在于：数据拷贝的时候进程是否阻塞</p>
<p>阻塞 IO 和非阻塞 IO 的区别就在于：应用程序的调用是否立即返回</p>
<h2 id="Ajax-异步和同步"><a href="#Ajax-异步和同步" class="headerlink" title="Ajax 异步和同步"></a>Ajax 异步和同步</h2><p> 同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。 异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。</p>
<p>\1. 同步通信方式要求通信双方以相同的时钟频率进行，而且准确协调，通过共享一个单个时钟或定时脉冲</p>
<p>源保证发送方和接收方的准确同步，效率较高；</p>
<p>\2. 异步通信方式不要求双方同步，收发方可采用各自的时钟源，双方遵循异步的通信协议，以字符为数据</p>
<p>传输单位，发送方传送字符的时间间隔不确定，发送效率比同步传送效率低。 使用者可以同步或异步实现服务调用。从使用者的观点来看，这两种方式的不同之处在于：</p>
<p> 同步——使用者通过单个线程调用服务；该线程发送请求，在服务运行时阻塞，并且等待响应。</p>
<p> 异步——使用者通过两个线程调用服务；一个线程发送请求，而另一个单独的线程接收响应。 事务的 ACID 和事务的隔离性?</p>
<p>1)原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败；</p>
<p>2)一致性(Consistent)：事务结束后系统状态是一致的；</p>
<p>3)隔离性(Isolated)：并发执行的事务彼此无法看到对方的中间状态；</p>
<p>4)持久性(Durable)：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。</p>
<p>脏读：事务 A 读到了事务 B 未提交的数据。</p>
<p>不可重复读:事务 A 第一次查询得到一行记录 row1,事务 B 提交修改后,事务 A 第二次查询得到 row1,但列内容发生了变化,侧重于次数，侧重于 update</p>
<p>幻读：事务 A 第一次查询得到一行记录 row1，事务 B 提交修改后，事务 A 第二次查询得到两行记录 row1 和 row2，</p>
<p>侧重于内容，侧重于 insert</p>
<h2 id="线程的-sleep-和-wait-区别"><a href="#线程的-sleep-和-wait-区别" class="headerlink" title="线程的 sleep 和 wait 区别?"></a>线程的 sleep 和 wait 区别?</h2><p>sleep()不释放同步锁,wait()释放同步锁.</p>
<p>sleep 可以用时间指定来使他自动醒过来,如果时间不到你只能调用 interreput()来强行打断;</p>
<p>wait()可以用 notify()直接唤起.</p>
<p>sleep 和 wait 的区别还有：</p>
<p>1。这两个方法来自不同的类分别是 Thread 和 Object</p>
<p>2。最主要是 sleep 方法没有释放锁，而 wait 方法释放了锁，使得其他线程可以使用同步控制块或者方法。</p>
<p>3。wait，notify 和 notifyAll 只能在同步控制方法或者同步控制块里面使用，而 sleep 可以在任何地方使用</p>
<h2 id="线程的状态（阶段）"><a href="#线程的状态（阶段）" class="headerlink" title="线程的状态（阶段）?"></a>线程的状态（阶段）?</h2><p>创建、就绪、运行、阻塞、终止。</p>
<p>1、新建状态(New)：新创建了一个线程对象。2、就绪状态(Runnable)：线程对象创建后，其他线程调用了该对象的 start()方法。该状态的线程位于“可运行</p>
<p>线程池”中，</p>
<p>变得可运行，只等待获取 CPU 的使用权。即在就绪状态的进程除 CPU 之外，其它的运行所需资源都已全部获得。</p>
<p>3、运行状态(Running)：就绪状态的线程获取了 CPU，执行程序代码。</p>
<p>4、阻塞状态(Blocked)：阻塞状态是线程因为某种原因放弃 CPU 使用权，暂时停止运行。直到线程进入就绪状态，</p>
<p>才有机会转到运行状态。</p>
<h2 id="http-和-https-的区别"><a href="#http-和-https-的区别" class="headerlink" title="http 和 https 的区别?"></a>http 和 https 的区别?</h2><p>1、https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。</p>
<p>2、http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。</p>
<p>3、http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</p>
<p>4、http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。 </p>
<h2 id="常见的运行时异常"><a href="#常见的运行时异常" class="headerlink" title="常见的运行时异常?"></a>常见的运行时异常?</h2><p>NullPointerException - 空指针引用异常</p>
<p>ClassCastException - 类型强制转换异常。</p>
<p>IllegalArgumentException - 传递非法参数异常。</p>
<p>ArithmeticException - 算术运算异常</p>
<p>ArrayStoreException - 向数组中存放与声明类型不兼容对象异常</p>
<p>IndexOutOfBoundsException - 下标越界异常</p>
<p>NegativeArraySizeException - 创建一个大小为负数的数组错误异常</p>
<p>NumberFormatException - 数字格式异常</p>
<p>SecurityException - 安全异常</p>
<p>UnsupportedOperationException - 不支持的操作异常</p>
<h2 id="BIO-和-NIO-区别"><a href="#BIO-和-NIO-区别" class="headerlink" title="BIO 和 NIO 区别?"></a>BIO 和 NIO 区别?</h2><p>互联网 强调的是信息/数据在网络之间的流通，</p>
<p>BIO：堵塞式 IO,相当于轮船运输</p>
<p>NIO：非堵塞式 IO：面向缓冲区（buffer），基于通道(chanel)的 io 操作,相当于火车运输，效率高</p>
<p>文件-&gt;双向通道（（缓冲区））-&gt;程序</p>
<h2 id="http-常见的状态码"><a href="#http-常见的状态码" class="headerlink" title="http 常见的状态码"></a>http 常见的状态码</h2><p>200 OK //客户端请求成功</p>
<p>302 found //重定向</p>
<p>400 Bad Request //客户端请求有语法错误，不能被服务器所理解401 Unauthorized //请求未经授权</p>
<p>403 Forbidden //服务器收到请求，但是拒绝提供服务</p>
<p>404 Not Found //请求资源不存在，eg：输入了错误的 URL</p>
<p>500 Internal Server Error //服务器发生不可预期的错误</p>
<p>503 Server Unavailable//服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>
<p>Hashmap 为什么线程不安全，如何让它线程安全</p>
<p>HashMap 在 put 的时候，插入的元素超过了容量（由负载因子决定）的范围就会触发扩容操作，就</p>
<p>是 rehash，这个会重新将原数组的内容重新 hash 到新的扩容数组中，在多线程的环境下，存在同</p>
<p>时其他的元素也在进行 put 操作，如果 hash 值相同，可能出现同时在同一数组下用链表表示，造</p>
<p>成闭环，导致在 get 时会出现死循环，所以 HashMap 是线程不安全的。</p>
<p> 使用 java.util.Hashtable 类，此类是线程安全的。</p>
<p> 使用 java.util.concurrent.ConcurrentHashMap，此类是线程安全的。</p>
<p> 使用 java.util.Collections.synchronizedMap() 方法包装 HashMap object，得到线程安全的 Map，并在此 Map上进行操作。 怎么加快程序访问速度</p>
<p>硬件上：加大网络带宽、和服务器内存</p>
<p>代码的处理：静态页面、缓存、优化 sql、创建索引等方案怎样进行程序性能调优</p>
<p>系统性能就是两个事：</p>
<p> Throughput ，吞吐量。也就是每秒钟可以处理的请求数，任务数。</p>
<p> Latency，系统延迟。系统在处理一个请求或一个任务时的延迟。那么 Latency 越好，能支持的 Throughput</p>
<p>就会越高。因为 Latency 短说明处理速度快，于是就可以处理更多的请求。 解决方案：</p>
<p> 提高吞吐量：分布式集群，模块解藕，设计模式</p>
<p> 系统延迟：异步通信</p>
<h2 id="冒泡排序和自然排序及定制排序怎么实现的或者手写出来"><a href="#冒泡排序和自然排序及定制排序怎么实现的或者手写出来" class="headerlink" title="冒泡排序和自然排序及定制排序怎么实现的或者手写出来"></a>冒泡排序和自然排序及定制排序怎么实现的或者手写出来</h2><p>冒泡排序</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] arr=&#123;<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"排序前数组为："</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> num:arr)&#123;</span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.print(num+<span class="string">" "</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;arr.length<span class="number">-1</span>;i++)&#123;<span class="comment">//外层循环控制排序趟数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;arr.length<span class="number">-1</span>-i;j++)&#123;<span class="comment">//内层循环控制每一趟排序多少次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> temp=arr[j];</span><br><span class="line"></span><br><span class="line">arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">arr[j+<span class="number">1</span>]=temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.println();</span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"排序后的数组为："</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> num:arr)&#123;</span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.print(num+<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自然排序</p>
<p>1、定义一个类（文章中为 Employee）实现 Comparable 接口</p>
<p>2、重写 Comparable 接口中的 compareTo()方法</p>
<p>3、在 compareTo()中按指定属性进行排序</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Employee</span> <span class="symbol">implements</span> <span class="symbol">Comparable</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> compareTo(Object o) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (o instanceof Employee) &#123;</span><br><span class="line"></span><br><span class="line">Employee e = (Employee) o;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(e.name);<span class="comment">//按 name 进行排序</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定制排序</p>
<p>1.创建一个 Compartor 实现类的对象，并传入到 TreeSet 的构造器中</p>
<p>2.重写 compare 方法</p>
<p>3.安照某个属性进行排序</p>
<p>4.向集合中添加元素</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">TreeSet <span class="built_in">set</span> = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> Comparator() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> compare(<span class="keyword">Object</span> o1, <span class="keyword">Object</span> o2) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Student &amp;&amp; o2 <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line"></span><br><span class="line">Student s1 = (Student)o1;</span><br><span class="line"></span><br><span class="line">Student s2 = (Student)o2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> s = s1.getAge() - s2.getAge();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s1.getName().compareTo(s2.getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>.<span class="built_in">add</span>(<span class="keyword">new</span> Student(<span class="string">"aaa"</span>, <span class="number">18</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>.<span class="built_in">add</span>(<span class="keyword">new</span> Student(<span class="string">"bbb"</span>, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>.<span class="built_in">add</span>(<span class="keyword">new</span> Student(<span class="string">"fff"</span>, <span class="number">38</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>.<span class="built_in">add</span>(<span class="keyword">new</span> Student(<span class="string">"ccc"</span>, <span class="number">28</span>));</span><br><span class="line"></span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">set</span>);</span><br></pre></td></tr></table></figure>

<h2 id="在使用定制排序或是自然排序时，在其用到的类中都要重写-hashCode-与-equals-方法三种遍历方式"><a href="#在使用定制排序或是自然排序时，在其用到的类中都要重写-hashCode-与-equals-方法三种遍历方式" class="headerlink" title="在使用定制排序或是自然排序时，在其用到的类中都要重写 hashCode()与 equals()方法三种遍历方式?"></a>在使用定制排序或是自然排序时，在其用到的类中都要重写 hashCode()与 equals()方法三种遍历方式?</h2><p>第一种遍历方法和输出结果。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,i&lt;<span class="built_in">list</span>.<span class="built_in">size</span>(),i++)&#123;</span><br><span class="line"></span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">list</span>.<span class="built_in">get</span>(i));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种用 foreach 循环。加强型 for 循环。推荐方式。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">String</span> <span class="built_in">string</span>:<span class="built_in">list</span>)&#123;</span><br><span class="line"></span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三钟迭代器</p>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">List</span>&lt;String&gt; <span class="meta">list</span>=new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">list</span>.<span class="meta">add</span>(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">list</span>.<span class="meta">add</span>(<span class="string">"ghi"</span>);</span><br><span class="line"></span><br><span class="line">for(Iterator&lt;String&gt; it=<span class="meta">list</span>.iterator();it.hasNext();)&#123;</span><br><span class="line"></span><br><span class="line">System.<span class="meta">out</span>.print<span class="meta">ln(</span>it.next());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>讲讲线程的创建及实现线程几种方式之间的区别</p>
<h2 id="Java-中线程的创建"><a href="#Java-中线程的创建" class="headerlink" title="Java 中线程的创建"></a>Java 中线程的创建</h2><p> 继承 Thread 类：重写该类的 run()方法。</p>
<p> 实现 Runnable 接口：并重写该接口的 run()方法，该 run()方法同样是线程执行体，创建 Runnable 实现类</p>
<p>的实例，并以此实例作为 Thread 类的 target 来创建 Thread 对象，该 Thread 对象才是真正的线程对象。 使用 Callable 和 Future 接口创建线程：具体是创建 Callable 接口的实现类，并实现 clall()方法。并使用</p>
<p>FutureTask 类来包装 Callable 实现类的对象，且以此 FutureTask 对象作为 Thread 对象的 target 来创建线程。</p>
<p> 线程池：线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这</p>
<p>些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多</p>
<p>线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程</p>
<p>来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池</p>
<p>将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，</p>
<p>但他们要等到其他线程完成后才启动。 继承 Thread 类，并重写里面的 run 方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">public void run()&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">System</span>.out.println(<span class="string">"-----------------"</span>+i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">A</span> a = <span class="keyword">new</span> <span class="type">A</span>();</span><br><span class="line"></span><br><span class="line">a.start();</span><br></pre></td></tr></table></figure>

<p>实现 Runnable 接口，并实现里面的 run 方法</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">B</span> <span class="symbol">implements</span> <span class="symbol">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> run()&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"-----------------"</span>+i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B b = new B();</span><br><span class="line"></span><br><span class="line">Thread t = new Thread(b);</span><br><span class="line"></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p>实现 Callable</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Callable</span></span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> call() throws Exception&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FutureTask&lt;<span class="keyword">String</span>&gt; ft = <span class="keyword">new</span> <span class="type">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="type">A</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="type">Thread</span>(ft).start();</span><br><span class="line"></span><br><span class="line">线程池ExcutorService es = Executors.<span class="keyword">new</span><span class="type">FixedThreadPool</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">es.submit(<span class="keyword">new</span> <span class="type">Runnable</span>()&#123;<span class="comment">//任务&#125;);</span></span><br><span class="line"></span><br><span class="line">es.submit(<span class="keyword">new</span> <span class="type">Runnable</span>()&#123;<span class="comment">//任务&#125;);</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">es.shutdown();</span><br></pre></td></tr></table></figure>

<h2 id="实现-Runnable-和实现-Callable-的区别？"><a href="#实现-Runnable-和实现-Callable-的区别？" class="headerlink" title="实现 Runnable 和实现 Callable 的区别？"></a>实现 Runnable 和实现 Callable 的区别？</h2><p>实现 Callable 接口，任务可以有返回值，Runnable 没有。</p>
<p>实现 Callable 接口，可以指定泛型，Runnable 没有。</p>
<p>实现 Callable 接口，可以在 call 方法中声明异常，Runnable 没有。</p>
<p>Runnable 和 Thread 二者的区别？</p>
<p>实现 Runnable 接口的方式，更适合处理有共享资源的情况。</p>
<p>实现 Runnable 接口的方式，避免了单继承的局限性。 线程的创建</p>
<p>同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。</p>
<p>线程分为五个阶段：创建、就绪、运行、阻塞、终止。</p>
<h2 id="Java-线程的五种基本状态："><a href="#Java-线程的五种基本状态：" class="headerlink" title="Java 线程的五种基本状态："></a>Java 线程的五种基本状态：</h2><p> 新建状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();  就绪状态（Runnable）：当调用线程对象的 start()方法（t.start();），线程即进入就绪状态。处于就绪状</p>
<p>态的线程，只是说明此线程已经做好了准备，随时等待 CPU 调度执行，并不是说执行了 t.start()此线程立</p>
<p>即就会执行；</p>
<p> 运行状态（Running）：当 CPU 开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运</p>
<p>行状态。注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必</p>
<p>须处于就绪状态中；</p>
<p> 阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对 CPU 的使用权，停止执行，此</p>
<p>时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被 CPU 调用以进入到运行状态。 根据阻塞产生的原因不同，阻塞状态又可以分为三种：</p>
<p>1.等待阻塞：运行状态中的线程执行 wait()方法，使本线程进入到等待阻塞状态；</p>
<p>2.同步阻塞 – 线程在获取 synchronized 同步锁失败(因为锁被其它线程所占用)，</p>
<p>它会进入同步阻塞状态；</p>
<p>3.其他阻塞 – 通过调用线程的 sleep()或 join()或发出了 I/O 请求时，线程会进入到</p>
<p>阻塞状态。当 sleep()状态超时、 join()等待线程终止或者超时、或者 I/O 处理</p>
<p>完毕时，线程重新转入就绪状态。</p>
<p> 死亡状态（Dead）：线程执行完了或者因异常退出了 run()方法，该线程结束生命周期。 如何实现线程的同步？为何要使用同步？ java 允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如</p>
<p>数据的增删改查），将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没</p>
<p>有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。</p>
<h2 id="线程同步（5-种同步方式）"><a href="#线程同步（5-种同步方式）" class="headerlink" title="线程同步（5 种同步方式）"></a>线程同步（5 种同步方式）</h2><p>\1. 同步方法</p>
<p>\2. 同步代码块</p>
<p>\3. 使用特殊域变量(volatile)实现线程同步</p>
<p>\4. 使用重入锁实现线程同步</p>
<p>\5. 使用局部变量实现线程同步</p>
<h2 id="讲一下-ThreadLocal-类。"><a href="#讲一下-ThreadLocal-类。" class="headerlink" title="讲一下 ThreadLocal 类。"></a>讲一下 ThreadLocal 类。</h2><p>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。可能</p>
<p>很多朋友都知道 ThreadLocal 为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己</p>
<p>内部的副本变量；ThreadLocal 在每个线程中对该变量会创建一个副本，即每个线程内部都会有一</p>
<p>个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问</p>
<p>题，也不会严重影响程序执行性能。但是要注意，虽然 ThreadLocal 能够解决上面说的问题，但是</p>
<p>由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用</p>
<p>ThreadLocal 要大；</p>
<h2 id="ReentrantReadWriteLock：读写锁"><a href="#ReentrantReadWriteLock：读写锁" class="headerlink" title="ReentrantReadWriteLock：读写锁"></a>ReentrantReadWriteLock：读写锁</h2><p>为什么要使用读写锁？</p>
<p>多线程同时读一个资源类没有任何问题，但是有一个线程去写共享资源，就不应该让其他线程可以</p>
<p>对该资源进行读或者写。</p>
<p>读和读的线程可以共存，读和写的线程不能共存，写和写的线程不能共存。</p>
<p>未使用读写锁之前：</p>
<p>一个线程正在写入共享资源的时候，其他线程有写入和读取的共享资源操作，导致数据不一致。而</p>
<p>使用 ReentrantLock 只能保证一个线程读，不能让其他线程同时读取，所以需要使用</p>
<p>ReentrantReadWriteLock 解决原子性和独占性，解决并发性和数据的一致性。</p>
<p> 独占锁：该锁一次只能被一个线程持有，ReentrantLock 和 Synchronized 都是独占锁。</p>
<p> 共享锁：该锁可以被多个线程持有。</p>
<p>private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();</p>
<p>说明：ReentrantReadWriteLock 的读锁是共享锁：lock.readLock().lock();，写锁是独占锁：</p>
<p>lock.writeLock().lock();</p>
<p>CountDownLatch：倒计时器作用：让一些线程阻塞，直到其他线程完成一系列的操作之后才被唤醒。</p>
<p>有几个方法：</p>
<p>CountDownLatch(int count) //实例化一个倒计数器，count 指定计数个数</p>
<p>countDown() // 计数减一</p>
<p>await() //等待，当计数减到 0 时，所有线程并行执行</p>
<h2 id="使用-CountDownLatch-的代码："><a href="#使用-CountDownLatch-的代码：" class="headerlink" title="使用 CountDownLatch 的代码："></a>使用 CountDownLatch 的代码：</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> &#123;</span></span><br><span class="line"></span><br><span class="line">public static <span class="literal">void</span> main(String[] args) throws Exception&#123;</span><br><span class="line"></span><br><span class="line">CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread<span class="function"><span class="params">(()-&gt;&#123;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">System.out.println(Thread.currentThread().getName()+<span class="string">"\t 工作任务完成，离开公</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">司"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">countDownLatch.countDown();</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;,String.valueOf(i))</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">countDownLatch</span>.<span class="title">await</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(Thread.currentThread().getName()+<span class="string">"\t 最后将公司门锁死，离开公司</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"</span>)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>控制台：<img src="/2021/03/20/java%E4%B8%AD%E7%BA%A7%E7%9F%A5%E8%AF%86/Git/myBlog/source/_posts/java%E4%B8%AD%E7%BA%A7%E7%9F%A5%E8%AF%86/clip_image004.jpg" alt="img"></p>
<h2 id="CyclicBarrier：循环栅栏"><a href="#CyclicBarrier：循环栅栏" class="headerlink" title="CyclicBarrier：循环栅栏"></a>CyclicBarrier：循环栅栏</h2><p>作用：就是会让所有线程都等待完成后才会继续下一步行动。举个例子，就像生活中我们会约朋友</p>
<p>们到某个餐厅一起吃饭，有些朋友可能会早到，有些朋友可能会晚到，但是这个餐厅规定必须等到</p>
<p>所有人到齐之后才会让我们进去。这里的朋友们就是各个线程，餐厅就是 CyclicBarrier。</p>
<p>使用 CyclicBarrier 的代码：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> &#123;</span></span><br><span class="line"></span><br><span class="line">public static <span class="literal">void</span> main(String[] args) throws Exception&#123;</span><br><span class="line"></span><br><span class="line">CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier<span class="function"><span class="params">(<span class="number">6</span>,()-&gt;&#123;System.out.println(<span class="string">"朋友</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">全部到了,才开始吃饭"</span>);&#125;)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">for</span> <span class="params">(int i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++)</span> &#123;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">final</span> <span class="title">int</span> <span class="title">tempInt</span> = <span class="title">i</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">new</span> <span class="title">Thread</span><span class="params">(()-&gt;&#123;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">System.out.println(tempInt+<span class="string">"朋友到了"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">cyclicBarrier.await();</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">e.printStackTrace();</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">&#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">e.printStackTrace();</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;,String.valueOf(i))</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>控制台：<img src="/2021/03/20/java%E4%B8%AD%E7%BA%A7%E7%9F%A5%E8%AF%86/Git/myBlog/source/_posts/java%E4%B8%AD%E7%BA%A7%E7%9F%A5%E8%AF%86/clip_image006.jpg" alt="img"></p>
<h2 id="Semaphore：信号灯"><a href="#Semaphore：信号灯" class="headerlink" title="Semaphore：信号灯"></a>Semaphore：信号灯</h2><p>Semaphore 是 synchronized 的加强版，作用是控制线程的并发数量。多个线程抢多个资源，只有</p>
<p>当一个线程使用资源完成之后，其他线程才可以抢占使用共享资源。下面案例是有六台车抢三个停</p>
<p>车位</p>
<p>使用 Semaphore 的代码：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> &#123;</span></span><br><span class="line"></span><br><span class="line">public static <span class="literal">void</span> main(String[] args) throws Exception&#123;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//模拟三个停车位</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Semaphore semaphore = new Semaphore(3);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span>模拟六台车</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread<span class="function"><span class="params">(()-&gt;&#123;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">semaphore.acquire();</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">System.out.println(Thread.currentThread().getName()+<span class="string">"\t 抢到车位"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">Thread.sleep(<span class="number">2000</span>);</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">System.out.println(Thread.currentThread().getName()+<span class="string">"\t 停车 2 秒后离开</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">车位"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">e.printStackTrace();</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;<span class="keyword">finally</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">semaphore.release();</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;&#125;,String.valueOf(i))</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>控制台：<img src="/2021/03/20/java%E4%B8%AD%E7%BA%A7%E7%9F%A5%E8%AF%86/Git/myBlog/source/_posts/java%E4%B8%AD%E7%BA%A7%E7%9F%A5%E8%AF%86/clip_image008.jpg" alt="img"></p>
<h2 id="Java-自定义类加载器与双亲委派模型"><a href="#Java-自定义类加载器与双亲委派模型" class="headerlink" title="Java 自定义类加载器与双亲委派模型"></a>Java 自定义类加载器与双亲委派模型</h2><p>启动类加载器（Bootstrap）C++</p>
<p>扩展类加载器（Extension）Java</p>
<p>应用程序类加载器（AppClassLoader）Java</p>
<p>双亲委派模型工作原理：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，</p>
<p>而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范</p>
<p>围内找不到指定的类时（ClassNotFoundException），子加载器才会尝试自己去加载。 讲讲 jvm 的组成与调优，内存模型，tomcat 调优t</p>
<p>omcat 调优：</p>
<p> 增加 JVM 堆内存大小</p>
<p> 修复 JRE 内存泄漏</p>
<p> 线程池设置</p>
<p> 压缩</p>
<p> 数据库性能调优</p>
<p> Tomcat 本地库</p>
<p>JVM 调优：</p>
<p>JVM 由类加载器子系统、运行时数据区、执行引擎以及本地方法接口组成，jvm 调优分以下三点：</p>
<p>堆大小设置</p>
<p> -Xms – 指定初始化时化的堆内存，默认为物理内存的 1/64</p>
<p> -Xmx – 指定最大的内存,默认为物理内存的 1/4</p>
<p> -XX:+PrintGCDetails：输出详细的 GC 处理日志</p>
<p> 在重启你的 Tomcat 服务器之后，这些配置的更改才会有效。回收器选择</p>
<p>辅助信息：JVM 提供了大量命令行参数，打印信息，供调试使用；</p>
<h2 id="设计模式在项目中如何体现"><a href="#设计模式在项目中如何体现" class="headerlink" title="设计模式在项目中如何体现"></a>设计模式在项目中如何体现</h2><p>1、模板方法模式 ：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，如 JdbcTemplate</p>
<p>2、代理 ：spring 的 Proxy 模式在 aop 中有体现</p>
<p>3、观察者 ：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它</p>
<p>的对象都得到通知并被自动更新。 spring 中 Observer 模式常用的地方是 listener 的实现。如</p>
<p>ApplicationListener。</p>
<p>4、适配器（Adapter ） ：MethodBeforeAdviceAdapter 类</p>
<p>5、策略模式 ：使用了 java 的继承和多态 。简单理解：执行多个事情时，创建多个对象</p>
<p> 案例 1：加减法计算器，定义一个计算类接口，加法和减法类都实现它，加的时候传入加法对象。</p>
<p> 案例 2：导出 excel,pdf,word 时，分别创建不同的对象</p>
<p>6、单例模式 ：解决一个全局使用的类频繁的创建与销毁</p>
<p>7、工厂模式 ：分为三种：简单工厂，工厂方法，抽象工厂 。根据“需求”生产“产品”，解耦“需求”“工</p>
<p>厂”和“产品”。</p>
<p> 简单工厂：通过构造时传入的标识来生产产品，不同产品都在同一个工厂中生产，每新增加一种产品，</p>
<p>需要改工厂类，来判断，这种判断会随着产品的增加而增加，给扩展和维护带来麻烦 。简单工厂项目案</p>
<p>例：根据传入的 不同（比如 1 对应支付流水，2 对应订单流水），生成不同类型的流水号。</p>
<p> 工厂方法：（使一个类的使用延迟到子类） 。其中的工厂类根据传入的 A.class 类型，反射出实例。 产</p>
<p>品接口，产品类 A，产品类 B，工厂类可以生成不同的产品类对象，如果要随着产品的增加而增加，工厂</p>
<p>类不变，只需新增一个产品类 C 即可。 项目案例：邮件服务器，有三种协议，POP3，IMAP,HTTP,把这三</p>
<p>种做完产品类，在定义个工厂方法</p>
<p> 抽象工厂：一个工厂生产多个产品，它们是一个产品族，不同的产品族的产品派生于不同的抽象产品。 讲讲 linux 命令 awk、cat、sort、cut、grep、uniq、wc、top、find、sed 等作用</p>
<p>awk:相较于 sed 常常作用于一整个行的处理，awk 则比较倾向于一行当中分成数个『字段』来处</p>
<p>理。 因此，awk</p>
<p>相当的适合处理小型的数据数据处理</p>
<p>cat:主要用来查看文件内容，创建文件，文件合并，追加文件内容等功能。</p>
<p>sort:功能：排序文本，默认对整列有效</p>
<p>cut:cut 命令可以从一个文本文件或者文本流中提取文本列</p>
<p>grep:是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来</p>
<p>uniq:功能：去除重复行，只会统计相邻的</p>
<p>wc:功能： 统计文件行数、字节、字符数</p>
<p>top:用来监控 Linux 的系统状况,比如 cpu、内存的使用</p>
<p>find:功能： 搜索文件目录层次结构</p>
<p>sed:sed 是一种在线编辑器，它一次处理一行内容Spring 框架</p>
<p>Spring 管理 bean 的作用域，为什么不会被 GC 处理？</p>
<p>当通过 spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 实例的实例化，还可以为 Bean 指定</p>
<p>特定的作用域。</p>
<h2 id="Spring-支持如下-5-种作用域："><a href="#Spring-支持如下-5-种作用域：" class="headerlink" title="Spring 支持如下 5 种作用域："></a>Spring 支持如下 5 种作用域：</h2><p> singleton：单例模式，在整个 Spring IoC 容器中，使用 singleton 定义的 Bean 将只有一个实例</p>
<p> prototype：原型模式，每次通过容器的 getBean 方法获取 prototype 定义的 Bean 时，都将产生一个新的</p>
<p>Bean 实例</p>
<p> request：对于每次 HTTP 请求，使用 request 定义的 Bean 都将产生一个新实例，即每次 HTTP 请求将会产</p>
<p>生不同的 Bean 实例。只有在 Web 应用中使用 Spring 时，该作用域才有效</p>
<p> session：对于每次 HTTP Session，使用 session 定义的 Bean 都将产生一个新实例。同样只有在 Web 应用中使用 Spring 时，该作用域才有效</p>
<p> globalsession：每个全局的 HTTP Session，使用 session 定义的 Bean 都将产生一个新实例。典型情况下，</p>
<p>仅在使用 portlet context 的时候有效。同样只有在 Web 应用中使用 Spring 时，该作用域才有效</p>
<p>说明：其中比较常用的是 singleton 和 prototype 两种作用域。</p>
<p>\1. 对于 singleton 作用域的 Bean：每次请求该 Bean 都将获得相同的实例。容器负责跟踪 Bean 实例的状态，</p>
<p>负责维护 Bean 实例的生命周期行为；</p>
<p>\2. 对于 prototype 作用域的 Bean：程序每次请求该 id 的 Bean，Spring 都会新建一个 Bean 实例，然后返回</p>
<p>给程序。在这种情况下，Spring 容器仅仅使用 new 关键字创建 Bean 实例，一旦创建成功，容器不在跟</p>
<p>踪实例，也不会维护 Bean 实例的状态。</p>
<p>Java 在创建 Java 实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导</p>
<p>致系统开销的增加。</p>
<p>prototype 作用域 Bean 的创建、销毁代价比较大。而 singleton 作用域的 Bean 实例一旦创建成功，</p>
<p>可以重复使用。因此，除非必要，否则尽量避免将 Bean 被设置成 prototype 作用域。如果不指定</p>
<p>Bean 的作用域，Spring 默认使用 singleton 作用域。spring 底层使用 map 来存放 bean 实体，而 map</p>
<p>的键值是强引用，所以不会被 GC，可以重复使用。</p>
<h2 id="Spring-对-bean-是如何解析"><a href="#Spring-对-bean-是如何解析" class="headerlink" title="Spring 对 bean 是如何解析"></a>Spring 对 bean 是如何解析</h2><p>所谓 bean 的解析就是将我们的 xml 文件中的 bean 解析出来，上面的入口看到使用的是</p>
<p>ClassPathXmlApplicationContext 来获取 ApplicationContext，所以，分析的入口也就从</p>
<p>ClassPathXmlApplicationContext 类中相应的构造函数开始。</p>
<p> getBean 方法开始创建过程，getBean()有一系列的重载方法，最终都是调用 doGetBean() 方法</p>
<p> getSingleton 方法尝试从缓存中获取单例 bean</p>
<p>当前 bean 是单例且缓存不存在则通过 getSingleton(String beanName, ObjectFactory&lt;?&gt;</p>
<p>singletonFactory) 方法创建单例对象主要包含下下面三个主要方法：</p>
<p> createBeanInstance 方法用于创建 Bean 实例</p>
<p> populateBean 方法主要给 Bean 进行属性注入</p>
<p> initializeBean 方法主要处理各种回调</p>
<h2 id="Spring-核心特性？"><a href="#Spring-核心特性？" class="headerlink" title="Spring 核心特性？"></a>Spring 核心特性？</h2><p>Spring 的核心特性就是 IOC 和 AOP，IOC（Inversion of Control），即“控制反转”；AOP</p>
<p>（Aspect-OrientedProgramming），即“面向切面编程”。</p>
<p>IOC：IOC，另外一种说法叫 DI（Dependency Injection），即依赖注入。它并不是一种技术实现，而</p>
<p>是一种设计思想。在任何一个有实际开发意义的程序项目中，我们会使用很多类来描述它们特有</p>
<p>的功能，并且通过类与类之间的相互协作来完成特定的业务逻辑。这个时候，每个类都需要负责管</p>
<p>理与自己有交互的类的引用和依赖，代码将会变的异常难以维护和极度的高耦合。而 IOC 的出现正</p>
<p>是用来解决这个问题，我们通过 IOC 将这些相互依赖对象的创建、协调工作交给 Spring 容器去处理，</p>
<p>每个对象只需要关注其自身的业务逻辑关系就可以了。在这样的角度上来看，获得依赖的对象的方</p>
<p>式，进行了反转，变成了由 spring 容器控制对象如何获取外部资源（包括其他对象和文件资料等等）。</p>
<p>AOP：面向切面编程，往往被定义为促使软件系统实现关注点的分离的技术。系统是由许多不同的</p>
<p>组件所组成的，每一个组件各负责一块特定功能。除了实现自身核心功能之外，这些组件还经常承</p>
<p>担着额外的职责。例如日志、事务管理和安全这样的核心服务经常融入到自身具有核心业务逻辑的</p>
<p>组件中去。这些系统服务经常被称为横切关注点，因为它们会跨越系统的多个组件。 讲讲 Spring 的 IOC（DI）和 AOP 动态代理</p>
<p>传统的程序开发（不用 IOC）：举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到</p>
<p>处去看哪里有</p>
<p>长得漂亮身材又好的 mm，然后打听她们的兴趣爱好、qq 号、电话号、ip 号、iq 号………，想办法</p>
<p>认识她们，投其</p>
<p>所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。</p>
<p>IOC：</p>
<p>IoC 是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。</p>
<p>婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，</p>
<p>比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚</p>
<p>介就会按照我们的要求，提供一个美眉，我们只需要去和她谈恋爱、结婚就行了。</p>
<p>总结控制反转：所有的类都会在 spring 容器中登记，告诉 spring 你是个什么东西，你需要什么东西，</p>
<p>然后 spring 会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东</p>
<p>西。所有的类的创建、销毁都由 spring 来控制，也就是说控制对象生存周期的不再是引用它的对</p>
<p>象，而是 spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被 spring</p>
<p>控制，所以这叫控制反转。</p>
<p>理解 DI 的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么” ●谁依赖于谁：当然是应用程序依赖于 IoC 容器；●为什么需要依赖：应用程序需要 IoC 容器来提供对象需要的外部资源；</p>
<p>●谁注入谁：很明显是 IoC 容器注入应用程序某个对象，应用程序依赖的对象；</p>
<p>●注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</p>
<h2 id="AOP-的各种实现"><a href="#AOP-的各种实现" class="headerlink" title="AOP 的各种实现"></a>AOP 的各种实现</h2><p>AOP 就是面向切面编程，我们可以从以下几个层面来实现 AOP</p>
<p> 在编译期修改源代码</p>
<p> 在运行期字节码加载前修改字节码</p>
<p> 在运行期字节码加载后动态创建代理类的字节码</p>
<p>AOP 各种实现机制的比较</p>
<p>以下是各种实现机制的比较：</p>
<p>类别 机制 原理 优点 缺点</p>
<p>静态AOP</p>
<p>静态织入</p>
<p>在编译期，切面直接以字节码的形式编译到目标字节码文件中</p>
<p>对系统无性能影响</p>
<p>灵活性不够</p>
<p>动态AOP</p>
<p>动态代理</p>
<p>在运行期，目标类加载后，为接口动态生成代理类，将切面织入到代理类中</p>
<p>相对于静态AOP 更加灵活</p>
<p>切入的关注点需要实现接口。</p>
<p>对系统有一点性能影响AOP 里的公民</p>
<p> Joinpoint：拦截点，如某个业务方法</p>
<p> Pointcut：Joinpoint 的表达式，表示拦截哪些方法。一个 Pointcut 对应多个 Joinpoint  Advice：要切入的逻辑</p>
<p> Before Advice：在方法前切入</p>
<p> After Advice：在方法后切入，抛出异常则不会切入</p>
<p> After Returning Advice：在方法返回后切入，抛出异常则不会切入</p>
<p> After Throwing Advice：在方法抛出异常时切入</p>
<p> Around Advice：在方法执行前后切入，可以中断或忽略原有流程的执行</p>
<h2 id="Spring-框架-AOP-执行原理简单说下？"><a href="#Spring-框架-AOP-执行原理简单说下？" class="headerlink" title="Spring 框架 AOP 执行原理简单说下？"></a>Spring 框架 AOP 执行原理简单说下？</h2><p>什么是动态代理：AOP 框架不会去修改字节码，而是在内存中临时为方法生成一个 AOP 对象，这</p>
<p>个 AOP 对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p>
<p>主要有两种方式：JDK 动态代理和 CGLIB 动态代理。</p>
<p> JDK 动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK 动态代理的核心</p>
<p>是 InvocationHandler 接口和 Proxy 类。如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动</p>
<p>态代理目标类。</p>
<p> CGLIB（Code GenerationLibrary），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注</p>
<p>意，CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final，那么它是无法使用 CGLIB 做</p>
<p>动态代理的。</p>
<p>AOP 在事务管理方面，Spring 使用 AOP 来完成声明式的事务管理有 annotation 和 xml 两种形式。开</p>
<p>发中，方便代码编写，很多时候都是在 spring 配置文件中配置事务管理器并开启事务控制注解。在</p>
<p>业务类或业务类方法中添加@Transactional 实现事务控制。</p>
<h2 id="Spring-分布式事务如何处理的？"><a href="#Spring-分布式事务如何处理的？" class="headerlink" title="Spring 分布式事务如何处理的？"></a>Spring 分布式事务如何处理的？</h2><p>第一种方案：可靠消息最终一致性，需要业务系统结合 MQ 消息中间件实现，在实现过程中需要</p>
<p>保证消息的成功发送及成功消费。即需要通过业务系统控制 MQ 的消息状态</p>
<p>动态字节码生成CGLIB在运行期，</p>
<p>目标类加载后，动态构建字节码文件生成目标类的子类，将切面逻辑加入到子类中没有接口也可以织入</p>
<p>扩展类的实例方法为final 时，则无法进行织入自定义类加载器</p>
<p>在运行期，目标加载前，将切面逻辑加到目标字节码里</p>
<p>可以对绝大部分类进行织入</p>
<p>代码中如果使用了其他类加载器，则这些类将不会被织入字节码转换</p>
<p>在运行期，所有类加载器加载字节码前进行拦截可以对所有类进行织入</p>
<p>第二种方案：TCC 补偿性，分为三个阶段 TRYING-CONFIRMING-CANCELING。每个阶段做不同的处理。</p>
<p> TRYING 阶段主要是对业务系统进行检测及资源预留</p>
<p> CONFIRMING 阶段是做业务提交，通过 TRYING 阶段执行成功后，再执行该阶段。默认如果 TRYING 阶段</p>
<p>执行成功，CONFIRMING 就一定能成功。</p>
<p> CANCELING 阶段是回对业务做回滚，在 TRYING 阶段中，如果存在分支事务 TRYING 失败，则需要调用</p>
<p>CANCELING 将已预留的资源进行释放。 SpringBoot 框架</p>
<h2 id="Springboot-的特点？"><a href="#Springboot-的特点？" class="headerlink" title="Springboot 的特点？"></a>Springboot 的特点？</h2><p>Springboot 用来简化 spring 应用的初始搭建以及开发过程 使用特定的方式来进行配置</p>
<p>（properties 或 yml 文件）</p>
<p>提供了各种启动器，独立运行，可以创建独立的 spring 引用程序 main 方法运行</p>
<p>Springboot 嵌入的 Tomcat 无需部署 war 文件</p>
<p>自动配置，无代码生成和 XML 配置，简化 maven 配置</p>
<h2 id="Spring-Boot-的核心配置文件有哪几个？它们的区别是什么？"><a href="#Spring-Boot-的核心配置文件有哪几个？它们的区别是什么？" class="headerlink" title="Spring Boot 的核心配置文件有哪几个？它们的区别是什么？"></a>Spring Boot 的核心配置文件有哪几个？它们的区别是什么？</h2><p>Spring Boot 的核心配置文件是 application 和 bootstrap 配置文件。</p>
<p> application 配置文件这个容易理解，主要用于 Spring Boot 项目的自动化配置。</p>
<p> bootstrap 配置文件有以下几个应用场景。</p>
<p>\1. 使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属</p>
<p>性来加载外部配置中心的配置信息；</p>
<p>\2. 一些固定的不能被覆盖的属性；</p>
<p>\3. 一些加密/解密的场景</p>
<h2 id="Spring-Boot-的配置文件有哪几种格式？它们有什么区别？"><a href="#Spring-Boot-的配置文件有哪几种格式？它们有什么区别？" class="headerlink" title="Spring Boot 的配置文件有哪几种格式？它们有什么区别？"></a>Spring Boot 的配置文件有哪几种格式？它们有什么区别？</h2><p>.properties 和 .yml，它们的区别主要是书写格式不同。</p>
<p> 在 properties 文件中是以”.”进行分割的， 在 yml 中是用”:”进行分割;  yml 的数据格式和 json 的格式很像，都是 K-V 格式，并且通过”:”进行赋值；</p>
<p> 在 yml 中缩进一定不能使用 TAB，否则会报很奇怪的错误；（缩进只能用空格！！！！）</p>
<p> 每个 k 的冒号后面一定都要加一个空格；</p>
<p> 使用 spring cloud 的 maven 进行构造的项目，在把 properties 换成 yml 后，一定要进行 mvn clean insatll  properties 的优先级高于 yml。即如果两个文件中都配置了端口号，只有 properties 中的端口号有效，而</p>
<p>yml 文件中端口配置无效Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</p>
<p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以</p>
<p>下 3 个注解：</p>
<p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p>
<p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，</p>
<p>比如关闭数据源自动配置：@SpringBootApplication(exclude =</p>
<p>{ DataSourceAutoConfiguration.class })。</p>
<p>这就是 spring boot 的核心功能，自动配置。就是根据当前引入的 JAR 包进行自动配置，</p>
<p>比如： 引入了 jackson 的 jar 包，那么就会自动配置 json 转换，所以可以使用@ResponseBody 进行转换</p>
<p>引入了 spring boot 的 web 模块，就会自动配置 web.xml 等与 web 项目相关的内容，所以这些配置都不需要我们</p>
<p>自己配了。</p>
<p>@ComponentScan：Spring 组件扫描。 开启 Spring Boot 特性有哪几种方式？</p>
<p> 要成为一个 spring boot 项目，首先就必须在 pom.xml 中继承 spring-boot-starter-parent，同时指定其版本。</p>
<p> 导 入 spring-boot-dependencies 项 目 依 赖 ： spring-boot-starter-parent 的 源 码 中 又 继 承 了</p>
<p>spring-boot-dependencies。</p>
<h2 id="Spring-Boot-需要独立的容器运行吗？"><a href="#Spring-Boot-需要独立的容器运行吗？" class="headerlink" title="Spring Boot 需要独立的容器运行吗？"></a>Spring Boot 需要独立的容器运行吗？</h2><p>引入依赖：spring-boot-starter-web：代表 web 模块，在这个模块中含了许多 JAR 包，有 spring 相关的 jar，</p>
<p>内置 tomcat 服务器，jackson 等，这些 web 项目中常用的的功能都会自动引入。所以可以不需要独立容器运行。 运行 Spring Boot 有哪几种方式？</p>
<p> 打包用命令或者放到容器中运行</p>
<p> 用 Maven 命令（spring-boot:run）/ Gradle 插件运行</p>
<p> 直接执行 main 方法运行</p>
<h2 id="Spring-Boot-自动配置原理是什么？"><a href="#Spring-Boot-自动配置原理是什么？" class="headerlink" title="Spring Boot 自动配置原理是什么？"></a>Spring Boot 自动配置原理是什么？</h2><p>注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，首先</p>
<p>它得是一个配置文件，其次根据类路径下是否有这个类去自动配置。 如何理解 Spring Boot 中的 Starters？Starters 可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成</p>
<p>Spring 及其他技术，而不需要到处找示例代码和依赖包。如你想使用 Spring JPA 访问数据库，只</p>
<p>要加入 spring-boot-starter-data-jpa 启动器依赖就能使用了。</p>
<p>Starters 包含了许多项目中需要用到的依赖，它们能快速持续的运行，都是一系列得到支持的管理</p>
<p>传递性依赖. 例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="如何在-Spring-Boot-启动的时候运行一些特定的代码？"><a href="#如何在-Spring-Boot-启动的时候运行一些特定的代码？" class="headerlink" title="如何在 Spring Boot 启动的时候运行一些特定的代码？"></a>如何在 Spring Boot 启动的时候运行一些特定的代码？</h2><p>可以实现接口 ApplicationRunner 或者 CommandLineRunner，这两个接口实现方式一样，它们都只</p>
<p>提供了一个 run 方法. 实现 CommandLineRunner 接口的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCommandLineRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... var1)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"This will be execute when the project was started!"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现 ApplicationRunner 接口的代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.boot</span><span class="selector-class">.ApplicationArguments</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.boot</span><span class="selector-class">.ApplicationRunner</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.stereotype</span><span class="selector-class">.Component</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@Componentpublic</span> class MyApplicationRunner implements ApplicationRunner &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@Override</span></span><br><span class="line"></span><br><span class="line">public void run(ApplicationArguments var1) throws Exception&#123;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>("<span class="selector-tag">MyApplicationRunner</span> <span class="selector-tag">class</span> <span class="selector-tag">will</span> <span class="selector-tag">be</span> <span class="selector-tag">execute</span> <span class="selector-tag">when</span> <span class="selector-tag">the</span> <span class="selector-tag">project</span> <span class="selector-tag">was</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">started</span>!");</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Boot-有哪几种读取配置的方式？"><a href="#Spring-Boot-有哪几种读取配置的方式？" class="headerlink" title="Spring Boot 有哪几种读取配置的方式？"></a>Spring Boot 有哪几种读取配置的方式？</h2><p>Spring Boot 可以通过 @PropertySource,@Value,@Environment, @ConfigurationProperties 来绑定变</p>
<p>量</p>
<p>读取 application 文件</p>
<p> @Value 注解读取方式</p>
<p> @ConfigurationProperties 注解读取方式</p>
<p>读取指定文件</p>
<p> @PropertySource+@Value 注解读取方式</p>
<p> @PropertySource+@ConfigurationProperties 注解读取方式</p>
<p>@Environment 读取方式</p>
<h2 id="Spring-boot-和-spring-cloud-的区别与联系"><a href="#Spring-boot-和-spring-cloud-的区别与联系" class="headerlink" title="Spring boot 和 spring cloud 的区别与联系"></a>Spring boot 和 spring cloud 的区别与联系</h2><p> Spring boot 是 Spring 的一套快速配置脚手架，可以基于 spring boot 快速开发单个微服务，Spring Boot，</p>
<p>看名字就知道是 Spring 的引导，就是用于启动 Spring 的，使得 Spring 的学习和使用变得快速无痛。不仅</p>
<p>适合替换原有的工程结构，更适合微服务开发。</p>
<p> Spring Cloud 基于 Spring Boot，为微服务体系开发中的架构问题，提供了一整套的解决方案——服务注册</p>
<p>与发现，服务消费，服务保护与熔断，网关，分布式调用追踪，分布式配置管理等。 说明：</p>
<p> Spring Cloud 是一个基于 Spring Boot 实现的云应用开发工具，它是关注全局的服务治理框架；</p>
<p> Spring boot 专注于快速，方便集成的单个个体，使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置；</p>
<p>MyBatis 框架 mybatis 是一个基于 java 的持久层框架，它内部封装了 jdbc，不需要花费精力去处理加载驱动、创建连接</p>
<p>等的过程，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接；</p>
<p> mybatis 通过 xml 或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中 sql</p>
<p>的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。</p>
<p> MyBatis 支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参</p>
<p>数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的</p>
<p>POJO 映射成数据库中的记录。</p>
<p> 提供了很多第三方插件（分页插件 / 逆向工程）；</p>
<p> 能够与 Spring 很好的集成；</p>
<p> MyBatis 相当灵活，SQL 写在 XML 里，从程序代码中彻底分离，解除 sql 与程序代码的耦合，便于统一管理，支持编写动态 SQL 语句。</p>
<p> 提供映射标签，支持对象与数据库的 ORM 字段关系映射。</p>
<p> SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p>
<p> 很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis</p>
<p>都支持，而 JDBC 提供了可扩展性，所以只要这个数据库有针对 Java 的 jar 包就可以就可以与 MyBatis 兼</p>
<p>容），开发人员不需要考虑数据库的差异性。</p>
<p> 对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis 将是不错的选择。 SpringMVC 框架</p>
<h2 id="SpringMVC-框架的工作流程和常用注解"><a href="#SpringMVC-框架的工作流程和常用注解" class="headerlink" title="SpringMVC 框架的工作流程和常用注解"></a>SpringMVC 框架的工作流程和常用注解</h2><p>1、用户向服务器发送请求，请求被 SpringMVC 的前端控制器 DispatcherServlet 截获。</p>
<p>2、DispatcherServlet 对请求的 URL（统一资源定位符）进行解析，得到 URI(请求资源标识符)，然</p>
<p>后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象，包括 Handler 对象以</p>
<p>及 Handler 对象对应的拦截器，这些对象都会被封装到一个 HandlerExecutionChain 对象当中返回。</p>
<h2 id="-url-和-uri-的区别？"><a href="#-url-和-uri-的区别？" class="headerlink" title=" url 和 uri 的区别？"></a> url 和 uri 的区别？</h2><p>URI 包括 URL 和 URN 两个类别，个人的身份证号就是 URN，个人的家庭地址就是 URL，</p>
<p>URN 可以唯一标识一个人，而 URL 可以告诉邮递员怎么把货送到你手里。</p>
<p>3、DispatcherServlet 根据获得的 Handler，选择一个合适的 HandlerAdapter。HandlerAdapter 的设计</p>
<p>符合面向对象中的单一职责原则，代码结构清晰，便于维护，最为重要的是，代码的可复制性高。</p>
<p>HandlerAdapter 会被用于处理多种 Handler，调用 Handler 实际处理请求的方法。</p>
<p>4、提取请求中的模型数据，开始执行 Handler(Controller)。在填充 Handler 的入参过程中，根据配</p>
<p>置，spring 将帮助做一些额外的工作</p>
<p> 消息转换：将请求的消息，如 json、xml 等数据转换成一个对象，将对象转换为指定的响应信息。</p>
<p> 数据转换：对请求消息进行数据转换，如 String 转换成 Integer、Double 等。</p>
<p> 数据格式化：对请求的消息进行数据格式化，如将字符串转换为格式化数字或格式化日期等。</p>
<p> 数据验证：验证数据的有效性如长度、格式等，验证结果存储到 BindingResult 或 Error 中。5、Handler 执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象，ModelAndView 对象中</p>
<p>应该包含视图名或视图模型。</p>
<p>6、根据返回的 ModelAndView 对象，选择一个合适的 ViewResolver(视图解析器)返回给</p>
<p>DispatcherServlet。</p>
<p>7、ViewResolver 结合 Model 和 View 来渲染视图。</p>
<p>8、将视图渲染结果返回给客户端。</p>
<p>以上 8 个步骤，DispatcherServlet、HandlerMapping、HandlerAdapter 和 ViewResolver 等对象协同工</p>
<p>作，完成 SpringMVC 请求—&gt;响应的整个工作流程，这些对象完成的工作对于开发者来说都是不可</p>
<p>见的，开发者并不需要关心这些对象是如何工作的，开发者，只需要在 Handler(Controller)当中完</p>
<p>成对请求的业务处理。 组件型注解：@Component 在类定义之前添加@Component 注解，他会被 spring 容器识别，并转为 bean。</p>
<p>@Repository 对 Dao 实现类进行注解 (特殊的@Component)</p>
<p>@Service 用于对业务逻辑层进行注解， (特殊的@Component)</p>
<p>@Controller 用于控制层注解 ， (特殊的@Component)</p>
<p>请求和参数型注解：</p>
<p>@RequestMapping：用于处理请求地址映射，可以作用于类和方法上。</p>
<p>@RequestParam：用于获取传入参数的值</p>
<p>@PathViriable：用于定义路径参数值</p>
<p>@ResponseBody：作用于方法上，可以将整个返回结果以某种格式返回，如 json 或 xml 格式。</p>
<p>@CookieValue：用于获取请求的 Cookie 值</p>
<p>Dubbo+Zookeeper 服务框架</p>
<p>Dubbo:</p>
<h2 id="简单的介绍一下-Dubbo？-Dubbo-是什么"><a href="#简单的介绍一下-Dubbo？-Dubbo-是什么" class="headerlink" title="简单的介绍一下 Dubbo？(Dubbo 是什么)"></a>简单的介绍一下 Dubbo？(Dubbo 是什么)</h2><p>dubbo 就是个服务调用的东东。为什么怎么说呢？因为 Dubbo 是由阿里开源的一个 RPC 分布式框</p>
<p>架。那么 RPC 是什么呢？就是不同的应用部署到不同的服务器上，应用之间想要调用没有办法直</p>
<p>接调用，因为不在一个内存空间，需要通过网络通讯来调用，或者传达调用的数据。而且 RPC 会</p>
<p>将远程调用的细节隐藏起来，让调用远程服务像调用本地服务一样简单。</p>
<h2 id="Dubbo-有哪些组件？"><a href="#Dubbo-有哪些组件？" class="headerlink" title="Dubbo 有哪些组件？"></a>Dubbo 有哪些组件？</h2><p>主要有五个角色/核心组件，分为是 Container（容器）、Provider（服务的提供方）、Registry（注</p>
<p>册中心）、Consumer（服务的消费方）、Monitor（监控中心）。</p>
<p>Container 容器：主要负责启动、加载、运行服务提供者；</p>
<p>Registry 注册中心：注册中心只负责地址的注册和查找</p>
<p>Monitor 监控中心：监控中心负责统计各服务调用次数、调用时间</p>
<p>Dubbo 支持什么协议？</p>
<p>Dubbo 协议：缺省协议、采用了单一长连接和 NIO 异步通讯、使用线程池并发处理请求，能减少</p>
<p>握手和加大并发效率Zookeeper:</p>
<h2 id="Zookeeper-的实现原理？（工作原理）"><a href="#Zookeeper-的实现原理？（工作原理）" class="headerlink" title="Zookeeper 的实现原理？（工作原理）"></a>Zookeeper 的实现原理？（工作原理）</h2><p>Zookeeper 会维护一个类似于标准的文件系统的具有层次关系的数据结构。这个文件系统中每个子</p>
<p>目录项都被称为 znode 节点，这个 znode 节点也可以有子节点，每个节点都可以存储数据，客户</p>
<p>端也可以对这些 node 节点进行 getChildren，getData,exists 方法，同时也可以在 znode tree 路径上</p>
<p>设置 watch（类似于监听），当 watch 路径上发生节点 create、delete、update 的时候，会通知到</p>
<p>client。client 可以得到通知后，再获取数据，执行业务逻辑操作。Zookeeper 的作用主要是用来维</p>
<p>护和监控存储的 node 节点上这些数据的状态变化，通过监控这些数据状态的变化，从而达到基于</p>
<p>数据的集群管理。 为什么要用 zookeeper 作为 dubbo 的注册中心？能选择其他的吗？</p>
<p>Zookeeper 的数据模型是由一系列的 Znode 数据节点组成，和文件系统类似。zookeeper 的数据全</p>
<p>部存储在内存中，性能高；zookeeper 也支持集群，实现了高可用；同时基于 zookeeper 的特性，</p>
<p>也支持事件监听（服务的暴露方发生变化，可以进行推送），所以 zookeeper 适合作为 dubbo 的</p>
<p>注册中心使用。redis、Simple 也可以作为 dubbo 的注册中心来使用。项目中主要用 zookeeper 做</p>
<p>了什么？（作用）作为注册中心用；主要是在服务器上搭建 zookeeper，其次在 spring 管理的 dubbo的配置文件中配置（暴露方和消费方都需要配置）</p>
<h3 id="对分布式，dubbo，zookeeper-说的不太清楚"><a href="#对分布式，dubbo，zookeeper-说的不太清楚" class="headerlink" title="对分布式，dubbo，zookeeper 说的不太清楚"></a>对分布式，dubbo，zookeeper 说的不太清楚</h3><p>分布式是从项目业务角度考虑划分项目整个架构。可以将项目基于功能模块划分再分别部署。</p>
<p>Dubbo 是实现分布式项目部署框架。在 zookeeper 是 dubbo 分布式框架的注册中心，管理服务的注册和调用。</p>
<h2 id="Zookeeper-待机的情况下，dubbo-如何工作？"><a href="#Zookeeper-待机的情况下，dubbo-如何工作？" class="headerlink" title="Zookeeper 待机的情况下，dubbo 如何工作？"></a>Zookeeper 待机的情况下，dubbo 如何工作？</h2><p>Zookeeper 的作用：</p>
<p>zookeeper 用来注册服务和进行负载均衡，哪一个服务由哪一个机器来提供必需让调用者知道，</p>
<p>简单来说就是 ip 地址和服务名称的对应关系。当然也可以通过硬编码的方式把这种对应关系在调</p>
<p>用方业务代码中实现，但是提供服务的机器挂掉，调用者无法知晓，如果不更改代码会继续请求</p>
<p>挂掉的机器提供服务。 而 zookeeper 通过心跳机制可以检测挂掉的机器并将挂掉机器的 ip 和服务</p>
<p>对应关系从列表中删除。至于支持高并发，简单来说就是横向扩展，在不更改代码的情况通过添</p>
<p>加机器来提高运算能力。通过添加新的机器向 zookeeper 注册服务，服务的提供者多了能服务的客</p>
<p>户就多了。</p>
<h2 id="Dubbo-的作用："><a href="#Dubbo-的作用：" class="headerlink" title="Dubbo 的作用："></a>Dubbo 的作用：</h2><p>是管理中间层的工具，在业务层到数据仓库间有非常多服务的接入和服务提供者需要调度，dubbo</p>
<p>提供一个框架解决这个问题。注意这里的 dubbo 只是一个框架，至于你架子上放什么是完全取决于你的，就像一个汽车骨架，你需要配你的轮子引擎。这个框架中要完成调度必须要有一个分布式</p>
<p>的注册中心，储存所有服务的元数据，你可以用 zk，也可以用别的，只是大家都用 zk。</p>
<h2 id="zookeeper-和-dubbo-的关系："><a href="#zookeeper-和-dubbo-的关系：" class="headerlink" title="zookeeper 和 dubbo 的关系："></a>zookeeper 和 dubbo 的关系：</h2><p>Dubbo 的将注册中心进行抽象，使得它可以外接不同的存储媒介给注册中心提供服务，有</p>
<p>ZooKeeper，Memcached，Redis 等。引入了 ZooKeeper 作为存储媒介，也就把 ZooKeeper 的特性引进来。</p>
<p> 首先是负载均衡，单注册中心的承载能力是有限的，在流量达到一定程度的时候就需要分流，负载均衡就是为了分流而存在的，一个 ZooKeeper 集群配合相应的 Web 应用就可以很容易达到负载均衡；</p>
<p> 资源同步，单单有负载均衡还不够，节点之间的数据和资源需要同步，ZooKeeper 集群就天然具备有这样的功能：命名服务。</p>
<p> 命名服务：将树状结构用于维护全局的服务地址列表，服务提供者在启动的时候，向 ZK 上的指定节点/dubbo/${serviceName}/providers 目录下写入自己的 URL 地址，这个操作就完成了服务的发布。 其他特性还有 Mast 选举，分布式锁等。</p>
<h3 id="Dubbo，Zookeeper，Nginx-说不清楚"><a href="#Dubbo，Zookeeper，Nginx-说不清楚" class="headerlink" title="Dubbo，Zookeeper，Nginx 说不清楚"></a>Dubbo，Zookeeper，Nginx 说不清楚</h3><p> Dubbo 是 Alibaba 开源的分布式服务框架，它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo 采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出服务提供方</p>
<p>（Provider）和服务消费方（Consumer）两个角色。</p>
<p> ZooKeeper 是 Apache 的一个顶级项目，为分布式应用提供高效、高可用的分布式协调服务，提供了诸</p>
<p>如数据发布/订阅、负载均衡、命名服务、分布式协调/通知和分布式锁等分布式基础服务。由于 ZooKeeper</p>
<p>便捷的使用方式、卓越的性能和良好的稳定性，被广泛地应用于诸如 Hadoop、HBase、Kafka 和 Dubbo 等大型分布式系统中。</p>
<p> Nginx 是一款自由的、开源的、高性能的 HTTP 服务器和反向代理服务器；同时也是一个 IMAP、POP3、</p>
<p>SMTP 代理服务器；Nginx 可以作为一个 HTTP 服务器进行网站的发布处理，另外 Nginx 可以作为反向代理</p>
<h2 id="进行负载均衡的实现。-如何保证-dubbo-高可用"><a href="#进行负载均衡的实现。-如何保证-dubbo-高可用" class="headerlink" title="进行负载均衡的实现。 如何保证 dubbo 高可用?"></a>进行负载均衡的实现。 如何保证 dubbo 高可用?</h2><p>zookeeper 宕机与 dubbo 直连：在实际生产中，假如 zookeeper 注册中心宕掉，一段时间内服务消</p>
<p>费方还是能够调用提供方的服务的，实际上它使用的本地缓存进行通讯，这只是 dubbo 健壮性的</p>
<p>一种。</p>
<h2 id="dubbo-的健壮性表现："><a href="#dubbo-的健壮性表现：" class="headerlink" title="dubbo 的健壮性表现："></a>dubbo 的健壮性表现：</h2><p> 监控中心宕掉不影响使用，只是丢失部分采样数据</p>
<p> 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</p>
<p> 注册中心对等集群，任意一台宕掉后，将自动切换到另一台</p>
<p> 注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</p>
<p> 服务提供者无状态，任意一台宕掉后，不影响使用</p>
<p> 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复注册中心的作用在于保存服务提供者的位置信息，我们可以完全可以绕过注册中心——采用 dubbo</p>
<p>直连，即在服务消费方配置服务提供方的位置信息。点对点直连方式，将以服务接口为单位，忽略</p>
<p>注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表。</p>
<h2 id="xml-配置方式"><a href="#xml-配置方式" class="headerlink" title="xml 配置方式"></a>xml 配置方式</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:reference <span class="attribute">id</span>=<span class="string">"userService"</span> <span class="attribute">interface</span>=<span class="string">"com.zang.gmall.service.UserService"</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">url</span>=<span class="string">"dubbo://localhost:20880"</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>注解上直接添加</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@Reference</span>(url = <span class="string">"127.0.0.1:20880"</span>)</span><br><span class="line"></span><br><span class="line">UserService userService;</span><br></pre></td></tr></table></figure>

<h2 id="集群下-dubbo-负载均衡配置"><a href="#集群下-dubbo-负载均衡配置" class="headerlink" title="集群下 dubbo 负载均衡配置"></a>集群下 dubbo 负载均衡配置</h2><p>在集群负载均衡时，Dubbo 提供了 4 种均衡策略，如：Random LoadBalance(随机均衡算法)、</p>
<p>RoundRobin LoadBalance(权重轮循均衡算法)、LeastAction LoadBalance(最少活跃调用数均衡算法)、</p>
<p>ConsistentHash LoadBalance(一致性 Hash 均衡算法)。缺省时为 Random 随机调用。@Reference(loadbalance = “roundrobin”)</p>
<p>UserService userService;</p>
<p>服务方方法级别配置（基于 xml 配置的权重轮询均衡算法）</p>
<p>&lt;dubbo:service interface=”com.zang.gmall.service.UserService”</p>
<p>&lt;dubbo:method name=”getUserAddressList” loadbalance=”roundrobin”&gt;</p>
<p></p>
<h2 id="权重设置"><a href="#权重设置" class="headerlink" title="权重设置"></a>权重设置</h2><p>当不设置负载均衡策略，即采用默认的 Random LoadBalance(随机均衡算法)时，默认每个服务的权</p>
<p>重相同，我们可以通过设置权重来分配访问的随机性。权重默认为 100，可以在暴露服务的同时设</p>
<p>置。</p>
<h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p>当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换</p>
<p>种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。可以通过服务降</p>
<p>级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略（不调用服务即返回为空 or 调</p>
<p>用失败返回为空）。</p>
<p>向注册中心写入动态配置覆盖规则：</p>
<p>RegistryFactory registryFactory =</p>
<p>ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();</p>
<p>Registry registry =</p>
<p>registryFactory.getRegistry(URL.valueOf(“zookeeper://10.20.153.10:2181”));</p>
<p>registry.register(URL.valueOf(“override://0.0.0.0/com.foo.BarService?category=configu</p>
<p>rators&amp;dynamic=false&amp;application=foo&amp;mock=force:return+null”));</p>
<p>其中：</p>
<p> mock=force:return+null 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽</p>
<p>不重要服务不可用时对调用方的影响。</p>
<p> 还可以改为 mock=fail:return+null 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。</p>
<p>用来容忍不重要服务不稳定时对调用方的影响。 通过操作管理控制台也可以方便的进行服务降级</p>
<h2 id="集群容错"><a href="#集群容错" class="headerlink" title="集群容错"></a>集群容错</h2><p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p>
<p>集群容错模式主要有以下几种： Failover Cluster：失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=”2” 来设置重试次数(不含第一次)。消费方服务级注解添加（不能到方法级）</p>
<p> Failfast Cluster：快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p>
<p> Failsafe Cluster：失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p>
<p> Failback Cluster：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p>
<p> Forking Cluster：并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2” 来设置最大并行数。</p>
<p> Broadcast Cluster：广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。 集群模式配置方法：在服务提供方和消费方配置集群模式</p>
<h2 id="整合-hystrix"><a href="#整合-hystrix" class="headerlink" title="整合 hystrix"></a>整合 hystrix</h2><p>Hystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大</p>
<p>的容错能力。Hystrix 具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，</p>
<p>以及监控和配置等功能。spring boot 官方提供了对 hystrix 的集成，直接在 pom.xml 里加入依赖：</p>
<dependency>

<p><groupId>org.springframework.cloud</groupId></p>
<p><artifactId>spring-cloud-starter-netflix-hystrix</artifactId></p>
<p><version>1.4.4.RELEASE</version></p>
</dependency>

<p>然后在 Application 类上增加@EnableHystrix 来启用 hystrix starter：</p>
<p>配置服务提供方：在 Dubbo 的 Provider 上增加@HystrixCommand 配置，这样子调用就会经过 Hystrix</p>
<p>代理。</p>
<p>配置服务消费方：对于 Consumer 端，则可以增加一层 method 调用，并在 method 上配置</p>
<p>@HystrixCommand 。当调用出错时，会走到 fallbackMethod = “reliable” 的调用里。@HystrixCommand 注解设置的 reliable 调用方法的里的参数要和 method 的参数保持一致。</p>
<h2 id="Zookeeper-怎样进行服务治理。"><a href="#Zookeeper-怎样进行服务治理。" class="headerlink" title="Zookeeper 怎样进行服务治理。"></a>Zookeeper 怎样进行服务治理。</h2><p>接受提供者的接口信息和提供者 ip 地址进行存储，然后管理消费者和提供者之间调用关系！</p>
<h2 id="如果-zookeeper-服务挂了怎么办，服务调用可以进行吗？"><a href="#如果-zookeeper-服务挂了怎么办，服务调用可以进行吗？" class="headerlink" title="如果 zookeeper 服务挂了怎么办，服务调用可以进行吗？"></a>如果 zookeeper 服务挂了怎么办，服务调用可以进行吗？</h2><p>注册中心对等集群，任意一台宕掉后，会自动切换到另一台</p>
<p>注册中心全部宕掉，服务提供者和消费者仍可以通过本地缓存通讯</p>
<p>服务提供者无状态，任一台宕机后，不影响使用</p>
<p>服务提供者全部宕机，服务消费者会无法使用，并无限次重连等待服务者恢复</p>
<h2 id="Dubbo-有-3-次重试，假如新消息被重复消费怎么处理"><a href="#Dubbo-有-3-次重试，假如新消息被重复消费怎么处理" class="headerlink" title="Dubbo 有 3 次重试，假如新消息被重复消费怎么处理"></a>Dubbo 有 3 次重试，假如新消息被重复消费怎么处理</h2><p> 去掉超时重试机制</p>
<p> 服务端增加幂等校验，服务器加入校验机制，如果这个消息已被消费就不再重复消费</p>
<p>Dubbo 的通信原理？</p>
<p> Dubbo 底层使用 hessain2 进行二进制序列化进行远程调用</p>
<p> Dubbo 底层使用 netty 框架进行异步通信。NIO</p>
<p>高并发，高可用，负载均衡</p>
<p>高并发解决方案：1）数据层</p>
<p> 数据库集群和库表散列</p>
<p> 分表分库</p>
<p> 开启索引</p>
<p> 开启缓存</p>
<p> 表设计优化</p>
<p> Sql 语句优化</p>
<p> 缓存服务器（提高查询效率，减轻数据库压力）</p>
<p> 搜索服务器（提高查询效率，减轻数据库压力）</p>
<p> 图片服务器分离</p>
<p>2）项目层</p>
<p> 采用面向服务分布式架构（分担服务器压力，提高并发能力）</p>
<p> 采用并发访问较高的详情系统采用静态页面，HTML 静态化 freemaker  使用页面缓存</p>
<p> 用 ActiveMQ 使得业务进一步进行解耦，提高业务处理能力</p>
<p> 使用分布式文件系统存储海量文件</p>
<p>3）应用层</p>
<p> Nginx 服务器来做负载均衡</p>
<p> Lvs 做二层负载</p>
<p> 镜像</p>
<h2 id="处理高并发常见的方法有哪些？"><a href="#处理高并发常见的方法有哪些？" class="headerlink" title="处理高并发常见的方法有哪些？"></a>处理高并发常见的方法有哪些？</h2><p>1、HTML 静态化 freemaker</p>
<p>其实大家都知道，效率最高、消耗最小的就是纯静态化的 html 页面，所以我们尽可能使我们的网</p>
<p>站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。但是对于大量内容并</p>
<p>且频繁更新的网站，我们无法全部手动去挨个实现，于是出现了我们常见的信息发布系统 CMS，</p>
<p>像我们常访问的各个门户站点的新闻频道，甚至他们的其他频道，都是通过信息发布系统来管理和</p>
<p>实现的，信息发布系统可以实现最简单的信息录入自动生成静态页面，还能具备频道管理、权限管</p>
<p>理、自动抓取等功能，对于一个大型网站来说，拥有一套高效、可管理的 CMS 是必不可少的。除</p>
<p>了门户和信息发布类型的网站，对于交互性要求很高的社区类型网站来说，尽可能的静态化也是提</p>
<p>高性能的必要手段，将社区内的帖子、文章进行实时的静态化，有更新的时候再重新静态化也是大</p>
<p>量使用的策略，像 Mop 的大杂烩就是使用了这样的策略，网易社区等也是如此。同时，html 静态</p>
<p>化也是某些缓存策略使用的手段，对于系统中频繁使用数据库查询但是内容更新很小的应用，可以</p>
<p>考虑使用 html 静态化来实现，比如论坛中论坛的公用设置信息，这些信息目前的主流论坛都可以</p>
<p>进行后台管理并且存储再数据库中，这些信息其实大量被前台程序调用，但是更新频率很小，可以</p>
<p>考虑将这部分内容进行后台更新的时候进行静态化，这样避免了大量的数据库访问请求。</p>
<p>2、图片服务器分离</p>
<p>大家知道，对于 Web 服务器来说，不管 是 Apache、IIS 还是其他容器，图片是最消耗资源的，于</p>
<p>是我们有必要将图片与页面进行分离，这是基本上大型网站都会采用的策略，他们都有独立的图</p>
<p>片服务器，甚至很多台图片服务器。这样的架构可以降低提供页面访问请求的服务器系统压力，并</p>
<p>且可以保证系统不会因为图片问题而崩溃，在应用服务器和图片服务器 上，可以进行不同的配置优化，比如 apache 在配置 ContentType 的时候可以尽量少支持，尽可能少的 LoadModule，保证更</p>
<p>高的系统消耗和执行效率。</p>
<p>3、数据库集群和库表散列</p>
<p>大型网站都有复杂的应用，这些应用必须使用数据库，那么在面对大量访问的时候，数据库的瓶颈</p>
<p>很快就能显现出来，这时一台数据库将很快无法满足应用，于是我们需要使用数据库集群或者库表</p>
<p>散列。在数据库集群方面，很多数据库都有自己的解决方案，Oracle、Sybase 等都有很好的方案，</p>
<p>常用的 MySQL 提供的 Master/Slave 也是类似的方案，您使用了什么样的 DB，就参考相应的解决方</p>
<p>案来实施即可。上面提到的数据库集群由于在架构、成本、扩张性方面都会受到所采用 DB 类型的</p>
<p>限制，于是我们需要从应用程序的角度来考虑改善系统架构，库表散列是常用并且最有效的解决方</p>
<p>案。我们在应用程序中安装业务和应用或者功能模块将数据库进行分离，不同的模块对应不同的数</p>
<p>据库或者表，再按照一定的策略对某个页面或者功能进行更小的数据库散列，比如用户表，按照用</p>
<p>户 ID 进行表散列，这样就能够低成本的提升系统的性能并且有很好的扩展性。sohu 的论坛就是采</p>
<p>用了这样的架 构，将论坛的用户、设置、帖子等信息进行数据库分离，然后对帖子、用户按照板</p>
<p>块和 ID 进行散列数据库和表，最终可以在配置文件中进行简单的配置便能让系统随时增加一台低</p>
<p>成本的数据库进来补充系统性能。</p>
<p>4、缓存</p>
<p>缓存一词搞技术的都接触过，很多地方用到缓存。网站架构和网站开发中的缓存也是非常重要。这</p>
<p>里先讲述最基本的两种缓存。高级和分布式的缓存在后面讲述。架构方面的缓存，对 Apache 比较</p>
<p>熟悉的人都能知道 Apache 提供了自己的缓存模块，也可以使用外加的 Squid 模块进行缓存，这两</p>
<p>种方式均可以有效的提高 Apache 的访问响应能力。 网站程序开发方面的缓存，Linux 上提供的</p>
<p>Memory Cache 是常用的缓存接口，可以在 web 开发中使用，比如用 Java 开发的时候就可以调用</p>
<p>MemoryCache 对一些数据进行缓存和通讯共享，一些大型社区使用了这样的架构。另外，在使用</p>
<p>web 语言开发的时候，各种语言基本都有自己的缓存模块和方法，PHP 有 Pear 的 Cache 模块，Java</p>
<p>就更多了。</p>
<p>5、镜像</p>
<p>镜像是大型网站常采用的提高性能和数据安全性的方式，镜像的技术可以解决不同网络接入商和地</p>
<p>域带来的用户访问速度差异，比如 ChinaNet 和 EduNet 之间的差异就促使了很多网站在教育网内搭</p>
<p>建镜像站点，数据进行定时更新或者实时更新。在镜像的细节技术方面，这里不阐述太深，有很多</p>
<p>专业的现成的解决架构和产品可选。也有廉价的通过软件实现的思路，比如 Linux 上的 rsync 等工</p>
<p>具。</p>
<p>6、负载均衡</p>
<p>负载均衡将是大型网站解决高负荷访问和大量并发请求采用的终极解决办法。 负载均衡技术发展</p>
<p>了多年，有很多专业的服务提供商和产品可以选择。 高并发下电商网站的秒杀活动</p>
<p>秒杀实现思路</p>
<p>秒杀技术实现核心思想是运用缓存减少数据库瞬间的访问压力！读取商品详细信息时运用缓存，</p>
<p>当用户点击抢购时减少 redis 中的库存数量，当库存数为 0 时或活动期结束时，同步到数据库。 产</p>
<p>生的秒杀预订单也不会立刻写到数据库中，而是先写到缓存，当用户付款成功后再写入数据库。所</p>
<p>有买家在同一时间网上抢购的一种销售方式。通俗一点讲就是网络商家为促销等目的组织的网上限</p>
<p>时抢购活动。由于商品价格低廉，往往一上架就被抢购一空，有时只用一秒钟。秒杀商品通常有两种限制：库存限制、时间限制。</p>
<p>需求：</p>
<p> 商家提交秒杀商品申请，录入秒杀商品数据，主要包括：商品标题、原价、秒杀价、商品图片、介绍等</p>
<p>信息</p>
<p> 运营商审核秒杀申请</p>
<p> 秒杀频道首页列出秒杀商品（进行中的）点击秒杀商品图片跳转到秒杀商品详细页。</p>
<p> 商品详细页显示秒杀商品信息，点击立即抢购实现秒杀下单，下单时扣减库存。当库存为 0 或不在活动</p>
<p>期范围内时无法秒杀。</p>
<p> 秒杀下单成功，直接跳转到支付页面（微信扫码），支付成功，跳转到成功页，填写收货地址、电话、</p>
<p>收件人等信息，完成订单。</p>
<p> 当用户秒杀下单 5 分钟内未支付，取消预订单，调用微信支付的关闭订单接口，恢复库存。 秒杀架构设计理念</p>
<p> 限流： 鉴于只有少部分用户能够秒杀成功，所以要限制大部分流量，只允许少部分流量进入服务后端。</p>
<p> 削峰：对于秒杀系统瞬时会有大量用户涌入，所以在抢购一开始会有很高的瞬间峰值。高峰值流量是压</p>
<p>垮系统很重要的原因，所以如何把瞬间的高流量变成一段时间平稳的流量也是设计秒杀系统很重要的思</p>
<p>路。实现削峰的常用的方法有利用缓存和消息中间件等技术。</p>
<p> 异步处理：秒杀系统是一个高并发系统，采用异步处理模式可以极大地提高系统并发量，其实异步处理</p>
<p>就是削峰的一种实现方式。</p>
<p> 内存缓存：秒杀系统最大的瓶颈一般都是数据库读写，由于数据库读写属于磁盘 IO，性能很低，如果能</p>
<p>够把部分数据或业务逻辑转移到内存缓存，效率会有极大地提升。</p>
<p> 可拓展：当然如果我们想支持更多用户，更大的并发，最好就将系统设计成弹性可拓展的，如果流量来</p>
<p>了，拓展机器就好了。像淘宝、京东等双十一活动时会增加大量机器应对交易高峰。 前端方案：浏览器端</p>
<p> 页面静态化：将活动页面上的所有可以静态的元素全部静态化，并尽量减少动态元素。通过 CDN 来抗峰</p>
<p>值。</p>
<p> 禁止重复提交：用户提交之后按钮置灰，禁止重复提交</p>
<p> 用户限流：在某一时间段内只允许用户提交一次请求，比如可以采取 IP 限流</p>
<p>后端方案：服务端控制器层(网关层)  限制 uid（UserID）访问频率：我们上面拦截了浏览器访问的请求，但针对某些恶意攻击或其它插件，在服务端控制层需要针对同一个访问 uid，限制访问频率。</p>
<p> 服务层：上面只拦截了一部分访问请求，当秒杀的用户量很大时，即使每个用户只有一个请求，到服务层的请求数量还是很大。比如我们有 100W 用户同时抢 100 台手机，服务层并发请求压力至少为 100W。</p>
<p> 采用消息队列缓存请求：既然服务层知道库存只有 100 台手机，那完全没有必要把 100W 个请求都传递到数据库啊，那么可以先把这些请求都写到消息队列缓存一下，数据库层订阅消息减库存，减库存成功的请求返回秒杀成功，失败的返回秒杀结束。</p>
<p> 利用缓存应对读请求：对类似于 12306 等购票业务，是典型的读多写少业务，大部分请求是查询请求，所以可以利用缓存分担数据库压力。</p>
<p> 利用缓存应对写请求：缓存也是可以应对写请求的，比如我们就可以把数据库中的库存数据转移到 Redis缓存中，所有减库存操作都在 Redis 中进行，然后再通过后台进程把 Redis 中的用户秒杀请求同步到数据库中。 数据库层：数据库层是最脆弱的一层，一般在应用设计时在上游就需要把请求拦截掉，数据库层只承担“能力范围内”的访问请求。所以，上面通过在服务层引入队列和缓存，让最底层的数据库高枕无忧。 使用 Redis 缓存实现秒杀：</p>
<p>Redis 是一个分布式缓存系统，支持多种数据结构，我们可以利用 Redis 轻松实现一个强大的秒杀</p>
<p>系统。我们可以采用 Redis 最简单的 key-value 数据结构，用一个原子类型的变量值(AtomicInteger)</p>
<p>作为 key，把用户 id 作为 value，库存数量便是原子变量的最大值。对于每个用户的秒杀，我们使</p>
<p>用 RPUSH key value 插入秒杀请求， 当插入的秒杀请求数达到上限时，停止所有后续插入。然后</p>
<p>我们可以在台启动多个工作线程，使用 LPOP key 读取秒杀成功者的用户 id，然后再操作数据库做</p>
<p>最终的下订单减库存操作。当然，上面 Redis 也可以替换成消息中间件如 ActiveMQ、RabbitMQ 等，也可以将缓存和消息中间件 组合起来，缓存系统负责接收记录用户请求，消息中间件负责将缓存中的请求同步到数据库。</p>
<h2 id="当商品库存数量不足时，如何保证不会超卖？"><a href="#当商品库存数量不足时，如何保证不会超卖？" class="headerlink" title="当商品库存数量不足时，如何保证不会超卖？"></a>当商品库存数量不足时，如何保证不会超卖？</h2><p>当库存数量不足时，必须保证库存不能被减为负数，</p>
<p>如果不加以控制，库存被减为小于等于 0 的数，那么这就叫做超卖。</p>
<p>那么如何防止超卖的现象发生呢？</p>
<p> 场景一： 如果系统并发要求不是很高：那么此时库存就可以存储在数据库中，数据库中加锁控制库存的</p>
<p>超卖现象。</p>
<p> 场景二：系统的并发量很大：如果系统并发量很大，那么就不能再使用数据库来进行减库存操作了，因为数据库加锁操作本身是以损失数据库的性能来进行控制数据库数据的一致性的。但是当并发量很大的时候，将会导致数据库排队，发生阻塞。因此必须使用一个高效的 nosql 数据库服务器来进行减库存。</p>
<p>此时可以使用 redis 服务器来存储库存，redis 是一个内存版的数据库，查询效率相当的高，可以使用 watch来监控减库存的操作，一旦发现库存被减为 0，立马停止售卖操作。 做交易或是金融系统安全性需要从哪些方面考虑？没有用什么第三方可以框架？</p>
<p>ip 黑白名单，访问日志明细记录，防止重复提交，访问频率控制，分布式锁，数据前后端校验，自</p>
<p>动对账任务处理，互联网金融项目一般情况下，不建议自动重试，最好结合对账系统，人工进行处</p>
<p>理，写好人工处理的接口就好。其他就是控制好数据的一致性了，这个最重要，其次还要保证接口</p>
<p>的幂等性，不要重复处理订单。这些是最基本的安全控制了。像这类网站用户的输入数据一般都不</p>
<p>会太多，一般敏感词过滤，广告之类的可以忽略，如果有的话还要控制这些。安全框架选 shiro 了，</p>
<p>在系统中分配好角色就好了，控制好用户的资源访问。其他的用 springmvc 就够了。</p>
<h3 id="讲一下高并发下的电商项目每台服务器的集群数量："><a href="#讲一下高并发下的电商项目每台服务器的集群数量：" class="headerlink" title="讲一下高并发下的电商项目每台服务器的集群数量："></a>讲一下高并发下的电商项目每台服务器的集群数量：</h3><p>项目中一共 15 台项目服务，那么为了每一台高可用一主一备，但首页项目高并发设为四台服务器，</p>
<p>则一共 32 台项目服务器，再加 redis 集群用了 3 台，为了每一台高可用一主一备一共 6 台，fastdfs 一个 trackerServer 一个 storageServer 搭建集群一共 6 台，solr 集群 7 台服务器，nginx 为了高可用</p>
<p>一主一备一共 2 台，mysql 数据库集群 3 台！activemq 消息中间件高可用 2 台；</p>
<p>共计：58 台服务器！</p>
<h2 id="介绍一下高并发的电商项目："><a href="#介绍一下高并发的电商项目：" class="headerlink" title="介绍一下高并发的电商项目："></a>介绍一下高并发的电商项目：</h2><p>我最近的一个项目是一个电商项目，我主要负责的是后台管理和商品详情的模块，然后也会参与到</p>
<p>购物车和订单模块。这个项目是以 SpringBoot 和 mybatis 为框架，应为 springBoot 相对于 SSM 来说配置方面，还有操作方面简单很多。然后是采用 zookeeper 加 dubbo 分布式架构和 RPC 远程调用，因为他 Dubbo 实现了软负载均衡，其特点是成本低，但也会有缺点，就是负载能力会受服务器本身影响，然后为了解决软负载均衡的缺点，我们使用了 Nginx 进行负载均衡的轮询算法，但 Nginx</p>
<p>主要在我们项目还是实现反向代理，就是可以防止外网对内网服务器的恶性攻击、缓存以减少服务</p>
<p>器的压力和访问安全控制。基础模块就有后台管理，商品详情，订单，支付，物流情况，库存服务。</p>
<p>然后 SpringBoot 整合 Thymeleaf 模块技术开发项目商品详情模块，easyUI 开发后台管理项目。至于我负责的两个模块呢，就是后台管理和商品详情，其中呢使用了 sku 和 spu 的数据表结构进行增删改查，spu 就好比我们要买一台 Mate20，但是我们没有选择它是什么配置，那么关于详细的配置</p>
<p>就是 sku 了，就是我要买一台 Mate20，黑色，内存是 128G 的。商品详情和商品列表模块使用 Nginx实现集群，使用 Redis 解决应用服务器的 cpu 和内存压力，减少 io 的读操作，减轻 io 的压力，使用分布式锁防止 Redis 缓存击穿。其中 Redis 的作用我是觉得挺大的，因为他可以防止过多的用户去直接访问我们的数据库，当然，Redis 也会在高并发的时候宕机，在使用 Redis 做缓存的时候，我们使用 Redis 持久化功能，防止 Redis 宕机后数据丢失，如果 Redis 宕机了，用户就会大量的去访问数据库，从而我们数据库也会崩溃吧。这个时候我们就用了一个分布式锁，用户需要获得一个</p>
<p>锁才能访问我们的数据库，当然啦，并不只是只有一个锁，而是锁的数量是有限的，当一位用户查</p>
<p>完了数据之后，锁就会释放，给下位用户，这也就是服务降降级。没有获得锁的用户，页面就一直</p>
<p>刷新直到自己拿到锁为止。redis 提供了持久化功能——RDB 和 AOF。通俗的讲就是将内存中的数据</p>
<p>写入硬盘中。在实际应用中，用户如果要查询商品的话呢，首先回到 Redis 缓存里面找的，如果找</p>
<p>不到，就会到数据库里面找，然后缓存到 Redis 中，那么下一次或者下一个用户需要查找这个数据</p>
<p>就不必到数据库中查找了！然后我还参与了购物车和订单模块的开发。购物车模块里面呢，我先和</p>
<p>您讲下他的业务逻辑吧。就像你逛网页淘宝一样，在没有登录的时候，把东西放入购物车，它是不</p>
<p>会和你的账号里的商品合并的，这个时候，商品就会以 cookie 的形式，放到你的浏览器里面。这</p>
<p>个时候如果你想购买这些商品的时候，你就要登录，这个时候就会使用到单点登录这一个技术。用</p>
<p>户跳转到订单页面的时候，我们会用拦截器去进行判断用户是否已经登录。我们是用 cookie 中是</p>
<p>否有 token，如果没有 token 的话就跳转到登录页面，然后生成 token，至于 token 的生成呢，我们</p>
<p>是用本地的 IP，用户的 id，保存在 map 中，还有一个常量，这个我们通常会以项目名称来命名的。</p>
<p>至于为什么要 token 呢，其实是因为 cookie 是不太安全的，它很容易被伪造，所以我们就需要 token，然后有了 token 之后，我们用 JWT 这个盐值生成最后的 token。并把它保存到 cookie 当中。下一次支付的时候我们也还会用到这个 token，用一个加密算法再去运算验证一下就可以了！然后就是合并购物车了。这个的话我所知道的就是将客户端的 cookie 复印一份到缓存中进行修改然后送回客户端进行覆盖，再接着就是数据库的修改了。那这个如果登陆了的就直接从数据库中取得数据跳到订单系统了。然后订单模块里面，简单来说就是从购物车中勾选的商品迁移到订单里面。但是呢订单模块其实是会联系到另外两个模块的，就是库存和支付。如果你点击了提交订单，商品就会在购</p>
<p>物车里移除。然后我们提交订单避免他反复的提交同一个订单，就会通过交易码防止订单重复提交。</p>
<p>我们会吧 tradecode 放在缓存里面，以用户 id 为 key 商品的交易为 value 在 Redis 里面保存这个交</p>
<p>易码。到最后选好收货地址，留言之后，提交订单了，就会用自己的 tradecode 和在 Redis 里面通</p>
<p>过用户的 id 去获取 tradecode 进行对比，如果能跳转到支付页面，那么缓存中的交易码就会删除掉。</p>
<p>到最后就是支付功能，这一步的话我是不太清楚其中的技术点了，只知道这个模块调用了支付宝的</p>
<p>接口和用了消息队列，异步通知。</p>
<h2 id="高并发下的一些优化："><a href="#高并发下的一些优化：" class="headerlink" title="高并发下的一些优化："></a>高并发下的一些优化：</h2><p>数据层面的优化：</p>
<p> 从数据库层面做优化，比如:索引，缓存，集群，读写分离，主从复制，分表，分库。</p>
<p> 从数据库设计层面的优化：比如减少表关联，加入冗余字段</p>
<p> 从缓存方面优化：比如 redis 实现数据缓存，减轻数据库压力</p>
<p> 从搜索上进行优化：比如查找索引库项目层面的优化：</p>
<p> 采用面向服务的分布式架构：分担服务器压力 ，提高项目并发量。 比如 dubbox+zookeeper 分布式架构</p>
<p> 采用分布式文件系统实现海量文件存储：如采用 fastdfs 实现海量图片存储，提高文件的访问速度。</p>
<p> 采用 mq 使用服务进一步解藕：同步索引库，同步静态资源，短信发送</p>
<h3 id="服务器层面的优化："><a href="#服务器层面的优化：" class="headerlink" title="服务器层面的优化："></a>服务器层面的优化：</h3><p> 集群思想的使用：tomcat,zookeeper,redis,mysql 等</p>
<p> Tomcat 异步通信的使用，tomcat 连接池配置</p>
<p>高可用解决方案:</p>
<p>通常企业级应用系统（特别是政府部门和大企业的应用系统）一般会采用安规的软硬件设备，如 IOE</p>
<p>（IBM 的小型机、Oracle 数据、EMC 存储设备）系列。而一般互联网公司更多地采用 PC 级服务器</p>
<p>（x86），开源的数据库（MySQL）和操作系统（Linux）组建廉价且高容错（硬件故障是常态）的</p>
<p>应用集群。</p>
<p>目的：保证服务器硬件故障服务依然可用，数据依然保存并能够被访问。</p>
<p>主要的手段？</p>
<p>数据和服务的①冗余备份以及②失效转移：</p>
<p> 对于服务而言，一旦某个服务器宕机，就将服务切换到其他可用的服务器上；</p>
<p> 对于数据而言，如果某个磁盘损坏，就从备份的磁盘（事先就做好了数据的同步复制）读取数据。 高可用的服务</p>
<p>①分级管理：核心应用和服务具有更高的优先级，比如用户及时付款比能否评价商品更重要；</p>
<p>②超时设置：设置服务调用的超时时间，一旦超时，通信框架抛出异常，应用程序则根据服务</p>
<p>调度策略选择重试 or 请求转移到其他服务器上</p>
<p>③异步调用：通过消息队列等异步方式完成，避免一个服务失败导致整个应用请求失败的情况。</p>
<p>不是所有服务都可以异步调用，对于获取用户信息这类调用，采用异步方式会延长响应时间，得不</p>
<p>偿失。对于那些必须确认服务调用成功后才能继续进行下一步的操作的应用也不适合异步调用。 ④服务降级：网站访问高峰期间，为了保证核心应用的正常运行，需要对服务降级。</p>
<p>降级有两种手段：</p>
<p> 拒绝服务，拒绝较低优先级的应用的调用，减少服务调用并发数，确保核心应用的正常运行；</p>
<p> 关闭功能，关闭部分不重要的服务，或者服务内部关闭部分不重要的功能，以节约系统开销，为核心应</p>
<p>用服务让出资源；</p>
<p>⑤幂等性设计：保证服务重复调用和调用一次产生的结果相同；</p>
<p>高可用的数据</p>
<p>保证数据高可用的主要手段有两种：一是数据备份，二是失效转移机制；</p>
<p>①数据备份：又分为冷备份和热备份，冷备份是定期复制，不能保证数据可用性。热备份又分</p>
<p>为异步热备和同步热备，异步热备是指多份数据副本的写入操作异步完成，而同步方式则是指多份</p>
<p>数据副本的写入操作同时完成。关系数据库的热备机制就是通常所说的主从同步机制，实践中通常使用读写分离的方法来访问 Master 和 Slave 数据库，也就是说写操作只访问 Master 库，读操作均</p>
<p>访问 Slave 库。</p>
<p>②失效转移：若数据服务器集群中任何一台服务器宕机，那么应用程序针对这台服务器的所有</p>
<p>读写操作都</p>
<p>要重新路由到其他服务器，保证数据访问不会失败。网站运行监控</p>
<p>”不允许没有监控的系统上线“ （1）监控数据采集</p>
<p>①用户行为日志收集：服务器端的日志收集和客户端的日志收集；目前许多网站逐步开发基于实</p>
<p>时计算框架 Storm 的日志统计与分析工具；</p>
<p>②服务器性能监控：收集服务器性能指标，如系统 Load、内存占用、磁盘 IO 等，及时判断，防患</p>
<p>于未然；</p>
<p>③运行数据报告：采集并报告，汇总后统一显示，应用程序需要在代码中处理运行数据采集的逻</p>
<p>辑；</p>
<p>（2）监控管理</p>
<p>①系统报警：配置报警阀值和值守人员联系方式，系统发生报警时，即使工程师在千里之外，也</p>
<p>可以被及时通知；</p>
<p>②失效转移：监控系统在发现故障时，主动通知应用进行失效转移；</p>
<p>③自动优雅降级：为了应付网站访问高峰，主动关闭部分功能，释放部分系统资源，保证核心应</p>
<p>用服务的正常运行；—&gt;网站柔性架构的理想状态</p>
<p>其他手段： 主从切换：很好理解，当其中一台机器的服务宕机后，对于服务调用者来说，能够迅速的切换到其他可用服务，从服务升级为主服务，这种切换速度应当控制在秒级别（几秒钟）。当宕机的服务恢复之后，自动变为从服务，主从服务角色切换。主从切换一定是要付出代价的，所以当主服务恢复之后，也就不再替换现有的主服务。</p>
<p> 负载均衡：当服务的请求量比较高的时候，一台服务不能满足需求，这时候需要多台机器提供同样的服</p>
<p>务，将所有请求分发到不同机器上。高可用架构中应该具有丰富的负载均衡策略和易调节负载的方式。</p>
<p>甚至可以自动化智能调节，例如由于机器性能的原因，响应时间可能不一样，这时候可以向性能差的机器少一点分发量，保证各个机器响应时间的均衡。</p>
<p> 易横向扩展：当用户量越来越多，已有服务不能承载更多的用户的时候，便需要对服务进行扩展，扩展的方式最好是不触动原有服务，对于服务的调用者是透明的。 负载均衡:</p>
<h2 id="什么是负载均衡？"><a href="#什么是负载均衡？" class="headerlink" title="什么是负载均衡？"></a>什么是负载均衡？</h2><p>当一台服务器的性能达到极限时，我们可以使用服务器集群来提高网站的整体性能。那么，在服务</p>
<p>器集群中，需要有一台服务器充当调度者的角色，用户的所有请求都会首先由它接收，调度者再根</p>
<p>据每台服务器的负载情况将请求分配给某一台后端服务器去处理。 简单介绍 5 种负载均衡：</p>
<p>（1）HTTP 重定向负载均衡。</p>
<p>这种负载均衡方案的优点是比较简单；</p>
<p>缺点是浏览器需要每次请求两次服务器才能拿完成一次访问，性能较差。</p>
<p>（2）DNS 域名解析负载均衡</p>
<p>优点是将负载均衡工作交给 DNS，省略掉了网络管理的麻烦；</p>
<p>缺点就是 DNS 可能缓存 A 记录，不受网站控制。</p>
<p>（3）反向代理负载均衡。</p>
<p>优点是部署简单；</p>
<p>缺点是反向代理服务器是所有请求和响应的中转站，其性能可能会成为瓶颈。</p>
<p>（4）IP 负载均衡。</p>
<p>优点：IP 负载均衡在内核进程完成数据分发，较反向代理均衡有更好的处理性能。</p>
<p>缺点：负载均衡的网卡带宽成为系统的瓶颈。</p>
<p>（5）数据链路层负载均衡。</p>
<p>避免负载均衡服务器网卡带宽成为瓶颈，是目前大型网站所使用的最广的一种负载均衡手段。 详情介绍 5 种负载均衡：（1）HTTP 重定向负载均衡。</p>
<p>原理：当用户向服务器发起请求时，请求首先被集群调度者截获；调度者根据某种分配策略，选择</p>
<p>一台服务器，并将选中的服务器的 IP 地址封装在 HTTP 响应消息头部的 Location 字段中，并将响应</p>
<p>消息的状态码设为 302，最后将这个响应消息返回给浏览器。当浏览器收到响应消息后，解析</p>
<p>Location 字段，并向该 URL 发起请求，然后指定的服务器处理该用户的请求，最后将结果返回给用</p>
<p>户。</p>
<p>优点：比较简单</p>
<p>缺点：调度服务器只在客户端第一次向网站发起请求的时候起作用。当调度服务器向浏览器返回响</p>
<p>应信息后，客户端此后的操作都基于新的 URL 进行的(也就是后端服务器)，此后浏览器就不会与调</p>
<p>度服务器产生关系，浏览器需要每次请求两次服务器才能拿完成一次访问，性能较差。而且调度服</p>
<p>务器在调度时，无法知道当前用户将会对服务器造成多大的压力，只不过是把请求次数平均分配给</p>
<p>每台服务器罢了，浏览器会与后端服务器直接交互。</p>
<p>（2）DNS 域名解析负载均衡</p>
<p>原理：为了方便用户记忆，我们使用域名来访问网站。通过域名访问网站之前，首先需要将域名解</p>
<p>析成 IP 地址，这个工作是由 DNS 域名服务器完成的。我们提交的请求不会直接发送给想要访问的</p>
<p>网站，而是首先发给域名服务器，它会帮我们把域名解析成 IP 地址并返回给我们。我们收到 IP 之</p>
<p>后才会向该 IP 发起请求。一个域名指向多个 IP 地址，每次进行域名解析时，DNS 只要选一个 IP 返</p>
<p>回给用户，就能够实现服务器集群的负载均衡。</p>
<p>优点：配置简单，将负载均衡工作交给 DNS，省略掉了网络管理的麻烦；</p>
<p>缺点：集群调度权交给了 DNS 服务器，从而我们没办法随心所欲地控制调度者，没办法定制调度</p>
<p>策略，没办法了解每台服务器的负载情况，只不过把所有请求平均分配给后端服务器罢了。某一台</p>
<p>后端服务器发生故障时，即使我们立即将该服务器从域名解析中去除，但由于 DNS 服务器会有缓</p>
<p>存，该 IP 仍然会在 DNS 中保留一段时间，那么就会导致一部分用户无法正常访问网站。不过动态</p>
<p>DNS 能够让我们通过程序动态修改 DNS 服务器中的域名解析。从而当我们的监控程序发现某台服</p>
<p>务器挂了之后，能立即通知 DNS 将其删掉。</p>
<p>调度策略：一般 DNS 提供商会提供一些调度策略供我们选择，如随机分配、轮询、根据请求者的</p>
<p>地域分配离他最近的服务器。</p>
<p>随机分配策略：当调度服务器收到用户请求后，可以随机决定使用哪台后端服务器，然后将该服</p>
<p>务器的 IP 封装在 HTTP 响应消息</p>
<p>的 Location 属性中，返回给浏览器即可。</p>
<p>轮询策略(RR) ：调度服务器需要维护一个值，用于记录上次分配的后端服务器的 IP。那么当新的</p>
<p>请求到来时，调度者将请求依</p>
<p>次分配给下一台服务器。</p>
<p>（3）反向代理负载均衡。</p>
<p>原理：反向代理服务器是一个位于实际服务器之前的服务器，所有向我们网站发来的请求都首先要</p>
<p>经过反向代理服务器，服务器根据用户的请求要么直接将结果返回给用户，要么将请求交给后端服</p>
<p>务器处理，再返回给用户。反向代理服务器就可以充当服务器集群的调度者，它可以根据当前后端</p>
<p>服务器的负载情况，将请求转发给一台合适的服务器，并将处理结果返回给用户。</p>
<p>优点：</p>
<p> 部署简单</p>
<p> 隐藏后端服务器：与 HTTP 重定向相比，反向代理能够隐藏后端服务器，所有浏览器都不会与后端服务器</p>
<p>直接交互，从而能够确保调度者的控制权，提升集群的整体性能。 故障转移 ：与 DNS 负载均衡相比，反向代理能够更快速地移除故障结点。当监控程序发现某一后端服</p>
<p>务器出现故障时，能够及时通知反向代理服务器，并立即将其删除。</p>
<p> 合理分配任务 ：HTTP 重定向和 DNS 负载均衡都无法实现真正意义上的负载均衡，也就是调度服务器无</p>
<p>法根据后端服务器的实际负载情况分配任务。但反向代理服务器支持手动设定每台后端服务器的权重。</p>
<p>我们可以根据服务器的配置设置不同的权重，权重的不同会导致被调度者选中的概率的不同。 缺点：</p>
<p> 调度者压力过大 ：由于所有的请求都先由反向代理服务器处理，那么当请求量超过调度服务器的最大负</p>
<p>载时，调度服务器的吞吐率降低会直接降低集群的整体性能。</p>
<p> 制约扩展 ：当后端服务器也无法满足巨大的吞吐量时，就需要增加后端服务器的数量，可没办法无限量</p>
<p>地增加，因为会受到调度服务器的最大吞吐量的制约。</p>
<p> 粘滞会话：反向代理服务器会引起一个问题。若某台后端服务器处理了用户的请求，并保存了该用户的</p>
<p>session 或存储了缓存，那么当该用户再次发送请求时，无法保证该请求仍然由保存了其 Session 或缓存</p>
<p>的服务器处理，若由其他服务器处理，先前的 Session 或缓存就找不到了。 解决办法：</p>
<p> 可以修改反向代理服务器的任务分配策略，以用户 IP 作为标识较为合适。相同的用户 IP 会交由同一台后端服务器处理，从而就避免了粘滞会话的问题。</p>
<p> 可以在 Cookie 中标注请求的服务器 ID，当再次提交请求时，调度者将该请求分配给 Cookie 中标注的服务器处理即可。 （4）IP 负载均衡。 通过 NAT 实现负载均衡：响应报文一般比较大，每一次都需要 NAT 转换的话，大流量的时候，会导致调度器成为一个瓶颈。</p>
<p> 通过直接路由实现负载均衡</p>
<p> VS/TUN 实现虚拟服务器</p>
<p>优点：IP 负载均衡在内核进程完成数据分发，较反向代理均衡有更好的处理性能。</p>
<p>缺点：负载均衡的网卡带宽成为系统的瓶颈，场景：某个服务器跑的应用非高峰期间都能达到</p>
<p>500M 以上，晚高峰一般能够超过 1G，主流服务器的网卡都是千兆的，超过 1G 的流量明显会导致丢包的问题，此时又不能停止业务对网卡进行更换。</p>
<p>（5）数据链路层负载均衡。</p>
<p>对于 linux 系统来说，数据链路层的解决方案就是实现多个网卡绑定联合提供服务，把多张网卡捆</p>
<p>绑做成一个逻辑网卡。避免负载均衡服务器网卡带宽成为瓶颈，是目前大型网站所使用的最广的一</p>
<p>种负载均衡手段。linux bonding 的七种模式，mod=0~6：平衡抡循环策略，主-备份策略，平衡策略，广播策略，动态链接聚合，适配器传输负载均衡，适配器适应性负载均衡</p>
<h2 id="分布式，集群，微服务，SOA微服务和-SOA-有什么区别？"><a href="#分布式，集群，微服务，SOA微服务和-SOA-有什么区别？" class="headerlink" title="分布式，集群，微服务，SOA微服务和 SOA 有什么区别？"></a>分布式，集群，微服务，SOA微服务和 SOA 有什么区别？</h2><p> 微服务剔除 SOA 中复杂的 ESB 企业服务总线，所有的业务智能逻辑在服务内部处理，使用 Http（Rest API）</p>
<p>进行轻量化通讯</p>
<p> SOA 强调按水平架构划分为：前、后端、数据库、测试等，微服务强调按垂直架构划分，按业务能力划</p>
<p>分，每个服务完成一种特定的功能，服务即产品</p>
<p> SOA 将组件以 library 的方式和应用部署在同一个进程中运行，微服务则是各个服务独立运行。</p>
<p> 传统应用倾向于使用统一的技术平台来解决所有问题，微服务可以针对不同业务特征选择不同技术平台，</p>
<p>去中心统一化，发挥各种技术平台的特长。</p>
<p> SOA 架构强调的是异构系统之间的通信和解耦合；（一种粗粒度、松耦合的服务架构）</p>
<p> 微服务架构强调的是系统按业务边界做细粒度的拆分和部署</p>
<p>分布式架构：</p>
<p>把系统按照模块拆分成多个子系统，多个子系统分布在不同的网络计算机上相互协作完成业务流</p>
<p>程，系统之间需要进行通信。</p>
<p>优点：</p>
<p>\1. 把模块拆分，使用接口通信，降低模块之间的耦合度。</p>
<p>\2. 把项目拆分成若干个子项目，不同的团队负责不同的子项目。</p>
<p>\3. 增加功能时只需要再增加一个子项目，调用其他系统的接口就可以。</p>
<p>\4. 可以灵活的进行分布式部署。 缺点：</p>
<p>\1. 系统之间交互需要使用远程通信，接口开发增加工作量。</p>
<p>\2. 各个模块有一些通用的业务逻辑无法共用。 基于 soa 的架构</p>
<p>SOA：面向服务的架构。可以把工程拆分成服务层、表现层两个工程。服务层中包含业务逻辑，只</p>
<p>需要对外提供服务即可。表现层只需要处理和页面的交互，业务逻辑都是调用服务层的服务来实现。</p>
<h2 id="分布式架构和-soa-架构有什么区别？"><a href="#分布式架构和-soa-架构有什么区别？" class="headerlink" title="分布式架构和 soa 架构有什么区别？"></a>分布式架构和 soa 架构有什么区别？</h2><p>SOA，主要还是从服务的角度，可以将工程拆分成服务层、表现层两个工程。</p>
<p>分布式，主要还是从部署的角度，将应用按照访问压力进行归类，主要目标是充分利用服务器的资</p>
<p>源，避免资源分配不均</p>
<p>集群: 一个集群系统是一群松散结合的服务器组，形成一个虚拟的服务器，为客户端用户提供统一的服</p>
<p>务。对于这个客户端来说，通常在访问集群系统时不会意识到它的服务是由具体的哪一台服务器提供。集群的目的，是为实现负载均衡、容错和灾难恢复。以达到系统可用性和可伸缩性的要求。</p>
<p>集群系统一般应具高可用性、可伸缩性、负载均衡、故障恢复和可维护性等特殊性能。一般同一</p>
<p>个工程会部署到多台服务器上。</p>
<p>常见的 tomcat 集群，Redis 集群，Zookeeper 集群，数据库集群</p>
<h2 id="分布式与集群的区别："><a href="#分布式与集群的区别：" class="headerlink" title="分布式与集群的区别："></a>分布式与集群的区别：</h2><p>分布式是指将不同的业务分布在不同的地方。 而集群指的是将几台服务器集中在一起，实现同一</p>
<p>业务。一句话：分布式是并联工作的，集群是串联工作的。</p>
<p>分布式中的每一个节点，都可以做集群。 而集群并不一定就是分布式的。</p>
<p>举例：就比如新浪网，访问的人多了，他可以做一个群集，前面放一个响应服务器，后面几台服务</p>
<p>器完成同一业务，如果有业务访问的时候，响应服务器看哪台服务器的负载不是很重，就将给哪一</p>
<p>台去完成。而分布式，从窄意上理解，也跟集群差不多，但是它的组织比较松散，不像集群，有一</p>
<p>个组织性，一台服务器垮了，其它的服务器可以顶上来。分布式的每一个节点，都完成不同的业务，</p>
<p>一个节点垮了，哪这个业务就不可访问了。</p>
<p>分布式是以缩短单个任务的执行时间来提升效率的，而集群则是通过提高单位时间内执行的任务</p>
<p>数来提升效率。</p>
<p>举例：如果一个任务由 10 个子任务组成，每个子任务单独执行需 1 小时，则在一台服务器上执行</p>
<p>该任务需 10 小时。采用分布式方案，提供 10 台服务器，每台服务器只负责处理一个子任务，不</p>
<p>考虑子任务间的依赖关系，执行完这个任务只需一个小时。(这种工作模式的一个典型代表就是</p>
<p>Hadoop 的 Map/Reduce 分布式计算模型）而采用集群方案，同样提供 10 台服务器，每台服务器都</p>
<p>能独立处理这个任务。假设有 10 个任务同时到达，10 个服务器将同时工作，1 小时后，10 个任务</p>
<p>同时完成，这样，整身来看，还是 1 小时内完成一个任务！</p>
<h2 id="讲讲分布式事务的异步通信问题解决方案"><a href="#讲讲分布式事务的异步通信问题解决方案" class="headerlink" title="讲讲分布式事务的异步通信问题解决方案"></a>讲讲分布式事务的异步通信问题解决方案</h2><p>问题介绍：一个消息发送过去了，不管结果如何发送端都不会原地等待接收端。直到接收端再推送</p>
<p>回来回执消息，发送端才直到结果。但是也有可能发送端消息发送后，石沉大海，杳无音信。这时候就需要一种机制能够对这种不确定性进行补充。</p>
<p>解决方案：</p>
<p>你给有很多笔友，平时写信一去一回，但是有时候会遇到迟迟没有回信的情况。那么针对这种偶尔</p>
<p>出现的情况，你可以选择两种策略。一种方案是你发信的时候用定个闹钟，设定 1 天以后去问一下对方收没收到信。</p>
<p>另一种方案就是每天夜里定个时间查看一下所有发过信但是已经一天没收到回复的信。然后挨个打个电话问一下。</p>
<p>第一种策略就是实现起来就是延迟队列，第二种策略就是定时轮询扫描。</p>
<p>二者的区别是延迟队列更加精准，但是如果周期太长，任务留在延迟队列中时间的就会非常长，</p>
<p>会把队列变得冗长。比如用户几天后待办提醒，生日提醒。那么如果遇到这种长周期的事件，而且并不需要精确到分秒级的事件，可以利用定时扫描来实现，尤其是比较消耗性能的大范围扫描，</p>
<p>可以安排到夜间执行。 分布式事务</p>
<p>一、两阶段提交（2PC）</p>
<p>两阶段提交这种解决方案属于牺牲了一部分可用性来换取的一致性。在实现方面，在 .NET 中，可</p>
<p>以借助 TransactionScop 提供的 API 来编程实现分布式系统中的两阶段提交，比如 WCF 中就有实</p>
<p>现这部分功能。不过在多服务器之间，需要依赖于 DTC 来完成事务一致性</p>
<p>优点： 尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能 100%保</p>
<p>证强一致）</p>
<p>缺点： 实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景，如果分布式系统</p>
<p>跨接口调用，目前 .NET 界还没有实现方案</p>
<p>二、补偿事务（TCC）</p>
<p>TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和</p>
<p>补偿（撤销）操作。它分为三个阶段：</p>
<p> Try 阶段主要是对业务系统做检测及资源预留</p>
<p> Confirm 阶段主要是对业务系统做确认提交，Try 阶段执行成功并开始执行 Confirm 阶段时，默认 Confirm</p>
<p>阶段是不会出错的。即：只要 Try 成功，Confirm 一定成功。</p>
<p> Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。 优点： 跟 2PC 比起来，实现以及流程相对简单了一些，但数据的一致性比 2PC 也要差一些</p>
<p>缺点：缺点还是比较明显的，在 2,3 步中都有可能失败。TCC 属于应用层的一种补偿方式，所以需</p>
<p>要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用 TCC 不太好定</p>
<p>义及处理</p>
<p>三、本地消息表（异步确保）（使用最多的技术方案）</p>
<p> 消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，</p>
<p>也就是说他们要在一个数据库里面。然后消息会经过 MQ 发送到消息的消费方。如果消息发送失败，会</p>
<p>进行重试发送。</p>
<p> 消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理</p>
<p>成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿</p>
<p>消息，通知生产方进行回滚等操作。 生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。</p>
<p>四、MQ 事务消息</p>
<p>有一些第三方的 MQ 是支持事务消息的，比如 RocketMQ，他们支持事务消息的方式也是类似于采</p>
<p>用的二阶段提交，但是市面上一些主流的 MQ 都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都</p>
<p>不支持。以阿里的 RocketMQ 中间件为例，其思路大致为：</p>
<p> 第一阶段 Prepared 消息，会拿到消息的地址。</p>
<p> 第二阶段执行本地事务</p>
<p> 第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。 也就是说在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息</p>
<p>发送失败了 RocketMQ 会定期扫描消息集群中的事务消息，这时候发现了 Prepared 消息，它会向</p>
<p>消息发送者确认，所以生产方需要实现一个 check 接口，RocketMQ 会根据发送端设置的策略来决</p>
<p>定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。 分布式架构 session 共享问题，如何在集群里边实现共享，分布式 session 跨域问题</p>
<p>用了 CAS，所有应用项目中如果需要登录时在 web.xml 中配置过滤器做请求转发到 cas 端工作原理</p>
<p>是在 cas 登录后会给浏览器发送一个票据（ticket），浏览器 cookie 中会缓存这个 ticket，在登录其</p>
<p>他项目时会拿着浏览器的 ticket 转发到 cas，到 cas 后根据票据判断是否登录。单点登录是相互信</p>
<p>任的系统模块登录一个模块后，其他模块不需要重复登录即认证通过。采用 CAS 单点登录框架，</p>
<p>首先 CAS 有两大部分：客户端和服务端。服务端就是一个 web 工程部署在 tomcat 中。在服务端完</p>
<p>成用户认证操作。每次访问系统模块时，需要去 CAS 完成获取 ticket。当验证通过后，访问继续操</p>
<p>作。对于 CAS 服务端来说，我们访问的应用模块就是 CAS 客户端。</p>
<h2 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h2><p>当异步请求时，访问的请求地址的协议、ip 地址、端口号任意一个与当前站点不同时，就会涉及跨</p>
<p>域访问。</p>
<h2 id="什么时候涉及跨域问题？"><a href="#什么时候涉及跨域问题？" class="headerlink" title="什么时候涉及跨域问题？"></a>什么时候涉及跨域问题？</h2><p>当涉及前端异步请求的时候才涉及跨域。</p>
<p>解决方案：</p>
<p> jQuery 提供了 jsonp 实现</p>
<p> W3C 标准提供了 CORS（跨域资源共享）解决方案。 用了 CAS，所有应用项目中如果需要登录时在 web.xml 中配置过滤器做请求转发到 cas 端工作原理</p>
<p>是在 cas 登录后会给浏览器发送一个票据（ticket），浏览器 cookie 中会缓存这个 ticket，在登录其</p>
<p>他项目时会拿着浏览器的 ticket 转发到 cas，到 cas 后根据票据判断是否登录。</p>
<p>Redis 缓存</p>
<h2 id="什么是-Redis"><a href="#什么是-Redis" class="headerlink" title="什么是 Redis?"></a>什么是 Redis?</h2><p>redis 是内存中的数据结构存储系统，一个 key-value 类型的非关系型数据库，可持久化的数据库，</p>
<p>相对于关系型数据库（数据主要存在硬盘中），性能高，因此我们一般用 redis 来做缓存使用；并且 redis 支持丰富的数据类型，比较容易解决各种问题，因此 redis 可以用来作为注册中心， 数据</p>
<p>库、缓存和消息中间件。Redis 的 Value 支持 5 种数据类型，string、hash、list、set、zset（sorted set）;  String 类型：一个 key 对应一个 value</p>
<p> Hash 类型：它的 key 是 string 类型，value 又是一个 map（key-value），适合存储对象。</p>
<p> List 类型：按照插入顺序的字符串链表（双向链表），主要命令是 LPUSH 和 RPUSH，能够支持反向查找</p>
<p>和遍历</p>
<p> Set 类型：用哈希表类型的字符串序列，没有顺序，集合成员是唯一的，没有重复数据，底层主要是由一</p>
<p>个 value 永远为 null 的 hashmap 来实现的。</p>
<p> zset 类型：和 set 类型基本一致，不过它会给每个元素关联一个 double 类型的分数（score），这样就可</p>
<p>以为成员排序，并且插入是有序的。 你还用过其他的缓存吗？这些缓存有什么区别？都在什么场景下去用？</p>
<p>对于缓存了解过 redis 和 memcache</p>
<p>Memcache 和 redis 的区别：</p>
<p> 数据支持的类型：redis 不仅仅支持简单的 k/v 类型的数据，同时还支持 list、set、zset、hash 等数据结构</p>
<p>的存储；memcache 只支持简单的 k/v 类型的数据，key 和 value 都是 string 类型</p>
<p> 可靠性：memcache 不支持数据持久化，断电或重启后数据消失，但其稳定性是有保证的；redis 支持数</p>
<p>据持久化和数据恢复，允许单点故障，但是同时也会付出性能的代价</p>
<p> 性能上：对于存储大数据，memcache 的性能要高于 redis</p>
<p>应用场景：</p>
<p> Memcache：适合多读少写，大数据量的情况（一些官网的文章信息等）</p>
<p> Redis：适用于对读写效率要求高、数据处理业务复杂、安全性要求较高的系统</p>
<p>案例：分布式系统，存在 session 之间的共享问题，因此在做单点登录的时候，我们利用 redis 来模</p>
<p>拟了 session 的共享，来存储用户的信息，实现不同系统的 session 共享；</p>
<p>对 redis 的持久化了解不？</p>
<p>redis 的持久化方式有两种：</p>
<p>RDB（半持久化方式）：按照配置不定期的通过异步的方式、快照的形式直接把内存中的数据持久</p>
<p>化到磁盘的一个 dump.rdb 文件（二进制的临时文件）中，redis 默认的持久化方式，它在配置文件</p>
<p>（redis.conf）中。</p>
<p> 优点：只包含一个文件，将一个单独的文件转移到其他存储媒介上，对于文件备份、灾难恢复而言，比</p>
<p>较实用。</p>
<p> 缺点：系统一旦在持久化策略之前出现宕机现象，此前没有来得及持久化的数据将会产生丢失</p>
<p>RDB 持久化配置：Redis 会将数据集的快照 dump 到 dump.rdb 文件中。此外，我们也可以通过配置文件来修改 Redis</p>
<p>服务器 dump 快照的频率，在打开 6379.conf 文件之后，我们搜索 save，可以看到下面的配置信息：</p>
<p> save 900 1 #在 900 秒(15 分钟)之后，如果至少有 1 个 key 发生变化，则 dump 内存快照。</p>
<p> save 300 10 #在 300 秒(5 分钟)之后，如果至少有 10 个 key 发生变化，则 dump 内存快照。</p>
<p> save 60 10000 #在 60 秒(1 分钟)之后，如果至少有 10000 个 key 发生变化，则 dump 内存快照。</p>
<p>AOF（全持久化的方式）：把每一次数据变化都通过 write()函数将你所执行的命令追加到一个</p>
<p>appendonly.aof 文件里面，Redis 默认是不支持这种全持久化方式的，需要在配置文件（redis.conf）</p>
<p>中将 appendonly no 改成 appendonly yes</p>
<p> 优点：数据安全性高，对日志文件的写入操作采用的是 append 模式，因此在写入过程中即使出现宕机问</p>
<p>题，也不会破坏日志文件中已经存在的内容；</p>
<p> 缺点：对于数量相同的数据集来说，aof 文件通常要比 rdb 文件大，因此 rdb 在恢复大数据集时的速度大</p>
<p>于 AOF；</p>
<p>AOF 持久化配置:</p>
<p>在 Redis 的配置文件中存在三种同步方式，它们分别是：</p>
<p> appendfsync always #每次有数据修改发生时都会都调用 fsync 刷新到 aof 文件，非常慢，但是安全；</p>
<p> appendfsync everysec #每秒钟都调用 fsync 刷新到 aof 文件中，很快，但是可能丢失一秒内的数据，推荐</p>
<p>使用，兼顾了速度和安全；</p>
<p> appendfsync no #不会自动同步到磁盘上，需要依靠 OS（操作系统）进行刷新，效率快，但是安全</p>
<p>性就比较差；</p>
<p>二种持久化方式区别：</p>
<p> AOF 在运行效率上往往慢于 RDB，每秒同步策略的效率是比较高的，同步禁用策略的效率和 RDB 一样高</p>
<p>效；</p>
<p> 如果缓存数据安全性要求比较高的话，用 aof 这种持久化方式（比如项目中的购物车）；</p>
<p> 如果对于大数据集要求效率高的话，就可以使用默认的。而且这两种持久化方式可以同时使用。 做过 redis 的集群吗？你们做集群的时候搭建了几台，都是怎么搭建的？</p>
<p> Redis 的数据是存放在内存中的，不适合存储大数据，大数据存储一般公司常用 hadoop 中的 Hbase 或者MogoDB。redis 主要用来处理高并发的，用我们的项目来说，电商项目如果并发大的话，一台单独的 redis是不能足够支持我们的并发，这就需要我们扩展多台设备协同合作，即用到集群。</p>
<p> Redis 搭建集群的方式有多种，例如：客户端分片、Twemproxy、Codis 等，但是 redis3.0 之后就支持redis-cluster 集群，这种方式采用的是无中心结构，每个节点保存数据和整个集群的状态，每个节点都和其他所有节点连接。如果使用的话就用 redis-cluster 集群。集群这块是公司运维搭建的，具体怎么搭建不是太了解。</p>
<p> 我们项目中 redis 集群主要搭建了 6 台，3 主（为了保证 redis 的投票机制）3 从（高可用），每个主服务器都有一个从服务器，作为备份机。所有的节点都通过 PING-PONG 机制彼此互相连接；客户端与 redis集群连接，只需要连接集群中的任何一个节点即可；Redis-cluster 中内置了 16384 个哈希槽Redis-cluster把所有的物理节点映射到【0-16383】slot 上，负责维护。</p>
<h2 id="Redis-有事务吗？"><a href="#Redis-有事务吗？" class="headerlink" title="Redis 有事务吗？"></a>Redis 有事务吗？</h2><p>Redis 是有事务的，redis 中的事务是一组命令的集合，这组命令要么都执行，要不都不执行，保证</p>
<p>一个事务中的命令依次执行而不被其他命令插入。redis 的事务是不支持回滚操作的。redis 事务的</p>
<p>实现，需要用到 MULTI（事务的开始）和 EXEC（事务的结束）命令 ;</p>
<p>缓存穿透缓存查询一般都是通过 key 去查找 value，如果不存在对应的 value，就要去数据库中查找。如果这个 key 对应的 value 在数据库中也不存在，并且对该 key 并发请求很大，就会对数据库产生很大的压力，这就叫缓存穿透。</p>
<p>解决方案：</p>
<p> 对所有可能查询的参数以 hash 形式存储，在控制层先进行校验，不符合则丢弃。</p>
<p> 将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，</p>
<p>从而避免了对底层存储系统的查询压力。</p>
<p> 如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，</p>
<p>但它的过期时间会很短，最长不超过五分钟。 缓存雪崩</p>
<p>当缓存服务器重启或者大量缓存集中在一段时间内失效，发生大量的缓存穿透，这样在失效的瞬间</p>
<p>对数据库的访问压力就比较大，所有的查询都落在数据库上，造成了缓存雪崩。 这个没有完美解</p>
<p>决办法，但可以分析用户行为，尽量让失效时间点均匀分布。大多数系统设计者考虑用加锁或者队</p>
<p>列的方式保证缓存的单线程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。</p>
<p>解决方案：</p>
<p> 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。</p>
<p> 可以通过缓存 reload 机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存</p>
<p> 不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀</p>
<p> 做二级缓存，或者双缓存策略。A1 为原始缓存，A2 为拷贝缓存，A1 失效时，可以访问 A2，A1 缓存失</p>
<p>效时间设置为短期，A2 设置为长期。</p>
<h2 id="redis-的安全机制（你们公司-redis-的安全这方面怎么考虑的？）"><a href="#redis-的安全机制（你们公司-redis-的安全这方面怎么考虑的？）" class="headerlink" title="redis 的安全机制（你们公司 redis 的安全这方面怎么考虑的？）"></a>redis 的安全机制（你们公司 redis 的安全这方面怎么考虑的？）</h2><p>漏洞介绍：redis 默认情况下，会绑定在 bind 0.0.0.0:6379，这样就会将 redis 的服务暴露到公网上，</p>
<p>如果在没有开启认证的情况下，可以导致任意用户在访问目标服务器的情况下，未授权就可访问</p>
<p>redis 以及读取 redis 的数据，攻击者就可以在未授权访问 redis 的情况下可以利用 redis 的相关方法，</p>
<p>成功在 redis 服务器上写入公钥，进而可以直接使用私钥进行直接登录目标主机；</p>
<p>解决方案：</p>
<p>\1. 禁止一些高危命令。修改 redis.conf 文件，用来禁止远程修改 DB 文件地址，比如 rename-command</p>
<p>FLUSHALL “” 、rename-command CONFIG”” 、rename-command EVAL “”等；</p>
<p>\2. 以低权限运行 redis 服务。为 redis 服务创建单独的用户和根目录，并且配置禁止登录；3. 为 redis 添加密码验证。修改 redis.conf 文件，添加 requirepass mypassword；</p>
<p>\4. 禁止外网访问 redis。修改 redis.conf 文件，添加或修改 bind 127.0.0.1，使得 redis 服务只在当前主机使用；</p>
<p>\5. 做 log 监控，及时发现攻击；</p>
<p>redis 的哨兵机制（redis2.6 以后出现的）：</p>
<p> 监控：监控主数据库和从数据库是否正常运行；</p>
<p> 提醒：当被监控的某个 redis 出现问题的时候，哨兵可以通过 API 向管理员或者其他应用程序发送通知；</p>
<p> 自动故障迁移：主数据库出现故障时，可以自动将从数据库转化为主数据库，实现自动切换；</p>
<p>具体的配置步骤参考的网上的文档。要注意的是，如果 master 主服务器设置了密码，记得在哨兵</p>
<p>的配置文件（sentinel.conf）里面配置访问密码</p>
<h2 id="redis-中对于生存时间的应用"><a href="#redis-中对于生存时间的应用" class="headerlink" title="redis 中对于生存时间的应用"></a>redis 中对于生存时间的应用</h2><p>Redis 中可以使用 expire 命令设置一个键的生存时间，到时间后 redis 会自动删除；</p>
<p>应用场景：</p>
<p>\1. 设置限制的优惠活动的信息；</p>
<p>\2. 一些及时需要更新的数据，积分排行榜；</p>
<p>\3. 手机验证码的时间；</p>
<p>\4. 限制网站访客访问频率；</p>
<h2 id="能讲下-redis-的具体使用场景吗？"><a href="#能讲下-redis-的具体使用场景吗？" class="headerlink" title="能讲下 redis 的具体使用场景吗？"></a>能讲下 redis 的具体使用场景吗？</h2><p>使用 redis 存储长期不改变的数据完全可以使用也看静态化，那么你们当时是为什么会使用 redis？</p>
<p>redis 在项目中应用：</p>
<p> 主要应用在门户网站首页广告信息的缓存。因为门户网站访问量较大，将广告缓存到 redis 中，可以降低数据库访问压力，提高查询性能。</p>
<p> 应用在用户注册验证码缓存。利用 redis 设置过期时间，当超过指定时间后，redis 清理验证码，使过期的验证码无效。</p>
<p> 用在购物车模块，用户登陆系统后，添加的购物车数据需要保存到 redis 缓存中。 使用 redis 主要是减少系统数据库访问压力。从缓存中查询数据，也提高了查询性能，挺高用户体</p>
<p>验度。</p>
<h2 id="Redis-分布式锁理解"><a href="#Redis-分布式锁理解" class="headerlink" title="Redis 分布式锁理解"></a>Redis 分布式锁理解</h2><p>获取锁的时候，使用 setnx 加锁，并使用 expire 命令为锁添加一个超时时间，超过该时间则自动释</p>
<p>放锁，锁的 value 值为一个随机生成的 UUID，通过此在释放锁的时候进行判断。</p>
<p> 获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</p>
<p> 释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。 SETEX:如果 key 已经存在， SETEX 命令将覆写旧值。</p>
<p> SETNX:若给定的 key 已经存在，则 SETNX 不做任何动作。</p>
<p>Redis 怎么设置过期的？</p>
<p>设置过期：this.redisTemplate.expire(“max”,tempTime,TimeUnit.SECONDS);</p>
<p>讲到 redis 缓存的时候说不清楚</p>
<h2 id="redis-中项目中的使用场景："><a href="#redis-中项目中的使用场景：" class="headerlink" title="redis 中项目中的使用场景："></a>redis 中项目中的使用场景：</h2><p> 主要应用在门户网站首页广告信息的缓存。因为门户网站访问量较大，将广告缓存到 redis 中，可以降低数据库访问压力，提高查询性能。</p>
<p> 应用在用户注册验证码缓存。利用 redis 设置过期时间，当超过指定时间后，redis 清理验证码，使过期的验证码无效。</p>
<p> 用在购物车模块，用户登陆系统后，添加的购物车数据需要保存到 redis 缓存中。 技术角度分析：</p>
<p> Redis 如何实现负载的？采用 Hash 槽来运算存储值，使用 CRC16 算法取模运算，来保证负载问题。</p>
<p> Redis 缓存穿透问题？将数据查询出来如果没有强制设置空值，并且设置过期时间，减少频繁查询数据库。</p>
<p> 使用 redis 主要是减少系统数据库访问压力。从缓存中查询数据，也提高了查询性能，挺高用户体验度。</p>
<h2 id="Redis-中对一个-key-进行自增或者自减操作，它是原子性的吗？"><a href="#Redis-中对一个-key-进行自增或者自减操作，它是原子性的吗？" class="headerlink" title="Redis 中对一个 key 进行自增或者自减操作，它是原子性的吗？"></a>Redis 中对一个 key 进行自增或者自减操作，它是原子性的吗？</h2><p>是原子性的。对于 Redis 而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要</p>
<p>么不执行。Redis 的操作之所以是原子性的，是因为 Redis 是单线程的。对 Redis 来说，执行 get、</p>
<p>set 以及 eval 等 API，都是一个一个的任务，这些任务都会由 Redis 的线程去负责执行，任务要么执</p>
<p>行成功，要么执行失败，这就是 Redis 的命令是原子性的原因。Redis 本身提供的所有 API 都是原</p>
<p>子操作，Redis 中的事务其实是要保证批量操作的原子性。 项目添加 Redis 缓存后，持久化具体怎么实现的。</p>
<p> RDB：保存存储文件到磁盘；同步时间为 15 分钟，5 分钟，1 分钟一次，可能存在数据丢失问题。</p>
<p> AOF：保存命令文件到磁盘；安全性高，修改后立即同步或每秒同步一次。 上述两种方式在我们的项目中都有使用到，在广告轮播的功能中使用了 redis 缓存，先从 redis 中获</p>
<p>取数据，无数据后从数据库中查询后保存到 redis 中。采用默认的 RDB 方式。 怎么提高 redis 缓存利用率？</p>
<p> 从业务场景分析，预计会高频率用到的数据预先存放到 redis 中，</p>
<p> 可以定时扫描命中率低的数据，可以直接从 redis 中清除。</p>
<h2 id="Redis-宕机之后，购物车中的数据如何处理？如何缓解-mysql-压力？"><a href="#Redis-宕机之后，购物车中的数据如何处理？如何缓解-mysql-压力？" class="headerlink" title="Redis 宕机之后，购物车中的数据如何处理？如何缓解 mysql 压力？"></a>Redis 宕机之后，购物车中的数据如何处理？如何缓解 mysql 压力？</h2><p>用 redis 保存的*.rdb 文件恢复即可。另外 redis 还有 AOF 功能，启动时可以自动恢复到前一条查询。</p>
<p>这样做在一定程度上减少数据丢失。但重启 redis 会需要从关系型数据库中读取数据，增大 mysql</p>
<p>的压力。依据实际情况，如果 redis 之前有主从复制，则可在其他节点 redis 上拿到数据。如果公司</p>
<p>没钱，则只能暂时限制客户端访问量，优先恢复 redis 数据。</p>
<h2 id="Redis-和-mysql-数据同步，是先删除-redis-的数据还是先删除-Mysql-的数据？"><a href="#Redis-和-mysql-数据同步，是先删除-redis-的数据还是先删除-Mysql-的数据？" class="headerlink" title="Redis 和 mysql 数据同步，是先删除 redis 的数据还是先删除 Mysql 的数据？"></a>Redis 和 mysql 数据同步，是先删除 redis 的数据还是先删除 Mysql 的数据？</h2><p>不管是先写库，再删除缓存；还是先删缓存，再写库，都有可能出现数据不一致的情况。因为写和</p>
<p>读是并发的，没法保证顺序，如果删了缓存，还没有来得及写库，另一个线程就来读取，发现缓存</p>
<p>为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。如果先写了库，再删除缓存前，写</p>
<p>库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。 如果是 redis 集群，或者主从模</p>
<p>式，写主读从，由于 redis 复制存在一定的时间延迟，也有可能导致数据不一致。这时候，考虑先</p>
<p>删除数据库内容，再删 redis。因为在库存等实时数据都是直接在数据库中读取，从业务逻辑上来</p>
<p>说，我们允许查询时的数据缓存误差，但是不允许结算时的数据存在误差。</p>
<h2 id="Redis-中-watch-机制和原理"><a href="#Redis-中-watch-机制和原理" class="headerlink" title="Redis 中 watch 机制和原理"></a>Redis 中 watch 机制和原理</h2><p>我们常用 redis 的 watch 和 multi 来处理一些涉及并发的操作，redis 的 watch+multi 实际是一种乐观锁。watch 命令描述：WATCH 命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行。监控一直持续到 EXEC 命令（事务中的命令是在 EXEC 之后才执行的，所以在 MULTI 命令后可以修改 WATCH 监控的键值）讲讲缓存的设计和优化，缓存和数据库一致性同步解决方案</p>
<p> 降低后端负载：对于高消耗的 SQL：join 结果集、分组统计结果；对这些结果进行缓存。</p>
<p> 加速请求响应</p>
<p> 大量写合并为批量写：如计数器先 redis 累加再批量写入 DB</p>
<p> 超时剔除：例如 expire</p>
<p> 主动更新：开发控制生命周期（最终一致性，时间间隔比较短）</p>
<p> 缓存空对象</p>
<p> 布隆过滤器拦截</p>
<p> 命令本身的效率：例如 sql 优化，命令优化</p>
<p> 网络次数：减少通信次数</p>
<p> 降低接入成本:长连/连接池,NIO 等。</p>
<p> IO 访问合并</p>
<p>目的：要减少缓存重建次数、数据尽可能一致、减少潜在危险。</p>
<p>解决方案：</p>
<p>互斥锁 setex,setnx：</p>
<p> 如果 set(nx 和 ex) 结果为 true，说明此时没有其他线程重建缓存，那么当前线程执行缓存构建逻辑。</p>
<p> 如果 setnx(nx 和 ex) 结果为 false，说明此时已经有其他线程正在执行构建缓存的工作，那么当前线程</p>
<p>将休息指定时间 ( 例如这里是 50 毫秒，取决于构建缓存的速度 ) 后，重新执行函数，直到获取到数据。永远不过期：</p>
<p>热点 key，无非是并发特别，重建缓存时间比较长，如果直接设置过期时间，那么时间到的时候，</p>
<p>巨大的访问量会压迫到数据库上，所以要给热点 key 的 val 增加一个逻辑过期时间字段，并发访问</p>
<p>的时候，判断这个逻辑字段的时间值是否大于当前时间，大于了说明要对缓存进行更新了，那么这</p>
<p>个时候，依然让所有线程访问老的缓存，因为缓存并没有设置过期，但是另开一个线程对缓存进行</p>
<p>重构。等重构成功，即执行了 redis set 操作之后，所有的线程就可以访问到重构后的缓存中的新的</p>
<p>内容了</p>
<p> 从缓存层面来看，确实没有设置过期时间，所以不会出现热点 key 过期后产生的问题，也就是“物理”不</p>
<p>过期。</p>
<p> 从功能层面来看，为每个 value 设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线</p>
<p>程去构建缓存。 一致性问题：</p>
<p> 先删除缓存，然后在更新数据库，如果删除缓存失败，那就不要更新数据库，如果说删除缓存成功，而</p>
<p>更新数据库失败，那查询的时候只是从数据库里查了旧的数据而已，这样就能保持数据库与缓存的一致</p>
<p>性。</p>
<p> 先去缓存里看下有没有数据，如果没有，可以先去队列里看是否有相同数据在做更新，发现队列里有一个请求了，那么就不要放新的操作进去了，用一个 while（true）循环去查询缓存，循环个 200MS 左右再次发送到队列里去，然后同步等待缓存更新完成。 MySQL 数据库和 SQL 优化与 JDBC</p>
<h2 id="为什么-InnoDB-支持事务而-myisam-不支持"><a href="#为什么-InnoDB-支持事务而-myisam-不支持" class="headerlink" title="为什么 InnoDB 支持事务而 myisam 不支持"></a>为什么 InnoDB 支持事务而 myisam 不支持</h2><p> MyISAM:这个是默认类型,它是基于传统的 ISAM 类型,ISAM 是 Indexed Sequential Access Method (有索引的</p>
<p>顺序访问方法) 的缩写,它是存储记录和文件的标准方法.与其他存储引擎比较,MyISAM 具有检查和修复表格的大多数工具. MyISAM 表格可以被压缩,而且它们支持全文搜索.它们不是事务安全的,而且也不支持外键。如果事物回滚将造成不完全回滚，不具有原子性。如果执行大量的 SELECT，MyISAM 是更好的选择。</p>
<p> InnoDB:这种类型是事务安全的.它与 BDB 类型具有相同的特性,它们还支持外键.InnoDB 表格速度很快.具有比 BDB 还丰富的特性,因此如果需要一个事务安全的存储引擎,建议使用它.如果你的数据执行大量的</p>
<p>INSERT 或 UPDATE,出于性能方面的考虑，应该使用 InnoDB 表</p>
<h2 id="SQL-语句中关于查询语句的优化你们是怎么做的？"><a href="#SQL-语句中关于查询语句的优化你们是怎么做的？" class="headerlink" title="SQL 语句中关于查询语句的优化你们是怎么做的？"></a>SQL 语句中关于查询语句的优化你们是怎么做的？</h2><p>\1. 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p>
<p>\2. 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
<p>\3. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</p>
<p>\4. 尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描</p>
<p>\5. in 和 not in 也要慎用，否则会导致全表扫描</p>
<p>\6. 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。</p>
<p>\7. 应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描8. 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用</p>
<p>索引。</p>
<p>\9. 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件</p>
<p>时才能保证系统使用该索引，否则该索引将不会被使 用，并且应尽可能的让字段顺序与索引顺序相一致。</p>
<p>\10. 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。</p>
<p>\11. 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>
<p>\12. 任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p>
<p>\13. 使用连接（JOIN）来代替子查询(Sub-Queries)</p>
<p>\14. 使用联合(UNION)来代替手动创建的临时表</p>
<p>MySQL 索引使用限制</p>
<p>不要在列上进行运算</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span><span class="built_in"> users </span>where YEAR(adddate)&lt;2007;</span><br></pre></td></tr></table></figure>

<p>将在每个行上进行运算，这将导致索引失效而进行全表扫描，</p>
<p>因此我们可以改成 select * from users where adddate&lt;‘2007-01-01’;</p>
<p>like 查询是以%开头不使用索引</p>
<p>如果使用 like。like “%aaa%” 不会使用索引而 like “aaa%”可以使用索引。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span><span class="built_in"> users </span>where name like <span class="string">'%aaa%'</span>不会使用索引</span><br><span class="line"></span><br><span class="line">select * <span class="keyword">from</span><span class="built_in"> users </span>where name like <span class="string">'aaa%'</span>可以使用索引</span><br></pre></td></tr></table></figure>

<p>使用短索引</p>
<p>例如，如果有一个 CHAR(255)的列，如果在前 10 个或 20 个字符内，多数值是惟一的，</p>
<p>那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和 I/O 操作。 索引不会包含 NULL 列，IS NULL /IS NOT NULL 不使用索引</p>
<p>复合索引中如果有一列含有 NULL 值那么这个组合索引都将失效,一般需要给默认值 0 或者 ‘ ‘字符串</p>
<p>最左匹配，任何一个索引的最左前缀可以通过使用优化器来查找行</p>
<p>不按索引最左列开始查询（多列索引） 例如：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">index</span>(‘<span class="built_in">c1</span>’, ‘<span class="built_in">c2</span>’, ‘<span class="built_in">c3</span>’) ，</span><br><span class="line"></span><br><span class="line"><span class="symbol">where</span> ‘<span class="built_in">c2</span>’ = ‘aaa’ 不使用索引,</span><br><span class="line"></span><br><span class="line"><span class="symbol">where</span> ‘<span class="built_in">c2</span>’ = ‘aaa’ <span class="keyword">and </span>‘<span class="built_in">c3</span>’ = ‘sss’ 不能使用索引。</span><br><span class="line"></span><br><span class="line"><span class="symbol">where</span> ‘<span class="built_in">c1</span>’ = ‘aaa’ <span class="keyword">and </span>‘<span class="built_in">c2</span>’ = ‘<span class="keyword">bbb’ </span>可以使用索引。</span><br></pre></td></tr></table></figure>

<p>index(‘c1’)靠最左可以使用索引。多列索引，不是使用的第一部分，则不会使用索引</p>
<p>查询中某个列有范围查询，则其右边的所有列都无法使用查询（多列查询）。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">where</span> <span class="built_in">c1</span>= ‘xxx’ <span class="keyword">and </span><span class="built_in">c2</span> like = ‘aa%’ <span class="keyword">and </span><span class="built_in">c3</span>=’sss’</span><br></pre></td></tr></table></figure>

<p>该查询只会使用索引中的前两列,c3 将不能使用到索引,因为 like 是范围查询。 检索排序</p>
<p>一个查询语句中，既有检索又有排序并且是不同的字段，且这两个列上都有单列索引（独立索引），</p>
<p>那么只有其中一个列用到索引，因为查询优化器在做检索和排序中不能同时使用两个不同的索引。 索引散列度通过索引扫描的记录超过了表总行数的 30%（估计值），则查询优化器认为全表扫描的效率更高，所以会变成全表扫描查询。 隐式转换：如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引隐式转换导致的索引失效。比如，表的字段 tu_mdn 定义为 varchar(20), 但在查询时把该字段作为 number 类型当做 where 条件,这样会导致索引失效. 错误的例子：select * from test where tu_mdn=13333333333;</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正确的例子：<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> tu_mdn=<span class="string">'13333333333’;</span></span><br></pre></td></tr></table></figure>

<p>条件中有 or</p>
<p>即使其中有条件带索引也不会使用(这也是为什么尽量少用 or 的原因)</p>
<p>注意：要想使用 or，又想让索引生效，只能将 or 条件中的每个列都加上索引</p>
<p>使用全表扫描要比使用索引快,则不使用索引，数据唯一性差（一个字段的取值只有几种时）的字</p>
<p>段不要使用索引比如性别，只有两种可能数据。意味着索引的二叉树级别少，多是平级。这样的二叉树查找无异于全表扫描频繁更新的字段不要使用索引</p>
<p>比如 logincount 登录次数，频繁变化导致索引也频繁变化，增大数据库工作量，降低效率</p>
<p>where 子句里对索引列使用不等于（&lt;&gt;），使用索引效果一般，不使用索引</p>
<h2 id="数据库创建表的时候会有哪些考虑呢？"><a href="#数据库创建表的时候会有哪些考虑呢？" class="headerlink" title="数据库创建表的时候会有哪些考虑呢？"></a>数据库创建表的时候会有哪些考虑呢？</h2><p>项目中使用的是 MySQL 数据库，数据库创建表时要考虑： 大数据字段最好剥离出单独的表，以便影响性能</p>
<p> 使用 varchar，代替 char，这是因为 varchar 会动态分配长度，char 指定为 20，即时你存储字符“1”，它依</p>
<p>然是 20 的长度</p>
<p> 给表建立主键，看到好多表没主键，这在查询和索引定义上将有一定的影响</p>
<p> 避免表字段运行为 null，如果不知道添加什么值，建议设置默认值，特别 int 类型，比如默认值为 0，在索引查询上，效率立显。</p>
<p> 建立索引，聚集索引则意味着数据的物理存储顺序，最好在唯一的，非空的字段上建立，其它索引也不是越多越好，索引在查询上优势显著，在频繁更新数据的字段上建立聚集索引，后果很严重，插入更新相当忙。</p>
<p> 组合索引和单索引的建立，要考虑查询实际和具体模式</p>
<h2 id="有了解过大数据层面的分库分表吗？以及-mysql-的执行计划吗？"><a href="#有了解过大数据层面的分库分表吗？以及-mysql-的执行计划吗？" class="headerlink" title="有了解过大数据层面的分库分表吗？以及 mysql 的执行计划吗？"></a>有了解过大数据层面的分库分表吗？以及 mysql 的执行计划吗？</h2><p> 分库：通过 Mycat 结点来管理不同服务器上的数据库，每个表最多存 500 万条记录</p>
<p> 分表：重直切割，水平切割</p>
<p>MySql 提供了 EXPLAIN 语法用来进行查询分析，在 SQL 语句前加一个”EXPLAIN”即可。mysql 中的</p>
<p>explain 语法可以帮助我们改写查询，优化表的结构和索引的设置，从而最大地提高查询效率。</p>
<h2 id="有了解过数据库中的表级锁和行级锁吗？乐观锁和悲观锁你有哪些了解？"><a href="#有了解过数据库中的表级锁和行级锁吗？乐观锁和悲观锁你有哪些了解？" class="headerlink" title="有了解过数据库中的表级锁和行级锁吗？乐观锁和悲观锁你有哪些了解？"></a>有了解过数据库中的表级锁和行级锁吗？乐观锁和悲观锁你有哪些了解？</h2><p>MySQL 的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。比如，MyISAM</p>
<p>和 MEMORY 存储引擎采用的是表级锁（table-level locking）；InnoDB 存储引擎既支持行级锁</p>
<p>（ row-level locking），也支持表级锁，但默认情况下是采用行级锁。</p>
<p>MySQL 主要锁的特性可大致归纳如下:  表级锁： 开销小，加锁快；不会出现死锁(因为 MyISAM 会一次性获得 SQL 所需的全部锁)；锁定粒度大，</p>
<p>发生锁冲突的概率最高,并发度最低。</p>
<p> 行级锁： 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p>
<p> 乐观锁：通过 version 版本字段来实现</p>
<p> 悲观锁：通过 for update 来实现</p>
<p>Sql 层面：</p>
<p>一、悲观锁</p>
<p> 排它锁，当事务在操作数据时把这部分数据进行锁定，直到操作完毕后再解锁，其他事务操作才可操</p>
<p>作该部分数据。这将防止其他进程读取或修改表中的数据。</p>
<p> 实现：大多数情况下依靠数据库的锁机制实现 一般使用 select …for update 对所选择的数据进行加锁处理，例如 select * from account where</p>
<p>name=”Max” for update， 这条 sql 语句锁定了 account 表中所有符合检索条件（name=”Max”）的</p>
<p>记录。本次事务提交之前（事务提交时会释放事务过程中的锁），外界无法修改这些记录。</p>
<p>二、乐观锁 如果有人在你之前更新了，你的更新应当是被拒绝的，可以让用户重新操作。</p>
<p> 实现：大多数基于数据版本（Version）记录机制实现</p>
<p>具体可通过给表加一个版本号或时间戳字段实现，当读取数据时，将 version 字段的值一同读出，</p>
<p>数据每更新一次，对此 version 值加一。当我们提交更新的时候，判断当前版本信息与第一次取出</p>
<p>来的版本值大小，如果数据库表当前版本号与第一次取出来的 version 值相等，则予以更新，否则</p>
<p>认为是过期数据，拒绝更新，让用户重新操作。</p>
<p>代码层面：</p>
<p> 悲观锁:一段执行逻辑加上悲观锁,不同线程同时执行时,只能有一个线程执行,其他的线程在入口处等待, 直到锁被释放.  乐观锁:一段执行逻辑加上乐观锁,不同线程同时执行时,可以同时进入执行,在最后更新数据的时候要检查</p>
<p>这些数据是否被其他线程修改了(版本和执行初是否相同),没有修改则进行更新,否则放弃本次操作。</p>
<h2 id="Mysql-优化有没有工具"><a href="#Mysql-优化有没有工具" class="headerlink" title="Mysql 优化有没有工具"></a>Mysql 优化有没有工具</h2><p>三个 MySQL 性能测试工具：The MySQL Benchmark Suite、MySQL super-smack、MyBench。除了第</p>
<p>一个为 MySQL 性能测试工具，其他两个都为压力测试工具。 </p>
<h2 id="你有了解-mysql-的隔离级别吗？mysql-默认的隔离级别是什么？"><a href="#你有了解-mysql-的隔离级别吗？mysql-默认的隔离级别是什么？" class="headerlink" title="你有了解 mysql 的隔离级别吗？mysql 默认的隔离级别是什么？"></a>你有了解 mysql 的隔离级别吗？mysql 默认的隔离级别是什么？</h2><p>数据库事务的隔离级别有四种，隔离级别高的数据库的可靠性高，但并发量低，而隔离级别低的数</p>
<p>据库可靠性低，但并发量高，系统开销小。</p>
<p>\1. READ UNCIMMITTED（未提交读）</p>
<p>\2. READ COMMITTED（提交读）</p>
<p>\3. REPEATABLE READ（可重复读）</p>
<p>\4. SERIALIZABLE（可串行化）</p>
<p>mysql 默认的事务处理级别是’REPEATABLE-READ’,也就是可重复读。 怎样进行数据库性能调优</p>
<p>一：应用程序优化</p>
<p> 把数据库当作奢侈的资源看待，在确保功能的同时，尽可能少地动用数据库资源。</p>
<p> 不要直接执行完整的 SQL 语法，尽量通过存储过程实现数据库操作。</p>
<p> 客户与服务器连接时，建立连接池，让连接尽量得以重用，以避免时间与资源的损耗。</p>
<p> 非到不得已，不要使用游标结构，确实使用时，注意各种游标的特性。 二：基本表设计优化</p>
<p> 表设计遵循第三范式。在基于表驱动的信息管理系统中，基本表的设计规范是第三范式。</p>
<p> 分割表。分割表可分为水平分割表和垂直分割表两种：水平分割是按照行将一个表分割为多个表。</p>
<p> 引入中间表。三： 数据库索引优化</p>
<p>索引是建立在表上的一种数据组织，它能提高访问表中一条或多条记录的特定查询效率。</p>
<p> 聚集索引：该索引中键值的逻辑顺序决定了表中相应行的物理顺序。聚集索引确定表中数据的物理顺序。</p>
<p> 非聚集索引：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同. MySQL 存储过程</p>
<p>SQL 语句需要先编译然后执行，而存储过程（Stored Procedure）是一组为了完成特定功能的 SQL</p>
<p>语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带</p>
<p>有参数）来调用执行它。存储过程是可编程的函数，在数据库中创建并保存，可以由 SQL 语句和</p>
<p>控制结构组成。当想要在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过</p>
<p>程是非常有用的。数据库中的存储过程可以看做是对编程中面向对象方法的模拟，它允许控制数据</p>
<p>的访问方式。</p>
<p>存储过程的优点：</p>
<p>\1. 增强 SQL 语言的功能和灵活性：存储过程可以用控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。</p>
<p>\2. 标准组件式编程：存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的 SQL 语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。</p>
<p>\3. 较快的执行速度：如果某一操作包含大量的 Transaction-SQL 代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的 Transaction-SQL 语句在每次运行时都要进行编译和优化，速度相对要慢一些。</p>
<p>\4. 减少网络流量：针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的 Transaction-SQL语句被组织进存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大减少网络流量并降低了网络负载。</p>
<p>\5. 作为一种安全机制来充分利用：通过对执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。 MySQL 存储过程的创建</p>
<p>语法：</p>
<p>CREATE PROCEDURE 过程名([[IN|OUT|INOUT] 参数名 数据类型[,[IN|OUT|INOUT] 参数名 数据类</p>
<p>型…]]) [特性 …] 过程体</p>
<p>DELIMITER //</p>
<p>CREATE PROCEDURE myproc(OUT s int)</p>
<p>BEGIN</p>
<p>SELECT COUNT(*) INTO s FROM students;</p>
<p>END</p>
<p>//</p>
<p>DELIMITER ;分隔符：MySQL 默认以”;”为分隔符，如果没有声明分割符，则编译器会把存储过程当成 SQL 语句进行处理，因此编译过程会报错，所以要事先用“DELIMITER //”声明当前段分隔符，让编译器把两个”//“之间的内容当做存储过程的代码，不会执行这些码；“DELIMITER ;”的意为把分隔符还原。</p>
<p>参数：存储过程根据需要可能会有输入、输出、输入输出参数，如果有多个参数用”,”分割开。MySQL</p>
<p>存储过程的参数用在存储过程的定义，共有三种参数类型,IN,OUT,INOUT:  IN 参数的值必须在调用存储过程时指定，在存储过程中修改该参数的值不能被返回，为默认值</p>
<p> OUT:该值可在存储过程内部被改变，并可返回</p>
<p> INOUT:调用时指定，并且可被改变和返回</p>
<p>过程体：过程体的开始与结束使用 BEGIN 与 END 进行标识。 怎么实现数据量大、 并发量高的搜索</p>
<p>创建 Elasticsearch/solr 索引库，数据量特别大时采用 Elasticsearch/solr 分布式集群。</p>
<h2 id="JDBC-的理解"><a href="#JDBC-的理解" class="headerlink" title="JDBC 的理解"></a>JDBC 的理解</h2><p>JDBC（Java DataBase Connectivity,java 数据库连接）是一种用于执行 SQL 语句的 Java API，可以为多种关系数据库提供统一访问，它由一组用 Java 语言编写的类和接口组成。JDBC 提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。有了 JDBC，向各种关系数据发送 SQL 语句就是一件很容易的事。换言之，有了 JDBC API，就不必为访问 Sybase</p>
<p>数据库专门写一个程序，为访问 Oracle 数据库又专门写一个程序，或为访问 Informix 数据库又编</p>
<p>写另一个程序等等，程序员只需用 JDBC API 写一个程序就够了，它可向相应数据库发送 SQL 调用。</p>
<p>AngularJS 框架</p>
<h2 id="AngularJS-四大特征？"><a href="#AngularJS-四大特征？" class="headerlink" title="AngularJS 四大特征？"></a>AngularJS 四大特征？</h2><p>MVC 模式</p>
<p> Model:数据,其实就是 angular 变量($scope.XX);  View: 数据的呈现,Html+Directive(指令);  Controller:操作数据,就是 function,数据的增删改查;</p>
<p>双向绑定</p>
<p>首先我们要理解数据绑定。我们看到的网站页面中，是由数据和设计两部分组合而成。将设计转换</p>
<p>成浏览器能理解的语言，便是 html 和 css 主要做的工作。而将数据显示在页面上，并且有一定的</p>
<p>交互效果（比如点击等用户操作及对应的页面反应）则是 js 主要完成的工作。很多时候我们不可</p>
<p>能每次更新数据便刷新页面（get 请求），而是通过向后端请求相关数据，并通过无刷新加载的方</p>
<p>式进行更新页面（post 请求）。那么数据进行更新后，页面上相应的位置也能自动做出对应的修改，便是数据绑定。在以前的开发模式中，这一步一般通过 jq 操作 DOM 结构，从而进行更新页面。</p>
<p>但这样带来的是大量的代码和大量的操作。如果能在开始的时候，便已经确定好从后端获取的数据</p>
<p>到页面上需要进行的操作，当数据发生改变，页面的相关内容也自动发生变化，这样便能极大地方</p>
<p>便前端工程师的开发。在新的框架中（angualr，react，vue 等）,通过对数据的监视，发现变化便</p>
<p>根据已经写好的规则进行修改页面，便实现了数据绑定。可以看出，数据绑定是 M(model，数据）</p>
<p>通过 VM（model-view，数据与页面之间的变换规则）向 V（view）的一个修改。而双向绑定则是</p>
<p>增加了一条反向的路。在用户操作页面（比如在 Input 中输入值）的时候，数据能及时发生变化，</p>
<p>并且根据数据的变化，页面的另一处也做出对应的修改。有一个常见的例子就是淘宝中的购物车，</p>
<p>在商品数量发生变化的时候，商品价格也能及时变化。这样便实现了 V——M——VM——V 的一个</p>
<p>双向绑定。这里是区别于 Jquery 的，jq 操作的是 dom 对象，angularJS 操作的是变量</p>
<p>依赖注入</p>
<p>对象在创建时，其依赖的对象由框架来自动创建并注入进来。控制器就是通过依赖注入的方式实</p>
<p>现对服务的调用。</p>
<p>模块化设计</p>
<p>高内聚低耦合法则</p>
<p> 高内聚：每个模块的具体功能具体实现</p>
<p> 低耦合：模块之间尽可能的少用关联和依赖</p>
<p> 官方提供的模块 ng(最核心)、ngRoute(路由)、ngAnimate（动画）</p>
<p> 用户自定义的模块 angular.module(‘模块名’,[ ])</p>
<h1 id="Nginx-服务器"><a href="#Nginx-服务器" class="headerlink" title="Nginx 服务器"></a>Nginx 服务器</h1><h2 id="什么是-Nginx"><a href="#什么是-Nginx" class="headerlink" title="什么是 Nginx?"></a>什么是 Nginx?</h2><p>nginx 本是一个 web 服务器和反向代理服务器，但由于丰富的负载均衡策略，常常被用于客户端可</p>
<p>真实的服务器之间，作为负载均衡的实现。用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。 请列举 Nginx 的一些特性？</p>
<p> 反向代理/L7 负载均衡器</p>
<p> 嵌入式 Perl 解释器</p>
<p> 动态二进制升级</p>
<p> 可用于重新编写 URL，具有非常好的 PCRE 支持</p>
<h2 id="nginx-和-apache-的区别？"><a href="#nginx-和-apache-的区别？" class="headerlink" title="nginx 和 apache 的区别？"></a>nginx 和 apache 的区别？</h2><p> 轻量级，同样起 web 服务，比 apache 占用更少的内存及资源 抗并发，nginx 处理请求是异步非阻塞的，而 apache 则是阻塞型的，在高并发下 nginx 能保持低资源低</p>
<p>消耗高性能</p>
<p> 高度模块化的设计，编写模块相对简单</p>
<p> 最核心的区别在于 apache 是同步多进程模型，一个连接对应一个进程；nginx 是异步的，多个连接（万</p>
<p>级别）可以对应一个进程</p>
<h2 id="nginx-是如何实现高并发的？"><a href="#nginx-是如何实现高并发的？" class="headerlink" title="nginx 是如何实现高并发的？"></a>nginx 是如何实现高并发的？</h2><p>一个主进程，多个工作进程，每个工作进程可以处理多个请求，每进来一个 request，会有一个 worker</p>
<p>进程去处理。但不是全程的处理，处理到可能发生阻塞的地方，比如向上游（后端）服务器转发</p>
<p>request，并等待请求返回。那么，这个处理的 worker 继续处理其他请求，而一旦上游服务器返回</p>
<p>了，就会触发这个事件，worker 才会来接手，这个 request 才会接着往下走。由于 web server 的工作性质决定了每个 request 的大部份生命都是在网络传输中，实际上花费在 server 机器上的时间片不多。这是几个进程就解决高并发的秘密所在。即@skoo 所说的 webserver 刚好属于网络 io 密集</p>
<p>型应用，不算是计算密集型。 </p>
<h2 id="请解释-Nginx-如何处理-HTTP-请求？"><a href="#请解释-Nginx-如何处理-HTTP-请求？" class="headerlink" title="请解释 Nginx 如何处理 HTTP 请求？"></a>请解释 Nginx 如何处理 HTTP 请求？</h2><p>Nginx 使用反应器模式。主事件循环等待操作系统发出准备事件的信号，这样数据就可以从套接字</p>
<p>读取，在该实例中读取到缓冲区并进行处理。单个线程可以提供数万个并发连接。 </p>
<h2 id="在-Nginx-中，如何使用未定义的服务器名称来阻止处理请求"><a href="#在-Nginx-中，如何使用未定义的服务器名称来阻止处理请求" class="headerlink" title="在 Nginx 中，如何使用未定义的服务器名称来阻止处理请求?"></a>在 Nginx 中，如何使用未定义的服务器名称来阻止处理请求?</h2><p>只需将请求删除的服务器就可以定义为：Server {listen 80; server_name “ “ ;return 444;}这里，服务</p>
<p>器名被保留为一个空字符串，它将在没有“主机”头字段的情况下匹配请求，而一个特殊的 Nginx 的</p>
<p>非标准代码 444 被返回，从而终止连接。7、 使用“反向代理服务器”的优点是什么?答：反向代理</p>
<p>服务器可以隐藏源服务器的存在和特征。它充当互联网云和 web 服务器之间的中间层。这对于安</p>
<p>全方面来说是很好的，特别是当您使用 web 托管服务时。 请列举 Nginx 服务器的最佳用途?</p>
<p>Nginx 服务器的最佳用法是在网络上部署动态 HTTP 内容，使用 SCGI、WSGI 应用程序服务器、用于</p>
<p>脚本的 FastCGI 处理程序。它还可以作为负载均衡器。 </p>
<h2 id="请解释-Nginx-服务器上的-Master-和-Worker-进程分别是什么"><a href="#请解释-Nginx-服务器上的-Master-和-Worker-进程分别是什么" class="headerlink" title="请解释 Nginx 服务器上的 Master 和 Worker 进程分别是什么?"></a>请解释 Nginx 服务器上的 Master 和 Worker 进程分别是什么?</h2><p>Master 进程：读取及评估配置和维持 Worker 进程：处理请求</p>
<h2 id="请解释你如何通过不同于-80-的端口开启-Nginx"><a href="#请解释你如何通过不同于-80-的端口开启-Nginx" class="headerlink" title="请解释你如何通过不同于 80 的端口开启 Nginx?"></a>请解释你如何通过不同于 80 的端口开启 Nginx?</h2><p>为了通过一个不同的端口开启 Nginx，你必须进入/etc/Nginx/sites-enabled/，如果这是默认文件，</p>
<p>那么你必须打开名为“default”的文件。编辑文件，并放置在你想要的端口：Like server {listen 81;}请解释是否有可能将 Nginx 的错误替换为 502 错误、503?</p>
<p>502 =错误网关 503 =服务器超载 有可能，但是您可以确保 fastcgi_intercept_errors 被设置为 ON，</p>
<p>并使用错误页面指令。Location / { fastcgi_pass 127.0.01:9001; fastcgi_intercept_errors on; error_page</p>
<p>502 =503/error_page.html; #… }</p>
<h2 id="在-Nginx-中，解释如何在-URL-中保留双斜线"><a href="#在-Nginx-中，解释如何在-URL-中保留双斜线" class="headerlink" title="在 Nginx 中，解释如何在 URL 中保留双斜线?"></a>在 Nginx 中，解释如何在 URL 中保留双斜线?</h2><p>要在 URL 中保留双斜线，就必须使用 merge_slashes_off;语法:merge_slashes [on/off]默认值:</p>
<p>merge_slashes on 环境: http，server</p>
<p>请解释 ngx_http_upstream_module 的作用是什么?</p>
<p>ngx_http_upstream_module 用于定义可通过 fastcgi 传递、proxy 传递、uwsgi 传递、memcached 传</p>
<p>递和 scgi 传递指令来引用的服务器组。 请解释什么是 C10K 问题?</p>
<p>C10K 问题是指无法同时处理大量客户端(10,000)的网络套接字。 </p>
<h2 id="请陈述-stub-status-和-sub-filter-指令的作用是什么"><a href="#请陈述-stub-status-和-sub-filter-指令的作用是什么" class="headerlink" title="请陈述 stub_status 和 sub_filter 指令的作用是什么?"></a>请陈述 stub_status 和 sub_filter 指令的作用是什么?</h2><p> Stub_status 指令：该指令用于了解 Nginx 当前状态的当前状态，如当前的活动连接，接受和处理当前读/</p>
<p>写/等待连接的总数</p>
<p> Sub_filter 指令：它用于搜索和替换响应中的内容，并快速修复陈旧的数据</p>
<p>解释 Nginx 是否支持将请求压缩到上游?</p>
<p>您可以使用 Nginx 模块 gunzip 将请求压缩到上游。gunzip 模块是一个过滤器，它可以对不支持“gzip” 编码方法的客户机或服务器使用“内容编码:gzip”来解压缩响应。 解释如何在 Nginx 中获得当前的时间?</p>
<p>要获得 Nginx 的当前时间，必须使用 SSI 模块、$date_gmt 和$date_local 的变量。Proxy_set_header</p>
<p>THE-TIME $date_gmt;</p>
<h2 id="用-Nginx-服务器解释-s-的目的是什么"><a href="#用-Nginx-服务器解释-s-的目的是什么" class="headerlink" title="用 Nginx 服务器解释-s 的目的是什么?"></a>用 Nginx 服务器解释-s 的目的是什么?</h2><p>用于运行 Nginx -s 参数的可执行文件。 解释如何在 Nginx 服务器上添加模块?在编译过程中，必须选择 Nginx 模块，因为 Nginx 不支持模块的运行时间选择。 什么是反向代理和正向代理?</p>
<p> 正向代理：被代理的是客户端，比如通过 XX 代理访问国外的某些网站，实际上客户端没有权限访问国外</p>
<p>的网站，客户端请求 XX 代理服务器，XX 代理服务器访问国外网站，将国外网站返回的内容传给真正的</p>
<p>用户。用户对于服务器是隐藏的，服务器并不知道真实的用户。</p>
<p> 反向代理：被代理的是服务器，也就是客户端访问了一个所谓的服务器，服务器会将请求转发给后台真</p>
<p>实的服务器，真实的服务器做出响应，通过代理服务器将结果返给客户端。服务器对于用户来说是隐藏</p>
<p>的，用户不知道真实的服务器是哪个。 说明：关于正向代理和反向代理，听起来比较绕，仔细理解，体会也不难明白到底是什么意思。用</p>
<p>nginx 做实现服务的高可用，nginx 本身可能成为单点，遇见的两种解决方案，一种是公司搭建自己</p>
<p>的 DNS，将请求解析到不同的 NGINX，另一只是配合 keepalive 实现服务的存活检测。</p>
<p>Nginx 静态页面服务跳转到购物车跨域问题</p>
<p>在 Nginx 中部署了静态页面，添加购物车时必须从静态页面跳转到购物车系统,实现购物车添加操</p>
<p>作。由于在静态页面中使用 angularJS 实现的跳转，发现跳转到购物车系统完全没有问题，但是并</p>
<p>不能跳转回到购物车系统页面。</p>
<p> 问题分析：从静态详情系统跳转到购物车系统，会存在跨域问题，因此不能进行回调函数的数据传递。</p>
<p>所以在回调函数中的页面跳转就不能实现。</p>
<p> 解决方案：使用 angularJS 跨域调用及 springmvc 跨域配置，解决问题。 FastDFS 分布式文件系统</p>
<p>简单介绍一下 FastDFS？</p>
<p> 开源的分布式文件系统，主要对文件进行存储、同步、上传、下载，有自己的容灾备份、负载均衡、线</p>
<p>性扩容机制；</p>
<p> FastDFS 架构主要包含 Tracker（跟踪） server 和 Storage（组，卷） server。客户端请求 Tracker server 进</p>
<p>行文件上传、下载的时候，通过 Tracker server 调度最终由 Storage server 完成文件上传和下载。</p>
<p> Tracker server：跟踪器或者调度器，主要起负载均衡和调度作用。通过 Tracker server 在文件上传时可以</p>
<p>根据一些策略找到 Storage server 提供文件上传服务。</p>
<p>Storage server：存储服务器，作用主要是文件存储，完成文件管理的所有功能。客户端上传的文件</p>
<p>主要保存在 Storage server 上，Storage server 没有实现自己的文件系统而是利用操作系统的文件系统去管理文件。</p>
<p> 存储服务器采用了分组/分卷的组织方式。</p>
<p> 整个系统由一个组或者多个组组成；</p>
<p> 组与组之间的文件是相互独立的； 所有组的文件容量累加就是整个存储系统的文件容量；</p>
<p> 一个组可以由多台存储服务器组成，一个组下的存储服务器中的文件都是相同的，组中的多台存储服务器起到了冗余备份和负载均衡的作用；</p>
<p> 在组内增加服务器时，如果需要同步数据，则由系统本身完成，同步完成之后，系统自动将新增的服务</p>
<p>器切换到线上提供使用；</p>
<p> 当存储空间不足或者耗尽时，可以动态的添加组。只需要增加一台服务器，并为他们配置一个新的组，</p>
<p>即扩大了存储系统的容量。 为什么要使用 FastDFS 作为你们的图片服务器？</p>
<p>首先基于 fastDFS 的特点：存储空间可扩展、提供了统一的访问方式、访问效率高、容灾性好 等</p>
<p>特点，再结合我们项目中图片的容量大、并发大等特点，因此我们选择了 FastDFS 作为我们的图片</p>
<p>服务器；Nginx 也可以作为一台图片服务器来使用，因为 nginx 可以作为一台 http 服务器来使用，</p>
<p>作为网页静态服务器，通过 location 标签配置；在公司中有的时候也用 ftp 作为图片服务器来使用。</p>
<h2 id="FastDFS-中文件上传下载的具体流程？"><a href="#FastDFS-中文件上传下载的具体流程？" class="headerlink" title="FastDFS 中文件上传下载的具体流程？"></a>FastDFS 中文件上传下载的具体流程？</h2><p>客户端上传文件后生成一个 file_id，返回给客户端，客户端利用这个 file_id 结合 ip 地址，生成一</p>
<p>个完成图片的 url，保存在数据库中。生成的那个 file_id 用于以后访问该文件的索引信息。</p>
<p>FastDFS 文件下载的流程ActiveMQ 信息队列</p>
<h2 id="什么是消息队列？"><a href="#什么是消息队列？" class="headerlink" title="什么是消息队列？"></a>什么是消息队列？</h2><p>就是消息的传输过程中保存消息的容器。 消息队列都解决了什么问题？</p>
<p>异步，并行，解耦，排队</p>
<h2 id="消息模式？"><a href="#消息模式？" class="headerlink" title="消息模式？"></a>消息模式？</h2><p>订阅，点对点</p>
<p>重复消费</p>
<p>Queue 支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。 丢消息</p>
<p> 用持久化消息</p>
<p> 非持久化消息及时处理不要堆积</p>
<p> 启动事务，启动事务后，commit()方法会负责等待服务器的返回，也就不会关闭连接导致消息丢失。消息重发</p>
<p>消息被重新传递给客户端：</p>
<p> 使用事务会话，并调用滚退（）。</p>
<p> 在调用 commit()之前关闭事务会话。</p>
<p> 会话使用 CLIENT_ACKNOWLEDGE 签收模式，并 Session .recover()重发被调用。</p>
<p> 客户端连接超时（也许正在执行的代码要比配置的超时周期更长）。 什么是 ActiveMQ？</p>
<p>activeMQ 是一种开源的，面向消息的中间件，用来系统之间进行通信的</p>
<p>activemq 的原理</p>
<p>原理就是生产者生产消息，把消息发送给 activemq。Activemq 接收到消息，然后查看有多少个消</p>
<p>费者， 然后把消息转发给消费者， 此过程中生产者无需参与。 消费者接收到消息后做相应的处理</p>
<p>和生产者没有任何关系</p>
<p>对比 RabbitMQ</p>
<p>RabbitMQ 的协议是 AMQP，而 ActiveMQ 使用的是 JMS 协议。顾名思义 JMS 是针对 Java 体系的传</p>
<p>输协议，队列两端必须有 JVM，所以如果开发环境都是 java 的话推荐使用 ActiveMQ，可以用 Java</p>
<p>的一些对象进行传递比如 Map、Blob（二进制大数据）、Stream 等。而 AMQP 通用行较强，非 java</p>
<p>环境经常使用，传输内容就是标准字符串。另外一点就是RabbitMQ用Erlang开发，安装前要装Erlang</p>
<p>环境，比较麻烦。ActiveMQ 解压即可用不用任何安装。 对比 KafKa</p>
<p>Kafka 性能超过 ActiveMQ 等传统 MQ 工具，集群扩展性好。</p>
<p>弊端是：</p>
<p> 在传输过程中可能会出现消息重复的情况，</p>
<p> 不保证发送顺序</p>
<p> 一些传统 MQ 的功能没有，比如消息的事务功能。</p>
<p> 所以通常用 Kafka 处理大数据日志。 对比 Redis</p>
<p>其实 Redis 本身利用 List 可以实现消息队列的功能，但是功能很少，而且队列体积较大时性能会急</p>
<p>剧下降。对于数据量不大、业务简单的场景可以使用。</p>
<p>如何解决消息重复问题所谓消息重复,就是消费者接收到了重复的消息,一般来说我们对于这个问题的处理要把握下面几</p>
<p>点,  消息不丢失</p>
<p> 消息不重复执行 一般来说我们可以在业务段加一张表,用来存放消息是否执行成功,每次业务事物 commit 之后,告知</p>
<p>服务端,已经处理过该消息，这样即使你消息重发了,也不会导致重复处理，大致流程如下：业务端</p>
<p>的表记录已经处理消息的 id,每次一个消息进来之前先判断该消息是否执行过,如果执行过就放弃, 如果没有执行就开始执行消息,消息执行完成之后存入这个消息的 id</p>
<p>关于事务控制</p>
<p>获取 session 链接的时候 设置参数 默认不开启</p>
<p>producer 提交时的事务</p>
<p>事务开启</p>
<p>只执行 send 并不会提交到队列中，只有</p>
<p>当执行 session.commit()时，消息才被真</p>
<p>正的提交到队列中。</p>
<p>事务不开启 只要执行 send，就进入到队列中。</p>
<p>consumer 接收时的事务</p>
<p>事务开启，签收必须写</p>
<p>Session.SESSION_TRANSACTED</p>
<p>收到消息后，消息并没有真正的被消费。</p>
<p>消息只是被锁住。一旦出现该线程死掉、</p>
<p>抛异常，或者程序执行了</p>
<p>session.rollback()那么消息会释放，重新</p>
<p>回到队列中被别的消费端再次消费。</p>
<p>事务不开启，签收方式选择</p>
<p>Session.AUTO_ACKNOWLEDGE</p>
<p>只要调用 comsumer.receive 方法 ，自动确认。</p>
<p>事务不开启，签收方式选择</p>
<p>Session.CLIENT_ACKNOWLEDGE</p>
<p>需要客户端执行</p>
<p>message.acknowledge(),否则视为未提交</p>
<p>状态，线程结束后，其他线程还可以接</p>
<p>收到。这种方式跟事务模式很像，区别</p>
<p>是不能手动回滚,而且可以单独确认某</p>
<p>个消息。</p>
<p>手动签收</p>
<p>事务不开启，签收方式选择</p>
<p>Session.DUPS_OK_ACKNOWLEDGE</p>
<p>在 Topic 模式下做批量签收时用的，可</p>
<p>以提高性能。但是某些情况消息可能会</p>
<p>被重复提交，使用这种模式的 consumer</p>
<p>要可以处理重复提交的问题。 持久化</p>
<p>通过 producer.setDeliveryMode(DeliveryMode.PERSISTENT) 进行设置，持久化的好处就是当 activemq</p>
<p>宕机的话，消息队列中的消息不会丢失。非持久化会丢失。但是会消耗一定的性能。哪些情况用到 activeMq？</p>
<p>商品上架后更新 ES 索引库时、更新静态页时、发送短信时，提交订单后清除购物车中的数据，支</p>
<p>付时修改订单状态，添加支付信息，支付成功时修改订单状态，修改支付信息，更新库存时</p>
<p>ActiveMQ 消息队列不消费</p>
<p>去 ActiveMQ.DLQ 里找找</p>
<h2 id="什么是-ActiveMQ-DLQ？"><a href="#什么是-ActiveMQ-DLQ？" class="headerlink" title="什么是 ActiveMQ.DLQ？"></a>什么是 ActiveMQ.DLQ？</h2><p> 一旦消息的重发尝试超过了为重发策略配置的最大重发次数，一个“Poison ACK”被发送回 the broker，让</p>
<p>他知道消息被认为是毒丸。the broker 然后接收消息并将其发送到死信队列，以便以后可以进行分析。</p>
<p> 在 activemq 中死信队列叫做 ActiveMQ.DLQ。所有无法传递的消息将被发送到这个队列，这很难管理。</p>
<p> 可以在 Activemq.xml 配置文件的目标策略映射中设置个体死信策略，它允许您为队列或主题指定特定的</p>
<p>死信队列前缀。</p>
<p>MQ 消费者接收不到消息怎么办？</p>
<p> 处理失败指的是 MessageListener 的 onMessage 方法里抛出 RuntimeException。</p>
<p> Message 头里有两个相关字段：Redelivered 默认为 false，redeliveryCounter 默认为 0。</p>
<p> 消息先由 broker 发送给 consumer，consumer 调用 listener，如果处理失败，本地 redeliveryCounter++，给</p>
<p>broker 一个特定应答，broker 端的 message 里 redeliveryCounter++，延迟一点时间继续调用，默认 1s。超</p>
<p>过 6 次，则给 broker 另一个特定应答，broker 就直接发送消息到 DLQ。</p>
<p> 如果失败 2 次，consumer 重启，则 broker 再推过来的消息里，redeliveryCounter=2，本地只能再重试 4</p>
<p>次即会进入 DLQ。</p>
<p> 重试的特定应答发送到 broker，broker 即会在内存将消息的 redelivered 设置为 true，redeliveryCounter++，</p>
<p>但是这两个字段都没有持久化，即没有修改存储中的消息记录。所以 broker 重启时这两个字段会被重置</p>
<p>为默认值。 怎样解决 activeMQ 的消息持久化问题？</p>
<p>A：持久化为文件</p>
<p>这个你装 ActiveMQ 时默认就是这种，只要你设置消息为持久化就可以了。</p>
<p>涉及到的配置：</p>
<persistenceAdapter>

<kahaDB directory="${activemq.base}/data/kahadb">

<p></p></kahaDB></persistenceAdapter>涉及到的代码：<p></p>
<p>producer.Send(request, MsgDeliveryMode.Persistent, level, TimeSpan.MinValue);</p>
<p>B：持久化为 MySql</p>
<p>加载驱动 jar，为数据中创建三个数据库表，存储 activemq 的消息信息</p>
<p>如果 activeMQ 的消息没有发送成功，怎样确保再次发送成功。</p>
<p>重新传递消息，ActiveMQ 在接收消息的 Client 有以下几种操作的时候，需要重新传递消息：</p>
<p> Client 用了 transactions（事务），且在 session 中调用了 rollback()  Client 用了 transactions，且在调用 commit()之前关闭</p>
<p> Client 在 CLIENT_ACKNOWLEDGE 的传递模式下，在 session 中调用了 recover()</p>
<p>确保客户端有几种状态，检测状态，只要提交了那就说明客户端成功！</p>
<p>MQ 丢包如何解决</p>
<p>transaction 机制就是说，发送消息前，开启事物(channel.txSelect())，然后发送消息，如果发送过程</p>
<p>中出现什么异常，事物就会回滚(channel.txRollback())，如果发送成功则提交事物</p>
<p>(channel.txCommit())。然而缺点就是吞吐量下降了。所有在该信道上面发布的消息都将会被指派一</p>
<p>个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，rabbitMQ 就会发送一个 Ack 给生</p>
<p>产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了.如果 rabiitMQ 没能</p>
<p>处理该消息，则会发送一个 Nack 消息给你，你可以进行重试操作。 如果 activeMQ 的服务挂了，怎么办？</p>
<p> 在通常的情况下，非持久化消息是存储在内存中的，持久化消息是存储在文件中的，它们的最大限制在</p>
<p>配置文件的<systemUsage>节点中配置。但是，在非持久化消息堆积到一定程度，内存告急的时候，</systemUsage></p>
<p>ActiveMQ 会将内存中的非持久化消息写入临时文件中，以腾出内存。虽然都保存到了文件里，但它和持</p>
<p>久化消息的区别是，重启后持久化消息会从文件中恢复，非持久化的临时文件会直接删除。</p>
<p> 考虑高可用，实现 activemq 集群。 消息发送失败怎么处理，发送数据，数据库已经保存了数据，但是 redis 中没有同步，</p>
<p>怎么办。或者说如何做到消息同步。</p>
<p>消息发送失败，可以进行消息的重新发送，可以配置消息的重发次数。如果消息重发完毕后，消息</p>
<p>还没有接受成功，重启服务。</p>
<p>ActiveMQ 存在发出消息太大，造成消息接受不成功，怎么解决？多个线程从 activeMQ 中取消息，随着业务的扩大，该机器占用的网络带宽越来越高。仔细分析发</p>
<p>现，mq 入队时并没有异常高的网络流量，仅仅在出队时会产生很高的网络流量。最终发现是 Spring</p>
<p>的 jmsTemplate 与 Activemq 的 prefetch 机制配合导致的问题，怎么解决？研究源码发现</p>
<p>jmsTemplate 实现机制是：每次调用 receive()时都会创建一个新的 consumer 对象，用完即销毁。正</p>
<p>常情况下仅仅会浪费重复创建 consumer 的资源代价，并不至于产生正常情况十倍百倍的网络流量。</p>
<p>但是 activeMQ 有一个提高性能的机制 prefetch，此时就会有严重的问题。</p>
<p>prefetch 机制：</p>
<p>每次 consumer 连接至 MQ 时，MQ 预先存放许多 message 到消费者（前提是 MQ 中存在大量消息），</p>
<p>预先存放 message 的数量取决于 prefetchSize（默认为 1000）。此机制的目的很显然，是想让客户</p>
<p>端代码用一个 consumer 反复进行 receive 操作，这样能够大量提高出队性能。此机制与 jmsTemplate</p>
<p>配合时就会产生严重的问题，每次 jmsTemplate.receive()，都会产生 1000 个消息的网络流量， 但</p>
<p>是因为jmsTemplae并不会重用consumer，导致后面999个消息都被废弃。反复jmsTemplate.receive()</p>
<p>时，表面上看不出任何问题，其实网络带宽会造成大量的浪费。</p>
<p>解决方案：</p>
<p> 若坚持使用 jmsTemplate，需要设置 prefetch 值为 1，相当于禁用了 activeMQ 的 prefetch 机制，此时感觉</p>
<p>最健壮， 就算多线程，反复调用 jmsTemplate.receive()也不会有任何问题。但是会有资源浪费，因为要反</p>
<p>复创建 consumer 并频繁与服务器进 行数据通信，但在性能要求不高的应用中也不算什么问题。</p>
<p> 不使用jmsTemplate，手工创建一个consumer，并单线程反复使用它来receive()，此时可以充分利用prefetch</p>
<p>机制。配合多线程的方式每个线程拥有自己的一个 consumer，此时能够充分发挥 MQ 在大吞吐量时的速</p>
<p>度优势。 切记避免多线程使用一个 consumer 造成的消息混乱。大吞吐量的应用推荐使用方案 2，能够充分</p>
<h2 id="利用-prefetch-机制提高系-MQ-的吞吐性能。"><a href="#利用-prefetch-机制提高系-MQ-的吞吐性能。" class="headerlink" title="利用 prefetch 机制提高系 MQ 的吞吐性能。"></a>利用 prefetch 机制提高系 MQ 的吞吐性能。</h2><p>activeMQ 存在运行时间长了以后，收不到消息的现象，怎么解决？</p>
<p>时间长了就会出现，卡死，新的数据不能从队列接听到。只能重启程序。</p>
<p>解决方案：</p>
<p> 不要频繁的建立和关闭连接：JMS 使用长连接方式，一个程序，只要和 JMS 服务器保持一个连接就可以</p>
<p>了，不要频繁的建立和关闭连接。频繁的建立和关闭连接，对程序的性能影响还是很大的。这一点和 jdbc</p>
<p>还是不太一样的。</p>
<p> Connection 的 start()和 stop()方法代价很高：JMS 的 Connection 的 start()和 stop()方法代价很高，不能经</p>
<p>常调用。我们试用的时候，写了个 jms 的 connection pool，每次将 connection 取出 pool 时调用 start()方</p>
<p>法，归还时调用 stop()方法，然而后来用 jprofiler 发现，一般的 cpu 时间都耗在了这两个方法上。</p>
<p> start()后才能收消息：Connection 的 start()方法调用后，才能收到 jms 消息。如果不调用这个方法，能发</p>
<p>出消息，但是一直收不到消息。不知道其它的 jms 服务器也是这样。</p>
<p> 显式关闭 Session：如果忘记了最后关闭 Connection 或 Session 对象，都会导致内存泄漏。这个在我测试</p>
<p>的时候也发现了。本来以为关闭了 Connection，由这个 Connection 生成的 Session 也会被自动关闭，结果</p>
<p>并非如此，Session 并没有关闭，导致内存泄漏。所以一定要显式的关闭 Connection 和 Session。</p>
<p> 对 Session 做对象池：对 Session 做对象池，而不是 Connection。Session 也是昂贵的对象，每次使用都新</p>
<p>建和关闭，代价也非常高。而且后来我们发现，原来 Connection 是线程安全的，而 Session 不是，所以后</p>
<p>来改成了对 Session 做对象池，而只保留一个 Connection。</p>
<p> 集群：ActiveMQ 有强大而灵活的集群功能，但是使用起来还是会有很多陷阱。Elasticsearch 全文搜索</p>
<h2 id="简单介绍一下-Elasticsearch-全文搜索"><a href="#简单介绍一下-Elasticsearch-全文搜索" class="headerlink" title="简单介绍一下 Elasticsearch 全文搜索"></a>简单介绍一下 Elasticsearch 全文搜索</h2><p>ElasticSearch 是一个基于 Lucene 的搜索服务器。通过 HTTP 使用 JSON 进行数据索引，用于分布式</p>
<p>全文检索，解决人们对于搜索的众多要求。</p>
<p>ES 的用途</p>
<p>ES 在系统中主要完成商品搜索功能，提高搜索性能。</p>
<h2 id="lucene-与-elasticsearch（solr）有什么区别？"><a href="#lucene-与-elasticsearch（solr）有什么区别？" class="headerlink" title="lucene 与 elasticsearch（solr）有什么区别？"></a>lucene 与 elasticsearch（solr）有什么区别？</h2><p>lucene 只是一个提供全文搜索功能类库的核心工具包，而真正使用它还需要一个完善的服务框架搭</p>
<p>建起来的应用。好比 lucene 是类似于 jdk，而搜索引擎软件就是 tomcat 的。elasticsearch 和 solr, 这两款都是基于 lucene 的搭建的，可以独立部署启动的搜索引擎服务软件。</p>
<p>基本概念：</p>
<p>cluster 集群 整个 elasticsearch 默认就是集群状态，整个集群是一份完整、互备的数据。</p>
<p>node 节点 集群中的一个节点，一般只一个进程就是一个 node</p>
<p>shard 分片</p>
<p>分片，即使是一个节点中的数据也会通过 hash 算法，分成多个片存放，默认是</p>
<p>5 片。</p>
<h2 id="index-逻辑数据库"><a href="#index-逻辑数据库" class="headerlink" title="index 逻辑数据库"></a>index 逻辑数据库</h2><p>相当于 rdbms 的 database, 对于用户来说是一个逻辑数据库，虽然物理上会被分</p>
<p>多个 shard 存放，也可能存放在多个 node 中。</p>
<p>type</p>
<p>类似于 rdbms 的 table，但是与其说像 table，其实更像面向对象中的 class , 同一</p>
<p>Json 的格式的数据集合。</p>
<p>document 类似于 rdbms 的 row、面向对象里的 object</p>
<p>field 相当于字段、属性</p>
<p>与 MySQL 对比利用 kibana 学习 elasticsearch restful api (DSL)</p>
<p>Kibana 是一个开源分析和可视化平台，可视化操作 Elasticsearch 。Kibana 可以用来搜索，查看和</p>
<p>与存储在 Elasticsearch 索引中的数据进行交互。可以轻松地进行高级数据分析，并可在各种图表，</p>
<p>表格和地图中显示数据。ES 提供了基于 JSON 的 query DSL 查询语言</p>
<p>es 中保存的数据结构</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">String</span> id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">String</span> name;</span><br><span class="line"></span><br><span class="line">Double doubanScore;</span><br><span class="line"></span><br><span class="line">List&lt;Actor&gt; actorList;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Actor</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">String</span> id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">String</span> name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个对象如果放在关系型数据库保存，会被拆成 2 张表，但是 elasticsearch 是用一个 json 来表示</p>
<p>一个 document。所以它保存到 es 中应该是：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; “<span class="built_in">id</span>”:”<span class="number">1</span>”, “<span class="built_in">name</span>”:”operation red sea”, “doubanScore”:”<span class="number">8.5</span>”, “actorList”:[</span><br><span class="line"></span><br><span class="line">&#123;“<span class="built_in">id</span>”:”<span class="number">1</span>”,”<span class="built_in">name</span>”:”zhangyi”&#125;, &#123;“<span class="built_in">id</span>”:”<span class="number">2</span>”,”<span class="built_in">name</span>”:”haiqing”&#125;, &#123;“<span class="built_in">id</span>”:”<span class="number">3</span>”,”<span class="built_in">name</span>”:”zhanghanyu”&#125;</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>es 的 java 客户端的选择</p>
<p>目前市面上有两类客户端</p>
<p> 一种是 TransportClient 为代表的 ES 原生客户端，不能执行原生 dsl 语句必须使用它的 Java api 方法。</p>
<p> 一种是以 Rest Api 为主的 missing client，最典型的就是 jest。 这种客户端可以直接使用 dsl 语句拼成的字</p>
<p>符串，直接传给服务端，然后返回 json 字符串再解析。 两种方式各有优劣，但是最近 elasticsearch 官网，宣布计划在 7.0 以后的版本中废除 TransportClient。</p>
<p>以 RestClient 为主。在官方的 RestClient 基础上，进行了简单包装的 Jest 客户端，就成了首选，而</p>
<p>且该客户端也与 springboot 完美集成。</p>
<p>中文分词：elasticsearch 本身自带的中文分词，就是单纯把中文一个字一个字的分开，根本没有词</p>
<p>汇的概念。</p>
<p>es 使用的问题：</p>
<p> es 大量的写操作会影响 es 性能，因为 es 需要更新索引，而且 es 不是内存数据库，会做相应的 io 操作。</p>
<p> 而且修改某一个值，在高并发情况下会有冲突，造成更新丢失，需要加锁，而 es 的乐观锁会恶化性能问</p>
<p>题。 解决思路：</p>
<p>用 redis 做精确计数器，redis 是内存数据库读写性能都非常快，利用 redis 的原子性的自增可以解</p>
<p>决并发写操作。redis 每计 100 次数（可以被 100 整除）我们就更新一次 es ，这样写操作就被稀释</p>
<p>了 100 倍，这个倍数可以根据业务情况灵活设定。增量同步索引库</p>
<p>推荐使用 MQ（RabbitMQ）原理：使用 MQ 做增量同步，即当修改数据之后就将此数据发送至 MQ，</p>
<p>由 MQ 将此数据同步到 ES 上</p>
<p>ES 索引中使用了 IK 分词器，你们项目中使用到了分词器的哪种工作模式？</p>
<p>IK 分词器，基本可分为两种模式，一种为 smart 模式，一种为非 smart 模式。</p>
<p>例如：张三说的确实在理</p>
<p> smart 模式的下分词结果为：张三 | 说的 | 确实 | 在理</p>
<p> 非 smart 模式下的分词结果为：张三 | 三 | 说的 | 的确 | 的 | 确实 | 实在 | 在理</p>
<p>区别：</p>
<p> 可见非 smart 模式所做的就是将能够分出来的词全部输出；</p>
<p> smart 模式下，IK 分词器则会根据内在方法输出一个认为最合理的分词结果，这就涉及到了歧义判断。 怎么分词</p>
<p>使用第三方的分词器 IKAnalyzer，会按照中国人用此习惯自动分词。</p>
<p>ES 高亮不能显示的问题</p>
<p>前台使用 angularJS 加载搜索结果，但是发现高亮不能展示。</p>
<p> 问题原因：angularJS 底层使用 ajax，异步加载高亮信息返回给页面后，页面没有刷新，就直接显示返回</p>
<p>的数据。此时会把所有的数据作为普通的文本数据进行加载。因此就没有高亮的效果。</p>
<p> 解决方案：使用 angularJS 过滤器过滤文本数据，此时 angularJS 过滤器把 html 文本数据解析为浏览器能</p>
<p>识别的 html 标签。高亮就能展示了。 简单介绍一下 Es 全文检索在整个系统中的应用，在更新索引库的同时会产生索引碎片，</p>
<p>这个碎片是如何处理的？</p>
<p>根据商品的名称，分类，品牌等属性来创建索引进行商品搜索。更新索引库时会先删除索引，然后</p>
<p>再重建。而对于删除聚集索引，则会导致对应的非聚集索引重建两次(删除时重建，建立时再重建). 直接删除碎片。单点登录</p>
<p>早期单一服务器，用户认证</p>
<p>缺点：单点性能压力，无法扩展</p>
<p>WEB 应用集群，session 共享模式</p>
<p>解决了单点性能瓶颈。</p>
<p>问题：</p>
<p>\1. 多业务分布式数据独立管理，不适合统一维护一份 session 数据。</p>
<p>\2. 分布式按业务功能切分，用户、认证解耦出来单独统一管理。</p>
<p>\3. cookie 中使用 jsessionId 容易被篡改、盗取。</p>
<p>\4. 跨顶级域名无法访问。 分布式，SSO(single sign on)模式解决 ：</p>
<p>\1. 用户身份信息独立管理，更好的分布式管理。</p>
<p>\2. 可以自己扩展安全策略</p>
<p>\3. 跨域不是问题</p>
<p>缺点：</p>
<p>认证服务器访问压力较大。业务流程图</p>
<p>认证中心模块(oauth 认证)</p>
<p>数据库表：user_info，并添加一条数据！密码应该是加密的！</p>
<p>在设计密码加密方式时 一般是使用 MD5+盐的方式进行加密和解密。 登录功能</p>
<p>业务：</p>
<p>\1. 用接受的用户名密码核对后台数据库2. 将用户信息写入 redis，redis 中有该用户视为登录状态。</p>
<p>\3. 用 userId+当前用户登录 ip 地址+密钥生成 token</p>
<p>\4. 重定向用户到之前的来源地址，同时把 token 作为参数附上。 生成 token</p>
<p>JWT（Json Web Token）是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准。JWT</p>
<p>的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器</p>
<p>获取资源。比如用在用户登录。JWT 最重要的作用就是对 token 信息的防伪作用。</p>
<p>JWT 的原理，一个 JWT 由三个部分组成：公共部分、私有部分、签名部分。最后由这三者组合进</p>
<p>行 base64 编码得到 JWT。</p>
<p> 公共部分：主要是该 JWT 的相关配置参数，比如签名的加密算法、格式类型、过期时间等等。</p>
<p> 私有部分：用户自定义的内容，根据实际需要真正要封装的信息。</p>
<p> 签名部分：根据用户信息+盐值+密钥生成的签名。如果想知道 JWT 是否是真实的只要把 JWT 的信息取出</p>
<p>来，加上盐值和服务器中的密钥就可以验证真伪。所以不管由谁保存 JWT，只要没有密钥就无法伪造。 例如:usrInfo+ip=密钥。</p>
<p>base64 编码，并不是加密，只是把明文信息变成了不可见的字符串。但是其实只要用一些工具就</p>
<p>可以吧 base64 编码解成明文，所以不要在 JWT 中放入涉及私密的信息，因为实际上 JWT 并不是加</p>
<p>密信息。 验证功能功能：当业务模块某个页面要检查当前用户是否登录时，提交到认证中心，认证中心进行检查校验，</p>
<p>返回登录状态、用户 Id 和用户名称。</p>
<p>业务：</p>
<p>\1. 利用密钥和 IP 检验 token 是否正确，并获得里面的 userId</p>
<p>\2. 用 userId 检查 Redis 中是否有用户信息,如果有延长它的过期时间。</p>
<p>\3. 登录成功状态返回。 业务模块页面登录情况检查 问题：</p>
<p>\1. 由认证中心签发的 token 如何保存？</p>
<p>\2. 难道每一个模块都要做一个 token 的保存功能？</p>
<p>\3. 如何区分请求是否一定要登录？</p>
<p>回答：</p>
<p> 登录成功后将 token 写到 cookie 中</p>
<p> 加入拦截器：首先这个验证功能是每个模块都要有的，也就是所有 web 模块都需要的。在每个 controller</p>
<p>方法进入前都需要进行检查。可以利用在 springmvc 中的拦截器功能。因为咱们是多个 web 模块分布式</p>
<p>部署的，所以不能写在某一个 web 模块中，可以是一个公共的 web 模块，加入拦截器。</p>
<p> 检验方法是否需要验证用户登录状态：为了方便程序员在 controller 方法上标记，可以借助自定义注解的</p>
<p>方式。比如某个 controller 方法需要验证用户登录，在方法上加入自定义的@LoginRequie。什么是 CAS?</p>
<p>中央认证服务,企业级单点登录解决方案。CAS（Central Authentication Service），是耶鲁大学开发</p>
<p>的单点登录系统（SSO，single sign-on），应用广泛，具有独立于平台的，易于理解，支持代理功</p>
<p>能。CAS 系统在各个大学如耶鲁大学、加州大学、剑桥大学、香港科技大学等得到应用。CAS 的设</p>
<p>计目的：</p>
<p> 为多个 Web 应用提供单点登录基础设施，同时可以为非 Web 应用但拥有 Web 前端的功能服务提供单点</p>
<p>登录的功能；</p>
<p> 简化应用认证用户身份的流程；</p>
<p> 将用户身份认证集中于单一的 Web 应用，让用户简化他们的密码管理，从而提高安全性；而且，当应用</p>
<p>需要修改身份验证的业务逻辑时，不需要到处修改代码。</p>
<p>\1. CAS Server 需要独立部署，主要负责对用户的认证工作；</p>
<p>\2. CAS Client 负责处理对客户端受保护资源的访问请求，需要登录时，重定向到 CAS Server。 单点登录的访问或者跨域问题</p>
<p> 单点登录：单点登录是相互信任的系统模块登录一个模块后，其他模块不需要重复登录即认证通过。项</p>
<p>目采用的是 CAS 单点登录框架完成的。首先 CAS 有两大部分。客户端和服务端。服务端就是一个 web 工</p>
<p>程部署在 tomcat 中。在服务端完成用户认证操作。每次访问系统模块时，需要去 CAS 完成获取 ticket。</p>
<p>当验证通过后，访问继续操作。对于 CAS 服务端来说，我们访问的应用模块就是 CAS 客户端。</p>
<p> 跨域问题：首先明白什么是跨域。什么时候涉及跨域问题。当涉及前端异步请求的时候才涉及跨域。那</p>
<p>什么是跨域呢？当异步请求时，访问的请求地址的协议、ip 地址、端口号任意一个与当前站点不同时，</p>
<p>就会涉及跨域访问。解决方案：1、jQuery 提供了 jsonp 实现 2、W3C 标准提供了 CORS（跨域资源共享）</p>
<p>解决方案。 单点登陆如果在另一台电脑上登陆并修改了密码怎么办？</p>
<p>单点登录系统（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。</p>
<p>SSO 的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。当用</p>
<p>户第一次访问应用系统的时候，因为还没有登录，会被引导到认证系统中进行登录；根据用户提供</p>
<p>的登录信息，认证系统进行身份校验，如果通过校验，应该返回给用户一个认证的凭据 ticket；用</p>
<p>户再访问别的应用的时候，就会将这个 ticket 带上，作为自己认证的凭据，应用系统接受到请求之</p>
<p>后会把 ticket 送到认证系统进行校验，检查 ticket 的合法性。如果通过校验，用户就可以在不用再</p>
<p>次登录的情况下访问应用系统 2 和应用系统 3 了。要实现 SSO，需要以下主要的功能：</p>
<p> 所有应用系统共享一个身份认证系统：认证成功后，认证系统应该生成统一的认证标志（ticket），返还</p>
<p>给用户。另外，认证系统还应该对 ticket 进行效验，判断其有效性。</p>
<p> 所有应用系统能够识别和提取 ticket 信息：要实现 SSO 的功能，让用户只登录一次，就必须让应用系统</p>
<p>能够识别已经登录过的用户。应用系统应该能对 ticket 进行识别和提取，通过与认证系统的通讯，能自</p>
<p>动判断当前用户是否登录过，从而完成单点登录的功能。当用户在另一终端登陆并修改密码，则对应的</p>
<p>ticket 附带的信息会发生改变，导致原有 ticket 因无法通过校验而失效。因此要求用户使用新的密码重新</p>
<p>登陆。锁</p>
<p>什么是死锁，怎么解决死锁，表级锁和行级锁，悲观锁与乐观锁以及线程同步锁区别</p>
<p>死锁：你去面试，面试官问你，你告诉我什么是死锁我就让你进公司。你回答说你让我进公司，我</p>
<p>就告诉你什么是死锁。</p>
<p>死锁产生的原因：</p>
<p> 系统资源的竞争：系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。</p>
<p> 进程运行推进顺序不合适：进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。 死锁的四个必要条件：</p>
<p> 互斥条件：资源不能被共享，只能由一个进程使用。</p>
<p> 请求与保持条件：进程已获得了一些资源，但因请求其它资源被阻塞时，对已获得的资源保持不放。</p>
<p> 不可抢占条件：有些系统资源是不可抢占的，当某个进程已获得这种资源后，系统不能强行收回，只能</p>
<p>由进程使用完时自己释放。</p>
<p> 循环等待条件：若干个进程形成环形链，每个都占用对方申请的下一个资源。 死锁的避免与预防：</p>
<p> 死锁预防：破坏导致死锁必要条件中的任意一个就可以预防死锁。例如，要求用户申请资源时一次性申</p>
<p>请所需要的全部资源，这就破坏了保持和等待条件；将资源分层，得到上一层资源后，才能够申请下一</p>
<p>层资源，它破坏了环路等待条件。预防通常会降低系统的效率。</p>
<p> 死锁避免：避免是指进程在每次申请资源时判断这些操作是否安全，例如，使用银行家算法。死锁避免</p>
<p>算法的执行会增加系统的开销。</p>
<p> 死锁检测：死锁预防和避免都是事前措施，而死锁的检测则是判断系统是否处于死锁状态，如果是，则</p>
<p>执行死锁解除策略。</p>
<p> 死锁解除：这是与死锁检测结合使用的，它使用的方式就是剥夺。即将某进程所拥有的资源强行收回，</p>
<p>分配给其他的进程。 其他锁：</p>
<p> 表级锁： 开销小，加锁快；不会出现死锁(因为 MyISAM 会一次性获得 SQL 所需的全部锁)；锁定粒度大，</p>
<p>发生锁冲突的概率最高,并发度最低。</p>
<p> 行级锁： 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p>
<p> 悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会</p>
<p>上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机</p>
<p>制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized</p>
<p>关键字的实现也是悲观锁。通过 for update 来实现</p>
<p> 乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更</p>
<p>新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读</p>
<p>的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了观锁的一种实现方式 CAS 实现</p>
<p>的。通过 version 版本字段来实现</p>
<p> 同步锁：</p>
<p> 场景：在开发中,遇到耗时的操作,我们需要把耗时的逻辑放入子线程中执行,防止卡顿。二个线程分别执</p>
<p>行两个任务，同时执行完成,同时解析文件,获取数据后,同时插入数据库,由于插入的表比较多，这样容易</p>
<p>出现插入错乱的 bug。 采用 synchronized：</p>
<p>声明该方法为同步方法,如果一个方法正在执行,别的方法调用,则处于等待状态。当这个方法执行完</p>
<p>成后,可以调用解锁方法,wait():释放占有的对象锁，线程进入等待池。</p>
<p>区别：</p>
<p>synchronized 是在 JVM 层面实现的,因此系统可以监控锁的释放与否,而 ReentrantLock 使用代码实现</p>
<p>的,系统无法自动释放锁,需要在代码中 finally 子句中显式释放锁 lock.unlock();在并发量比较小的情</p>
<p>况下，使用 synchronized 是个不错的选择，但是在并发量比较高的情况下，其性能下降很严重，此</p>
<p>时 ReentrantLock 是个不错的方案。</p>
<p>Sql 层面的锁：</p>
<p>一、悲观锁</p>
<p> 排它锁，当事务在操作数据时把这部分数据进行锁定，直到操作完毕后再解锁，其他事务操作才可操作</p>
<p>该部分数据。这将防止其他进程读取或修改表中的数据。</p>
<p> 实现：大多数情况下依靠数据库的锁机制实现 一般使用 select …for update 对所选择的数据进行加锁处理，例如 select * from account where</p>
<p>name=”Max” for update， 这条 sql 语句锁定了 account 表中所有符合检索条件（name=”Max”）的</p>
<p>记录。本次事务提交之前（事务提交时会释放事务过程中的锁），外界无法修改这些记录。</p>
<p>二、乐观锁</p>
<p> 如果有人在你之前更新了，你的更新应当是被拒绝的，可以让用户重新操作。</p>
<p> 实现：大多数基于数据版本（Version）记录机制实现</p>
<p>具体可通过给表加一个版本号或时间戳字段实现，当读取数据时，将 version 字段的值一同读出，</p>
<p>数据每更新一次，对此 version 值加一。当我们提交更新的时候，判断当前版本信息与第一次取出</p>
<p>来的版本值大小，如果数据库表当前版本号与第一次取出来的 version 值相等，则予以更新，否则</p>
<p>认为是过期数据，拒绝更新，让用户重新操作。</p>
<p>代码层面：</p>
<p> 悲观锁：一段执行逻辑加上悲观锁,不同线程同时执行时,只能有一个线程执行,其他的线程在入口处等待, 直到锁被释放.  乐观锁：一段执行逻辑加上乐观锁,不同线程同时执行时,可以同时进入执行,在最后更新数据的时候要检</p>
<p>查这些数据是否被其他线程修改了(版本和执行初是否相同),没有修改则进行更新,否则放弃本次操作。 分布式锁的问题针对分布式锁的实现，目前比较常用的有以下几种方案：</p>
<p> 基于数据库实现分布式锁</p>
<p> 基于缓存（redis，memcached，tair）实现分布式锁</p>
<p> 基于 zookeeper 实现分布式锁</p>
<p>分布式锁（zookeeper，redis，数据库）如何实现</p>
<p>一、基于数据库实现的分布式锁</p>
<p>基于表实现的分布式锁</p>
<p>CREATE TABLE <code>methodLock</code> (</p>
<p><code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘主键’,</p>
<p><code>method_name</code> varchar(64) NOT NULL DEFAULT ‘’ COMMENT ‘锁定的方法名’,</p>
<p><code>desc</code> varchar(1024) NOT NULL DEFAULT ‘备注信息’,</p>
<p><code>update_time</code> timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</p>
<p>COMMENT ‘保存数据时间，自动生成’,</p>
<p>PRIMARY KEY (<code>id</code>),</p>
<p>UNIQUE KEY <code>uidx_method_name</code> (<code>method_name</code>) USING BTREE ) ENGINE=InnoDB DEFAULT</p>
<p>CHARSET=utf8 COMMENT=’锁定中的方法’;</p>
<p>当我们想要锁住某个方法时，执行以下 SQL：</p>
<p>insert into methodLock(method_name,desc) values (‘method_name’,‘desc’)</p>
<p>因为我们对 method_name 做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库</p>
<p>会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以</p>
<p>执行方法体内容。当方法执行完毕之后，想要释放锁的话，需要执行以下 Sql:</p>
<p>delete from methodLock where method_name =’method_name’ 上面这种简单的实现有以下几个问题：</p>
<p> 这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</p>
<p> 这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</p>
<p> 这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不</p>
<p>会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</p>
<p> 这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</p>
<p> 这把锁是非公平锁，所有等待锁的线程凭运气去争夺锁。 当然，我们也可以有其他方式解决上面的问题。</p>
<p> 数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。 没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。</p>
<p> 非阻塞的？搞一个 while 循环，直到 insert 成功再返回成功。</p>
<p> 非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁</p>
<p>的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他</p>
<p>就可以了。</p>
<p> 非公平的？再建一张中间表，将等待锁的线程全记录下来，并根据创建时间排序，只有最先创建的允许</p>
<p>获取锁</p>
<p>基于排他锁实现的分布式锁</p>
<p>除了可以通过增删操作数据表中的记录以外，其实还可以借助数据中自带的锁来实现分布式的锁。</p>
<p>我们还用刚刚创建的那张数据库表。可以通过数据库的排他锁来实现分布式锁。 基于 MySql 的</p>
<p>InnoDB 引擎，可以使用以下方法来实现加锁操作：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">boolean</span> <span class="keyword">lock</span>()&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">connection</span>.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">try&#123;</span><br><span class="line"></span><br><span class="line">result = <span class="keyword">select</span> * <span class="keyword">from</span> methodLock <span class="keyword">where</span> method_name=xxx <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result==<span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;catch(<span class="keyword">Exception</span> e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在查询语句后面增加 for update，数据库会在查询过程中给数据库表增加排他锁。当某条记录被加</p>
<p>上排他锁之后，其他线程无法再在该行记录上增加排他锁。我们可以认为获得排它锁的线程即可获</p>
<p>得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，再通过以下方法解锁：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> unlock()&#123; <span class="keyword">connection</span>.<span class="keyword">commit</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p>通过 connection.commit();操作来释放锁。这种方法可以有效的解决上面提到的无法释放锁和阻塞</p>
<p>锁的问题。</p>
<p>问题：</p>
<p> 阻塞锁？ for update 语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。</p>
<p> 锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。但是还是无法</p>
<p>直接解决数据库单点、可重入和公平锁的问题。总结一下使用数据库来实现分布式锁的方式，这两种方</p>
<p>式都是依赖数据库的一张表，一种是通过表中的记录的存在情况确定当前是否有锁存在，另外一种是通</p>
<p>过数据库的排他锁来实现分布式锁。数据库实现分布式锁的优点：直接借助数据库</p>
<p>数据库实现分布式锁的缺点：</p>
<p> 会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。</p>
<p> 操作数据库需要一定的开销，性能问题需要考虑。 二、基于缓存的分布式锁</p>
<p>相比较于基于数据库实现分布式锁的方案来说，基于缓存来实现在性能方面会表现的更好一点。目</p>
<p>前有很多成熟的缓存产品，包括 Redis，memcached 等。这里以 Redis 为例来分析下使用缓存实现</p>
<p>分布式锁的方案。基于 Redis 实现分布式锁在网上有很多相关文章，其中主要的实现方式是使用</p>
<p>Jedis.setNX 方法来实现。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> trylock(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</span><br><span class="line"></span><br><span class="line">ResultCode code = jedis.setNX(<span class="built_in">key</span>, <span class="string">"This is a Lock."</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ResultCode.SUCCESS.equals(code))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> unlock(<span class="keyword">String</span> <span class="built_in">key</span>)&#123;</span><br><span class="line"></span><br><span class="line">ldbTairManager.invalid(NAMESPACE, <span class="built_in">key</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实现方式同样存在几个问题：</p>
<p> 单点问题。</p>
<p> 这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在 redis 中，其他线程无法再获得到锁。</p>
<p> 这把锁只能是非阻塞的，无论成功还是失败都直接返回。</p>
<p> 这把锁是非重入的，一个线程获得锁之后，在释放锁之前，无法再次获得该锁，因为使用到的 key 在 redis</p>
<p>中已经存在。无法再执行 setNX 操作。</p>
<p> 这把锁是非公平的，所有等待的线程同时去发起 setNX 操作，运气好的线程能获取锁。 当然，同样有方式可以解决。现在主流的缓存服务都支持集群部署，通过集群来解决单点问题。</p>
<p> 没有失效时间？redis 的 setExpire 方法支持传入失效时间，到达时间之后数据会自动删除。</p>
<p> 非阻塞？while 重复执行。</p>
<p> 非可重入？在一个线程获取到锁之后，把当前主机信息和线程信息保存起来，下次再获取之前先检查自</p>
<p>己是不是当前锁的拥有者。</p>
<p> 非公平？在线程获取锁之前先把所有等待的线程放入一个队列中，然后按先进先出原则获取锁。</p>
<p>redis 集群的同步策略是需要时间的，有可能 A 线程 setNX 成功后拿到锁，但是这个值还没有更新</p>
<p>到 B 线程执行 setNX 的这台服务器，那就会产生并发问题。redis 的作者 Salvatore Sanfilippo，提出</p>
<p>了 Redlock 算法，该算法实现了比单一节点更安全、可靠的分布式锁管理（DLM）。Redlock 算法</p>
<p>假设有 N 个 redis 节点，这些节点互相独立，一般设置为 N=5，这 N 个节点运行在不同的机器上以</p>
<p>保持物理层面的独立。算法的步骤如下：</p>
<p> 客户端获取当前时间，以毫秒为单位。</p>
<p> 客户端尝试获取 N 个节点的锁，（每个节点获取锁的方式和前面说的缓存锁一样），N 个节点以相同的</p>
<p>key 和 value 获取锁。客户端需要设置接口访问超时，接口超时时间需要远远小于锁超时时间，比如锁自</p>
<p>动释放的时间是 10s，那么接口超时大概设置 5-50ms。这样可以在有 redis 节点宕机后，访问该节点时能</p>
<p>尽快超时，而减小锁的正常使用。</p>
<p> 客户端计算在获得锁的时候花费了多少时间，方法是用当前时间减去在步骤一获取的时间，只有客户端</p>
<p>获得了超过 3 个节点的锁，而且获取锁的时间小于锁的超时时间，客户端才获得了分布式锁。</p>
<p> 客户端获取的锁的时间为设置的锁超时时间减去步骤三计算出的获取锁花费时间。</p>
<p> 如果客户端获取锁失败了，客户端会依次删除所有的锁。 使用 Redlock 算法，可以保证在挂掉最多 2 个</p>
<p>节点的时候，分布式锁服务仍然能工作，这相比之前的数据库锁和缓存锁大大提高了可用性，由于 redis</p>
<p>的高效性能，分布式缓存锁性能并不比数据库锁差。 但是，有一位分布式的专家写了一篇文章《How to do distributed locking》，质疑 Redlock 的正确性。</p>
<p>该专家提到，考虑分布式锁的时候需要考虑两个方面：性能和正确性。如果使用高性能的分布式锁，</p>
<p>对正确性要求不高的场景下，那么使用缓存锁就足够了。如果使用可靠性高的分布式锁，那么就需</p>
<p>要考虑严格的可靠性问题。而 Redlock 则不符合正确性。为什么不符合呢？专家列举了几个方面。</p>
<p>现在很多编程语言使用的虚拟机都有 GC 功能，在 Full GC 的时候，程序会停下来处理 GC，有些时</p>
<p>候 Full GC 耗时很长，甚至程序有几分钟的卡顿，文章列举了 HBase 的例子，HBase 有时候 GC 几分</p>
<p>钟，会导致租约超时。而且 Full GC 什么时候到来，程序无法掌控，程序的任何时候都可能停下来</p>
<p>处理 GC，比如下图，客户端 1 获得了锁，正准备处理共享资源的时候，发生了 Full GC 直到锁过期。</p>
<p>这样，客户端 2 又获得了锁，开始处理共享资源。在客户端 2 处理的时候，客户端 1 Full GC 完成，</p>
<p>也开始处理共享资源，这样就出现了 2 个客户端都在处理共享资源的情况。给锁带上 token，token</p>
<p>就是 version 的概念，每次操作锁完成，token 都会加 1，在处理共享资源的时候带上 token，只有</p>
<p>指定版本的 token 能够处理共享资源。</p>
<p>使用缓存实现分布式锁：</p>
<p> 优点：性能好。</p>
<p> 缺点：实现过于负责，需要考虑的因素太多。 基于 Zookeeper 实现的分布式锁</p>
<p>基于 zookeeper 临时有序节点可以实现的分布式锁。大致思想即为：每个客户端对某个方法加锁时，</p>
<p>在 zookeeper 上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否</p>
<p>获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬</p>
<p>时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。来看下</p>
<p>Zookeeper 能不能解决前面提到的问题。</p>
<p> 锁无法释放？使用 Zookeeper 可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在 ZK</p>
<p>中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session 连接断开），那么这个临时节点就会</p>
<p>自动删除掉。其他客户端就可以再次获得锁。</p>
<p> 非阻塞锁？使用 Zookeeper 可以实现阻塞的锁，客户端可以通过在 ZK 中创建顺序节点，并且在节点上绑</p>
<p>定监听器，一旦节点有变化，Zookeeper 会通知客户端，客户端可以检查自己创建的节点是不是当前所有</p>
<p>节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。</p>
<p> 不可重入？使用 Zookeeper 也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户</p>
<p>端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节</p>
<p>点，参与排队。</p>
<p> 单点问题？使用 Zookeeper 可以有效的解决单点问题，ZK 是集群部署的，只要集群中有半数以上的机器</p>
<p>存活，就可以对外提供服务。</p>
<p> 公平问题？使用 Zookeeper 可以解决公平锁问题，客户端在 ZK 中创建的临时节点是有序的，每次锁被释</p>
<p>放时，ZK 可以通知最小节点来获取锁，保证了公平。 问题又来了，我们知道 Zookeeper 需要集群部署，会不会出现 Redis 集群那样的数据同步问题呢？</p>
<p>Zookeeper 是一个保证了弱一致性即最终一致性的分布式组件。采用称为 Quorum Based Protocol</p>
<p>的数据同步协议。假如 Zookeeper 集群有 N 台 Zookeeper 服务器(N 通常取奇数，3 台能够满足数据</p>
<p>可靠性同时有很高读写性能，5 台在数据可靠性和读写性能方面平衡最好)，那么用户的一个写操</p>
<p>作，首先同步到 N/2 + 1 台服务器上，然后返回给用户，提示用户写成功。基于 Quorum Based Protocol</p>
<p>的数据同步协议决定了 Zookeeper 能够支持什么强度的一致性。在分布式环境下，满足强一致性的</p>
<p>数据储存基本不存在，它要求在更新一个节点的数据，需要同步更新所有的节点。这种同步策略出</p>
<p>现在主从同步复制的数据库中。但是这种同步策略，对写性能的影响太大而很少见于实践。因为</p>
<p>Zookeeper 是同步写 N/2+1 个节点，还有 N/2 个节点没有同步更新，所以 Zookeeper 不是强一致性</p>
<p>的。用户的数据更新操作，不保证后续的读操作能够读到更新后的值，但是最终会呈现一致性。牺</p>
<p>牲一致性，并不是完全不管数据的一致性，否则数据是混乱的，那么系统可用性再高分布式再好也</p>
<p>没有了价值。牺牲一致性，只是不再要求关系型数据库中的强一致性，而是只要系统能达到最终一</p>
<p>致性即可。</p>
<p>Zookeeper 是否满足因果一致性，需要看客户端的编程方式。</p>
<p>不满足因果一致性的做法</p>
<p> A 进程向 Zookeeper 的/z 写入一个数据，成功返回</p>
<p> A 进程通知 B 进程，A 已经修改了/z 的数据</p>
<p> B 读取 Zookeeper 的/z 的数据</p>
<p> 由于 B 连接的 Zookeeper 的服务器有可能还没有得到 A 写入数据的更新，那么 B 将读不到 A 写入的数据</p>
<p>满足因果一致性的做法</p>
<p> B 进程监听 Zookeeper 上/z 的数据变化</p>
<p> A 进程向 Zookeeper 的/z 写入一个数据，成功返回前，Zookeeper 需要调用注册在/z 上的监听器，Leader</p>
<p>将数据变化的通知告诉 B</p>
<p> B 进程的事件响应方法得到响应后，去取变化的数据，那么 B 一定能够得到变化的值</p>
<p> 这里的因果一致性提现在 Leader 和 B 之间的因果一致性，也就是是 Leader 通知了数据有变化，第二种事</p>
<p>件监听机制也是对 Zookeeper 进行正确编程应该使用的方法，所以，Zookeeper 应该是满足因果一致性的，</p>
<p>所以我们在基于 Zookeeper 实现分布式锁的时候，应该使用满足因果一致性的做法，即等待锁的线程都</p>
<p>监听 Zookeeper 上锁的变化，在锁被释放的时候，Zookeeper 会将锁变化的通知告诉满足公平锁条件的等</p>
<p>待线程。可以直接使用 zookeeper 第三方库客户端，这个客户端中封装了一个可重入的锁服务</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/20/java%E5%AD%97%E7%AC%A6%E8%B0%9C%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/20/java%E5%AD%97%E7%AC%A6%E8%B0%9C%E9%A2%98/" class="post-title-link" itemprop="url">java字符谜题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-20 19:15:36 / 修改时间：22:27:59" itemprop="dateCreated datePublished" datetime="2021-03-20T19:15:36+08:00">2021-03-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java-谜题-Java-谜题-2——字符谜题"><a href="#Java-谜题-Java-谜题-2——字符谜题" class="headerlink" title="Java 谜题 Java 谜题 2——字符谜题"></a>Java 谜题 Java 谜题 2——字符谜题</h1><h2 id="谜题-11：最后的笑声"><a href="#谜题-11：最后的笑声" class="headerlink" title="谜题 11：最后的笑声"></a>谜题 11：最后的笑声</h2><p>下面的程序将打印出什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LastLaugh</span>&#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">print</span>(<span class="string">"H"</span>+<span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">print</span>(<span class="string">'H'</span>+<span class="string">'a'</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能会认为这个程序将打印 HaHa。该程序看起来好像是用两种方式连接了 H</p>
<p>和 a，但是你所见为虚。如果你运行这个程序，就会发现它打印的是 Ha169。那</p>
<p>么，为什么它会产生这样的行为呢？ </p>
<p>正如我们所期望的，第一个对 System.out.print 的调用打印的是 Ha：它的参数</p>
<p>是表达式”H”+”a”，显然它执行的是一个字符串连接。而第二个对</p>
<p>System.out.print 的调用就是另外一回事了。问题在于’H’和’a’是字符型字面</p>
<p>常量，因为这两个操作数都不是字符串类型的，所以 + 操作符执行的是加法而</p>
<p>不是字符串连接。</p>
<p>编译器在计算常量表达式’H’+’a’时，是通过我们熟知的拓宽原始类型转换将两</p>
<p>个具有字符型数值的操作数（’H’和’a’）提升为 int 数值而实现的。从 char 到</p>
<p>int 的拓宽原始类型转换是将 16 位的 char 数值零扩展到 32 位的 int。对于’H’，</p>
<p>char 数值是 72，而对于’a’，char 数值是 97，因此表达式’H’+’a’等价于 int</p>
<p>常量 72 + 97，或 169。 </p>
<p>站在语言的立场上，若干个 char 和字符串的相似之处是虚幻的。语言所关心的</p>
<p>是，char 是一个无符号 16 位原始类型整数——仅此而已。对类库来说就不尽如</p>
<p>此了，类库包含了许多可以接受 char 参数，并将其作为 Unicode 字符处理的方</p>
<p>法。 </p>
<p>那么你应该怎样将字符连接在一起呢？你可以使用这些类库。例如，你可以使用</p>
<p>一个字符串缓冲区： </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="built_in">new</span> StringBuffer(); </span><br><span class="line"></span><br><span class="line">sb.<span class="built_in">append</span>(<span class="string">'H'</span>); </span><br><span class="line"></span><br><span class="line">sb.<span class="built_in">append</span>(<span class="string">'a'</span>); </span><br><span class="line"></span><br><span class="line">System.out.<span class="built_in">println</span>(sb); 这么做可以正常运行，但是显得很丑陋。其实我们还是有办法去避免这种方式所</span><br></pre></td></tr></table></figure>

<p>产生的拖沓冗长的代码。 你可以通过确保至少有一个操作数为字符串类型，来</p>
<p>强制 + 操作符去执行一个字符串连接操作，而不是一个加法操作。这种常见的</p>
<p>惯用法用一个空字符串（””）作为一个连接序列的开始，如下所示： </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println("" + <span class="string">'H'</span> + <span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>

<p>这种惯用法可以确保子表达式都被转型为字符串。尽管这很有用，但是多少有一</p>
<p>点难看，而且它自身可能会引发某些混淆。你能猜到下面的语句将会打印出什么</p>
<p>吗？如果你不能确定，那么就试一下： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.<span class="keyword">out</span>.print(<span class="string">"2 + 2 = "</span> + <span class="number">2</span>+<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>如果使用的是 JDK 5.0，你还可以使用</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(<span class="string">"%c%c"</span>, <span class="string">'H'</span>, <span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>

<p>总之，使用字符串连接操作符使用格外小心。+ 操作符当且仅当它的操作数中至</p>
<p>少有一个是 String 类型时，才会执行字符串连接操作；否则，它执行的就是加</p>
<p>法。如果要连接的没有一个数值是字符串类型的，那么你可以有几种选择： </p>
<p>• 预置一个空字符串； </p>
<p>• 将第一个数值用 String.valueOf 显式地转换成一个字符串； </p>
<p>• 使用一个字符串缓冲区； </p>
<p>• 或者如果你使用的 JDK 5.0，可以用 printf 方法。 </p>
<p>这个谜题还包含了一个给语言设计者的教训。操作符重载，即使在 Java 中只在</p>
<p>有限的范围内得到了支持，它仍然会引起混淆。为字符串连接而重载 + 操作符</p>
<p>可能就是一个已铸成的错误。 </p>
<h2 id="谜题-12：ABC"><a href="#谜题-12：ABC" class="headerlink" title="谜题 12：ABC"></a>谜题 12：ABC</h2><p>这个谜题要问的是一个悦耳的问题，下面的程序将打印什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABC</span>&#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">String</span> letters = <span class="string">"ABC"</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">char</span>[] numbers = &#123;<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>&#125;; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(letters + <span class="string">" easy as "</span> + numbers); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能大家希望这个程序打印出 ABC easy as 123。遗憾的是，它没有。如果你运</p>
<p>行它，就会发现它打印的是诸如 ABC easy as [C@16f0472 之类的东西。为什么</p>
<p>这个输出会如此丑陋？ 尽管 char 是一个整数类型，但是许多类库都对其进行了特殊处理，因为 char</p>
<p>数值通常表示的是字符而不是整数。例如，将一个 char 数值传递给 println 方</p>
<p>法会打印出一个 Unicode 字符而不是它的数字代码。字符数组受到了相同的特殊</p>
<p>处理：println 的 char[]重载版本会打印出数组所包含的所有字符，而</p>
<p>String.valueOf和StringBuffer.append的 char[]重载版本的行为也是类似的。 </p>
<p>然而，字符串连接操作符在这些方法中没有被定义。该操作符被定义为先对它的</p>
<p>两个操作数执行字符串转换，然后将产生的两个字符串连接到一起。对包括数组</p>
<p>在内的对象引用的字符串转换定义如下[JLS 15.18.1.1]： </p>
<p>如果引用为 null，它将被转换成字符串”null”。否则，该转换的执行就像是不</p>
<p>用任何参数调用该引用对象的 toString 方法一样；但是如果调用 toString 方法</p>
<p>的结果是 null，那么就用字符串”null”来代替。 </p>
<p>那么，在一个非空 char 数组上面调用 toString 方法会产生什么样的行为呢？数</p>
<p>组是从 Object 那里继承的 toString 方法[JLS 10.7]，规范中描述到：“返回一</p>
<p>个字符串，它包含了该对象所属类的名字，‘@’符号，以及表示对象散列码的一</p>
<p>个无符号十六进制整数”[Java-API]。有关 Class.getName 的规范描述到：在</p>
<p>char[]类型的类对象上调用该方法的结果为字符串”[C”。将它们连接到一起就形</p>
<p>成了在我们的程序中打印出来的那个丑陋的字符串。 </p>
<p>有两种方法可以订正这个程序。你可以在调用字符串连接操作之前，显式地将一</p>
<p>个数组转换成一个字符串： </p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(letters + <span class="string">" easy as "</span> + </span><br><span class="line"></span><br><span class="line"> <span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">numbers</span>)</span>);</span><br></pre></td></tr></table></figure>

<p>或者，你可以将 System.out.println 调用分解为两个调用，以利用 println 的</p>
<p>char[]重载版本： </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.print(letters + " easy as "); </span><br><span class="line"></span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(numbers);</span><br></pre></td></tr></table></figure>

<p>请注意，这些订正只有在你调用了 valueOf 和 println 方法正确的重载版本的情</p>
<p>况下，才能正常运行。换句话说，它们严格依赖于数组引用的编译期类型。 </p>
<p>下面的程序说明了这种依赖性。看起来它像是所描述的第二种订正方式的具体实</p>
<p>现，但是它产生的输出却与最初的程序所产生的输出一样丑陋，因为它调用的是</p>
<p>println 的 Object 重载版本，而不是 char[]重载版本。 </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ABC2</span>&#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">String</span> letters = <span class="string">"ABC"</span>; </span><br><span class="line"></span><br><span class="line"> Object numbers = <span class="keyword">new</span> <span class="keyword">char</span>[] &#123; <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span> &#125;;</span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">print</span>(letters + <span class="string">" easy as "</span>); </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(numbers); </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>} 总之，char 数组不是字符串。要想将一个 char 数组转换成一个字符串，就要调</p>
<p>用 String.valueOf(char[])方法。某些类库中的方法提供了对 char 数组的类似</p>
<p>字符串的支持，通常是提供一个 Object 版本的重载方法和一个 char[]版本的重</p>
<p>载方法，而之后后者才能产生我们想要的行为。 </p>
<p>对语言设计者的教训是：char[]类型可能应该覆写 toString 方法，使其返回数</p>
<p>组中包含的字符。更一般地讲，数组类型可能都应该覆写 toString 方法，使其</p>
<p>返回数组内容的一个字符串表示。 </p>
<h2 id="谜题-13：畜牧场"><a href="#谜题-13：畜牧场" class="headerlink" title="谜题 13：畜牧场"></a>谜题 13：畜牧场</h2><p>George Orwell 的《畜牧场（Animal Farm）》一书的读者可能还记得老上校的</p>
<p>宣言：“所有的动物都是平等的。”下面的 Java 程序试图要测试这项宣言。那</p>
<p>么，它将打印出什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalFarm</span>&#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">String</span> pig = <span class="string">"length: 10"</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">String</span> dog = <span class="string">"length: "</span> + pig.length(); </span><br><span class="line"></span><br><span class="line"> System.out. <span class="built_in">println</span>(<span class="string">"Animals are equal: "</span></span><br><span class="line"></span><br><span class="line"> + pig == dog); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对该程序的表面分析可能会认为它应该打印出 Animal are equal: true。毕竟，</p>
<p>pig和 dog都是final的 string类型变量，它们都被初始化为字符序列“length:</p>
<p>10”。换句话说，被 pig 和 dog 引用的字符串是且永远是彼此相等的。然而，==</p>
<p>操作符测试的是这两个对象引用是否正好引用到了相同的对象上。在本例中，它</p>
<p>们并非引用到了相同的对象上。 </p>
<p>你可能知道 String 类型的编译期常量是内存限定的。换句话说，任何两个 String</p>
<p>类型的常量表达式，如果标明的是相同的字符序列，那么它们就用相同的对象引</p>
<p>用来表示。如果用常量表达式来初始化 pig 和 dog，那么它们确实会指向相同的</p>
<p>对象，但是 dog 并不是用常量表达式初始化的。既然语言已经对在常量表达式中</p>
<p>允许出现的操作作出了限制，而方法调用又不在其中，那么，这个程序就应该打</p>
<p>印 Animal are equal: false，对吗？ </p>
<p>嗯，实际上不对。如果你运行该程序，你就会发现它打印的只是 false，并没有</p>
<p>其它的任何东西。它没有打印 Animal are equal: 。它怎么会不打印这个字符</p>
<p>串字面常量呢？毕竟打印它才是正确的呀！谜题 11 的解谜方案包含了一条暗示：</p>
<p>+ 操作符，不论是用作加法还是字符串连接操作，它都比 == 操作符的优先级高。</p>
<p>因此，println 方法的参数是按照下面的方式计算的： </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(("Animals are equal: " + pig) == dog);</span><br></pre></td></tr></table></figure>

<p>这个布尔表达式的值当然是 false，它正是该程序的所打印的输出。 有一个肯定能够避免此类窘境的方法：在使用字符串连接操作符时，总是将非平</p>
<p>凡的操作数用括号括起来。更一般地讲，当你不能确定你是否需要括号时，应该</p>
<p>选择稳妥地做法，将它们括起来。如果你在 println 语句中像下面这样把比较部</p>
<p>分括起来，它将产生所期望的输出 Animals are equal: false ： </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println("Animals are equal: " + (pig == dog));</span><br></pre></td></tr></table></figure>

<p>可以论证，该程序仍然有问题。 </p>
<p>如果可以的话，你的代码不应该依赖于字符串常量的内存限定机制。内存限定机</p>
<p>制只是设计用来减少虚拟机内存占有量的，它并不是作为程序员可以使用的一种</p>
<p>工具而设计的。就像这个谜题所展示的，哪一个表达式会产生字符串常量并非总</p>
<p>是很显而易见。 </p>
<p>更糟的是，如果你的代码依赖于内存限定机制实现操作的正确性，那么你就必须</p>
<p>仔细地了解哪些域和参数必定是内存限定的。编译器不会帮你去检查这些不变</p>
<p>量，因为内存限定的和不限定的字符串使用相同的类型（String）来表示的。这</p>
<p>些因在内存中限定字符串失败而导致的 bug 是非常难以探测到的。 </p>
<p>在比较对象引用时，你应该优先使用 equals 方法而不是 == 操作符，除非你需</p>
<p>要比较的是对象的标识而不是对象的值。通过把这个教训应用到我们的程序中，</p>
<p>我们给出了下面的 println 语句，这才是它应该具有的模样。很明显，在用这种</p>
<p>方式订正了该程序之后，它将打印出 true： </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"Animals are equal: "</span> + pig.<span class="keyword">equals</span>(dog));</span><br></pre></td></tr></table></figure>

<p>这个谜题对语言设计者来说有两个教训。 </p>
<p>• 字符串连接的优先级不应该和加法一样。这意味着重载 + 操作符来执行</p>
<p>字符串连接是有问题的，就像在谜题 11 中提到的一样。 </p>
<p>• 还有就是，对于不可修改的类型，例如 String，其引用的等价性比值的</p>
<p>等价性更加让人感到迷惑。也许 == 操作符在被应用于不可修改的类型时</p>
<p>应该执行值比较。要实现这一点，一种方法是将 == 操作符作为 equals</p>
<p>方法的简便写法，并提供一个单独的类似于 System.identityHashCode</p>
<p>的方法来执行引用标识的比较。 </p>
<h2 id="谜题-14：转义字符的溃败-转义字符的溃败"><a href="#谜题-14：转义字符的溃败-转义字符的溃败" class="headerlink" title="谜题 14：转义字符的溃败 转义字符的溃败"></a>谜题 14：转义字符的溃败 转义字符的溃败</h2><p>下面的程序使用了两个 Unicode 的转义字符，它们是用其十六进制代码来表示</p>
<p>Unicode 字符。那么，这个程序会打印什么呢？ </p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> EscapeRout&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args)&#123; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// \u0022 是双引号的 Unicode 转义字符</span></span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println(<span class="string">"a\u0022.length() </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">+\u0022b"</span>.length()); </span><br><span class="line"></span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>对该程序的一种很肤浅的分析会认为它应该打印出 26，因为在由两个双引号</p>
<p>“a\u0022.length()+\u0022b”标识的字符串之间总共有 26 个字符。 </p>
<p>稍微深入一点的分析会认为该程序应该打印 16，因为两个 Unicode 转义字符每</p>
<p>一个在源文件中都需要用 6 个字符来表示，但是它们只表示字符串中的一个字</p>
<p>符。因此这个字符串应该比它的外表看其来要短 10 个字符。 如果你运行这个程</p>
<p>序，就会发现事情远不是这么回事。它打印的既不是 26 也不是 16，而是 2。 </p>
<p>理解这个谜题的关键是要知道：Java 对在字符串字面常量中的 Unicode 转义字</p>
<p>符没有提供任何特殊处理。编译器在将程序解析成各种符号之前，先将 Unicode</p>
<p>转义字符转换成为它们所表示的字符[JLS 3.2]。因此，程序中的第一个 Unicode</p>
<p>转义字符将作为一个单字符字符串字面常量（”a”）的结束引号，而第二个</p>
<p>Unicode 转义字符将作为另一个单字符字符串字面常量（”b”）的开始引号。程</p>
<p>序打印的是表达式”a”.length()+”b”.length()，即 2。 </p>
<p>如果该程序的作者确实希望得到这种行为，那么下面的语句将要清楚得多： </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println("a".length()+"b".length());</span><br></pre></td></tr></table></figure>

<p>更有可能的情况是该作者希望将两个双引号字符置于字符串字面常量的内部。使</p>
<p>用 Unicode 转义字符你是不能实现这一点的，但是你可以使用转义字符序列来实</p>
<p>现[JLS 3.10.6]。表示一个双引号的转义字符序列是一个反斜杠后面紧跟着一个</p>
<p>双引号（\”）。如果将最初的程序中的 Unicode 转义字符用转义字符序列来替</p>
<p>换，那么它将打印出所期望的 16： </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println("a\".length()+\"b".length());</span><br></pre></td></tr></table></figure>

<p>许多字符都有相应的转义字符序列，包括单引号（&#39;）、换行（\n）、制表符（\t）</p>
<p>和反斜线（\）。你可以在字符字面常量和字符串字面常量中使用转义字符序列。 </p>
<p>实际上，你可以通过使用被称为八进制转义字符的特殊类型的转义字符序列，将</p>
<p>任何 ASCII 字符置于一个字符串字面常量或一个字符字面常量中，但是最好是尽</p>
<p>可能地使用普通的转义字符序列。 </p>
<p>普通的转义字符序列和八进制转义字符都比 Unicode 转义字符要好得多，因为与</p>
<p>Unicode 转义字符不同，转义字符序列是在程序被解析为各种符号之后被处理</p>
<p>的。 </p>
<p>ASCII 是字符集的最小公共特性集，它只有 128 个字符，但是 Unicode 有超过</p>
<p>65,000 个字符。一个 Unicode 转义字符可以被用来在只使用 ASCII 字符的程序</p>
<p>中插入一个Unicode字符。一个Unicode转义字符精确地等价于它所表示的字符。 </p>
<p>Unicode 转义字符被设计为用于在程序员需要插入一个不能用源文件字符集表</p>
<p>示的字符的情况。它们主要用于将非 ASCII 字符置于标识符、字符串字面常量、</p>
<p>字符字面常量以及注释中。偶尔地，Unicode 转义字符也被用来在看起来颇为相</p>
<p>似的数个字符中明确地标识其中的某一个，从而增加程序的清晰度。 总之，在字符串和字符字面常量中要优先选择的是转义字符序列，而不是</p>
<p>Unicode 转义字符。Unicode 转义字符可能会因为它们在编译序列中被处理得过</p>
<p>早而引起混乱。不要使用 Unicode 转义字符来表示 ASCII 字符。在字符串和字符</p>
<p>字面常量中，应该使用转义字符序列；对于除这些字面常量之外的情况，应该直</p>
<p>接将 ASCII 字符插入到源文件中。 </p>
<h2 id="谜题-15：令人晕头转向的-令人晕头转向的-Hello"><a href="#谜题-15：令人晕头转向的-令人晕头转向的-Hello" class="headerlink" title="谜题 15：令人晕头转向的 令人晕头转向的 Hello"></a>谜题 15：令人晕头转向的 令人晕头转向的 Hello</h2><p>下面的程序是对一个老生常谈的例子做出了稍许的变化之后的版本。那么，它会</p>
<p>打印出什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> \* Generated by the IBM IDL-to-Java compiler, version 1.0 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> \* from F:\TestRoot\apps\a1\units\include\PolicyHome.idl </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> \* Wednesday, June 17, 1998 6:44:40 o’clock AM GMT+00:00 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">print</span>(<span class="string">"Hell"</span>); </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"o world"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个谜题看起来相当简单。该程序包含了两条语句，第一条打印 Hell，而第二</p>
<p>条在同一行打印 o world，从而将两个字符串有效地连接在了一起。因此，你可</p>
<p>能期望该程序打印出 Hello world。但是很可惜，你犯了错，实际上，它根本就</p>
<p>通不过编译。 </p>
<p>问题在于注释的第三行，它包含了字符\units。这些字符以反斜杠（\）以及紧</p>
<p>跟着的字母 u 开头的，而它（\u）表示的是一个 Unicode 转义字符的开始。遗憾</p>
<p>的是，这些字符后面没有紧跟四个十六进制的数字，因此，这个 Unicode 转义字</p>
<p>符是病构的，而编译器则被要求拒绝该程序。Unicode 转义字符必须是良构的，</p>
<p>即使是出现在注释中也是如此。 </p>
<p>在注释中插入一个良构的 Unicode 转义字符是合法的，但是我们几乎没有什么理</p>
<p>由去这么做。程序员有时会在 JavaDoc 注释中使用 Unicode 转义字符来在文档中</p>
<p>生成特殊的字符。 </p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unicode 转义字符在 JavaDoc 注释中有问题的用法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> \* This method calls itself recursively, causing a </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> \* StackOverflowError to be thrown. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> \* The algorithm is due to Peter von der Ah\u00E9. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>这项技术表示了Unicode转义字符的一种没什么用处的用法。在 Javadoc注释中，</p>
<p>应该使用 HTML 实体转义字符来代替 Unicode 转义字符：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"></span><br><span class="line">\* This method calls itself recursively, causing <span class="keyword">a</span> </span><br><span class="line"></span><br><span class="line">\* StackOverflowError <span class="keyword">to</span> <span class="keyword">be</span> thrown. </span><br><span class="line"></span><br><span class="line">\* The algorithm <span class="keyword">is</span> due <span class="keyword">to</span> Peter von der Ahé. </span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>前面的两个注释都应该是的在文档中出现的名字为“Peter der Ahé”，但是后</p>
<p>一个注释在源文件中还是可理解的。 </p>
<p>可能你会感到很诧异，在这个谜题中，问题出在注释这一信息来源自一个实际的</p>
<p>bug 报告。该程序是机器生成的，这使得我们很难追踪到问题的源头</p>
<p>——IDL-to-Java 编译器。为了避免让其他程序员也陷入此境地，在没有将</p>
<p>Windows 文件名进行预先处理，以消除的其中的反斜杠的情况下，工具应该确保</p>
<p>不将 Windows 文件名置于所生成的 Java 源文件的注释中。 </p>
<p>总之，要确保字符\u 不出现在一个合法的 Unicode 转义字符上下文之外，即使</p>
<p>是在注释中也是如此。在机器生成的代码中要特别注意此问题。 </p>
<h2 id="谜题-16：行打印程序"><a href="#谜题-16：行打印程序" class="headerlink" title="谜题 16：行打印程序"></a>谜题 16：行打印程序</h2><p>行分隔符（line separator）是为用来分隔文本行的字符或字符组合而起的名字，</p>
<p>并且它在不同的平台上是存在差异的。在 Windows 平台上，它是 CR 字符（回车）</p>
<p>和紧随其后的 LF 字符（换行）组成的，而在 UNIX 平台上，通常单独的 LF 字符</p>
<p>被当作换行字符来引用。下面的程序将这个字符传递给了 println 方法，那么，</p>
<p>它将打印出什么呢？它的行为是否是依赖于平台的呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinePrinter</span>&#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// Note: \u000A is Unicode representation of linefeed (LF) </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">char</span> c = <span class="number">0x000A</span>; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(c); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序的行为是平台无关的：它在任何平台上都不能通过编译。如果你尝试着</p>
<p>去编译它，就会得到类似下面的出错信息： </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">LinePrinter.java:3</span>: ';' expected </span><br><span class="line"></span><br><span class="line">// Note: \u000A is Unicode representation of linefeed (LF) </span><br><span class="line"></span><br><span class="line">^</span><br><span class="line"></span><br><span class="line">1 error</span><br></pre></td></tr></table></figure>

<p>如果你和大多数人一样，那么这条信息对界定问题是毫无用处的。 </p>
<p>这个谜题的关键就是程序第三行的注释。与最好的注释一样，这条注释也是一种</p>
<p>准确的表达，遗憾的是，它有一点准确得过头了。编译器不仅会在将程序解析成</p>
<p>为符号之前把 Unicode 转义字符转换成它们所表示的字符（谜题 14），而且它</p>
<p>是在丢弃注释和空格之前做这些事的[JLS 3.2]。 这个程序包含了一个 Unicode 转移字符（\u000A），它位于程序唯一的注释行中。</p>
<p>就像注释所陈述的，这个转义字符表示换行符，编译器将在丢弃注释之前适时地</p>
<p>转换它。遗憾的是，这个换行符是表示注释开始的两个斜杠符之后的第一个行终</p>
<p>结符（line terminator），因此它将终结该注释[JLS 3.4]。所以，该转义字符</p>
<p>之后的字（is Unicode representation of linefeed (LF)）就不是注释的一部</p>
<p>分了，而它们在语法上也不是有效的。 </p>
<p>订正该程序的最简单的方式就是在注释中移除 Unicode 转义字符，但是更好的方</p>
<p>式是用一个转义字符序列而不是一个十六进制整型字面常量来初始化 c，从而消</p>
<p>除使用注释的必要： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinePrinter</span>&#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">char</span> c = <span class="string">'\n'</span>; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(c); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要这么做了，程序就可以编译并运行，但是这仍然是一个有问题的程序：它是</p>
<p>平台相关的，这正是本谜题所要表达的真正意图。在某些平台上，例如 UNIX，</p>
<p>它将打印出两个完整的行分隔符；但是在其它一些平台上，例如 Windows，它就</p>
<p>不会产生这样的行为。尽管这些输出用肉眼看起来是一样的，但是如果它们要被</p>
<p>存储到文件中，或是输出到后续的其它处理程序中，那就很容易引发问题。 </p>
<p>如果你想打印两行空行，你应该调用 println 两次。如果使用的是 JDK 5.0，那</p>
<p>么你可以用带有格式化字符串”%n%n”的 printf 来代替 println。%n 的每一次出</p>
<p>现都将导致 printf 打印一个恰当的、与平台相关的行分隔符。 </p>
<p>我们希望，上面三个谜题已经使你信服：Unicode 转义字符绝对会产生混乱。教</p>
<p>训很简单：除非确实是必需的，否则就不要使用 Unicode 转义字符。它们很少是</p>
<p>必需的。 </p>
<h2 id="谜题-17：嗯？"><a href="#谜题-17：嗯？" class="headerlink" title="谜题 17：嗯？"></a>谜题 17：嗯？</h2><p>下面的是一个合法的 Java 程序吗？如果是，它会打印出什么呢？ </p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">\u</span>0070<span class="symbol">\u</span>0075<span class="symbol">\u</span>0062<span class="symbol">\u</span>006c<span class="symbol">\u</span>0069<span class="symbol">\u</span>0063<span class="symbol">\u</span>0020<span class="symbol">\u</span>0020<span class="symbol">\u</span>0020<span class="symbol">\u</span>0020</span><br><span class="line"></span><br><span class="line"><span class="symbol">\u</span>0063<span class="symbol">\u</span>006c<span class="symbol">\u</span>0061<span class="symbol">\u</span>0073<span class="symbol">\u</span>0073<span class="symbol">\u</span>0020<span class="symbol">\u</span>0055<span class="symbol">\u</span>0067<span class="symbol">\u</span>006c<span class="symbol">\u</span>0079</span><br><span class="line"></span><br><span class="line"><span class="symbol">\u</span>007b<span class="symbol">\u</span>0070<span class="symbol">\u</span>0075<span class="symbol">\u</span>0062<span class="symbol">\u</span>006c<span class="symbol">\u</span>0069<span class="symbol">\u</span>0063<span class="symbol">\u</span>0020<span class="symbol">\u</span>0020<span class="symbol">\u</span>0020</span><br><span class="line"></span><br><span class="line"><span class="symbol">\u</span>0020<span class="symbol">\u</span>0020<span class="symbol">\u</span>0020<span class="symbol">\u</span>0020<span class="symbol">\u</span>0073<span class="symbol">\u</span>0074<span class="symbol">\u</span>0061<span class="symbol">\u</span>0074<span class="symbol">\u</span>0069<span class="symbol">\u</span>0063</span><br><span class="line"></span><br><span class="line"><span class="symbol">\u</span>0076<span class="symbol">\u</span>006f<span class="symbol">\u</span>0069<span class="symbol">\u</span>0064<span class="symbol">\u</span>0020<span class="symbol">\u</span>006d<span class="symbol">\u</span>0061<span class="symbol">\u</span>0069<span class="symbol">\u</span>006e<span class="symbol">\u</span>0028</span><br><span class="line"></span><br><span class="line"><span class="symbol">\u</span>0053<span class="symbol">\u</span>0074<span class="symbol">\u</span>0072<span class="symbol">\u</span>0069<span class="symbol">\u</span>006e<span class="symbol">\u</span>0067<span class="symbol">\u</span>005b<span class="symbol">\u</span>005d<span class="symbol">\u</span>0020<span class="symbol">\u</span>0020</span><br><span class="line"></span><br><span class="line"><span class="symbol">\u</span>0020<span class="symbol">\u</span>0020<span class="symbol">\u</span>0020<span class="symbol">\u</span>0020<span class="symbol">\u</span>0061<span class="symbol">\u</span>0072<span class="symbol">\u</span>0067<span class="symbol">\u</span>0073<span class="symbol">\u</span>0029<span class="symbol">\u</span>007b</span><br><span class="line"></span><br><span class="line"><span class="symbol">\u</span>0053<span class="symbol">\u</span>0079<span class="symbol">\u</span>0073<span class="symbol">\u</span>0074<span class="symbol">\u</span>0065<span class="symbol">\u</span>006d<span class="symbol">\u</span>002e<span class="symbol">\u</span>006f<span class="symbol">\u</span>0075<span class="symbol">\u</span>0074</span><br><span class="line"></span><br><span class="line"><span class="symbol">\u</span>002e<span class="symbol">\u</span>0070<span class="symbol">\u</span>0072<span class="symbol">\u</span>0069<span class="symbol">\u</span>006e<span class="symbol">\u</span>0074<span class="symbol">\u</span>006c<span class="symbol">\u</span>006e<span class="symbol">\u</span>0028<span class="symbol">\u</span>0020</span><br><span class="line"></span><br><span class="line"><span class="symbol">\u</span>0022<span class="symbol">\u</span>0048<span class="symbol">\u</span>0065<span class="symbol">\u</span>006c<span class="symbol">\u</span>006c<span class="symbol">\u</span>006f<span class="symbol">\u</span>0020<span class="symbol">\u</span>0077<span class="symbol">\u</span>0022<span class="symbol">\u</span>002b <span class="symbol">\u</span>0022<span class="symbol">\u</span>006f<span class="symbol">\u</span>0072<span class="symbol">\u</span>006c<span class="symbol">\u</span>0064<span class="symbol">\u</span>0022<span class="symbol">\u</span>0029<span class="symbol">\u</span>003b<span class="symbol">\u</span>007d<span class="symbol">\u</span>007d</span><br></pre></td></tr></table></figure>

<p>这当然是一个合法的 Java 程序！这不是很显而易见吗？它会打印 Hello World。</p>
<p>噢，可能是不那么明显。事实上，该程序根本让人无法理解。每当你没必要地使</p>
<p>用了一个 Unicode 转义字符时，都会使你的程序的可理解性更缺失一点，而该程</p>
<p>序将这种做法发挥到了极致。如果你很好奇，可以看看下面给出的该程序在</p>
<p>Unicode 转义字符都被转换为它们所表示的字符之后的样子： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ugly</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span><span class="keyword">public</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">String</span>[]</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">args)</span></span>&#123; </span><br><span class="line"></span><br><span class="line">System.out </span><br><span class="line"></span><br><span class="line">.<span class="built_in">println</span>( </span><br><span class="line"></span><br><span class="line">“Hello w”+ </span><br><span class="line"></span><br><span class="line">“orld”);&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>下面给出了将其进行格式化整理之后的样子： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ugly</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"Hello w"</span>+<span class="string">"orld"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个谜题的教训是：仅仅是因为你可以不以应有的方式去进行表达。或者说，如</p>
<p>果你这么做会造成损害，那么就请不要这么做！更严肃地讲，这个谜题是对前面</p>
<p>三个教训的补充：Unicode 转义字符只有在你要向程序中插入用其他任何方式都</p>
<p>无法表示的字符时才是必需的，除此之外的任何情况都不应该避免使用它们。</p>
<p>Unicode 转义字符降低了程序的清晰度，并且增加了产生 bug 的可能性。 </p>
<p>对语言的设计者来说，也许使用 Unicode 转义字符来表示 ASCII 字符应该被定义</p>
<p>为是非法的。这样就可以使得在谜题 14、15 和 17（本谜题）中的程序非法，从</p>
<p>而消除了大量的混乱。这个限制对程序员并不会造成任何困难。 </p>
<h2 id="谜题-18：字符串奶酪"><a href="#谜题-18：字符串奶酪" class="headerlink" title="谜题 18：字符串奶酪"></a>谜题 18：字符串奶酪</h2><p>下面的程序从一个字节序列创建了一个字符串，然后迭代遍历字符串中的字符，</p>
<p>并将它们作为数字打印。请描述一下程序打印出来的数字序列： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringCheese</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">byte</span> bytes[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">256</span>]; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) </span><br><span class="line"></span><br><span class="line"> bytes[i] = (<span class="keyword">byte</span>)i; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">String</span> str = <span class="keyword">new</span> <span class="keyword">String</span>(bytes); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = str.length(); i &lt; n; i++) System.out.<span class="built_in">println</span>((<span class="keyword">int</span>)str.charAt(i) + <span class="string">" "</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，byte 数组用从 0 到 255 每一个可能的 byte 数值进行了初始化，然后这些</p>
<p>byte 数值通过 String 构造器被转换成了 char 数值。最后，char 数值被转型为</p>
<p>int 数值并被打印。打印出来的数值肯定是非负整数，因为 char 数值是无符号</p>
<p>的，因此，你可能期望该程序将按顺序打印出 0 到 255 的整数。 </p>
<p>如果你运行该程序，可能会看到这样的序列。但是在运行一次，可能看到的就不</p>
<p>是这个序列了。我们在四台机器上运行它，会看到四个不同的序列，包括前面描</p>
<p>述的那个序列。这个程序甚至都不能保证会正常终止，比打印其他任何特定字符</p>
<p>串都要缺乏这种保证。它的行为完全是不确定的。 </p>
<p>这里的罪魁祸首就是 String(byte[])构造器。有关它的规范描述道：“在通过</p>
<p>解码使用平台缺省字符集的指定 byte 数组来构造一个新的 String 时，该新</p>
<p>String 的长度是字符集的一个函数，因此，它可能不等于 byte 数组的长度。当</p>
<p>给定的所有字节在缺省字符集中并非全部有效时，这个构造器的行为是不确定</p>
<p>的”[Java-API]。 </p>
<p>到底什么是字符集？从技术角度上讲，它是“被编码的字符集合和字符编码模式</p>
<p>的结合物”[Java-API]。换句话说，字符集是一个包，包含了字符、表示字符的</p>
<p>数字编码以及在字符编码序列和字节序列之间来回转换的方式。转换模式在字符</p>
<p>集之间存在着很大的区别：某些是在字符和字节之间做一对一的映射，但是大多</p>
<p>数都不是这样。ISO-8859-1 是唯一能够让该程序按顺序打印从 0 到 255 的整数</p>
<p>的缺省字符集，它更为大家所熟知的名字是 Latin-1[ISO-8859-1]。 </p>
<p>J2SE 运行期环境（JRE）的缺省字符集依赖于底层的操作系统和语言。如果你想</p>
<p>知道你的 JRE 的缺省字符集，并且你使用的是 5.0 或更新的版本，那么你可以通</p>
<p>过调用 java.nio.charset.Charset.defaultCharset()来了解。如果你使用的是</p>
<p>较早的版本，那么你可以通过阅读系统属性“file.encoding”来了解。 </p>
<p>幸运的是，你没有被强制要求必须去容忍各种稀奇古怪的缺省字符集。当你在</p>
<p>char 序列和 byte 序列之间做转换时，你可以且通常是应该显式地指定字符集。</p>
<p>除了接受 byte 数字之外，还可以接受一个字符集名称的 String 构造器就是专为</p>
<p>此目的而设计的。如果你用下面的构造器去替换在最初的程序中的 String 构造</p>
<p>器，那么不管缺省的字符集是什么，该程序都保证能够按照顺序打印从 0 到 255</p>
<p>的整数： </p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> str = <span class="literal">new</span> <span class="built_in">String</span>(<span class="built_in">bytes</span>, <span class="string">"ISO-8859-1"</span>);</span><br></pre></td></tr></table></figure>

<p>这个构造器声明会抛出 UnsupportedEncodingException 异常，因此你必须捕获</p>
<p>它，或者更适宜的方式是声明 main 方法将抛出它，要不然程序不能通过编译。</p>
<p>尽管如此，该程序实际上不会抛出异常。Charset 的规范要求 Java 平台的每一</p>
<p>种实现都要支持某些种类的字符集，ISO-8859-1 就位列其中。 这个谜题的教训是：每当你要将一个 byte 序列转换成一个 String 时，你都在使</p>
<p>用某一个字符集，不管你是否显式地指定了它。如果你想让你的程序的行为是可</p>
<p>预知的，那么就请你在每次使用字符集时都明确地指定。对 API 的设计者来说，</p>
<p>提供这么一个依赖于缺省字符集的 String(byte[])构造器可能并非是一个好主</p>
<p>意。 </p>
<h2 id="谜题-19：漂亮的火花"><a href="#谜题-19：漂亮的火花" class="headerlink" title="谜题 19：漂亮的火花"></a>谜题 19：漂亮的火花</h2><p>下面的程序用一个方法对字符进行了分类。这个程序会打印出什么呢？ </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Classifier &#123; </span><br><span class="line"></span><br><span class="line"> <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">System</span>.<span class="keyword">out</span>.println( </span><br><span class="line"></span><br><span class="line"> classify(<span class="string">'n'</span>) + classify(<span class="string">'+'</span>) + classify(<span class="string">'2'</span>)); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> static String classify(<span class="type">char</span> ch) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> ("0123456789".indexOf(ch) &gt;= <span class="number">0</span>) </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> "NUMERAL "; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> ("abcdefghijklmnopqrstuvwxyz".indexOf(ch) &gt;= <span class="number">0</span>) </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> "LETTER "; </span><br><span class="line"></span><br><span class="line"> <span class="comment">/* (Operators not supported yet) </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> if ("+-*/</span>&amp;|!=" &gt;= 0) </span><br><span class="line"></span><br><span class="line"> return "<span class="keyword">OPERATOR</span> "; </span><br><span class="line"></span><br><span class="line"> */ </span><br><span class="line"></span><br><span class="line"> return "<span class="type">UNKNOWN</span>"; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你猜想该程序将打印 LETTER UNKNOWN NUMERAL，那么你就掉进陷阱里面了。</p>
<p>这个程序连编译都通不过。让我们再看一看相关的部分，这一次我们用粗体字突</p>
<p>出注释部分： </p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if (<span class="string">"abcdefghijklmnopqrstuvwxyz"</span>.indexOf(<span class="name">ch</span>) &gt;= <span class="number">0</span>) </span><br><span class="line"></span><br><span class="line"> return <span class="string">"LETTER "</span><span class="comment">; </span></span><br><span class="line"></span><br><span class="line"> /* (<span class="name">Operators</span> not supported yet) /* (<span class="name">Operators</span> not supported yet) </span><br><span class="line"></span><br><span class="line"> if (<span class="string">"+- if ("</span>+-*/&amp;|!=<span class="string">" &gt;= 0) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> return "</span>OPERATOR <span class="string">"; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> */ </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> return "</span>UNKNOWN<span class="string">"; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> &#125; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>正如你之所见，注释在包含了字符*/的字符串内部就结束了，结果使得程序在语</p>
<p>法上变成非法的了。我们将程序中的一部分注释出来的尝试之所以失败了，是因</p>
<p>为字符串字面常量在注释中没有被特殊处理。 </p>
<p>更一般地讲，注释内部的文本没有以任何方式进行特殊处理[JLS 3.7]。因此，</p>
<p>块注释不能嵌套。请考虑下面的代码段： /* Add the numbers from 1 to n */ </p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">for (<span class="built_in">int</span> i = <span class="number">1</span>; I &lt;= <span class="built_in">n</span>; i++) </span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span> += i;</span><br></pre></td></tr></table></figure>

<p>现在假设我们要将该代码段注释成为一个块注释，我们再次用粗体字突出整个注</p>
<p>释： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/* Add the numbers from 1 to n */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sum = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; I &lt;= n; i++) </span><br><span class="line"></span><br><span class="line">sum += i; </span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>正如你之所见，我们没有能够将最初的代码段注释掉。好在所产生的代码包含了</p>
<p>一个语法错误，因此编译器将会告诉我们代码存在着问题。 </p>
<p>你可能偶尔看到过这样的代码段，它被一个布尔表达式为常量 false 的 if 语句</p>
<p>禁用了： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//code commented out with an if statement - doesn't always work! </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Add the numbers from 1 to n */</span> </span><br><span class="line"></span><br><span class="line"> <span class="built_in">int</span> sum = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line"></span><br><span class="line"> sum += i; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>语言规范建议将这种方式作为一种条件编译技术[JLS 14.21]，但是它不适合用</p>
<p>来注释代码。除非要被禁用的代码是一个合法的语句序列，否则就不要使用这项</p>
<p>技术。 </p>
<p>注释掉一个代码段的最好的方式是使用单行的注释序列。大多数 IDE 工具都可以</p>
<p>自动化这个过程： </p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//code commented out with an if statement - doesn't always work! </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /* Add the numbers from 1 to n */ </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int sum = 0; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for (int i = 1; i &lt;= n; i++) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sum += i;</span></span><br></pre></td></tr></table></figure>

<p>总之，块注释不能可靠地注释掉代码段，应该用单行的注释序列来代替。对语言</p>
<p>设计者来说，应该注意到可嵌套的块注释并不是一个好主意。他们强制编译器去</p>
<p>解析块注释内部的文本，而由此引发的问题比它能够解决的问题还要多。 </p>
<h2 id="谜题-20：我的类是什么？"><a href="#谜题-20：我的类是什么？" class="headerlink" title="谜题 20：我的类是什么？"></a>谜题 20：我的类是什么？</h2><p> 下面的程序被设计用来打印它的类文件的名称。如果你不熟悉类字面常量，那么</p>
<p>我告诉你 Me.class.getName()将返回 Me 类完整的名称，即</p>
<p>“com.javapuzzlers.Me”。那么，这个程序会打印出什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.javapuzzlers; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Me</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>( </span><br><span class="line"></span><br><span class="line"> Me.class.getName(). </span><br><span class="line"></span><br><span class="line"> replaceAll(<span class="string">"."</span>,<span class="string">"/"</span>) + <span class="string">".class"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序看起来会获得它的类名（“com.javapuzzlers.Me”），然后用“/”替换</p>
<p>掉所有出现的字符串“.”，并在末尾追加字符串“.class”。你可能会认为该</p>
<p>程序将打印 com/javapuzzlers/Me.class，该程序正式从这个类文件中被加载</p>
<p>的。如果你运行这个程序，就会发现它实际上打印的是</p>
<p>///////////////////.class。到底怎么回事？难道我们是斜杠的受害者吗？ </p>
<p>问题在于 String.replaceAll 接受了一个正则表达式作为它的第一个参数，而并</p>
<p>非接受了一个字符序列字面常量。（正则表达式已经被添加到了 Java 平台的 1.4</p>
<p>版本中。）正则表达式“.”可以匹配任何单个的字符，因此，类名中的每一个</p>
<p>字符都被替换成了一个斜杠，进而产生了我们看到的输出。 </p>
<p>要想只匹配句点符号，在正则表达式中的句点必须在其前面添加一个反斜杠（\）</p>
<p>进行转义。因为反斜杠字符在字面含义的字符串中具有特殊的含义——它标识转</p>
<p>义字符序列的开始——因此反斜杠自身必须用另一个反斜杠来转义，这样就可以</p>
<p>产生一个转义字符序列，它可以在字面含义的字符串中生成一个反斜杠。把这些</p>
<p>合在一起，就可以使下面的程序打印出我们所期望的</p>
<p>com/javapuzzlers/Me.class： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.javapuzzlers; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Me</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>( </span><br><span class="line"></span><br><span class="line"> Me.class.getName().replaceAll(<span class="string">"\\."</span>,<span class="string">"/"</span>) + <span class="string">".class"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决这类问题，5.0 版本提供了新的静态方法</p>
<p>java.util.regex.Pattern.quote。它接受一个字符串作为参数，并可以添加必</p>
<p>需的转义字符，它将返回一个正则表达式字符串，该字符串将精确匹配输入的字</p>
<p>符串。下面是使用该方法之后的程序： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.javapuzzlers; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Me</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(Me.class.getName(). replaceAll(Pattern.quote(<span class="string">"."</span>),<span class="string">"/"</span>) + <span class="string">".class"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序的另一个问题是：其正确的行为是与平台相关的。并不是所有的文件系统</p>
<p>都使用斜杠符号来分隔层次结构的文件名组成部分的。要想获取一个你正在运行</p>
<p>的平台上的有效文件名，你应该使用正确的平台相关的分隔符号来代替斜杠符</p>
<p>号。这正是下一个谜题所要做的。 </p>
<h2 id="谜题-21：我的类是什么？II"><a href="#谜题-21：我的类是什么？II" class="headerlink" title="谜题 21：我的类是什么？II"></a>谜题 21：我的类是什么？II</h2><p>下面的程序所要做的事情正是前一个谜题所做的事情，但是它没有假设斜杠符号</p>
<p>就是分隔文件名组成部分的符号。相反，该程序使用的是</p>
<p>java.io.File.separator，它被指定为一个公共的 String 域，包含了平台相关</p>
<p>的文件名分隔符。那么，这个程序会打印出其正确的、平台相关的类文件名吗？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.javapuzzlers; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.<span class="built_in">File</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MeToo</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(MeToo.class.getName(). </span><br><span class="line"></span><br><span class="line"> replaceAll(<span class="string">"\\."</span>, <span class="built_in">File</span>.separator) + <span class="string">".class"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序根据底层平台的不同会显示两种行为中的一种。如果文件分隔符是斜</p>
<p>杠，就像在 UNIX 上一样，那么该程序将打印 com/javapuzzlers/MeToo.class，</p>
<p>这是正确的。但是，如果文件分隔符是反斜杠，就像在 Windows 上一样，那么该</p>
<p>程序将打印像下面这样的内容： </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Exception</span> <span class="selector-tag">in</span> <span class="selector-tag">thread</span> "<span class="selector-tag">main</span>" </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.StringIndexOutOfBoundsException</span>: <span class="selector-tag">String</span> <span class="selector-tag">index</span> <span class="selector-tag">out</span> <span class="selector-tag">of</span> <span class="selector-tag">range</span>: 1 </span><br><span class="line"></span><br><span class="line"> <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.String</span><span class="selector-class">.charAt</span>(<span class="selector-tag">String</span><span class="selector-class">.java</span><span class="selector-pseudo">:558)</span> </span><br><span class="line"></span><br><span class="line"> <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.regex</span><span class="selector-class">.Matcher</span><span class="selector-class">.appendReplacement</span>(<span class="selector-tag">Mather</span>. </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">java</span><span class="selector-pseudo">:696)</span> </span><br><span class="line"></span><br><span class="line"> <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.regex</span><span class="selector-class">.Matcher</span><span class="selector-class">.replaceAll</span>(<span class="selector-tag">Mather</span><span class="selector-class">.java</span><span class="selector-pseudo">:806)</span> </span><br><span class="line"></span><br><span class="line"> <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.String</span><span class="selector-class">.replaceAll</span>(<span class="selector-tag">String</span><span class="selector-class">.java</span><span class="selector-pseudo">:2000)</span> </span><br><span class="line"></span><br><span class="line"> <span class="selector-tag">at</span> <span class="selector-tag">com</span><span class="selector-class">.javapuzzlers</span><span class="selector-class">.MeToo</span><span class="selector-class">.main</span>(<span class="selector-tag">MeToo</span><span class="selector-class">.java</span><span class="selector-pseudo">:6)</span></span><br></pre></td></tr></table></figure>

<p>尽管这种行为是平台相关的，但是它并非就是我们所期待的。在 Windows 上出了</p>
<p>什么错呢？ </p>
<p>事实证明，String.replaceAll 的第二个参数不是一个普通的字符串，而是一个</p>
<p>替代字符串（replacement string），就像在 java.util.regex 规范中所定义的</p>
<p>那样[Java-API]。在替代字符串中出现的反斜杠会把紧随其后的字符进行转义，</p>
<p>从而导致其被按字面含义而处理了。 </p>
<p>当你在 Windows 上运行该程序时，替代字符串是单独的一个反斜杠，它是无效的。</p>
<p>不可否认，抛出的异常应该提供更多一些有用的信息。 那么你应该怎样解决此问题呢？5.0 版本提供了不是一个而是两个新的方法来</p>
<p>解决它。第一个方法是 java.util.regex.Matcher.quoteReplacement，它将字</p>
<p>符串转换成相应的替代字符串。下面展示了如何使用这个方法来订正该程序： </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="selector-tag">MeToo</span><span class="selector-class">.class</span><span class="selector-class">.getName</span>()<span class="selector-class">.replaceAll</span>("\\.",</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">Matcher</span><span class="selector-class">.quoteReplacement</span>(<span class="selector-tag">File</span><span class="selector-class">.separator</span>)) + "<span class="selector-class">.class</span>");</span><br></pre></td></tr></table></figure>

<p>引入到 5.0 版本中的第二个方法提供了一个更好的解决方案。该方法就是</p>
<p>String.replace(CharSequence, CharSequence)，它做的事情和</p>
<p>String.replaceAll 相同，但是它将模式和替代物都当作字面含义的字符串处</p>
<p>理。下面展示了如何使用这个方法来订正该程序： </p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">MeToo</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">Name()</span>. </span><br><span class="line"></span><br><span class="line"> replace(<span class="string">"."</span>, <span class="module-access"><span class="module"><span class="identifier">File</span>.</span></span>separator) + <span class="string">".class"</span>);</span><br></pre></td></tr></table></figure>

<p>但是如果你使用的是较早版本的 Java 该怎么办？很遗憾，没有任何捷径能够生</p>
<p>成替代字符串。完全不使用正则表达式，而使用 String.replace(char,char)也</p>
<p>许要显得更容易一些： </p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">MeToo</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">Name()</span>. </span><br><span class="line"></span><br><span class="line"> replace(<span class="character">'.'</span>, <span class="module-access"><span class="module"><span class="identifier">File</span>.</span></span>separatorChar) + <span class="string">".class"</span>);</span><br></pre></td></tr></table></figure>

<p>本谜题和前一个谜题的主要教训是：在使用不熟悉的类库方法时一定要格外小</p>
<p>心。当你心存疑虑时，就要求助于 Javadoc。还有就是正则表达式是很棘手的：</p>
<p>它所引发的问题趋向于在运行时刻而不是在编译时刻暴露出来。 </p>
<p>对 API 的设计者来说，使用方法具名的模式来以明显的方式区分方法行为的差异</p>
<p>是很重要的。Java 的 String 类就没有很好地遵从这一原则。对许多程序员来说，</p>
<p>对于哪些字符串替代方法使用的是字面含义的字符串，以及哪些使用的是正则表</p>
<p>达式或替代字符串，要记住这些都不是一件容易事。 </p>
<h2 id="谜题-22：URL-的愚弄"><a href="#谜题-22：URL-的愚弄" class="headerlink" title="谜题 22：URL 的愚弄"></a>谜题 22：URL 的愚弄</h2><p>本谜题利用了 Java 编程语言中一个很少被人了解的特性。请考虑下面的程序将</p>
<p>会做些什么？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrowserTest</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">print</span>(<span class="string">"iexplore:"</span>); </span><br><span class="line"></span><br><span class="line"> http:<span class="comment">//www.google.com; </span></span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">":maximize"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个有点诡异的问题。该程序将不会做任何特殊的事情，而是直接打印</p>
<p>iexplore::maximize。在程序中间出现的 URL 是一个语句标号（statement label）</p>
<p>[JLS 14.7]后面跟着一行行尾注释（end-of-line comment）[JLS 3.7]。在 Java</p>
<p>中很少需要标号，这多亏了 Java 没有 goto 语句。在本谜题中所引用的“Java</p>
<p>编程语言中很少被人了解的特性”实际上就是你可以在任何语句前面放置标号。</p>
<p>这个程序标注了一个表达式语句，它是合法的，但是却没什么用处。 它的价值所在，就是提醒你，如果你真的想要使用标号，那么应该用一种更合理</p>
<p>的方式来格式化程序： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrowserTest</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">print</span>(<span class="string">"iexplore:"</span>); </span><br><span class="line"></span><br><span class="line"> http: <span class="comment">//www.google.com; </span></span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">":maximize"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是说，我们没有任何可能的理由去使用与程序没有任何关系的标号和注释。 </p>
<p>本谜题的教训是：令人误解的注释和无关的代码会引起混乱。要仔细地写注释，</p>
<p>并让它们跟上时代；要切除那些已遭废弃的代码。还有就是如果某些东西看起来</p>
<p>过于奇怪，以至于不像对的，那么它极有可能就是错的。 </p>
<h2 id="谜题-23：不劳无获"><a href="#谜题-23：不劳无获" class="headerlink" title="谜题 23：不劳无获"></a>谜题 23：不劳无获</h2><p>下面的程序将打印一个单词，其第一个字母是由一个随机数生成器来选择的。请</p>
<p>描述该程序的行为： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rhymes</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Random rnd = <span class="keyword">new</span> Random(); </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> StringBuffer <span class="keyword">word</span> = null; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">switch</span>(rnd.nextInt(<span class="number">2</span>)) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">word</span> = <span class="keyword">new</span> StringBuffer(<span class="string">'P'</span>); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">word</span> = <span class="keyword">new</span> StringBuffer(<span class="string">'G'</span>); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">default</span>: <span class="keyword">word</span> = <span class="keyword">new</span> StringBuffer(<span class="string">'M'</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">word</span>.append(<span class="string">'a'</span>); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">word</span>.append(<span class="string">'i'</span>); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">word</span>.append(<span class="string">'n'</span>); </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="keyword">word</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乍一看，这个程序可能会在一次又一次的运行中，以相等的概率打印出 Pain，</p>
<p>Gain 或 Main。看起来该程序会根据随机数生成器所选取的值来选择单词的第一</p>
<p>个字母：0 选 M，1 选 P，2 选 G。谜题的题目也许已经给你提供了线索，它实际</p>
<p>上既不会打印 Pain，也不会打印 Gain。也许更令人吃惊的是，它也不会打印 Main，</p>
<p>并且它的行为不会在一次又一次的运行中发生变化，它总是在打印 ain。 </p>
<p>有三个 bug 凑到一起引发了这种行为。你完全没有发现它们吗？第一个 bug 是所</p>
<p>选取的随机数使得 switch 语句只能到达其三种情况中的两种。Random.nextInt(int)的规范描述道：“返回一个伪随机的、均等地分布在从 0</p>
<p>（包括）到指定的数值（不包括）之间的一个 int 数值”[Java-API]。这意味着</p>
<p>表达式 rnd.nextInt(2)可能的取值只有 0 和 1，Switch 语句将永远也到不了 case </p>
<p>2 分支，这表示程序将永远不会打印 Gain。nextInt 的参数应该是 3 而不是 2。 </p>
<p>这是一个相当常见的问题源，被熟知为“栅栏柱错误（fencepost error）”。</p>
<p>这个名字来源于对下面这个问题最常见的但却是错误的答案，如果你要建造一个</p>
<p>100 英尺长的栅栏，其栅栏柱间隔为 10 英尺，那么你需要多少根栅栏柱呢？11</p>
<p>根或 9 根都是正确答案，这取决于是否要在栅栏的两端树立栅栏柱，但是 10 根</p>
<p>却是错误的。要当心栅栏柱错误，每当你在处理长度、范围或模数的时候，都要</p>
<p>仔细确定其端点是否应该被包括在内，并且要确保你的代码的行为要与其相对</p>
<p>应。 </p>
<p>第二个 bug 是在不同的情况（case）中没有任何 break 语句。不论 switch 表达</p>
<p>式为何值，该程序都将执行其相对应的 case 以及所有后续的 case[JLS 14.11]。</p>
<p>因此，尽管每一个 case 都对变量 word 赋了一个值，但是总是最后一个赋值胜出，</p>
<p>覆盖了前面的赋值。最后一个赋值将总是最后一种情况（default），即 new</p>
<p>StringBuffer{‘M’}。这表明该程序将总是打印Main，而从来不打印Pain或Gain。 </p>
<p>在 switch 的各种情况中缺少 break 语句是非常常见的错误。从 5.0 版本起，javac</p>
<p>提供了-Xlint:fallthrough 标志，当你忘记在一个 case 与下一个 case 之间添</p>
<p>加 break 语句是，它可以生成警告信息。不要从一个非空的 case 向下进入了另</p>
<p>一个 case。这是一种拙劣的风格，因为它并不常用，因此会误导读者。十次中</p>
<p>有九次它都会包含错误。如果 Java 不是模仿 C 建模的，那么它倒是有可能不需</p>
<p>要 break。对语言设计者的教训是：应该考虑提供一个结构化的 switch 语句。 </p>
<p>最后一个，也是最微妙的一个 bug 是表达式 new StringBuffer(‘M’)可能没有做</p>
<p>哪些你希望它做的事情。你可能对 StringBuffer(char)构造器并不熟悉，这很</p>
<p>容易解释：它压根就不存在。StringBuffer 有一个无参数的构造器，一个接受</p>
<p>一个 String 作为字符串缓冲区初始内容的构造器，以及一个接受一个 int 作为</p>
<p>缓冲区初始容量的构造器。在本例中，编译器会选择接受 int 的构造器，通过拓</p>
<p>宽原始类型转换把字符数值’M’转换为一个 int 数值 77[JLS 5.1.2]。换句话说，</p>
<p>new StringBuffer(‘M’)返回的是一个具有初始容量 77 的空的字符串缓冲区。该</p>
<p>程序余下的部分将字符 a、i 和 n 添加到了这个空字符串缓冲区中，并打印出该</p>
<p>字符串缓冲区那总是 ain 的内容。 </p>
<p>为了避免这类问题，不管在什么时候，都要尽可能使用熟悉的惯用法和 API。如</p>
<p>果你必须使用不熟悉的 API，那么请仔细阅读其文档。在本例中，程序应该使用</p>
<p>常用的接受一个 String 的 StringBuffer 构造器。 </p>
<p>下面是该程序订正了这三个 bug 之后的正确版本，它将以均等的概率打印 Pain、</p>
<p>Gain 和 Main： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rhymes1</span> &#123;</span> <span class="keyword">private</span> <span class="keyword">static</span> Random rnd = <span class="keyword">new</span> Random(); </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> StringBuffer <span class="keyword">word</span> = null; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">switch</span>(rnd.nextInt(<span class="number">3</span>)) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line"></span><br><span class="line"> <span class="keyword">word</span> = <span class="keyword">new</span> StringBuffer(<span class="string">"P"</span>); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">case</span> <span class="number">2</span>: </span><br><span class="line"></span><br><span class="line"> <span class="keyword">word</span> = <span class="keyword">new</span> StringBuffer(<span class="string">"G"</span>); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line"> <span class="keyword">word</span> = <span class="keyword">new</span> StringBuffer(<span class="string">"M"</span>); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">word</span>.append(<span class="string">'a'</span>); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">word</span>.append(<span class="string">'i'</span>); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">word</span>.append(<span class="string">'n'</span>); </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="keyword">word</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管这个程序订正了所有的 bug，它还是显得过于冗长了。下面是一个更优雅的</p>
<p>版本： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rhymes2</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Random rnd = <span class="keyword">new</span> Random(); </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"PGM"</span>.charAt(rnd.nextInt(<span class="number">3</span>)) + <span class="string">"ain"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个更好的版本。尽管它稍微长了一点，但是它更加通用。它不依赖于所</p>
<p>有可能的输出只是在它们的第一个字符上有所不同的这个事实： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rhymes3</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">String</span> a[] = &#123;<span class="string">"Main"</span>,<span class="string">"Pain"</span>,<span class="string">"Gain"</span>&#125;; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(randomElement(a)); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Random rnd = <span class="keyword">new</span> Random(); </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> <span class="title">randomElement</span><span class="params">(<span class="keyword">String</span>[] a)</span></span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> a[rnd.nextInt(a.length)]; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下：首先，要当心栅栏柱错误。其次，牢记在 switch 语句的每一个 case </p>
<p>中都放置一条 break 语句。第三，要使用常用的惯用法和 API，并且当你在离开老路子的时候，一定要参考相关的文档。第四，一个 char 不是一个 String，</p>
<p>而是更像一个 int。最后，要提防各种诡异的谜题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/20/java%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%B0%9C%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/20/java%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%B0%9C%E9%A2%98/" class="post-title-link" itemprop="url">java表达式谜题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-20 18:13:32 / 修改时间：22:28:11" itemprop="dateCreated datePublished" datetime="2021-03-20T18:13:32+08:00">2021-03-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java-谜题-Java-谜题-1——表达式谜题"><a href="#Java-谜题-Java-谜题-1——表达式谜题" class="headerlink" title="Java 谜题 Java 谜题 1——表达式谜题"></a>Java 谜题 Java 谜题 1——表达式谜题</h1><h2 id="谜题-1：奇数性"><a href="#谜题-1：奇数性" class="headerlink" title="谜题 1：奇数性"></a>谜题 1：奇数性</h2><p>下面的方法意图确定它那唯一的参数是否是一个奇数。这个方法能够正确运转</p>
<p>吗？ </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> static <span class="built_in">bool</span>ean isOdd(<span class="built_in">int</span> i)&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>奇数可以被定义为被 2 整除余数为 1 的整数。表达式 i % 2 计算的是 i 整除 2 </p>
<p>时所产生的余数，因此看起来这个程序应该能够正确运转。遗憾的是，它不能；</p>
<p>它在四分之一的时间里返回的都是错误的答案。 </p>
<p>为什么是四分之一？因为在所有的 int 数值中，有一半都是负数，而 isOdd 方</p>
<p>法对于对所有负奇数的判断都会失败。在任何负整数上调用该方法都回返回</p>
<p>false ，不管该整数是偶数还是奇数。 </p>
<p>这是 Java 对取余操作符（%）的定义所产生的后果。该操作符被定义为对于所</p>
<p>有的 int 数值 a 和所有的非零 int 数值 b，都满足下面的恒等式： </p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(a / b)</span> * b + <span class="comment">(a % b)</span> == a</span><br></pre></td></tr></table></figure>

<p>换句话说，如果你用 b 整除 a，将商乘以 b，然后加上余数，那么你就得到了最</p>
<p>初的值 a 。该恒等式具有正确的含义，但是当与 Java 的截尾整数整除操作符</p>
<p>相结合时，它就意味着：当取余操作返回一个非零的结果时，它与左操作数具有</p>
<p>相同的正负符号。 </p>
<p>当 i 是一个负奇数时，i % 2 等于-1 而不是 1， 因此 isOdd 方法将错误地返</p>
<p>回 false。为了防止这种意外，请测试你的方法在为每一个数值型参数传递负数、</p>
<p>零和正数数值时，其行为是否正确。 </p>
<p>这个问题很容易订正。只需将 i % 2 与 0 而不是与 1 比较，并且反转比较的含</p>
<p>义即可： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> static <span class="built_in">bool</span>ean isOdd(<span class="built_in">int</span> i)&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> i % <span class="number">2</span> != <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你正在在一个性能临k界（performance-critical）环境中使用 isOdd 方法，</p>
<p>那么用位操作符 AND（&amp;）来替代取余操作符会显得更好： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> static <span class="built_in">bool</span>ean isOdd(<span class="built_in">int</span> i)&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> (i &amp; <span class="number">1</span>) != <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，无论你何时使用到了取余操作符，都要考虑到操作数和结果的符号。该操</p>
<p>作符的行为在其操作数非负时是一目了然的，但是当一个或两个操作数都是负数</p>
<p>时，它的行为就不那么显而易见了。</p>
<h2 id="谜题-2：找零时刻"><a href="#谜题-2：找零时刻" class="headerlink" title="谜题 2：找零时刻"></a>谜题 2：找零时刻</h2><p>请考虑下面这段话所描述的问题： </p>
<p>Tom 在一家汽车配件商店购买了一个价值$1.10 的火花塞，但是他钱包中都是两</p>
<p>美元一张的钞票。如果他用一张两美元的钞票支付这个火花塞，那么应该找给他</p>
<p>多少零钱呢？ </p>
<p>下面是一个试图解决上述问题的程序，它会打印出什么呢？ </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Change</span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> static <span class="built_in">void</span> main(String args[])&#123; </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println(<span class="number">2.00</span> - <span class="number">1.10</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能会很天真地期望该程序能够打印出 0.90，但是它如何才能知道你想要打</p>
<p>印小数点后两位小数呢？ </p>
<p>如果你对在 Double.toString 文档中所设定的将 double 类型的值转换为字符串</p>
<p>的规则有所了解，你就会知道该程序打印出来的小数，是足以将 double 类型的</p>
<p>值与最靠近它的临近值区分出来的最短的小数，它在小数点之前和之后都至少有</p>
<p>一位。因此，看起来，该程序应该打印 0.9 是合理的。 </p>
<p>这么分析可能显得很合理，但是并不正确。如果你运行该程序，你就会发现它打</p>
<p>印的是 0.8999999999999999。 </p>
<p>问题在于 1.1 这个数字不能被精确表示成为一个 double，因此它被表示成为最</p>
<p>接近它的 double 值。该程序从 2 中减去的就是这个值。遗憾的是，这个计算的</p>
<p>结果并不是最接近 0.9 的 double 值。表示结果的 double 值的最短表示就是你所</p>
<p>看到的打印出来的那个可恶的数字。 </p>
<p>更一般地说，问题在于并不是所有的小数都可以用二进制浮点数来精确表示的。 </p>
<p>如果你正在用的是 JDK 5.0 或更新的版本，那么你可能会受其诱惑，通过使用</p>
<p>printf 工具来设置输出精度的方订正该程序： </p>
<p>//拙劣的解决方案——仍旧是使用二进制浮点数</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.printf</span>("%<span class="selector-class">.2f</span>%<span class="selector-tag">n</span>",2<span class="selector-class">.00</span> <span class="selector-tag">-</span> 1<span class="selector-class">.10</span>);</span><br></pre></td></tr></table></figure>

<p>这条语句打印的是正确的结果，但是这并不表示它就是对底层问题的通用解决方</p>
<p>案：它使用的仍旧是二进制浮点数的 double 运算。浮点运算在一个范围很广的</p>
<p>值域上提供了很好的近似，但是它通常不能产生精确的结果。二进制浮点对于货</p>
<p>币计算是非常不适合的，因为它不可能将 0.1——或者 10 的其它任何次负幂——</p>
<p>精确表示为一个长度有限的二进制小数 </p>
<p>解决该问题的一种方式是使用某种整数类型，例如 int 或 long，并且以分为单</p>
<p>位来执行计算。如果你采纳了此路线，请确保该整数类型大到足够表示在程序中</p>
<p>你将要用到的所有值。对这里举例的谜题来说，int 就足够了。下面是我们用 int</p>
<p>类型来以分为单位表示货币值后重写的 println 语句。这个版本将打印出正确答</p>
<p>案 90 分： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.<span class="keyword">out</span>.println((<span class="number">200</span> - <span class="number">110</span>) + <span class="string">"cents"</span>);</span><br></pre></td></tr></table></figure>

<p>解决该问题的另一种方式是使用执行精确小数运算的 BigDecimal。它还可以通</p>
<p>过 JDBC 与 SQL DECIMAL 类型进行互操作。这里要告诫你一点： 一定要用</p>
<p>BigDecimal(String)构造器，而千万不要用 BigDecimal(double)。后一个构造</p>
<p>器将用它的参数的“精确”值来创建一个实例：new BigDecimal(.1)将返回一个</p>
<p>表示 0.100000000000000055511151231257827021181583404541015625 的</p>
<p>BigDecimal。通过正确使用 BigDecimal，程序就可以打印出我们所期望的结果</p>
<p>0.90： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Change1</span>&#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span> args[])</span></span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="keyword">new</span> BigDecimal(<span class="string">"2.00"</span>). </span><br><span class="line"></span><br><span class="line"> subtract(<span class="keyword">new</span> BigDecimal(<span class="string">"1.10"</span>))); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个版本并不是十分地完美，因为 Java 并没有为 BigDecimal 提供任何语言上的</p>
<p>支持。使用 BigDecimal 的计算很有可能比那些使用原始类型的计算要慢一些，</p>
<p>对某些大量使用小数计算的程序来说，这可能会成为问题，而对大多数程序来说，</p>
<p>这显得一点也不重要。 </p>
<p>总之， 在需要精确答案的地方，要避免使用 float 和 double；对于货币计算，</p>
<p>要使用 int、long 或 BigDecimal。对于语言设计者来说，应该考虑对小数运算</p>
<p>提供语言支持。一种方式是提供对操作符重载的有限支持，以使得运算符可以被</p>
<p>塑造为能够对数值引用类型起作用，例如 BigDecimal。另一种方式是提供原始</p>
<p>的小数类型，就像 COBOL 与 PL/I 所作的一样。 </p>
<h2 id="谜题-3：长整除"><a href="#谜题-3：长整除" class="headerlink" title="谜题 3：长整除"></a>谜题 3：长整除</h2><p>这个谜题之所以被称为长整除是因为它所涉及的程序是有关两个 long 型数值整</p>
<p>除的。被除数表示的是一天里的微秒数；而除数表示的是一天里的毫秒数。这个</p>
<p>程序会打印出什么呢？ </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">LongDivision</span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> static <span class="built_in">void</span> main(String args[])&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> long MICROS_PER_DAY = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> * <span class="number">1000</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> long MILLIS_PER_DAY = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>; </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println(MICROS_PER_DAY/MILLIS_PER_DAY);</span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个谜题看起来相当直观。每天的毫秒数和每天的微秒数都是常量。为清楚起见，</p>
<p>它们都被表示成积的形式。每天的微秒数是（24 小时/天<em>60 分钟/小时</em>60 秒/</p>
<p>分钟<em>1000 毫秒/秒</em>1000 微秒/毫秒）。而每天的毫秒数的不同之处只是少了最</p>
<p>后一个因子 1000。 </p>
<p>当你用每天的毫秒数来整除每天的微秒数时，除数中所有的因子都被约掉了，只</p>
<p>剩下 1000，这正是每毫秒包含的微秒数。 </p>
<p>除数和被除数都是 long 类型的，long 类型大到了可以很容易地保存这两个乘积</p>
<p>而不产生溢出。因此，看起来程序打印的必定是 1000。 </p>
<p>遗憾的是，它打印的是 5。这里到底发生了什么呢？ </p>
<p>问题在于常数 MICROS_PER_DAY 的计算“确实”溢出了。尽管计算的结果适合放</p>
<p>入 long 中，并且其空间还有富余，但是这个结果并不适合放入 int 中。这个计</p>
<p>算完全是以 int 运算来执行的，并且只有在运算完成之后，其结果才被提升到</p>
<p>long，而此时已经太迟了：计算已经溢出了，它返回的是一个小了 200 倍的数值。</p>
<p>从 int提升到long是一种拓宽原始类型转换（widening primitive conversion），</p>
<p>它保留了（不正确的）数值。这个值之后被 MILLIS_PER_DAY 整除，而</p>
<p>MILLIS_PER_DAY 的计算是正确的，因为它适合 int 运算。这样整除的结果就得</p>
<p>到了 5。 </p>
<p>那么为什么计算会是以 int 运算来执行的呢？因为所有乘在一起的因子都是 int</p>
<p>数值。当你将两个 int 数值相乘时，你将得到另一个 int 数值。Java 不具有目</p>
<p>标确定类型的特性，这是一种语言特性，其含义是指存储结果的变量的类型会影</p>
<p>响到计算所使用的类型。 </p>
<p>通过使用 long 常量来替代 int 常量作为每一个乘积的第一个因子，我们就可以</p>
<p>很容易地订正这个程序。这样做可以强制表达式中所有的后续计算都用 long 运</p>
<p>作来完成。尽管这么做只在 MICROS_PER_DAY 表达式中是必需的，但是在两个乘</p>
<p>积中都这么做是一种很好的方式。相似地，使用 long 作为乘积的“第一个”数</p>
<p>值也并不总是必需的，但是这么做也是一种很好的形式。在两个计算中都以 long</p>
<p>数值开始可以很清楚地表明它们都不会溢出。下面的程序将打印出我们所期望的</p>
<p>1000： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">LongDivision</span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> static <span class="built_in">void</span> main(String args[ ])&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> long MICROS_PER_DAY = <span class="number">24</span>L * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> * <span class="number">1000</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> long MILLIS_PER_DAY = <span class="number">24</span>L * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>; </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println(MICROS_PER_DAY/MILLIS_PER_DAY);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这个教训很简单：当你在操作很大的数字时，千万要提防溢出——它可是一个缄</p>
<p>默杀手。即使用来保存结果的变量已显得足够大，也并不意味着要产生结果的计</p>
<p>算具有正确的类型。当你拿不准时，就使用 long 运算来执行整个计算。 </p>
<p>语言设计者从中可以吸取的教训是：也许降低缄默溢出产生的可能性确实是值得</p>
<p>做的一件事。这可以通过对不会产生缄默溢出的运算提供支持来实现。程序可以</p>
<p>抛出一个异常而不是直接溢出，就像 Ada 所作的那样，或者它们可以在需要的时</p>
<p>候自动地切换到一个更大的内部表示上以防止溢出，就像 Lisp 所作的那样。这</p>
<p>两种方式都可能会遭受与其相关的性能方面的损失。降低缄默溢出的另一种方式</p>
<p>是支持目标确定类型，但是这么做会显著地增加类型系统的复杂度 </p>
<h2 id="谜题-4：初级问题"><a href="#谜题-4：初级问题" class="headerlink" title="谜题 4：初级问题"></a>谜题 4：初级问题</h2><p>得啦，前面那个谜题是有点棘手，但它是有关整除的，每个人都知道整除是很麻</p>
<p>烦的。那么下面的程序只涉及加法，它又会打印出什么呢？ </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Elementary</span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args)&#123; </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println(<span class="number">12345</span>+<span class="number">5432</span>l); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从表面上看，这像是一个很简单的谜题——简单到不需要纸和笔你就可以解决</p>
<p>它。加号的左操作数的各个位是从 1 到 5 升序排列的，而右操作数是降序排列的。</p>
<p>因此，相应各位的和仍然是常数，程序必定打印 66666。对于这样的分析，只有</p>
<p>一个问题：当你运行该程序时，它打印出的是 17777。难道是 Java 对打印这样</p>
<p>的非常数字抱有偏见吗？不知怎么的，这看起来并不像是一个合理的解释。 </p>
<p>事物往往有别于它的表象。就以这个问题为例，它并没有打印出我们想要的输出。</p>
<p>请仔细观察 + 操作符的两个操作数，我们是将一个 int 类型的 12345 加到了</p>
<p>long 类型的 5432l 上。请注意左操作数开头的数字 1 和右操作数结尾的小写字</p>
<p>母 l 之间的细微差异。数字 1 的水平笔划（称为“臂（arm）”）和垂直笔划（称</p>
<p>为“茎（stem）”）之间是一个锐角，而与此相对照的是，小写字母 l 的臂和茎</p>
<p>之间是一个直角。 </p>
<p>在你大喊“恶心！”之前，你应该注意到这个问题确实已经引起了混乱，这里确</p>
<p>实有一个教训：在 long 型字面常量中，一定要用大写的 L，千万不要用小写的 l。</p>
<p>这样就可以完全掐断这个谜题所产生的混乱的源头。 </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.<span class="keyword">out</span>.println(<span class="number">12345</span>+<span class="number">5432</span>L);</span><br></pre></td></tr></table></figure>

<p>相类似的，要避免使用单独的一个 l 字母作为变量名。例如，我们很难通过观察</p>
<p>下面的代码段来判断它到底是打印出列表 l 还是数字 1。 </p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不良代码-使用了 l 作为变量名</span></span><br><span class="line"></span><br><span class="line">List l = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;(); </span><br><span class="line"></span><br><span class="line">l.<span class="built_in">add</span>(<span class="string">"Foo"</span>); </span><br><span class="line"></span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>总之，小写字母 l 和数字 1 在大多数打字机字体中都是几乎一样的。为避免你的</p>
<p>程序的读者对二者产生混淆，千万不要使用小写的 l 来作为 long 型字面常量的</p>
<p>结尾或是作为变量名。Java 从 C 编程语言中继承良多，包括 long 型字面常量的</p>
<p>语法。也许当初允许用小写的 l 来编写 long 型字面常量本身就是一个错误。 </p>
<h2 id="谜题-5：十六进制的趣事-十六进制的趣事"><a href="#谜题-5：十六进制的趣事-十六进制的趣事" class="headerlink" title="谜题 5：十六进制的趣事 十六进制的趣事"></a>谜题 5：十六进制的趣事 十六进制的趣事</h2><p>下面的程序是对两个十六进制（hex）字面常量进行相加，然后打印出十六进制</p>
<p>的结果。这个程序会打印出什么呢？ </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">JoyOfHex</span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args)&#123; </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println( </span><br><span class="line"></span><br><span class="line"> Long.toHexString(<span class="number">0x100000000</span>L + <span class="number">0xcafebabe</span>)); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来很明显，该程序应该打印出 1cafebabe。毕竟，这确实就是十六进制数字</p>
<p>10000000016 与 cafebabe16 的和。该程序使用的是 long 型运算，它可以支持 16</p>
<p>位十六进制数，因此运算溢出是不可能的。 </p>
<p>然而，如果你运行该程序，你就会发现它打印出来的是 cafebabe，并没有任何</p>
<p>前导的 1。这个输出表示的是正确结果的低 32 位，但是不知何故，第 33 位丢失</p>
<p>了。 </p>
<p>看起来程序好像执行的是 int 型运算而不是 long 型运算，或者是忘了加第一个</p>
<p>操作数。这里到底发生了什么呢？ </p>
<p>十进制字面常量具有一个很好的属性，即所有的十进制字面常量都是正的，而十</p>
<p>六进制或是八进制字面常量并不具备这个属性。要想书写一个负的十进制常量，</p>
<p>可以使用一元取反操作符（-）连接一个十进制字面常量。以这种方式，你可以</p>
<p>用十进制来书写任何 int 或 long 型的数值，不管它是正的还是负的，并且负的</p>
<p>十进制常数可以很明确地用一个减号符号来标识。但是十六进制和八进制字面常</p>
<p>量并不是这么回事，它们可以具有正的以及负的数值。如果十六进制和八进制字</p>
<p>面常量的最高位被置位了，那么它们就是负数。在这个程序中，数字 0xcafebabe</p>
<p>是一个 int 常量，它的最高位被置位了，所以它是一个负数。它等于十进制数值</p>
<p>-889275714。 </p>
<p>该程序执行的这个加法是一种“混合类型的计算（mixed-type computation）:</p>
<p>左操作数是 long 类型的，而右操作数是 int 类型的。为了执行该计算，Java 将</p>
<p>int 类型的数值用拓宽原始类型转换提升为一个 long 类型，然后对两个 long 类</p>
<p>型数值相加。因为 int 是一个有符号的整数类型，所以这个转换执行的是符合扩</p>
<p>展：它将负的 int 类型的数值提升为一个在数值上相等的 long 类型数值。 </p>
<p>这个加法的右操作数 0xcafebabe 被提升为了 long 类型的数值</p>
<p>0xffffffffcafebabeL。这个数值之后被加到了左操作数 0x100000000L 上。当作</p>
<p>为 int 类型来被审视时，经过符号扩展之后的右操作数的高 32 位是-1，而左操</p>
<p>作数的高 32 位是 1，将这两个数值相加就得到了 0，这也就解释了为什么在程序</p>
<p>输出中前导 1 丢失了。下面所示是用手写的加法实现。（在加法上面的数字是进</p>
<p>位。） </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1111111</span> </span><br><span class="line"></span><br><span class="line"> <span class="number">0xffffffffcafebabe</span>L</span><br><span class="line"></span><br><span class="line">\+ <span class="number">0x0000000100000000</span>L</span><br><span class="line"></span><br><span class="line">\--------------------- </span><br><span class="line"></span><br><span class="line"> <span class="number">0x00000000cafebabe</span>L</span><br></pre></td></tr></table></figure>

<p>订正该程序非常简单，只需用一个 long 十六进制字面常量来表示右操作数即可。</p>
<p>这就可以避免了具有破坏力的符号扩展，并且程序也就可以打印出我们所期望的</p>
<p>结果 1cafebabe： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">JoyOfHex</span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args)&#123; </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println( </span><br><span class="line"></span><br><span class="line"> Long.toHexString(<span class="number">0x100000000</span>L + <span class="number">0xcafebabe</span>L));</span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个谜题给我们的教训是：混合类型的计算可能会产生混淆，尤其是十六进制和</p>
<p>八进制字面常量无需显式的减号符号就可以表示负的数值。为了避免这种窘境，</p>
<p>通常最好是避免混合类型的计算。对于语言的设计者们来说，应该考虑支持无符</p>
<p>号的整数类型，从而根除符号扩展的可能性。可能会有这样的争辩：负的十六进</p>
<p>制和八进制字面常量应该被禁用，但是这可能会挫伤程序员，他们经常使用十六</p>
<p>进制字面常量来表示那些符号没有任何重要含义的数值。 </p>
<h2 id="谜题-6：多重转型"><a href="#谜题-6：多重转型" class="headerlink" title="谜题 6：多重转型"></a>谜题 6：多重转型</h2><p>转型被用来将一个数值从一种类型转换到另一种类型。下面的程序连续使用了三</p>
<p>个转型。那么它到底会打印出什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Multicast</span>&#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>((<span class="keyword">int</span>)(<span class="keyword">char</span>)(<span class="keyword">byte</span>) <span class="number">-1</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论你怎样分析这个程序，都会感到很迷惑。它以 int 数值-1 开始，然后从 int</p>
<p>转型为 byte，之后转型为 char，最后转型回 int。第一个转型将数值从 32 位窄</p>
<p>化到了 8 位，第二个转型将数值从 8 位拓宽到了 16 位，最后一个转型又将数值</p>
<p>从 16 位拓宽回了 32 位。这个数值最终是回到了起点吗？如果你运行该程序，你</p>
<p>就会发现不是。它打印出来的是 65535，但是这是为什么呢？ </p>
<p>该程序的行为紧密依赖于转型的符号扩展行为。Java 使用了基于 2 的补码的二</p>
<p>进制运算，因此 int 类型的数值-1 的所有 32 位都是置位的。从 int 到 byte 的</p>
<p>转型是很简单的，它执行了一个窄化原始类型转化（narrowing primitive </p>
<p>conversion），直接将除低 8 位之外的所有位全部砍掉。这样做留下的是一个 8</p>
<p>位都被置位了的 byte，它仍旧表示-1。 </p>
<p>从 byte 到 char 的转型稍微麻烦一点，因为 byte 是一个有符号类型，而 char</p>
<p>是一个无符号类型。在将一个整数类型转换成另一个宽度更宽的整数类型时，通</p>
<p>常是可以保持其数值的，但是却不可能将一个负的 byte 数值表示成一个 char。</p>
<p>因此，从 byte 到 char 的转换被认为不是一个拓宽原始类型的转换，而是一个拓</p>
<p>宽并窄化原始类型的转换（widening and narrowing primitive conversion）：</p>
<p>byte 被转换成了 int，而这个 int 又被转换成了 char。 </p>
<p>所有这些听起来有点复杂，幸运的是，有一条很简单的规则能够描述从较窄的整</p>
<p>型转换成较宽的整型时的符号扩展行为：如果最初的数值类型是有符号的，那么</p>
<p>就执行符号扩展；如果它是 char，那么不管它将要被转换成什么类型，都执行</p>
<p>零扩展。了解这条规则可以使我们很容易地解决这个谜题。</p>
<p>因为 byte 是一个有符号的类型，所以在将 byte 数值-1 转换成 char 时，会发生</p>
<p>符号扩展。作为结果的 char 数值的 16 个位就都被置位了，因此它等于 216-1，</p>
<p>即 65535。从 char 到 int 的转型也是一个拓宽原始类型转换，所以这条规则告</p>
<p>诉我们，它将执行零扩展而不是符号扩展。作为结果的 int 数值也就成了 65535，</p>
<p>这正是程序打印出的结果。 </p>
<p>尽管这条简单的规则描述了在有符号和无符号整型之间进行拓宽原始类型时的</p>
<p>符号扩展行为，你最好还是不要编写出依赖于它的程序。如果你正在执行一个转</p>
<p>型到 char 或从 char 转型的拓宽原始类型转换，并且这个 char 是仅有的无符号</p>
<p>整型，那么你最好将你的意图明确地表达出来。 </p>
<p>如果你在将一个 char 数值 c 转型为一个宽度更宽的类型，并且你不希望有符号</p>
<p>扩展，那么为清晰表达意图，可以考虑使用一个位掩码，即使它并不是必需的： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i = c &amp; <span class="number">0xffff</span>;</span><br></pre></td></tr></table></figure>

<p>或者，书写一句注释来描述转换的行为： </p>
<p>int i = c; //不会执行符号扩展</p>
<p>如果你在将一个 char 数值 c 转型为一个宽度更宽的整型，并且你希望有符号扩</p>
<p>展，那么就先将 char 转型为一个 short，它与 char 具有同样的宽度，但是它是</p>
<p>有符号的。在给出了这种细微的代码之后，你应该也为它书写一句注释： </p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = (<span class="keyword">short</span>) c; <span class="comment">//转型将引起符号扩展</span></span><br></pre></td></tr></table></figure>

<p>如果你在将一个 byte 数值 b 转型为一个 char，并且你不希望有符号扩展，那么</p>
<p>你必须使用一个位掩码来限制它。这是一种通用做法，所以不需要任何注释： </p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char c = (<span class="name">char</span>) (<span class="name">b</span> &amp; <span class="number">0</span>xff)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>这个教训很简单：如果你通过观察不能确定程序将要做什么，那么它做的就很有</p>
<p>可能不是你想要的。要为明白清晰地表达你的意图而努力。尽管有这么一条简单</p>
<p>的规则，描述了涉及有符号和无符号整型拓宽转换的符号扩展行为，但是大多数</p>
<p>程序员都不知道它。如果你的程序依赖于它，那么你就应该把你的意图表达清楚。 </p>
<h2 id="谜题-7：互换内容"><a href="#谜题-7：互换内容" class="headerlink" title="谜题 7：互换内容"></a>谜题 7：互换内容</h2><p>下面的程序使用了复合的异或赋值操作符，它所展示的技术是一种编程习俗。那</p>
<p>么它会打印出什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CleverSwap</span>&#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> x = <span class="number">1984</span>; <span class="comment">// (0x7c0) </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> y = <span class="number">2001</span>; <span class="comment">// (0x7d1) </span></span><br><span class="line"></span><br><span class="line"> x^= y^= x^= y; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"x= "</span> + x + <span class="string">"; y= "</span> + y); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像其名称所暗示的，这个程序应该交换变量 x 和 y 的值。如果你运行它，就会</p>
<p>发现很悲惨，它失败了，打印的是</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">x</span> = <span class="number">0</span><span class="comment">; y = 1984。</span></span><br></pre></td></tr></table></figure>

<p>交换两个变量的最显而易见的方式是使用一个临时变量： </p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int tmp</span> = x; </span><br><span class="line"></span><br><span class="line"><span class="attribute">x</span> = y; </span><br><span class="line"></span><br><span class="line"><span class="attribute">y</span> = tmp;</span><br></pre></td></tr></table></figure>

<p>很久以前，当中央处理器只有少数寄存器时，人们发现可以通过利用异或操作符</p>
<p>（^）的属性(x ^ y ^ x) == y 来避免使用临时变量： </p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">x</span> = <span class="symbol">x</span> ^ <span class="symbol">y</span>; </span><br><span class="line"></span><br><span class="line"><span class="symbol">y</span> = <span class="symbol">y</span> ^ <span class="symbol">x</span>; </span><br><span class="line"></span><br><span class="line"><span class="symbol">x</span> = <span class="symbol">y</span> ^ <span class="symbol">x</span>;</span><br></pre></td></tr></table></figure>

<p>这个惯用法曾经在 C 编程语言中被使用过，并进一步被构建到了 C++中，但是它</p>
<p>并不保证在二者中都可以正确运行。但是有一点是肯定的，那就是它在 Java 中</p>
<p>肯定是不能正确运行的。 </p>
<p>Java 语言规范描述到：操作符的操作数是从左向右求值的。为了求表达式 x ^= </p>
<p>expr 的值，x 的值是在计算 expr 之前被提取的，并且这两个值的异或结果被赋</p>
<p>给变量 x。在 CleverSwap 程序中，变量 x 的值被提取了两次——每次在表达式</p>
<p>中出现时都提取一次——但是两次提取都发生在所有的赋值操作之前。 </p>
<p>下面的代码段详细地描述了将互换惯用法分解开之后的行为，并且解释了为什么</p>
<p>产生的是我们所看到的输出： </p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 中 x^= y^= x^= y 的实际行为</span></span><br><span class="line"></span><br><span class="line">int tmp1 = <span class="symbol">x</span> ; <span class="comment">// x 在表达式中第一次出现</span></span><br><span class="line"></span><br><span class="line">int tmp2 = <span class="symbol">y</span> ; <span class="comment">// y 的第一次出现</span></span><br><span class="line"></span><br><span class="line">int tmp3 = <span class="symbol">x</span> ^ <span class="symbol">y</span> ; <span class="comment">// 计算 x ^ y</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">x</span> = tmp3 ; <span class="comment">// 最后一个赋值：存储 x ^ y 到 x</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">y</span> = tmp2 ^ tmp3 ; <span class="comment">// 第二个赋值：存储最初的 x 值到 y 中 </span></span><br><span class="line"></span><br><span class="line"><span class="symbol">x</span> = tmp1 ^ <span class="symbol">y</span> ; <span class="comment">// 第一个赋值：存储 0 到 x 中</span></span><br></pre></td></tr></table></figure>

<p>在 C 和 C++中，并没有指定表达式的计算顺序。当编译表达式 x ^= expr 时，许</p>
<p>多 C 和 C++编译器都是在计算 expr 之后才提取 x 的值的，这就使得上述的惯用</p>
<p>法可以正常运转。尽管它可以正常运转，但是它仍然违背了 C/C++有关不能在两</p>
<p>个连续的序列点之间重复修改变量的规则。因此，这个惯用法的行为在 C 和 C++</p>
<p>中也没有明确定义。 </p>
<p>为了看重其价值，我们还是可以写出不用临时变量就可以互换两个变量内容的</p>
<p>Java 表达式的。但是它同样是丑陋而无用的： </p>
<p>// 杀鸡用牛刀的做法，千万不要这么做！</p>
<p>y = (x^= (y^= x))^ y ; </p>
<p>这个教训很简单：在单个的表达式中不要对相同的变量赋值两次。表达式如果包</p>
<p>含对相同变量的多次赋值，就会引起混乱，并且很少能够执行你希望的操作。即</p>
<p>使对多个变量进行赋值也很容易出错。更一般地讲，要避免所谓聪明的编程技巧。</p>
<p>它们都是易于产生 bug 的，很难以维护，并且运行速度经常是比它们所替代掉的</p>
<p>简单直观的代码要慢。 </p>
<p>语言设计者可能会考虑禁止在一个表达式中对相同的变量多次赋值，但是在一般</p>
<p>的情况下，强制执行这条禁令会因为别名机制的存在而显得很不灵活。例如，请</p>
<p>考虑表达式 x = a[i]++ - a[j]++，它是否递增了相同的变量两次呢？这取决于</p>
<p>在表达式被计算时 i 和 j 的值，并且编译器通常是无法确定这一点。 </p>
<h2 id="谜题-8：Dos-Equis-Dos-Equis-Dos-Equis"><a href="#谜题-8：Dos-Equis-Dos-Equis-Dos-Equis" class="headerlink" title="谜题 8：Dos Equis Dos Equis Dos Equis"></a>谜题 8：Dos Equis Dos Equis Dos Equis</h2><p>这个谜题将测试你对条件操作符的掌握程度，这个操作符有一个更广为人知的名</p>
<p>字：问号冒号操作符。下面的程序将会打印出什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DosEquis</span>&#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">char</span> x = <span class="string">'X'</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="literal">true</span> ? x : <span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="literal">false</span> ? i : x); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序由两个变量声明和两个 print 语句构成。第一个 print 语句计算条件表</p>
<p>达式(true ? x : 0)并打印出结果，这个结果是 char 类型变量 x 的值’X’。而</p>
<p>第二个 print 语句计算表达式(false ? i : x)并打印出结果，这个结果还是依</p>
<p>旧是’X’的 x，因此这个程序应该打印 XX。然而，如果你运行该程序，你就会</p>
<p>发现它打印出来的是 X88。这种行为看起来挺怪的。第一个 print 语句打印的是</p>
<p>X，而第二个打印的却是 88。它们的不同行为说明了什么呢？ </p>
<p>答案就在规范有关条件表达式部分的一个阴暗的角落里。请注意在这两个表达式</p>
<p>中，每一个表达式的第二个和第三个操作数的类型都不相同：x 是 char 类型的，</p>
<p>而 0 和 i 都是 int 类型的。就像在谜题 5 的解答中提到的，混合类型的计算会引</p>
<p>起混乱，而这一点比在条件表达式中比在其它任何地方都表现得更明显。你可能</p>
<p>考虑过，这个程序中两个条件表达式的结果类型是相同的，就像它们的操作数类</p>
<p>型是相同的一样，尽管操作数的顺序颠倒了一下，但是实际情况并非如此。 </p>
<p>确定条件表达式结果类型的规则过于冗长和复杂，很难完全记住它们，但是其核</p>
<p>心就是一下三点： </p>
<p>• 如果第二个和第三个操作数具有相同的类型，那么它就是条件表达式的类</p>
<p>型。换句话说，你可以通过绕过混合类型的计算来避免大麻烦。 </p>
<p>• 如果一个操作数的类型是 T，T 表示 byte、short 或 char，而另一个操作</p>
<p>数是一个 int 类型的常量表达式，它的值是可以用类型 T 表示的，那么条</p>
<p>件表达式的类型就是 T。 </p>
<p>• 否则，将对操作数类型运用二进制数字提升，而条件表达式的类型就是第</p>
<p>二个和第三个操作数被提升之后的类型。 </p>
<p>2、3 两点对本谜题是关键。在程序的两个条件表达式中，一个操作数的类型是</p>
<p>char，另一个的类型是 int。在两个表达式中，int 操作数都是 0，它可以被表</p>
<p>示成一个 char。然而，只有第一个表达式中的 int 操作数是常量（0），而第二</p>
<p>个表达式中的 int 操作数是变量（i）。因此，第 2 点被应用到了第一个表达式</p>
<p>上，它返回的类型是 char，而第 3 点被应用到了第二个表达式上，其返回的类</p>
<p>型是对 int 和 char 运用了二进制数字提升之后的类型，即 int。 </p>
<p>条件表达式的类型将确定哪一个重载的 print 方法将被调用。对第一个表达式来</p>
<p>说，PrintStream.print(char)将被调用，而对第二个表达式来说，</p>
<p>PrintStream.print(int)将被调用。前一个重载方法将变量 x 的值作为 Unicode</p>
<p>字符（X）来打印，而后一个重载方法将其作为一个十进制整数（88）来打印。</p>
<p>至此，谜题被解开了。 </p>
<p>总之，通常最好是在条件表达式中使用类型相同的第二和第三操作数。否则，你</p>
<p>和你的程序的读者必须要彻底理解这些表达式行为的复杂规范。 </p>
<p>对语言设计者来说，也许可以设计一个牺牲掉了部分灵活性，但是增加了简洁性</p>
<p>的条件操作符。例如，要求第二和第三操作数必须就有相同的类型，这看起来就</p>
<p>很合理。或者，条件操作符可以被定义为对常量没有任何特殊处理。为了让这些</p>
<p>选择对程序员来说更加容易接受，可以提供用来表示所有原始类型字面常量的语</p>
<p>法。这也许确实是一个好注意，因为它增加了语言的一致性和完备性，同时又减</p>
<p>少了对转型的需求。 </p>
<h2 id="谜题-9：半斤"><a href="#谜题-9：半斤" class="headerlink" title="谜题 9：半斤"></a>谜题 9：半斤</h2><p>现在该轮到你来写些代码了，好消息是，你只需为这个谜题编写两行代码，并为</p>
<p>下一个谜题也编写两行代码。这有什么难的呢？我们给出一个对变量 x 和 i 的声</p>
<p>明即可，它肯定是一个合法的语句： </p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">x +</span>=<span class="string"> i;</span></span><br></pre></td></tr></table></figure>

<p>但是，它并不是： </p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">x</span> = x + i<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>许多程序员都会认为该迷题中的第一个表达式（x += i）只是第二个表达式（x = </p>
<p>x + i）的简写方式。但是这并不十分准确。这两个表达式都被称为赋值表达式。</p>
<p>第二条语句使用的是简单赋值操作符（=），而第一条语句使用的是复合赋值操</p>
<p>作符。（复合赋值操作符包括 +=、-=、*=、/=、%=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=、&amp;=、^=</p>
<p>和|=）Java 语言规范中讲到，复合赋值 E1 op= E2 等价于简单赋值 E1 = </p>
<p>(T)((E1)op(E2))，其中 T 是 E1 的类型，除非 E1 只被计算一次。 </p>
<p>换句话说，复合赋值表达式自动地将它们所执行的计算的结果转型为其左侧变量</p>
<p>的类型。如果结果的类型与该变量的类型相同，那么这个转型不会造成任何影响。</p>
<p>然而，如果结果的类型比该变量的类型要宽，那么复合赋值操作符将悄悄地执行</p>
<p>一个窄化原始类型转换。因此，我们有很好的理由去解释为什么在尝试着执行等</p>
<p>价的简单赋值可能会产生一个编译错误。 </p>
<p>为了说得具体一些，并提供一个解决方案给这个谜题，假设我们在该谜题的两个</p>
<p>赋值表达式之前有下面这些声明： </p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">short x</span> = 0; </span><br><span class="line"></span><br><span class="line"><span class="attribute">int i</span> = 123456;</span><br></pre></td></tr></table></figure>

<p>复合赋值编译将不会产生任何错误： </p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">x</span> += i; <span class="comment">// 包含了一个隐藏的转型！</span></span><br></pre></td></tr></table></figure>

<p>你可能期望 x 的值在这条语句执行之后是 123,456，但是并非如此 l，它的值是</p>
<p>-7,616。int 类型的数值 123456 对于 short 来说太大了。自动产生的转型悄悄</p>
<p>地把 int 数值的高两位给截掉了。这也许就不是你想要的了。 </p>
<p>相对应的简单赋值是非法的，因为它试图将 int 数值赋值给 short 变量，它需要</p>
<p>一个显式的转型： </p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">x</span> = <span class="symbol">x</span> + i; <span class="comment">// 不要编译——“可能会丢掉精度”</span></span><br></pre></td></tr></table></figure>

<p>这应该是明显的，复合赋值表达式可能是很危险的。为了避免这种令人不快的突</p>
<p>袭，请不要将复合赋值操作符作用于 byte、short 或 char 类型的变量上。在将</p>
<p>复合赋值操作符作用于 int 类型的变量上时，要确保表达式右侧不是 long、float</p>
<p>或 double 类型。在将复合赋值操作符作用于 float 类型的变量上时，要确保表</p>
<p>达式右侧不是 double 类型。这些规则足以防止编译器产生危险的窄化转型。 </p>
<p>总之，复合赋值操作符会悄悄地产生一个转型。如果计算结果的类型宽于变量的</p>
<p>类型，那么所产生的转型就是一个危险的窄化转型。这样的转型可能会悄悄地丢</p>
<p>弃掉精度或数量值。对语言设计者来说，也许让复合赋值操作符产生一个不可见</p>
<p>的转型本身就是一个错误；对于在复合赋值中的变量类型比计算结果窄的情况，</p>
<p>也许应该让其非法才对。</p>
<h2 id="谜题-10：八两"><a href="#谜题-10：八两" class="headerlink" title="谜题 10：八两"></a>谜题 10：八两</h2><p>与上面的例子相反，如果我们给出的关于变量 x 和 i 的声明是如下的合法语句： </p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">x</span> = x + i<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>但是，它并不是： </p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">x +</span>=<span class="string"> i;</span></span><br></pre></td></tr></table></figure>

<p>乍一看，这个谜题可能看起来与前面一个谜题相同。但是请放心，它们并不一样。</p>
<p>这两个谜题在哪一条语句必是合法的，以及哪一条语句必是不合法的方面，正好</p>
<p>相反。 </p>
<p>就像前面的谜题一样，这个谜题也依赖于有关复合赋值操作符的规范中的细节。</p>
<p>二者的相似之处就此打住。基于前面的谜题，你可能会想：符合赋值操作符比简</p>
<p>单赋值操作符的限制要少一些。在一般情况下，这是对的，但是有这么一个领域，</p>
<p>在其中简单赋值操作符会显得更宽松一些。 </p>
<p>复合赋值操作符要求两个操作数都是原始类型的，例如 int，或包装了的原始类</p>
<p>型，例如 Integer，但是有一个例外：如果在+=操作符左侧的操作数是 String</p>
<p>类型的，那么它允许右侧的操作数是任意类型，在这种情况下，该操作符执行的</p>
<p>是字符串连接操作。简单赋值操作符（=）允许其左侧的是对象引用类型，这就</p>
<p>显得要宽松许多了：你可以使用它们来表示任何你想要表示的内容，只要表达式</p>
<p>的右侧与左侧的变量是赋值兼容的即可。 </p>
<p>你可以利用这一差异来解决该谜题。要想用 += 操作符来执行字符串连接操作，</p>
<p>你就必须将左侧的变量声明为 String 类型。通过使用直接赋值操作符，字符串</p>
<p>连接的结果可以存放到一个 Object 类型的变量中。 </p>
<p>为了说得具体一些，并提供一个解决方案给这个谜题，假设我们在该谜题的两个</p>
<p>赋值表达式之前有下面这些声明： </p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Object x</span> = <span class="string">"Buy "</span>; </span><br><span class="line"></span><br><span class="line"><span class="attribute">String i</span> = <span class="string">"Effective Java!"</span>;</span><br></pre></td></tr></table></figure>

<p>简单赋值是合法的，因为 x + i 是 String 类型的，而 String 类型又是与 Object</p>
<p>赋值兼容的： </p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">x</span> = x + i<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>复合赋值是非法的，因为左侧是一个 Object 引用类型，而右侧是一个 String</p>
<p>类型： </p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">x +</span>=<span class="string"> i;</span></span><br></pre></td></tr></table></figure>

<p>这个谜题对程序员来说几乎算不上什么教训。对语言设计者来说，加法的复合赋</p>
<p>值操作符应该在右侧是 String 类型的情况下，允许左侧是 Object 类型。这项修</p>
<p>改将根除这个谜题所展示的违背直觉的行为。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/20/java%E5%BC%82%E5%B8%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/20/java%E5%BC%82%E5%B8%B8/" class="post-title-link" itemprop="url">java异常处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-20 16:45:32 / 修改时间：16:55:10" itemprop="dateCreated datePublished" datetime="2021-03-20T16:45:32+08:00">2021-03-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java-异常处理"><a href="#Java-异常处理" class="headerlink" title="Java 异常处理"></a>Java 异常处理</h1><p>异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。</p>
<p>比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.Error；如果你用System.out.println(11/0)，那么你是因为你用0做了除数，会抛出 java.lang.ArithmeticException 的异常。</p>
<p>异常发生的原因有很多，通常包含以下几大类：</p>
<ul>
<li>用户输入了非法数据。</li>
<li>要打开的文件不存在。</li>
<li>网络通信时连接中断，或者JVM内存溢出。</li>
</ul>
<p>这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。-</p>
<p>要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：</p>
<ul>
<li><strong>检查性异常：</strong>最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li>
<li><strong>运行时异常：</strong> 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li>
<li><strong>错误：</strong> 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li>
</ul>
<hr>
<h2 id="Exception-类的层次"><a href="#Exception-类的层次" class="headerlink" title="Exception 类的层次"></a>Exception 类的层次</h2><p>所有的异常类是从 java.lang.Exception 类继承的子类。</p>
<p>Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。</p>
<p>Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。</p>
<p>Error 用来指示运行时环境发生的错误。</p>
<p>例如，JVM 内存溢出。一般地，程序不会从错误中恢复。</p>
<p>异常类有两个主要的子类：IOException 类和 RuntimeException 类。</p>
<p><img src="/2021/03/20/java%E5%BC%82%E5%B8%B8/12-130Q1234I6223.jpg" alt="img"></p>
<p>在 Java 内置类中(接下来会说明)，有大部分常用检查性和非检查性异常。</p>
<hr>
<h2 id="Java-内置异常类"><a href="#Java-内置异常类" class="headerlink" title="Java 内置异常类"></a>Java 内置异常类</h2><p>Java 语言定义了一些异常类在 java.lang 标准包中。</p>
<p>标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。</p>
<p>Java 根据各个类库也定义了一些其他的异常，下面的表中列出了 Java 的非检查性异常。</p>
<table>
<thead>
<tr>
<th align="left"><strong>异常</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">ArithmeticException</td>
<td align="left">当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。</td>
</tr>
<tr>
<td align="left">ArrayIndexOutOfBoundsException</td>
<td align="left">用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</td>
</tr>
<tr>
<td align="left">ArrayStoreException</td>
<td align="left">试图将错误类型的对象存储到一个对象数组时抛出的异常。</td>
</tr>
<tr>
<td align="left">ClassCastException</td>
<td align="left">当试图将对象强制转换为不是实例的子类时，抛出该异常。</td>
</tr>
<tr>
<td align="left">IllegalArgumentException</td>
<td align="left">抛出的异常表明向方法传递了一个不合法或不正确的参数。</td>
</tr>
<tr>
<td align="left">IllegalMonitorStateException</td>
<td align="left">抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。</td>
</tr>
<tr>
<td align="left">IllegalStateException</td>
<td align="left">在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。</td>
</tr>
<tr>
<td align="left">IllegalThreadStateException</td>
<td align="left">线程没有处于请求操作所要求的适当状态时抛出的异常。</td>
</tr>
<tr>
<td align="left">IndexOutOfBoundsException</td>
<td align="left">指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</td>
</tr>
<tr>
<td align="left">NegativeArraySizeException</td>
<td align="left">如果应用程序试图创建大小为负的数组，则抛出该异常。</td>
</tr>
<tr>
<td align="left">NullPointerException</td>
<td align="left">当应用程序试图在需要对象的地方使用 <code>null</code> 时，抛出该异常</td>
</tr>
<tr>
<td align="left">NumberFormatException</td>
<td align="left">当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</td>
</tr>
<tr>
<td align="left">SecurityException</td>
<td align="left">由安全管理器抛出的异常，指示存在安全侵犯。</td>
</tr>
<tr>
<td align="left">StringIndexOutOfBoundsException</td>
<td align="left">此异常由 <code>String</code> 方法抛出，指示索引或者为负，或者超出字符串的大小。</td>
</tr>
<tr>
<td align="left">UnsupportedOperationException</td>
<td align="left">当不支持请求的操作时，抛出该异常。</td>
</tr>
</tbody></table>
<p>下面的表中列出了 Java 定义在 java.lang 包中的检查性异常类。</p>
<table>
<thead>
<tr>
<th align="left"><strong>异常</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">ClassNotFoundException</td>
<td align="left">应用程序试图加载类时，找不到相应的类，抛出该异常。</td>
</tr>
<tr>
<td align="left">CloneNotSupportedException</td>
<td align="left">当调用 <code>Object</code> 类中的 <code>clone</code> 方法克隆对象，但该对象的类无法实现 <code>Cloneable</code> 接口时，抛出该异常。</td>
</tr>
<tr>
<td align="left">IllegalAccessException</td>
<td align="left">拒绝访问一个类的时候，抛出该异常。</td>
</tr>
<tr>
<td align="left">InstantiationException</td>
<td align="left">当试图使用 <code>Class</code> 类中的 <code>newInstance</code> 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。</td>
</tr>
<tr>
<td align="left">InterruptedException</td>
<td align="left">一个线程被另一个线程中断，抛出该异常。</td>
</tr>
<tr>
<td align="left">NoSuchFieldException</td>
<td align="left">请求的变量不存在</td>
</tr>
<tr>
<td align="left">NoSuchMethodException</td>
<td align="left">请求的方法不存在</td>
</tr>
</tbody></table>
<hr>
<h2 id="异常方法"><a href="#异常方法" class="headerlink" title="异常方法"></a>异常方法</h2><p>下面的列表是 Throwable 类的主要方法:</p>
<table>
<thead>
<tr>
<th align="left"><strong>序号</strong></th>
<th align="left"><strong>方法及说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>public String getMessage()</strong> 返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>public Throwable getCause()</strong> 返回一个Throwable 对象代表异常原因。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>public String toString()</strong> 使用getMessage()的结果返回类的串级名字。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>public void printStackTrace()</strong> 打印toString()结果和栈层次到System.err，即错误输出流。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>public StackTraceElement [] getStackTrace()</strong> 返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>public Throwable fillInStackTrace()</strong> 用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。</td>
</tr>
</tbody></table>
<hr>
<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。</p>
<p>try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ExceptionName e1)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//Catch 块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。</p>
<p>如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面的例子中声明有两个元素的一个数组，当代码试图访问数组的第三个元素的时候就会抛出一个异常。</p>
<h2 id="ExcepTest-java-文件代码："><a href="#ExcepTest-java-文件代码：" class="headerlink" title="ExcepTest.java 文件代码："></a>ExcepTest.java 文件代码：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名 : ExcepTest.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcepTest</span>&#123;</span></span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span> args[])</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">         System.out.<span class="built_in">println</span>(<span class="string">"Access element three :"</span> + a[<span class="number">3</span>]);</span><br><span class="line">      &#125;<span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">         System.out.<span class="built_in">println</span>(<span class="string">"Exception thrown  :"</span> + e);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.<span class="built_in">println</span>(<span class="string">"Out of the block"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码编译运行输出结果如下：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Exception</span> thrown  :java.lang.ArrayIndexOutOfBoundsException: <span class="number">3</span></span><br><span class="line"><span class="keyword">Out</span> <span class="keyword">of</span> the block</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="多重捕获块"><a href="#多重捕获块" class="headerlink" title="多重捕获块"></a>多重捕获块</h2><p>一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。</p>
<p>多重捕获块的语法如下所示：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 异常的变量名<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">3</span> 异常的变量名<span class="number">3</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码段包含了 3 个 catch块。</p>
<p>可以在 try 语句后面添加任意数量的 catch 块。</p>
<p>如果保护代码中发生异常，异常被抛给第一个 catch 块。</p>
<p>如果抛出异常的数据类型与 ExceptionType1 匹配，它在这里就会被捕获。</p>
<p>如果不匹配，它会被传递给第二个 catch 块。</p>
<p>如此，直到异常被捕获或者通过所有的 catch 块。</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>该实例展示了怎么使用多重 try/catch。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">file</span> = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">    x = (<span class="keyword">byte</span>) <span class="keyword">file</span>.<span class="keyword">read</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span>(FileNotFoundException f) &#123; <span class="comment">// Not valid!</span></span><br><span class="line">    f.printStackTrace();</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException i) &#123;</span><br><span class="line">    i.printStackTrace();</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="throws-throw-关键字："><a href="#throws-throw-关键字：" class="headerlink" title="throws/throw 关键字："></a>throws/throw 关键字：</h2><p>如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。</p>
<p>也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。</p>
<p>下面方法的声明抛出一个 RemoteException 异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">className</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> RemoteException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// Method implementation</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Remainder of class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。</p>
<p>例如，下面的方法声明抛出 RemoteException 和 InsufficientFundsException：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">className</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> RemoteException,</span></span><br><span class="line"><span class="function">                              InsufficientFundsException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="comment">// Method implementation</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//Remainder of class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h2><p>finally 关键字用来创建在 try 代码块后面执行的代码块。</p>
<p>无论是否发生异常，finally 代码块中的代码总会被执行。</p>
<p>在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。</p>
<p>finally 代码块出现在 catch 代码块最后，语法如下：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 异常的变量名<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;finally&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><h2 id="ExcepTest-java-文件代码：-1"><a href="#ExcepTest-java-文件代码：-1" class="headerlink" title="ExcepTest.java 文件代码："></a>ExcepTest.java 文件代码：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcepTest</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span> args[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">       System.out.<span class="built_in">println</span>(<span class="string">"Access element three :"</span> + a[<span class="number">3</span>]);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">       System.out.<span class="built_in">println</span>(<span class="string">"Exception thrown  :"</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">    finally&#123;</span><br><span class="line">       a[<span class="number">0</span>] = <span class="number">6</span>;</span><br><span class="line">       System.out.<span class="built_in">println</span>(<span class="string">"First element value: "</span> +a[<span class="number">0</span>]);</span><br><span class="line">       System.out.<span class="built_in">println</span>(<span class="string">"The finally statement is executed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例编译运行结果如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="string">thrown  :</span>java.lang.<span class="string">ArrayIndexOutOfBoundsException:</span> <span class="number">3</span></span><br><span class="line">First element <span class="string">value:</span> <span class="number">6</span></span><br><span class="line">The <span class="keyword">finally</span> statement is executed</span><br></pre></td></tr></table></figure>

<p>注意下面事项：</p>
<ul>
<li>catch 不能独立于 try 存在。</li>
<li>在 try/catch 后面添加 finally 块并非强制性要求的。</li>
<li>try 代码后不能既没 catch 块也没 finally 块。</li>
<li>try, catch, finally 块之间不能添加任何代码。</li>
</ul>
<hr>
<h2 id="声明自定义异常"><a href="#声明自定义异常" class="headerlink" title="声明自定义异常"></a>声明自定义异常</h2><p>在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。</p>
<ul>
<li>所有异常都必须是 Throwable 的子类。</li>
<li>如果希望写一个检查性异常类，则需要继承 Exception 类。</li>
<li>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。</li>
</ul>
<p>可以像下面这样定义自己的异常类：</p>
<p>class MyException extends Exception{ }</p>
<p>只继承Exception 类来创建的异常类是检查性异常类。</p>
<p>下面的 InsufficientFundsException 类是用户定义的异常类，它继承自 Exception。</p>
<p>一个异常类和其它任何类一样，包含有变量和方法。</p>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>以下实例是一个银行账户的模拟，通过银行卡的号码完成识别，可以进行存钱和取钱的操作。</p>
<h2 id="InsufficientFundsException-java-文件代码："><a href="#InsufficientFundsException-java-文件代码：" class="headerlink" title="InsufficientFundsException.java 文件代码："></a>InsufficientFundsException.java 文件代码：</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名InsufficientFundsException.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//自定义异常类，继承Exception类</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">InsufficientFundsException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="comment">//此处的amount用来储存当出现异常（取出钱多于余额时）所缺乏的钱</span></span><br><span class="line">  <span class="keyword">private</span> double amount;</span><br><span class="line">  public <span class="type">InsufficientFundsException</span>(double amount)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">this</span>.amount = amount;</span><br><span class="line">  &#125; </span><br><span class="line">  public double getAmount()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> amount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了展示如何使用我们自定义的异常类，</p>
<p>在下面的 CheckingAccount 类中包含一个 withdraw() 方法抛出一个 InsufficientFundsException 异常。</p>
<h2 id="CheckingAccount-java-文件代码："><a href="#CheckingAccount-java-文件代码：" class="headerlink" title="CheckingAccount.java 文件代码："></a>CheckingAccount.java 文件代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名称 CheckingAccount.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//此类模拟银行账户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckingAccount</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="comment">//balance为余额，number为卡号</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CheckingAccount</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.number = number;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">//方法：存钱</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> amount)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      balance += amount;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">//方法：取钱</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">                              InsufficientFundsException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(amount &lt;= balance)</span><br><span class="line">      &#123;</span><br><span class="line">         balance -= amount;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">double</span> needs = amount - balance;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFundsException(needs);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">//方法：返回余额</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> balance;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">//方法：返回卡号</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> number;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的 BankDemo 程序示范了如何调用 CheckingAccount 类的 deposit() 和 withdraw() 方法。</p>
<h2 id="BankDemo-java-文件代码："><a href="#BankDemo-java-文件代码：" class="headerlink" title="BankDemo.java 文件代码："></a>BankDemo.java 文件代码：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名称 BankDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankDemo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span> [] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      CheckingAccount c = <span class="keyword">new</span> CheckingAccount(<span class="number">101</span>);</span><br><span class="line">      System.out.<span class="built_in">println</span>(<span class="string">"Depositing $500..."</span>);</span><br><span class="line">      c.deposit(<span class="number">500.00</span>);</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         System.out.<span class="built_in">println</span>(<span class="string">"\nWithdrawing $100..."</span>);</span><br><span class="line">         c.withdraw(<span class="number">100.00</span>);</span><br><span class="line">         System.out.<span class="built_in">println</span>(<span class="string">"\nWithdrawing $600..."</span>);</span><br><span class="line">         c.withdraw(<span class="number">600.00</span>);</span><br><span class="line">      &#125;<span class="keyword">catch</span>(InsufficientFundsException e)</span><br><span class="line">      &#123;</span><br><span class="line">         System.out.<span class="built_in">println</span>(<span class="string">"Sorry, but you are short $"</span></span><br><span class="line">                                  + e.getAmount());</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译上面三个文件，并运行程序 BankDemo，得到结果如下所示：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Depositing</span></span> <span class="symbol">$</span><span class="number">500.</span>..</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">Withdrawing</span></span> <span class="symbol">$</span><span class="number">100.</span>..</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">Withdrawing</span></span> <span class="symbol">$</span><span class="number">600.</span>..</span><br><span class="line">Sorry, but you are short <span class="symbol">$</span><span class="number">200.0</span></span><br><span class="line">InsufficientFundsException</span><br><span class="line">        at CheckingAccount.withdraw(CheckingAccount.java:<span class="number">25</span>)</span><br><span class="line">        at BankDemo.main(BankDemo.java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="通用异常"><a href="#通用异常" class="headerlink" title="通用异常"></a>通用异常</h2><p>在Java中定义了两种类型的异常和错误。</p>
<ul>
<li><strong>JVM(Java**</strong>虚拟机<strong>**)</strong> <strong>异常：</strong>由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。</li>
<li><strong>程序级异常：</strong>由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/20/javaScanner%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/20/javaScanner%E7%B1%BB/" class="post-title-link" itemprop="url">javaScanner类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-20 16:43:26 / 修改时间：16:45:14" itemprop="dateCreated datePublished" datetime="2021-03-20T16:43:26+08:00">2021-03-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java-Scanner-类"><a href="#Java-Scanner-类" class="headerlink" title="Java Scanner 类"></a>Java Scanner 类</h1><p>java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。</p>
<p>下面是创建 Scanner 对象的基本语法：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner s = <span class="keyword">new</span> <span class="constructor">Scanner(System.<span class="params">in</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>接下来我们演示一个最简单的数据输入，并通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据：</p>
<h3 id="使用-next-方法："><a href="#使用-next-方法：" class="headerlink" title="使用 next 方法："></a>使用 next 方法：</h3><h2 id="ScannerDemo-java-文件代码："><a href="#ScannerDemo-java-文件代码：" class="headerlink" title="ScannerDemo.java 文件代码："></a>ScannerDemo.java 文件代码：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScannerDemo</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">// 从键盘接收数据</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// next方式接收字符串</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"next方式接收："</span>);</span><br><span class="line">        <span class="comment">// 判断是否还有输入</span></span><br><span class="line">        <span class="keyword">if</span> (scan.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">String</span> str1 = scan.next();</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"输入的数据为："</span> + str1);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上程序输出结果为：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">javac </span><span class="keyword">ScannerDemo.java</span></span><br><span class="line"><span class="keyword">$ </span><span class="keyword">java </span><span class="keyword">ScannerDemo</span></span><br><span class="line"><span class="keyword">next方式接收：</span></span><br><span class="line"><span class="keyword">runoob </span>com</span><br><span class="line">输入的数据为：runoob</span><br></pre></td></tr></table></figure>

<p>可以看到 com 字符串并未输出，接下来我们看 nextLine。</p>
<h3 id="使用-nextLine-方法："><a href="#使用-nextLine-方法：" class="headerlink" title="使用 nextLine 方法："></a>使用 nextLine 方法：</h3><h2 id="ScannerDemo-java-文件代码：-1"><a href="#ScannerDemo-java-文件代码：-1" class="headerlink" title="ScannerDemo.java 文件代码："></a>ScannerDemo.java 文件代码：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScannerDemo</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">// 从键盘接收数据</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// nextLine方式接收字符串</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"nextLine方式接收："</span>);</span><br><span class="line">        <span class="comment">// 判断是否还有输入</span></span><br><span class="line">        <span class="keyword">if</span> (scan.hasNextLine()) &#123;</span><br><span class="line">            <span class="keyword">String</span> str2 = scan.nextLine();</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"输入的数据为："</span> + str2);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上程序输出结果为：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">javac </span><span class="keyword">ScannerDemo.java</span></span><br><span class="line"><span class="keyword">$ </span><span class="keyword">java </span><span class="keyword">ScannerDemo</span></span><br><span class="line"><span class="keyword">nextLine方式接收：</span></span><br><span class="line"><span class="keyword">runoob </span>com</span><br><span class="line">输入的数据为：runoob com</span><br></pre></td></tr></table></figure>

<p>可以看到 com 字符串输出。</p>
<h3 id="next-与-nextLine-区别"><a href="#next-与-nextLine-区别" class="headerlink" title="next() 与 nextLine() 区别"></a>next() 与 nextLine() 区别</h3><p>next():</p>
<ul>
<li>1、一定要读取到有效字符后才可以结束输入。</li>
<li>2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。</li>
<li>3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li>
<li>next() 不能得到带有空格的字符串。</li>
</ul>
<p>nextLine()：</p>
<ul>
<li>1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。</li>
<li>2、可以获得空白。</li>
</ul>
<p>如果要输入 int 或 float 类型的数据，在 Scanner 类中也有支持，但是在输入之前最好先使用 hasNextXxx() 方法进行验证，再使用 nextXxx() 来读取：</p>
<h2 id="ScannerDemo-java-文件代码：-2"><a href="#ScannerDemo-java-文件代码：-2" class="headerlink" title="ScannerDemo.java 文件代码："></a>ScannerDemo.java 文件代码：</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"> </span><br><span class="line">public <span class="keyword">class</span> ScannerDemo &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> <span class="constructor">Scanner(System.<span class="params">in</span>)</span>;</span><br><span class="line">        <span class="comment">// 从键盘接收数据</span></span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">float</span> f = <span class="number">0.0</span>f;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print(<span class="string">"输入整数："</span>);</span><br><span class="line">        <span class="keyword">if</span> (scan.has<span class="constructor">NextInt()</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断输入的是否是整数</span></span><br><span class="line">            i = scan.next<span class="constructor">Int()</span>;</span><br><span class="line">            <span class="comment">// 接收整数</span></span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"整数数据："</span> + i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 输入错误的信息</span></span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"输入的不是整数！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print(<span class="string">"输入小数："</span>);</span><br><span class="line">        <span class="keyword">if</span> (scan.has<span class="constructor">NextFloat()</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断输入的是否是小数</span></span><br><span class="line">            f = scan.next<span class="constructor">Float()</span>;</span><br><span class="line">            <span class="comment">// 接收小数</span></span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"小数数据："</span> + f);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 输入错误的信息</span></span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"输入的不是小数！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上程序输出结果为：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ javac ScannerDemo.java</span><br><span class="line">$ java ScannerDemo</span><br><span class="line">输入整数：<span class="number">12</span></span><br><span class="line">整数数据：<span class="number">12</span></span><br><span class="line">输入小数：<span class="number">1.2</span></span><br><span class="line">小数数据：<span class="number">1.2</span></span><br></pre></td></tr></table></figure>

<p>以下实例我们可以输入多个数字，并求其总和与平均数，每输入一个数字用回车确认，通过输入非数字来结束输入并输出执行结果：</p>
<h2 id="ScannerDemo-java-文件代码：-3"><a href="#ScannerDemo-java-文件代码：-3" class="headerlink" title="ScannerDemo.java 文件代码："></a>ScannerDemo.java 文件代码：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunoobTest</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"请输入数字："</span>);</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> (scan.hasNextDouble()) &#123;</span><br><span class="line">            <span class="keyword">double</span> x = scan.nextDouble();</span><br><span class="line">            m = m + <span class="number">1</span>;</span><br><span class="line">            sum = sum + x;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.<span class="built_in">println</span>(m + <span class="string">"个数的和为"</span> + sum);</span><br><span class="line">        System.out.<span class="built_in">println</span>(m + <span class="string">"个数的平均值是"</span> + (sum / m));</span><br><span class="line">        scan.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上程序输出结果为（输入非数字来结束输入）：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ javac ScannerDemo.java</span><br><span class="line">$ java ScannerDemo</span><br><span class="line">请输入数字：</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">21.4</span></span><br><span class="line">end</span><br><span class="line"><span class="number">4</span>个数的和为<span class="number">71.4</span></span><br><span class="line"><span class="number">4</span>个数的平均值是<span class="number">17.85</span></span><br></pre></td></tr></table></figure>

<p>更多内容可以参考 API 文档：<a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html。" target="_blank" rel="noopener">https://www.runoob.com/manual/jdk11api/java.base/java/util/Scanner.html。</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/20/java%E6%B5%81%E3%80%81%E6%96%87%E4%BB%B6%E5%92%8CIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/20/java%E6%B5%81%E3%80%81%E6%96%87%E4%BB%B6%E5%92%8CIO/" class="post-title-link" itemprop="url">java流(Stream)、文件(File)和IO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-20 16:37:43 / 修改时间：16:43:10" itemprop="dateCreated datePublished" datetime="2021-03-20T16:37:43+08:00">2021-03-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java-流-Stream-、文件-File-和IO"><a href="#Java-流-Stream-、文件-File-和IO" class="headerlink" title="Java 流(Stream)、文件(File)和IO"></a>Java 流(Stream)、文件(File)和IO</h1><p>Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。</p>
<p>Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。</p>
<p>一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。</p>
<p>Java 为 I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。</p>
<p>但本节讲述最基本的和流与 I/O 相关的功能。我们将通过一个个例子来学习这些功能。</p>
<hr>
<h2 id="读取控制台输入"><a href="#读取控制台输入" class="headerlink" title="读取控制台输入"></a>读取控制台输入</h2><p>Java 的控制台输入由 System.in 完成。</p>
<p>为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。</p>
<p>下面是创建 BufferedReader 的基本语法：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> <span class="type">BufferedReader</span>(<span class="keyword">new</span>                       <span class="type">InputStreamReader</span>(System.<span class="keyword">in</span>));</span><br></pre></td></tr></table></figure>

<p>BufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符，或者用 readLine() 方法读取一个字符串。</p>
<hr>
<h2 id="从控制台读取多字符输入"><a href="#从控制台读取多字符输入" class="headerlink" title="从控制台读取多字符输入"></a>从控制台读取多字符输入</h2><p>从 BufferedReader 对象读取一个字符要使用 read() 方法，它的语法如下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">read</span>( ) <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<p>每次调用 read() 方法，它从输入流读取一个字符并把该字符作为整数值返回。 当流结束的时候返回 -1。该方法抛出 IOException。</p>
<p>下面的程序示范了用 read() 方法从控制台不断读取字符直到用户输入 <strong>q</strong>。</p>
<h2 id="BRRead-java-文件代码："><a href="#BRRead-java-文件代码：" class="headerlink" title="BRRead.java 文件代码："></a>BRRead.java 文件代码：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 BufferedReader 在控制台读取字符</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BRRead</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws IOException </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="comment">// 使用 System.in 创建 BufferedReader</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"输入字符, 按下 'q' 键退出。"</span>);</span><br><span class="line">        <span class="comment">// 读取字符</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            c = (<span class="keyword">char</span>) br.<span class="built_in">read</span>();</span><br><span class="line">            System.out.<span class="built_in">println</span>(c);</span><br><span class="line">        &#125; <span class="keyword">while</span> (c != <span class="string">'q'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例编译运行结果如下:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入字符, 按下 <span class="string">'q'</span> 键退出。</span><br><span class="line">runoob</span><br><span class="line">r</span><br><span class="line">u</span><br><span class="line">n</span><br><span class="line">o</span><br><span class="line">o</span><br><span class="line">b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">q</span><br><span class="line">q</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="从控制台读取字符串"><a href="#从控制台读取字符串" class="headerlink" title="从控制台读取字符串"></a>从控制台读取字符串</h2><p>从标准输入读取一个字符串需要使用 BufferedReader 的 readLine() 方法。</p>
<p>它的一般格式是：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> readLine( ) <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<p>下面的程序读取和显示字符行直到你输入了单词”end”。</p>
<h2 id="BRReadLines-java-文件代码："><a href="#BRReadLines-java-文件代码：" class="headerlink" title="BRReadLines.java 文件代码："></a>BRReadLines.java 文件代码：</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 BufferedReader 在控制台读取字符</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> class BRReadLines &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用 System.in 创建 BufferedReader</span></span><br><span class="line">        <span class="keyword">BufferedReader</span> br = <span class="keyword">new</span> <span class="keyword">BufferedReader</span>(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">String</span> <span class="built_in">str</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Enter lines of text."</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Enter 'end' to quit."</span>);</span><br><span class="line">        do &#123;</span><br><span class="line">            <span class="built_in">str</span> = br.readLine();</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!<span class="built_in">str</span>.equals(<span class="string">"end"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例编译运行结果如下:</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Enter <span class="keyword">lines</span> <span class="keyword">of</span> <span class="keyword">text</span>.</span><br><span class="line">Enter <span class="string">'end'</span> <span class="built_in">to</span> quit.</span><br><span class="line">This is <span class="built_in">line</span> <span class="literal">one</span></span><br><span class="line">This is <span class="built_in">line</span> <span class="literal">one</span></span><br><span class="line">This is <span class="built_in">line</span> <span class="literal">two</span></span><br><span class="line">This is <span class="built_in">line</span> <span class="literal">two</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>JDK 5 后的版本我们也可以使用 <a href="https://www.runoob.com/java/java-scanner-class.html" target="_blank" rel="noopener">Java Scanner</a> 类来获取控制台的输入。</p>
</blockquote>
<h2 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h2><p>在此前已经介绍过，控制台的输出由 print( ) 和 println() 完成。这些方法都由类 PrintStream 定义，System.out 是该类对象的一个引用。</p>
<p>PrintStream 继承了 OutputStream类，并且实现了方法 write()。这样，write() 也可以用来往控制台写操作。</p>
<p>PrintStream 定义 write() 的最简单格式如下所示：</p>
<p>void write(int byteval)</p>
<p>该方法将 byteval 的低八位字节写到流中。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面的例子用 write() 把字符 “A” 和紧跟着的换行符输出到屏幕：</p>
<h2 id="WriteDemo-java-文件代码："><a href="#WriteDemo-java-文件代码：" class="headerlink" title="WriteDemo.java 文件代码："></a>WriteDemo.java 文件代码：</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line">//演示 <span class="keyword">System</span>.<span class="keyword">out</span>.<span class="keyword">write</span>().</span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> WriteDemo &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        b = <span class="string">'A'</span>;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.<span class="keyword">write</span>(b);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.<span class="keyword">write</span>(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>System.out.write(‘\n’);    } }</p>
<p>运行以上实例在输出窗口输出 “A” 字符</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">A</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>write() 方法不经常使用，因为 print() 和 println() 方法用起来更为方便。</p>
<hr>
<h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><p>如前所述，一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。</p>
<p>下图是一个描述输入流和输出流的类层次图。</p>
<p><img src="/2021/03/20/java%E6%B5%81%E3%80%81%E6%96%87%E4%BB%B6%E5%92%8CIO/iostream2xx.png" alt="img"></p>
<p>下面将要讨论的两个重要的流是 FileInputStream 和 FileOutputStream：</p>
<hr>
<h2 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h2><p>该流用于从文件读取数据，它的对象可以用关键字 new 来创建。</p>
<p>有多种构造方法可用来创建对象。</p>
<p>可以使用字符串类型的文件名来创建一个输入流对象来读取文件：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">InputStream f</span> = new FileInputStream(<span class="string">"C:/java/hello"</span>);</span><br></pre></td></tr></table></figure>

<p>也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> <span class="constructor">File(<span class="string">"C:/java/hello"</span>)</span>; </span><br><span class="line">InputStream out = <span class="keyword">new</span> <span class="constructor">FileInputStream(<span class="params">f</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>创建了InputStream对象，就可以使用下面的方法来读取流或者进行其他的流操作。</p>
<table>
<thead>
<tr>
<th align="left"><strong>序号</strong></th>
<th align="left"><strong>方法及描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>public void close() throws IOException{}</strong> 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>protected void finalize()throws IOException {}</strong> 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>public int read(int r)throws IOException{}</strong> 这个方法从 InputStream 对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>public int read(byte[] r) throws IOException{}</strong> 这个方法从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>public int available() throws IOException{}</strong> 返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。</td>
</tr>
</tbody></table>
<p>除了 InputStream 外，还有一些其他的输入流，更多的细节参考下面链接：</p>
<ul>
<li><a href="https://www.runoob.com/java/java-bytearrayinputstream.html" target="_blank" rel="noopener">ByteArrayInputStream</a></li>
<li><a href="https://www.runoob.com/java/java-datainputstream.html" target="_blank" rel="noopener">DataInputStream</a></li>
</ul>
<hr>
<h2 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h2><p>该类用来创建一个文件并向文件中写数据。</p>
<p>如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。</p>
<p>有两个构造方法可以用来创建 FileOutputStream 对象。</p>
<p>使用字符串类型的文件名来创建一个输出流对象：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OutputStream f = <span class="keyword">new</span> <span class="type">FileOutputStream</span>(<span class="string">"C:/java/hello"</span>)</span><br></pre></td></tr></table></figure>

<p>也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> <span class="constructor">File(<span class="string">"C:/java/hello"</span>)</span>; </span><br><span class="line">OutputStream f = <span class="keyword">new</span> <span class="constructor">FileOutputStream(<span class="params">f</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>创建OutputStream 对象完成后，就可以使用下面的方法来写入流或者进行其他的流操作。</p>
<table>
<thead>
<tr>
<th align="left"><strong>序号</strong></th>
<th align="left"><strong>方法及描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>public void close() throws IOException{}</strong> 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>protected void finalize()throws IOException {}</strong> 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>public void write(int w)throws IOException{}</strong> 这个方法把指定的字节写到输出流中。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>public void write(byte[] w)</strong> 把指定数组中w.length长度的字节写到OutputStream中。</td>
</tr>
</tbody></table>
<p>除了OutputStream外，还有一些其他的输出流，更多的细节参考下面链接：</p>
<ul>
<li><a href="https://www.runoob.com/java/java-bytearrayoutputstream.html" target="_blank" rel="noopener">ByteArrayOutputStream</a></li>
<li><a href="https://www.runoob.com/java/java-dataoutputstream.html" target="_blank" rel="noopener">DataOutputStream</a></li>
</ul>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>下面是一个演示 InputStream 和 OutputStream 用法的例子：</p>
<h2 id="fileStreamTest-java-文件代码："><a href="#fileStreamTest-java-文件代码：" class="headerlink" title="fileStreamTest.java 文件代码："></a>fileStreamTest.java 文件代码：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fileStreamTest</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span> bWrite[] = &#123; <span class="number">11</span>, <span class="number">21</span>, <span class="number">3</span>, <span class="number">40</span>, <span class="number">5</span> &#125;;</span><br><span class="line">            OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">"test.txt"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; bWrite.length; x++) &#123;</span><br><span class="line">                os.<span class="built_in">write</span>(bWrite[x]); <span class="comment">// writes the bytes</span></span><br><span class="line">            &#125;</span><br><span class="line">            os.<span class="built_in">close</span>();</span><br><span class="line"> </span><br><span class="line">            InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>);</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = is.<span class="built_in">available</span>();</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">                System.out.<span class="built_in">print</span>((<span class="keyword">char</span>) is.<span class="built_in">read</span>() + <span class="string">"  "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            is.<span class="built_in">close</span>();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(<span class="string">"Exception"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序首先创建文件test.txt，并把给定的数字以二进制形式写进该文件，同时输出到控制台上。</p>
<p>以上代码由于是二进制写入，可能存在乱码，你可以使用以下代码实例来解决乱码问题：</p>
<h2 id="fileStreamTest2-java-文件代码："><a href="#fileStreamTest2-java-文件代码：" class="headerlink" title="fileStreamTest2.java 文件代码："></a>fileStreamTest2.java 文件代码：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名 :fileStreamTest2.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fileStreamTest2</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws IOException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">File</span> f = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"a.txt"</span>);</span><br><span class="line">        FileOutputStream fop = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">        <span class="comment">// 构建FileOutputStream对象,文件不存在会自动新建</span></span><br><span class="line"> </span><br><span class="line">        OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(fop, <span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="comment">// 构建OutputStreamWriter对象,参数可以指定编码,默认为操作系统默认编码,windows上是gbk</span></span><br><span class="line"> </span><br><span class="line">        writer.append(<span class="string">"中文输入"</span>);</span><br><span class="line">        <span class="comment">// 写入到缓冲区</span></span><br><span class="line"> </span><br><span class="line">        writer.append(<span class="string">"\r\n"</span>);</span><br><span class="line">        <span class="comment">// 换行</span></span><br><span class="line"> </span><br><span class="line">        writer.append(<span class="string">"English"</span>);</span><br><span class="line">        <span class="comment">// 刷新缓存冲,写入到文件,如果下面已经没有写入的内容了,直接close也会写入</span></span><br><span class="line"> </span><br><span class="line">        writer.<span class="built_in">close</span>();</span><br><span class="line">        <span class="comment">// 关闭写入流,同时会把缓冲区内容写入文件,所以上面的注释掉</span></span><br><span class="line"> </span><br><span class="line">        fop.<span class="built_in">close</span>();</span><br><span class="line">        <span class="comment">// 关闭输出流,释放系统资源</span></span><br><span class="line"> </span><br><span class="line">        FileInputStream fip = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">        <span class="comment">// 构建FileInputStream对象</span></span><br><span class="line"> </span><br><span class="line">        InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(fip, <span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="comment">// 构建InputStreamReader对象,编码与写入相同</span></span><br><span class="line"> </span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (reader.<span class="built_in">ready</span>()) &#123;</span><br><span class="line">            sb.append((<span class="keyword">char</span>) reader.<span class="built_in">read</span>());</span><br><span class="line">            <span class="comment">// 转成char加到StringBuffer对象中</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.<span class="built_in">println</span>(sb.toString());</span><br><span class="line">        reader.<span class="built_in">close</span>();</span><br><span class="line">        <span class="comment">// 关闭读取流</span></span><br><span class="line"> </span><br><span class="line">        fip.<span class="built_in">close</span>();</span><br><span class="line">        <span class="comment">// 关闭输入流,释放系统资源</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="文件和I-O"><a href="#文件和I-O" class="headerlink" title="文件和I/O"></a>文件和I/O</h2><p>还有一些关于文件和I/O的类，我们也需要知道：</p>
<ul>
<li><a href="https://www.runoob.com/java/java-file.html" target="_blank" rel="noopener">File Class(类)</a></li>
<li><a href="https://www.runoob.com/java/java-filereader.html" target="_blank" rel="noopener">FileReader Class(类)</a></li>
<li><a href="https://www.runoob.com/java/java-filewriter.html" target="_blank" rel="noopener">FileWriter Class(类)</a></li>
</ul>
<hr>
<h2 id="Java中的目录"><a href="#Java中的目录" class="headerlink" title="Java中的目录"></a>Java中的目录</h2><h3 id="创建目录："><a href="#创建目录：" class="headerlink" title="创建目录："></a>创建目录：</h3><p>File类中有两个方法可以用来创建文件夹：</p>
<ul>
<li><strong>mkdir( )</strong>方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。</li>
<li><strong>mkdirs()</strong>方法创建一个文件夹和它的所有父文件夹。</li>
</ul>
<p>下面的例子创建 “/tmp/user/java/bin”文件夹：</p>
<h2 id="CreateDir-java-文件代码："><a href="#CreateDir-java-文件代码：" class="headerlink" title="CreateDir.java 文件代码："></a>CreateDir.java 文件代码：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.<span class="built_in">File</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateDir</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> dirname = <span class="string">"/tmp/user/java/bin"</span>;</span><br><span class="line">        <span class="built_in">File</span> d = <span class="keyword">new</span> <span class="built_in">File</span>(dirname);</span><br><span class="line">        <span class="comment">// 现在创建目录</span></span><br><span class="line">        d.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并执行上面代码来创建目录 “/tmp/user/java/bin”。</p>
<p><strong>注意：</strong> Java 在 UNIX 和 Windows 自动按约定分辨文件路径分隔符。如果你在 Windows 版本的 Java 中使用分隔符 (/) ，路径依然能够被正确解析。</p>
<hr>
<h2 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h2><p>一个目录其实就是一个 File 对象，它包含其他文件和文件夹。</p>
<p>如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory() 方法会返回 true。</p>
<p>可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。</p>
<p>下面展示的例子说明如何使用 list() 方法来检查一个文件夹中包含的内容：</p>
<h2 id="DirList-java-文件代码："><a href="#DirList-java-文件代码：" class="headerlink" title="DirList.java 文件代码："></a>DirList.java 文件代码：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.<span class="built_in">File</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span> args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> dirname = <span class="string">"/tmp"</span>;</span><br><span class="line">        <span class="built_in">File</span> f1 = <span class="keyword">new</span> <span class="built_in">File</span>(dirname);</span><br><span class="line">        <span class="keyword">if</span> (f1.<span class="built_in">isDirectory</span>()) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"目录 "</span> + dirname);</span><br><span class="line">            <span class="keyword">String</span> s[] = f1.<span class="built_in">list</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">                <span class="built_in">File</span> f = <span class="keyword">new</span> <span class="built_in">File</span>(dirname + <span class="string">"/"</span> + s[i]);</span><br><span class="line">                <span class="keyword">if</span> (f.<span class="built_in">isDirectory</span>()) &#123;</span><br><span class="line">                    System.out.<span class="built_in">println</span>(s[i] + <span class="string">" 是一个目录"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.<span class="built_in">println</span>(s[i] + <span class="string">" 是一个文件"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(dirname + <span class="string">" 不是一个目录"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例编译运行结果如下：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">目录 /tmp</span><br><span class="line">bin 是一个目录</span><br><span class="line"><span class="class"><span class="keyword">lib</span> 是一个目录</span></span><br><span class="line">demo 是一个目录</span><br><span class="line">test.txt 是一个文件</span><br><span class="line">README 是一个文件</span><br><span class="line">index.html 是一个文件</span><br><span class="line"><span class="keyword">include</span> 是一个目录</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="删除目录或文件"><a href="#删除目录或文件" class="headerlink" title="删除目录或文件"></a>删除目录或文件</h2><p>删除文件可以使用 <strong>java.io.File.delete()</strong> 方法。</p>
<p>以下代码会删除目录 <strong>/tmp/java/</strong>，需要注意的是当删除某一目录时，必须保证该目录下没有其他文件才能正确删除，否则将删除失败。</p>
<p>测试目录结构：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/tmp/java/</span><br><span class="line"><span class="string">|-- 1.log</span></span><br><span class="line"><span class="string">|-- test</span></span><br></pre></td></tr></table></figure>

<h2 id="DeleteFileDemo-java-文件代码："><a href="#DeleteFileDemo-java-文件代码：" class="headerlink" title="DeleteFileDemo.java 文件代码："></a>DeleteFileDemo.java 文件代码：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.<span class="built_in">File</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteFileDemo</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里修改为自己的测试目录</span></span><br><span class="line">        <span class="built_in">File</span> folder = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"/tmp/java/"</span>);</span><br><span class="line">        deleteFolder(folder);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 删除文件及目录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteFolder</span><span class="params">(<span class="built_in">File</span> folder)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">File</span>[] files = folder.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (files != null) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">File</span> f : files) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f.<span class="built_in">isDirectory</span>()) &#123;</span><br><span class="line">                    deleteFolder(f);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f.<span class="keyword">delete</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        folder.<span class="keyword">delete</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/20/java%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/20/java%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">java方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-20 16:24:04 / 修改时间：16:27:56" itemprop="dateCreated datePublished" datetime="2021-03-20T16:24:04+08:00">2021-03-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java-方法"><a href="#Java-方法" class="headerlink" title="Java 方法"></a>Java 方法</h1><p>在前面几个章节中我们经常使用到 <strong>System.out.println()</strong>，那么它是什么呢？</p>
<ul>
<li>println() 是一个方法。</li>
<li>System 是系统类。</li>
<li>out 是标准输出对象。</li>
</ul>
<p>这句话的用法是调用系统类 System 中的标准输出对象 out 中的方法 println()。</p>
<h3 id="那么什么是方法呢？"><a href="#那么什么是方法呢？" class="headerlink" title="那么什么是方法呢？"></a>那么什么是方法呢？</h3><p>Java方法是语句的集合，它们在一起执行一个功能。</p>
<ul>
<li>方法是解决一类问题的步骤的有序组合</li>
<li>方法包含于类或对象中</li>
<li>方法在程序中被创建，在其他地方被引用</li>
</ul>
<h3 id="方法的优点"><a href="#方法的优点" class="headerlink" title="方法的优点"></a>方法的优点</h3><ul>
<li>\1. 使程序变得更简短而清晰。</li>
<li>\2. 有利于程序维护。</li>
<li>\3. 可以提高程序开发的效率。</li>
<li>\4. 提高了代码的重用性。</li>
</ul>
<h3 id="方法的命名规则"><a href="#方法的命名规则" class="headerlink" title="方法的命名规则"></a>方法的命名规则</h3><ul>
<li>1.方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头写，不使用连接符。例如：<strong>addPerson</strong>。</li>
<li>2.下划线可能出现在 JUnit 测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<strong>test<MethodUnderTest>_<state></state></MethodUnderTest></strong>，例如 <strong>testPop_emptyStack</strong>。</li>
</ul>
<hr>
<h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><p>一般情况下，定义一个方法包含以下语法：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">    <span class="params">...</span></span><br><span class="line">    方法体</span><br><span class="line">    <span class="params">...</span></span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p>
<ul>
<li><strong>修饰符：</strong>修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li>
<li><strong>返回值类型 ：</strong>方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字<strong>void</strong>。</li>
<li><strong>方法名：</strong>是方法的实际名称。方法名和参数表共同构成方法签名。</li>
<li><strong>参数类型：</strong>参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li>
<li><strong>方法体：</strong>方法体包含具体的语句，定义该方法的功能。</li>
</ul>
<p><img src="/2021/03/20/java%E6%96%B9%E6%B3%95/D53C92B3-9643-4871-8A72-33D491299653.jpg" alt="img"></p>
<p>如：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="built_in">int</span> age(<span class="built_in">int</span> birthday)<span class="meta">&#123;...&#125;</span></span><br></pre></td></tr></table></figure>

<p>参数可以有多个：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">float</span> interest(<span class="built_in">float</span> principal, <span class="built_in">int</span> year)<span class="meta">&#123;...&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 在一些其它语言中方法指过程和函数。一个返回非void类型返回值的方法称为函数；一个返回void类型返回值的方法叫做过程。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面的方法包含 2 个参数 num1 和 num2，它返回这两个参数的最大值。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/** 返回两个整型变量数据的较大值 */</span><br><span class="line">public <span class="keyword">static</span> <span class="built_in">int</span> max(<span class="built_in">int</span> num1, <span class="built_in">int</span> num2) &#123;</span><br><span class="line">   <span class="built_in">int</span> <span class="literal">result</span>;</span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">      <span class="literal">result</span> = num1;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="literal">result</span> = num2;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">result</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更简略的写法（三元运算符）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 &gt; num2 ? num1 : num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>Java 支持两种调用方法的方式，根据方法是否返回值来选择。</p>
<p>当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。</p>
<p>当方法返回一个值的时候，方法调用通常被当做一个值。例如：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> larger = max(<span class="number">30</span>, <span class="number">40</span>);</span><br></pre></td></tr></table></figure>

<p>如果方法返回值是void，方法调用一定是一条语句。例如，方法println返回void。下面的调用是个语句：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println("欢迎访问本博客！");</span><br></pre></td></tr></table></figure>



<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面的例子演示了如何定义一个方法，以及如何调用它：</p>
<h2 id="TestMax-java-文件代码："><a href="#TestMax-java-文件代码：" class="headerlink" title="TestMax.java 文件代码："></a>TestMax.java 文件代码：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMax</span> &#123;</span></span><br><span class="line">   <span class="comment">/** 主方法 */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">int</span> k = <span class="built_in">max</span>(i, j);</span><br><span class="line">      System.out.<span class="built_in">println</span>( i + <span class="string">" 和 "</span> + j + <span class="string">" 比较，最大值是："</span> + k);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/** 返回两个整数变量较大的值 */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> result;</span><br><span class="line">      <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">         result = num1;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         result = num2;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">return</span> result; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例编译运行结果如下：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">5 </span>和 <span class="number">2</span> 比较，最大值是：<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>这个程序包含 main 方法和 max 方法。main 方法是被 JVM 调用的，除此之外，main 方法和其它方法没什么区别。</p>
<p>main 方法的头部是不变的，如例子所示，带修饰符 public 和 static,返回 void 类型值，方法名字是 main,此外带个一个 String[] 类型参数。String[] 表明参数是字符串数组。</p>
<hr>
<h2 id="void-关键字"><a href="#void-关键字" class="headerlink" title="void 关键字"></a>void 关键字</h2><p>本节说明如何声明和调用一个 void 方法。</p>
<p>下面的例子声明了一个名为 printGrade 的方法，并且调用它来打印给定的分数。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><h2 id="TestVoidMethod-java-文件代码："><a href="#TestVoidMethod-java-文件代码：" class="headerlink" title="TestVoidMethod.java 文件代码："></a>TestVoidMethod.java 文件代码：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVoidMethod</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">    printGrade(<span class="number">78.5</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printGrade</span><span class="params">(<span class="keyword">double</span> score)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (score &gt;= <span class="number">90.0</span>) &#123;</span><br><span class="line">       System.out.<span class="built_in">println</span>(<span class="string">'A'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">80.0</span>) &#123;</span><br><span class="line">       System.out.<span class="built_in">println</span>(<span class="string">'B'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">70.0</span>) &#123;</span><br><span class="line">       System.out.<span class="built_in">println</span>(<span class="string">'C'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60.0</span>) &#123;</span><br><span class="line">       System.out.<span class="built_in">println</span>(<span class="string">'D'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">       System.out.<span class="built_in">println</span>(<span class="string">'F'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例编译运行结果如下：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">C</span></span><br></pre></td></tr></table></figure>

<p>这里printGrade方法是一个void类型方法，它不返回值。</p>
<p>一个void方法的调用一定是一个语句。 所以，它被在main方法第三行以语句形式调用。就像任何以分号结束的语句一样。</p>
<hr>
<h2 id="通过值传递参数"><a href="#通过值传递参数" class="headerlink" title="通过值传递参数"></a>通过值传递参数</h2><p>调用一个方法时候需要提供参数，你必须按照参数列表指定的顺序提供。</p>
<p>例如，下面的方法连续n次打印一个消息：</p>
<h2 id="TestVoidMethod-java-文件代码：-1"><a href="#TestVoidMethod-java-文件代码：-1" class="headerlink" title="TestVoidMethod.java 文件代码："></a>TestVoidMethod.java 文件代码：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nPrintln</span><span class="params">(<span class="keyword">String</span> message, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>下面的例子演示按值传递的效果。</p>
<p>该程序创建一个方法，该方法用于交换两个变量。</p>
<h2 id="TestPassByValue-java-文件代码："><a href="#TestPassByValue-java-文件代码：" class="headerlink" title="TestPassByValue.java 文件代码："></a>TestPassByValue.java 文件代码：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPassByValue</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"交换前 num1 的值为："</span> +</span><br><span class="line">                        num1 + <span class="string">" ，num2 的值为："</span> + num2);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 调用swap方法</span></span><br><span class="line">    swap(num1, num2);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"交换后 num1 的值为："</span> +</span><br><span class="line">                       num1 + <span class="string">" ，num2 的值为："</span> + num2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** 交换两个变量的方法 */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"\t进入 swap 方法"</span>);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"\t\t交换前 n1 的值为："</span> + n1</span><br><span class="line">                         + <span class="string">"，n2 的值："</span> + n2);</span><br><span class="line">    <span class="comment">// 交换 n1 与 n2的值</span></span><br><span class="line">    <span class="keyword">int</span> temp = n1;</span><br><span class="line">    n1 = n2;</span><br><span class="line">    n2 = temp;</span><br><span class="line"> </span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"\t\t交换后 n1 的值为 "</span> + n1</span><br><span class="line">                         + <span class="string">"，n2 的值："</span> + n2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例编译运行结果如下：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">交换前 num1 的值为：<span class="number">1</span> ，num2 的值为：<span class="number">2</span></span><br><span class="line">    进入 swap 方法</span><br><span class="line">        交换前 n1 的值为：<span class="number">1</span>，n2 的值：<span class="number">2</span></span><br><span class="line">        交换后 n1 的值为 <span class="number">2</span>，n2 的值：<span class="number">1</span></span><br><span class="line">交换后 num1 的值为：<span class="number">1</span> ，num2 的值为：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>传递两个参数调用swap方法。有趣的是，方法被调用后，实参的值并没有改变。</p>
<hr>
<h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>上面使用的max方法仅仅适用于int型数据。但如果你想得到两个浮点类型数据的最大值呢？</p>
<p>解决方法是创建另一个有相同名字但参数不同的方法，如下面代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">    <span class="keyword">return</span> num1;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你调用max方法时传递的是int型参数，则 int型参数的max方法就会被调用；</p>
<p>如果传递的是double型参数，则double类型的max方法体会被调用，这叫做方法重载；</p>
<p>就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。</p>
<p>Java编译器根据方法签名判断哪个方法应该被调用。</p>
<p>方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。</p>
<p>重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。</p>
<hr>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>变量的范围是程序中该变量可以被引用的部分。</p>
<p>方法内定义的变量被称为局部变量。</p>
<p>局部变量的作用范围从声明开始，直到包含它的块结束。</p>
<p>局部变量必须声明才可以使用。</p>
<p>方法的参数范围涵盖整个方法。参数实际上是一个局部变量。</p>
<p>for循环的初始化部分声明的变量，其作用范围在整个循环。</p>
<p>但循环体内声明的变量其适用范围是从它声明到循环体结束。它包含如下所示的变量声明：</p>
<p><img src="/2021/03/20/java%E6%96%B9%E6%B3%95/12-130Q1221013F0.jpg" alt="img"></p>
<p>你可以在一个方法里，不同的非嵌套块中多次声明一个具有相同的名称局部变量，但你不能在嵌套块内两次声明局部变量。</p>
<h2 id="命令行参数的使用"><a href="#命令行参数的使用" class="headerlink" title="命令行参数的使用"></a>命令行参数的使用</h2><p>有时候你希望运行一个程序时候再传递给它消息。这要靠传递命令行参数给main()函数实现。</p>
<p>命令行参数是在执行程序时候紧跟在程序名字后面的信息。</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>下面的程序打印所有的命令行参数：</p>
<h2 id="CommandLine-java-文件代码："><a href="#CommandLine-java-文件代码：" class="headerlink" title="CommandLine.java 文件代码："></a>CommandLine.java 文件代码：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandLine</span> &#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span> args[])</span></span>&#123; </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;args.length; i++)&#123;</span><br><span class="line">         System.out.<span class="built_in">println</span>(<span class="string">"args["</span> + i + <span class="string">"]: "</span> + args[i]);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下所示，运行这个程序：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ javac CommandLine.java </span><br><span class="line">$ java CommandLine <span class="keyword">this</span> <span class="keyword">is</span> a command line <span class="number">200</span> <span class="number">-100</span></span><br><span class="line">args[<span class="number">0</span>]: <span class="keyword">this</span></span><br><span class="line">args[<span class="number">1</span>]: <span class="keyword">is</span></span><br><span class="line">args[<span class="number">2</span>]: a</span><br><span class="line">args[<span class="number">3</span>]: command</span><br><span class="line">args[<span class="number">4</span>]: line</span><br><span class="line">args[<span class="number">5</span>]: <span class="number">200</span></span><br><span class="line">args[<span class="number">6</span>]: <span class="number">-100</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。</p>
<p>通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。</p>
<p>不管你是否自定义构造方法，所有的类都有构造方法，因为 Java 自动提供了一个默认构造方法，默认构造方法的访问修饰符和类的访问修饰符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)。</p>
<p>一旦你定义了自己的构造方法，默认构造方法就会失效。</p>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>下面是一个使用构造方法的例子：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个简单的构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">MyClass</span> &#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 以下是构造函数</span></span><br><span class="line">  MyClass() &#123;</span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以像下面这样调用构造方法来初始化一个对象：</p>
<h2 id="ConsDemo-java-文件代码："><a href="#ConsDemo-java-文件代码：" class="headerlink" title="ConsDemo.java 文件代码："></a>ConsDemo.java 文件代码：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsDemo</span> &#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span> args[])</span> </span>&#123;</span><br><span class="line">      MyClass t1 = <span class="keyword">new</span> MyClass();</span><br><span class="line">      MyClass t2 = <span class="keyword">new</span> MyClass();</span><br><span class="line">      System.out.<span class="built_in">println</span>(t1.x + <span class="string">" "</span> + t2.x);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大多时候需要一个有参数的构造方法。</p>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>下面是一个使用构造方法的例子：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个简单的构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">MyClass</span> &#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 以下是构造函数</span></span><br><span class="line">  MyClass(<span class="built_in">int</span> i ) &#123;</span><br><span class="line">    x = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以像下面这样调用构造方法来初始化一个对象：</p>
<h2 id="ConsDemo-java-文件代码：-1"><a href="#ConsDemo-java-文件代码：-1" class="headerlink" title="ConsDemo.java 文件代码："></a>ConsDemo.java 文件代码：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsDemo</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span> args[])</span> </span>&#123;</span><br><span class="line">    MyClass t1 = <span class="keyword">new</span> MyClass( <span class="number">10</span> );</span><br><span class="line">    MyClass t2 = <span class="keyword">new</span> MyClass( <span class="number">20</span> );</span><br><span class="line">    System.out.<span class="built_in">println</span>(t1.x + <span class="string">" "</span> + t2.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">10 </span><span class="number">20</span></span><br></pre></td></tr></table></figure>

<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。</p>
<p>方法的可变参数的声明如下所示：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">typeName</span></span>... parameterName</span><br></pre></td></tr></table></figure>

<p>在方法声明中，在指定参数类型后加一个省略号(…) 。</p>
<p>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</p>
<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><h2 id="VarargsDemo-java-文件代码："><a href="#VarargsDemo-java-文件代码：" class="headerlink" title="VarargsDemo.java 文件代码："></a>VarargsDemo.java 文件代码：</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">VarargsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String args[]) &#123;</span><br><span class="line">        <span class="comment">// 调用可变参数的方法</span></span><br><span class="line">        printMax(<span class="number">34</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">56.5</span>);</span><br><span class="line">        printMax(new <span class="built_in">double</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> printMax( <span class="built_in">double</span>... numbers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"No argument passed"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">double</span> result = numbers[<span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;  numbers.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] &gt;  result) &#123;</span><br><span class="line">                result = numbers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"The max value is "</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例编译运行结果如下：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The<span class="built_in"> max</span> <span class="keyword">value</span> <span class="literal">is</span> <span class="number">56.5</span></span><br><span class="line">The<span class="built_in"> max</span> <span class="keyword">value</span> <span class="literal">is</span> <span class="number">3.0</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize() 方法"></a>finalize() 方法</h2><p>Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。</p>
<p>例如，你可以使用 finalize() 来确保一个对象打开的文件被关闭了。</p>
<p>在 finalize() 方法里，你必须指定在对象销毁时候要执行的操作。</p>
<p>finalize() 一般格式是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 在这里终结代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键字 protected 是一个限定符，它确保 finalize() 方法不会被该类以外的代码调用。</p>
<p>当然，Java 的内存回收可以由 JVM 来自动完成。如果你手动使用，则可以使用上面的方法。</p>
<h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><h2 id="FinalizationDemo-java-文件代码："><a href="#FinalizationDemo-java-文件代码：" class="headerlink" title="FinalizationDemo.java 文件代码："></a>FinalizationDemo.java 文件代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizationDemo</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    Cake c1 = <span class="keyword">new</span> Cake(<span class="number">1</span>);  </span><br><span class="line">    Cake c2 = <span class="keyword">new</span> Cake(<span class="number">2</span>);  </span><br><span class="line">    Cake c3 = <span class="keyword">new</span> Cake(<span class="number">3</span>);  </span><br><span class="line">      </span><br><span class="line">    c2 = c3 = <span class="keyword">null</span>;  </span><br><span class="line">    System.gc(); <span class="comment">//调用Java垃圾收集器</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cake</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Cake</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.id = id;  </span><br><span class="line">    System.out.println(<span class="string">"Cake Object "</span> + id + <span class="string">"is created"</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> java.lang.Throwable </span>&#123;  </span><br><span class="line">    <span class="keyword">super</span>.finalize();  </span><br><span class="line">    System.out.println(<span class="string">"Cake Object "</span> + id + <span class="string">"is disposed"</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行以上代码，输出结果如下：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ javac FinalizationDemo.java </span><br><span class="line">$ java FinalizationDemo</span><br><span class="line">Cake Object <span class="number">1</span><span class="keyword">is</span> created</span><br><span class="line">Cake Object <span class="number">2</span><span class="keyword">is</span> created</span><br><span class="line">Cake Object <span class="number">3</span><span class="keyword">is</span> created</span><br><span class="line">Cake Object <span class="number">3</span><span class="keyword">is</span> disposed</span><br><span class="line">Cake Object <span class="number">2</span><span class="keyword">is</span> disposed</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">匡俊桦</p>
  <div class="site-description" itemprop="description">回忆的沙漏将曾经屈指可数的日子渐渐淡去</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">233</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">匡俊桦</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">28:26</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
