<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="基础知识汇编语言指令组成 汇编指令：机器码的助记符，有对应的机器码。 伪指令：没有对应的机器码，编译器执行，机器不执行。 其他符号：如±*&#x2F;有编译器识别，无对应机器码。  CPU与外部器件交互需要 存储单元地址（地址信息） 器件选择，读写命令（控制信息） 数据（数据信息）  总线总线就是一根根导线的集合，分为  地址总线，越宽（数量越多）代表可以寻址的范围越大 数据总线，越宽代表一次性读写的数据越">
<meta property="og:type" content="article">
<meta property="og:title" content="汇编语言基础学习汇总1">
<meta property="og:url" content="http://yoursite.com/2020/12/29/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="基础知识汇编语言指令组成 汇编指令：机器码的助记符，有对应的机器码。 伪指令：没有对应的机器码，编译器执行，机器不执行。 其他符号：如±*&#x2F;有编译器识别，无对应机器码。  CPU与外部器件交互需要 存储单元地址（地址信息） 器件选择，读写命令（控制信息） 数据（数据信息）  总线总线就是一根根导线的集合，分为  地址总线，越宽（数量越多）代表可以寻址的范围越大 数据总线，越宽代表一次性读写的数据越">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-12-29T13:04:30.396Z">
<meta property="article:modified_time" content="2021-01-01T14:20:21.918Z">
<meta property="article:author" content="KJH">
<meta property="article:tag" content="汇编基础学习">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/12/29/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>汇编语言基础学习汇总1 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/29/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          汇编语言基础学习汇总1
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-29 21:04:30" itemprop="dateCreated datePublished" datetime="2020-12-29T21:04:30+08:00">2020-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-01 22:20:21" itemprop="dateModified" datetime="2021-01-01T22:20:21+08:00">2021-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96/" itemprop="url" rel="index"><span itemprop="name">汇编</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h5 id="汇编语言指令组成"><a href="#汇编语言指令组成" class="headerlink" title="汇编语言指令组成"></a><strong>汇编语言指令组成</strong></h5><ul>
<li>汇编指令：机器码的助记符，有对应的机器码。</li>
<li>伪指令：没有对应的机器码，编译器执行，机器不执行。</li>
<li>其他符号：如±*/有编译器识别，无对应机器码。</li>
</ul>
<h5 id="CPU与外部器件交互需要"><a href="#CPU与外部器件交互需要" class="headerlink" title="CPU与外部器件交互需要"></a><strong>CPU与外部器件交互需要</strong></h5><ul>
<li>存储单元地址（地址信息）</li>
<li>器件选择，读写命令（控制信息）</li>
<li>数据（数据信息）</li>
</ul>
<h5 id="总线"><a href="#总线" class="headerlink" title="总线"></a><strong>总线</strong></h5><p>总线就是一根根导线的集合，分为</p>
<ul>
<li>地址总线，越宽（数量越多）代表可以寻址的范围越大</li>
<li>数据总线，越宽代表一次性读写的数据越多（8根1字节）</li>
<li>控制总线，越宽代表对器件控制操作越多</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h5><p>汇编指令和机器指令一一对应</p>
<p>每一种cpu都有自己的汇编指令集</p>
<p>在存储器中指令和数据都是二进制，没有任何区别</p>
<p>CPU可以直接使用的信息存放在存储器中（内存）</p>
<h5 id="接口卡"><a href="#接口卡" class="headerlink" title="接口卡"></a><strong>接口卡</strong></h5><p>CPU无法直接控制显示器，键盘等的外围设备，但CPU通过直接控制这些外围设备在主板上的接口卡来控制这些设备。</p>
<h5 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a><strong>存储器</strong></h5><p>随机存储器（RAM）：带电存储，关机丢失，可读可写</p>
<ul>
<li>用于存放CPU使用的绝大部分程序和数据，主随机存储器由装在主板上的RAM和扩展插槽的RAM组成。</li>
<li>其他接口卡上也可能有自己的RAM</li>
</ul>
<p>只读存储器（ROM）：关机不丢，只能读取</p>
<ul>
<li>主板上的ROM装有系统的BIOS（基本输入输出系统）。</li>
<li>其他接口卡上也可能有自己的ROM，一般装着相应的BIOS。</li>
</ul>
<p>（P10图）</p>
<h5 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a><strong>内存地址空间</strong></h5><p>以上这些内存都和CPU总线相连，CPU都通过控制总线向他们发出内存读写命令。所以CPU都把他们当内存对待，看做一个一个由若干存储单元组成的逻辑存储器，即内存地址空间（一个假想的逻辑存储器P11图）。</p>
<p>内存地址空间中的各个不同的地址段代表不同的存储设备，内存地址空间大小收到CPU地址总线长度限制。</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><h5 id="内部总线"><a href="#内部总线" class="headerlink" title="内部总线"></a><strong>内部总线</strong></h5><p>之前讨论的总线是CPU控制外部设备使用的总线，是将CPU和外部部件连接的。而CPU内部由寄存器，运算器，控制器等组成，由内部总线相连，内部总线负责连接CPU内部的部件。</p>
<h5 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a><strong>通用寄存器</strong></h5><p>8086CPU寄存器都是16位的，一共14个，分别是AX,BX,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW。其中AX,BX,CX,DX四个寄存器通常存放一般性的数据，称为通用寄存器。</p>
<p>而且为了兼容上一代的8位寄存器，这四个寄存器可以拆开成两个8位的寄存器来使用。称为AH,AL,BH,BL,CH,CL,DH,DL。低八位（编号0-7）构成L寄存器，高八位构成H寄存器。</p>
<h5 id="字"><a href="#字" class="headerlink" title="字"></a><strong>字</strong></h5><p>8086CPU可以处理以下两种数据</p>
<ul>
<li>字节byte，8位</li>
<li>字word，连个字节，16位。分别称为高位字节和低位字节。</li>
</ul>
<h5 id="简单的汇编指令"><a href="#简单的汇编指令" class="headerlink" title="简单的汇编指令"></a><strong>简单的汇编指令</strong></h5><table>
<thead>
<tr>
<th>指令</th>
<th>操作</th>
<th>高级语言</th>
</tr>
</thead>
<tbody><tr>
<td>mov ax,18</td>
<td>将18存入AX寄存器</td>
<td>AX=18</td>
</tr>
<tr>
<td>add ax,8</td>
<td>将AX寄存器中的数加8</td>
<td>AX=AX+8</td>
</tr>
<tr>
<td>mov ax,bx</td>
<td>将BX中的数据存入AX</td>
<td>AX=BX</td>
</tr>
<tr>
<td>add ax,bx</td>
<td>将AX中的数据和BX中的数据相加存入AX</td>
<td>AX=AX+BX</td>
</tr>
</tbody></table>
<p>汇编指令或寄存器名称不区分大小写。</p>
<p>注：AX寄存器当做两个8位寄存器al和ah使用的时候，CPU就把他们当做两个8位寄存器使用，而不会看成是一个16未分开，即如果al进行加法运算C5+93=158，即add al,93，al会变成58，ax则是0058而不是0158。</p>
<h5 id="CPU位结构"><a href="#CPU位结构" class="headerlink" title="CPU位结构"></a><strong>CPU位结构</strong></h5><p>16位结构的CPU指的是运算器一次最多处理16位数据，寄存器宽度16，寄存器和运算器之间通路也是16位。</p>
<h5 id="CPU表示物理地址"><a href="#CPU表示物理地址" class="headerlink" title="CPU表示物理地址"></a><strong>CPU表示物理地址</strong></h5><p>如果物理总线宽度超过寄存器宽度，CPU寻址方法是两个寄存器输出一个地址，当地址总线宽度20的时候，P21图。一个寄存器输出短地址，另一个输出偏移地址。然后通过地址加法器合并为一个20位的地址，然后通过内部总线送给控制电路，控制电路通过地址总线送给内存。</p>
<p>公式：物理地址=段地址x16+偏移地址（这里的x16其实就是左移四位，P21图）</p>
<p>虽然这么表示，但内存并没有被分为一段一段的，是CPU划分的段。段地址x16称为基础地址，所以我们可以根据需求把任意的基础地址加上不超过一个寄存器表示的最长（64KB）的偏移地址来表示地址。而且一个实际地址往往可以有各种不同的方法表示，通常我们表示21F60H这个地址通过下面方法：</p>
<ul>
<li>2000:1F60</li>
<li>2000H段中的1F60单元中</li>
</ul>
<h5 id="段寄存器与指令指针寄存器"><a href="#段寄存器与指令指针寄存器" class="headerlink" title="段寄存器与指令指针寄存器"></a><strong>段寄存器与指令指针寄存器</strong></h5><p>8086CPU有四个段寄存器：CS,DS,SS,ES</p>
<p>除此之外，IP寄存器称为指令指针寄存器，所以任意时刻可以读取从CSx16+IP单元开始，读取一条指令执行。也就是说，CPU将IP指向的内容当做指令执行。</p>
<p>P26图，CPU执行一段指令。另外，8086CPU开机时CS被置为FFFFH，IP被置为0000H，也就是说刚开机的第一条指令从FFFF0H开始读取执行。</p>
<p>CPU将CS:IP指向的内存中的内容当做指令，一条指令被执行了，那一定被CS:IP指向过。</p>
<h5 id="修改CS，IP"><a href="#修改CS，IP" class="headerlink" title="修改CS，IP"></a><strong>修改CS，IP</strong></h5><p>CS和IP寄存器不可以使用传送指令mov来改变，而能改变CS，IP内容的指令是转移指令。</p>
<p>jmp指令用法：</p>
<ul>
<li>jmp 段地址:偏移地址 同时修改CS和IP的值 如jmp 2AE3:3 结果CS=2AE3H IP=0003H</li>
<li>jmp 某一合法寄存器 只修改IP的值 如jmp ax，将IP的值置为AX中的值（AX不变）</li>
</ul>
<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a><strong>小结</strong></h5><p>8086CPU有四个段寄存器，CS是用来存放指令的段地址的段寄存器</p>
<p>IP用来存放指令的偏移地址</p>
<p>CS:IP指向的内容在任意时刻会被当做指令执行</p>
<p>使用转移指令修改CS和IP的内容</p>
<h5 id="实验"><a href="#实验" class="headerlink" title="实验"></a><strong>实验</strong></h5><p>Debug命令：</p>
<ul>
<li>R：查看，改变CPU寄存器内容<ul>
<li>直接-r查看寄存器内容</li>
<li>-r 寄存器名，改变寄存器内容</li>
</ul>
</li>
<li>D：查看内存中内容<ul>
<li>-d直接查看</li>
<li>-d 段地址:偏移地址 查看固定地址开始的内容</li>
<li>-d 段地址:偏移地址 结尾偏移地址 查看指定范围内存</li>
</ul>
</li>
<li>E：改写内存中内容<ul>
<li>-e 起始地址 数据 数据 数据 …</li>
<li>提问方式修改 -e 段地址:偏移地址 从这个地址开始一个一个改，空格下一个，回车结束</li>
<li>也可以写入字符 ‘a’</li>
</ul>
</li>
<li>U：将内存中的机器指令翻译成汇编指令<ul>
<li>-u 段地址:偏移地址</li>
</ul>
</li>
<li>T：执行一条机器指令<ul>
<li>-t 执行cs:ip指向的命令</li>
</ul>
</li>
<li>A：以汇编指令格式在内存中写入一条机器指令<ul>
<li>-a 段地址:偏移地址 从这个地址开始一行一行的写入汇编语句</li>
</ul>
</li>
</ul>
<h3 id="寄存器（内存访问）"><a href="#寄存器（内存访问）" class="headerlink" title="寄存器（内存访问）"></a>寄存器（内存访问）</h3><h5 id="内存到寄存器的储存"><a href="#内存到寄存器的储存" class="headerlink" title="内存到寄存器的储存"></a><strong>内存到寄存器的储存</strong></h5><p>寄存器是16位的，可以存放一个字即两个字节，而内存中的一个存储单元是一字节。所以一个寄存器可以存两个存储单元的内容，高地址存储单元存在高位字节中，低地址存储单元存在低位字节中。</p>
<p>字单元：存放一个字型数据的两个地址连续的内存单元。</p>
<h5 id="DS寄存器"><a href="#DS寄存器" class="headerlink" title="DS寄存器"></a><strong>DS寄存器</strong></h5><p>与CS类似，DS寄存器存放的是要从内存中读取的数据的段地址。我们想要使用mov指令从内存10000H（1000:0）中的数据送给AL时，如下：</p>
<p>mov al,[0]</p>
<p>后面的[0]指的是内存的偏移地址是0，CPU会自动从DS寄存器中提取段地址，所以应该首先将段地址1000H写入DS寄存器中。但却不能直接使用mov ds,1000指令，只能从其他寄存器中转传入DS寄存器。所以完整命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000</span><br><span class="line">mov ds,bx</span><br><span class="line">mov al,[0]</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>当然，从AL寄存器中将数据送入内存只要反过来使用mov就可以了，mov [0],al</p>
<p>如果需要传输字型数，只要使用对应的16位寄存器就可以了，传输的是以相应地址开始的一个字型数据（连续两个字节）。如mov [0],cx。</p>
<h5 id="mov，add，sub"><a href="#mov，add，sub" class="headerlink" title="mov，add，sub"></a><strong>mov，add，sub</strong></h5><p>mov常见语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov 寄存器,数据       mov ax,8</span><br><span class="line">mov 寄存器,寄存器		mov ax,bx</span><br><span class="line">mov 寄存器,内存单元    mov ax,[0]</span><br><span class="line">mov 内存单元,寄存器    mov [0],ax</span><br><span class="line">mov 段寄存器,寄存器    mov ds,ax</span><br><span class="line">mov 寄存器,段寄存器    mov ax,ds</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<p>add，sub常见语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add 寄存器,数据        add ax,8</span><br><span class="line">add 寄存器,寄存器      add ax,bx</span><br><span class="line">add 寄存器,内存单元    add ax,[0]</span><br><span class="line">add 内存单元,寄存器    add [0],ax</span><br><span class="line">sub和add一样</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>注意，add，sub不可以操作段寄存器。</p>
<h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a><strong>栈</strong></h5><p>栈是一种后进先出的存储空间，从栈顶出栈入栈。LIFO（last in first out）</p>
<p>入栈指令：push ax ax中的数据送入栈顶</p>
<p>出栈指令：pop ax 栈顶送入ax</p>
<p>入栈和出栈指令都是以字为单位的。P58图</p>
<h5 id="栈寄存器SS，SP与push，pop"><a href="#栈寄存器SS，SP与push，pop" class="headerlink" title="栈寄存器SS，SP与push，pop"></a><strong>栈寄存器SS，SP与push，pop</strong></h5><p>CPU通过SS寄存器和SP寄存器来知道栈的范围，段寄存器SS存放的是栈顶的段地址，SP寄存器存放的是栈顶的偏移地址。所以，任意时刻SS:SP指向栈顶元素。</p>
<p>指令push ax执行过程：</p>
<ol>
<li>SP=SP-2，SP指针向前移动两格代表新栈顶</li>
<li>AX中的数据送入SS:SP目前指向的内存字单元，P59图</li>
</ol>
<p>所以栈顶在低地址，栈底在高地址。初始状态下，SP指向栈底的下一个单元。</p>
<p>反之pop ax执行过程相反。</p>
<p>8086CPU并不会自己检测push是否会超栈顶，pop是否会超栈底。</p>
<p>push和pop可以加寄存器，段寄存器，内存单元（直接偏移地址[address]）</p>
<p>指定栈空间通常通过指定SS来进行，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">指定10000H~1000FH为栈空间</span><br><span class="line">mov ax,1000</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp 0010</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<p>注：将一个寄存器清零 sub ax,ax 两个字节，mov ax,0 三个字节</p>
<p>注：若设定一个栈段为10000H~1FFFFH，栈空的时候SP=0（要知道入栈操作先SP-2，然后再送入栈）</p>
<h5 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a><strong>实验</strong></h5><p>Debug中的t命令一次执行一条指令，但如果执行的指令修改了ss段寄存器，下一条命令也会紧跟着执行（中断机制）。</p>
<h3 id="简单编程"><a href="#简单编程" class="headerlink" title="简单编程"></a>简单编程</h3><h5 id="一个汇编语言程序"><a href="#一个汇编语言程序" class="headerlink" title="一个汇编语言程序"></a><strong>一个汇编语言程序</strong></h5><ol>
<li>编写</li>
<li>编译（masm5.0）</li>
<li>连接</li>
</ol>
<h5 id="一些伪指令功能"><a href="#一些伪指令功能" class="headerlink" title="一些伪指令功能"></a><strong>一些伪指令功能</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">mov ax,0123</span><br><span class="line">mov bx,0456</span><br><span class="line">add ax,bx</span><br><span class="line">add ax,ax</span><br><span class="line"></span><br><span class="line">mov ax,4c00</span><br><span class="line">int 21</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line">123456789101112131415</span><br></pre></td></tr></table></figure>

<p>涉及到的一些知识：</p>
<ul>
<li>XXX segment···XXXends<ul>
<li>segment和ends成对出现，代表一个段的开始和结束。</li>
<li>一个汇编程序可以有多个段，代码，数据和栈等，至少要有一个段。</li>
</ul>
</li>
<li>end<ul>
<li>end代表一个汇编程序结束，遇到end编译器停止编译。</li>
</ul>
</li>
<li>assume<ul>
<li>assume 假设，假设某一个段寄存器和程序中的一个段关联。</li>
<li>可以理解为将这个段寄存器指向程序段的段地址</li>
</ul>
</li>
<li>标号（codesg）<ul>
<li>一个标号代表一个地址</li>
</ul>
</li>
<li>程序返回mov ax,4c00 int 21<ul>
<li>暂时记住这两条指令代表程序返回</li>
</ul>
</li>
</ul>
<p>编译和连接方法，P83。</p>
<p>注：编译器只能发现语法错误而无法发现逻辑错误。</p>
<p>CPU执行一个程序，需要有另一个程序将它加载进内存（即将CS:IP指向它），一般情况下我们通过DOS执行这个.exe，所以是DOS程序将它加载进入内存。当这个程序运行结束，再返回DOS程序继续执行。如果是DOS调用Debug调用.exe，那么先返回Debug再返回DOS。</p>
<p>DOS加载一个.exe时，先在内存中找到一段内存，起始段地址SA，然后分配256字节的PSP区域，用来和被加载程序通信。在之后的段地址SA+10就是程序开始的段地址。CS:IP指向它，DS=SA。</p>
<p>注：在Debug中，最后的int 21指令要使用P命令执行。</p>
<h3 id="BX-和loop指令"><a href="#BX-和loop指令" class="headerlink" title="[BX]和loop指令"></a>[BX]和loop指令</h3><h5 id="内存单元的描述"><a href="#内存单元的描述" class="headerlink" title="内存单元的描述"></a><strong>内存单元的描述</strong></h5><p>内存单元可以使用[数字]表示，当然也可以使用[寄存器]表示，如[bx]，mov ax,[bx]，mov al,[bx]</p>
<p>为了表示方便，使用()来表示一个内存单元或寄存器中的内容，如(ax),(20000H)，或((dx)*16+(bx))表示ds:bx中的内容，但不可写为(1000:0),((dx):0H)。而(X)中的内容由具体寄存器名或运算来决定。</p>
<p>我们使用idata来表示常亮。所以以下语句可以这么写：mov ax,[idata] mov ax,idata。</p>
<h5 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a><strong>loop指令</strong></h5><p>loop指令格式：loop 标号。</p>
<p>loop指令通常用来实现循环功能，当执行loop指令时，CPU进行两步操作：</p>
<ol>
<li>(cx)=(cx)-1</li>
<li>(cx)不为零则跳至标号处执行程序。</li>
</ol>
<p>所以CX中存放的是循环次数，一个简单的例子如下（计算2^12）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">mov ax,2</span><br><span class="line"></span><br><span class="line">mov cx,11</span><br><span class="line">s:add ax,ax</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br><span class="line">1234567891011121314</span><br></pre></td></tr></table></figure>

<p>所以使用loop注意三点：</p>
<ol>
<li>先设置cx的值 mov cx,循环次数</li>
<li>设置标号与执行循环的程序段 s:执行程序段</li>
<li>在程序段最后写loop loop</li>
</ol>
<p>注：在汇编语言中，数据不能以字母开头，所以大于9fffH的数据，要在开头加0，如0A000H</p>
<p>注：debug中G命令 g 0012表示CPU从当前CS:IP开始一直执行到0012处暂停。P命令可以将loop部分一次执行完毕，直到(CX)=0，或使用g loop的下一条命令。</p>
<h5 id="Debug和masm编译器对指令的不同处理"><a href="#Debug和masm编译器对指令的不同处理" class="headerlink" title="Debug和masm编译器对指令的不同处理"></a><strong>Debug和masm编译器对指令的不同处理</strong></h5><p>mov ax,[0]这条指令在Debug和masm中有着不同的解释，Debug是将DS:0内存中的数据送给AX，而masm中则是mov ax,0，即将0送入AX。</p>
<p>解决方法1：先将偏移地址送入BX，然后再使用mov ax,[bx]</p>
<p>解决方法2：直接显式给出地址，如mov al，ds:[0] （相应的段寄存器还有CS,SS,ES这些在汇编语言中可以称为“段前缀”）当然，这种写法通过编译器之后会变成Debug中的mov al,[0]</p>
<p>注：inc bx bx值加一</p>
<h5 id="安全的编程空间"><a href="#安全的编程空间" class="headerlink" title="安全的编程空间"></a><strong>安全的编程空间</strong></h5><p>在之前没有提到的一个问题，如果在写程序之前不看一眼要操作的内存，就直接开始使用的话，万一改写了内存中重要的系统数据，可能会引起系统崩溃。所以我们一般在一个安全的内存空间中操作。一般操作系统和合法程序都不会使用0:200~0:2ff这256字节的空间，所以我们可以在这里操作。</p>
<p>学习汇编语言的目的就是直接和硬件对话，而不理会操作系统，这在DOS（实模式）下是可以做到的，但在windows或Unix这种运行与CPU保护模式的操作系统上却是不可能的，因为这种操作系统已经将CPU全面严格的管理了。</p>
<h5 id="段前缀的使用"><a href="#段前缀的使用" class="headerlink" title="段前缀的使用"></a><strong>段前缀的使用</strong></h5><p>将ffff:0ffff:b中的数据转存入0:2000:20b中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">mov ax,0ffffh</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov ax,0020h</span><br><span class="line">mov es,ax</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov cx,12</span><br><span class="line">s:mov dl,[bx]</span><br><span class="line">mov es:[bx],dl</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br><span class="line">12345678910111213141516171819202122</span><br></pre></td></tr></table></figure>

<p>[bx]直接使用的时候默认段前缀是ds，但要使用其他的段前缀，如es就要在前面加上。</p>
<h3 id="程序的段"><a href="#程序的段" class="headerlink" title="程序的段"></a>程序的段</h3><h5 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a><strong>数据段</strong></h5><p>一般一个程序想要使用内存空间，有两种方法，在程序加载的时候系统分配或在需要使用的时候向系统申请，我们先考虑第一种情况。所以我们应事先将所需的数据存入内存中的某一段中，但我们又不可以随意的指定内存地址，以下面的求8个数据累加和的代码为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line">mov ax,0</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s:add ax,cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br><span class="line">123456789101112131415161718</span><br></pre></td></tr></table></figure>

<p>代码第一行的dw是定义字类型数据，define word的意思。这里定义了8个字类型数据，占16字节。由于是在程序最开始定义的dw，所以数据段的偏移地址为0，也就是说第一个数据0123h的地址是CS:[0]第二个0456h的地址是CS:[2]以此类推。</p>
<p>所以这个程序加载之后CS:IP指向的是数据段的第一个数据，我们要是想成功执行，需要把IP置10，指向第一条指令mov bx,0，所以我们想要直接执行（不在Debug中调整IP）的话，需要指定程序开始的地方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line"></span><br><span class="line">start:mov bx,0</span><br><span class="line">···</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>

<p>在第一条指令前加start，后面的end变成end start，end除了通知编译器程序在哪里结束之外，也可以通知程序的入口在哪，也就是第一条语句，在这里编译器就知道了mov bx,0是程序的第一条指令。也就是说，我们想要CPU从何处开始执行程序，只要在源程序中使用end 标号指定就好了。</p>
<p>所以有如下框架：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">···数据···</span><br><span class="line">start:</span><br><span class="line">···代码···</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>

<h5 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a><strong>栈段</strong></h5><p>看下面一段使8个数逆序存放的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line"></span><br><span class="line">start:mov ax,cs</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,30h</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:push cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s0:pop cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br><span class="line">123456789101112131415161718192021222324252627</span><br></pre></td></tr></table></figure>

<p>在定义了8个字型数据之后，又定义了16个取值为0的字型数据，用作栈空间。所以dw这个定义不仅仅用来定义数据，也可以用来开辟内存空间留给之后的程序使用。</p>
<h5 id="数据，代码，栈的程序段"><a href="#数据，代码，栈的程序段" class="headerlink" title="数据，代码，栈的程序段"></a><strong>数据，代码，栈的程序段</strong></h5><p>在8086CPU中，一个段的长度最大为64KB，所以如果我们将数据或栈空间定义的比较大，就不能像前面一样编程了。我们需要将代码，数据，栈放入不同的段中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line">data segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">srack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,20h</span><br><span class="line"></span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s:push [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s0:pop [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">123456789101112131415161718192021222324252627282930313233343536</span><br></pre></td></tr></table></figure>

<p>我们可以这样在写代码时就将程序分为几个段，这段代码中，mov ax,data的意思是将data段的段地址送入ax寄存器。但我们不可以使用mov ds,data这样是错误的，因为在这里data被编译器视为一个数值。</p>
<p>在这里将数据命名为data，代码命名为code，栈命名为stack只是为了方便阅读，CPU并不能理解，和start，s，s0一样，只在源程序中使用。而assume cs:code,ds:data,ss:stack这段代码也并不能让CPU的cs，ds，ss指向对应的段，因为assume是伪指令，CPU并不认识，它是由编译器执行的。源程序中end start语句指明了程序的入口，在这个程序被加载后，CS:IP被指向start处，开始执行第一条语句，这样CPU才会将code段当做代码执行。而当CPU执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,20h</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>这三条语句后才会将stack段当做栈空间开使用。也就是说，CPU如何区分哪个段的功能，全靠我们使用汇编指令对ds，ss，cs寄存器的内容设置来指定。</p>
<h3 id="灵活定位内存地址"><a href="#灵活定位内存地址" class="headerlink" title="灵活定位内存地址"></a>灵活定位内存地址</h3><h5 id="and和or指令"><a href="#and和or指令" class="headerlink" title="and和or指令"></a><strong>and和or指令</strong></h5><p>and：逻辑与指令，按位与运算，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,01100011B</span><br><span class="line">and al,00111011B</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>执行结果是al=00100011B，所以我们想要把某一位置零的时候可以使用and指令。</p>
<p>or：逻辑或指令，按位或运算，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,01100011B</span><br><span class="line">or al,00111011B</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>执行结果是al=01111011B，or指令可以将相应位置1。</p>
<h5 id="ASCII码和字符形式的数据"><a href="#ASCII码和字符形式的数据" class="headerlink" title="ASCII码和字符形式的数据"></a><strong>ASCII码和字符形式的数据</strong></h5><p>在汇编语言中我们可以使用’···’的方式指明数据是以字符形式给出的，编译器会自动将它们转化为ASCII码。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">db &#39;unIX&#39;</span><br><span class="line">db &#39;foRK&#39;</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:mov al,&#39;a&#39;</span><br><span class="line">mov bl,&#39;b&#39;</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure>

<p>db和dw类似，只不过定义的是字节型数据，然后通过’unIX’相继在接下来四个字节中写下75H,6EH,49H,58H即unIX的ASCII值。同理,mov al,’a’也是将’a’的ASCII值61H送入al寄存器。</p>
<p>使用and和or指令改变一串字符串字母的大小写，将第一串全变为大写，第二串全变为小写：</p>
<p>首先分析ASCII码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">大写	十六进制	二进制			小写	十六进制	二进制</span><br><span class="line"> A		41		01000001		a		61	   01100001</span><br><span class="line"> B		42		01000010		b		62	   01100010</span><br><span class="line"> C 		43		01000011		c		63	   01100011</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<p>可见，只有第5位（从右往左数，从0开始计数）在大写和小写的二进制中是不一样的，所以我们只要把所有字母的二进制第五位置零，那就是大写，置1就是小写。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">db &#39;BaSiC&#39;</span><br><span class="line">db &#39;iNfOrMaTiOn&#39;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov cx,5</span><br><span class="line">s:mov al,[bx]</span><br><span class="line">and al,11011111B</span><br><span class="line">mov [bx],al</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov bx,5</span><br><span class="line"></span><br><span class="line">mov cx,11</span><br><span class="line">s0:mov al,[bx]</span><br><span class="line">or al,00100000B</span><br><span class="line">mov [bx],al</span><br><span class="line">inc bx</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br><span class="line">123456789101112131415161718192021222324252627282930313233</span><br></pre></td></tr></table></figure>

<h5 id="bx-idata-的内存表示方法与数组处理"><a href="#bx-idata-的内存表示方法与数组处理" class="headerlink" title="[bx+idata]的内存表示方法与数组处理"></a><strong>[bx+idata]的内存表示方法与数组处理</strong></h5><p>除了使用[bx]来表示一个内存单元外，我们还可以使用[bx+idata]来表示一个内存单元，他表示的意思是偏移地址为(bx)+idata（bx中的数值加idata）的内存单元。当然也可写为[idata+bx]，除此之外还可写为，200[bx]，[bx].200。</p>
<p>既然有了这种表示方法，我们就可以使用这种方法来操作数组，刚才将两个字符串改变大小写的代码的循环部分可以如下优化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">s:mov al,[bx]</span><br><span class="line">and al,11011111B</span><br><span class="line">mov [bx],al</span><br><span class="line">mov al,[5+bx]</span><br><span class="line">or al,00100000B</span><br><span class="line">mov [5+bx],al</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line">···</span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure>

<p>当然也可写为0[bx]和5[bx]，注意这种写法和C语言中数组的相似之处：C语言中数组表示为a[i]，汇编语言中表示为5[bx]。</p>
<h5 id="SI和DI寄存器"><a href="#SI和DI寄存器" class="headerlink" title="SI和DI寄存器"></a><strong>SI和DI寄存器</strong></h5><p>SI和DI功能和BX相似，但不可以拆分为两个8位寄存器。也就是说下面代码等价：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx|si|di,0</span><br><span class="line">mov ax,[bx|si|di]</span><br><span class="line">mov ax,[bx|si|di+123]</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>所以在这里可以使用更方便的方式：[bx+si]和[bx+di]，这两个式子表示偏移地址为(bx)+(si)的内存单元，使用方法如：mov ax,[bx+si]等价于<code>mov ax,[bx][si]。</code></p>
<p>当然，有了这些表示方法，自然就有[bx+si+idata]和[bx+di+idata]，相似的，也可以写成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx+200+si]</span><br><span class="line">mov ax,[200+bx+si]</span><br><span class="line">mov ax,200[bx][si]</span><br><span class="line">mov ax,[bx].200[si]</span><br><span class="line">mov ax,[bx][si].200</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>那我们总结一下这些内存寻址方法：</p>
<ul>
<li>[idata]用一个常量表示偏移地址，直接定位一个内存单元</li>
<li>[bx]用一个变量表示偏移地址，定位一个内存单元</li>
<li>[bx+idata]用一个常量和一个变量表示偏移地址，可在一个起始地址的基础上间接定位一个内存单元</li>
<li>[bx+si]用两个变量表示偏移地址</li>
<li>[bx+si+idata]用两个变量和一个常量表示偏移地址</li>
</ul>
<p>使用双循环，使用一个寄存器暂存cs的值，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">mov cx,4</span><br><span class="line">s0:mov dx,cx</span><br><span class="line">mov si,0</span><br><span class="line"></span><br><span class="line">mov cx,3</span><br><span class="line">s:mov al,[bx+si]</span><br><span class="line">and al,11011111b</span><br><span class="line">mov [bx+si],al</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">add bx,16</span><br><span class="line">mov cx,dx</span><br><span class="line">loop s0</span><br><span class="line">···</span><br><span class="line">12345678910111213141516</span><br></pre></td></tr></table></figure>

<p>假如循环比较复杂，没有多余的寄存器可用，我们可以使用内存暂存cx或其他数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">dw 0</span><br><span class="line">···</span><br><span class="line">mov cx,4</span><br><span class="line">s0:mov ds:[40H],cx</span><br><span class="line">mov si,0</span><br><span class="line"></span><br><span class="line">mov cx,3</span><br><span class="line">s:mov al,[bx+si]</span><br><span class="line">and al,11011111b</span><br><span class="line">mov [bx+si],al</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">add bx,16</span><br><span class="line">mov cx,ds:[40H]</span><br><span class="line">loop s0</span><br><span class="line">···</span><br><span class="line">123456789101112131415161718</span><br></pre></td></tr></table></figure>

<p>这么使用的话注意需要在数据段声明用来暂存的内存，好在程序加载时分配出来。当然，在需要暂存的地方，还是建议使用栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">dw 0,0,0,0,0,0,0,0</span><br><span class="line">···</span><br><span class="line">mov ax,stacksg</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,16</span><br><span class="line">···</span><br><span class="line">mov cx,4</span><br><span class="line">s0:push cx</span><br><span class="line">mov si,0</span><br><span class="line"></span><br><span class="line">mov cx,3</span><br><span class="line">s:mov al,[bx+si]</span><br><span class="line">and al,11011111b</span><br><span class="line">mov [bx+si],al</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">add bx,16</span><br><span class="line">pop cx</span><br><span class="line">loop s0</span><br><span class="line">···</span><br><span class="line">12345678910111213141516171819202122</span><br></pre></td></tr></table></figure>

<h3 id="数据处理的两个基本问题"><a href="#数据处理的两个基本问题" class="headerlink" title="数据处理的两个基本问题"></a>数据处理的两个基本问题</h3><h5 id="两个基本问题"><a href="#两个基本问题" class="headerlink" title="两个基本问题"></a><strong>两个基本问题</strong></h5><ol>
<li>处理的数据在什么地方</li>
<li>要处理的数据有多长</li>
</ol>
<p>接下来的讨论中，使用reg来表示一个寄存器，使用sreg来表示一个段寄存器。所以：</p>
<ul>
<li>reg：ax,bx,cx,dx,ah,al,bh,bl,ch,cl,dh,dl,sp,bp,si,di</li>
<li>sreg：ds,ss,cs,es</li>
</ul>
<h5 id="bx，si，di和bp"><a href="#bx，si，di和bp" class="headerlink" title="bx，si，di和bp"></a><strong>bx，si，di和bp</strong></h5><p>在8086CPU中，只有这四个寄存器可以使用[···]来进行内存寻址，可以单个出现，或以下面组合出现（常数可以随意出现在这些表示方法中）：</p>
<ul>
<li>bx+si/di</li>
<li>bp+si/di</li>
</ul>
<p>注：如果使用了bp来寻址，而没有显式的表明段地址，默认使用ss段寄存器，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bp]              ;(ax)&#x3D;((ss)*16+(bp))</span><br><span class="line">mov ax,[bp+idata]        ;(ax)&#x3D;((ss)*16+(bp)+idata)</span><br><span class="line">mov ax,[bp+si]           ;(ax)&#x3D;((ss)*16+(bp)+(si)+idata)</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<h5 id="数据的位置"><a href="#数据的位置" class="headerlink" title="数据的位置"></a><strong>数据的位置</strong></h5><p>绝大部分机器指令都是用来处理数据的，基本可分为读取，写入，运算。在机器指令这个层面上，并不关心数据是什么，而关心指令执行前数据的位置。一般数据会在三个地方，CPU内部，内存，端口。</p>
<p>汇编语言中使用三个概念来表示数据的位置：</p>
<ul>
<li>立即数（idata）<ul>
<li>对于直接包含在机器指令中的数据，在汇编语言中称为立即数</li>
<li>例：mov ax,1 add bx,2000h</li>
</ul>
</li>
<li>寄存器<ul>
<li>指令要处理的数据在寄存器中，在汇编指令中给出相应寄存器名</li>
<li>例：mov ax,bx mov ds,ax</li>
</ul>
</li>
<li>段地址（SA）和偏移地址（EA）<ul>
<li>指令要处理的数据在内存中，在指令中使用[X]方式给出，SA在某个段寄存器中</li>
<li>例：mov ax,[0] mov ax,[di]</li>
</ul>
</li>
</ul>
<p>总结一下寻址方式：</p>
<table>
<thead>
<tr>
<th>寻址方式</th>
<th>含义</th>
<th>名称</th>
</tr>
</thead>
<tbody><tr>
<td>[idata]</td>
<td>EA=idata;SA=(DS)</td>
<td>直接寻址</td>
</tr>
<tr>
<td>[bx|si|di|bp]</td>
<td>EA=(bx|si|di|bp);SA=(DS)</td>
<td>寄存器间接寻址</td>
</tr>
<tr>
<td>[bx|si|di|bp+idata]</td>
<td>EA=(bx|si|di|bp+idata);SA=(DS)</td>
<td>寄存器相对寻址</td>
</tr>
<tr>
<td>[bx|bp+si|di]</td>
<td>EA=(bx|bp+si|di);SA=(DS|SS)</td>
<td>基址变址寻址</td>
</tr>
<tr>
<td>[bx|bp+si|di+idata]</td>
<td>EA=(bx|bp+si|di+idata);SA=(DS|SS)</td>
<td>相对基址变址寻址</td>
</tr>
</tbody></table>
<h5 id="数据的长度"><a href="#数据的长度" class="headerlink" title="数据的长度"></a><strong>数据的长度</strong></h5><p>8086CPU中可以指定两种尺寸的数据，byte和word，所以在使用数据的时候要指明数据尺寸。</p>
<ul>
<li>在有寄存器参与的时候使用寄存器的种类区分<ul>
<li>字：mov ax,1</li>
<li>字节：mov al,1</li>
</ul>
</li>
<li>在没有寄存器参与的时候，使用X ptr指明内存单元长度，X是word或byte<ul>
<li>字：mov word ptr ds:[0],1 add word ptr [bx],2</li>
<li>字节：mov byte ptr ds:[0],1 add byte ptr [bx],2</li>
</ul>
</li>
<li>其他默认指明处理类型的指令<ul>
<li>push [1000H]，push默认只进行字操作</li>
</ul>
</li>
</ul>
<p>灵活使用寻址方式的例子，修改下面内存空间中的数据：</p>
<p>段seg:60</p>
<table>
<thead>
<tr>
<th>起始地址</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>00</td>
<td>‘DEC’</td>
</tr>
<tr>
<td>03</td>
<td>‘Ken Oslen’</td>
</tr>
<tr>
<td>0C</td>
<td>137</td>
</tr>
<tr>
<td>0E</td>
<td>40</td>
</tr>
<tr>
<td>10</td>
<td>‘PDP’</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">mov ax,seg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,60h</span><br><span class="line"></span><br><span class="line">mov word ptr [bx].0ch,38    ;第三字段改为38</span><br><span class="line"></span><br><span class="line">add word ptr [bx].0eh,70    ;第四字段改为70</span><br><span class="line"></span><br><span class="line">mov si,0</span><br><span class="line">mov byte ptr [bx].10h[si],&#39;v&#39;   ;修改最后一个字段的三个字符</span><br><span class="line">inc si</span><br><span class="line">mov byte ptr [bx].10h[si],&#39;A&#39;</span><br><span class="line">inc si</span><br><span class="line">mov byte ptr [bx].10h[si],&#39;X&#39;</span><br><span class="line">···</span><br><span class="line">12345678910111213141516</span><br></pre></td></tr></table></figure>

<p>这段代码中地址的使用类似c++中结构体的使用。[bx].idata.[si]，就类似与c++中的dec.cp[i]。dec是结构体，cp是结构体中的字符串成员，[i]表示第几个字符。</p>
<h5 id="div指令"><a href="#div指令" class="headerlink" title="div指令"></a><strong>div指令</strong></h5><p>div是除法指令，需要注意以下三点：</p>
<ul>
<li>除数：8位或16位，在一个reg或内存单元中</li>
<li>被除数：默认在AX或DX中，如果除数8位，被除数则为16位，放在AX中；如果除数16位，则被除数32位，在DX和AX中，DX存放高16位，AX放低16位。</li>
<li>结果，除数8位，结果（商）存放在AL中，AH存放余数；如果除数16位，则AX存放商，DX存放余数</li>
</ul>
<p>格式：div reg或div 内存单元，所以div byte ptr ds:[0]表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(al)&#x3D;(ax)&#x2F;((ds)*16+0)的商;</span><br><span class="line">(ah)&#x3D;(ax)&#x2F;((ds)*16+0)的余数；</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>div word ptr es:[0]表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(al)&#x3D;[(dx)*10000H+(ax)]&#x2F;((es)*16+0)的商</span><br><span class="line">(ah)&#x3D;[(dx)*10000H+(ax)]&#x2F;((es)*16+0)的余数</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>例：计算100001/100，因为100001(186A1H)大于65535，则需要存放在ax和dx两个寄存器，那么除数100只能存放在一个16位的寄存器中，实现代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov dx,1</span><br><span class="line">mov ax,86A1H</span><br><span class="line">mov bx,100</span><br><span class="line">div bx</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<p>执行之后(ax)=03E8H(1000),(dx)=1。</p>
<h5 id="伪指令dd"><a href="#伪指令dd" class="headerlink" title="伪指令dd"></a><strong>伪指令dd</strong></h5><p>dd是一个伪指令，类似dw，但dd是用来定义dword（double word，双字），如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dd 1  ;2字，4字节</span><br><span class="line">dw 1  ;1字，2字节</span><br><span class="line">db 1  ;1字节</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>将data段中第一个数据除以第二个数据，商存入第三个数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">data segment</span><br><span class="line">dd 100001</span><br><span class="line">dw 100</span><br><span class="line">dw 0</span><br><span class="line">data ends</span><br><span class="line">···</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,ds:[0]</span><br><span class="line">mov dx,ds:[2]</span><br><span class="line">div word ptr ds:[4]</span><br><span class="line">mov ds:[6],ax</span><br><span class="line">···</span><br><span class="line">1234567891011121314</span><br></pre></td></tr></table></figure>

<p>总结一下div相关：</p>
<ul>
<li>div后面跟的是除数</li>
<li>被除数位数是除数两倍</li>
<li>被除数存在ax中或ax+dx（ax低，dx高）</li>
<li>商在ax或al中，余数在ah或dx中（高余数，低商）</li>
</ul>
<h5 id="dup"><a href="#dup" class="headerlink" title="dup"></a><strong>dup</strong></h5><p>dup是一个操作符，由编译器识别，和db,dw,dd配合使用，如：</p>
<p>db 3 dup (0)表示定义了三个值是0的字节，等价于db 0,0,0</p>
<p>db 3 dup (1,2,3)等价于db 1,2,3,1,2,3,1,2,3 共九个字节</p>
<p>db 3 dup (‘abc’,‘ABC’)等价于db ‘abcABCabcABCabcABC’</p>
<p>综上，db|dw|dd 重复次数 dup (重复内容)</p>
<h3 id="转移指令原理"><a href="#转移指令原理" class="headerlink" title="转移指令原理"></a>转移指令原理</h3><h5 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a><strong>转移指令</strong></h5><p>可以修改IP或同时修改CS，IP的系统指令称为转移指令，可分为以下几类：</p>
<ul>
<li>转移行为：<ul>
<li>只修改IP，称为段内转移，如jmp ax</li>
<li>同时修改CS和IP，称为段间转移，如jmp 1000:0</li>
</ul>
</li>
<li>修改范围（段内转移）：<ul>
<li>短转移：修改IP范围-128~127</li>
<li>近转移：修改IP范围-32768~32767</li>
</ul>
</li>
<li>转移指令分类：<ul>
<li>无条件转移：jmp</li>
<li>条件转移</li>
<li>循环指令</li>
<li>过程</li>
<li>中断</li>
</ul>
</li>
</ul>
<h5 id="offset操作符"><a href="#offset操作符" class="headerlink" title="offset操作符"></a><strong>offset操作符</strong></h5><p>offset是由编译器处理的符号，它能去的标号的偏移地址，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start:mov ax,offset start</span><br><span class="line">s:mov ax,offset s</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>这里就是将start和s的偏移地址分别送给ax，也就是0和3</p>
<h5 id="jmp指令"><a href="#jmp指令" class="headerlink" title="jmp指令"></a><strong>jmp指令</strong></h5><p>jmp是无条件转移指令，可以只修改IP也可以同时修改CS和IP，只要给出两种信息，要转移的目的地址和专一的距离。</p>
<p>依据位移的jmp指令：jmp short 标号（转到标号处执行指令）。这个指令实现的是段内短转移，对IP修改范围是-128~127，指令结束后CS:IP指向标号的地址，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0BBD:0000   start:mov ax,0  (B80000)</span><br><span class="line">0BBD:0003   jmp short s   (EB03)</span><br><span class="line">0BBD:0005   add ax,1    (050100)</span><br><span class="line">0BBD:0008   s:inc ax    (40)</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<p>执行之后ax值为1，因为跳过了add指令。</p>
<p>还应注意的是，jmp short短转移指令并不会在机器码中直接写明需要转移的地址（0BBD:0008）,jmp的机器码是EB03并没有包含转移的地址，这里的转移距离是相对计算而出的地址，来看下面的执行过程：</p>
<ol>
<li>(CS)=0BBDH,(IP)=0006H，CS:IP指向EB03（jmp short s）</li>
<li>读取指令EB03进入指令缓冲器</li>
<li>(IP)=(IP)+指令长度，即(IP)=(IP)+2=0008H，之后CS:IP指向add ax,1</li>
<li>CPU指向指令缓冲器中的指令EB03</li>
<li>执行之后(IP)=000BH，指向inc ax</li>
</ol>
<p>在jmp short s的机器码中，包含的并不是转移的地址，而是转移的位移，这里的位移是相对计算出来的，用8位一字节来表示，所以表示范围是-128<del>127，用补码表示。计算方法如是，8位位移=标号处地址-jmp下一条指令的地址。当然还有一种类似的指令是jmp near ptr 标号，是近转移，原理一样，只是表示位移的是字类型16位，表示范围-32768</del>32767。</p>
<h5 id="jmp-地址远转移"><a href="#jmp-地址远转移" class="headerlink" title="jmp+地址远转移"></a><strong>jmp+地址远转移</strong></h5><p>jmp far ptr 标号实现的是段间转移，也就是远转移，它的机器码中指明了转移的目的地址的CS和IP的值，如下面例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0BBD:0000   start:mov ax,0    (B80000)</span><br><span class="line">0BBD:0003   mov bx,0    (BB0000)</span><br><span class="line">0BBD:0006   jmp far ptr s    (EA0B01BD0B)</span><br><span class="line">0BBD:000B   db 256 dup (0)    </span><br><span class="line">0BBD:010B   s:add ax,1    </span><br><span class="line">0BBD:010X   inc ax</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<p>可以看出，jmp的机器码中明确指明了跳转位置s的地址0BBD:010B，在低位的是IP的值，高位的是CS的值。</p>
<h5 id="jmp-寄存器-内存转移"><a href="#jmp-寄存器-内存转移" class="headerlink" title="jmp+寄存器|内存转移"></a><strong>jmp+寄存器|内存转移</strong></h5><p>jmp+寄存器：jmp 16位reg，实现的是(IP)=(16位reg)，之前讨论过，直接修改IP的值为寄存器中的值。</p>
<p>jmp+内存：jmp加内存使用的时候有两种用法：</p>
<ul>
<li>jmp word ptr 内存单元地址（段内转移）<ul>
<li>从内存单元地址处开始存放一个座位转移目的的偏移地址的字</li>
<li>内存单元支持任何寻址方式</li>
<li>如jmp word ptr ds:[0]，执行后(IP)=0123H(ds:[0]中的值是123H)</li>
</ul>
</li>
<li>jmp dword ptr 内存单元地址（段间转移）<ul>
<li>从内存单元地址处开始存放两个字，高位存放段地址，低位偏移地址作为转移的目的地址</li>
<li>(CS)=(内存单元地址+2),(IP)=(内存单元地址)，支持任一种寻址方式</li>
<li>如jmp dword ptr [bx]跳转到0:123H</li>
</ul>
</li>
</ul>
<h5 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a><strong>jcxz指令</strong></h5><p>jcxz指令为条件转移指令，所有的条件转移指令都是短转移，转移范围是-128~127。使用格式是jcxz 标号，功能是如果(cx)=0则跳转到标号处执行；如果(cx)!=0，那么什么也不做继续执行代码。</p>
<h5 id="loop指令-1"><a href="#loop指令-1" class="headerlink" title="loop指令"></a><strong>loop指令</strong></h5><p>loop为循环指令，所有的循环指令都是短转移，转移范围是-128~127。使用格式是loop 标号，功能是如果(cx)!=0那么跳转到标号处执行；如果(cx)=0那么什么也不做继续执行程序。</p>
<h5 id="根据位移进行转移的指令总结"><a href="#根据位移进行转移的指令总结" class="headerlink" title="根据位移进行转移的指令总结"></a><strong>根据位移进行转移的指令总结</strong></h5><p>下面几条指令是根据位移进行转移（相对计算转移位置，而不是直接提供转移目的的IP和CS的值）</p>
<ul>
<li>jmp short 标号</li>
<li>jmp near ptr 标号</li>
<li>jcxz 标号</li>
<li>loop 标号</li>
</ul>
<p>这些指令之所以是间接计算标号的位置，是为了方便在代码中浮动装配，使得循环体或这些指令的代码段在任何位置都可以执行（不要超跳转范围）。而编译器会对跳转的范围进行检测，如果跳转超过了范围，编译器会报错。</p>
<p>注：jmp 2100:0是debug使用的汇编指令，编译器并不认识。</p>
<h3 id="call和ret指令"><a href="#call和ret指令" class="headerlink" title="call和ret指令"></a>call和ret指令</h3><h5 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a><strong>ret和retf</strong></h5><p>ret和call都是转移指令，都是修改IP的值，或同时修改CS和IP。</p>
<p>ret指令用栈中的数据修改IP，实现的是近转移；retf指令用栈中的数据修改CS和IP的值，实现远转移。格式：直接用 ret。</p>
<p>ret执行步骤：</p>
<ol>
<li>(IP)=((SS)*16+(SP))</li>
<li>(SP)=(SP)+2</li>
</ol>
<p>retf执行步骤：</p>
<ol>
<li>(IP)=((SS)*16+(SP))</li>
<li>(SP)=(SP)+2</li>
<li>(CS)=((SS)*16+(SP))</li>
<li>(SP)=(SP)+2</li>
</ol>
<p>所以ret指令相当于 pop ip，执行retf指令相当于执行pop ip,pop cs。</p>
<h5 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a><strong>call指令</strong></h5><p>call指令也是一个转移指令，执行格式：call 目标（具体使用接下来说明），call的执行步骤：</p>
<ol>
<li>将当前的IP或CS和IP入栈</li>
<li>转移</li>
</ol>
<p>call不能实现短转移，但它实现转移的原理和jmp相同。</p>
<p>根据位移转移：call 标号，近转移，16位转移范围，也是使用相对的转移地址。</p>
<p>执行步骤：</p>
<ol>
<li>(SP)=(SP)-2</li>
<li>((SS)*16+(SP))=(IP)</li>
<li>(IP)=(IP)+16</li>
</ol>
<p>所以执行这条命令相当于执行push ip,jmp near ptr 标号。</p>
<p>直接使用地址进行（远）转移：call far ptr 标号，执行步骤：</p>
<ol>
<li>(SP)=(SP)-2</li>
<li>((SS)*16+(SP))=(CS)</li>
<li>(SP)=(SP)-2</li>
<li>((SS)*16+(SP))=(IP)</li>
<li>(CS)=标号所在的段的段地址</li>
<li>(IP)=标号的偏移地址</li>
</ol>
<p>所以执行call far ptr 标号相当于执行push cs,push ip,jmp far ptr 标号</p>
<p>使用寄存器的值作为call的跳转地址：call 16位reg</p>
<ol>
<li>(SP)=(SP)-2</li>
<li>((SS)*16+(SP))=(IP)</li>
<li>(IP)=(16为reg)</li>
</ol>
<p>相当于执行push ip,jmp 16位reg</p>
<p>使用内存中的值作为call的跳转地址：call word ptr 内存单元地址，当然还有call dword ptr 内存单元地址，这样进行的就是远转移。</p>
<h5 id="联合使用ret和call"><a href="#联合使用ret和call" class="headerlink" title="联合使用ret和call"></a><strong>联合使用ret和call</strong></h5><p>联合使用ret和call实现子程序的框架：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">main:</span><br><span class="line">···</span><br><span class="line">call sub1</span><br><span class="line">···</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">sub1:</span><br><span class="line">···</span><br><span class="line">call sub2</span><br><span class="line">···</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">sub2:</span><br><span class="line">···</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end main</span><br><span class="line">1234567891011121314151617181920</span><br></pre></td></tr></table></figure>

<h5 id="mul指令"><a href="#mul指令" class="headerlink" title="mul指令"></a><strong>mul指令</strong></h5><p>mul是乘法指令，使用时应注意，两个相乘的数，要么都是8位，要么都是16位，如果是8位，那么其中一个默认放在al中，另一个在一个8位reg或字节内存单元中；若是16位，则一个默认在ax中，另一个在16位reg或字内存单元中。如果是8位乘法， 则结果放在ax中，结果是16位；若是16位乘法，结果默认在ax和dx中，dx高位，ax低位，共32位。</p>
<p>格式：mul reg 或 mul 内存单元，支持内存单元的各种寻址方式。</p>
<p>如mul word ptr [bx+si+8]代表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(ax)&#x3D;(ax)*((ds)*16+(bx)+(si)+8)低16位</span><br><span class="line">(dx)&#x3D;(ax)*((ds)*16+(bx)+(si)+8)高16位</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>例：计算100*10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,100</span><br><span class="line">mov bl,10</span><br><span class="line">mul bl</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<h5 id="参数的传递和模块化编程"><a href="#参数的传递和模块化编程" class="headerlink" title="参数的传递和模块化编程"></a><strong>参数的传递和模块化编程</strong></h5><p>看下面一段程序：计算data中第一行的数的立方存在第二行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">dw 1,2,3,4,5,6,7,8</span><br><span class="line">dd 0,0,0,0,0,0,0,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov di,16</span><br><span class="line"></span><br><span class="line">mov cs,8</span><br><span class="line">s:mov bx,[si]</span><br><span class="line">call cube</span><br><span class="line">mov [di],ax</span><br><span class="line">mov [di].2,dx</span><br><span class="line">add si,2</span><br><span class="line">add di,4</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">cube:mov ax,bx</span><br><span class="line">mul bx</span><br><span class="line">mul bx</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">12345678910111213141516171819202122232425262728293031</span><br></pre></td></tr></table></figure>

<h5 id="寄存器冲突"><a href="#寄存器冲突" class="headerlink" title="寄存器冲突"></a><strong>寄存器冲突</strong></h5><p>观察下面将data中的数据全转化为大写的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">db &#39;word&#39;,0</span><br><span class="line">db &#39;unix&#39;,0</span><br><span class="line">db &#39;wind&#39;,0</span><br><span class="line">db &#39;good&#39;,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov cx,4</span><br><span class="line">s:mov si,bx</span><br><span class="line">call capital</span><br><span class="line">add bx,5</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">capital:mov cl,[si]</span><br><span class="line">mov ch,0</span><br><span class="line">jcxz ok</span><br><span class="line">and byte ptr [si],11011111b</span><br><span class="line">inc si</span><br><span class="line">jmp short capital</span><br><span class="line">ok:ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">12345678910111213141516171819202122232425262728293031</span><br></pre></td></tr></table></figure>

<p>这段代码有一个问题出在，主函数部分使用cx设置循环次数4次，在循环中调用了子函数，而子函数中有一个判断语句jcxz也是用了cx，并且在之前修改了cx的值，造成逻辑错误。虽然修改的方法有很多，但我们应遵循以下的标准：</p>
<ul>
<li>编写调用子程序的程序不必关心子程序使用了什么寄存器</li>
<li>编写子程序不用关心调用子程序的程序使用了什么寄存器</li>
<li>不会发生寄存器冲突</li>
</ul>
<p>针对这三点，我们可以如下修改代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">capital:push cx</span><br><span class="line">push si</span><br><span class="line"></span><br><span class="line">change:mov cl,[si]</span><br><span class="line">mov ch,0</span><br><span class="line">jcxz ok</span><br><span class="line">and byte ptr [si],11011111b</span><br><span class="line">inc si</span><br><span class="line">jmp short change</span><br><span class="line"></span><br><span class="line">ok:pop si</span><br><span class="line">pop cx</span><br><span class="line">ret</span><br><span class="line">···</span><br><span class="line">123456789101112131415</span><br></pre></td></tr></table></figure>

<p>虽然和上面的程序中没有冲突的是si，但我们保险起见，在子程序开始时将子程序用到的所有的寄存器的内容存入栈中，在返回之前在出栈回到相应寄存器中。这样无论调用子程序的程序使用了什么寄存器，都不会产生寄存器冲突。</p>
<h3 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h3><h5 id="标志寄存器-1"><a href="#标志寄存器-1" class="headerlink" title="标志寄存器"></a><strong>标志寄存器</strong></h5><p>CPU中有一种特殊的寄存器——标志寄存器（不同CPU中的个数和结构都可能不同），主要有以下三种作用：</p>
<ol>
<li>存储相关指令的某些执行结果</li>
<li>为CPU执行相关质量提供行为依据</li>
<li>控制CPU相关工作方式</li>
</ol>
<p>8086CPU中的标志寄存器有16位，其中存储的信息通常被称为程序状态字（PSW），标志寄存器以下简称为flag。标志位如图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0</span><br><span class="line">				OF	DF	IF	TF	SF	ZF		AF		PF		CF</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>如上图所示，1,3,5,12,13,14,15位没有使用，没有任何意义，而其他几位都有不同的含义。</p>
<h5 id="ZF标志"><a href="#ZF标志" class="headerlink" title="ZF标志"></a><strong>ZF标志</strong></h5><p>ZF位于flag第6位，零标志位，功能是记录相关指令执行后结果是否为0，如果结果为0，则ZF=1，否则ZF=0。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>执行后结果为0，ZF=1。一般情况下，运算指令（如add,sub,mul,div,inc,or,and）影响标志寄存器，而传送指令（如mov,push,pop）不影响标志寄存器。</p>
<h5 id="PF标志"><a href="#PF标志" class="headerlink" title="PF标志"></a><strong>PF标志</strong></h5><p>flag的第2位是PF标志位，奇偶标志位，功能是记录相关指令执行后，其结果的所有bit中1的个数是否为偶数，若1的个数是偶数，pf=1，如果是奇数，fp=0。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">add al,10</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>执行后结果为00001011b，有3个1，所以PF=0。</p>
<h5 id="SF标志"><a href="#SF标志" class="headerlink" title="SF标志"></a><strong>SF标志</strong></h5><p>flag的第7位是SF标志位，符号标志位，它记录相关指令执行后，结果是否为负，如果结果为负，则sf=1，结果为正，sf=0。计算机中通常用补码表示数据，一个数可以看成有符号数或无符号数，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000001B，可以看成无符号1或有符号+1</span><br><span class="line">10000001B，可以看成无符号129或有符号-127</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>也就是说对于同一个数字，可以当做有符号数运算也可以当做无符号数运算。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,10000001b</span><br><span class="line">add al,1</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>这段代码结果是(al)=10000010b，可以将add指令进行的运算当做无符号运算，那么相当于129+1=130，也可以当做有符号运算，相当于-127+1=-126。SF标志就是在进行有符号运算的时候记录结果的符号的，当进行无符号运算的时候SF无意义（但还会影响SF，只是对我们来说没有意义了）。</p>
<h5 id="CF标志"><a href="#CF标志" class="headerlink" title="CF标志"></a><strong>CF标志</strong></h5><p>flag的第0位是CF标志位，进位标志位，一般情况下载进行无符号运算时，他记录了运算结果的最高有效为向更高为的进位值，或从更高位的借位值。加入一个无符号数据是8位的，也就是0-7个位，那么在做加法的时候就可能造成进位到第8位，这时并不是丢弃这个进位，而是记录在falg的CF位上。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,98h</span><br><span class="line">add al,al</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>执行后al=30h，CF=1。当两个数据做减法的时候有可能向更高位借位，如97h-98h借位后相当于197h-198h，CF也可以用来记录借位，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,97h</span><br><span class="line">sub al,98h</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>执行后(al)=FFH，CF=1记录了向更高位借位的信息。</p>
<h5 id="OF标志"><a href="#OF标志" class="headerlink" title="OF标志"></a><strong>OF标志</strong></h5><p>在进行有符号运算的时候，如果结果超过了机器能表示的范围称为“溢出”。机器能表示的范围是指如8位寄存器存放或一个内存单元存放，表示范围就是-128~127,16位同理。如果超出了这个范围就叫做溢出，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov al,98</span><br><span class="line">add al,99</span><br><span class="line"></span><br><span class="line">mov al,0F0H</span><br><span class="line">add al,088H</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>第一段代码(al)=(al)+99=98+99=197超过了8位能表示的有符号数的范围，第二段代码结果(al)=(al)+(-120)=(-16)+(-12-)=-136也超过了8位有符号的范围，所以计算的结果是不可信的。如第一段代码计算之后(al)=0C5H，换成补码表示的是-59,98+99=-59很明显是不正确的结果。</p>
<p>flag的第11位是OF标志位，溢出标志位，一般情况下，OF记录有符号数运算结果是否溢出，如果溢出则OF=1，如果没有溢出，OF=0。所以CF是对无符号数的标志，OF是对有符号的标志。但对于一个运算指令，他们是同时生效的，只不过这个指令究竟是有符号还是无符号，是看实际的操作的。有符号CF无意义，无符号OF无意义。</p>
<h5 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a><strong>adc指令</strong></h5><p>adc是带进位加法指令，利用了CF标志位上记录的进位值。格式：adc 操作对象1,操作对象2。功能：操作对象1=操作对象1+操作对象2+CF。如abc ax,bx实现的是(ax)=(ax)+(bx)+CF，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">mov bx,1</span><br><span class="line">sub bx,ax</span><br><span class="line">adc ax,1</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<p>注意这段代码，首先ax中的值是2，bx中的值是1，然后进行(bx)-(ax)的计算，结果是-1造成了无符号的借位，此时CF=1，在进行adc ax,1时，进行的是(ax)+1+CF=2+1+1=4。仔细分析一下就可以发现，如果把整个加法分开，低位先相加，然后高位相加再加上进位CF， 就是一个完整的加法运算，也就是说add ax,dx这个指令可以拆分为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add al,bl</span><br><span class="line">adc ah,bh</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>所以有了adc这个指令我们就可以完成一些更庞大的数据量的加法运算。如计算1EF000H+000H的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,001eh</span><br><span class="line">mov bx,0f000h</span><br><span class="line">add bx,1000h</span><br><span class="line">adc ax,0020h</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<p>注：inc和loop指令不影响CF位。</p>
<h5 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a><strong>sbb指令</strong></h5><p>sbb和adc类似，是带借位的减法，格式：sbb 操作对象1,操作对象2，执行的功能是操作对象1=操作对象1-操作对象2-CF，如：sbb ax,bx即(ax)=(ax)-(bx)-CF。sbb指令影响CF。</p>
<h5 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a><strong>cmp指令</strong></h5><p>cmp是比较指令，cmp的功能相当于减法，只是不保存结果。cmp执行后影响标志寄存器，其他相关指令通过识别被影响的标志位来得知结果。格式：cmp 操作对象1,操作对象2，执行功能是计算对操作对象1-操作对象2但不保存结果，仅仅根据结果对标志位进行设置，如：cmp ax,ax结果为0，但并不保存在ax中，执行之后zf=1,pf=1,sf=0,cf=0,of=0。若执行cmp ax,bx通过标志位就可以判断结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">若(ax)&#x3D;(bx)则(ax)-(bx)&#x3D;0,zf&#x3D;1</span><br><span class="line">若(ax)!&#x3D;(bx)则(ax)-(bx)!&#x3D;0,zf&#x3D;0</span><br><span class="line">若(ax)&lt;(bx)则(ax)-(bx)产生借位,cf&#x3D;1</span><br><span class="line">若(ax)&gt;&#x3D;(bx)则(ax)-(bx)不产生借位,cf&#x3D;0</span><br><span class="line">若(ax)&gt;(bx)则(ax)-(bx)既不产生借位,结果又不为0,cf&#x3D;0且zf&#x3D;0</span><br><span class="line">若(ax)&lt;&#x3D;(bx)则(ax)-(bx)既可能借位,结果可能为0,cf&#x3D;1或zf&#x3D;1</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<p>但实际上往往会出现溢出，如34-(-96)=82H(82H是-126的补码)，但应该等于130超出了补码表示的范围，所以sf=1。我们可以同时检验sf和of两个来验证cmp的结果：cmp ah,bh</p>
<ul>
<li>若sf=1，of=0说明没有溢出，那么sf的计算结果正确(ah)&lt;(bh)</li>
<li>若sf=1，of=1说明出现了溢出，那么sf结果相反(ah)&gt;(bh)</li>
<li>若sf=0，of=1说明有溢出，那么sf结果相反(ah)&lt;(bh)</li>
<li>若sf=0，of=0说明没有溢出，那么结果正确(ah)&gt;=(bh)</li>
</ul>
<h5 id="检测比较结果的条件转移指令"><a href="#检测比较结果的条件转移指令" class="headerlink" title="检测比较结果的条件转移指令"></a><strong>检测比较结果的条件转移指令</strong></h5><p>下面几条指令和cmp一起使用，检测不同的标志位来达到不同的条件跳转效果：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
<th>检测的标志位</th>
</tr>
</thead>
<tbody><tr>
<td>je</td>
<td>等于则转移</td>
<td>zf=1</td>
</tr>
<tr>
<td>jne</td>
<td>不等于转移</td>
<td>zf=0</td>
</tr>
<tr>
<td>jb</td>
<td>小于转移</td>
<td>cf=1</td>
</tr>
<tr>
<td>jnb</td>
<td>不小于转移</td>
<td>cf=0</td>
</tr>
<tr>
<td>ja</td>
<td>大于转移</td>
<td>cf=0且zf=0</td>
</tr>
<tr>
<td>jna</td>
<td>不大于转移</td>
<td>cf=1或zf=1</td>
</tr>
</tbody></table>
<p>指令中的字母含义如下：</p>
<ul>
<li>e:equa;</li>
<li>ne:not equal</li>
<li>b:below</li>
<li>nb:not below</li>
<li>a:above</li>
<li>na:not above</li>
</ul>
<p>上面的检测都是在cmp进行无符号比较时的检测位，有符号数检测原理一样，只是检测的标志位不同而已。下面看一个例子，如果(ah)=(bh)则(ah)=(ah)+(ah)，否则(ah)=(ah)+(bh)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmp ah,bh</span><br><span class="line">je s</span><br><span class="line">add ab,bh</span><br><span class="line">jmp short ok</span><br><span class="line">s:add ah,ah</span><br><span class="line">ok:···</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<p>这里注意的是，je检测的是zf位，而不管之前执行的是什么指令，只要zf=1就会发生转移，所以cmp的位置需要仔细的把控，当然是否和cmp配合使用也是取决于编程者，下面例子实现了统计data中数值为8的字节个数，然后用ax保存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">data segment</span><br><span class="line">db 8,11,8,1,8,5,63,38</span><br><span class="line">data ends</span><br><span class="line">···</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov ax,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:cmp byte ptr [bx],8</span><br><span class="line">jne next</span><br><span class="line">inc ax</span><br><span class="line">next:inc bx</span><br><span class="line">loop s</span><br><span class="line">···</span><br><span class="line">12345678910111213141516</span><br></pre></td></tr></table></figure>

<h5 id="DF标志位和串传送指令"><a href="#DF标志位和串传送指令" class="headerlink" title="DF标志位和串传送指令"></a><strong>DF标志位和串传送指令</strong></h5><p>flag的第10位是DF标志位，方向标志位，在串处理中，每次操作si，di的增减。</p>
<ul>
<li>df=0每次操作后si，di递增</li>
<li>df=1每次操作后si，di递减</li>
</ul>
<p>串传送指令，movsb，这个指令相当于执行：</p>
<ol>
<li><p><code>((es)*16+(di))=((ds)*16+(si))</code></p>
</li>
<li><p>如果df=0：(si)=(si)+1,(di)=(di)+1</p>
<p>如果df=1：(si)=(si)-1,(di)=(di)-1</p>
</li>
</ol>
<p>可以看出，movsb是将DS:SI指向的内存单元中的字节送入ES:DI中，然后根据DF的值对SI和DI增减1</p>
<p>同理mobsw就是将DS:SI指向的内存单元中的字送入ES:DI中，然后根据DF的值对SI和DI增减2</p>
<p>但一般来说，movsb和movsw都是和rep联合使用的，格式：rep movsb，这相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s:movsb</span><br><span class="line">loop s</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>所以rep的作用是根据cx的值重复执行后面的串传送指令，由于每次执行movsb之后si和di都会自行增减，所以使用rep可以完成(cx)个字节的传送。movsw也一样。</p>
<p>由于DF位决定着串传送的方向，所以这里有两条指令用来设置df的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cld：df&#x3D;0</span><br><span class="line">std：df&#x3D;1</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>例子：使用串传送指令将data段中第一个字符串复制到他后面的空间中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">data segment</span><br><span class="line">db &#39;Welcome to masm!&#39;</span><br><span class="line">db 16 dup (0)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,16</span><br><span class="line">mov cx,16</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">···</span><br><span class="line">123456789101112131415</span><br></pre></td></tr></table></figure>

<h5 id="pushf和popf"><a href="#pushf和popf" class="headerlink" title="pushf和popf"></a><strong>pushf和popf</strong></h5><p>pushf的功能是将标志寄存器的值入栈，popf是出栈标志寄存器。有了这两个命令，就可以直接访问标志寄存器了，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">push ax</span><br><span class="line">popf</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<h5 id="标志寄存器在Debug中的表示"><a href="#标志寄存器在Debug中的表示" class="headerlink" title="标志寄存器在Debug中的表示"></a><strong>标志寄存器在Debug中的表示</strong></h5><p>Debug中-r查看寄存器信息，最后有一段表示，下面列出我们已知的寄存器在Debug里的表示：</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>值1的标记</th>
<th>值0的标记</th>
</tr>
</thead>
<tbody><tr>
<td>of</td>
<td>OV</td>
<td>NV</td>
</tr>
<tr>
<td>sf</td>
<td>NG</td>
<td>PL</td>
</tr>
<tr>
<td>zf</td>
<td>ZR</td>
<td>NZ</td>
</tr>
<tr>
<td>pf</td>
<td>PE</td>
<td>PO</td>
</tr>
<tr>
<td>cf</td>
<td>CY</td>
<td>NC</td>
</tr>
<tr>
<td>df</td>
<td>DN</td>
<td>UP</td>
</tr>
</tbody></table>
<h3 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h3><h5 id="内中断的产生"><a href="#内中断的产生" class="headerlink" title="内中断的产生"></a><strong>内中断的产生</strong></h5><p>任何一个通用CPU都拥有执行完当前正在执行的指令后，检测到从CPU发来的中断信息，然后立即去处理中断信息的能力。这里的中断信息是指几个具有先后顺序的硬件操作，当CPU出现下面请看时会产生中断信息，相应的中断信息类型码（供CPU区分来源，是字节型，共256种）如下：</p>
<ul>
<li>除法错误，如执行div指令出现除法溢出 0</li>
<li>单步执行 1</li>
<li>执行into指令 4</li>
<li>执行int指令 指令执行的int n后面的n就是一个字节型立即数，即为中断类型码</li>
</ul>
<h5 id="中断处理和中断向量表"><a href="#中断处理和中断向量表" class="headerlink" title="中断处理和中断向量表"></a><strong>中断处理</strong>和中断向量表</h5><p>CPU接收到中断信息之后，往往要对中断信息进行处理，而如何处理使我们编程决定的。而CPU通过中断向量表来根据中断类型找到处理程序的入口地址（CS:IP)也称为中断向量。</p>
<p>中断向量表中存放着不同的中断类型对应的中断向量（处理程序的入口地址），中断向量表存放在内存中，8086PC指定必须放在内存地址0处，从0000:0000到0000:03FF的1024个单元存放中断向量表，每个表项占两个字，四个字节。</p>
<p>CPU会自动根据中断类型找到对应的中断向量并设置CS和IP的值，这个过程称为中断过程，步骤如下：</p>
<ol>
<li>（从中断信息中）取得中断类型码</li>
<li>标志寄存器的值入栈（暂存）pushf</li>
<li>设置标志寄存器第8位TF和第9位IF的值为0 TF=0,IF=0</li>
<li>CS内容入栈 push cs</li>
<li>IP内容入栈 push ip</li>
<li>在中断向量表中找到对应的CS和IP值并设置 <code>(ip)=(N*4),(cs)=(N*4+2)</code></li>
</ol>
<p>这么做的目的是，在中断处理之后还要回复CPU的现场（各个寄存器的值），所以先把那些入栈。</p>
<h5 id="中断处理程序和iret指令"><a href="#中断处理程序和iret指令" class="headerlink" title="中断处理程序和iret指令"></a><strong>中断处理程序和iret指令</strong></h5><p>运行中的CPU随时都可能接收到中断信息，所以CPU随时都可能执行中断程序，执行的步骤：</p>
<ol>
<li>保存用到的寄存器</li>
<li>处理中断</li>
<li>回复用到的寄存器</li>
<li>用iret返回</li>
</ol>
<p>iret的指令功能是：pop ip pop cs popf(前面说到了，这三个寄存器的入栈是硬件自动完成的，所以iret是和硬件自动完成的步骤配合使用的)。</p>
<p>以处理0号除法溢出中断为例，我们想要编写除法溢出的中断处理程序需要解决如下几步问题：</p>
<ol>
<li>编写程序</li>
<li>找到一段没有使用的内存空间</li>
<li>将程序写入到内存</li>
<li>将内存中的程序的入口写入0号中断的向量表位置</li>
</ol>
<p>我们可以采取下面框架来完成这个过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">start do0安装程序</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">do0 程序部分</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">···</span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure>

<p>可以看出我们分成了两部分，第一部分称之为“安装”，第二部分是代码实现。安装部分的函数实现思路如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">设置es:di至项目的地址</span><br><span class="line">设置ds:si指向源地址</span><br><span class="line">设置cx为传输长度</span><br><span class="line">设置传输方向为正</span><br><span class="line">rep movsb</span><br><span class="line">设置中断向量表</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<p>实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">start:mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">es,ax</span><br><span class="line">mov di,200h</span><br><span class="line">mov cx,offset do0end-fooset do0</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">···</span><br><span class="line">do0:代码</span><br><span class="line">do0end:nop</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure>

<p>这里offset do0end-fooset do0的意思是do0到do0end的代码长度，-是编译器可以识别并运算的符号，也就是说编译器可以再编译时处理表达式，如8-4等。还要注意的是，假如代码部分要输出“owerflow！”的话，需要将输出的内容写在代码部分并写入选择的内存中，否则如果单单在这个安装程序开始开辟一段data段的话，是会在程序返回时被释放。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">do0:jmp short do0start</span><br><span class="line">db &quot;overflow!&quot;</span><br><span class="line"></span><br><span class="line">do0start:</span><br><span class="line">···</span><br><span class="line">do0end:nop</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<h5 id="单步中断"><a href="#单步中断" class="headerlink" title="单步中断"></a><strong>单步中断</strong></h5><p>当标志寄存器的TF标志位为1的时候，CPU会在执行一条语句之后将资源入栈，然后去执行单步中断处理程序，如Debug就是运行在单步中断的条件下的，它能让CPU每执行一条指令都暂停，然后我们可以查看CPU的状态。但CPU可以防止在运行单步中断处理程序的时候再发生中断然后又去调用单步中断处理程序…CPU可以将TF置零，这样就不会再中断了。CPU提供这个功能就是为了单步跟踪程序的执行。</p>
<p>但需要注意的是，CPU并不会每次接收中断信息之后立即执行，在某些特定情况下它不会立即响应中断，如设置ss寄存器的时候如果接收到了中断信息，就不会响应。因为我们需要连续设置ss和ip的值，在debug中单步执行的时候也是，mov ss,ax和mov sp,0是在一步之内执行的，所以我们需要灵活使用这个特性，sp紧跟着ss执行，而不要在设置ss和sp之间插入其他指令。</p>
<h3 id="int指令"><a href="#int指令" class="headerlink" title="int指令"></a>int指令</h3><h5 id="int指令-1"><a href="#int指令-1" class="headerlink" title="int指令"></a><strong>int指令</strong></h5><p>int指令也会引发中断，使用格式是int n，n就是int引发的中断类型码，int中断的执行过程：</p>
<ol>
<li>获取类型码n</li>
<li>标志寄存器入栈，if=0，tf=0</li>
<li>cs，ip入栈</li>
<li><code>(ip)=(n*4),(cs)=(n*4+2)</code></li>
<li>执行n号中断的程序</li>
</ol>
<p>所以我们可以使用int指令调用任何一个中断的中断程序，如int 0调用除法溢出中断。一般情况下，系统将一些具有一定功能的小程序以中断的方式提供给程序调用，当然也可以自己编写，可以简称为中断例程。</p>
<h5 id="编写中断例程"><a href="#编写中断例程" class="headerlink" title="编写中断例程"></a><strong>编写中断例程</strong></h5><p>如编写中断7ch的中断例程，实现word型数据的平方，返回dx和ax中。求2*3456^2，代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start mov ax,3456</span><br><span class="line">int 7ch</span><br><span class="line">add ax,ax</span><br><span class="line">adc dx,dx</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure>

<p>接下来写7ch的功能和安装程序，并修改7ch中断向量表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset sqr</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200h</span><br><span class="line">mov cx,offset sqrend-offset sqr</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line"></span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[7ch*4],200h</span><br><span class="line">mov word ptr es:[7ch*4+2],0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">sqr:mul ax</span><br><span class="line">iret</span><br><span class="line"></span><br><span class="line">sqrend:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">1234567891011121314151617181920212223242526</span><br></pre></td></tr></table></figure>

<p>编写7ch中断实现loop指令，主程序输出80个“！”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">start mov ax,0b800h</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,160*12</span><br><span class="line">mov bx,offset s-offset se</span><br><span class="line">mov cx,80</span><br><span class="line">s:mov byte ptr es:[di],&#39;!&#39;</span><br><span class="line">add di,2</span><br><span class="line">int 7ch</span><br><span class="line">se:nop</span><br><span class="line">···</span><br><span class="line">1234567891011</span><br></pre></td></tr></table></figure>

<p>7ch实现部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lp:push bp</span><br><span class="line">mov bp,sp</span><br><span class="line">dec cx</span><br><span class="line">jcxz lpret</span><br><span class="line">add [bp+2],bx</span><br><span class="line">lpret:pop bp</span><br><span class="line">iret</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>

<p>因为bx里面是需要专一的偏移地址，而使用bp的时候默认段寄存器是ss，所以add [bp+2],bx就可以实现将栈中的sp的值修改回s处，自行推导一下就ok。</p>
<h5 id="BIOS和DOS提供的中断例程"><a href="#BIOS和DOS提供的中断例程" class="headerlink" title="BIOS和DOS提供的中断例程"></a><strong>BIOS和DOS提供的中断例程</strong></h5><p>系统ROM中存放着一套程序，称为BIOS，除此之外还有DOS都提供了一套可以供我们调用的中断例程，不同历程有不同的中断类型码，并且还能根据传入的参数不同而实现不同的功能，也就是说同一个类型码的中断例程可以实现很多不同功能，如int 10h是BIOS提供的包含了多个和屏幕输出相关子程序的中断例程。传参数如下面例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">mov ah,2 ;置光标</span><br><span class="line">mov bh,0 ;第0页</span><br><span class="line">mov dh,5 ;dh中放行号</span><br><span class="line">mov dl,12 ;dl中放列号</span><br><span class="line">int 10h</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<p>BIOS和DOS安装历程的过程是，开机后CPU一加电，自动初始化CS为0FFFFH，IP为0，而在这个地方有一个跳转指令，挑战到BIOS和系统检测初始化程序。在BIOS系统检测初始化程序中会设置中断向量表中的值。</p>
<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><h5 id="端口的概念"><a href="#端口的概念" class="headerlink" title="端口的概念"></a><strong>端口的概念</strong></h5><p>各种存储器都要和CPU的地址线，数据线，控制线相连，在CPU看来，总线就是一个由若干个存储单元构成的逻辑存储器，称之为内存地址空间。除了各种存储器，通过总线和CPU相连的还有下面三种芯片：</p>
<ul>
<li>各种接口卡（如网卡显卡）上的接口芯片，他们控制接口卡工作</li>
<li>主板上的接口芯片，CPU通过它们访问外部设备</li>
<li>其他芯片，用来存储相关系统信息，或进行相应的输入输出</li>
</ul>
<p>上面的芯片中都有一种由CPU读写的寄存器，它们都和CPU的总线相连（通过各自的芯片），CPU对他们进行读写时候都通过控制线向他们所在的芯片发出端口读写指令。</p>
<p>所以，对于CPU来说，将这些寄存器都当做端口，对他们进行统一编址，建立了一个端口地址空间，每一个端口拥有一个地址，所以CPU可以直接读取下面三个地方的数据：</p>
<ul>
<li>CPU内部的寄存器</li>
<li>内存单元</li>
<li>端口</li>
</ul>
<h5 id="端口的写"><a href="#端口的写" class="headerlink" title="端口的写"></a><strong>端口的写</strong></h5><p>因为端口所在的芯片和CPU通过总线相连，所以端口地址和内存地址一样通过地址总线传送，并且在PC系统中，CPU最多可以定位64KB个不同的端口，所以端口地址范围是0~65535。</p>
<p>对端口的读写不能使用mov,push,pop等内存读写指令，端口的读写指令只有两个：in和out分别用于从端口读取数据和往端口写入数据。</p>
<p>访问端口的步骤：</p>
<ol>
<li>CPU通过地址总线降低至信息60h发出</li>
<li>CPU通过控制线发出端口读命令，选中端口所在芯片，并通知它要从中读取数据</li>
<li>端口所在芯片将目标端口中的数据通过数据线送入CPU</li>
</ol>
<p>注：在in和out指令中，只能通过ax或al来存放从端口中读入的数据或要发送到端口中的数据，且访问8位端口时，用al，访问16位端口用ax。</p>
<p>对0~255以内的端口进行读写时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in al,20h</span><br><span class="line">out 20h,al</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>对256~65535的端口进行读写时，需要将端口号写在dx中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov dx，3f8h</span><br><span class="line">in al,dx</span><br><span class="line">out dx,al</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<h5 id="CMOS-RAM芯片"><a href="#CMOS-RAM芯片" class="headerlink" title="CMOS RAM芯片"></a><strong>CMOS RAM芯片</strong></h5><p>PC中有一个叫做CMOS RAM的芯片，称为CMOS，有如下特征：</p>
<ul>
<li>包含一个实时钟和一个有128个存储单元的RAM存储器（早期的计算机64个字节）</li>
<li>靠电池供电，关机后内部的实时钟仍可继续工作，RAM中的信息不丢失</li>
<li>128个字节的RAM中，内部实时钟占用0~0dh单元保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取，BIOS也提供了相关的程序可以让我们在开机时配置CMOS中的系统信息。</li>
<li>芯片内部有两个端口70h和71h，CPU通过这两个端口读写CMOS</li>
<li>70h为地址端口，存放要访问CMOS单元的地址，71h为数据端口，存放从选定的单元中读取的数据，或写入的数据。</li>
</ul>
<p>所以可以看出，想要从CMOS中读取数据，应分两步，先将单元号送入70h，然后再从71h读出对应号的数据。</p>
<h5 id="shl和shr指令"><a href="#shl和shr指令" class="headerlink" title="shl和shr指令"></a><strong>shl和shr指令</strong></h5><p>shl和shr是逻辑移位指令，shl是逻辑左移，功能为：</p>
<ol>
<li>将一个寄存器或内存单元中的数向左移位</li>
<li>将最后移出的一位写入CF</li>
<li>最低位补0</li>
</ol>
<p>如：mov al,01001000b shl al,1执行结束后(al)=10010000b，CF=0。</p>
<p>注：如果移动位数大于1，那么必须将移动位数写在cl中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,01010001b</span><br><span class="line">mov cl,3</span><br><span class="line">shl al,cl</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>执行后(al)=10001000b,最后移出的一位是0，所以CF=0。可以看出左移操作相当于x=x*2。</p>
<p>右移shr同理，最高位用0补充，移出的写入CF，若移动位数大于1，也要写在cl中，相当于x=x/2</p>
<p>在CMOS中存放着当前时间的年月日时分秒，分别存在下面的单元内：</p>
<table>
<thead>
<tr>
<th>秒</th>
<th>分</th>
<th>时</th>
<th>日</th>
<th>月</th>
<th>年</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>2</td>
<td>4</td>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
</tbody></table>
<p>每个信息使用一个字节存放，以BCD码的形式，BCD码是对0-9这几个数字使用二进制表示，如：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>0000</td>
<td>0001</td>
<td>0010</td>
<td>0011</td>
<td>0100</td>
<td>0101</td>
<td>0110</td>
<td>0111</td>
<td>1000</td>
<td>1001</td>
</tr>
</tbody></table>
<p>如果要表示一个两位数如13，就是一个字节高四位是十位1的BCD码，低四位是个位3的BCD码，表示为00010011b。下面程序获取当前月份：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">mov al,8</span><br><span class="line">out 70h,al   ;要从8号单元读取数据，所以先将8号单元送入70h端口</span><br><span class="line">in al,71h    ;从71h端口拿数据</span><br><span class="line"></span><br><span class="line">mov ah,al    ;复制一下</span><br><span class="line">mov cl,4     </span><br><span class="line">shr ah,cl    ;ah右移四位，ah里面的就是月份的十位</span><br><span class="line">and al,00001111b  ;al里面剩下的就是月份的个位</span><br><span class="line">123456789</span><br></pre></td></tr></table></figure>

<h3 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h3><h5 id="接口芯片和端口"><a href="#接口芯片和端口" class="headerlink" title="接口芯片和端口"></a><strong>接口芯片和端口</strong></h5><p>CPU除了需要拥有运算的能力，还要拥有I/O（输入输出）能力，我们键入一个字母，要能处理，所以我们需要面对的是：外部设备随时的输入和CPU何处得到外部设备的输入。</p>
<p>外部设备拥有自己的芯片连接到主板上，这些芯片内部由若干寄存器，而CPU将这些寄存器当做端口访问，外设的输入或CPU向外设输出都是送给对应的端口然后再由芯片处理送给目标（CPU或外设）。</p>
<h5 id="外中断-1"><a href="#外中断-1" class="headerlink" title="外中断"></a><strong>外中断</strong></h5><p>CPU提供外中断来处理这些如随时可能出现的来自外设的输入，在PC系统中，外中断源有以下两类：</p>
<p>可屏蔽中断：CPU可以不响应的外部中断，CPU是否响应看标志寄存器IF的设置，如果IF=1，CPU执行完当前指令后响应中断，如果IF=0，则不响应。可屏蔽中断的执行步骤和内部中断类似：</p>
<ol>
<li>获取中断类型码n（从外部通过总线输入）</li>
<li>标志寄存器入栈，IF=0，TF=0</li>
<li>CS，IP入栈</li>
<li><code>(IP)=(n*4)，(CS)=(n*4+2)</code></li>
</ol>
<p>可见，将IF置零的原因是以免在处理中断程序的时候再发生中断。当然我们也可以选择处理，下面两个指令可以改变IF的值：sti，设置IF=1，cli，设置IF=0。</p>
<p>不可屏蔽中断：CPU必须响应的外部中断，CPU检测到不可屏蔽中断后执行完当前指令立即响应中断。8086CPU中不可屏蔽中断的中断类型码固定位2，所以中断过程中不需要获取中断类型码，步骤：</p>
<ol>
<li>标志寄存器入栈，IF=0，TF=0</li>
<li>CS，IP入栈</li>
<li>(IP)=(8),(CS)=(0AH)</li>
</ol>
<p>几乎所有由外设引发的外中断都是可屏蔽中断，如键盘输入，不可屏蔽中断通常是在系统中又必须处理的紧急情况发生时通知CPU的中断信息。</p>
<h5 id="PC键盘处理过程"><a href="#PC键盘处理过程" class="headerlink" title="PC键盘处理过程"></a><strong>PC键盘处理过程</strong></h5><p>键盘上每个按键都相当于一个开关，按下就是开关接通，抬起就是开关断开。键盘上有一个芯片对键盘中每一个键盘的状态进行扫描，开关按下生成一个扫描码——通码，记录按下的按键位置，开关抬起也会产生一个扫描——断码，码记录松开的位置，都是送入60h端口。通码的第7位为0，断码第7位为1，也就是说断码=通码+80h。P247表。</p>
<p>当键盘输入送达60h时，相关新品就会向CPU发送中断类型码为9的可屏蔽中断信息。CPU检测到该中断信息之后，如果IF=1，响应中断，引发中断过程并执行int9的中断例程。BIOS中int9的中断程序用来进行基本的键盘输入处理，步骤如下：</p>
<ol>
<li>读出60h的扫描码</li>
<li>如果是字符的扫描码，将对应的字符的ASCII吗存入内存中的BIOS键盘缓冲区，如果是控制键（Ctrl）和切换键（CapsLock）扫描码，则将其转换为状态字（二进制位记录控制键和切换键状态的字节）写入内存中的存储状态字节的单元。</li>
<li>对键盘系统进行相关控制，如向新平发出应答</li>
</ol>
<p>BIOS中键盘缓冲区能存储15个键盘输入，每个键盘输入两字节，高位存放扫描码，低位存放字符。此外，0040:17单元存放键盘状态字节，记录了控制键和切换键的状态，记录信息如下：</p>
<table>
<thead>
<tr>
<th>位</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>右shift，1表示按下</td>
</tr>
<tr>
<td>1</td>
<td>左shift，1按下</td>
</tr>
<tr>
<td>2</td>
<td>Ctrl，1按下</td>
</tr>
<tr>
<td>3</td>
<td>Alt，1按下</td>
</tr>
<tr>
<td>4</td>
<td>ScrollLock状态，1表示指示灯亮</td>
</tr>
<tr>
<td>5</td>
<td>NumLock状态，1表示小键盘输入的是数字</td>
</tr>
<tr>
<td>6</td>
<td>CapsLock状态，1表示大写字母</td>
</tr>
<tr>
<td>7</td>
<td>Insert状态，1表示处于删除状态</td>
</tr>
</tbody></table>
<p>可以看书P276的一个改写int 9的中断例程。</p>
<h3 id="直接定址表"><a href="#直接定址表" class="headerlink" title="直接定址表"></a>直接定址表</h3><h5 id="描述单元长度的标号"><a href="#描述单元长度的标号" class="headerlink" title="描述单元长度的标号"></a><strong>描述单元长度的标号</strong></h5><p>我们可以使用下面的标号来表示数据的开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">code segment</span><br><span class="line">a:db 1,2,3,4,5,6,7,8</span><br><span class="line">b:dw 0</span><br><span class="line">···</span><br><span class="line">code ends</span><br><span class="line">···</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>

<p>a，b都是代表对应数据的起始地址，但并不能判断数据的长度或类型。下面一段程序将a中的8个数累加存入b中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">start mov si,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:mov al,a[si]</span><br><span class="line">mov ah,0</span><br><span class="line">add b,ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">123456789101112131415</span><br></pre></td></tr></table></figure>

<p>code段中a和b后并没有”:”号，这种写法同时描述内存地址和单元长度的标号。a描述了地址code:0和从这个地址开始后的内存单元都是字节单元，而b描述了地址code:8和从这个地址开始以后的内存单元都是字单元。所以b相当于CS:[8]，a[si]相当于CS:0[si]，使用这种标号，我们可以间接地访问内存数据。</p>
<h5 id="其它段中使用数据标号"><a href="#其它段中使用数据标号" class="headerlink" title="其它段中使用数据标号"></a><strong>其它段中使用数据标号</strong></h5><p>刚说的第一种标号即加”:”号的标号，只能使用在代码段中，不能在其他段中使用。如果想要在其它段中（如data段）使用标号可以使用第二种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">data ends</span><br><span class="line">···</span><br><span class="line">start mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov al,a[si]</span><br><span class="line">···</span><br><span class="line">1234567891011</span><br></pre></td></tr></table></figure>

<p>如果想在代码段中直接使用数据标号访问数据，需要使用assume伪指令将标号所在段和一个寄存器联系起来，是让寄存器明白，我们要访问的数据在ds指向的段中，但编译器并不会真的将段地址存入ds中，我们做了如下假设之后，编译器在编译的时候就会默认ds中已经存放了data的地址，如下面的编译例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,a[si]</span><br><span class="line">编译为：mov al,[si+0]</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>可以看出编译器默认了a[si]在ds所在的段中。所以我们需要手工指定ds指向data：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>也可以这么使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c a,b</span><br><span class="line">data ends</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>c处存放的是a和b的偏移地址，相当于c dw offset a,offset b。同理c dd a,b相当于c dw offset a,seg a,offset b,seg b即存的是a和b的段地址和偏移地址。</p>
<h5 id="直接定址表-1"><a href="#直接定址表-1" class="headerlink" title="直接定址表"></a><strong>直接定址表</strong></h5><p>使用查表的方法编写相关程序，如输出一个字节型数据的16进制形式（子程序）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">showbyte jmp short show</span><br><span class="line">table db &#39;0123456789ABCDEF&#39;</span><br><span class="line">show:push bx</span><br><span class="line">push es</span><br><span class="line">mov ah,al</span><br><span class="line">she ah,1</span><br><span class="line">she ah,1</span><br><span class="line">she ah,1</span><br><span class="line">she ah,1 ;右移四位，位移子程序限制使用的寄存器数，只能这么移</span><br><span class="line">and al,00001111b</span><br><span class="line">mov bl,al</span><br><span class="line">mov bh,0</span><br><span class="line">mov ah,table[bx]  ;高四位作为相对于table的偏移，取得对应字符</span><br><span class="line">mov bx,0b800h</span><br><span class="line">mov es,bx</span><br><span class="line">mov es:[160*12+40*2],ah</span><br><span class="line">mov bl,al</span><br><span class="line">mov bh,0</span><br><span class="line">mov al,table[bx]</span><br><span class="line">mov es:[160*12+40*2+2],al</span><br><span class="line">pop es</span><br><span class="line">pop bx</span><br><span class="line">ret</span><br><span class="line">1234567891011121314151617181920212223</span><br></pre></td></tr></table></figure>

<p>可见我们直接使用需要的数值和地址的映射关系来寻找需要的数据。</p>
<h5 id="程序入口地址的直接定址表"><a href="#程序入口地址的直接定址表" class="headerlink" title="程序入口地址的直接定址表"></a><strong>程序入口地址的直接定址表</strong></h5><p>可以看书P296的例程，主要思想是，编写多个子程序实现不同功能，每个子程序有自己的标号，如sub1，sub2···等。将它们存在一个表中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">table dw sub1,sub2,sub3,sub4</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>然后按照之前的方法使用如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setscreen:jmp short set</span><br><span class="line">table dw sub1,sub2,sub3,sub4</span><br><span class="line">set:push bx</span><br><span class="line">cmp ah,3</span><br><span class="line">ja sret</span><br><span class="line">mov bl,ah</span><br><span class="line">mov bh,0</span><br><span class="line">add bx,bx</span><br><span class="line">call word ptr table[bx]</span><br><span class="line">sret:pop bx</span><br><span class="line">ret</span><br><span class="line">1234567891011</span><br></pre></td></tr></table></figure>

<h3 id="使用BIOS进行键盘输入和磁盘读写"><a href="#使用BIOS进行键盘输入和磁盘读写" class="headerlink" title="使用BIOS进行键盘输入和磁盘读写"></a>使用BIOS进行键盘输入和磁盘读写</h3><h5 id="int-9中断例程对键盘输入的处理"><a href="#int-9中断例程对键盘输入的处理" class="headerlink" title="int 9中断例程对键盘输入的处理"></a><strong>int 9中断例程对键盘输入的处理</strong></h5><p>键盘处理依次按下A,B,C,D,E,shift_A,A的过程：</p>
<p>我们知道，键盘有16字的缓冲区，可以存放15个按键的扫描码和对应的ASCII码值，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>我们按下A时，引发键盘中断，CPU执行int 9中断例程，从60h端口读出A键通码，然后检测状态字，看是否有控制键或切换键按下，发现没有，将A的扫描码1eh和对应的ASCII码’a’61h写在缓冲区：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|1e61|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>然后BCDE同理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|1e61|3062|2e63|2064|1265|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>在按下shift之后引发键盘中断，int 9程序接受了shift的通码之后设置0040:17处状态字第一位为1，表示左shift按下，接下来按A间，引发中断，int 9中断例程从60h端口督导通码之后检测状态字，发现左shift被按下，于是将A的键盘扫描码1eh和’A’的ASCII41h写入缓冲区：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|1e61|3062|2e63|2064|1265|1e41|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>松开shift，0040:17第一位变回0,之后又按下A和之前一样。</p>
<h5 id="int-16h读取键盘缓冲区"><a href="#int-16h读取键盘缓冲区" class="headerlink" title="int 16h读取键盘缓冲区"></a><strong>int 16h读取键盘缓冲区</strong></h5><p>int 16h可以供程序员调用，编号为0的功能是从键盘缓冲区读一个键盘输入，(ah)=扫描码，(al)=ascii码。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ah,0</span><br><span class="line">int 16h</span><br><span class="line">|3062|2e63|2064|1265|1e41|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>执行后，缓冲区第一个没了，然后ah中是1eh，al中是61h。如果缓冲区为空的时候执行，那么会循环等待知道缓冲区有数据，所以int 16h的0号功能的步骤是：</p>
<ol>
<li>检测键盘缓冲区是否有数据</li>
<li>没有则继续1</li>
<li>读取第一个单元的键盘输入</li>
<li>扫描码送ah，ascii码送al</li>
</ol>
<h5 id="int-13h读写磁盘"><a href="#int-13h读写磁盘" class="headerlink" title="int 13h读写磁盘"></a><strong>int 13h读写磁盘</strong></h5><p>3.5寸软盘分为上下两面，每面80个磁道，每个磁道18个扇区，每个扇区512字节，共约1.44MB。磁盘的实际访问时磁盘控制器进行的，我们通过控制磁盘控制器来控制磁盘，只能以扇区为单位读写磁盘，每次需要给出面号，磁道号，和扇区号，面号和磁道号从0开始，扇区号从1开始。BIOS提供int 13h来实现访问磁盘，读取0面0道1扇区的内容到0:200的程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,200h</span><br><span class="line"></span><br><span class="line">mov al,1   ;读取的扇区数</span><br><span class="line">mov ch,0   ;磁道号</span><br><span class="line">mov cl,1   ;扇区号</span><br><span class="line">mov dl,0   ;驱动器号，0开始，0软驱A，1软驱B，磁盘从80h开始，80h硬盘C，81h硬盘D</span><br><span class="line">mov dh,0   ;磁头号（软盘面号）</span><br><span class="line">mov ah,2   ;13h的功能号，2表示读扇区</span><br><span class="line">int 13h</span><br><span class="line">1234567891011</span><br></pre></td></tr></table></figure>

<p>es:bx指向接收数据的内存区。操作成功(ah)=0,(al)=读入的扇区数，操作失败(ah)=错误代码。将0:200的数据写入0面0道1扇区：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">miv es,ax</span><br><span class="line">mov bx,200h</span><br><span class="line"></span><br><span class="line">mov al,1   ;读取的扇区数</span><br><span class="line">mov ch,0   ;磁道号</span><br><span class="line">mov cl,1   ;扇区号</span><br><span class="line">mov dl,0   ;驱动器号</span><br><span class="line">mov dh,0   ;磁头号（软盘面号）</span><br><span class="line">mov ah,3   ;13h的功能号，3表示写扇区</span><br><span class="line">int 13h</span><br><span class="line">1234567891011</span><br></pre></td></tr></table></figure>

<p>es:bx指向写入磁盘的数据，操作成功(ah)=0,(al)=写入的扇区数，操作失败(ah)=错误代码</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/" rel="tag"># 汇编基础学习</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/29/C++%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F/" rel="prev" title="C++编译产生文件">
      <i class="fa fa-chevron-left"></i> C++编译产生文件
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0/" rel="next" title="数据结构BFS、DFS">
      数据结构BFS、DFS <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础知识"><span class="nav-number">1.</span> <span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#汇编语言指令组成"><span class="nav-number">1.0.1.</span> <span class="nav-text">汇编语言指令组成</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CPU与外部器件交互需要"><span class="nav-number">1.0.2.</span> <span class="nav-text">CPU与外部器件交互需要</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#总线"><span class="nav-number">1.0.3.</span> <span class="nav-text">总线</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小结"><span class="nav-number">1.0.4.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#接口卡"><span class="nav-number">1.0.5.</span> <span class="nav-text">接口卡</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#存储器"><span class="nav-number">1.0.6.</span> <span class="nav-text">存储器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内存地址空间"><span class="nav-number">1.0.7.</span> <span class="nav-text">内存地址空间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寄存器"><span class="nav-number">2.</span> <span class="nav-text">寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#内部总线"><span class="nav-number">2.0.1.</span> <span class="nav-text">内部总线</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#通用寄存器"><span class="nav-number">2.0.2.</span> <span class="nav-text">通用寄存器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字"><span class="nav-number">2.0.3.</span> <span class="nav-text">字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#简单的汇编指令"><span class="nav-number">2.0.4.</span> <span class="nav-text">简单的汇编指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CPU位结构"><span class="nav-number">2.0.5.</span> <span class="nav-text">CPU位结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CPU表示物理地址"><span class="nav-number">2.0.6.</span> <span class="nav-text">CPU表示物理地址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#段寄存器与指令指针寄存器"><span class="nav-number">2.0.7.</span> <span class="nav-text">段寄存器与指令指针寄存器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#修改CS，IP"><span class="nav-number">2.0.8.</span> <span class="nav-text">修改CS，IP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小结-1"><span class="nav-number">2.0.9.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实验"><span class="nav-number">2.0.10.</span> <span class="nav-text">实验</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寄存器（内存访问）"><span class="nav-number">3.</span> <span class="nav-text">寄存器（内存访问）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#内存到寄存器的储存"><span class="nav-number">3.0.1.</span> <span class="nav-text">内存到寄存器的储存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DS寄存器"><span class="nav-number">3.0.2.</span> <span class="nav-text">DS寄存器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mov，add，sub"><span class="nav-number">3.0.3.</span> <span class="nav-text">mov，add，sub</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#栈"><span class="nav-number">3.0.4.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#栈寄存器SS，SP与push，pop"><span class="nav-number">3.0.5.</span> <span class="nav-text">栈寄存器SS，SP与push，pop</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实验-1"><span class="nav-number">3.0.6.</span> <span class="nav-text">实验</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单编程"><span class="nav-number">4.</span> <span class="nav-text">简单编程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#一个汇编语言程序"><span class="nav-number">4.0.1.</span> <span class="nav-text">一个汇编语言程序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#一些伪指令功能"><span class="nav-number">4.0.2.</span> <span class="nav-text">一些伪指令功能</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BX-和loop指令"><span class="nav-number">5.</span> <span class="nav-text">[BX]和loop指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#内存单元的描述"><span class="nav-number">5.0.1.</span> <span class="nav-text">内存单元的描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#loop指令"><span class="nav-number">5.0.2.</span> <span class="nav-text">loop指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Debug和masm编译器对指令的不同处理"><span class="nav-number">5.0.3.</span> <span class="nav-text">Debug和masm编译器对指令的不同处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#安全的编程空间"><span class="nav-number">5.0.4.</span> <span class="nav-text">安全的编程空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#段前缀的使用"><span class="nav-number">5.0.5.</span> <span class="nav-text">段前缀的使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序的段"><span class="nav-number">6.</span> <span class="nav-text">程序的段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#数据段"><span class="nav-number">6.0.1.</span> <span class="nav-text">数据段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#栈段"><span class="nav-number">6.0.2.</span> <span class="nav-text">栈段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数据，代码，栈的程序段"><span class="nav-number">6.0.3.</span> <span class="nav-text">数据，代码，栈的程序段</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#灵活定位内存地址"><span class="nav-number">7.</span> <span class="nav-text">灵活定位内存地址</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#and和or指令"><span class="nav-number">7.0.1.</span> <span class="nav-text">and和or指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ASCII码和字符形式的数据"><span class="nav-number">7.0.2.</span> <span class="nav-text">ASCII码和字符形式的数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bx-idata-的内存表示方法与数组处理"><span class="nav-number">7.0.3.</span> <span class="nav-text">[bx+idata]的内存表示方法与数组处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SI和DI寄存器"><span class="nav-number">7.0.4.</span> <span class="nav-text">SI和DI寄存器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据处理的两个基本问题"><span class="nav-number">8.</span> <span class="nav-text">数据处理的两个基本问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#两个基本问题"><span class="nav-number">8.0.1.</span> <span class="nav-text">两个基本问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bx，si，di和bp"><span class="nav-number">8.0.2.</span> <span class="nav-text">bx，si，di和bp</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数据的位置"><span class="nav-number">8.0.3.</span> <span class="nav-text">数据的位置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数据的长度"><span class="nav-number">8.0.4.</span> <span class="nav-text">数据的长度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#div指令"><span class="nav-number">8.0.5.</span> <span class="nav-text">div指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#伪指令dd"><span class="nav-number">8.0.6.</span> <span class="nav-text">伪指令dd</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dup"><span class="nav-number">8.0.7.</span> <span class="nav-text">dup</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转移指令原理"><span class="nav-number">9.</span> <span class="nav-text">转移指令原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#转移指令"><span class="nav-number">9.0.1.</span> <span class="nav-text">转移指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#offset操作符"><span class="nav-number">9.0.2.</span> <span class="nav-text">offset操作符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jmp指令"><span class="nav-number">9.0.3.</span> <span class="nav-text">jmp指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jmp-地址远转移"><span class="nav-number">9.0.4.</span> <span class="nav-text">jmp+地址远转移</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jmp-寄存器-内存转移"><span class="nav-number">9.0.5.</span> <span class="nav-text">jmp+寄存器|内存转移</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jcxz指令"><span class="nav-number">9.0.6.</span> <span class="nav-text">jcxz指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#loop指令-1"><span class="nav-number">9.0.7.</span> <span class="nav-text">loop指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#根据位移进行转移的指令总结"><span class="nav-number">9.0.8.</span> <span class="nav-text">根据位移进行转移的指令总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#call和ret指令"><span class="nav-number">10.</span> <span class="nav-text">call和ret指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ret和retf"><span class="nav-number">10.0.1.</span> <span class="nav-text">ret和retf</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#call指令"><span class="nav-number">10.0.2.</span> <span class="nav-text">call指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#联合使用ret和call"><span class="nav-number">10.0.3.</span> <span class="nav-text">联合使用ret和call</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mul指令"><span class="nav-number">10.0.4.</span> <span class="nav-text">mul指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#参数的传递和模块化编程"><span class="nav-number">10.0.5.</span> <span class="nav-text">参数的传递和模块化编程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#寄存器冲突"><span class="nav-number">10.0.6.</span> <span class="nav-text">寄存器冲突</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标志寄存器"><span class="nav-number">11.</span> <span class="nav-text">标志寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#标志寄存器-1"><span class="nav-number">11.0.1.</span> <span class="nav-text">标志寄存器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ZF标志"><span class="nav-number">11.0.2.</span> <span class="nav-text">ZF标志</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PF标志"><span class="nav-number">11.0.3.</span> <span class="nav-text">PF标志</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SF标志"><span class="nav-number">11.0.4.</span> <span class="nav-text">SF标志</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CF标志"><span class="nav-number">11.0.5.</span> <span class="nav-text">CF标志</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#OF标志"><span class="nav-number">11.0.6.</span> <span class="nav-text">OF标志</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#adc指令"><span class="nav-number">11.0.7.</span> <span class="nav-text">adc指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sbb指令"><span class="nav-number">11.0.8.</span> <span class="nav-text">sbb指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#cmp指令"><span class="nav-number">11.0.9.</span> <span class="nav-text">cmp指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#检测比较结果的条件转移指令"><span class="nav-number">11.0.10.</span> <span class="nav-text">检测比较结果的条件转移指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DF标志位和串传送指令"><span class="nav-number">11.0.11.</span> <span class="nav-text">DF标志位和串传送指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pushf和popf"><span class="nav-number">11.0.12.</span> <span class="nav-text">pushf和popf</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#标志寄存器在Debug中的表示"><span class="nav-number">11.0.13.</span> <span class="nav-text">标志寄存器在Debug中的表示</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内中断"><span class="nav-number">12.</span> <span class="nav-text">内中断</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#内中断的产生"><span class="nav-number">12.0.1.</span> <span class="nav-text">内中断的产生</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#中断处理和中断向量表"><span class="nav-number">12.0.2.</span> <span class="nav-text">中断处理和中断向量表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#中断处理程序和iret指令"><span class="nav-number">12.0.3.</span> <span class="nav-text">中断处理程序和iret指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#单步中断"><span class="nav-number">12.0.4.</span> <span class="nav-text">单步中断</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#int指令"><span class="nav-number">13.</span> <span class="nav-text">int指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#int指令-1"><span class="nav-number">13.0.1.</span> <span class="nav-text">int指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#编写中断例程"><span class="nav-number">13.0.2.</span> <span class="nav-text">编写中断例程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BIOS和DOS提供的中断例程"><span class="nav-number">13.0.3.</span> <span class="nav-text">BIOS和DOS提供的中断例程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#端口"><span class="nav-number">14.</span> <span class="nav-text">端口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#端口的概念"><span class="nav-number">14.0.1.</span> <span class="nav-text">端口的概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#端口的写"><span class="nav-number">14.0.2.</span> <span class="nav-text">端口的写</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CMOS-RAM芯片"><span class="nav-number">14.0.3.</span> <span class="nav-text">CMOS RAM芯片</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#shl和shr指令"><span class="nav-number">14.0.4.</span> <span class="nav-text">shl和shr指令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#外中断"><span class="nav-number">15.</span> <span class="nav-text">外中断</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#接口芯片和端口"><span class="nav-number">15.0.1.</span> <span class="nav-text">接口芯片和端口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#外中断-1"><span class="nav-number">15.0.2.</span> <span class="nav-text">外中断</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PC键盘处理过程"><span class="nav-number">15.0.3.</span> <span class="nav-text">PC键盘处理过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#直接定址表"><span class="nav-number">16.</span> <span class="nav-text">直接定址表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#描述单元长度的标号"><span class="nav-number">16.0.1.</span> <span class="nav-text">描述单元长度的标号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#其它段中使用数据标号"><span class="nav-number">16.0.2.</span> <span class="nav-text">其它段中使用数据标号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#直接定址表-1"><span class="nav-number">16.0.3.</span> <span class="nav-text">直接定址表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#程序入口地址的直接定址表"><span class="nav-number">16.0.4.</span> <span class="nav-text">程序入口地址的直接定址表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用BIOS进行键盘输入和磁盘读写"><span class="nav-number">17.</span> <span class="nav-text">使用BIOS进行键盘输入和磁盘读写</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#int-9中断例程对键盘输入的处理"><span class="nav-number">17.0.1.</span> <span class="nav-text">int 9中断例程对键盘输入的处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#int-16h读取键盘缓冲区"><span class="nav-number">17.0.2.</span> <span class="nav-text">int 16h读取键盘缓冲区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#int-13h读写磁盘"><span class="nav-number">17.0.3.</span> <span class="nav-text">int 13h读写磁盘</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">KJH</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">178</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KJH</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

<span id="busuanzi_container_site_uv">
  本站总访问量<span id="busuanzi_value_site_uv"></span>次
</span>
        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
