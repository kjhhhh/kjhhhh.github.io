<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="今日内容介绍1、集合2、Iterator迭代器3、增强for循环4、泛型 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;第一节课开始&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ###01集合使用的回顾     *A:集合使用的回顾       *a.ArrayList集合存储5个int类型元素          public static void">
<meta property="og:type" content="article">
<meta property="og:title" content="day18笔记">
<meta property="og:url" content="http://yoursite.com/2020/12/22/day18%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="今日内容介绍1、集合2、Iterator迭代器3、增强for循环4、泛型 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;第一节课开始&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ###01集合使用的回顾     *A:集合使用的回顾       *a.ArrayList集合存储5个int类型元素          public static void">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-12-22T11:21:13.889Z">
<meta property="article:modified_time" content="2019-01-11T01:22:48.636Z">
<meta property="article:author" content="KJH">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/12/22/day18%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>day18笔记 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day18%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          day18笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-11 09:22:48" itemprop="dateModified" datetime="2019-01-11T09:22:48+08:00">2019-01-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>今日内容介绍<br>1、集合<br>2、Iterator迭代器<br>3、增强for循环<br>4、泛型</p>
<p>=======================第一节课开始=============================================</p>
<p>###01集合使用的回顾<br>     *A:集合使用的回顾<br>       *a.ArrayList集合存储5个int类型元素<br>          public static void main(String[] args) {<br>               ArrayList<Integer> list = new ArrayList<Integer>();<br>            list.add(111);<br>            list.add(222);<br>            list.add(333);<br>            list.add(444);<br>            list.add(555);<br>            for(int i=0; i&lt;list.size(); i++){<br>                   System.out.println(list.get(i));<br>           }<br>          }</Integer></Integer></p>
<pre><code>*b.ArrayList集合存储5个Person类型元素
   public static void main(String[] args) {
    ArrayList&lt;Person&gt; list = new ArrayList&lt;Person&gt;();
    list.add(new Person(“小强”));
    list.add(new Person(“老王”));
    list.add(new Person(“小虎”));
    list.add(new Person(“小泽”));
    list.add(new Person(“小红”));
    for(int i=0; i&lt;list.size(); i++){
      Person p = list.get(i);
            System.out.println(p);
     }
   }</code></pre><p>###02集合的学习目标<br>       集合，集合是java中提供的一种容器，可以用来存储多个数据。<br>     在前面的学习中，我们知道数据多了，可以使用数组存放或者使用ArrayList集合进行存放数据。那么，集合和数组既然都是容器，它们有啥区别呢？<br>       数组的长度是固定的。集合的长度是可变的。<br>       集合中存储的元素必须是引用类型数据</p>
<p>###03集合继承关系图<br>    A:集合继承关系图<br>     a:ArrayList的继承关系:<br>     查看ArrayList类发现它继承了抽象类AbstractList同时实现接口List，而List接口又继承了Collection接口。Collection接口为最顶层集合接口了。<br>     源代码：<br>      interface List extends Collection {<br>      }<br>      public class ArrayList extends AbstractList implements List{<br>      }</p>
<pre><code>b:集合继承体系
 这说明我们在使用ArrayList类时，该类已经把所有抽象方法进行了重写。那么，实现Collection接口的所有子类都会进行方法重写。
   Collecton接口常用的子接口有：List接口、Set接口
   List接口常用的子类有：ArrayList类、LinkedList类
   Set接口常用的子类有：HashSet类、LinkedHashSet类

                          Collection 接口     
                               |
 ----------------------------------------------------------------
 |                                                              |
List接口                                                       Set接口
 |                                                              |</code></pre><hr>
<p> |              |                                             |            |<br>ArrayList类    LinkedList类                                 HashSet类     LinkedHashSet类</p>
<p>###04集合Collection的方法<br>    A:集合Collection的方法<br>     /*<br>      *  Collection接口中的方法<br>      *  是集合中所有实现类必须拥有的方法<br>      *  使用Collection接口的实现类,程序的演示<br>      *  ArrayList implements List<br>      *  List extends Collection<br>      *  方法的执行,都是实现的重写<br>      */<br>     public class CollectionDemo {<br>      public static void main(String[] args) {<br>        function_2();<br>      }</p>
<pre><code> /*  Collection接口方法
  *  Object[] toArray() 集合中的元素,转成一个数组中的元素, 集合转成数组
  *  返回是一个存储对象的数组, 数组存储的数据类型是Object
  */
 private static void function_2() {
   Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();
   coll.add(&quot;abc&quot;);
   coll.add(&quot;itcast&quot;);
   coll.add(&quot;itheima&quot;);
   coll.add(&quot;money&quot;);
   coll.add(&quot;123&quot;);

   Object[] objs = coll.toArray();
   for(int i = 0 ; i &lt; objs.length ; i++){
     System.out.println(objs[i]);
   }
 }
 /*
  * 学习Java中三种长度表现形式
  *   数组.length 属性  返回值 int
  *   字符串.length() 方法,返回值int
  *   集合.size()方法, 返回值int
  */

 /*
  * Collection接口方法
  * boolean contains(Object o) 判断对象是否存在于集合中,对象存在返回true
  * 方法参数是Object类型
  */
 private static void function_1() {
   Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();
   coll.add(&quot;abc&quot;);
   coll.add(&quot;itcast&quot;);
   coll.add(&quot;itheima&quot;);
   coll.add(&quot;money&quot;);
   coll.add(&quot;123&quot;);

   boolean b = coll.contains(&quot;itcast&quot;);
   System.out.println(b);
 }


 /*
  * Collection接口的方法
  * void clear() 清空集合中的所有元素
  * 集合容器本身依然存在
  */
 public static void function(){
   //接口多态的方式调用
   Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();
   coll.add(&quot;abc&quot;);
   coll.add(&quot;bcd&quot;);
   System.out.println(coll);

   coll.clear();

   System.out.println(coll);

 }
}</code></pre><p>###05集合Collection的remove方法<br>   A:05集合Collection的remove方法<br>    /*<br>     * Collection接口方法<br>     * boolean remove(Object o)移除集合中指定的元素<br>     */<br>    private static void function_3(){<br>      Collection<String> coll = new ArrayList<String>();<br>      coll.add(“abc”);<br>      coll.add(“money”);<br>      coll.add(“itcast”);<br>      coll.add(“itheima”);<br>      coll.add(“money”);<br>      coll.add(“123”);<br>      System.out.println(coll);</String></String></p>
<pre><code>  boolean b = coll.remove(&quot;money&quot;);
  System.out.println(b);
  System.out.println(coll);
}</code></pre><p>=======================第二节课开始=============================================<br>###06迭代器的概述<br>  A:迭代器概述:<br>   a:java中提供了很多个集合，它们在存储元素时，采用的存储方式不同。<br>    我们要取出这些集合中的元素，可通过一种通用的获取方式来完成。</p>
<p>   b:Collection集合元素的通用获取方式：在取元素之前先要判断集合中有没有元素，<br>  如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</p>
<p>   c:每种集合的底层的数据结构不同,例如ArrayList是数组,LinkedList底层是链表,但是无论使用那种集合,我们都会有判断是否有元素<br>     以及取出里面的元素的动作,那么Java为我们提供一个迭代器定义了统一的判断元素和取元素的方法 </p>
<p>###07迭代器的实现原理<br>   <em>A:迭代器的实现原理<br>      /</em><br>     *  集合中的迭代器:<br>     *    获取集合中元素方式<br>     *  接口 Iterator : 两个抽象方法<br>     *     boolean hasNext() 判断集合中还有没有可以被取出的元素,如果有返回true<br>     *     next() 取出集合中的下一个元素<br>     *<br>     *  Iterator接口,找实现类.<br>     *    Collection接口定义方法<br>     *       Iterator  iterator()<br>     *    ArrayList 重写方法 iterator(),返回了Iterator接口的实现类的对象<br>     *    使用ArrayList集合的对象<br>     *     Iterator it =array.iterator(),运行结果就是Iterator接口的实现类的对象<br>     *     it是接口的实现类对象,调用方法 hasNext 和 next 集合元素迭代<br>     */</p>
<p>###08迭代器的代码实现<br>   *A:迭代器的代码实现<br>      public class IteratorDemo {<br>        public static void main(String[] args) {<br>          Collection<String> coll = new ArrayList<String>();<br>          coll.add(“abc1”);<br>          coll.add(“abc2”);<br>          coll.add(“abc3”);<br>          coll.add(“abc4”);<br>          //迭代器,对集合ArrayList中的元素进行取出</String></String></p>
<pre><code>    //调用集合的方法iterator()获取出,Iterator接口的实现类的对象
    Iterator&lt;String&gt; it = coll.iterator();
    //接口实现类对象,调用方法hasNext()判断集合中是否有元素
    //boolean b = it.hasNext();
    //System.out.println(b);
    //接口的实现类对象,调用方法next()取出集合中的元素
    //String s = it.next();
    //System.out.println(s);

    //迭代是反复内容,使用循环实现,循环的条件,集合中没元素, hasNext()返回了false
    while(it.hasNext()){
      String s = it.next();
      System.out.println(s);
    }



  }
}</code></pre><p>###09迭代器的执行过程<br>   A:迭代器的执行过程<br>     a:迭代器的原理:<br>       while(it.hasNext()) {<br>            System.out.println(it.next());<br>       }</p>
<pre><code>  //cursor记录的索引值不等于集合的长度返回true,否则返回false
    public boolean hasNext() {       
      return cursor != size; //cursor初值为0

    }

   //next()方法作用:
   //①返回cursor指向的当前元素 
   //②cursor++
   public Object next() {            
            int i = cursor; 
            cursor = i + 1;  
            return  elementData[lastRet = i]; 

        }
b:for循环迭代写法:
   for (Iterator&lt;String&gt; it2 = coll.iterator(); it2.hasNext();  ) {
    System.out.println(it2.next());
  } </code></pre><p>###10集合迭代中的转型<br>   A:集合迭代中的转型<br>     a:在使用集合时，我们需要注意以下几点：<br>       集合中存储其实都是对象的地址。<br>       集合中可以存储基本数值吗？jdk1.5版本以后可以存储了。<br>         因为出现了基本类型包装类，它提供了自动装箱操作（基本类型对象），这样，集合中的元素就是基本数值的包装类对象。</p>
<pre><code>b:存储时提升了Object。取出时要使用元素的特有内容，必须向下转型。
 Collection coll = new ArrayList();
 coll.add(&quot;abc&quot;);
 coll.add(&quot;aabbcc&quot;);
 coll.add(&quot;shitcast&quot;);
 Iterator it = coll.iterator();
 while (it.hasNext()) {
  //由于元素被存放进集合后全部被提升为Object类型
 //当需要使用子类对象特有方法时，需要向下转型
  String str = (String) it.next();
  System.out.println(str.length());
 }
 注意：如果集合中存放的是多个对象，这时进行向下转型会发生类型转换异常。


c:Iterator接口也可以使用&lt;&gt;来控制迭代元素的类型的。代码演示如下：
 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();
 coll.add(&quot;abc&quot;);
 coll.add(&quot;aabbcc&quot;);
 coll.add(&quot;shitcast&quot;);
 Iterator&lt;String&gt; it = coll.iterator();
 while (it.hasNext()) {
  String str =  it.next(); 
 //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型
  System.out.println(str.length());
 }</code></pre><p>=========================第三节课开始====================================<br>###11增强for循环遍历数组<br>   <em>A:增强for循环遍历数组<br>     a:格式:<br>     /</em><br>      *  JDK1.5新特性,增强for循环<br>      *  JDK1.5版本后,出现新的接口 java.lang.Iterable<br>      *    Collection开是继承Iterable<br>      *    Iterable作用,实现增强for循环<br>      *<br>      *    格式:<br>      *      for( 数据类型  变量名 : 数组或者集合 ){<br>      *         sop(变量);<br>      *      }<br>      */<br>     public static void function_1(){<br>        //for对于对象数组遍历的时候,能否调用对象的方法呢<br>        String[] str = {“abc”,”itcast”,”cn”};<br>        for(String s : str){<br>          System.out.println(s.length());<br>        }<br>      }</p>
<pre><code>/*
 *  实现for循环,遍历数组
 *  好处: 代码少了,方便对容器遍历
 *  弊端: 没有索引,不能操作容器里面的元素
 */
public static void function(){
  int[] arr = {3,1,9,0};
  for(int i : arr){
    System.out.println(i+1);
  }
  System.out.println(arr[0]);
}</code></pre><p>###12增强for循环遍历集合<br>      A:增强for循环遍历集合<br>        /*<br>         *  增强for循环遍历集合<br>         *  存储自定义Person类型<br>         */<br>        public static void function_2(){<br>          ArrayList<Person> array = new ArrayList<Person>();<br>          array.add(new Person(“a”,20));<br>          array.add(new Person(“b”,10));<br>          for(Person p : array){<br>            System.out.println(p);// System.out.println(p.toString());<br>          }<br>        }</Person></Person></p>
<p>###13泛型的引入<br>   A:泛型的引入<br>    在前面学习集合时，我们都知道集合中是可以存放任意对象的，<br>    只要把对象存储集合后，那么这时他们都会被提升成Object类型。<br>    当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。比如下面程序：<br>    public class GenericDemo {<br>      public static void main(String[] args) {<br>        List list = new ArrayList();<br>        list.add(“abc”);<br>        list.add(“itcast”);<br>        list.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放<br>                    //相当于:Object obj=new Integer(5);</p>
<pre><code>    Iterator it = list.iterator();
    while(it.hasNext()){
      //需要打印每个字符串的长度,就要把迭代出来的对象转成String类型
      String str = (String) it.next();//String str=(String)obj;
                                      //编译时期仅检查语法错误,String是Object的儿子可以向下转型
                                      //运行时期String str=(String)(new Integer(5))
                                      //String与Integer没有父子关系所以转换失败
                                      //程序在运行时发生了问题java.lang.ClassCastException
      System.out.println(str.length());
    }
  }
}</code></pre><p>###14泛型的定义和使用<br>  A:泛型的定义和使用<br>    /*<br>     * JDK1.5 出现新的安全机制,保证程序的安全性<br>     *   泛型: 指明了集合中存储数据的类型  &lt;数据类型&gt;<br>     */</p>
<pre><code>public class GenericDemo {
  public static void main(String[] args) {
    function();
  }

  public static void function(){
    Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();
    coll.add(&quot;abc&quot;);
    coll.add(&quot;rtyg&quot;);
    coll.add(&quot;43rt5yhju&quot;);
//    coll.add(1);

    Iterator&lt;String&gt; it = coll.iterator();
    while(it.hasNext()){
      String s = it.next();
      System.out.println(s.length());
    }
  }
}</code></pre><p>###15Java中的伪泛型<br>     A:Java中的伪泛型：<br>       泛型只在编译时存在,编译后就被擦除,在编译之前我们就可以限制集合的类型,起到作用<br>     例如:ArrayList<String> al=new ArrayList<String>();<br>     编译后:ArrayList al=new ArrayList();</String></String></p>
<p>================================第四节课开始======================================================<br>###16泛型类<br>  A:泛型类:<br>    a:定义格式：<br>      修饰符 class 类名&lt;代表泛型的变量&gt; {  }</p>
<pre><code>  例如，API中的ArrayList集合：
  class ArrayList&lt;E&gt;{ 
       public boolean add(E e){ }
    public E get(int index){  }
  }

b:使用格式：
  创建对象时，确定泛型的类型

  例如，ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
  此时，变量E的值就是String类型
  class ArrayList&lt;String&gt;{ 
    public boolean add(String e){ }
    public String get(int index){  }
  }

  例如，ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
  此时，变量E的值就是Integer类型
  class ArrayList&lt;Integer&gt;{ 
       public boolean add(Integer e){ }
       public Integer get(int index){  }
  }</code></pre><p>###17泛型的方法<br>  A:泛型的方法<br>    a:定义格式：修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数){  }<br>    b:泛型方法的使用:<br>     1:例如，API中的ArrayList集合中的方法：<br>      public <T> T[] toArray(T[] a){  }<br>      //该方法，用来把集合元素存储到指定数据类型的数组中，返回已存储集合元素的数组</T></p>
<pre><code>  使用格式：调用方法时，确定泛型的类型
例如:
      ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
      String[] arr = new String[100];
      String[] result = list.toArray(arr);
   此时，变量T的值就是String类型。变量T，可以与定义集合的泛型不同
   public &lt;String&gt; String[] toArray(String[] a){  } 


  例如:
      ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
      Integer[] arr = new Integer[100];
      Integer [] result = list.toArray(arr);

  此时，变量T的值就是Integer类型。变量T，可以与定义集合的泛型不同
  public &lt;Integer&gt; Integer[] toArray(Integer[] a){  } </code></pre><p>###18泛型的接口<br>   A:泛型的接口:<br>     /*<br>      *  带有泛型的接口<br>      *<br>      *  public interface List <E>{<br>      *    abstract boolean add(E e);<br>      *  }<br>      *<br>      *  实现类,先实现接口,不理会泛型<br>      *  public class ArrayList<E> implements List<E>{<br>      *  }<br>      *  调用者 : new ArrayList<String>() 后期创建集合对象的时候,指定数据类型<br>      *<br>      *<br>      *  实现类,实现接口的同时,也指定了数据类型<br>      *  public class XXX implements List<String>{<br>      *  }<br>      *  new XXX()<br>      */<br>     public class GenericDemo2 {</String></String></E></E></E></p>
<pre><code>}</code></pre><p>###19泛型的好处<br>  A:泛型的好处<br>    a:将运行时期的ClassCastException，转移到了编译时期变成了编译失败。<br>    b:避免了类型强转的麻烦。<br>    演示下列代码：<br>    public class GenericDemo {<br>      public static void main(String[] args) {<br>        List<String> list = new ArrayList<String>();<br>        list.add(“abc”);<br>        list.add(“itcast”);<br>        //list.add(5);//当集合明确类型后，存放类型不一致就会编译报错<br>                     //集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</String></String></p>
<pre><code>    Iterator&lt;String&gt; it = list.iterator();
    while(it.hasNext()){
       String str = it.next();
       System.out.println(str.length()); //当使用Iterator&lt;String&gt;      
                                        //控制元素类型后，就不需要强转了。获取到的元素直接就是String类型
    }
  }
}</code></pre><p>###20泛型的通配符<br>   A:泛型的通配符<br>   /*<br>    *  泛型的通配符<br>    */<br>   public class GenericDemo {<br>    public static void main(String[] args) {<br>      ArrayList<String> array = new ArrayList<String>();</String></String></p>
<pre><code>  HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();

  array.add(&quot;123&quot;);
  array.add(&quot;456&quot;);

  set.add(789);
  set.add(890);

  iterator(array);
  iterator(set);
}
/*
 *  定义方法,可以同时迭代2个集合
 *  参数: 怎么实现 , 不能写ArrayList,也不能写HashSet
 *  参数: 或者共同实现的接口
 *  泛型的通配,匹配所有的数据类型  ?
 */
public static void iterator(Collection&lt;?&gt; coll){
  Iterator&lt;?&gt; it = coll.iterator();
  while(it.hasNext()){
    //it.next()获取的对象,什么类型
    System.out.println(it.next());
  }
}</code></pre><p>   }</p>
<p>###21泛型的限定<br> A:泛型的限定<br>   /*<br>    *  将的酒店员工,厨师,服务员,经理,分别存储到3个集合中<br>    *  定义方法,可以同时遍历3集合,遍历三个集合的同时,可以调用工作方法<br>    */<br>   import java.util.ArrayList;<br>   import java.util.Iterator;<br>   public class GenericTest {<br>    public static void main(String[] args) {<br>      //创建3个集合对象<br>      ArrayList<ChuShi> cs = new ArrayList<ChuShi>();<br>      ArrayList<FuWuYuan> fwy = new ArrayList<FuWuYuan>();<br>      ArrayList<JingLi> jl = new ArrayList<JingLi>();</JingLi></JingLi></FuWuYuan></FuWuYuan></ChuShi></ChuShi></p>
<pre><code>//每个集合存储自己的元素
cs.add(new ChuShi(&quot;张三&quot;, &quot;后厨001&quot;));
cs.add(new ChuShi(&quot;李四&quot;, &quot;后厨002&quot;));

fwy.add(new FuWuYuan(&quot;翠花&quot;, &quot;服务部001&quot;));
fwy.add(new FuWuYuan(&quot;酸菜&quot;, &quot;服务部002&quot;));

jl.add(new JingLi(&quot;小名&quot;, &quot;董事会001&quot;, 123456789.32));
jl.add(new JingLi(&quot;小强&quot;, &quot;董事会002&quot;, 123456789.33));</code></pre><p>   //   ArrayList<String> arrayString = new ArrayList<String>();<br>      iterator(jl);<br>      iterator(fwy);<br>      iterator(cs);</String></String></p>
<pre><code>}
/*
 * 定义方法,可以同时遍历3集合,遍历三个集合的同时,可以调用工作方法 work
 * ? 通配符,迭代器it.next()方法取出来的是Object类型,怎么调用work方法
 * 强制转换:  it.next()=Object o ==&gt; Employee
 * 方法参数: 控制,可以传递Employee对象,也可以传递Employee的子类的对象
 * 泛型的限定  本案例,父类固定Employee,但是子类可以无限?
 *   ? extends Employee 限制的是父类, 上限限定, 可以传递Employee,传递他的子类对象
 *   ? super   Employee 限制的是子类, 下限限定, 可以传递Employee,传递他的父类对象
 */
public static void iterator(ArrayList&lt;? extends Employee&gt; array){

   Iterator&lt;? extends Employee&gt; it = array.iterator();
   while(it.hasNext()){
     //获取出的next() 数据类型,是什么Employee
     Employee e = it.next();
     e.work();
   }
}</code></pre><p>   }</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/22/day17%E7%AC%94%E8%AE%B0/" rel="prev" title="day17笔记">
      <i class="fa fa-chevron-left"></i> day17笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/22/day19%E7%AC%94%E8%AE%B0/" rel="next" title="day19笔记">
      day19笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">KJH</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">95</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KJH</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
