<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="今日内容介绍1、构造方法2、this关键字3、super关键字4、综合案例 第一节课###01(面向对象)构造方法引入.avi                03：33###02(面向对象)构造方法作用.avi                05：56###03(面向对象)构造方法的定义和运行特点.avi        09：21###04(面向对象)默认添加的构造方法.avi">
<meta property="og:type" content="article">
<meta property="og:title" content="java学习笔记12">
<meta property="og:url" content="http://yoursite.com/2020/12/22/day12%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="今日内容介绍1、构造方法2、this关键字3、super关键字4、综合案例 第一节课###01(面向对象)构造方法引入.avi                03：33###02(面向对象)构造方法作用.avi                05：56###03(面向对象)构造方法的定义和运行特点.avi        09：21###04(面向对象)默认添加的构造方法.avi">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-12-22T11:21:13.851Z">
<meta property="article:modified_time" content="2020-12-23T15:08:06.691Z">
<meta property="article:author" content="KJH">
<meta property="article:tag" content="java基础学习">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/12/22/day12%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>java学习笔记12 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day12%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java学习笔记12
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:08:06" itemprop="dateModified" datetime="2020-12-23T23:08:06+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>今日内容介绍<br>1、构造方法<br>2、this关键字<br>3、super关键字<br>4、综合案例</p>
<p>第一节课<br>###01(面向对象)构造方法引入.avi                03：33<br>###02(面向对象)构造方法作用.avi                05：56<br>###03(面向对象)构造方法的定义和运行特点.avi        09：21<br>###04(面向对象)默认添加的构造方法.avi            04：32<br>###05(面向对象)构造方法的调用赋值.avi            05：22<br>###06(面向对象)构造方法的内存.avi                 09：44</p>
<p>第二节课<br>###07(面向对象)构造方法的重载.avi                 08：41<br>###08(面向对象)构造方法和一般方法区别.avi        02：31<br>###09(面向对象)this在构造方法之间的调用.avi     15：12<br>###10(面向对象)this在构造方法调用的内存图.avi    08：45<br>###11(面向对象)this简易应用.avi                  02：12</p>
<p>第三节课<br>###12(面向对象)super关键字_1.avi                 03：02<br>###13(面向对象)super关键字_2.avi                 08：59<br>###14(面向对象)子类父类的内存图.avi             16：04<br>###15(面向对象)super关键字_3.avi                11：38</p>
<p>第四节课<br>###16(面向对象)super关键字_4.avi                 08：17<br>###17(面向对象)创建子类对象过程的细节.avi       03：27<br>###18(面向对象)super的应用.avi                 13：02<br>###19(面向对象)完整员工案例分析.avi            05：50<br>###20(面向对象)完整员工案例代码实现.avi         10：46</p>
<p>============上面的内容,方便我们只做ppt,word教案以及书写下面的简要的笔记=================</p>
<p>=======================第一节课开始=============================================</p>
<p>###01构造方法引入<br>    * A:构造方法的引入<br>            在开发中经常需要在创建对象的同时明确对象的属性值，比如员工入职公司就要明确他的姓名、年龄等属性信息。<br>            那么，创建对象就要明确属性值，那怎么解决呢？也就是在创建对象的时候就要做的事情，当使用new关键字创建对象时，怎么给对象的属性初始化值呢？<br>            这就要学习Java另外一门小技术，构造方法。<br>    * B: 那什么是构造方法呢？<br>             从字面上理解即为构建创造时用的方法，即就是对象创建时要执行的方法。既然是对象创建时要执行的方法，那么只要在new对象时，<br>            知道其执行的构造方法是什么，就可以在执行这个方法的时候给对象进行属性赋值。</p>
<p>###02构造方法作用<br>    * A: 构造方法的作用:<br>            在new的同时给成员变量赋值,给对象属性进行初始化。<br>    * B: 举例:<br>            Perons p = new Person(“张三”,23); 在new 的时候给p对象的name属性和age属性进行赋值,使这个对象的属性有值。</p>
<p>​<br>###03构造方法的定义和运行特点<br>    * A: 构造方法定义<br>            构造方法的格式：<br>            修饰符 构造方法名(参数列表)<br>            {<br>            }</p>
<pre><code>* B: 构造方法的体现：
        构造方法没有返回值类型。也不需要写返回值。因为它是为构建对象的，对象创建完，方法就执行结束。
        构造方法名称必须和类型保持一致。
        构造方法没有具体的返回值。
        构造方法的代码体现：

* C: 构造方法举例
        class Person {
            // Person的成员属性age和name
            private int age;
            private String name;

            // Person的构造方法，拥有参数列表
            Person(int a, String nm) {
                // 接受到创建对象时传递进来的值，将值赋给成员属性
                age = a;
                name = nm;
            }
        }

* D: 构造方法运行特点:
        在new 对象的时候自动调用执行。</code></pre><p>###04默认添加的构造方法<br>    * A: 每一class类都必须有一个构造方法，构造方法不写也有。<br>         编译的时候，javac，系统会自动检查类中是否有构造方法，如果没有编译器就会自动添加一个构造方法<br>         比如Person类， 编译器添加一个无参构造 public Person(){}</p>
<p>###05构造方法的调用赋值<br>    * A: 理解构造方法的格式和基本功能之后，现在就要研究构造方法是怎么执行的呢？在创建对象的时候是如何初始化的呢？<br>         构造方法是专门用来创建对象的，也就是在new对象时要调用构造方法。现在来看看如何调用构造方法。</p>
<pre><code>* B: 案例
        class Person {
            // Person的成员属性age和name
            private int age;
            private String name;

            // Person的构造方法，拥有参数列表
            Person(int a, String nm) {
                // 接受到创建对象时传递进来的值，将值赋给成员属性
                age = a;
                name = nm;
            }

            public void speak() {
                System.out.println(&quot;name=&quot; + name + &quot;,age=&quot; + age);
            }
        }

        class PersonDemo {
            public static void main(String[] args) {
                // 创建Person对象，并明确对象的年龄和姓名
                Person p2 = new Person(23, &quot;张三&quot;);
                p2.speak();
            }
        }

    上述代码演示了创建对象时构造方法的调用。即在创建对象时，会调用与参数列表对应的构造方法</code></pre><p>###06构造方法的内存<br>        A:内存加载的过程<br>            有一个Person类, 创建Person 对象new Person()<br>            1、首先会将main方法压入栈中，执行main方法中的 new Person(23,”张三”);<br>            2、在堆内存中分配一片区域，用来存放创建的Person对象，这片内存区域会有属于自己的内存地址（0x88）。然后给成员变量进行默认初始化（name=null，age=0）。<br>            3、执行构造方法中的代码（age = a ; name = nm;）,将变量a对应的23赋值给age，将变量nm对应的”张三赋值给name，这段代码执行结束后，成员变量age和name的值已经改变。执行结束之后构造方法弹栈，Person对象创建完成。将Person对象的内存地址0x88赋值给p2。</p>
<p>==============================第二节课开始====================================    </p>
<p>###07构造方法的重载<br>    * A：当在描述事物时，要不要在类中写构造方法呢？这时要根据描述事物的特点来确定，当描述的事物在创建其对象时就要明确属性的值，这时就需要在定义类的时候书写带参数的构造方法。<br>    *    若创建对象时不需要明确具体的数据，这时可以不用书写构造方法（不书写也有默认的构造方法）。<br>            构造方法的细节：<br>            1、一个类中可以有多个构造方法，多个构造方法是以重载的形式存在的<br>            2、构造方法是可以被private修饰的，作用：其他程序无法创建该类的对象。<br>    * B: 举例<br>        class Person {<br>            private int age;<br>            private String name;</p>
<pre><code>    // 私有无参数的构造方法，即外界不能通过new Person();语句创建本类对象
    private Person() {
    }

    // 多个构造方法是以重载的形式存在
    Person(int a) {
        age = a;
    }

    Person(String nm, int a) {
        name = nm;
        age = a;
    }
}</code></pre><p>​        </p>
<p>###08构造方法和一般方法区别<br>    * A: 目前为止，学习两种方法，分别为构造方法和一般方法，那么他们之间有什么异同呢？<br>        1.格式不同<br>         构造方法 : 修饰符  类名(参数类型 参数 …){<br>            初始化成员变量<br>        }<br>        一般方法: 需要有返回值类型<br>        2.作用不同<br>        构造方法一般用来给成员变量初始化;<br>        一般方法根据需求而定;<br>        3.调用方式不同<br>        构造方法创建对象时调用, 或者this() super() 语句调用<br>        普通方法需要对象调用或者静态方法直接调用静态方法.<br>        4.执行不同<br>        构造方法在对象创建时就执行了，而且只执行一次。<br>        一般方法是在对象创建后，需要使用时才被对象调用，并可以被多次调用。</p>
<p>​<br>###09this在构造方法之间的调用<br>    * A: 在之前学习方法之间调用时，可以通过方法名进行调用。可是针对构造方法，无法通过构造方法名来相互调用。<br>        构造方法之间的调用，可以通过this关键字来完成。<br>        构造方法调用格式：<br>        this(参数列表);</p>
<pre><code>* B:调用构造方法的案例
    class Person {
        // Person的成员属性
        private int age;
        private String name;

        // 无参数的构造方法
        Person() {
        }

        // 给姓名初始化的构造方法
        Person(String nm) {
            name = nm;
        }

        // 给姓名和年龄初始化的构造方法
        Person(String nm, int a) {
            // 由于已经存在给姓名进行初始化的构造方法 name = nm;因此只需要调用即可
            // 调用其他构造方法，需要通过this关键字来调用
            this(nm);
            // 给年龄初始化
            age = a;
        }
    }</code></pre><p>###10this在构造方法调用的内存图<br>    * A: 被加载的代码<br>        class Person {<br>            private int age;<br>            private String name;</p>
<pre><code>    Person() {
    }
    Person(String nm) {
        name = nm;
    }
    Person(String nm, int a) {
        this(nm);
        age = a;
    }
}

class PersonDemo {
    public static void main(String[] args) {
        Person p = new Person(&quot;张三&quot;, 23);
    }
}</code></pre><p>​<br>    * B: 构造方法调用的原理图<br>    *   图略<br>        1、先执行main方法，main方法压栈，执行其中的new Person(“张三”,23);<br>        2、堆内存中开辟空间，并为其分配内存地址0x33，，紧接着成员变量默认初始化（name=null  age = 0）；<br>        3、拥有两个参数的构造方法（Person（String nm , int a））压栈，在这个构造方法中有一个隐式的this，因为构造方法是给对象初始化的，那个对象调用到这个构造方法，this就指向堆中的那个对象。<br>        4、由于Person（String nm , int a）构造方法中使用了this(nm);构造方法Person(String nm)就会压栈，并将“张三”传递给nm。在Person（String nm , int a）构造方法中同样也有隐式的this，this的值同样也为0x33，这时会执行其中name = nm，即把“张三”赋值给成员的name。当赋值结束后Person（String nm , int a）构造方法弹栈。<br>        5、程序继续执行构造方法（Person（String nm , int a）中的age = a；这时会将23赋值给成员属性age。赋值结束构造方法（Person（String nm , int a）弹栈。<br>        6、当构造方法（Person（String nm , int a）弹栈结束后，Person对象在内存中创建完成，并将0x33赋值给main方法中的p引用变量。<br>        注意：<br>        this到底代表什么呢？this代表的是对象，具体代表哪个对象呢？哪个对象调用了this所在的方法，this就代表哪个对象。<br>        调用其他构造方法的语句必须定义在构造方法的第一行，原因是初始化动作要最先执行。</p>
<p>###11this简易应用<br>    * A: 当在方法中出现了局部变量和成员变量同名的时候，那么在方法中怎么区别局部变量成员变量呢？可以在成员变量名前面加上this.来区别成员变量和局部变量<br>    * B: 举例1<br>        class Person {<br>            private int age;<br>            private String name;</p>
<pre><code>        // 给姓名和年龄初始化的构造方法
        Person(String name, int age) {
            // 当需要访问成员变量是，只需要在成员变量前面加上this.即可
            this.name = name;
            this.age = age;
        }

        public void speak() {
            System.out.println(&quot;name=&quot; + this.name + &quot;,age=&quot; + this.age);
        }
    }

    class PersonDemo {
        public static void main(String[] args) {
            Person p = new Person(&quot;张三&quot;, 23);
            p.speak();
        }
    }

* C: 举例2
    学习完了构造方法、this的用法之后，现在做个小小的练习。
    需求：在Person类中定义功能，判断两个人是否是同龄人
    class Person {
        private int age;
        private String name;

        // 给姓名和年龄初始化的构造方法
        Person(String name, int age) {
            // 当需要访问成员变量是，只需要在成员变量前面加上this.即可
            this.name = name;
            this.age = age;
        }

        public void speak() {
            System.out.println(&quot;name=&quot; + this.name + &quot;,age=&quot; + this.age);
        }

        // 判断是否为同龄人
        public boolean equalsAge(Person p) {
            // 使用当前调用该equalsAge方法对象的age和传递进来p的age进行比较
            // 由于无法确定具体是哪一个对象调用equalsAge方法，这里就可以使用this来代替
            /*
             * if(this.age == p.age) { return true; } return false;
             */
            return this.age = p.age;
        }
    }</code></pre><p>==============================第三节课开始====================================</p>
<p>​<br>###12super关键字_1</p>
<pre><code>* A: 子父类中构造方法的调用
    在创建子类对象时，父类的构造方法会先执行，因为子类中所有构造方法的第一行有默认的隐式super();语句。
* B: 格式：
    调用本类中的构造方法
    this(实参列表);
    调用父类中的空参数构造方法
    super();
    调用父类中的有参数构造方法
    super(实参列表);</code></pre><p>###13super关键字_2<br>    * A:子类构造方法,有一个默认添加的构造方法<br>        public class Student extends Person {<br>             public Student(){<br>                 super();<br>             }<br>        }<br>    * B :为什么子类对象创建都要访问父类中的构造方法？因为子类继承了父类的内容，所以创建对象时，必须要先看父类是如何对其内容进行初始化的，看如下程序<br>        public class Test {<br>            public static void main(String[] args) {<br>                new Zi();<br>            }</p>
<pre><code>}
class Fu{
    int num ;
    Fu(){
        System.out.println(&quot;Fu构造方法&quot;+num);
        num = 4;
    }
}
class Zi extends Fu{
    Zi(){
         //super(); 调用父类空参数构造方法
        System.out.println(&quot;Zi构造方法&quot;+num);
    }
}

执行结果：</code></pre><p>　　     Fu构造方法0<br>　　     Zi构造方法4</p>
<pre><code>通过结果发现，子类构造方法执行时中，调用了父类构造方法，这说明，子类构造方法中有一句super()。
那么，子类中的构造方法为什么会有一句隐式的super()呢？
原因：子类会继承父类中的内容，所以子类在初始化时，必须先到父类中去执行父类的初始化动作。这样，才可以使用父类中的内容。
当父类中没有空参数构造方法时，子类的构造方法必须有显示的super语句，指定要访问的父类有参数构造方法。</code></pre><p>​<br>###14子类父类的内存图<br>        略:<br>        具体见 day12_source/子类父类的内存图.JPG    </p>
<p>###15super关键字_3<br>    * A: 创建子类对象的时候会必须调用父类的构造方法。<br>       子类默认会调用父类的无参构造， 但如果父类没有无参构造，子类的构造方法继续调用父类的无参构造就会报错。<br>       因此子类构造方法的第一行需要调用父类的构造方法，既可以调用父类的无参构造，也可以调用父类的有参构造，这样语法上就不会报错。</p>
<p>###16super关键字_4<br>    * A: 构造方法第一行,写this()还是super()<br>    *  this() 是调用本类的构造方法,super()是调用父类的构造方法, 且两条语句不能同时存在<br>    *  保证子类的所有构造方法调用到父类的构造方法即可</p>
<pre><code>* B: 小结:
* 无论如何,子类的所有构造方法,直接或间接必须调用到父类构造方法;
* 子类的构造方法什么都不写,默认的构造方法第一行super()</code></pre><p>​<br>###17创建子类对象过程的细节<br>    * A 创建子类对象过程的细节<br>    * 如果子类的构造方法第一行写了this调用了本类其他构造方法，那么super调用父类的语句还有吗？<br>    * 这时是没有的，因为this()或者super(),只能定义在构造方法的第一行，因为初始化动作要先执行。<br>    * 父类构造方法中是否有隐式的super呢？<br>    * 也是有的。记住：只要是构造方法默认第一行都是super();<br>    * 父类的父类是谁呢？super调用的到底是谁的构造方法呢？<br>    * Java体系在设计，定义了一个所有对象的父类Object</p>
<pre><code>* 注意：
    类中的构造方法默认第一行都有隐式的super()语句，在访问父类中的空参数构造方法。所以父类的构造方法既可以给自己的对象初始化，也可以给自己的子类对象初始化。
    如果默认的隐式super()语句在父类中没有对应的构造方法，那么必须在构造方法中通过this或者super的形式明确要调用的构造方法。</code></pre><p>==============================第四节课开始====================================</p>
<p>###18super的应用<br>     * A: 练习：描述学生和工人这两个类，将他们的共性name和age抽取出来存放在父类中，并提供相应的get和set方法，同时需要在创建学生和工人对象就必须明确姓名和年龄<br>     * 案例:<br>        //定义Person类，将Student和Worker共性抽取出来<br>        class Person {<br>            private String name;<br>            private int age;<br>            public Person(String name, int age) {<br>                // super();<br>                this.name = name;<br>                this.age = age;<br>            }<br>            public String getName() {<br>                return name;<br>            }<br>            public void setName(String name) {<br>                this.name = name;<br>            }<br>            public int getAge() {<br>                return age;<br>            }<br>            public void setAge(int age) {<br>                this.age = age;<br>            }<br>        }<br>        class Student extends Person {<br>            // Student类的构造方法<br>            Student(String name, int age) {<br>                // 使用super关键字调用父类构造方法，进行相应的初始化动作<br>                super(name, age);<br>            }<br>            public void study() {// Studnet中特有的方法<br>                System.out.println(this.getName() + “同学在学习”);<br>            }<br>        }<br>        class Worker extends Person {<br>            Worker(String name, int age) {<br>                // 使用super关键字调用父类构造方法，进行相应的初始化动作<br>                super(name, age);<br>            }<br>            public void work() {// Worker 中特有的方法<br>                System.out.println(this.getName() + “工人在工作”);<br>            }<br>        }<br>        public class Test {<br>            public static void main(String[] args) {<br>                Student stu = new Student(“小明”,23);<br>        stu.study();</p>
<pre><code>Worker w = new Worker(&quot;小李&quot;,45);
w.work();
    }
}</code></pre><p>###19完整员工案例分析<br>     * A: 项目介绍<br>        某IT公司有多名员工，按照员工负责的工作不同，进行了部门的划分（研发部员工、维护部员工）。研发部根据所需研发的内容不同，又分为JavaEE工程师、Android工程师；维护部根据所需维护的内容不同，又分为网络维护工程师、硬件维护工程师。<br>        公司的每名员工都有他们自己的员工编号、姓名，并要做它们所负责的工作。<br>        工作内容<br>        JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站<br>        Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件<br>        网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通<br>        硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机<br>        请根据描述，完成员工体系中所有类的定义，并指定类之间的继承关系。进行XX工程师类的对象创建，完成工作方法的调用。</p>
<pre><code>* B: 案例分析
    根据上述部门的描述，得出如下的员工体系图

    根据员工信息的描述，确定每个员工都有员工编号、姓名、要进行工作。则，把这些共同的属性与功能抽取到父类中（员工类），关于工作的内容由具体的工程师来进行指定。
    工作内容
    JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站
    Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件
    网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通
    硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机
    创建JavaEE工程师对象，完成工作方法的调用</code></pre><p>###20案例代码实现<br>     * A:定义员工类(抽象类)<br>        public abstract class Employee {<br>            private String id;// 员工编号<br>            private String name; // 员工姓名</p>
<pre><code>    //空参数构造方法
    public Employee() {
        super();
    }
    //有参数构造方法
    public Employee(String id, String name) {
        super();
        this.id = id;
        this.name = name;
    }
    public String getId() {
        return id;
    }
    public void setId(String id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    //工作方法（抽象方法）
    public abstract void work(); 
}

* B :    定义研发部员工类Developer 继承 员工类Employee
public abstract class Developer extends Employee {
    //空参数构造方法
    public Developer() {
        super();
    }
    //有参数构造方法
    public Developer(String id, String name) {
        super(id, name);
    }
}

* C:    定义维护部员工类Maintainer 继承 员工类Employee
public abstract class Maintainer extends Employee {
    //空参数构造方法
    public Maintainer() {
        super();
    }
    //有参数构造方法
    public Maintainer(String id, String name) {
        super(id, name);
    }
}

* D:    定义JavaEE工程师 继承 研发部员工类，重写工作方法
public class JavaEE extends Developer {
    //空参数构造方法
    public JavaEE() {
        super();
    }
    //有参数构造方法
    public JavaEE(String id, String name) {
        super(id, name);
    }

    @Override
    public void work() {
        System.out.println(&quot;员工号为 &quot; + getId() + &quot; 的 &quot; + getName() + &quot; 员工，正在研发淘宝网站&quot;);
    }
}

* E:    定义Android工程师 继承 研发部员工类，重写工作方法
public class Android extends Developer {
    //空参数构造方法
    public Android() {
        super();
    }
    //有参数构造方法
    public Android(String id, String name) {
        super(id, name);
    }

    @Override
    public void work() {
        System.out.println(&quot;员工号为 &quot; + getId() + &quot; 的 &quot; + getName() + &quot; 员工，正在研发淘宝手机客户端软件&quot;);
    }
}

* F:    定义Network网络维护工程师 继承 维护部员工类，重写工作方法
public class Network extends Maintainer {
    //空参数构造方法
    public Network() {
        super();
    }
    //有参数构造方法
    public Network(String id, String name) {
        super(id, name);
    }

    @Override
    public void work() {
        System.out.println(&quot;员工号为 &quot; + getId() + &quot; 的 &quot; + getName() + &quot; 员工，正在检查网络是否畅通&quot;);
    }
}

* G:    定义Hardware硬件维护工程师 继承 维护部员工类，重写工作方法
public class Hardware extends Maintainer {
    //空参数构造方法
    public Hardware() {
        super();
    }
    //有参数构造方法
    public Hardware(String id, String name) {
        super(id, name);
    }

    @Override
    public void work() {
        System.out.println(&quot;员工号为 &quot; + getId() + &quot; 的 &quot; + getName() + &quot; 员工，正在修复打印机&quot;);
    }
}

* H:    在测试类中，创建JavaEE工程师对象，完成工作方法的调用
public class Test {
    public static void main(String[] args) {
        //创建JavaEE工程师员工对象，该员工的编号000015，员工的姓名 小明
        JavaEE ee = new JavaEE(&quot;000015&quot;, &quot;小明&quot;);
        //调用该员工的工作方法
        ee.work();
    }
}</code></pre><p>###21总结<br>    * 把今天的知识点总结一遍。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/" rel="tag"># java基础学习</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/22/day11%E7%AC%94%E8%AE%B0/" rel="prev" title="java学习笔记11">
      <i class="fa fa-chevron-left"></i> java学习笔记11
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/22/day13%E7%AC%94%E8%AE%B0/" rel="next" title="java学习笔记13">
      java学习笔记13 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">KJH</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">104</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KJH</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

<span id="busuanzi_container_site_uv">
  本站总访问量<span id="busuanzi_value_site_uv"></span>次
</span>
        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
