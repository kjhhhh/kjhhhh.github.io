<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="List 就是链表，这个我们在很久之前就学习过了单向链表，双向链表。之前对STL有过大概的剖析，但没涉及到链表，早几天使用到了STL中的，对其中的有些细节不明了，特意重新阅读了下源码，对STL中的List 加深一下理解。。。。论指针（地址）的重要性。 附带说一句，阅读源码，建议使用Source Insight，非常好的源码阅读工具，没有其二。 1、List 概述 list 和 vector 是两个">
<meta property="og:type" content="article">
<meta property="og:title" content="STLlist内部机制">
<meta property="og:url" content="http://yoursite.com/2020/12/27/STLlist%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="KJHの博客">
<meta property="og:description" content="List 就是链表，这个我们在很久之前就学习过了单向链表，双向链表。之前对STL有过大概的剖析，但没涉及到链表，早几天使用到了STL中的，对其中的有些细节不明了，特意重新阅读了下源码，对STL中的List 加深一下理解。。。。论指针（地址）的重要性。 附带说一句，阅读源码，建议使用Source Insight，非常好的源码阅读工具，没有其二。 1、List 概述 list 和 vector 是两个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/12/27/STLlist%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/20150321140643595">
<meta property="og:image" content="http://yoursite.com/2020/12/27/STLlist%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/20150321140648010">
<meta property="og:image" content="http://yoursite.com/2020/12/27/STLlist%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/20150321140621241">
<meta property="og:image" content="http://yoursite.com/2020/12/27/STLlist%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/20150321140626139">
<meta property="og:image" content="http://yoursite.com/2020/12/27/STLlist%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/20150321140630008">
<meta property="og:image" content="http://yoursite.com/2020/12/27/STLlist%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/20150321140633455">
<meta property="article:published_time" content="2020-12-27T07:33:31.606Z">
<meta property="article:modified_time" content="2021-03-22T13:36:34.167Z">
<meta property="article:author" content="匡俊桦">
<meta property="article:tag" content="C++进阶学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/12/27/STLlist%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/20150321140643595">

<link rel="canonical" href="http://yoursite.com/2020/12/27/STLlist%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>STLlist内部机制 | KJHの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KJHの博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录&回忆</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/STLlist%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          STLlist内部机制
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-27 15:33:31" itemprop="dateCreated datePublished" datetime="2020-12-27T15:33:31+08:00">2020-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-22 21:36:34" itemprop="dateModified" datetime="2021-03-22T21:36:34+08:00">2021-03-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>List 就是链表，这个我们在很久之前就学习过了<a href="http://blog.csdn.net/wenqian1991/article/details/17764165" target="_blank" rel="noopener">单向链表</a>，<a href="http://blog.csdn.net/wenqian1991/article/details/17969861" target="_blank" rel="noopener">双向链表</a>。之前对STL有过大概的剖析，但没涉及到链表，早几天使用到了STL中的<list>，对其中的有些细节不明了，特意重新阅读了下源码，对STL中的List 加深一下理解。。。。论指针（地址）的重要性。</list></p>
<p>附带说一句，阅读源码，建议使用Source Insight，非常好的源码阅读工具，没有其二。</p>
<p><strong>1、List 概述</strong></p>
<p>list 和 <a href="http://blog.csdn.net/wenqian1991/article/details/19540385" target="_blank" rel="noopener">vector</a> 是两个最常用的容器（序列式容器）。二者最显著的区别自然就是vector是连续线性空间，list则是不连续线性空间，相比于vector（动态数组），它的好处是每次插入和删除一个元素，只需配置或释放一个元素空间，对于任何位置的元素插入或元素移除，list永远是常数时间。尺有所长，寸有所短，list 寻址某一元素也没有vector（常数时间）方便。那么什么时机下最适合使用哪一种容器呢？必须视元素的多寡，元素的构造复杂度，元素存取行为的特定而定。</p>
<p><strong>2、list 的节点</strong></p>
<p>侯捷先生剖析的是STL203版的源码，我们这里紧跟下时尚，来剖析最新的STL源码<a href="http://www.sgi.com/tech/stl/download.html" target="_blank" rel="noopener">http://www.sgi.com/tech/stl/download.html </a></p>
<p>以下是STL list的节点结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_node_base</span> &#123;</span></span><br><span class="line">  _List_node_base* _M_next;</span><br><span class="line">  _List_node_base* _M_prev;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">List_node</span> :</span> <span class="keyword">public</span> _List_node_base &#123;</span><br><span class="line">  _Tp _M_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>显然这是一个双向链表，链表节点的数据部分单独的放在一个结构体中，然后通过继承来获得链表的先后指针。node_base中仅含指针，这赶脚有点类似于linux内核中的list。<a id="more"></a></p>
<p><strong><em>\</em>3、list 的迭代器**</strong></p>
<p>因为链表节点在储存空间中不一定是连续存在的，自然也就不能像vector一样用普通指针作为迭代器。list迭代器必须有能力指向list的节点，并有能力正确的递增。递减。取值、成员存取等操作。这是作为任何一个容器的迭代器必须具备的。对于非连续空间的递增，递减等操作自然是针对该容器的属性来的，就list而言，则是指向上一个节点，下一个节点，以及获取指定节点。</p>
<p>STL list是一个双向链表，迭代器必须具备前移，后移的能力，所以list提供的是bidirectional iterator （双向一个个移动）。关于迭代器的分类，参见<a href="http://blog.csdn.net/wenqian1991/article/details/19815721" target="_blank" rel="noopener">STL迭代器</a>。vector是随机迭代器类型（random access iterator），这也是符合vector 可随机存取的能力。</p>
<p>以下是list迭代器的设计：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_iterator_base</span> &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span>                     size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                  difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">	_List_node_base* _M_node;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	_List_iterator_base(_List_node_base* __x) : _M_node(__x) &#123;&#125;</span><br><span class="line">	_List_iterator_base() &#123;&#125;</span><br><span class="line">	<span class="comment">//增加和减少，就是指向上一个节点和下一个节点</span></span><br><span class="line">	<span class="keyword">void</span> _M_incr() &#123; _M_node = _M_node-&gt;_M_next; &#125;</span><br><span class="line">	<span class="keyword">void</span> _M_decr() &#123; _M_node = _M_node-&gt;_M_prev; &#125;</span><br><span class="line">	<span class="comment">//运算符重载</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> _List_iterator_base&amp; __x) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> _M_node == __x._M_node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> _List_iterator_base&amp; __x) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> _M_node != __x._M_node;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Ref</span>, <span class="title">class</span> _<span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">List_iterator</span> :</span> <span class="keyword">public</span> _List_iterator_base &#123;</span><br><span class="line">	<span class="keyword">typedef</span> _List_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt;             iterator;</span><br><span class="line">	<span class="keyword">typedef</span> _List_iterator&lt;_Tp, <span class="keyword">const</span> _Tp&amp;, <span class="keyword">const</span> _Tp*&gt; const_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> _List_iterator&lt;_Tp, _Ref, _Ptr&gt;             _Self;</span><br><span class="line">	<span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">	<span class="keyword">typedef</span> _Ptr pointer;</span><br><span class="line">	<span class="keyword">typedef</span> _Ref reference;</span><br><span class="line">	<span class="keyword">typedef</span> _List_node&lt;_Tp&gt; _Node;</span><br><span class="line">	<span class="comment">//下面是子类指针赋值给父类指针，is-a原则（反过来不行）</span></span><br><span class="line">	_List_iterator(_Node* __x) : _List_iterator_base(__x) &#123;&#125;</span><br><span class="line">	_List_iterator() &#123;&#125;</span><br><span class="line">	_List_iterator(<span class="keyword">const</span> iterator&amp; __x) : _List_iterator_base(__x._M_node) &#123;&#125;</span><br><span class="line">	<span class="comment">//对迭代器取值，获取节点的数据</span></span><br><span class="line">	reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> ((_Node*)_M_node)-&gt;_M_data; &#125;</span><br><span class="line">	<span class="comment">//对迭代器的成员存取，返回的是地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">	pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line">	<span class="comment">//前缀和后缀++和--自增自减符重载</span></span><br><span class="line">	_Self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;_M_incr();</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回引用，可链式操作</span></span><br><span class="line">	&#125;</span><br><span class="line">	_Self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">		_Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;_M_incr();</span><br><span class="line">		<span class="keyword">return</span> __tmp;<span class="comment">//返回变量，不可链式操作</span></span><br><span class="line">	&#125;</span><br><span class="line">	_Self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;_M_decr();</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	_Self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">		_Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;_M_decr();</span><br><span class="line">		<span class="keyword">return</span> __tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>struct 也具备class 一样的特性哦，差别在于成员的默认属性不一样。</p>
<p><strong><em>\</em>4、list 的数据结构**</strong></p>
<p>表示源码中list的数据结构有点大，这里只贴出重要的核心部分，省略了一部分语义重复或结构重复的部分，面向对象编程就是所有的成员及操作均封装在一个类中，私有成员也都必须用成员函数（友元）访问，应用时，一个实例化对象直接调用这些操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span> = __<span class="title">STL_DEFAULT_ALLOCATOR</span>(_<span class="title">Tp</span>) &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">list</span> :</span> <span class="keyword">protected</span> _List_base&lt;_Tp, _Alloc&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">//创建一个数据节点，带初始化数据</span></span><br><span class="line">	_Node* _M_create_node(<span class="keyword">const</span> _Tp&amp; __x)</span><br><span class="line">	&#123;</span><br><span class="line">		_Node* __p = _M_get_node();<span class="comment">//配置一个节点空间</span></span><br><span class="line">		__STL_TRY&#123;</span><br><span class="line">			_Construct(&amp;__p-&gt;_M_data, __x);<span class="comment">//构造函数：构造对象在预先准备好了的缓冲区中进行</span></span><br><span class="line">			                               <span class="comment">//将数据植入</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//异常处理</span></span><br><span class="line">		__STL_UNWIND(_M_put_node(__p));<span class="comment">//释放空间</span></span><br><span class="line">		<span class="keyword">return</span> __p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//不带初始化数据</span></span><br><span class="line">	_Node* _M_create_node()</span><br><span class="line">	&#123;</span><br><span class="line">		_Node* __p = _M_get_node();</span><br><span class="line">		__STL_TRY&#123;</span><br><span class="line">			_Construct(&amp;__p-&gt;_M_data);</span><br><span class="line">		&#125;</span><br><span class="line">		__STL_UNWIND(_M_put_node(__p));</span><br><span class="line">		<span class="keyword">return</span> __p;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">list</span><span class="params">(<span class="keyword">const</span> allocator_type&amp; __a = allocator_type())</span> : _<span class="title">Base</span><span class="params">(__a)</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">//指向第一个数据节点</span></span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span>             </span>&#123; <span class="keyword">return</span> (_Node*)(_M_node-&gt;_M_next); &#125;</span><br><span class="line">	<span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (_Node*)(_M_node-&gt;_M_next); &#125;</span><br><span class="line">	<span class="comment">//指向最后一个数据节点的下一个节点，也就是头节点</span></span><br><span class="line">	<span class="comment">//在STL中，所有序列式容器都是前闭后开区间</span></span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span>             </span>&#123; <span class="keyword">return</span> _M_node; &#125;</span><br><span class="line">	<span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _M_node; &#125;</span><br><span class="line">	<span class="comment">//判断链表是否为空，即是否还有数据节点</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _M_node-&gt;_M_next == _M_node; &#125;</span><br><span class="line">	<span class="comment">//返回链表的大小</span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		size_type __result = <span class="number">0</span>;</span><br><span class="line">		distance(begin(), end(), __result);</span><br><span class="line">		<span class="keyword">return</span> __result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//最大空间</span></span><br><span class="line">	<span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(<span class="number">-1</span>); &#125;</span><br><span class="line">	<span class="comment">//返回第一个节点数据（元素）</span></span><br><span class="line">	<span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *begin(); &#125;</span><br><span class="line">	<span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> *begin(); &#125;</span><br><span class="line">	<span class="comment">//返回最后一个节点数据</span></span><br><span class="line">	<span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(--end()); &#125;</span><br><span class="line">	<span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> *(--end()); &#125;</span><br><span class="line">	<span class="comment">//交换两个链表，一看代码，就是直接交换一下头节点指针，几多方便，链表的优越性，通过指针穿针引线</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">list</span>&lt;_Tp, _Alloc&gt;&amp; __x)</span> </span>&#123; __STD::swap(_M_node, __x._M_node); &#125;</span><br><span class="line">	<span class="comment">//在指定位置插入数据节点，是插入到指定位置position的前面，返回插入节点</span></span><br><span class="line">	<span class="function">iterator <span class="title">insert</span><span class="params">(iterator __position, <span class="keyword">const</span> _Tp&amp; __x)</span> </span>&#123;</span><br><span class="line">		_Node* __tmp = _M_create_node(__x);<span class="comment">//创建一个数据节点</span></span><br><span class="line">		<span class="comment">//双向链表的插入操作，处理好前后指针的指向</span></span><br><span class="line">		<span class="comment">//处理新节点的指向</span></span><br><span class="line">		__tmp-&gt;_M_next = __position._M_node;<span class="comment">//新节点next指针指向position的节点</span></span><br><span class="line">		__tmp-&gt;_M_prev = __position._M_node-&gt;_M_prev;<span class="comment">//新节点的prev指针指向position前面的那个节点</span></span><br><span class="line">		<span class="comment">//修正新节点前后两个节点的指向</span></span><br><span class="line">		__position._M_node-&gt;_M_prev-&gt;_M_next = __tmp;</span><br><span class="line">		__position._M_node-&gt;_M_prev = __tmp;</span><br><span class="line">		<span class="keyword">return</span> __tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//在头部插入一个节点，成为头节点（表头的后面那个数据节点）</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x)</span> </span>&#123; insert(begin(), __x); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">()</span> </span>&#123; insert(begin()); &#125;</span><br><span class="line">	<span class="comment">//插入一个尾节点</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x)</span> </span>&#123; insert(end(), __x); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">()</span> </span>&#123; insert(end()); &#125;</span><br><span class="line">	<span class="comment">//删除指定节点，并返回下一个节点</span></span><br><span class="line">	<span class="function">iterator <span class="title">erase</span><span class="params">(iterator __position)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//记录待删除节点的前后两个节点</span></span><br><span class="line">		_List_node_base* __next_node = __position._M_node-&gt;_M_next;</span><br><span class="line">		_List_node_base* __prev_node = __position._M_node-&gt;_M_prev;</span><br><span class="line">		_Node* __n = (_Node*)__position._M_node;<span class="comment">//定位待删除数据节点</span></span><br><span class="line">		<span class="comment">//修正节点前后指针</span></span><br><span class="line">		__prev_node-&gt;_M_next = __next_node;</span><br><span class="line">		__next_node-&gt;_M_prev = __prev_node;</span><br><span class="line">		<span class="comment">//销毁数据并释放空间</span></span><br><span class="line">		_Destroy(&amp;__n-&gt;_M_data);</span><br><span class="line">		_M_put_node(__n);</span><br><span class="line">		<span class="keyword">return</span> iterator((_Node*)__next_node);<span class="comment">//返回删除节点的下一个节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; _Base::clear(); &#125;</span><br><span class="line">	<span class="comment">//重新调整链表大小，多退少补方针</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type __new_size, <span class="keyword">const</span> _Tp&amp; __x)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type __new_size)</span> </span>&#123; <span class="keyword">this</span>-&gt;resize(__new_size, _Tp()); &#125;</span><br><span class="line">	<span class="comment">//删除头节点（第一个数据节点）</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123; erase(begin()); &#125;</span><br><span class="line">	<span class="comment">//删除尾节点</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		iterator __tmp = end();</span><br><span class="line">		erase(--__tmp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">list</span>() &#123; &#125;</span><br><span class="line">	<span class="built_in">list</span>&lt;_Tp, _Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">list</span>&lt;_Tp, _Alloc&gt;&amp; __x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// assign(), a generalized assignment member function.  Two</span></span><br><span class="line">	<span class="comment">// versions: one that takes a count, and one that takes a range.</span></span><br><span class="line">	<span class="comment">// The range version is a member template, so we dispatch on whether</span></span><br><span class="line">	<span class="comment">// or not the type is an integer.</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">(size_type __n, <span class="keyword">const</span> _Tp&amp; __val)</span> </span>&#123; _M_fill_assign(__n, __val); &#125;</span><br><span class="line">	<span class="keyword">void</span> _M_fill_assign(size_type __n, <span class="keyword">const</span> _Tp&amp; __val);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">//迁移操作，将[first,last)之间的所有元素移动到position之前</span></span><br><span class="line">	<span class="comment">//原来是这样纸：one,two,position,three,four,first,five,last,six</span></span><br><span class="line"><span class="comment">//操作之后是酱紫：one,two,first,five,position,three,four,last,six</span></span><br><span class="line">	<span class="comment">//很简单，调整临界区的几个指针就行了，指针（地址）真方便</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(iterator __position, iterator __first, iterator __last)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (__position != __last) &#123;</span><br><span class="line">			<span class="comment">// Remove [first, last) from its old position.调出来</span></span><br><span class="line">			<span class="comment">//以上面例子为例</span></span><br><span class="line">			__last._M_node-&gt;_M_prev-&gt;_M_next = __position._M_node;<span class="comment">//five-&gt;next = position</span></span><br><span class="line">			__first._M_node-&gt;_M_prev-&gt;_M_next = __last._M_node;<span class="comment">//four-&gt;next = last</span></span><br><span class="line">			__position._M_node-&gt;_M_prev-&gt;_M_next = __first._M_node;<span class="comment">//two-&gt;first</span></span><br><span class="line">			<span class="comment">// Splice [first, last) into its new position.移进去</span></span><br><span class="line">			_List_node_base* __tmp = __position._M_node-&gt;_M_prev;<span class="comment">//tmp = three</span></span><br><span class="line">			__position._M_node-&gt;_M_prev = __last._M_node-&gt;_M_prev;<span class="comment">//position-&gt;prev = five</span></span><br><span class="line"></span><br><span class="line">			__last._M_node-&gt;_M_prev = __first._M_node-&gt;_M_prev;<span class="comment">//last-&gt;prev = four</span></span><br><span class="line">			__first._M_node-&gt;_M_prev = __tmp;<span class="comment">//four-&gt;prev = three</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//上面这个函数再次将链表的优越性显露无疑，这得归功于非连续空间指针的灵活性</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//将链表x接合与position所指位置之前，x必须不同于*this</span></span><br><span class="line">	<span class="comment">//不过下面这个函数似乎没有有效性处理</span></span><br><span class="line">	<span class="comment">/*添加下面语句会更好</span></span><br><span class="line"><span class="comment">		if(&amp;__x != this)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator __position, <span class="built_in">list</span>&amp; __x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!__x.empty())</span><br><span class="line">			<span class="keyword">this</span>-&gt;transfer(__position, __x.begin(), __x.end());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将i所指元素移动到position位置之前</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator __position, <span class="built_in">list</span>&amp;, iterator __i)</span> </span>&#123;</span><br><span class="line">		iterator __j = __i;</span><br><span class="line">		++__j;</span><br><span class="line">		<span class="keyword">if</span> (__position == __i || __position == __j) <span class="keyword">return</span>;<span class="comment">//是否为空</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;transfer(__position, __i, __j);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将[first,last)移动到position位置之前</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator __position, <span class="built_in">list</span>&amp;, iterator __first, iterator __last)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (__first != __last)</span><br><span class="line">			<span class="keyword">this</span>-&gt;transfer(__position, __first, __last);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">unique</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">list</span>&amp; __x)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>5、list的构造与内存管理</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> _<span class="title">List_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> _Alloc allocator_type;</span><br><span class="line">	<span class="function">allocator_type <span class="title">get_allocator</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> allocator_type(); &#125;</span><br><span class="line">	<span class="comment">//构造函数，构造一个环状链表</span></span><br><span class="line">	_List_base(<span class="keyword">const</span> allocator_type&amp;) &#123;</span><br><span class="line">		_M_node = _M_get_node();<span class="comment">//只是配置一个空间，并没有存入数据，可以认为是表头</span></span><br><span class="line">		_M_node-&gt;_M_next = _M_node;</span><br><span class="line">		_M_node-&gt;_M_prev = _M_node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~_List_base() &#123;</span><br><span class="line">		clear();<span class="comment">//清除数据节点和回收空间</span></span><br><span class="line">		_M_put_node(_M_node);<span class="comment">//释放表头节点空间</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">//第一级空间配置器</span></span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;_List_node&lt;_Tp&gt;, _Alloc&gt; _Alloc_type;</span><br><span class="line">	<span class="comment">//配置一个节点</span></span><br><span class="line">	_List_node&lt;_Tp&gt;* _M_get_node() &#123; <span class="keyword">return</span> _Alloc_type::allocate(<span class="number">1</span>); &#125;</span><br><span class="line">	<span class="comment">//释放一个指定节点</span></span><br><span class="line">	<span class="keyword">void</span> _M_put_node(_List_node&lt;_Tp&gt;* __p) &#123; _Alloc_type::deallocate(__p, <span class="number">1</span>); &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	_List_node&lt;_Tp&gt;* _M_node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于上面的配置和释放节点空间：allocate和deallocate函数参见前面博文： <a href="http://blog.csdn.net/wenqian1991/article/details/19566499" target="_blank" rel="noopener">第一级空间配置器</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span></span></span><br><span class="line"><span class="class">_<span class="title">List_base</span>&lt;_Tp, _Alloc&gt;:</span>:clear()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//_M_node 头节点，不带数据</span></span><br><span class="line">	_List_node&lt;_Tp&gt;* __cur = (_List_node&lt;_Tp&gt;*) _M_node-&gt;_M_next;<span class="comment">//指向链表中的第一个数据</span></span><br><span class="line">	<span class="comment">//环状链表，逐个清除数据和释放节点空间</span></span><br><span class="line">	<span class="keyword">while</span> (__cur != _M_node) &#123;</span><br><span class="line">		_List_node&lt;_Tp&gt;* __tmp = __cur;<span class="comment">//保存当前节点</span></span><br><span class="line">		__cur = (_List_node&lt;_Tp&gt;*) __cur-&gt;_M_next;<span class="comment">//指向下一个数据节点</span></span><br><span class="line">		_Destroy(&amp;__tmp-&gt;_M_data);<span class="comment">//清除数据，转调用该数据对应的析构函数</span></span><br><span class="line">		_M_put_node(__tmp);<span class="comment">//释放该节点空间</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	_M_node-&gt;_M_next = _M_node;</span><br><span class="line">	_M_node-&gt;_M_prev = _M_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的_Destrory函数参见博文： <a href="http://blog.csdn.net/wenqian1991/article/details/19545049" target="_blank" rel="noopener">构造与析构</a></p>
<p><strong>6、list的元素操作</strong></p>
<p>看看list数据结构中外部实现的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;_Tp, _Alloc&gt;:</span>:resize(size_type __new_size, <span class="keyword">const</span> _Tp&amp; __x)</span><br><span class="line">&#123;</span><br><span class="line">    iterator __i = begin();</span><br><span class="line">	size_type __len = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//计算原本链表实际大小</span></span><br><span class="line">	<span class="keyword">for</span> (; __i != end() &amp;&amp; __len &lt; __new_size; ++__i, ++__len)</span><br><span class="line">		;</span><br><span class="line">	<span class="comment">//大于重调整空间大小，多退</span></span><br><span class="line">	<span class="keyword">if</span> (__len == __new_size)</span><br><span class="line">		erase(__i, end());</span><br><span class="line">	<span class="comment">//少补，补差额个x</span></span><br><span class="line">	<span class="keyword">else</span>                          <span class="comment">// __i == end()</span></span><br><span class="line">		insert(end(), __new_size - __len, __x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除链表中所有值为value的元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;_Tp, _Alloc&gt;:</span>:remove(<span class="keyword">const</span> _Tp&amp; __value)</span><br><span class="line">&#123;</span><br><span class="line">	iterator __first = begin();</span><br><span class="line">	iterator __last = end();</span><br><span class="line">	<span class="keyword">while</span> (__first != __last) &#123;</span><br><span class="line">		iterator __next = __first;</span><br><span class="line">		++__next;</span><br><span class="line">		<span class="keyword">if</span> (*__first == __value) erase(__first);<span class="comment">//找到==value的就删除</span></span><br><span class="line">		__first = __next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//去掉链表中的重复元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;_Tp, _Alloc&gt;:</span>:unique()</span><br><span class="line">&#123;</span><br><span class="line">	iterator __first = begin();</span><br><span class="line">	iterator __last = end();</span><br><span class="line">	<span class="keyword">if</span> (__first == __last) <span class="keyword">return</span>;</span><br><span class="line">	iterator __next = __first;</span><br><span class="line">	<span class="comment">//下面这个程序有点意思，咋一看就一个while循环，以为时间复杂度为O(N)，</span></span><br><span class="line">	<span class="comment">//实际上最后还有个修正区段范围操作，时间复杂度为O(N!)</span></span><br><span class="line">	<span class="keyword">while</span> (++__next != __last) &#123;<span class="comment">//调用了++重载函数，遍历每个节点</span></span><br><span class="line">		<span class="keyword">if</span> (*__first == *__next)<span class="comment">//有相同元素就移除</span></span><br><span class="line">			erase(__next);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			__first = __next;<span class="comment">//调整指针</span></span><br><span class="line">		__next = __first;<span class="comment">//修正区段范围</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将list x有序地合并到原链表中，默认小于号，</span></span><br><span class="line"><span class="comment">//两个已经排序好的链表合成一个排序的链表，时间复杂度O(m)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;_Tp, _Alloc&gt;:</span>:merge(<span class="built_in">list</span>&lt;_Tp, _Alloc&gt;&amp; __x)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//原有链表</span></span><br><span class="line">	iterator __first1 = begin();</span><br><span class="line">	iterator __last1 = end();</span><br><span class="line">	<span class="comment">//新链表</span></span><br><span class="line">	iterator __first2 = __x.begin();</span><br><span class="line">	iterator __last2 = __x.end();</span><br><span class="line">	<span class="comment">//前提，这两个链表都已经排序好（递增）</span></span><br><span class="line">	<span class="comment">//所以这个函数的功能实际上就是将两个已经排序好的链表合成一个排序好的链表</span></span><br><span class="line">	<span class="keyword">while</span> (__first1 != __last1 &amp;&amp; __first2 != __last2)<span class="comment">//谁先终止</span></span><br><span class="line">	<span class="keyword">if</span> (*__first2 &lt; *__first1) &#123;</span><br><span class="line">		iterator __next = __first2;</span><br><span class="line">		transfer(__first1, __first2, ++__next);</span><br><span class="line">		__first2 = __next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		++__first1;</span><br><span class="line">	<span class="keyword">if</span> (__first2 != __last2) transfer(__last1, __first2, __last2);<span class="comment">//剩下的直接追加</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反转链表，其实双向链表反转没什么意思，有前指针</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __List_base_reverse(_List_node_base* __p)</span><br><span class="line">&#123;</span><br><span class="line">	_List_node_base* __tmp = __p;<span class="comment">//表头</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">//这里就是交换一下指针</span></span><br><span class="line">		__STD::swap(__tmp-&gt;_M_next, __tmp-&gt;_M_prev);<span class="comment">//tmp前后指针交换</span></span><br><span class="line">		__tmp = __tmp-&gt;_M_prev;     <span class="comment">// Old next node is now prev.</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (__tmp != __p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">list</span>&lt;_Tp, _Alloc&gt;:</span>:reverse()</span><br><span class="line">&#123;</span><br><span class="line">	__List_base_reverse(<span class="keyword">this</span>-&gt;_M_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>\</em>7、详解list::sort()**</strong></p>
<p>list中的sort函数比较拗口，不易理解，这里单独列出来，剖析一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//list不能使用STL中的sort算法，因为stl中的sort只接受random access iterator，也就是连续空间</span></span><br><span class="line"><span class="comment">//所以对于list 得有自己的sort</span></span><br><span class="line"><span class="comment">//分而治之</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;_Tp, _Alloc&gt;:</span>:sort()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Do nothing if the list has length 0 or 1.</span></span><br><span class="line">	<span class="keyword">if</span> (_M_node-&gt;_M_next != _M_node &amp;&amp; _M_node-&gt;_M_next-&gt;_M_next != _M_node) &#123;</span><br><span class="line">		<span class="comment">//中间数据存放区</span></span><br><span class="line">		<span class="built_in">list</span>&lt;_Tp, _Alloc&gt; __carry;</span><br><span class="line">		<span class="built_in">list</span>&lt;_Tp, _Alloc&gt; __counter[<span class="number">64</span>];<span class="comment">//大小为64的链表数组</span></span><br><span class="line">		<span class="keyword">int</span> __fill = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*排序部分，下面的排序部分主要是借助merge函数来实现的。</span></span><br><span class="line"><span class="comment">		先归并两个元素，然后归并后面两个，再将四个归并，依次进行8个、16个……排好序的元素，</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">while</span> (!empty()) &#123;</span><br><span class="line">            <span class="comment">//分割</span></span><br><span class="line">			__carry.splice(__carry.begin(), *<span class="keyword">this</span>, begin());<span class="comment">//调用splice（第二个），将begin()接合（移动）到carry.begin()之前</span></span><br><span class="line">                                                            <span class="comment">//它取代了carry.begin()，就是将list中第一个数据，移动存入carry</span></span><br><span class="line">			<span class="keyword">int</span> __i = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (__i &lt; __fill &amp;&amp; !__counter[__i].empty()) &#123;</span><br><span class="line">				<span class="comment">//合并，排好序的元素归并到counter中</span></span><br><span class="line">				__counter[__i].merge(__carry);<span class="comment">//将carry中的数据，合并到counter链中</span></span><br><span class="line">                                              <span class="comment">//排序两个已排序的链表，可以看出是归并算法。侯捷先生的解释是错的</span></span><br><span class="line">				__carry.swap(__counter[__i++]);<span class="comment">//排序好的链表部分数据划到carry中，i++</span></span><br><span class="line">			&#125;</span><br><span class="line">			__carry.swap(__counter[__i]);<span class="comment">//数据交换，此时carry中为空，数据到counter[i]中了（while中i++）</span></span><br><span class="line">			<span class="keyword">if</span> (__i == __fill) ++__fill;</span><br><span class="line">		&#125;</span><br><span class="line">      <span class="comment">//最后一轮合并</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> __i = <span class="number">1</span>; __i &lt; __fill; ++__i)</span><br><span class="line">			__counter[__i].merge(__counter[__i - <span class="number">1</span>]);</span><br><span class="line">		swap(__counter[__fill - <span class="number">1</span>]);<span class="comment">//*this.swap</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果实在不理解STL中的某些算法的细节是怎么运作的，你就把该算法源码copy一份，修改下个别参数类型，直接并入你的测试代码中，自己单步运行，看看中间数据结果，就一目了然了。这不失为一个好的理解源码的方式。<br>那么上面这个排序的时间复杂度如何呢？ <a href="http://blog.csdn.net/wenqian1991/article/details/20737201" target="_blank" rel="noopener">归并算法</a>的时间复杂度为O(NlogN)。上面这个排序的时间复杂度也是O(NlogN)。</p>
<p>最后面补充一下STL中的list成员函数及其相应功能，如果只是单纯的使用STL来加快开发速度，下面这个表格够用了，但熟悉内部原理总是好的，知己知彼。借用西方的的一句话：不要重复造轮子。已经有这么优秀的list了，（<a href="http://blog.csdn.net/wenqian1991/article/details/44515713" target="_blank" rel="noopener">Linux内核中的list</a>，本人认为更精妙）。就直接拿来用吧，或者适当修改以满足自己的实际开发需求。</p>
<p><img src="/2020/12/27/STLlist%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/20150321140643595" alt="img"></p>
<p><img src="/2020/12/27/STLlist%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/20150321140648010" alt="img"></p>
<p><img src="/2020/12/27/STLlist%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/20150321140621241" alt="img"></p>
<p><img src="/2020/12/27/STLlist%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/20150321140626139" alt="img"></p>
<p><img src="/2020/12/27/STLlist%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/20150321140630008" alt="img"></p>
<p><img src="/2020/12/27/STLlist%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/20150321140633455" alt="img"></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0/" rel="tag"># C++进阶学习</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/27/STLvector%20%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/" rel="prev" title="STLvector内部机制">
      <i class="fa fa-chevron-left"></i> STLvector内部机制
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/27/STLhashtable%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89/" rel="next" title="STL哈希表">
      STL哈希表 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">匡俊桦</p>
  <div class="site-description" itemprop="description">回忆的沙漏将曾经屈指可数的日子渐渐淡去</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">276</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">匡俊桦</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">2.3m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">35:09</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
