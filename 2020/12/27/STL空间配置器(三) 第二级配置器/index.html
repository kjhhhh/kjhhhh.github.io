<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="考虑到小型区块所可能造成的内存破碎问题，SGI 设计了双层级配置器，这里则学习第二级配置器，第二级配置器的设计思想为：  如果配置区块超过128 bytes，则移交给第一级配置器处理； 如果配置区块小于128 bytes，则采用内存池管理（memory pool）。每次配置一大块内存，则维护对应的自由链表（free-list），下次若再有相同大小的内存需求，就直接从 free-list 中拨出（没">
<meta property="og:type" content="article">
<meta property="og:title" content="STL第二级配置器">
<meta property="og:url" content="http://yoursite.com/2020/12/27/STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8(%E4%B8%89)%20%E7%AC%AC%E4%BA%8C%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8/index.html">
<meta property="og:site_name" content="KJHの博客">
<meta property="og:description" content="考虑到小型区块所可能造成的内存破碎问题，SGI 设计了双层级配置器，这里则学习第二级配置器，第二级配置器的设计思想为：  如果配置区块超过128 bytes，则移交给第一级配置器处理； 如果配置区块小于128 bytes，则采用内存池管理（memory pool）。每次配置一大块内存，则维护对应的自由链表（free-list），下次若再有相同大小的内存需求，就直接从 free-list 中拨出（没">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/12/27/STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8(%E4%B8%89)%20%E7%AC%AC%E4%BA%8C%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8/20140221155259531">
<meta property="og:image" content="http://yoursite.com/2020/12/27/STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8(%E4%B8%89)%20%E7%AC%AC%E4%BA%8C%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8/20140221191442375">
<meta property="og:image" content="http://yoursite.com/2020/12/27/STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8(%E4%B8%89)%20%E7%AC%AC%E4%BA%8C%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8/20140221201652625">
<meta property="article:published_time" content="2020-12-27T07:32:21.509Z">
<meta property="article:modified_time" content="2021-03-04T07:20:44.522Z">
<meta property="article:author" content="匡俊桦">
<meta property="article:tag" content="C++进阶学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/12/27/STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8(%E4%B8%89)%20%E7%AC%AC%E4%BA%8C%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8/20140221155259531">

<link rel="canonical" href="http://yoursite.com/2020/12/27/STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8(%E4%B8%89)%20%E7%AC%AC%E4%BA%8C%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>STL第二级配置器 | KJHの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>


<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KJHの博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录&回忆</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8(%E4%B8%89)%20%E7%AC%AC%E4%BA%8C%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          STL第二级配置器
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-27 15:32:21" itemprop="dateCreated datePublished" datetime="2020-12-27T15:32:21+08:00">2020-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-04 15:20:44" itemprop="dateModified" datetime="2021-03-04T15:20:44+08:00">2021-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>考虑到小型区块所可能造成的内存破碎问题，SGI 设计了双层级配置器，这里则学习第二级配置器，第二级配置器的设计思想为：</p>
<ol>
<li>如果配置区块超过128 bytes，则移交给第一级配置器处理；</li>
<li>如果配置区块小于128 bytes，则采用内存池管理（memory pool）。每次配置一大块内存，则维护对应的自由链表（free-list），下次若再有相同大小的内存需求，就直接从 free-list 中拨出（没有就继续配置内存，具体后面讲述），如果客端释换小额区块，就有配置器回收到 free-list 中。</li>
</ol>
<p>需要说明的是：本系列引用的STL源码版本为 v3.3，对比版本 v2.03 风格上有了些许变化，但设计思想还是不变的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* part of stl source code v3.3 */</span></span><br><span class="line"><span class="keyword">enum</span> &#123; _ALIGN = <span class="number">8</span> &#125;;                <span class="comment">//小型区块的上调边界</span></span><br><span class="line"><span class="keyword">enum</span> &#123; _MAX_BYTES = <span class="number">128</span> &#125;;          <span class="comment">//小型区块的上限</span></span><br><span class="line"><span class="keyword">enum</span> &#123; _NFREELISTS = <span class="number">16</span> &#125;; <span class="comment">// _MAX_BYTES/_ALIGN   //free-list 编号数</span></span><br><span class="line"><span class="comment">//配置内存后，维护对应内存块的空闲链表节点结构</span></span><br><span class="line"><span class="keyword">union</span> _Obj &#123;</span><br><span class="line">	<span class="keyword">union</span> _Obj* _M_free_list_link;   <span class="comment">//空闲链表</span></span><br><span class="line">	<span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this. 用户使用的*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>考虑内存对其等因素，SGI 第二级配置器会主动将任何小额区块的内存需求量上调至 8 的倍数。并维护 16 个 free-list，各自管理大小分别为 8，16，24，32，40，48，56，64，72，80，88，96，104，112，120，128 bytes 的小额区块。</p>
<p>union _Obj 中的 <em>M</em>client_data 是C/C++中常见的变长数组实现方式（如果编译器支持 0 长度的数组，还可以声明为 <em>M</em>client_data[0] 达到更节省的目的），所以 union _Obj 的大小就是一个指针大小（<em>M</em>free_list_link 指针的大小）。union 实现一物二用，这个free-list 有两个作用：一个是指向下一块空白内存（当存在于 free-list 中时），一个就是供用户使用的一块内存（不存在于 free-list）。</p>
<p>回顾第二级配置器的设计思想的第 2 点，内存空间的分配大致是这样的：<strong><em>\</em>配置器分配空间时，先从 free-list 中拨出，如果有，就直接拨出，该需求大小的区块位于 free-list 对应编号的第一位置，然后从该链表中拨出，这样该区块就不位于 free-list 中对应编号内，第一位置向后移动指向，仅此一区块(刚已经拨出去)，则指向 0 ，表示 free-list 中没有该大小的区块；如果没有则需要向 free-list 填补区块，继而转向内存块分配函数，然后分配所需大小的新区块(一次性缺省分配20个，不够就分配小于20的，至少一个)，分配成功后，第一个区块直接划给客端，然后后面的（如果有）就填进 free-list，这样下次再有相同大小的内存需求时，可直接从 free-list 中拨出，如果一个区块都分配不出，就转向调用第一级配置器里的内存分配异常处理例程。 配置器还可以回收释放的内存，释还的小额内存区块划进 free-list 中（其实是关联到 free-list 对应编号区域）。<br>**</strong></p>
<p>SGI 缺省的 free-list 中都是0值，也就是说该链表中没有可用的小额区块，因为不可能 SGI STL 一开始就自动的给你分配出来（它知道你要多少呀）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*源码看上去相当绕口，这里精简下*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_Obj* <span class="keyword">volatile</span></span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt; ::_S_free_list[_NFREELISTS] = </span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#125;;         <span class="comment">//一一对应大小为 8,16 ... 128 bytes 大小的区块</span></span><br></pre></td></tr></table></figure>

<p>最开始只要需求小额区块内存，就会转到内存块分配函数。这样一来，相当于 free-list 是用来分配内存的，底层分配内存时，一次性分配一定数量的该额度区块（实际上是一次性分配大块内存，然后“分割”成小块），这样下次需求的时候直接从 free-list 中获取，而不用频繁的分配小额内存块，减少了内存碎片的产生，也提高了效率。</p>
<p>下面我们跟踪源码，来看看其内部是如何来实现这种机制的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将 __bytes 上调至最邻近的 8 的倍数*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">_S_round_up(<span class="keyword">size_t</span> __bytes)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (((__bytes)+(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) &amp; ~((<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*返回 __bytes 大小的小额区块位于 free-list 中的编号*/</span></span><br><span class="line"><span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) &#123;</span><br><span class="line">	<span class="keyword">return</span> (((__bytes)+(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) / (<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看 allocate()，然后穿针引线。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span>   <span class="comment">//分配大小为 __n 的区块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span>* __ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>)_MAX_BYTES) &#123;</span><br><span class="line">		__ret = malloc_alloc::allocate(__n);    <span class="comment">//大于128 bytes 就调用第一级配置器</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="comment">//__n 大小区块对应的位置：free-lists 首地址 + __n 位于free-lists 中的编号</span></span><br><span class="line">		_Obj* __STL_VOLATILE* __my_free_list    <span class="comment">//这里是二级指针，便于调整 free-lists </span></span><br><span class="line">			= _S_free_list + _S_freelist_index(__n);  		</span><br><span class="line"><span class="meta">#     <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">		_Lock __lock_instance;</span><br><span class="line"><span class="meta">#     <span class="meta-keyword">endif</span></span></span><br><span class="line">		_Obj* __RESTRICT __result = *__my_free_list; <span class="comment">//将对应位置的区块拨出(第一个)</span></span><br><span class="line">		<span class="keyword">if</span> (__result == <span class="number">0</span>)                       <span class="comment">//如果 free-lists 中没有对应大小的区块</span></span><br><span class="line">			__ret = _S_refill(_S_round_up(__n)); <span class="comment">//调用 _S_refill()</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			*__my_free_list = __result-&gt;_M_free_list_link;<span class="comment">//这个结构有点类似链式哈希表结构，这里是指向下一块空闲内存块  </span></span><br><span class="line">			<span class="comment">//二级指针调整 free-lists，拨出去的区块就不属于该链表了</span></span><br><span class="line">			__ret = __result;                               </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> __ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>区块自 free-list 拨出的操作（下面这个数据结构类似于链式哈希表），如下图所示（图片源自《STL源码剖析》）<br><img src="/2020/12/27/STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8(%E4%B8%89)%20%E7%AC%AC%E4%BA%8C%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8/20140221155259531" alt="img"></p>
<p>如果 free-list 中没有对应大小的区块，就转去调用 <em>S</em>refill()。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>*           <span class="comment">//重新填充__n大小的区块进 free-list</span></span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_refill(<span class="keyword">size_t</span> __n)  </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> __nobjs = <span class="number">20</span>;      <span class="comment">//缺省取得 20 个新区块</span></span><br><span class="line">	<span class="keyword">char</span>* __chunk = _S_chunk_alloc(__n, __nobjs);  <span class="comment">//调用_S_chunk_alloc()</span></span><br><span class="line">	_Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">	_Obj* __result;</span><br><span class="line">	_Obj* __current_obj;</span><br><span class="line">	_Obj* __next_obj;</span><br><span class="line">	<span class="keyword">int</span> __i;</span><br><span class="line">	<span class="comment">/*如果只获得一个新区块，直接划给用户，free-list 仍然无新节点*/</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == __nobjs) <span class="keyword">return</span>(__chunk);  </span><br><span class="line">	__my_free_list = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">	__result = (_Obj*)__chunk;   <span class="comment">//这一块返回给客端(分配出来的第一块)</span></span><br><span class="line">	*__my_free_list = __next_obj = (_Obj*)(__chunk + __n); </span><br><span class="line">	<span class="comment">/*接下来的区块(拨出去了__n大小给用户)填补进 free-list*/</span></span><br><span class="line">	<span class="keyword">for</span> (__i = <span class="number">1</span>;; __i++) &#123;</span><br><span class="line">		__current_obj = __next_obj; </span><br><span class="line">		__next_obj = (_Obj*)((<span class="keyword">char</span>*)__next_obj + __n); </span><br><span class="line">		<span class="comment">/*将分配的连续大块"分割"成__n bytes大小的区块*/</span></span><br><span class="line">		<span class="keyword">if</span> (__nobjs - <span class="number">1</span> == __i) &#123;  <span class="comment">//如果新区块填补完毕</span></span><br><span class="line">			__current_obj-&gt;_M_free_list_link = <span class="number">0</span>;  <span class="comment">//free-list 最后位置指向0</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="comment">//把_M_free_list_link当做链表的 next 指针理解</span></span><br><span class="line">			__current_obj-&gt;_M_free_list_link = __next_obj; <span class="comment">//将各节点串联起来填进空闲链表</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(__result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样将把第一块返回给客端的剩余 “大块”内存 “分割” 成指定大小的区块，并填进 free-list 中。新的区块取自内存池，由 <em>S</em>chunk_alloc() 完成。</p>
<p>这个函数的具体实现思想为：</p>
<p>1、内存池剩余空间完全满足 20 个区块的需求量，则直接取出对应大小的空间；<br>2、内存池剩余空间不能完全满足 20 个区块的需求量，但可以提供一个及以上的区块，<br>  则取出能够满足需求区块的最大个数的空间；<br>3、内存池剩余空间不能满足一个需求区块的大小，则进行以下处理：<br>    \1. 首先判池中是否存在残余零头的内存空间，如果有则进行回收，将其划入 free-list 中的适当位置；<br>    \2. 然后向 system heap 申请空间，补充内存池。<br>     2.1 若 heap 空间充足，则空间分配成功；<br>     2.2 若 heap 空间不足，出现 malloc() 调用失败。<br>      则搜寻适当的 free-list （适当是指 “尚有未有区块，且区块较大” 的 free-list ），<br>      即搜寻 free-list 大于等于需求块的区块，将其编入内存池，然后递归调用 <em>S</em>chunk_alloc()<br>      函数从内存池中取空间重复上述过程。如果很不幸，free-list 中没有合适的内存空间可用了，<br>      这时候则调用第一级配置器，利用 out-of-memory 机制尝试解决内存不足问题，<br>      结果要么内存不足的情况获得改善，要么抛出 bad_alloc 异常。 </p>
<p>接下来直接看源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_start_free;   <span class="comment">//内存池起始位置</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_end_free;     <span class="comment">//内存池末端位置</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;   <span class="comment">//堆空间容量</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>*__default_alloc_template&lt;__threads, __inst&gt;::_S_chunk_alloc(<span class="keyword">size_t</span> __size,</span><br><span class="line"><span class="keyword">int</span>&amp; __nobjs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span>* __result;</span><br><span class="line">	<span class="keyword">size_t</span> __total_bytes = __size * __nobjs;       <span class="comment">//需要内存的总额大小</span></span><br><span class="line">	<span class="keyword">size_t</span> __bytes_left = _S_end_free - _S_start_free;  <span class="comment">//内存池中还剩余多少可用内存</span></span><br><span class="line">	<span class="keyword">if</span> (__bytes_left &gt;= __total_bytes) &#123;    <span class="comment">//剩余可用量大于需求量，直接划分出去</span></span><br><span class="line">		__result = _S_start_free;           <span class="comment">//内存池的首地址</span></span><br><span class="line">        _S_start_free += __total_bytes;     <span class="comment">//调整内存池位置							return(__result);  </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//内存池剩余空间不能完全满足需求，但至少可供应一个及以上的区块</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (__bytes_left &gt;= __size) &#123;      </span><br><span class="line">		__nobjs = (<span class="keyword">int</span>)(__bytes_left / __size);  <span class="comment">//调整划分个数，划分出去最大量</span></span><br><span class="line">		__total_bytes = __size * __nobjs;        <span class="comment">//同上</span></span><br><span class="line">		__result = _S_start_free;</span><br><span class="line">		_S_start_free += __total_bytes;</span><br><span class="line">		<span class="keyword">return</span>(__result);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;    <span class="comment">//内存池剩余空间连一个区块都无法提供</span></span><br><span class="line">		<span class="keyword">size_t</span> __bytes_to_get =<span class="comment">//配置大小为总需求量的两倍再加上一个随配置次数逐渐增加的附加量</span></span><br><span class="line">			<span class="number">2</span> * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="number">4</span>); /</span><br><span class="line">		<span class="keyword">if</span> (__bytes_left &gt; <span class="number">0</span>) &#123;   <span class="comment">//充分利用内存池中的剩余空间</span></span><br><span class="line">			_Obj* __STL_VOLATILE* __my_free_list =   <span class="comment">//剩余空间寻找适当的free-list</span></span><br><span class="line">				_S_free_list + _S_freelist_index(__bytes_left);   </span><br><span class="line">         <span class="comment">//调整 free-list，将内存池中残余空间编入 free-list 对应位置中</span></span><br><span class="line">			((_Obj*)_S_start_free)-&gt;_M_free_list_link = *__my_free_list;</span><br><span class="line">			*__my_free_list = (_Obj*)_S_start_free;</span><br><span class="line">		&#125;</span><br><span class="line">		_S_start_free = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(__bytes_to_get);  <span class="comment">//配置heap空间，用来补充内存池</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == _S_start_free) &#123;         <span class="comment">//system heap 空间不足，分配失败</span></span><br><span class="line">			<span class="keyword">size_t</span> __i;</span><br><span class="line">			_Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">			_Obj* __p;</span><br><span class="line">			<span class="keyword">for</span> (__i = __size;                 <span class="comment">//起始大小为需求区块大小</span></span><br><span class="line">				__i &lt;= (<span class="keyword">size_t</span>)_MAX_BYTES;      </span><br><span class="line">				__i += (<span class="keyword">size_t</span>)_ALIGN) &#123;       <span class="comment">//以 8 为步长搜寻整个 free-list</span></span><br><span class="line">				__my_free_list = _S_free_list + _S_freelist_index(__i);  <span class="comment">//找到 __i大小区块在free-list 中的位置</span></span><br><span class="line">				__p = *__my_free_list;</span><br><span class="line">				<span class="keyword">if</span> (<span class="number">0</span> != __p) &#123;               <span class="comment">//如果 free-list 中该区块未使用</span></span><br><span class="line">					*__my_free_list = __p-&gt;_M_free_list_link;   <span class="comment">//调整 free-list，释放第一位置块</span></span><br><span class="line">					_S_start_free = (<span class="keyword">char</span>*)__p;              <span class="comment">//编入内存池</span></span><br><span class="line">					_S_end_free = _S_start_free + __i;       </span><br><span class="line">					<span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));    <span class="comment">//递归调用</span></span><br><span class="line">        <span class="comment">/*该for循环的作用就是从 free-list 中划出大于需求区块(单个）的未用空间区块到内存池，然后再从内存池中取出。</span></span><br><span class="line"><span class="comment">		由于从大于__size 的区块开始搜寻，所以如果 free-list 中搜寻到，那么只需动用该搜寻区块的第一位置区块即可，</span></span><br><span class="line"><span class="comment">		最后取出的空间也可能是单个区块，也可能是多个区块(取决于 free-list 未用区块的最小区块(大于__size)的大小)*/</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			_S_end_free = <span class="number">0</span>;	<span class="comment">//表示到处无内存可用，for循环中free-list没有搜寻到适当的未用空间</span></span><br><span class="line">			_S_start_free = (<span class="keyword">char</span>*)malloc_alloc::allocate(__bytes_to_get); <span class="comment">//调用第一级配置器</span></span><br><span class="line">			<span class="comment">/*要么内存不足的问题获得改善，要么抛出 bad_alloc 异常*/</span></span><br><span class="line">		&#125;</span><br><span class="line">		_S_heap_size += __bytes_to_get;   <span class="comment">//调用第一级配置器后，内存不足问题获得改善，调整堆空间</span></span><br><span class="line">		_S_end_free = _S_start_free + __bytes_to_get;    <span class="comment">//编入内存池</span></span><br><span class="line">		<span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));   <span class="comment">//重新调用 _S_chunk_alloc()</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里补充一下内存池的概念：内存池是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存。这样，内存池允许在运行期以常数时间规划内存块，并且尽量避免了内存破碎的情况产生，使得内存分配的效率得到提升。<br>内存池实际操练结果如下图：</p>
<p><img src="/2020/12/27/STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8(%E4%B8%89)%20%E7%AC%AC%E4%BA%8C%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8/20140221191442375" alt="img"></p>
<p>如上图，加入程序一开始，客端就调用 <em>S</em>chunk_alloc(32, 20)，于是 malloc() 配置 40 个 32 bytes 区块，其中第 1 个返回给客端，另 19 个交给 <em>S</em>free_list [3] 维护，余 20 个留给内存池。接下来客端调用 <em>S</em>chunk_alloc(64, 20)，此时 <em>S</em>free_list [7] 是空的，必须向内存池要求空间，内存池只够供应 (32 * 20) / 64 = 10 个 64 bytes 区块，就把这 10 个区块返回，第 1 个交给客端，余 9 个由 <em>S</em>free_list [7] 维护，此时内存池全空，接下来再调用 <em>S</em>chunk_alloc(96, 20)，此时 <em>S</em>free_list [11] 空空如也，必须向内存池要求支持，而内存池此时也是空的，于是以 malloc() 配置 40 + n（附加量）个 96 bytes 区块，其中第 1 个交出，另 19 个交给 <em>S</em>free_list [11] 维护，余 20 + n 个区块留给内存池……</p>
<p>如果到最后，整个 system heap 空间都不够了，malloc() 分配失败，<em>S</em>chunk_alloc() 就四处寻找有无 “尚有未用区块，且足够大” 的 free-list。找到了就挖一块交出，找不到就调用第一级配置器，第一级其实也是调用 malloc() 来配置内存，但它有 out-of-memory 处理机制，或许有机会释放其它的内存拿来此处使用。如果可以，就成功，否则发出 bad_alloc 异常。 </p>
<p>配置器自然也有释放空间的能力，这里再学习空间释放函数 deallocate()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*空间释放后被编入 free-list*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>)_MAX_BYTES)  <span class="comment">//大于 128 就调用第一级配置器</span></span><br><span class="line">		malloc_alloc::deallocate(__p, __n);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		_Obj* __STL_VOLATILE*  __my_free_list  <span class="comment">//定位到对应的 free-list</span></span><br><span class="line">			= _S_free_list + _S_freelist_index(__n);</span><br><span class="line">		_Obj* __q = (_Obj*)__p;       </span><br><span class="line"><span class="meta">#       <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">		_Lock __lock_instance;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">endif</span> </span></span><br><span class="line">		__q-&gt;_M_free_list_link = *__my_free_list;  <span class="comment">//调整 free-list 回收区块</span></span><br><span class="line">		*__my_free_list = __q;        <span class="comment">//回收的区块是挂接到free-list 对应区块的第一位置，而不是添加到尾端</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区块回收纳入 free-list 的操作（序号对应顺序），如下图所示</p>
<p><img src="/2020/12/27/STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8(%E4%B8%89)%20%E7%AC%AC%E4%BA%8C%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8/20140221201652625" alt="img"></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0/" rel="tag"># C++进阶学习</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/27/STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8(%E4%BA%8C)%20%E7%AC%AC%E4%B8%80%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8/" rel="prev" title="STL第一级配置器">
      <i class="fa fa-chevron-left"></i> STL第一级配置器
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/27/STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8(%E5%9B%9B)%20%E5%86%85%E5%AD%98%E5%9F%BA%E6%9C%AC%E5%A4%84%E7%90%86/" rel="next" title="STL内存基本处理">
      STL内存基本处理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">匡俊桦</p>
  <div class="site-description" itemprop="description">回忆的沙漏将曾经屈指可数的日子渐渐淡去</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">202</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">匡俊桦</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">22:23</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
