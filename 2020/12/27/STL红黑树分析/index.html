<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="红黑树概述 历史上 AVL 树流行的另一变种是红黑树（red-black tree）。对红黑树的操作能保证在最坏情况下动态几何操作的时间为 O(logN) 。之前介绍过AVL 树，该树都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。但 RB-Tree 出来之后，便很少有应用场合用到 AVL 。 这里在探索STL源码时学习红黑树的，由于STL中的关联式容器默认的底">
<meta property="og:type" content="article">
<meta property="og:title" content="STL红黑树">
<meta property="og:url" content="http://yoursite.com/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="KJHの博客">
<meta property="og:description" content="红黑树概述 历史上 AVL 树流行的另一变种是红黑树（red-black tree）。对红黑树的操作能保证在最坏情况下动态几何操作的时间为 O(logN) 。之前介绍过AVL 树，该树都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。但 RB-Tree 出来之后，便很少有应用场合用到 AVL 。 这里在探索STL源码时学习红黑树的，由于STL中的关联式容器默认的底">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/20140529155704640">
<meta property="og:image" content="http://yoursite.com/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/20140529165422375">
<meta property="og:image" content="http://yoursite.com/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/20140529221039281">
<meta property="og:image" content="http://yoursite.com/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/20140529215000765">
<meta property="og:image" content="http://yoursite.com/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/20140529215801078">
<meta property="og:image" content="http://yoursite.com/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/20140530145159171">
<meta property="og:image" content="http://yoursite.com/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/20140530145633828">
<meta property="og:image" content="http://yoursite.com/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/20140530145757640">
<meta property="og:image" content="http://yoursite.com/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/20140530150458796">
<meta property="og:image" content="http://yoursite.com/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/20140530150535671">
<meta property="og:image" content="http://yoursite.com/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/20140531194219343">
<meta property="article:published_time" content="2020-12-27T07:34:34.648Z">
<meta property="article:modified_time" content="2021-03-03T15:07:22.219Z">
<meta property="article:author" content="匡俊桦">
<meta property="article:tag" content="C++进阶学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/20140529155704640">

<link rel="canonical" href="http://yoursite.com/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>STL红黑树 | KJHの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KJHの博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录&回忆</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          STL红黑树
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-27 15:34:34" itemprop="dateCreated datePublished" datetime="2020-12-27T15:34:34+08:00">2020-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-03 23:07:22" itemprop="dateModified" datetime="2021-03-03T23:07:22+08:00">2021-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>红黑树概述</p>
<p>历史上 AVL 树流行的另一变种是红黑树（red-black tree）。对红黑树的操作能保证在最坏情况下动态几何操作的时间为 O(logN) 。之前介绍过<a href="http://blog.csdn.net/wenqian1991/article/details/21889147" target="_blank" rel="noopener">AVL 树</a>，该树都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。但 RB-Tree 出来之后，便很少有应用场合用到 AVL 。</p>
<p>这里在探索STL源码时学习红黑树的，由于STL中的关联式容器默认的底层实现都是红黑树，以及 Linux 内核中包括进程队列等结构也是基于红黑树的。所以有必要掌握红黑树的实现原理和源码实现。</p>
<p>红黑树是二叉查找树，但在每个节点上增加了一位存储位表示该节点的颜色，具体可以是 RED 或 BLACK。通过对任一条从根到叶子的路径上各节点着色方式的限制，红黑树确保了没有一条路径会比其他路径长到两倍，因而基本上是平衡的。它所追求的的是局部平衡而不是AVL树中的非常严格的平衡。</p>
<p>红黑树在二叉查找树的基础上还必须满足以下着色规则：</p>
<ol>
<li>每个节点不是红色就是黑色</li>
<li>根节点为黑色</li>
<li>如果节点为红，其子节点必须为黑（一条路径上不能出现连续的两个红色节点）</li>
<li>任一节点至NULL（树尾端）的任何路径，所含之黑节点数必须相同</li>
</ol>
<p>根据规则4，新增节点必须为红；根据规则3，新增节点之父点必须为黑。当新节点根据二叉查找树的规则（键值大小）到达其插入点，却未能符合上述条件，就必须调整颜色并旋转树形。AVL 树插入节点后如果不满足其平衡条件，需要旋转树形。红黑树并不是基于 AVL 树的，它是在二叉查找树的基础上。</p>
<p>那么红黑树的基本平衡又是如何保证的呢？红黑树的着色法则，根据上面的规则，一条路径上不能出现连续的两个红色节点，必须有黑色节点间隔开来，然后红黑树的每条路径中所含黑色节点的数目必须相同，这样就限制每条路径之间的高度差，从而达到接近平衡的目的。</p>
<p><strong><em>\</em>插入节点**</strong></p>
<p>同 AVL 树，红黑树的插入也要考虑以下几种情况，然后兼顾上面的着色法则。所有待插入节点初始着色为红色，最后将根节点重新设置为黑色。</p>
<p>1、空树</p>
<p>这是最简单的一种形式，直接添加，着色为黑色（规则2）</p>
<p>2、仅存在根节点（黑色），或待插入节点 X 的父节点 P 为黑色</p>
<p>直接添加即可，无需任何旋转和调整颜色。这种情况下，直接添加满足所有的着色法则，不用理会其叔节点的特征。</p>
<p>3、待插入节点 X 的父节点 P 为红色，且<strong>该父节点 P 为X 祖父节点G 的左儿子</strong></p>
<p>这种情况下，又分为几种情况：</p>
<p> 3.1、X 的叔节点 S 为红色，（X 的叔节点就是 X 的祖父节点的右儿子）</p>
<p>此时存在红- 红的情况，父子节点同时为红色，不满足着色法则3，需要作出调整。</p>
<p>调整策略就是：将X 节点的父节点和叔节点着黑色，将其祖父节点着红色，这样该局部满足着色法则，但是尚不清楚其曾祖父GG节点的颜色，如果GG为红色，由于G也为红色，这样就不满足着色法则3，仍需要调整；如果GG为黑色就不需要调整了，这里的调整策略便是向上迭代调整，就是向上更换当前位置（将原当前位置X，设置为X的祖父节点G），再进行同等判断调整。如下图：</p>
<p><img src="/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/20140529155704640" alt="img"></p>
<p> 3.2、X 的叔节点 S 为黑色（NULL认为是黑色节点）</p>
<p>红黑树还有个规则就是NULL节点一律看作是黑节点，如某节点K 的右儿子不存在，即该右儿子看作是黑色节点，这个不影响着色法则。</p>
<p>叔节点S 为黑，这样就需要通过旋转和改变颜色来调整了，通过之前的 <a href="https://blog.csdn.net/wenqian1991/article/details/blog.csdn.net/wenqian1991/article/details/21889147" target="_blank" rel="noopener">AVL 树</a>，我们知道外侧插入和内侧插入的旋转不一样，外侧插入（这里的左左）只需单旋转，而内侧插入（左右）则需要双旋转。</p>
<p>  3.2.1、先看看外侧插入，即待插入节点X 为其父节点的左儿子</p>
<p>这种情况下，需要进行单旋转然后调整颜色。关于外侧插入的旋转已经在AVL树中介绍，这里是相似的，不再赘述。实现细节看图便知</p>
<p><img src="/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/20140529165422375" alt="img"></p>
<p>调整前后局部根节点还是黑色，也就是这种情况下只需要局部调整颜色然后单旋转即可，不需要向上迭代</p>
<p>  3.2.2、内侧插入，即待插入节点X 为其父节点的右儿子</p>
<p>该情况下，需要先进行左旋转，然后调整颜色，然后再次进行右旋转即可，前后局部根节点依旧为黑色节点，同样不需要考虑上一层的红-红问题，实现细节如下图：</p>
<p><img src="/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/20140529221039281" alt="img"></p>
<p>上述第3点考虑的是待插入节点的父节点 P 为X 祖父节点G 的左儿子的情况，其作为右儿子也是类似的操作，差别在于旋转的先后顺序上，同AVL树的旋转调整。这里也顺便贴出来，见第4点</p>
<p>4、待插入节点 X 的父节点 P 为红色，且<strong>该父节点 P 为X 祖父节点G 的右儿子</strong></p>
<p>同样分为以下几种情况，由于与第3点是对称性结构，这里就简单的贴图说明：</p>
<p> 4.1、X 的叔节点 S 为红色，（X 的叔节点就是 X 的祖父节点的左儿子）</p>
<p>具体说明参见3.1。同样需要解决红-红（父子节点同时为红色）的问题，调整位置向上迭代判断调整</p>
<p><img src="/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/20140529215000765" alt="img"></p>
<p> 4.2、X 的叔节点 S 为黑色（NULL认为是黑色节点）</p>
<p>也是需要考虑外侧插入和内侧插入的情况</p>
<p>  4.2.1、外侧插入，即待插入节点X 为其父节点的右儿子</p>
<p><img src="/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/20140529215801078" alt="img"></p>
<p>   4.2.2、内侧插入，即待插入节点X 为其父节点的左儿子</p>
<p><img src="/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/20140530145159171" alt="img"></p>
<p>以上便是红黑树插入节点的所有情况。</p>
<p>下面我们通过STL的源码来剖析上述过程：</p>
<p>先看看两个关键函数：<strong><em>\</em>左旋转和右旋转**</strong></p>
<p>左旋转<strong>*\</strong>*：**<br>****</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*左旋转*/</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__rb_tree_rotate_left(__rb_tree_node_base* x, __r_node_base*&amp; root)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//X为旋转点</span></span><br><span class="line">	__rb_tree_node_base* y = x-&gt;right;<span class="comment">//令Y为旋转点的右子节点</span></span><br><span class="line"></span><br><span class="line">	x-&gt;right = y-&gt;left;<span class="comment">//X的右子节点指向Y的左子节点</span></span><br><span class="line">	<span class="keyword">if</span> (y-&gt;left != <span class="number">0</span>)</span><br><span class="line">		y-&gt;left-&gt;parent = x;<span class="comment">//如果Y有左儿子，则其左儿子的父节点设置为X</span></span><br><span class="line">	y-&gt;parent = x-&gt;parent;<span class="comment">//Y的父节点设为X的父节点</span></span><br><span class="line">	<span class="keyword">if</span> (x == root)</span><br><span class="line">		root = y;<span class="comment">//如果X为根节点，则将Y设为根节点</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;left)</span><br><span class="line">		x-&gt;parent-&gt;left = y;<span class="comment">//如果X为其父节点的左儿子，则将X的父节点的左儿子设为Y</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		x-&gt;parent-&gt;right = y;<span class="comment">//如果X为右儿子，则将其父节点的右儿子设为Y</span></span><br><span class="line">	y-&gt;left = x;<span class="comment">//Y的左儿子设为X</span></span><br><span class="line">	x-&gt;parent = y;<span class="comment">//X的父节点设为Y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其旋转过程参见下图：</p>
<p><img src="/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/20140530145633828" alt="img">   &amp;  <img src="/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/20140530145757640" alt="img"></p>
<p>右旋转：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*右旋转，必须将所有父子关系转接过来*/</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__rb_tree_rotate_right(__rb_tree_node_base* x, __rb_tree_node_base*&amp; root)</span><br><span class="line">&#123;  </span><br><span class="line">	<span class="comment">//X为旋转点</span></span><br><span class="line">	__rb_tree_node_base* y = x-&gt;left;<span class="comment">//令Y为旋转点的左子节点</span></span><br><span class="line">	x-&gt;left = y-&gt;right;<span class="comment">//X的右子节点指向Y的右子节点</span></span><br><span class="line">	<span class="keyword">if</span> (y-&gt;right != <span class="number">0</span>)</span><br><span class="line">		y-&gt;right-&gt;parent = x;<span class="comment">//如果Y有右儿子，则其右儿子的父节点设置为X</span></span><br><span class="line">	y-&gt;parent = x-&gt;parent;<span class="comment">//Y的父节点设为X的父节点</span></span><br><span class="line">	<span class="comment">/*将Y完全替代X的地位，将X的所有父子关系转接过来*/</span></span><br><span class="line">	<span class="keyword">if</span> (x == root)</span><br><span class="line">		root = y;<span class="comment">//如果X为根节点，则将Y设为根节点</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;right)</span><br><span class="line">		x-&gt;parent-&gt;right = y;<span class="comment">//如果X为其父节点的右儿子，则将X的父节点的右儿子设为Y</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		x-&gt;parent-&gt;left = y;<span class="comment">//如果X为左儿子，则将其父节点的左儿子设为Y</span></span><br><span class="line">	y-&gt;right = x;<span class="comment">//Y的右儿子设为X</span></span><br><span class="line">	x-&gt;parent = y;<span class="comment">//X的父节点设为Y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>旋转示意图如下</p>
<p><img src="/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/20140530150458796" alt="img"> &amp;   <img src="/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/20140530150535671" alt="img"></p>
<p>有了前面的旋转函数，接下来来看看STL中红黑树插入节点后的<strong><em>\</em>平衡调整函数**</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*调整红黑树，旋转以及改变颜色*/</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__rb_tree_rebalance(__rb_tree_node_base* x, __rb_tree_node_base*&amp; root)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//X为新插入节点</span></span><br><span class="line">	x-&gt;color = __rb_tree_red;<span class="comment">//新插入节点初始为红色</span></span><br><span class="line">	<span class="keyword">while</span> (x != root &amp;&amp; x-&gt;parent-&gt;color == __rb_tree_red)<span class="comment">//父节点为红</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;parent == x-&gt;parent-&gt;parent-&gt;left)<span class="comment">//X的父节点为其祖父节点的左儿子</span></span><br><span class="line">		&#123;</span><br><span class="line">			__rb_tree_node_base* y = x-&gt;parent-&gt;parent-&gt;right;<span class="comment">//Y指定为X的叔节点</span></span><br><span class="line">			<span class="keyword">if</span> (y &amp;&amp; y-&gt;color == __rb_tree_red)<span class="comment">//如果X的叔节点存在且为红色</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/*调整颜色，需要向上迭代，直至满足着色法则第3点（不能红-红）*/</span></span><br><span class="line">				x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//X的父节点着黑色</span></span><br><span class="line">				y-&gt;color = __rb_tree_black;<span class="comment">//X的叔节点Y着黑色</span></span><br><span class="line">				x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;<span class="comment">//X的祖父节点着红色</span></span><br><span class="line">				x = x-&gt;parent-&gt;parent;<span class="comment">//调整位置，将当前位置重置为X的祖父节点，开始上层迭代调整</span></span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span><span class="comment">//X的叔节点不存在或者为黑色</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (x == x-&gt;parent-&gt;right)<span class="comment">//X为右儿子，即内侧插入（左右）</span></span><br><span class="line">				&#123;</span><br><span class="line">					x = x-&gt;parent;<span class="comment">//设置旋转点为X的父节点，不影响后面if外X的值</span></span><br><span class="line">					__rb_tree_rotate_left(x, root);<span class="comment">//以X(实际为原X的父节点)为旋转点左旋转</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//因为上面X的赋值在随后的左旋转已经彻底转换了父子关系，所以后面的X还是指向新插入节点位置(不是值)</span></span><br><span class="line">				x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//将X的父节点着黑色</span></span><br><span class="line">				x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;<span class="comment">//X的祖父节点</span></span><br><span class="line">				__rb_tree_rotate_right(x-&gt;parent-&gt;parent, root);<span class="comment">//以X的祖父节点为旋转点右旋转</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//X的父节点为其祖父节点的右儿子</span></span><br><span class="line">		&#123;</span><br><span class="line">			__rb_tree_node_base* y = x-&gt;parent-&gt;parent-&gt;left;<span class="comment">//Y指定为X的叔节点</span></span><br><span class="line">			<span class="keyword">if</span> (y &amp;&amp; y-&gt;color == __rb_tree_red)<span class="comment">//如果X的叔节点存在且为红色</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/*调整颜色，并向上迭代判断调整*/</span></span><br><span class="line">				x-&gt;parent-&gt;color = __rb_tree_black;</span><br><span class="line">				y-&gt;color = __rb_tree_black;</span><br><span class="line">				x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;</span><br><span class="line">				x = x-&gt;parent-&gt;parent;<span class="comment">//调整位置</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (x == x-&gt;parent-&gt;left)</span><br><span class="line">				&#123;</span><br><span class="line">					x = x-&gt;parent;</span><br><span class="line">					__rb_tree_rotate_right(x, root);<span class="comment">//以X(原X的父节点)为旋转点，右旋转</span></span><br><span class="line">				&#125;</span><br><span class="line">				x-&gt;parent-&gt;color = __rb_tree_black;</span><br><span class="line">				x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;</span><br><span class="line">				__rb_tree_rotate_left(x-&gt;parent-&gt;parent, root);<span class="comment">//以X的祖父节点为旋转点进行左旋转</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">//end while</span></span><br><span class="line">	root-&gt;color = __rb_tree_black;<span class="comment">//最后将根节点着色为黑色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了前面的介绍，相信不难理解这个程序。上面便是红黑树插入节点后的核心部分程序</p>
<p>再来看看红黑树的插入函数，在了解红黑树的插入操作之前，有必要先了解红黑树的数据结构以及构造和内存管理</p>
<p>先看看<strong><em>\</em>红黑树的节点结构**</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*红黑树rb_tree 的节点结构*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rb_tree_node_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line">	color_type color;</span><br><span class="line">	base_ptr parent;</span><br><span class="line">	base_ptr left;</span><br><span class="line">	base_ptr right;</span><br><span class="line">	<span class="comment">/*求取X节点以下的最小值(小于等于X的最小值)*/</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> base_ptr <span class="title">minimum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (x-&gt;left != <span class="number">0</span>) x = x-&gt;left;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*求取X节点以下的最大值（大于等于X的最大值）*/</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> base_ptr <span class="title">maximum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (x-&gt;right != <span class="number">0</span>) x = x-&gt;right;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<p>接下来<strong>红黑树rb_tree 的类体结构</strong>，由于比较大，这里只摘取相关部分</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>,</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">rb_tree</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">/*typedef 数据类型*/</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt; rb_tree_node;</span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;rb_tree_node, Alloc&gt; rb_tree_node_allocator;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_node* link_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">/*分配节点空间*/</span></span><br><span class="line">	<span class="function">link_type <span class="title">get_node</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rb_tree_node_allocator::allocate(); &#125;</span><br><span class="line">	<span class="comment">/*释放节点空间*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span> </span>&#123; rb_tree_node_allocator::deallocate(p); &#125;</span><br><span class="line">	<span class="comment">/*创建一个节点*/</span></span><br><span class="line">	<span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		link_type tmp = get_node();<span class="comment">//获取空间</span></span><br><span class="line">        <span class="comment">//……省略捕获异常  </span></span><br><span class="line">		construct(&amp;tmp-&gt;value_field, x);<span class="comment">//构造内容</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">link_type <span class="title">clone_node</span><span class="params">(link_type x)</span><span class="comment">//复制一个节点（值和颜色）</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		link_type tmp = create_node(x-&gt;value_field);</span><br><span class="line">		tmp-&gt;color = x-&gt;color;</span><br><span class="line">		tmp-&gt;left = <span class="number">0</span>;</span><br><span class="line">		tmp-&gt;right = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">destroy_node</span><span class="params">(link_type p)</span><span class="comment">//删除节点</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		destroy(&amp;p-&gt;value_field);<span class="comment">//析构内容</span></span><br><span class="line">		put_node(p);<span class="comment">//释放节点空间</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	size_type node_count; <span class="comment">// keeps track of size of tree</span></span><br><span class="line">	link_type header;<span class="comment">//这是实现上的一个技巧，该类没有单独指定根节点，header-&gt;parent就是指向根节点</span></span><br><span class="line">	Compare key_compare;</span><br><span class="line">	<span class="comment">/*以下三个函数用来方便取得 header 的成员*/</span></span><br><span class="line">	<span class="function">link_type&amp; <span class="title">root</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)header-&gt;parent; &#125;<span class="comment">//树的根节点</span></span><br><span class="line">	<span class="function">link_type&amp; <span class="title">leftmost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)header-&gt;left; &#125;<span class="comment">//树的最小节点</span></span><br><span class="line">	<span class="function">link_type&amp; <span class="title">rightmost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)header-&gt;right; &#125;<span class="comment">//树的最大节点</span></span><br><span class="line">	<span class="comment">/*以下六个函数用来方便取得节点 X 的成员*/</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">left</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;left); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">right</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;right); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">parent</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;parent); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> reference <span class="title">value</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> x-&gt;value_field; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">const</span> Key&amp; <span class="title">key</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> KeyOfValue()(value(x)); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> color_type&amp; <span class="title">color</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (color_type&amp;)(x-&gt;color); &#125;</span><br><span class="line">	<span class="comment">/*省略类型base_ptr的同类函数，功能一样*/</span></span><br><span class="line">	<span class="comment">/*求取极小值*/</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> link_type <span class="title">minimum</span><span class="params">(link_type x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (link_type)__rb_tree_node_base::minimum(x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*求取极大值*/</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> link_type <span class="title">maximum</span><span class="params">(link_type x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (link_type)__rb_tree_node_base::maximum(x);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	iterator __insert(base_ptr x, base_ptr y, <span class="keyword">const</span> value_type&amp; v);</span><br><span class="line">	link_type __copy(link_type x, link_type p);</span><br><span class="line">	<span class="keyword">void</span> __erase(link_type x);</span><br><span class="line">	<span class="comment">/*下面这个函数需要说明一下*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		header = get_node();<span class="comment">//产生一个节点空间，让 header 指向它</span></span><br><span class="line">		color(header) = __rb_tree_red; <span class="comment">//令header 为红色，用于区分root</span></span><br><span class="line">		root() = <span class="number">0</span>;<span class="comment">//header-&gt;parent = 0</span></span><br><span class="line">		leftmost() = header;<span class="comment">//令header 的左儿子为自己</span></span><br><span class="line">		rightmost() = header;<span class="comment">//令header 的右儿子为自己</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// allocation/deallocation</span></span><br><span class="line">	rb_tree(<span class="keyword">const</span> Compare&amp; comp = Compare())</span><br><span class="line">		: node_count(<span class="number">0</span>), key_compare(comp) &#123;</span><br><span class="line">		init();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*拷贝构造函数*/</span></span><br><span class="line">	rb_tree(<span class="keyword">const</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; x)</span><br><span class="line">		: node_count(<span class="number">0</span>), key_compare(x.key_compare) </span><br><span class="line">	&#123;</span><br><span class="line">		header = get_node();</span><br><span class="line">		color(header) = __rb_tree_red;</span><br><span class="line">		<span class="keyword">if</span> (x.root() == <span class="number">0</span>)<span class="comment">//拷贝空树，仅存在header</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/*设置 header*/</span></span><br><span class="line">			root() = <span class="number">0</span>;</span><br><span class="line">			leftmost() = header;</span><br><span class="line">			rightmost() = header;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/*树结构拷贝*/</span></span><br><span class="line">			root() = __copy(x.root(), header);<span class="comment">//x.root()就是树x的根节点</span></span><br><span class="line">			<span class="comment">//省略异常处理部分</span></span><br><span class="line">			<span class="comment">/*设置最大值和最小值</span></span><br><span class="line"><span class="comment">			header 的父节点指向根节点，然后左子节点指向最小节点，右子结点指向最大节点*/</span></span><br><span class="line">			leftmost() = minimum(root());<span class="comment">//不为空树，root()则返回根节点(header的父节点)</span></span><br><span class="line">			rightmost() = maximum(root());</span><br><span class="line">		&#125;</span><br><span class="line">		node_count = x.node_count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*析构函数*/</span></span><br><span class="line">	~rb_tree() </span><br><span class="line">	&#123;</span><br><span class="line">		clear();</span><br><span class="line">		put_node(header);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*赋值构造函数*/</span></span><br><span class="line">	rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp;</span><br><span class="line">		<span class="keyword">operator</span>=(<span class="keyword">const</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; x);</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>这里对上面的 header 节点说明一下，树状结构的各种操作，最需注意的就是边界情况的发生，也就是走到根节点是要有特殊的处理，这里STL 特别为根节点再设计了一个父节点 header，而当插入节点后，header 的父节点指向根节点，其左子节点指向树的最小节点，右子结点指向树的最大节点。类似于链表的表头，这里也多了个头节点不实际存储数据，为管理而存在。</p>
<p>​                   <img src="/2020/12/27/STL%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%86%E6%9E%90/20140531194219343" alt="img"></p>
<p>也就是在一棵非空红黑树中，header-&gt;parent 就是指的该树的根节点，header-&gt;left 就是指该树的最小节点，header-&gt;right 就是指该树的最大节点。</p>
<p>有了前面的了解，接下来看看<strong>红黑树的插入操作</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*插入节点：节点键值不允许重复，若重复则插入无效</span></span><br><span class="line"><span class="comment">返回值是个pair，第一元素是个 rb_tree 迭代器，指向新增节点*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator, bool&gt;</span></span><br><span class="line"><span class="class"><span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;:</span>:insert_unique(<span class="keyword">const</span> Value&amp; v)</span><br><span class="line">&#123;	</span><br><span class="line">    link_type y = header;<span class="comment">//y为根节点的父节点</span></span><br><span class="line">	link_type x = root();<span class="comment">//x为根节点</span></span><br><span class="line">	<span class="keyword">bool</span> comp = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">while</span> (x != <span class="number">0</span>)<span class="comment">//从根节点开始，往下寻找适当的插入点</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//二叉查找树特性插入</span></span><br><span class="line">		y = x;</span><br><span class="line">		comp = key_compare(KeyOfValue()(v), key(x));<span class="comment">//比较新增值v 和x节点的键值</span></span><br><span class="line">		x = comp ? left(x) : right(x);<span class="comment">//v遇"大"则往左，遇"小或等于"往右</span></span><br><span class="line">	&#125;<span class="comment">//while内单次每次运行结束，y总为x的父节点</span></span><br><span class="line">	iterator j = iterator(y);<span class="comment">//此时y节点必为叶子节点</span></span><br><span class="line">	<span class="keyword">if</span> (comp)<span class="comment">//v小于比较值，将插入左侧</span></span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="keyword">if</span> (j == begin())<span class="comment">//begin()实际就是header-&gt;left，也就是树的最左节点</span></span><br><span class="line">			<span class="keyword">return</span> pair&lt;iterator, <span class="keyword">bool</span>&gt;(__insert(x, y, v), <span class="literal">true</span>);<span class="comment">//转入实际插入函数__insert()</span></span><br><span class="line">		<span class="keyword">else</span><span class="comment">//如果插入点之父节点不为最左节点</span></span><br><span class="line">			--j;<span class="comment">//调整j，--重载，调用decrement()，即找到比当前节点小的最大节点</span></span><br><span class="line">		<span class="comment">//与此同时还有++重载，调用increment()，找到比当前节点大的最小节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (key_compare(key(j.node), KeyOfValue()(v)))<span class="comment">//遇"小"将插入右侧(v值大)</span></span><br><span class="line">		<span class="keyword">return</span> pair&lt;iterator, <span class="keyword">bool</span>&gt;(__insert(x, y, v), <span class="literal">true</span>);</span><br><span class="line">	<span class="comment">/*以上，x为新插入点位置，y为插入点之父节点，v为键值*/</span></span><br><span class="line">	<span class="keyword">return</span> pair&lt;iterator, <span class="keyword">bool</span>&gt;(j, <span class="literal">false</span>);<span class="comment">//存在重复键值就不插入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*插入节点：节点键值允许重复</span></span><br><span class="line"><span class="comment">返回值是一个 rb_tree 迭代器，指向新增节点*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;:</span>:iterator</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::insert_equal(<span class="keyword">const</span> Value&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">	link_type y = header;<span class="comment">//y为根节点的父节点</span></span><br><span class="line">	link_type x = root(); <span class="comment">//x为根节点</span></span><br><span class="line">	<span class="keyword">while</span> (x != <span class="number">0</span>)<span class="comment">//从根节点开始，往下寻找适当的插入点</span></span><br><span class="line">	&#123;</span><br><span class="line">		y = x;</span><br><span class="line">		<span class="comment">//直接找到合适位置，无需考虑键值是否重复</span></span><br><span class="line">		x = key_compare(KeyOfValue()(v), key(x)) ? left(x) : right(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> __insert(x, y, v);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>从上面可知，真正的插入操作是<strong><em>\</em>__insert()**</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*x为新增节点位置，y为新增节点的父节点，v为新增节点的键值*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;:</span>:iterator</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::</span><br><span class="line">__insert(base_ptr x_, base_ptr y_, <span class="keyword">const</span> Value&amp; v) &#123;</span><br><span class="line">	link_type x = (link_type)x_;</span><br><span class="line">	link_type y = (link_type)y_;</span><br><span class="line">	link_type z;</span><br><span class="line">	<span class="keyword">if</span> (y == header || x != <span class="number">0</span> || key_compare(KeyOfValue()(v), key(y)))</span><br><span class="line">	&#123;</span><br><span class="line">		z = create_node(v);<span class="comment">//为新节点配置空间</span></span><br><span class="line">		left(y) = z;                <span class="comment">// also makes leftmost() = z when y == header</span></span><br><span class="line">		<span class="keyword">if</span> (y == header)<span class="comment">//如果y为头节点，也就是空树第一次插入节点</span></span><br><span class="line">		&#123;</span><br><span class="line">			root() = z;<span class="comment">//z为根节点，与header节点互为父节点</span></span><br><span class="line">			rightmost() = z;<span class="comment">//树的最大节点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (y == leftmost())<span class="comment">//如果y为最左节点</span></span><br><span class="line">			leftmost() = z;<span class="comment">//修正最小节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//上面三种全不满足，即插入键值大于插入点的父节点，右侧插入</span></span><br><span class="line">	&#123;</span><br><span class="line">		z = create_node(v);</span><br><span class="line">		right(y) = z;<span class="comment">//使新节点成为插入点的父节点y的右子结点</span></span><br><span class="line">		<span class="keyword">if</span> (y == rightmost())</span><br><span class="line">			rightmost() = z;          <span class="comment">// maintain rightmost() pointing to max node</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置新增节点z的关系</span></span><br><span class="line">	parent(z) = y;</span><br><span class="line">	left(z) = <span class="number">0</span>;</span><br><span class="line">	right(z) = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//平衡红黑树</span></span><br><span class="line">	__rb_tree_rebalance(z, header-&gt;parent);</span><br><span class="line">	++node_count;<span class="comment">//节点数累加</span></span><br><span class="line">	<span class="keyword">return</span> iterator(z);<span class="comment">//返回迭代器，指向新增节点</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>以上就是红黑树的整个节点插入操作过程</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C-%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0/" rel="tag"># C++进阶学习</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/27/STL%E7%89%B9%E6%AE%8A%E5%AE%B9%E5%99%A8%20string/" rel="prev" title="STLstring">
      <i class="fa fa-chevron-left"></i> STLstring
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/27/STL%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8set%E5%92%8Cmultiset/" rel="next" title="STLset和multiset">
      STLset和multiset <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">匡俊桦</p>
  <div class="site-description" itemprop="description">回忆的沙漏将曾经屈指可数的日子渐渐淡去</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">227</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">匡俊桦</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.7m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">25:36</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
