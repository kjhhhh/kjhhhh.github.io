<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一、基础知识引言 基本了解硬件系统的结构； 利用硬件系统的编程结构和指令集，有效灵活地控制系统进行工作。  1.1 机器语言 机器语言是机器指令的集合。电子计算机的机器指令是一系列二进制数字。计算机将之转换为一系列高低电平脉冲信号来驱动硬件工作的。  1.2 汇编语言的产生 由于机器语言指令都是由01组成,难以编写,记忆和维护程序.所以汇编语言为了解决这一问题产生。汇编语言的主体是汇编指令，汇编指">
<meta property="og:type" content="article">
<meta property="og:title" content="汇编语言基础学习汇总3">
<meta property="og:url" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/index.html">
<meta property="og:site_name" content="KJHの博客">
<meta property="og:description" content="一、基础知识引言 基本了解硬件系统的结构； 利用硬件系统的编程结构和指令集，有效灵活地控制系统进行工作。  1.1 机器语言 机器语言是机器指令的集合。电子计算机的机器指令是一系列二进制数字。计算机将之转换为一系列高低电平脉冲信号来驱动硬件工作的。  1.2 汇编语言的产生 由于机器语言指令都是由01组成,难以编写,记忆和维护程序.所以汇编语言为了解决这一问题产生。汇编语言的主体是汇编指令，汇编指">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516130510663.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516130534835.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516130646132.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516130610742.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516130720273.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516130748089.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516130857852.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516130922414.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516131059431.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516131242884.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516131316807.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516131420213.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516131442463.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516132148984.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516132601845.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516134102680.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516134717267.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516134733996.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516134809731.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516134828737.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516134954833.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516135020850.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516135110577.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516183617791.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516183634486.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516183712370.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516183806106.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516184105129.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516184158629.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516185351745.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516185650553.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516190632064.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516191127691.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516191202229.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516192520279.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516192653168.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516192911638.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516192928623.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516192952451.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516193134171.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516193307578.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516193354516.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516194436381.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516194814140.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516195028618.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516195158771.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516195225072.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516195935453.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516200035483.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516200530657.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170529230442772.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516201316988.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516201335895.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516201508975.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516201621398.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516201820025.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516201938980.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516202038274.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516202241000.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516202326635.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516202411776.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516202448666.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516202513426.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516202547067.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522073406637.jfif">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522073441450.jfif">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522073505403.jfif">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522075507746.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522075642999.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522075757000.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522075820704.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522075847336.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522080045212.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522080117865.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522080147556.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522080219665.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522080305742.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522080322023.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522080826858.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522080919891.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522081015575.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522081037059.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522081718999.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522081751015.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522081857031.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522081929203.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522082205111.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522082758756.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522082906398.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522082937633.png">
<meta property="og:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170523225635283.jfif">
<meta property="article:published_time" content="2021-01-01T14:14:52.011Z">
<meta property="article:modified_time" content="2021-03-22T15:05:04.361Z">
<meta property="article:author" content="匡俊桦">
<meta property="article:tag" content="汇编基础学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516130510663.png">

<link rel="canonical" href="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>汇编语言基础学习汇总3 | KJHの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KJHの博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录&回忆</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          汇编语言基础学习汇总3
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-01 22:14:52" itemprop="dateCreated datePublished" datetime="2021-01-01T22:14:52+08:00">2021-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-22 23:05:04" itemprop="dateModified" datetime="2021-03-22T23:05:04+08:00">2021-03-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96/" itemprop="url" rel="index"><span itemprop="name">汇编</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>64k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>58 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul>
<li>基本了解硬件系统的结构；</li>
<li>利用硬件系统的编程结构和指令集，有效灵活地控制系统进行工作。</li>
</ul>
<h2 id="1-1-机器语言"><a href="#1-1-机器语言" class="headerlink" title="1.1 机器语言"></a>1.1 机器语言</h2><ul>
<li>机器语言是机器指令的集合。电子计算机的机器指令是一系列二进制数字。计算机将之转换为一系列高低电平脉冲信号来驱动硬件工作的。</li>
</ul>
<h2 id="1-2-汇编语言的产生"><a href="#1-2-汇编语言的产生" class="headerlink" title="1.2 汇编语言的产生"></a>1.2 汇编语言的产生</h2><ul>
<li>由于机器语言指令都是由01组成,难以编写,记忆和维护程序.所以汇编语言为了解决这一问题产生。汇编语言的主体是汇编指令，汇编指令是机器指令的助记符。</li>
<li><strong>寄存器：</strong> CPU中存储数据的器件，一个CPU中有多个寄存器。</li>
</ul>
<h2 id="1-3-汇编语言的组成"><a href="#1-3-汇编语言的组成" class="headerlink" title="1.3 汇编语言的组成"></a>1.3 汇编语言的组成</h2><ul>
<li><strong>1、汇编指令</strong>(机器码的助记符，有对应的机器码)；</li>
<li><strong>2、伪指令</strong>(由编译器执行)和<strong>其他符号</strong>(由编译器识别)。</li>
</ul>
<h2 id="1-4-存储器"><a href="#1-4-存储器" class="headerlink" title="1.4 存储器"></a>1.4 存储器</h2><ul>
<li>CPU工作需要指令和数据，指令和数据存储在存储器中。</li>
</ul>
<h2 id="1-5-指令和数据"><a href="#1-5-指令和数据" class="headerlink" title="1.5 指令和数据"></a>1.5 指令和数据</h2><ul>
<li>在内存或者磁盘中存储的都是为二进制信息，<strong>指令和数据由我们设定(走的总线)</strong>。<a id="more"></a></li>
</ul>
<h2 id="1-6-存储单元"><a href="#1-6-存储单元" class="headerlink" title="1.6 存储单元"></a>1.6 存储单元</h2><ul>
<li>存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号。</li>
<li>B、KB、MB、GB、TB等单位。</li>
</ul>
<h2 id="1-7-CPU对存储器的读写"><a href="#1-7-CPU对存储器的读写" class="headerlink" title="1.7 CPU对存储器的读写"></a>1.7 CPU对存储器的读写</h2><ul>
<li><p><strong>CPU要对数据进行读写，必须和外部器件进行以下三类信息的交互：</strong></p>
<ul>
<li><strong>1、存储单元的地址</strong>(地址信息)；</li>
<li><strong>2、器件的选择、读或写命令</strong>(控制信息)；</li>
<li><strong>3、读或写的数据</strong>(数据信息) 。</li>
</ul>
</li>
<li><p>总线是连接CPU和其他芯片的导线，逻辑上分为<strong>地址总线</strong>、<strong>数据总线</strong>、<strong>控制总线</strong>。</p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516130510663.png" alt="逻辑上总线的分类"></p>
</li>
<li><p>CPU从内存单元中读写数据的过程：</p>
<ul>
<li>1、CPU通过地址线将地址信息发出；</li>
<li>2、CPU通过控制线发出内存读命令，选中存储器芯片，并通知它将要从中读或写数据；</li>
<li>3、存储器将相应的地址单元中的数据通过数据线送入CPU或CPU通过数据线将数据送入相应的内存单元。</li>
</ul>
</li>
</ul>
<h2 id="1-8-地址总线"><a href="#1-8-地址总线" class="headerlink" title="1.8 地址总线"></a>1.8 地址总线</h2><ul>
<li>CPU是通过地址总线指定存储单元，地址总线传送的能力决定了CPU对存储单元的寻址能力。(一般32位CPU，寻址能力为2^32=4G)</li>
</ul>
<h2 id="1-9-数据总线"><a href="#1-9-数据总线" class="headerlink" title="1.9 数据总线"></a>1.9 数据总线</h2><ul>
<li>CPU通过数据总线来与内存等器件进行数据传送，数据总线的宽度决定了CPU和外界的数据传送速度。</li>
</ul>
<h2 id="1-10-控制总线"><a href="#1-10-控制总线" class="headerlink" title="1.10 控制总线"></a>1.10 控制总线</h2><ul>
<li>控制总线是一些不同控制的集合，CPU通过控制总线对外部器件的控制。控制总线的宽度决定了CPU对外部器件的控制能力。</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>1、汇编指令时机器指令的助记符，与机器指令一一对应。</li>
<li>2、每一种CPU都有自己的汇编指令集。</li>
<li>3、CPU可以直接使用的信息在存储器中存放。</li>
<li>4、在存储器中指令和数据都是二进制信息。</li>
<li>5、存储单元从0开始顺序编号。</li>
<li>6、一个存储单元可以存储8个bit。</li>
<li>7、B、KB、MB、GB等单位之间的转换。</li>
<li>8、CPU管脚和总线相连。总线的宽度表示CPU不同方面的性能：<ul>
<li>地址总线的宽度决定了CPU的寻址能力；</li>
<li>数据总线的宽度决定了CPU与其他器件进行一次数据传送的量；</li>
<li>控制总线宽度决定了CPU对系统中其他器件的控制。</li>
</ul>
</li>
</ul>
<h2 id="检测点-1-1"><a href="#检测点-1-1" class="headerlink" title="检测点 1.1"></a>检测点 1.1</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516130534835.png" alt="检测点1.1"></p>
<h2 id="1-11-内存地址空间-概述"><a href="#1-11-内存地址空间-概述" class="headerlink" title="1.11 内存地址空间(概述)"></a>1.11 内存地址空间(概述)</h2><ul>
<li>CPU可寻的内存单元构成这个CPU的内存地址空间。例如一个CPU的地址总线宽度为10，那么可以寻址的1024个内存单元构成了这个CPU的内存空间。</li>
</ul>
<h2 id="1-12-主板"><a href="#1-12-主板" class="headerlink" title="1.12 主板"></a>1.12 主板</h2><ul>
<li>主板主板，主要的电路板 :laughing:</li>
</ul>
<h2 id="1-13-接口卡"><a href="#1-13-接口卡" class="headerlink" title="1.13 接口卡"></a>1.13 接口卡</h2><ul>
<li>CPU通过接口卡间接控制外部设备。</li>
</ul>
<h2 id="1-14-各类存储器"><a href="#1-14-各类存储器" class="headerlink" title="1.14 各类存储器"></a>1.14 各类存储器</h2><ul>
<li>随机存储器RAM(主板上的RAM、拓展插槽上的RAM和接口卡上的RAM)和只读存储器器ROM(装有BIOS的ROM)。<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516130646132.png" alt="PC集中各类存储器的逻辑连接"></li>
</ul>
<h2 id="1-15-内存地址空间"><a href="#1-15-内存地址空间" class="headerlink" title="1.15 内存地址空间"></a>1.15 内存地址空间</h2><ul>
<li><p><strong>各类存储器在物理上是独立的，但是：</strong></p>
<ul>
<li><strong>1、都和CPU的总线相连；</strong></li>
<li><strong>2、 CPU对他们进行读或写的时候都通过控制线发出的内存读写命令。</strong></li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516130610742.png" alt="将各类存储器看作一个逻辑存储器"></p>
</li>
<li><p>不同的计算机系统的内存地址空间分配情况是不同的。</p>
</li>
</ul>
<hr>
<h1 id="二、寄存器-CPU的工作原理"><a href="#二、寄存器-CPU的工作原理" class="headerlink" title="二、寄存器(CPU的工作原理)"></a>二、寄存器(CPU的工作原理)</h1><h2 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h2><ul>
<li>CPU由运算器、控制器、寄存器 等器件组成，靠内部总线相连。</li>
<li>内部总线实现CPU内部各器件之间的联系；外部总线实现CPU和主板上其他器件的联系。</li>
<li>在CPU中：<ul>
<li>运算器进行信息处理；</li>
<li>寄存器进行信息存储；</li>
<li>控制器控制各种器件进行工作；</li>
<li>内部总线连接各种器件在它们之间进行数据的传送。</li>
</ul>
</li>
</ul>
<h2 id="2-1-通用寄存器"><a href="#2-1-通用寄存器" class="headerlink" title="2.1 通用寄存器"></a>2.1 通用寄存器</h2><ul>
<li>8086有14个寄存器：<ul>
<li><strong>AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、CS、ES、PSW</strong>。</li>
</ul>
</li>
<li>AX、BX、CX、DX通常用来存放一般性数据，被称为通用寄存器。</li>
<li>16位寄存器所能存储的数据最大值为2^16^-1 。</li>
<li>为保证兼容性，8086 CPU的通用寄存器可以分为两个独立的8位寄存器使用。<strong>例：</strong> AX可分为AH和AL。</li>
</ul>
<h2 id="2-2-字在寄存器中的存储"><a href="#2-2-字在寄存器中的存储" class="headerlink" title="2.2 字在寄存器中的存储"></a>2.2 字在寄存器中的存储</h2><ul>
<li><p>8086 CPU所有的寄存器是16位，可以存放2个字节(一个字)。</p>
</li>
<li><p>一字节由8 bit 组成，可以存在8位寄存器中。</p>
</li>
<li><p>字(word)是两字节，16位。</p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516130720273.png" alt="一个字由两个字节组成"></p>
</li>
</ul>
<h2 id="2-3-几条汇编指令"><a href="#2-3-几条汇编指令" class="headerlink" title="2.3 几条汇编指令"></a>2.3 几条汇编指令</h2><ul>
<li><p>汇编指令对大小写不敏感</p>
<p>汇编指令举例</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>汇编指令</th>
<th>控制CPU完成的操作</th>
<th>用高级语言的语法描述</th>
</tr>
</thead>
<tbody><tr>
<td>mov ax，18</td>
<td>将8送入AX</td>
<td>AX=18</td>
</tr>
<tr>
<td>mov ah，78</td>
<td>将78送入AH</td>
<td>AH=78</td>
</tr>
<tr>
<td>add ax，8</td>
<td>将寄存器AX中的数值加上8结果存入AX中</td>
<td>AX=AX+8</td>
</tr>
<tr>
<td>mov ax，bx</td>
<td>将寄存器BX中的数据送入寄存器AX</td>
<td>AX=BX</td>
</tr>
<tr>
<td>add ax，bx</td>
<td>将AX，BX中的内容相加结果存入AX中</td>
<td>AX=AX+BX</td>
</tr>
</tbody></table>
<h2 id="检测点-2-1"><a href="#检测点-2-1" class="headerlink" title="检测点 2.1"></a>检测点 2.1</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516130748089.png" alt="检测点2.1"></p>
<h2 id="2-4-物理地址"><a href="#2-4-物理地址" class="headerlink" title="2.4 物理地址"></a>2.4 物理地址</h2><ul>
<li>所有的内存单元构成一个一维的线性存储空间。</li>
<li>CPU访问内存单元时要给出内存单元的唯一地址就是物理地址。</li>
</ul>
<h2 id="2-5-16位结构的CPU"><a href="#2-5-16位结构的CPU" class="headerlink" title="2.5 16位结构的CPU"></a>2.5 16位结构的CPU</h2><ul>
<li>1、运算器一次最多可以处理16位数据。</li>
<li>2、 寄存器的最大宽度为16位。</li>
<li>3、寄存器和运算器之间的通路是16位。</li>
</ul>
<h2 id="2-6-8086-CPU给出物理地址的方法"><a href="#2-6-8086-CPU给出物理地址的方法" class="headerlink" title="2.6 8086 CPU给出物理地址的方法"></a>2.6 8086 CPU给出物理地址的方法</h2><ul>
<li>8086有20位的地址总线，可以传送20位地址，寻址能力为1M；但8086内部为16位结构，只能传送16位的地址。</li>
<li><strong>8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。</strong></li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516130857852.png" alt="8086CPU相关部件的逻辑结构"></p>
<ul>
<li>8086CPU读写内存的步骤：<ul>
<li>1、CPU中的相关部件提供段子和偏移地址这两个16位的地址；</li>
<li>2、段地址和偏移地址通过内部总线送入到一个称为地址加法器的部件；</li>
<li>3、地址加法器将两个16位地址合并成一个20位的地址；</li>
<li>4、地址加法器通过内部总线将20位物理地址送送入输入输出地址；</li>
<li>5、输入输出控制电路将20位物理地址送上地址总线；</li>
<li>6、20位物理地址被地址总线传送到存储器。</li>
</ul>
</li>
<li>地址加法器工作原理：<strong>物理地址=段地址*16+偏移地址。</strong></li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516130922414.png" alt="地址加法器的过程"><br>- 段地址*16就是数据左移4位(二进制)</p>
<table>
<thead>
<tr>
<th>移位位数</th>
<th>二进制</th>
<th>十六进制</th>
<th>十进制</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>10B</td>
<td>2H</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>100B</td>
<td>4H</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>1000B</td>
<td>8H</td>
<td>8</td>
</tr>
<tr>
<td>3</td>
<td>10000B</td>
<td>10H</td>
<td>16</td>
</tr>
<tr>
<td>4</td>
<td>100000B</td>
<td>20H</td>
<td>32</td>
</tr>
</tbody></table>
<ul>
<li><strong>一个数据的二进制形式左移N位，相当于该数据乘以2的N次方。一个数据X进制形式左移N位，相当乘以NX。</strong></li>
</ul>
<h2 id="2-7-段地址-16-偏移地址-物理地址"><a href="#2-7-段地址-16-偏移地址-物理地址" class="headerlink" title="2.7 段地址*16+偏移地址=物理地址"></a>2.7 段地址*16+偏移地址=物理地址</h2><ul>
<li><strong>CPU可以通过不同的段地址和偏移地址形成一个相同的物理地址。</strong></li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516131059431.png" alt="CPU可以通过不同的段地址和偏移地址形成相同的物理地址"></p>
<blockquote>
<p>段地址*16是移位</p>
</blockquote>
<h2 id="2-8-段的概念"><a href="#2-8-段的概念" class="headerlink" title="2.8 段的概念"></a>2.8 段的概念</h2><ul>
<li>人为定义的，将若干地址连续的内存单元看作一个段。用段地址*16定位段的起始地址(基址)，用偏移地址定位段中的内存单元。<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516131242884.png" alt="段的概念"></li>
<li><strong>一个段的起始地址是16的倍数。偏移地址为16位，寻址能力为64K，所以段的最大长度也是64K。</strong></li>
</ul>
<h2 id="检测点-2-2"><a href="#检测点-2-2" class="headerlink" title="检测点 2.2"></a>检测点 2.2</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516131316807.png" alt="检测点2.2"></p>
<h2 id="2-9-段寄存器"><a href="#2-9-段寄存器" class="headerlink" title="2.9 段寄存器"></a>2.9 段寄存器</h2><ul>
<li>8086 CPU有4个段寄存器:<strong>CS(代码段)、DS(数据段)、SS(堆栈段)、ES(附加段)</strong>，这4个段提供给8086CPU内存单元的段地址。</li>
</ul>
<h2 id="2-10-CS和IP"><a href="#2-10-CS和IP" class="headerlink" title="2.10 CS和IP"></a>2.10 CS和IP</h2><ul>
<li><p><strong>CS(代码段寄存器)</strong> 和<strong>IP(指令指针寄存器)</strong> 是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址。在任意时刻CPU将CS:IP指向的内容当作指令执行。</p>
</li>
<li><p>8086CPU工作过程的简要概述：</p>
<ul>
<li><p>1、从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器；</p>
<blockquote>
<p>8086PC机刚开始启动时，CPU从内存FFFF0h单元中读取指令执行，FFFF0h单元中的指令时8086PC机开机后执行的第一条指令。</p>
</blockquote>
</li>
<li><p>2、 IP=IP+所读取指令的长度，从而正确的指向下一条指令；</p>
</li>
<li><p>3、执行指令。转到步骤1，周而复始。</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-11-修改CS、IP的指令"><a href="#2-11-修改CS、IP的指令" class="headerlink" title="2.11 修改CS、IP的指令"></a>2.11 修改CS、IP的指令</h2><ul>
<li><strong>mov指令(传送指令)</strong> 可以改变8086CPU大部分寄存器的值，但不能用于设置CS、IP的值。</li>
<li><strong>jmp指令(转移指令)</strong> 可以用来同时修改CS和IP的值，格式为</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmp 段地址:偏移地址;同时修改CS和IP</span><br><span class="line">jmp 某一合法寄存器;则是仅修改IP12</span><br></pre></td></tr></table></figure>

<h2 id="2-12-代码段"><a href="#2-12-代码段" class="headerlink" title="2.12 代码段"></a>2.12 代码段</h2><ul>
<li>对于8086PC机，在编程时可以将长度为N(N小于等于64KB)的一组代码存在一组地址连续、起始地址为16的倍数的内存单元中，这段内存是用来存放代码的，从而定义了一个代码段。</li>
<li>利用CS:IP来指向内存单元从而让CPU执行其中的内容。</li>
</ul>
<h2 id="检测点-2-3"><a href="#检测点-2-3" class="headerlink" title="检测点 2.3"></a>检测点 2.3</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516131420213.png" alt="检测点2.3"></p>
<h2 id="使用Debug"><a href="#使用Debug" class="headerlink" title="使用Debug"></a>使用Debug</h2><blockquote>
<p>windows xp系统自带debug，请使用xp以上系统的读者执行自行下载debug.exe和dosbox，使用方法笔者不再赘述，在dosbox中可以使用debug。<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516131442463.png" alt="debug in dosbox"></p>
</blockquote>
<ul>
<li><strong>可以使用汇编金手指查阅指令。</strong></li>
<li><strong>R</strong>命令查看、改变CPU寄存器的内容；</li>
<li><strong>D</strong>命令查看内存中的内容；</li>
<li><strong>E</strong>命令改写内存中的内容；</li>
<li><strong>U</strong>命令将内存中的机器指令翻译成汇编指令；</li>
<li><strong>T</strong>命令执行一条机器指令；</li>
<li><strong>G</strong>命令跳转到偏移地址；</li>
<li><strong>P</strong>命令结束循环或者是int 21H时是退出程序；</li>
<li><strong>A</strong>命令是以汇编指令的格式在内存中写入一条机器指令。</li>
</ul>
<hr>
<h1 id="三、寄存器-内存访问"><a href="#三、寄存器-内存访问" class="headerlink" title="三、寄存器(内存访问)"></a>三、寄存器(内存访问)</h1><h2 id="3-1-内存中字的存储"><a href="#3-1-内存中字的存储" class="headerlink" title="3.1 内存中字的存储"></a>3.1 内存中字的存储</h2><ul>
<li>字是两个字节，要用两个地址连续的内存来存放，字的低位字节存在低地址中，高位字节存放在高地址单元中。</li>
</ul>
<h2 id="3-2-DS和-address"><a href="#3-2-DS和-address" class="headerlink" title="3.2 DS和[address]"></a>3.2 DS和[address]</h2><ul>
<li><p>DS通常存放要访问的数据的段地址。</p>
</li>
<li><p><strong>8086 CPU由于硬件的设计不支持将数据直接送入段寄存器的操作。</strong></p>
<blockquote>
<p>数据 -&gt; 通用寄存器 -&gt; 段寄存器</p>
</blockquote>
</li>
<li><p>[ ]里边的数据代表偏移地址值</p>
</li>
<li><p>mov指令：</p>
<ul>
<li>将数据直接送入寄存器；</li>
<li>将一个寄存器或内存单元中的内容送入另一个寄存器；</li>
</ul>
</li>
<li><p>mov指令格式:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov 寄存器名,内存单元1</span><br></pre></td></tr></table></figure>

<h2 id="3-3-字型的传送"><a href="#3-3-字型的传送" class="headerlink" title="3.3 字型的传送"></a>3.3 字型的传送</h2><ul>
<li>高地址单元和高8位寄存器，低地址单元和低8位寄存器相对应。</li>
</ul>
<h2 id="3-4-mov、add、sub指令"><a href="#3-4-mov、add、sub指令" class="headerlink" title="3.4 mov、add、sub指令"></a>3.4 mov、add、sub指令</h2><ul>
<li>有两个操作对象，jmp只有一个操作对象。</li>
<li><strong>使用汇编金手指查阅指令</strong></li>
<li><strong>mov指令的几种形式</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov 寄存器,数据;mov ax,8</span><br><span class="line">mov 寄存器,寄存器;mov ax,bx</span><br><span class="line">mov 寄存器,内存单元;mov ax,[0]</span><br><span class="line">mov 内存单元,寄存器;mov [0],ax</span><br><span class="line">mov 段寄存器,寄存器;mov ds,ax</span><br><span class="line">mov 寄存器,段寄存器;mov ax,ds</span><br><span class="line">     ……1234567</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>add指令的几种形式</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add 通用寄存器,数据</span><br><span class="line">add 通用寄存器,通用寄存器</span><br><span class="line">add 通用寄存器,内存单元</span><br><span class="line">add 内存单元,寄存器1234</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>sub指令的几种形式</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sub 通用寄存器,数据</span><br><span class="line">sub 通用寄存器,通用寄存器</span><br><span class="line">sub 通用寄存器,内存单元</span><br><span class="line">sub 内存单元,通用寄存器  1234</span><br></pre></td></tr></table></figure>

<h2 id="3-5-数据段"><a href="#3-5-数据段" class="headerlink" title="3.5 数据段"></a>3.5 数据段</h2><ul>
<li>对于8086PC机，在编程时可以将长度为N(N小于等于64KB)的一组代码存在一组地址连续、起始地址为16的倍数的内存单元中，这段内存是用来存放数据的，从而定义了一个数据段。</li>
<li>可以通过在DS中存放数据段的段地址，用相关的指令访问数据段中的具体单元来访问数据段中的数据。</li>
</ul>
<h2 id="检测点-3-1"><a href="#检测点-3-1" class="headerlink" title="检测点 3.1"></a>检测点 3.1</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516132148984.png" alt="检测点3.1"></p>
<h2 id="3-6-栈"><a href="#3-6-栈" class="headerlink" title="3.6 栈"></a>3.6 栈</h2><ul>
<li>具有特殊的访问方式的存储空间，也是内存空间的一部分，数据<strong>先进后出。</strong></li>
<li>有两个基本操作:<ul>
<li>入栈：将一个新的元素放到栈顶；</li>
<li>出栈：从栈顶取出一个元素。</li>
</ul>
</li>
<li>栈顶元素最后入栈最先出栈。</li>
</ul>
<h2 id="3-7-8086-CPU提供的栈机制"><a href="#3-7-8086-CPU提供的栈机制" class="headerlink" title="3.7 8086 CPU提供的栈机制"></a>3.7 8086 CPU提供的栈机制</h2><ul>
<li><p>现今的CPU都有栈的设计，基于8086CPU编程可以将一段内存当作栈来使用。</p>
</li>
<li><p>8086CPU的</p>
<p>入栈(PUSH)</p>
<p>和</p>
<p>POP(出栈)</p>
<p>，以字为单位。</p>
<ul>
<li>push ax 将寄存器ax中的数据送入栈</li>
<li>pop ax 从栈顶取出数据送入ax</li>
</ul>
</li>
<li><p><strong>段寄存器SS存放栈顶的段地址，寄存器SP存放栈顶的偏移地址。任意时刻SS:SP指向栈顶元素。push时SP先自减法后写内存，pop先读内存sp后自加。</strong></p>
</li>
<li><p>pop之后数据还是存在内存中，push时覆盖。</p>
<blockquote>
<p>CS和IP存放当前指令的段地址和偏移地址。</p>
</blockquote>
</li>
</ul>
<h2 id="3-8-栈顶越界的问题"><a href="#3-8-栈顶越界的问题" class="headerlink" title="3.8 栈顶越界的问题"></a>3.8 栈顶越界的问题</h2><ul>
<li><strong>栈是空的，则SP指向栈底+1的内存。</strong></li>
<li>8086 CPU只纪录栈顶，栈空间由自己控制。栈顶越界问题导致溢出漏洞。</li>
<li>8086CPU只考虑当前的情况：<ul>
<li>当前栈顶在何处；</li>
<li>当前要执行的指令时哪一条。</li>
</ul>
</li>
</ul>
<h2 id="3-9-push、pop指令"><a href="#3-9-push、pop指令" class="headerlink" title="3.9 push、pop指令"></a>3.9 push、pop指令</h2><ul>
<li>可以直接对段寄存器使用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;push和pop格式</span><br><span class="line">push 寄存器</span><br><span class="line">pop 寄存器</span><br><span class="line">push 段寄存器</span><br><span class="line">pop 段寄存器</span><br><span class="line">push 内存单元</span><br><span class="line">pop 内存单元1234567</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>通用寄存器命名是x结尾的，段寄存器是以s结尾。</strong></li>
<li>CPU在执行指令时，数据的段地址是从DS中获得，代码是在CS中获得，栈地址是从SS获得。</li>
</ul>
<h2 id="3-10-栈段"><a href="#3-10-栈段" class="headerlink" title="3.10 栈段"></a>3.10 栈段</h2><ul>
<li>对于8086PC机，在编程时可以将长度为N(N小于等于64KB)的一组代码存在一组地址连续、起始地址为16的倍数的内存单元中，这段内存是当作栈来用，从而定义了一个栈段。</li>
<li><strong>寄存器清零可用sub ax,ax或者直接赋值0，</strong>常见的也有使用xor。</li>
<li>当栈空间定义为最大时，栈为空时SP=0。</li>
</ul>
<h2 id="检测点-3-2"><a href="#检测点-3-2" class="headerlink" title="检测点 3.2"></a>检测点 3.2</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516132601845.png" alt="检测点3.2"></p>
<hr>
<h1 id="四、第一个程序"><a href="#四、第一个程序" class="headerlink" title="四、第一个程序"></a>四、第一个程序</h1><h2 id="引言-2"><a href="#引言-2" class="headerlink" title="引言"></a>引言</h2><p>编写完成的汇编语言程序，用编译器编译成可执行文件并在操作系统中运行。</p>
<h2 id="4-1-一个源程序从写出到执行的过程"><a href="#4-1-一个源程序从写出到执行的过程" class="headerlink" title="4.1 一个源程序从写出到执行的过程"></a>4.1 一个源程序从写出到执行的过程</h2><ul>
<li><p>编写</p>
<ul>
<li>用编辑器(Sublime Text、Nodepad++、UltraEdit)编写，文件后缀为.asm。</li>
</ul>
</li>
<li><p>编译链接</p>
<ul>
<li>使用MASM.EXE编译生产obj(目标文件)。masm也请读者自行搜索下载。</li>
<li>LINKE.EXE对目标文件进行连接生产可在操作系统中直接运行的可执行文件。</li>
</ul>
</li>
</ul>
<blockquote>
<p>可执行文件包含程序(机器码)、数据(源程序中定义的数据)和相关的描述信息。</p>
</blockquote>
<ul>
<li><p>执行</p>
<ul>
<li>操作系统中依照可执行文件中的描述信息将可执行文件中的机器码和数据加载入内存并进行相关的初始化，然后CPU执行。</li>
</ul>
</li>
<li><h2 id="4-2-源程序"><a href="#4-2-源程序" class="headerlink" title="4.2 源程序"></a>4.2 源程序</h2><ul>
<li>汇编指令：有对应的机器码的指令，编译为机器码被CPU执行</li>
<li>伪指令：没有对应的机器码，不被CPU所执行，由编译器执行来进行相关的编译工作。<ul>
<li>segment和ends是用来定义一个段的，是成对使用的伪指令，再写可被编译器编译的汇编程序是必须要用的。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg ;假设代码段的名称为codesg</span><br><span class="line">codesg segment ;定义一个codesg段</span><br><span class="line">mov ax,0123H</span><br><span class="line">mov bx,0456H</span><br><span class="line">add ax,bx</span><br><span class="line">add ax,ax</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends ;codesg段结束</span><br><span class="line">end ;是个伪指令，程序的结束标记12345678910</span><br></pre></td></tr></table></figure>

<blockquote>
<p>assume用来加上某一段寄存器和程序中的某一用segment……ends定义的段相关联。通过assume说明这种关联，在需要的情况下编译程序可以将段寄存器和某一个具体的段相联系。<br>- 一个汇编程序是由多个段组成。一个有意义的汇编程序中至少要用一个段来存放代码。<br>- 程序与源程序<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516134102680.png" alt="程序与源程序"></p>
</blockquote>
<ul>
<li>标号:指代地址</li>
<li>程序的结构</li>
<li>小练习：</li>
</ul>
<figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;编程运算<span class="number">2</span>^<span class="number">3</span></span><br><span class="line">assume cs:abc ;段与寄存器关联</span><br><span class="line"></span><br><span class="line">abc segment ;定义一个段，名称为abc</span><br><span class="line">mov ax,<span class="number">2</span>;写入汇编指令</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br><span class="line"></span><br><span class="line">abd ends      </span><br><span class="line">end ;程序结束处<span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>程序的返回:一个程序结束后将CPU的控制权交还给使它得以运行的程序的过程。应该在程序的末尾添加返回的程序段。</p>
<blockquote>
<p>codesg：放在segment前面，作为一个段的名称，这个段的名称最终将被编译、连接程序，称为一个段的段地址 。</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00H</span><br><span class="line">int 21H ;第21号中断</span><br><span class="line">;这两条指令说实现的功能就是程序返回。123</span><br></pre></td></tr></table></figure>

<ul>
<li>语法错误和逻辑错误</li>
</ul>
<h2 id="4-3-编辑源程序"><a href="#4-3-编辑源程序" class="headerlink" title="4.3 编辑源程序"></a>4.3 编辑源程序</h2><ul>
<li>使用编辑器编辑，扩展名为.asm</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assume cs:ABC</span><br><span class="line">ABC segment</span><br><span class="line">    mov ax,2</span><br><span class="line">    add ax,ax</span><br><span class="line">    add ax,ax</span><br><span class="line">    mov ax,4c00H</span><br><span class="line">    int 21h</span><br><span class="line">ABC ends</span><br><span class="line">end123456789</span><br></pre></td></tr></table></figure>

<h2 id="4-4-编译"><a href="#4-4-编译" class="headerlink" title="4.4 编译"></a>4.4 编译</h2><ul>
<li><p>masn和 1.asm在同一目录中，dos下使用masm 1.asm命令即可生产1.obj文件。<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516134717267.png" alt="源程序文件和masm文件在同一目录下"></p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516134733996.png" alt="编译源程序"></p>
</li>
</ul>
<h2 id="4-5-连接"><a href="#4-5-连接" class="headerlink" title="4.5 连接"></a>4.5 连接</h2><ul>
<li><p>link 1.obj，生成exe文件，摁enter忽略编译程序提示输入的信息。</p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516134809731.png" alt="连接程序"></p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516134828737.png" alt="连接生成exe"></p>
</li>
<li><p>当源程序很大时，可以将它分成多个源程序文件编译，每个源程序编译成目标文件后再用连接程序将他们连接到一起，生成一个可执行文件。或者程序中调用了某个库文件中的子程序，需要将这个库文件和该目标文件连接到一起，生成一个可执行文件。或者一个源程序编译后得到存有机器码的目标文件，目标文件中的有些内容还不能直接生成可执行文件，连接程序将此内容处理为最终的可执行文件信息。</p>
</li>
</ul>
<h2 id="4-6-简化编译和连接"><a href="#4-6-简化编译和连接" class="headerlink" title="4.6 简化编译和连接"></a>4.6 简化编译和连接</h2><ul>
<li>使用ml命令，ml 1.asm</li>
</ul>
<h2 id="4-7-exe的执行"><a href="#4-7-exe的执行" class="headerlink" title="4.7 exe的执行"></a>4.7 exe的执行</h2><ul>
<li>为兼容16位的程序，使用dosbox运行。</li>
</ul>
<h2 id="4-8-可执行文件中的程序转入内存并运行的原理"><a href="#4-8-可执行文件中的程序转入内存并运行的原理" class="headerlink" title="4.8 可执行文件中的程序转入内存并运行的原理"></a>4.8 可执行文件中的程序转入内存并运行的原理</h2><ul>
<li><p>在dos中可执行文件中的程序p1若要运行吗必须有一个正在运行的程序p2将p1从可执行文件中加载如内存，将CPU的控制权交给它，p1才能得以运行；当p1运行完毕后，应该将CPU的控制权交还给使它de’yi 运行的程序p2。</p>
</li>
<li><p>汇编程序从写出到执行的过程：编程 -&gt; 编译 -&gt; 连接 -&gt; 加载 -&gt; 内存中的程序 -&gt; 运行</p>
</li>
<li><p>在dos系统中.exe文件中的加载过程</p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516134954833.png" alt="exe文件中程序的加载过程"></p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516135020850.png" alt="psp的内容"></p>
</li>
</ul>
<h2 id="4-9-程序执行过程的跟踪"><a href="#4-9-程序执行过程的跟踪" class="headerlink" title="4.9 程序执行过程的跟踪"></a>4.9 程序执行过程的跟踪</h2><ul>
<li>使用debug(xp以上的系统在dosbox中使用)来跟踪一个程序的运行过程。</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516135110577.png" alt="使用debug来跟踪程序运行"></p>
<hr>
<h1 id="五、-BX-和loop指令"><a href="#五、-BX-和loop指令" class="headerlink" title="五、[BX]和loop指令"></a>五、[BX]和loop指令</h1><h2 id="引言-3"><a href="#引言-3" class="headerlink" title="引言"></a>引言</h2><ul>
<li>约定符号()来表示一个寄存器或者一个内存单元中的内容。<strong>例如</strong>(ax)=0010H表示ax中的内容为0010H；(21000H)=0010H，表示2000:1000处的内容为0010H。</li>
<li>约定符号idata表示常量。</li>
</ul>
<h2 id="5-1-BX"><a href="#5-1-BX" class="headerlink" title="5.1 [BX]"></a>5.1 [BX]</h2><ul>
<li><strong>inc指令是自增1的意思</strong></li>
<li>和[0]有些类似，[0]表示内存单元，它的偏移地址是0。[bx]也是表示一个内存单元，它的内存偏移地址在bx中。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bx,0</span><br><span class="line">mov ax,[bx]</span><br><span class="line">mov al,[bx]123</span><br></pre></td></tr></table></figure>

<ul>
<li><p>用以下两种信息描述一个内存单元：</p>
<ul>
<li><p>1、内存单元的地址；</p>
</li>
<li><p>2、内训单元的长度(类型)。</p>
<blockquote>
<p>我们用[0]表示一个内训单元时，0表示单元的偏移地址，段地址默认在DS中，单元的长度(类型)可以由具体指令中的其他的操作对象(比如说寄存器)指出。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[0];0对应的字单元，主要单位要看操作对象(寄存器)</span><br><span class="line">mov al,[0];字节12</span><br></pre></td></tr></table></figure>

<h2 id="5-2-loop指令"><a href="#5-2-loop指令" class="headerlink" title="5.2 loop指令"></a>5.2 loop指令</h2><ul>
<li>指令的格式是loop 标号。CUP执行loop指令时要进两步操作：<ul>
<li><strong>CX中存放循环的次数，执行时CX中的内容自减1。相当于C的do while</strong></li>
<li><strong>判断CX中的值，不为0则转至标号处执行程序，为0则向下执行。</strong></li>
</ul>
</li>
<li>通常loop指令来实现循坏功能CX中存放循环的次数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">       code segment</span><br><span class="line">       mov ax,2</span><br><span class="line">       add ax,ax</span><br><span class="line"></span><br><span class="line">       mov ax,4c00H</span><br><span class="line">       int 21H</span><br><span class="line">code ends</span><br><span class="line">end123456789</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">;计算2^3</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">     mov ax,2</span><br><span class="line">     add ax,ax</span><br><span class="line">     add,ax,ax</span><br><span class="line"></span><br><span class="line">     mov ax,4c00H</span><br><span class="line">     int 21h</span><br><span class="line">code ends</span><br><span class="line">end1234567891011</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">;计算2^12</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:  mov ax,2</span><br><span class="line">        mov cx,11</span><br><span class="line">      p:add,ax,ax       </span><br><span class="line">        loop p;p是标号</span><br><span class="line"></span><br><span class="line">       mov ax,4c00H;masm默认数字是十进制</span><br><span class="line">       int 21H</span><br><span class="line">code ends</span><br><span class="line">end start123456789101112</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">;编程计算123*236，结果放在ax中</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,0</span><br><span class="line">      mov cx,236</span><br><span class="line">   an:add ax,123</span><br><span class="line">     loop an</span><br><span class="line">      mov ax,4c00H</span><br><span class="line">      int 21H</span><br><span class="line">code ends</span><br><span class="line">end start1234567891011</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,0</span><br><span class="line">      mov cx,123</span><br><span class="line">  pa:add ax,236</span><br><span class="line">      loop pa</span><br><span class="line"></span><br><span class="line">      mov ax,4c00H</span><br><span class="line">      int 21H</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start123456789101112</span><br></pre></td></tr></table></figure>

<h2 id="5-3-在Debug中跟踪用loop指令实现的循环程序"><a href="#5-3-在Debug中跟踪用loop指令实现的循环程序" class="headerlink" title="5.3 在Debug中跟踪用loop指令实现的循环程序"></a>5.3 在Debug中跟踪用loop指令实现的循环程序</h2><ul>
<li><strong>注意：在汇编源程序中数据不能以字母开头，有字母的在前面加0处理。</strong></li>
<li>t命令单步执行、G命令和P命令。</li>
<li><strong>使用汇编金手指查阅指令。</strong></li>
</ul>
<h2 id="5-4-Debug和汇编编译器Masm对指令的不同处理"><a href="#5-4-Debug和汇编编译器Masm对指令的不同处理" class="headerlink" title="5.4 Debug和汇编编译器Masm对指令的不同处理"></a>5.4 Debug和汇编编译器Masm对指令的不同处理</h2><ul>
<li><p><strong>Degug中mov ax,[0]，表示将ds:0处的数据存入al中。ah=0，因为一个内存单元是8位的，ax是16位的，同位存储。而编译器[0]会被当作0处理</strong></p>
</li>
<li><p>将内存2000:0、2000:1、2000:2、2000:3单元中的数据(字节)送入阿al、bl、cl、dl中。</p>
<ul>
<li>debug中：</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516183617791.png" alt="debug 1"></p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516183634486.png" alt="debug 3"></p>
<ul>
<li>在MASM中：</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516183712370.png" alt="1masmtest"></p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516183806106.png" alt="masmtest2"></p>
<ul>
<li><strong>要在编译器中实现用偏移地址[]中的内容传送先bx来代替，mov 偏移地址,bx 再 mov al,[bx]。如要直接使用[ ]则要加上段地址ds:[偏移地址]</strong></li>
</ul>
</li>
<li><p>在MASM中：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,[0] ;将al赋值0</span><br><span class="line">mov al,ds[0] ;将al赋值段地址为ds，偏移地址为0的内存单元中的内容</span><br><span class="line">mov al,[bx] ;默认段地址为ds，将al赋值偏移地址为bx</span><br><span class="line">mov al,ds:[bx] ;将al赋值段地址为ds，偏移地址为bx1234</span><br></pre></td></tr></table></figure>

<h2 id="5-5-loop和-BX-的联合应用"><a href="#5-5-loop和-BX-的联合应用" class="headerlink" title="5.5 loop和[BX]的联合应用"></a>5.5 loop和[BX]的联合应用</h2><ul>
<li>可以用循环来解决处理地址连续的内存单元中的数据的问题，用变量来给出内存单元的地址。</li>
</ul>
<h2 id="5-6-段前缀"><a href="#5-6-段前缀" class="headerlink" title="5.6 段前缀"></a>5.6 段前缀</h2><ul>
<li>出现在访问内存单元的指令中用显式地指明内存单元的段地址的ds、cs、ss、es称为段前缀。<strong>没有显式地给出内存单元的段地址则默认在ds中。</strong></li>
</ul>
<h2 id="5-7-一段安全的空间"><a href="#5-7-一段安全的空间" class="headerlink" title="5.7 一段安全的空间"></a>5.7 一段安全的空间</h2><blockquote>
<p>在8086模式中，随意向一段内存空间写入数据是危险的，因为这段空间中可能存放着重要的系统数据或代码。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    mov ax,0</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ds:[26H],ax</span><br><span class="line">    mov ax,4c00H</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end123456789</span><br></pre></td></tr></table></figure>

<ul>
<li><p>但笔者在练习的时候出现dosbox下debug卡死</p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516184105129.png" alt="dangeroustest"></p>
</li>
<li><p>dos下0:200H<del>0:2FFH的256个字节的空间是安全的，dos和其他合法程序一般都不会使用这段空间。内存0000:0000</del>0000:03FF大小为1kb的空间是系统存放中断处理程序入口地址的中断向量表。一般情况下0:200H~0:2FFH的256个字节的空间所对应的中断向量表都是空的，操作系统和其他应用程序都不占用。<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516184158629.png" alt="dos安全空间"></p>
</li>
</ul>
<h2 id="5-8-段前缀的使用"><a href="#5-8-段前缀的使用" class="headerlink" title="5.8 段前缀的使用"></a>5.8 段前缀的使用</h2><ul>
<li>将内存ffff:0~ffff:b段单元中的数据拷贝到0:200 ~ 0:20b单元中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">          mov bx,0 ;(bx)&#x3D;0，偏移地址从0开始</span><br><span class="line">          mov cx,12 ;(cx)&#x3D;12，循环12次</span><br><span class="line">      s:  mov ax,offffh</span><br><span class="line">          mov ds,ax ;(ds)&#x3D;0ffffh</span><br><span class="line">          mov dl,[bx] ;(ds)&#x3D;((ds)*16+(bx))，将ffff:bx中的数据送入dl</span><br><span class="line">          mov ax,0020h</span><br><span class="line">          mov ds,ax ;(ds)&#x3D;0020h</span><br><span class="line">          mov [bx],dl ;((ds)*16+(bx))&#x3D;dl，将数据送入0020:bx</span><br><span class="line">          inc bx ;(bx)&#x3D;(bx)+1</span><br><span class="line">          loop s</span><br><span class="line"></span><br><span class="line">          mov ax,4c00h</span><br><span class="line">          int 21h</span><br><span class="line">code ends</span><br><span class="line">end1234567891011121314151617</span><br></pre></td></tr></table></figure>

<ul>
<li>两个内存单元相差64KB则不再同一个段里，需要设置ds的值两次，效率不高。</li>
<li>使用 es(附加段)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">;优化后的代码，优化了两次设置ds</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">           mov ax,offffh</span><br><span class="line">           mov ds,ax ;(ds)&#x3D;0ffffh</span><br><span class="line">           mov ax,0020h</span><br><span class="line">           mov es,ax ;(es)&#x3D;0020H</span><br><span class="line">           mov bx,0 ;(bx)&#x3D;0，此时ds:bx指向ffff:0，es:bx指向0020:0</span><br><span class="line">           mov cx,12 ;(cx)&#x3D;12，循环12次</span><br><span class="line">       s:  mov dl,[bx] ;(ds)&#x3D;((ds)*16+(bx))，将ffff:bx中的数据送入dl</span><br><span class="line">           mov es:[bx],dl ;((es)*16+(bx))&#x3D;dl，将数据送入0020:bx</span><br><span class="line">           inc bx ;(bx)&#x3D;(bx)+1</span><br><span class="line">           loop s</span><br><span class="line"></span><br><span class="line">           mov ax,4c00h</span><br><span class="line">           int 21h</span><br><span class="line">code ends</span><br><span class="line">end123456789101112131415161718</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="六、包含多个段的程序"><a href="#六、包含多个段的程序" class="headerlink" title="六、包含多个段的程序"></a>六、包含多个段的程序</h1><h2 id="6-1在代码段中使用数据"><a href="#6-1在代码段中使用数据" class="headerlink" title="6.1在代码段中使用数据"></a>6.1在代码段中使用数据</h2><ul>
<li>编程计算0123H、0456H，0abxH、0defH、0fesH、0cbaH、0987H这8个数据的和，结果存放在ax中：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">        dw 0123H,0564H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span><br><span class="line">        ;dw，define word，定义字型数据，db定义字节型数据</span><br><span class="line">        ;由于数据在代码段中，所以段地址是CS</span><br><span class="line">        ;dw定义的数据在最开始的地方，所以偏移地址是0开始</span><br><span class="line">    start:mov bx,0 ;第一条指令</span><br><span class="line">        mov ax,0</span><br><span class="line">        mov cx,8</span><br><span class="line">    s:      add ax,cs:[bx]</span><br><span class="line">        add bx,2</span><br><span class="line">        loop s</span><br><span class="line">        mov ax,4c00H</span><br><span class="line">        int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start ;入口找end12345678910111213141516</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516185351745.png" alt="定义字型数据"></p>
<ul>
<li><strong>end的作用除了通知编译器结束之外还有告诉编译器程序的入口在什么地方。</strong></li>
<li>可执行文件中的程序执行过程</li>
</ul>
<h2 id="6-2-在代码段中使用栈"><a href="#6-2-在代码段中使用栈" class="headerlink" title="6.2 在代码段中使用栈"></a>6.2 在代码段中使用栈</h2><ul>
<li>利用栈编程将定义的数据逆序(联想栈的特性)存放：dw 0123H,0564H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">        dw 0123H,0564H,0789H,0abcH,0defH,0fedH,0cbaH,0987H;地址0~15</span><br><span class="line">        dw 0,0,0,0,0,0,0,0;定义8个字型空数据，后面当作栈来使用，地址是16~31</span><br><span class="line"></span><br><span class="line">    start:  </span><br><span class="line">            mov ax,cs</span><br><span class="line">            mov ss,ax</span><br><span class="line">            mov sp,32;设置栈底ss:sp指向cs:32，十进制的32</span><br><span class="line">            mov bx,0</span><br><span class="line">            mov cx,8</span><br><span class="line">           s:push cs:[bx]</span><br><span class="line">            add bx,2</span><br><span class="line">            loop s; 以上代码段0~15个单元中的8个字型数据一次入栈</span><br><span class="line"></span><br><span class="line">            mov bx,0</span><br><span class="line">            mov cx,8</span><br><span class="line">          s0:pop cs:[bx]</span><br><span class="line">            add bx,2</span><br><span class="line">            loop s0;依次出栈8个执行数据到代码段0~15单元中</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start;指明程序入口在start处12345678910111213141516171819202122232425</span><br></pre></td></tr></table></figure>

<ul>
<li>如果对此程序的栈有疑惑，跳转到 3.6 栈和3.10 栈段</li>
</ul>
<h2 id="6-3-将数据、代码、栈放入不同的段"><a href="#6-3-将数据、代码、栈放入不同的段" class="headerlink" title="6.3 将数据、代码、栈放入不同的段"></a>6.3 将数据、代码、栈放入不同的段</h2><ul>
<li>在8086CPU中数据、栈和代码存储空间不能大于64KB。<strong>可以用像定义代码段一样的方法来定义多个段并在其中定义需要的数据，或者通过定义数据来取得栈空间。</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:data,ss:stack;在源程序中为三个段进行有意义的名称</span><br><span class="line">data segment</span><br><span class="line">        dw 0123H,0564H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">        dw 0,0,0,0,0,0,0,0;定义8个字型空数据，后面当作栈来使用</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    start:      </span><br><span class="line">            mov ax,stack</span><br><span class="line">            mov ss,ax</span><br><span class="line">            mov sp,16;设置栈底ss:sp指向stack:16，</span><br><span class="line">            mov ax,data</span><br><span class="line">            mov ds,ax;ds指向data段</span><br><span class="line">            mov bx,0;ds:bx指向data段中的第一个单元</span><br><span class="line">           s:push cs:[bx]</span><br><span class="line">            add bx,2</span><br><span class="line">            loop s; 以上代码段0~16个单元中的8个字型数据一次入栈</span><br><span class="line"></span><br><span class="line">            mov bx,0</span><br><span class="line">            mov cx,8</span><br><span class="line">          s0:pop cs:[bx]</span><br><span class="line">            add bx,2</span><br><span class="line">            loop s0;依次出栈8个执行数据到代码段0~16单元中</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start;指明程序入口在start处12345678910111213141516171819202122232425262728293031</span><br></pre></td></tr></table></figure>

<ul>
<li>程序中指令决定了断中的内容是作为数据处理还是作为指令执行还是作为栈空间使用。</li>
</ul>
<h2 id="检测点-6-1"><a href="#检测点-6-1" class="headerlink" title="检测点 6.1"></a>检测点 6.1</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516185650553.png" alt="检测点6.1"></p>
<h2 id="实验五"><a href="#实验五" class="headerlink" title="实验五"></a>实验五</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:data,ss:stack</span><br><span class="line">data segment</span><br><span class="line">        dw 0123H,0564H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">        dw 0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">    start:  mov ax,stack</span><br><span class="line">            mov ss,ax</span><br><span class="line">            mov sp,16</span><br><span class="line">            mov ax,data</span><br><span class="line">            mov ds,ax</span><br><span class="line">            push ds:[0]</span><br><span class="line">            push ds:[2]</span><br><span class="line">            pop ds:[2]</span><br><span class="line">            pop ds:[0]</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start123456789101112131415161718192021222324</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="七、更灵活的定位内存地址的方法"><a href="#七、更灵活的定位内存地址的方法" class="headerlink" title="七、更灵活的定位内存地址的方法"></a>七、更灵活的定位内存地址的方法</h1><h2 id="7-1-and和or指令"><a href="#7-1-and和or指令" class="headerlink" title="7.1 and和or指令"></a>7.1 and和or指令</h2><ul>
<li><p>and指令：逻辑与指令，按位进行与运算。</p>
<blockquote>
<p>and两个同时为真的结果才为真。</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,01100011B</span><br><span class="line">and al,00111011B</span><br><span class="line">;执行后 al&#x3D;00100011B123</span><br></pre></td></tr></table></figure>

<ul>
<li>可用and指令将操作对象的相应位设为0，其他位不变</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">and al,10111111B;将al第六位设为0</span><br><span class="line">and al,01111111B;将al第七位设为0</span><br><span class="line">and al,11111110B;将al第0位设为0123</span><br></pre></td></tr></table></figure>

<ul>
<li>or指令：逻辑或指令，按位进行或运算。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,01100011B</span><br><span class="line">and al,00111011B</span><br><span class="line">;执行后 al&#x3D;01111011B123</span><br></pre></td></tr></table></figure>

<ul>
<li>可用or指令将操作对象的相应位设为1，其他位不变</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">and al,01000000B;将al第六位设为1</span><br><span class="line">and al,10000000B;将al第七位设为1</span><br><span class="line">and al,00000001B;将al第0位设为1123</span><br></pre></td></tr></table></figure>

<h2 id="7-2-关于ASCII码"><a href="#7-2-关于ASCII码" class="headerlink" title="7.2 关于ASCII码"></a>7.2 关于ASCII码</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516190632064.png" alt="ASCII码表"></p>
<ul>
<li>将字符的ascii码写入显存屏幕就显示出相关的字符。</li>
</ul>
<h2 id="7-3-以字符形式给出数据"><a href="#7-3-以字符形式给出数据" class="headerlink" title="7.3 以字符形式给出数据"></a>7.3 以字符形式给出数据</h2><ul>
<li>用‘’的方式指明数据是以字符的形式给出的。<strong>例如’A’</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">        db &#39;unIx&#39;</span><br><span class="line">        db &#39;foRK&#39;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:  mov al,&#39;a&#39;</span><br><span class="line">            mov bx,&#39;b&#39;</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">code ends</span><br><span class="line">end start123456789101112131415</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516191127691.png" alt="73 ascii"></p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516191202229.png" alt="以字符形式给出数据"></p>
<h2 id="7-4-大小写转换的问题"><a href="#7-4-大小写转换的问题" class="headerlink" title="7.4 大小写转换的问题"></a>7.4 大小写转换的问题</h2><ul>
<li><strong>大写字母比小写字母ASCII大32(20H)。</strong></li>
</ul>
<table>
<thead>
<tr>
<th>大写</th>
<th>二进制</th>
<th>小写</th>
<th>二进制</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>01000001</td>
<td>a</td>
<td>01100001</td>
</tr>
<tr>
<td>B</td>
<td>01000010</td>
<td>b</td>
<td>01100010</td>
</tr>
<tr>
<td>C</td>
<td>01000011</td>
<td>c</td>
<td>01100011</td>
</tr>
<tr>
<td>D</td>
<td>01000100</td>
<td>d</td>
<td>01100100</td>
</tr>
</tbody></table>
<ul>
<li>从第0位开始计算，大写字母ASCII码第五位为0，小写字母ASCII码第五位为1。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">;大小写转换</span><br><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db&#39;BaSiC&#39;</span><br><span class="line">db&#39;iNfOfMaTiOn&#39;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">    start:  mov ax,datasg</span><br><span class="line">            mov ds,ax;设置ds执行datasg段</span><br><span class="line">            mov bx,0;设置(bx)&#x3D;0，ds:bx指向&#39;BaSiC&#39;的第一个字母</span><br><span class="line">            mov cx,5;设置循环次数，因为BaSiC有5个字母</span><br><span class="line">              s:mov al,[bx];将ASCII码从ds:bx所指向的单元中取出</span><br><span class="line">            and al,11011111B;口岸al中ASCII码的第5个位置变为0，变为大写字母</span><br><span class="line">            mov [bx],al;转变后将ASCII码写回单元</span><br><span class="line">            inc bx;(bx)加1，ds:bx指向下一个字母</span><br><span class="line">            loop x</span><br><span class="line">            mov bx,5;设置(bx)&#x3D;5，ds:bx指向&#39;iNfOfMaTiOn&#39;的第一个字母</span><br><span class="line">            mov cx,11</span><br><span class="line">             s0:mov al,[bx]</span><br><span class="line">            or al,00100000B</span><br><span class="line">            mov [bx],al</span><br><span class="line">            inc bx</span><br><span class="line">            loop s0</span><br><span class="line"></span><br><span class="line">            mov ax,4c00H</span><br><span class="line">            int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br><span class="line">123456789101112131415161718192021222324252627282930</span><br></pre></td></tr></table></figure>

<h2 id="7-5-bx-idata"><a href="#7-5-bx-idata" class="headerlink" title="7.5 [bx+idata]"></a>7.5 [bx+idata]</h2><ul>
<li>[bx+idata]表示的是一个内存单元，它的偏移地址为bx+idata</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;[bx+idata]可以写成以下格式</span><br><span class="line">mov ax,[200+bx]</span><br><span class="line">mov ax,200[bx]</span><br><span class="line">mov ax,[bx].2001234</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;使用debug查看内存</span><br><span class="line">mov ax,2000H</span><br><span class="line">mov ds:ax</span><br><span class="line">mov bx,1000H</span><br><span class="line">mov ax,[bx]</span><br><span class="line">mov cx,[bx+1]</span><br><span class="line">add cx,[bx+2]1234567</span><br></pre></td></tr></table></figure>

<h2 id="7-6-用-bx-idata-的方式进行数组的处理"><a href="#7-6-用-bx-idata-的方式进行数组的处理" class="headerlink" title="7.6 用[bx+idata]的方式进行数组的处理"></a>7.6 用[bx+idata]的方式进行数组的处理</h2><ul>
<li>用[bx+idata]的方式进行数组处理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">;改进大小写转换程序</span><br><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db&#39;BaSiC&#39;</span><br><span class="line">db&#39;iNfOfMaTiOn&#39;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">    start:  mov ax,datasg</span><br><span class="line">            mov ds,ax;设置ds执行datasg段</span><br><span class="line">            mov bx,0;设置(bx)&#x3D;0，ds:bx指向&#39;BaSiC&#39;的第一个字母</span><br><span class="line">            mov cx,5;设置循环次数，因为BaSiC有5个字母</span><br><span class="line">          s:mov al,[bx+0];将ASCII码从ds:bx所指向的单元中取出</span><br><span class="line">            and al,11011111B;口岸al中ASCII码的第5个位置变为0，变为大写字母</span><br><span class="line">            mov [bx],al;转变后将ASCII码写回单元</span><br><span class="line">            mov [bx+5];定位第二个字符串的字符</span><br><span class="line">            or al,00100000B</span><br><span class="line">            mov [bx+5],al</span><br><span class="line">            inc bx</span><br><span class="line">            loop s</span><br><span class="line"></span><br><span class="line">            mov ax,4c00H</span><br><span class="line">            int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start12345678910111213141516171819202122232425</span><br></pre></td></tr></table></figure>

<ul>
<li>C语言的形式</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">include&lt;stdio.h&gt;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">char</span> a[<span class="number">5</span>]=<span class="string">"BaSiC"</span>;</span><br><span class="line"><span class="keyword">char</span> b[<span class="number">11</span>]=<span class="string">"iNfOfMaTiOn"</span>;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=a[i]&amp;<span class="number">0xDF</span>;</span><br><span class="line">        b[i]=b[i]|<span class="number">0x20</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;<span class="keyword">while</span>(i&lt;<span class="number">5</span>);</span><br><span class="line">&#125;<span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<h2 id="7-7-SI和DI"><a href="#7-7-SI和DI" class="headerlink" title="7.7 SI和DI"></a>7.7 SI和DI</h2><ul>
<li><strong>SI和DI在8086CPU中和bx功能相近，充当BX的扩充，但是不能分成两个8位寄存器来使用。[SI]段地址默认也是在DS中。</strong></li>
<li>下面的指令实现了相同的功能</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mov bx,0</span><br><span class="line">mov ax,[bx]</span><br><span class="line"></span><br><span class="line">mov si,0</span><br><span class="line">mov ax,[si]</span><br><span class="line"></span><br><span class="line">mov di,0</span><br><span class="line">mov ax,[di]</span><br><span class="line">;-------------</span><br><span class="line">;下面的三组指令也实现了另一个组相同的功能</span><br><span class="line">;-------------</span><br><span class="line">mov bx,0</span><br><span class="line">mov ax,[bx+123]</span><br><span class="line"></span><br><span class="line">mov si,0</span><br><span class="line">mov ax,[si+123]</span><br><span class="line"></span><br><span class="line">mov di,0</span><br><span class="line">mov ax,[di+123]12345678910111213141516171819</span><br></pre></td></tr></table></figure>

<ul>
<li>一般ds:si指向要复制的原始空间，ds:di指向复制的目的空间。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">;用DI和SI实现复制到它后面的数据区中</span><br><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db&#39;welcome to asm!&#39;</span><br><span class="line">db&#39;................&#39;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">    start  :mov ax,datasg</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov si,0</span><br><span class="line">            mov di,16</span><br><span class="line">            mov cx,8</span><br><span class="line">          s:mov ax,[si]</span><br><span class="line">            mov [di],ax</span><br><span class="line">            add si,2</span><br><span class="line">            add di,2</span><br><span class="line">            loop s</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21H</span><br><span class="line">;------</span><br><span class="line">;用数组的思维[bx(si或di)+idata]的方式优化程序</span><br><span class="line">;------</span><br><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db&#39;welcome to asm!&#39;</span><br><span class="line">db&#39;................&#39;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">    start  :mov ax,datasg</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov si,0</span><br><span class="line">            mov cx,8</span><br><span class="line">          s:mov ax,[si];第一个字符串的的第一个元素</span><br><span class="line">            mov [si+16],ax;目标字符串的第二个元素</span><br><span class="line">            add si,2</span><br><span class="line">            loop s</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br><span class="line">123456789101112131415161718192021222324252627282930313233343536373839404142434445</span><br></pre></td></tr></table></figure>

<h2 id="7-8-bx-si-和-bx-di"><a href="#7-8-bx-si-和-bx-di" class="headerlink" title="7.8 [bx+si]和[bx+di]"></a>7.8 [bx+si]和[bx+di]</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2000h</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,1000h</span><br><span class="line">mov si,0</span><br><span class="line">mov ax,[bx+si]</span><br><span class="line">inc si</span><br><span class="line">mov cx,[bx+si]</span><br><span class="line">inc si</span><br><span class="line">mov di,si</span><br><span class="line">mov ax,[bx+di]12345678910</span><br></pre></td></tr></table></figure>

<h2 id="7-9-bx-si-idata-和-bx-di-idata"><a href="#7-9-bx-si-idata-和-bx-di-idata" class="headerlink" title="7.9 [bx+si+idata]和[bx+di+idata]"></a>7.9 [bx+si+idata]和[bx+di+idata]</h2><ul>
<li>常数后要加.<strong>例如</strong>[bx+si].idata或者[bx].idata[si]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2000h</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,1000h</span><br><span class="line">mov si,0</span><br><span class="line">mov ax,[bx+2+si]</span><br><span class="line">inc si</span><br><span class="line">mov cx,[bx+si+2]</span><br><span class="line">inc si</span><br><span class="line">mov di,si</span><br><span class="line">mov ax,[bx+di+2]12345678910</span><br></pre></td></tr></table></figure>

<h2 id="7-10-不同的寻址方式的灵活应用"><a href="#7-10-不同的寻址方式的灵活应用" class="headerlink" title="7.10 不同的寻址方式的灵活应用"></a>7.10 不同的寻址方式的灵活应用</h2><ul>
<li>编程将数据段中每一个单词的头一个字母改为大写字母。</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516192520279.png" alt="数据段中的数据存储结构_2"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">    db&#39;1. file          &#39;;长度刚好都是16个字节</span><br><span class="line">    db&#39;2. edit          &#39;</span><br><span class="line">    db&#39;3. search        &#39;</span><br><span class="line">    db&#39;4. view          &#39;</span><br><span class="line">    db&#39;5. options       &#39;</span><br><span class="line">    db&#39;6. help          &#39;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">      start:</span><br><span class="line">            mov ax,datasg</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov bx,0</span><br><span class="line">            mov cx,6</span><br><span class="line">          s:    </span><br><span class="line">            mov al,[bx+3]</span><br><span class="line">            and al,11011111B</span><br><span class="line">            mov [bx+3],al</span><br><span class="line">            add bx,16</span><br><span class="line">            loop s</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start123456789101112131415161718192021222324252627</span><br></pre></td></tr></table></figure>

<ul>
<li>编程将数据段中每个单词改为大写字母</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516192653168.png" alt="数据段中的数据存储结构2"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">;有bug，问题在于cx的使用，进行二重循环，只用一个循环计数器，造成在进行内层的时候覆盖了外层循环的循环计数值。</span><br><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">    db &#39;ibm             &#39;</span><br><span class="line">    db &#39;dec             &#39;</span><br><span class="line">    db &#39;dos             &#39;</span><br><span class="line">    db &#39;vax             &#39;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">      start:mov ax,datasg</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov bx,0;用bx来定位行</span><br><span class="line">            mov cx,4</span><br><span class="line">         s0:mov si,0;用si来定位列</span><br><span class="line">            mov cx,3</span><br><span class="line">          s:mov al,[bx+si]</span><br><span class="line">            and al,11011111B</span><br><span class="line">            mov [bx+si],al</span><br><span class="line">            inc si</span><br><span class="line">            loop s</span><br><span class="line">            add bx,16</span><br><span class="line">            loop s0</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start12345678910111213141516171819202122232425262728</span><br></pre></td></tr></table></figure>

<ul>
<li>程序没有返回到cmd</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516192911638.png" alt="712bug"></p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516192928623.png" alt="712bug1"></p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516192952451.png" alt="712bug2"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loop s;三次循环后cx等于0了</span><br><span class="line">add bx,16</span><br><span class="line">loop s0;先是cx&#x3D;cx-1再判断时候等于0，此时cx&#x3D;FFFF不为0再循环，变成死循环了123</span><br></pre></td></tr></table></figure>

<ul>
<li>因为loop是和cx一起使用的，不能多用个寄存器来解决loop循环次数的问题。解决的方法是在每次开始内层循环时用dx将外层循环cx的值保存起来，在执行外层循环的loop指令前再回复外层循环的cx的数值。</li>
<li>改进后程序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">    datasg segment</span><br><span class="line">    db &#39;ibm             &#39;</span><br><span class="line">    db &#39;dec             &#39;</span><br><span class="line">    db &#39;dos             &#39;</span><br><span class="line">    db &#39;vax             &#39;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">      start:</span><br><span class="line">            mov ax,datasg</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov bx,0;用bx来定会行</span><br><span class="line">            mov cx,4</span><br><span class="line">         s0:</span><br><span class="line">            mov dx,cx;用dx寄存器来临时存放外层cx的值</span><br><span class="line">            mov si,0;用si来定位列</span><br><span class="line">            mov cx,3</span><br><span class="line">          s:</span><br><span class="line">            mov al,[bx+si]</span><br><span class="line">            and al,11011111B</span><br><span class="line">            mov [bx+si],al</span><br><span class="line">            inc si</span><br><span class="line">            loop s</span><br><span class="line">            add bx,16</span><br><span class="line">            mov cx,dx;在进行外层循环的时候回复cx的值</span><br><span class="line">            loop s0</span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start12345678910111213141516171819202122232425262728293031</span><br></pre></td></tr></table></figure>

<ul>
<li>在上面的程序中，8086 CPU si、cx、ax、bx这些寄存器经常要使用到；cs、ip、ds也不能用，因为cs:ip时刻指向当前指令，ds指向datasg段；那么可用的寄存器就只用dx、di、es、ss、sp、bp等寄存器了。<strong>内存可以解决经常性的数据暂存问题。为了使程序结构清晰便于阅读，应该使用栈</strong></li>
<li>再次被改进的程序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">    datasg segment</span><br><span class="line">    db &#39;ibm             &#39;</span><br><span class="line">    db &#39;dec             &#39;</span><br><span class="line">    db &#39;dos             &#39;</span><br><span class="line">    db &#39;vax             &#39;</span><br><span class="line">    dw 0;定义一个字用来保存cx的值</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">      start:mov ax,datasg</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov bx,0;用bx来定位行</span><br><span class="line">            mov cx,4</span><br><span class="line">         s0:mov ds:[40h],cx;datasg:40h单元存放外层cx的值</span><br><span class="line">            mov si,0;用si来定位列</span><br><span class="line">            mov cx,3</span><br><span class="line">          s:mov al,[bx+si]</span><br><span class="line">            and al,11011111B</span><br><span class="line">            mov [bx+si],al</span><br><span class="line">            inc si</span><br><span class="line">            loop s</span><br><span class="line">            add bx,16</span><br><span class="line">            mov cx,ds:[40h];在进行外层循环的时候回复cx的值</span><br><span class="line">            loop s0</span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start1234567891011121314151617181920212223242526272829</span><br></pre></td></tr></table></figure>

<ul>
<li>再次使用栈改进程序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg,ss:stacksg</span><br><span class="line">datasg segment</span><br><span class="line">    db &#39;ibm             &#39;</span><br><span class="line">    db &#39;dec             &#39;</span><br><span class="line">    db &#39;dos             &#39;</span><br><span class="line">    db &#39;vax             &#39;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">stacksg segment</span><br><span class="line">    dw 0,0,0,0,0,0,0,0;定义一个段，用作栈段，容量为16个字节</span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">      start:mov ax,stacksg</span><br><span class="line">            mov ss,ax</span><br><span class="line">            mov sp,16</span><br><span class="line">            mov ax,datasg</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov bx,0;用bx来定位行</span><br><span class="line">            mov cx,4</span><br><span class="line">         s0:push cx;datasg:40h单元存放外层cx的值</span><br><span class="line">            mov si,0;用si来定位列</span><br><span class="line">            mov cx,3</span><br><span class="line">          s:mov al,[bx+si]</span><br><span class="line">            and al,11011111B</span><br><span class="line">            mov [bx+si],al</span><br><span class="line">            inc si</span><br><span class="line">            loop s</span><br><span class="line">            add bx,16</span><br><span class="line">            pop cx;在进行外层循环的时候回复cx的值</span><br><span class="line">            loop s0</span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start1234567891011121314151617181920212223242526272829303132333435</span><br></pre></td></tr></table></figure>

<ul>
<li>编程将数据段中的每个单词的前四个字母改为大写字母</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516193134171.png" alt="数据段中的数据存储结构3"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg,ss:stacksg</span><br><span class="line"></span><br><span class="line">stacksg segment</span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">    db &#39;1. display      &#39;</span><br><span class="line">    db &#39;2. brows        &#39;</span><br><span class="line">    db &#39;3. replace      &#39;</span><br><span class="line">    db &#39;4. modify       &#39;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">      start:mov ax,stacksg</span><br><span class="line">            mov ss,ax</span><br><span class="line">            mov sp,16</span><br><span class="line">            mov ax,datasg</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov bx,0</span><br><span class="line">            mov cx,4</span><br><span class="line">         s0:push cx</span><br><span class="line">            mov si,0</span><br><span class="line">            mov cx,4</span><br><span class="line">          s:mov al,[bx+si+3]</span><br><span class="line">            and al,11011111B</span><br><span class="line">            mov [bx+si+3],al</span><br><span class="line">            inc si</span><br><span class="line">            loop s</span><br><span class="line">            add bx,16</span><br><span class="line">            pop cx</span><br><span class="line">            loop s0</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start1234567891011121314151617181920212223242526272829303132333435</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="八、数据处理的两个基本问题"><a href="#八、数据处理的两个基本问题" class="headerlink" title="八、数据处理的两个基本问题"></a>八、数据处理的两个基本问题</h1><h2 id="引言-4"><a href="#引言-4" class="headerlink" title="引言"></a>引言</h2><ul>
<li>本章是总结性的内容，数据处理的两个基本问题是<ul>
<li>处理的数据在哪？</li>
<li>要处理的数据有多长？</li>
</ul>
</li>
<li>自定义得描述符：<ul>
<li>reg寄存器<ul>
<li>ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di；</li>
</ul>
</li>
<li>sreg段寄存器<ul>
<li>ds、ss、cs、es。</li>
<li>-</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="8-1-bx、si、di、bp"><a href="#8-1-bx、si、di、bp" class="headerlink" title="8.1 bx、si、di、bp"></a>8.1 bx、si、di、bp</h2><ul>
<li>在8086 CPU中只有bx、si、di、bp这四个寄存器用在[ ]中进行内存单元寻址。<strong>在[]中，组合只能以这四种形式：bx和si、bx和di、bp和si、bp和di</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;以下指令是错误的</span><br><span class="line">mov ax,[ax]</span><br><span class="line">mov ax,[cx]</span><br><span class="line">mov ax,[dx]</span><br><span class="line">mov ax,[ds]</span><br><span class="line">mov ax,[bx+bp]</span><br><span class="line">mov ax,[si+di]1234567</span><br></pre></td></tr></table></figure>

<ul>
<li>正确的指令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx]</span><br><span class="line">mov ax,[si]</span><br><span class="line">mov ax,[di]</span><br><span class="line">mov ax,[bp]</span><br><span class="line">mov ax,[bx+si]</span><br><span class="line">mov ax,[bx+di]</span><br><span class="line">mov ax,[bp+si]</span><br><span class="line">mov ax,[bp+di]</span><br><span class="line">mov ax,[bx+si+idata]</span><br><span class="line">mov ax,[bx+di+idata]</span><br><span class="line">mov ax,[bp+si+idata]</span><br><span class="line">mov ax,[bp+di+idata]123456789101112</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>[bp]的段地址默认在ss中。</strong></li>
</ul>
<h2 id="8-2-机器指令处理的数据所在的位置"><a href="#8-2-机器指令处理的数据所在的位置" class="headerlink" title="8.2 机器指令处理的数据所在的位置"></a>8.2 机器指令处理的数据所在的位置</h2><ul>
<li>绝大部分机器指令时进行数据处理的，大致可以分为3类：读、写、运算。指令在处理前可以在三个地方：CPU内部、内存、端口。</li>
</ul>
<table>
<thead>
<tr>
<th>机器码</th>
<th>汇编指令</th>
<th>指令执行前数据的位置</th>
</tr>
</thead>
<tbody><tr>
<td>89C3</td>
<td>mov bx,[0]</td>
<td>内存，ds:0单元</td>
</tr>
<tr>
<td>89C3</td>
<td>mov bx,ax</td>
<td>CPU内部，ax寄存器</td>
</tr>
<tr>
<td>BB0100</td>
<td>mov bx,1</td>
<td>CPU内部，指令缓冲器</td>
</tr>
</tbody></table>
<h2 id="8-3-汇编语言中数据位置的表达"><a href="#8-3-汇编语言中数据位置的表达" class="headerlink" title="8.3 汇编语言中数据位置的表达"></a>8.3 汇编语言中数据位置的表达</h2><ul>
<li>汇编语言中用三个概念来表达数据的位置。<ul>
<li>1、立即数(idata)</li>
<li>2、寄存器</li>
<li>3、段地址(SA)和偏移地址(EA)</li>
</ul>
</li>
</ul>
<h2 id="8-4-寻址方式总小结"><a href="#8-4-寻址方式总小结" class="headerlink" title="8.4 寻址方式总小结"></a>8.4 寻址方式总小结</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516193307578.png" alt="寻址方式总结_1"></p>
<h2 id="8-5-指令要处理的数据有多长"><a href="#8-5-指令要处理的数据有多长" class="headerlink" title="8.5 指令要处理的数据有多长"></a>8.5 指令要处理的数据有多长</h2><ul>
<li>8086 CPU可以处理byte和word两种数据尺寸。</li>
<li><strong>通过寄存器指明要处理的数据尺寸；push指令只进行字操作，若没有寄存器名存在的情况下，用操作符word ptr或者byte ptr指明内存单元的长度。</strong> 例如</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr ds:[0],1</span><br><span class="line">inc word ptr [bx]</span><br><span class="line">inc word ptr ds:[0]</span><br><span class="line">add byte ptr [bx],21234</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">;假设内存2000:1000 FF FF FF FF FF FF ……</span><br><span class="line">;如果用以下指令</span><br><span class="line">mov ax,2000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov byte ptr [1000H],1</span><br><span class="line">;那么内存中的内容变为</span><br><span class="line">;2000:1000 01 FF FF FF FF FF ……</span><br><span class="line">如果是用以下指令</span><br><span class="line">mov ax,2000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov word ptr [1000H],1</span><br><span class="line">;那么内存中的内容变为</span><br><span class="line">;2000:1000 01 00 FF FF FF ……12345678910111213</span><br></pre></td></tr></table></figure>

<h2 id="8-6-寻址方式的综合应用"><a href="#8-6-寻址方式的综合应用" class="headerlink" title="8.6 寻址方式的综合应用"></a>8.6 寻址方式的综合应用</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516193354516.png" alt="86题目_1"></p>
<ul>
<li>初步汇编代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mov ax,seg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,60h;确定记录物理地址：ds:bx</span><br><span class="line">mov word ptr [bx+0ch],38;寄存器相对寻址     排名字段改为38</span><br><span class="line">add word ptr [bx+0eh],70;收入字段增加70</span><br><span class="line">  </span><br><span class="line">mov si,0;用si来定位产品字符串中的字符</span><br><span class="line">mov byte ptr [bx+10h+si],&#39;V&#39;;相对基址变址寻址</span><br><span class="line">inc si</span><br><span class="line">mov byte ptr [bx+10h+si],&#39;A&#39;</span><br><span class="line">inc si</span><br><span class="line">mov byte ptr [bx+10h+si],&#39;X&#39;123456789101112</span><br></pre></td></tr></table></figure>

<ul>
<li>c语言描述</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">company</span>  /*定义一个公司记录的结构体*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> cn[<span class="number">3</span>]; <span class="comment">/*公司名称*/</span></span><br><span class="line">    <span class="keyword">char</span> hn[<span class="number">9</span>]; <span class="comment">/*总裁姓名*/</span></span><br><span class="line">    <span class="keyword">int</span> pm;     <span class="comment">/*排名*/</span></span><br><span class="line">    <span class="keyword">int</span> sr;     <span class="comment">/*收入*/</span></span><br><span class="line">    <span class="keyword">char</span> cp[<span class="number">3</span>]; <span class="comment">/*著名产品*/</span></span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">compant</span> <span class="title">dec</span>=&#123;</span><span class="string">"DEC"</span>,<span class="string">"Ken Olsen"</span>,<span class="number">137</span>,<span class="number">40</span>,<span class="string">"PDF"</span>&#125;;</span><br><span class="line"><span class="comment">/*定义一个公司记录的变量，内存中将存有一条公司的记录*/</span></span><br><span class="line">mian()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    dec.pm=<span class="number">38</span>;</span><br><span class="line">    dec.sr=dec.sr+<span class="number">70</span>;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    dec.cp[i]=<span class="string">'V'</span>;</span><br><span class="line">    i++;</span><br><span class="line">    dec.cp[i]=<span class="string">'A'</span>;</span><br><span class="line">    i++;</span><br><span class="line">    dec.cp[i]=<span class="string">'X'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="number">123456789101112131415161718192021222324</span></span><br></pre></td></tr></table></figure>

<ul>
<li>按照c语言的风格用汇编写</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mov ax,seg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,60h;记录首地址送入bx</span><br><span class="line">  </span><br><span class="line">mov word ptr [bx].och,38;排名字段改为38</span><br><span class="line">add word ptr [bx].0eh,70;收入字段增加70</span><br><span class="line">  </span><br><span class="line">;产品名字段改为字符串&#39;VAX&#39;</span><br><span class="line">mov si,0</span><br><span class="line">mov byte ptr [bx].10h[si],&#39;V&#39;</span><br><span class="line">inc si</span><br><span class="line">mov byte ptr [bx].10h[si],&#39;A&#39;</span><br><span class="line">inc si</span><br><span class="line">mov byte ptr [bx].10h[si],&#39;X&#39;1234567891011121314</span><br></pre></td></tr></table></figure>

<ul>
<li>多种寻址方式为结构化数据的处理提供了方便。</li>
<li><strong>一般用[bx+idata+si]的方式来访问结构体，用idata定位结构体中的某一数据项，用si定位数组项中的每个元素。</strong> 例如：[bx].idata、[bx].idata[si]。</li>
</ul>
<h2 id="8-7-div指令"><a href="#8-7-div指令" class="headerlink" title="8.7 div指令"></a>8.7 div指令</h2><ul>
<li>div(divide)是除法指令，可用乘法模拟，格式为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div reg(寄存器)</span><br><span class="line">div 内存单元。12</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>除数：8位或16位，在寄存器或内存单元中；被除数：默认放在AX或DX和AX中。</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div byte ptr ds:[0]</span><br><span class="line">div byte ptr [bx+si+idata]</span><br><span class="line">;al放商，ah放余数</span><br><span class="line">  </span><br><span class="line">div word ptr es:[0]</span><br><span class="line">div word ptr [bx+si+idata]</span><br><span class="line">;ax放商，dx放余数1234567</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>除数</th>
<th>被除数</th>
</tr>
</thead>
<tbody><tr>
<td>8位</td>
<td>16为(AX)</td>
</tr>
<tr>
<td>16位</td>
<td>32位(DX高16位+AX低16位)</td>
</tr>
</tbody></table>
<p>- 8位或16位看的是除数。</p>
<table>
<thead>
<tr>
<th>运算</th>
<th>8位</th>
<th>16位</th>
</tr>
</thead>
<tbody><tr>
<td>商</td>
<td>AL</td>
<td>AX</td>
</tr>
<tr>
<td>余数</td>
<td>AH</td>
<td>DX</td>
</tr>
</tbody></table>
<p>- 利用除法指令计算10001/100编程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;被除数1001可用ax寄存器存放，除数100可用8位寄存器存放，要进行8位除法。</span><br><span class="line">mov ax,1001</span><br><span class="line">mov bl,100</span><br><span class="line">div bl</span><br><span class="line">;执行后al的值等于0AH(10)，ah的值等于1(余数为1)。12345</span><br></pre></td></tr></table></figure>

<ul>
<li>利用除法指令计算100001/100编程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;被除数100001大于2^16&#x3D;65535(FFFF)，不能用ax来存放，要用dx和ax两个寄存器联合存放。除数小于255，可用一个8位寄存器存放，但是被除数是32位的，除数应为16位，所以要用一个16位寄存器来存放除数。</span><br><span class="line">;100001的十六进制为186A1H，100001的高16位(1)存放在dx，低16位(86AH)存放在ax中。</span><br><span class="line">mov dx,1</span><br><span class="line">mov ax,86A1H</span><br><span class="line">mov bx,100</span><br><span class="line">div bx</span><br><span class="line">;执行后ax内容等于03E8H(即1000)，dx的值等于1(余数)。1234567</span><br></pre></td></tr></table></figure>

<h2 id="8-8-伪指令dd"><a href="#8-8-伪指令dd" class="headerlink" title="8.8 伪指令dd"></a>8.8 伪指令dd</h2><ul>
<li>db定义字节型数据，dw定于字型数据，<strong>dd 定于 dword(double word双字型数据)</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">        db 1;第一个数据为01h，在data:0处，占1个字节</span><br><span class="line">        dw 1;第二个数据为0001h，在data:1处，占1个字</span><br><span class="line">        dd 1;第三个数据为00000001h，在data:3处，占2个字</span><br><span class="line">data ends12345</span><br></pre></td></tr></table></figure>

<ul>
<li>利用除法指令计算 dd 100001H 除以 dw 100，商放在 dw 0中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">    dd 100001H;低16位存储在ax中，高16位存储在dx中</span><br><span class="line">    dw 100</span><br><span class="line">    dw 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ax,ds:[0];低16位存储在ax中</span><br><span class="line">    mov dx,ds:[2];高16位存储在dx中</span><br><span class="line">    div word ptr ds:[4]</span><br><span class="line">    mov ds:[6],ax123456789101112</span><br></pre></td></tr></table></figure>

<h2 id="8-9-伪指令dup"><a href="#8-9-伪指令dup" class="headerlink" title="8.9 伪指令dup"></a>8.9 伪指令dup</h2><ul>
<li>和db、dw、dd等数据定义伪指令配合使用，用来进行数据的重复。格式 db或者dw或者dd 重复的次数 dup (重复的数据)</li>
<li>例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db 3 dup(0)</span><br><span class="line">;定义了3个字节，它们的值都是0，等同于db 0,0,0。</span><br><span class="line">db 3 dup(0,1,2)</span><br><span class="line">;定义了9个直接，它们是0、1、2、0、1、2、0、1、2，相当于db 0、1、2、0、1、2、0、1、2</span><br><span class="line">db 3 dup(&#39;abc&#39;,&#39;ABC&#39;)</span><br><span class="line">;定义了18个直接，它们是&#39;abcABCabcABCabcABC&#39;123456</span><br></pre></td></tr></table></figure>

<h2 id="实验七-寻址方式在结构化数据访问中的应用"><a href="#实验七-寻址方式在结构化数据访问中的应用" class="headerlink" title="实验七 寻址方式在结构化数据访问中的应用"></a>实验七 寻址方式在结构化数据访问中的应用</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516194436381.png" alt="实验7"><br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516194814140.png" alt="实验7数据"></p>
<ul>
<li>ds已经和data段联系了，数据段不够用时用扩展段ES</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">;初始化阶段</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,table;data已经被占用</span><br><span class="line">mov es,ax</span><br><span class="line">  </span><br><span class="line">mov bx,0</span><br><span class="line">mov si,0</span><br><span class="line">mov di,0</span><br><span class="line">mov cx,21</span><br><span class="line">  </span><br><span class="line">;存放年份,每一个bx就是一个字节</span><br><span class="line">mov al,[bx]</span><br><span class="line">mov es:[di],al</span><br><span class="line">mov al,[bx+1]</span><br><span class="line">mov es:[di+1],al</span><br><span class="line">mov al,[bx+2]</span><br><span class="line">mov es:[di+2],al</span><br><span class="line">mov al,[bx+3]</span><br><span class="line">mov es:[di+3],al</span><br><span class="line">  </span><br><span class="line">;存放公司的总收入</span><br><span class="line">mov ax,[bx+54H];第一个年收入是dd数据类型，段地址为54H</span><br><span class="line">mov dx,[bx+54H]</span><br><span class="line">mov es:[di+5H],ax</span><br><span class="line">mov es:[di+7H],dx</span><br><span class="line">  </span><br><span class="line">;存放公司的人数</span><br><span class="line">mov ax,[si+0A8H];第一个人数的数据段地址为0A8H</span><br><span class="line">mov es:[di+0A8H],ax</span><br><span class="line">  </span><br><span class="line">;计算人均收入并存放</span><br><span class="line">mov ax,[bx+54H]</span><br><span class="line">mov dx,[bx+56H];这两句诗初始化被除数</span><br><span class="line">div word ptr,ds:[si+0A8H];除以人数</span><br><span class="line">mov es:[di+0dH],ax;将商放入指定位置</span><br><span class="line">  </span><br><span class="line">;为下一次循环时存放数据做准备</span><br><span class="line">add bx,4;bx确定年份和收入</span><br><span class="line">add si,2;si确定人数</span><br><span class="line">add di,16;di确定的是每行的列数1234567891011121314151617181920212223242526272829303132333435363738394041</span><br></pre></td></tr></table></figure>

<ul>
<li>完整的程序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:data,es:table</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">        db &#39;1975&#39;,&#39;1976&#39; &#39;1977&#39; ……</span><br><span class="line">        dd 16，22，382 ……</span><br><span class="line">        dw 3,7,9 ……</span><br><span class="line">        ;数据在题目中</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">table segment</span><br><span class="line">        db 21 dup(&#39;year summ ne ?? &#39;)</span><br><span class="line">table ends</span><br><span class="line"></span><br><span class="line">      start:mov ax,data</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov ax,table</span><br><span class="line">            mov es,ax</span><br><span class="line"></span><br><span class="line">            mov bx,0</span><br><span class="line">            mov si,0</span><br><span class="line">            mov di,0</span><br><span class="line">            mov cx,21</span><br><span class="line"></span><br><span class="line">          s:mov al,[bx]</span><br><span class="line">            mov es:[di],al</span><br><span class="line">            mov al,[bx+1]</span><br><span class="line">            mov es:[di+1],al</span><br><span class="line">            mov al,[bx+2]</span><br><span class="line">            mov es:[di+2],al</span><br><span class="line">            mov al,[bx+3]</span><br><span class="line">            mov es:[di+3],al</span><br><span class="line"></span><br><span class="line">            mov ax,[bx+54H]</span><br><span class="line">            mov dx,[bx+56H]</span><br><span class="line">            mov es:[di+5H],ax</span><br><span class="line">            mov es:[di+7H],dx</span><br><span class="line"></span><br><span class="line">            mov ax,[si+0A8H]</span><br><span class="line">            mov es:[di+0AH],ax</span><br><span class="line"></span><br><span class="line">            mov ax,[bx+54H]</span><br><span class="line">            div word ptr ds:[si+0A8H]</span><br><span class="line">            mov es:[di+0dH],ax</span><br><span class="line"></span><br><span class="line">            add bx,4</span><br><span class="line">            add si,2</span><br><span class="line">        loop s</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="九、转移指令的原理"><a href="#九、转移指令的原理" class="headerlink" title="九、转移指令的原理"></a>九、转移指令的原理</h1><h2 id="引言-5"><a href="#引言-5" class="headerlink" title="引言"></a>引言</h2><ul>
<li><strong>可以修改IP，或者同时修改CS和IP的指令统称为转移指令。</strong> 简单的来说可以控制CPU执行内存中某处代码的指令就是转移指令。</li>
<li>8086</li>
<li>CPU的转移行为有<strong>只修改的段内转移</strong>(如jmp ax) 和<strong>同时修改该CS和IP的段间转移</strong>(如jmp 1000:0)。其中段内转移分为<strong>短转移</strong>(IP的修改范围为-128<del>127)和<strong>近转移</strong> (IP的修改范围为-32768</del>32767)。</li>
<li>8086 CPU的转移指令分为以下几类：<ul>
<li>无条件转移指令(如：jmp)</li>
<li>条件转移指令</li>
<li>循环指令(如：loop)</li>
<li>过程</li>
<li>中断</li>
</ul>
</li>
</ul>
<h2 id="9-1-操作符offset"><a href="#9-1-操作符offset" class="headerlink" title="9.1 操作符offset"></a>9.1 操作符offset</h2><ul>
<li>offset是伪指令，由编译器处理，它的功能是取得标号的偏移地址。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">  </span><br><span class="line">  start:mov ax,offset start;相当于 mov ax,偏移地址0，段地址是从0开始</span><br><span class="line">      s:mov ax,offset s;相当于 mov ax,3，标记的是代码段中的第二条指令，第一条指令长度为3个字节，则s的偏移地址为3</span><br><span class="line">  </span><br><span class="line">codesg ends</span><br><span class="line">end start12345678</span><br></pre></td></tr></table></figure>

<h2 id="9-2-jmp指令"><a href="#9-2-jmp指令" class="headerlink" title="9.2 jmp指令"></a>9.2 jmp指令</h2><ul>
<li><strong>jmp为无条件转移，可以只修改IP，也可以同时修改CS和IP。</strong></li>
<li>jmp需要两种信息<ul>
<li>1、转移的目的地址；</li>
<li>2、转移的距离(段间转移、段内转移、段内近转移)。</li>
</ul>
</li>
</ul>
<h2 id="9-3-依据位移进行转移的jmp指令"><a href="#9-3-依据位移进行转移的jmp指令" class="headerlink" title="9.3 依据位移进行转移的jmp指令"></a>9.3 依据位移进行转移的jmp指令</h2><ul>
<li>段内短转移，<strong>jmp short 标号</strong> ，对IP的修改范围是-128~127，一个字节的空间，即向前转移最多128字节，向后最多127字节。short 表明指令进行的是短转移，标号指明了指令要转移的目的地，转移指令结束后<strong>CS:IP指向标号处的指令</strong>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">  </span><br><span class="line">  start:mov ax,0</span><br><span class="line">      jmp short s</span><br><span class="line">      add ax,1</span><br><span class="line">      s:inc ax</span><br><span class="line">  </span><br><span class="line">codesg ends</span><br><span class="line">end start12345678910</span><br></pre></td></tr></table></figure>

<ul>
<li>一般汇编指令中的立即数(idata)会出现在对应的机器指令中。而jmp指令的机器指令并不包含目的地址，包含的是相对于当前IP的转移位移，CPU并不需要目的地址就可以实现对IP的修改。<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516195028618.png" alt="92debug_1"></li>
<li>CPU执行指令的过程 在 2.10 CS和IP</li>
<li>jmp short s 指令的读取和执行过程：<ul>
<li>1、CS:IP指向jmp short s 的机器码；</li>
<li>2、读取指令码进入指令缓冲器</li>
<li>3、 改变IP，(IP)=(IP)+所读取指令的长度，IP指向下一个指令；</li>
<li>4、CPU执行指令缓冲器中的指令；</li>
<li>5、执行后CS:IP继续指向下一个指令</li>
</ul>
</li>
<li>jmp short 标号的功能为(IP)=(IP)+8位位移。<ul>
<li>1、8位为=标号处的地址-jmp指令后的第一个字节的地址；</li>
<li>2、short 指明此处的位移为8位；</li>
<li>3、8位位移的范围为-128~127，用补码表示。</li>
<li>4、8位位移由编译程序在编译时算出的。</li>
</ul>
</li>
<li>jmp near ptr 标号 指令实现段内近转移，功能为(IP)=(IP)+16位位移。<ul>
<li>1、16位为=标号处的地址-jmp指令后的第一个字节的地址；</li>
<li>2、nearptr 指明此处的位移为16位；</li>
<li>3、16位位移的范围为-32769~32767，用补码表示。</li>
<li>4、16位位移由编译程序在编译时算出的。</li>
</ul>
</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516195158771.png" alt="转移位移的计算方法"></p>
<h2 id="9-4-转移的目的地址在指令中的jmp指令"><a href="#9-4-转移的目的地址在指令中的jmp指令" class="headerlink" title="9.4 转移的目的地址在指令中的jmp指令"></a>9.4 转移的目的地址在指令中的jmp指令</h2><ul>
<li><strong>jmp far ptr 段间转移，又称为远转移</strong></li>
<li>jmp far ptr 标号的功能：<ul>
<li>(CS)=标号所在段的段地址；</li>
<li>(IP)=标号所在段总的偏移地址；</li>
<li>far ptr 指明了指令用标号的段地址和偏移地址修改CS和IP。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">  start:mov ax,0</span><br><span class="line">      mov bx,0</span><br><span class="line">      jmp far ptr s</span><br><span class="line">      db 256 dup(0)</span><br><span class="line">    s:add ax,1</span><br><span class="line">        inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start12345678910</span><br></pre></td></tr></table></figure>

<ul>
<li>机器码中包含了转移的目的地址。</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516195225072.png" alt="94debug"></p>
<h2 id="附注3-汇编编译器-masm-exe-对jmp的相关处理"><a href="#附注3-汇编编译器-masm-exe-对jmp的相关处理" class="headerlink" title="附注3 汇编编译器(masm.exe)对jmp的相关处理"></a>附注3 汇编编译器(masm.exe)对jmp的相关处理</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516195935453.png" alt="这里写图片描述"></p>
<h2 id="9-5-转移地址在寄存器中的jmp指令"><a href="#9-5-转移地址在寄存器中的jmp指令" class="headerlink" title="9.5 转移地址在寄存器中的jmp指令"></a>9.5 转移地址在寄存器中的jmp指令</h2><ul>
<li>jmp 16位寄存器，功能是16位寄存器赋值给IP，实现段内的近(短)转移。</li>
<li>参考 2.11 修改CS、IP的指令</li>
</ul>
<h2 id="9-6-转移地址在内存中的jmp指令"><a href="#9-6-转移地址在内存中的jmp指令" class="headerlink" title="9.6 转移地址在内存中的jmp指令"></a>9.6 转移地址在内存中的jmp指令</h2><ul>
<li><p>转移地址在内存中的jmp指令有两种格式：</p>
<ul>
<li><p><strong>1、jmp word ptr内存单元地址(16位只能实现段内转移)。</strong> 功能是从内存单元地址处开始存放一个字(转移的目的偏移地址)，内存单元地址可用寻址方式的格式给出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">jmp word ptr ds:[0]</span><br><span class="line">;相当于 jmp ax，执行后(IP)&#x3D;0123h</span><br><span class="line">      </span><br><span class="line">mov ax,0123H</span><br><span class="line">mov [bx],ax</span><br><span class="line">jmp word ptr [bx]</span><br><span class="line">;执行后(IP)&#x3D;0123h123456789</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>2、jmp dword ptr 内存单元地址(段间转移)。</strong> 功能：从内存单元地址处开始存放两个字型数据，高地址是转移的目的段地址，低地址处是转移的目的偏移地址。(CS)=(内存单元地址+2),(IP)=(内存单元地址)，内存单元地址可用寻址方式的任一格式给出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0]</span><br><span class="line">      </span><br><span class="line">mov ax,0123H</span><br><span class="line">mov [dx],ax</span><br><span class="line">mov word ptr [bx+2],0</span><br><span class="line">jmp dword ptr [bx]</span><br><span class="line">      </span><br><span class="line">;执行后 (CS)&#x3D;0,(IP)&#x3D;0123H CS:IP指向0000:01231234567891011</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="检测点-9-1"><a href="#检测点-9-1" class="headerlink" title="检测点 9.1"></a>检测点 9.1</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516200035483.png" alt="检测点 9.1"></p>
<h2 id="9-7-jcxz指令"><a href="#9-7-jcxz指令" class="headerlink" title="9.7 jcxz指令"></a>9.7 jcxz指令</h2><ul>
<li>指令格式为jcxz 标号，如果cx的值为0，则转移到标号处执行，不为0则向下执行。<ul>
<li>当cx的值为0时，(IP)=(IP)+8位位移，8位位移=标号处的地址-jcxz指令后的第一个字节的地址。</li>
<li>8位位移的范围是-128~127，用补码表。</li>
<li>8位位移由编译器在编译时算出。</li>
</ul>
</li>
<li><strong>jcxz指令是有条件转移指令，所有的条件转移指令都是短指令，在对应的机器码中包含转移的位移而不包含目的地址，对IP的修改范围都为-128-127。</strong></li>
</ul>
<h2 id="检测点-9-2"><a href="#检测点-9-2" class="headerlink" title="检测点 9.2"></a>检测点 9.2</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516200530657.png" alt="检测点9.2_1"></p>
<h2 id="9-8-loop指令"><a href="#9-8-loop指令" class="headerlink" title="9.8 loop指令"></a>9.8 loop指令</h2><ul>
<li><p>loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移而不包含目的地址。</p>
<p>操作i：</p>
<ul>
<li><strong>cx先自减1；</strong></li>
<li><strong>当cx的值不为0时，(IP)=(IP)+8位位移，8位位移=标号处的地址-loop指令后的第一个字节的地址。</strong></li>
<li>8位位移的范围是-128~127，用补码表。</li>
<li>8位位移由编译器在编译时算出。</li>
</ul>
</li>
</ul>
<h2 id="检测点-9-3"><a href="#检测点-9-3" class="headerlink" title="检测点 9.3"></a>检测点 9.3</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170529230442772.png" alt="检测点 9.3"></p>
<h2 id="9-9-根据位移进行转移的意义"><a href="#9-9-根据位移进行转移的意义" class="headerlink" title="9.9 根据位移进行转移的意义"></a>9.9 根据位移进行转移的意义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jmp short 标号</span><br><span class="line">jmp near ptr 标号</span><br><span class="line">jcxz 标号</span><br><span class="line">loop 标号1234</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>它们对IP的修改时根据转移目的地址和转移起始地址自检的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是目的地址的位移距离。方便了程序段在内存中的浮动分配，没有固定目的地址的限制，更灵活。</strong></li>
</ul>
<h2 id="9-10-编译器对转移位移超界的检测"><a href="#9-10-编译器对转移位移超界的检测" class="headerlink" title="9.10 编译器对转移位移超界的检测"></a>9.10 编译器对转移位移超界的检测</h2><ul>
<li>根据位移进行转移的指令，它们的转移范围受到了转移位移的限制，如果在源程序中出现了转移范围超界的问题，在编译时编译器会报错。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:  jmp short s</span><br><span class="line">          db 128 dup(0)</span><br><span class="line">          s:mov ax,0FFFFH</span><br><span class="line">    code ends</span><br><span class="line">end start12345678</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516201316988.png" alt="910err"></p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516201335895.png" alt="910err2"></p>
<h1 id="实验8"><a href="#实验8" class="headerlink" title="实验8"></a>实验8</h1><ul>
<li>实验八可以正常退出<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516201508975.png" alt="test8"></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line"></span><br><span class="line">      start:mov ax,0</span><br><span class="line">          s:nop</span><br><span class="line">            nop;nop占用两个字节，不执行任何操作</span><br><span class="line"></span><br><span class="line">            mov di,offset s</span><br><span class="line">            mov si,offset s2</span><br><span class="line">            mov ax,cs:[si];jmp short s1的机器码给了ax</span><br><span class="line">            mov cs:[di],ax;覆盖到指令 s:nop nop那</span><br><span class="line"></span><br><span class="line">         s0:jmp short s;s那已经被jmp short s1机器码覆盖</span><br><span class="line">         s1:mov ax,0</span><br><span class="line">            int 21h</span><br><span class="line">            mov ax,0</span><br><span class="line">         s2:jmp short s1;jmp -8h，向上跳到s1，s1又向上跳-10字节</span><br><span class="line">            nop</span><br><span class="line">codesg ends</span><br><span class="line">end start   12345678910111213141516171819202122</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516201621398.png" alt="test8debug"></p>
<h1 id="实验9"><a href="#实验9" class="headerlink" title="实验9"></a>实验9</h1><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516201820025.png" alt="实验9"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">            db&#39;welcome to masm!&#39;;定义要显示的字符串(共16字节)</span><br><span class="line">            db 02H,24H,71H;定义字符的属性</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">            dw 8 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">    start:</span><br><span class="line">            mov ax,data</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov ax,stack</span><br><span class="line">            mov ss,ax</span><br><span class="line">            mov sp,10H</span><br><span class="line"></span><br><span class="line">            xor bx,bx;bx清零，用来索引颜色</span><br><span class="line">            mov ax,0b872H;算出屏幕第12行中间的显存的段起始位置放入ax中</span><br><span class="line"></span><br><span class="line">            mov cx,3;s3循环控制行数，要显示三个字符串外循环为3次</span><br><span class="line">        s3: push cx;三个进栈操作为外循环s3保存相关寄存器的值</span><br><span class="line">            push ax;以防止它们的值在内循环中被破坏</span><br><span class="line">            push bx</span><br><span class="line"></span><br><span class="line">            mov es,ax;此时es为屏幕第12行中间的显存的段起始位置</span><br><span class="line"></span><br><span class="line">            mov si,0;si用来索引代码列的字符</span><br><span class="line">            mov di,0;di用来定位目标列</span><br><span class="line"></span><br><span class="line">            mov cx,10H</span><br><span class="line">            ;s1循环控制存放的字符，一个字符串中含有10H个字节内循环为10H次</span><br><span class="line">        s1: mov al,ds:[si]</span><br><span class="line">            mov es:[di],al</span><br><span class="line">            inc si</span><br><span class="line">            add id,2</span><br><span class="line">            loop s1;吃循环实现偶地址中存放字符</span><br><span class="line"></span><br><span class="line">            mov di,1;设置di的值为1，为在显存奇数地址中存放字符的颜色属性做准备</span><br><span class="line">            pop bx</span><br><span class="line">            mov al.ds:[bx+10H];取消颜色属性</span><br><span class="line">            inc bx</span><br><span class="line"></span><br><span class="line">            mov cx,10H;第二个内循环也为10H</span><br><span class="line">        s2: mov es:[di],al</span><br><span class="line">            add di 2</span><br><span class="line">            loop s2;此循环实现奇数地址存放字符的颜色属性</span><br><span class="line"></span><br><span class="line">            ;以下4句为下一趟外循环做准备</span><br><span class="line">            pop ax</span><br><span class="line">            add ax,0AH;将显存的段地址起始地址设置为当前行的下一行</span><br><span class="line">                      ;[在段地址中甲0aH，相当于在偏移地址中加了0a0h(&#x3D;160d)]</span><br><span class="line">            pop cx</span><br><span class="line">            loop s3</span><br><span class="line"></span><br><span class="line">            mov ax，4C00H</span><br><span class="line">            int 21H</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263</span><br></pre></td></tr></table></figure>

<ul>
<li>welcome to masm</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516201938980.png" alt="welcome to masm"></p>
<h1 id="十、CALL和RET指令"><a href="#十、CALL和RET指令" class="headerlink" title="十、CALL和RET指令"></a>十、CALL和RET指令</h1><h2 id="引言-6"><a href="#引言-6" class="headerlink" title="引言"></a>引言</h2><ul>
<li>回想程序之间的加载返回过程。</li>
<li>call和ret指令都是转移指令，它们都修改IP或者同时修改CS和IP，经常被共用来实现程序的设计。</li>
<li>这一章讲解call和ret指令的原理。</li>
</ul>
<h2 id="10-1-ret和retf指令"><a href="#10-1-ret和retf指令" class="headerlink" title="10.1 ret和retf指令"></a>10.1 ret和retf指令</h2><ul>
<li><strong>ret指令用栈中的数据来修改IP的内容，从而实现近转移。</strong></li>
<li>CPU执行ret指令时：<ul>
<li>1、(IP)=((SS)*16+(SP))，指向栈顶</li>
<li>2、(SP)=(SP)+2</li>
</ul>
</li>
<li><strong>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。</strong></li>
<li>CPU执行retf指令时，进行下面两步操作：<ul>
<li>1、(IP)=((SS)*16+(SP))</li>
<li>2、(SP)=(SP)+2</li>
<li>3、(CS)=((SS)*16+(SP))</li>
<li>4、(SP)=(SP)+2</li>
</ul>
</li>
<li>用汇编的语法来解释ret和retf指令：<ul>
<li>CPU执行ret指令相当于进行 POP IP</li>
<li>CPU执行retf指令相当于进行 POP IP和POP CS</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line"> stack segment</span><br><span class="line">              db 16 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">          codesg segment</span><br><span class="line">              mov ax,4c00h</span><br><span class="line">              int 21h</span><br><span class="line"></span><br><span class="line">          start:</span><br><span class="line">              mov ax,stack</span><br><span class="line">              mov ss,ax</span><br><span class="line">              mov sp,16</span><br><span class="line">              mov ax,0</span><br><span class="line"></span><br><span class="line">              push ax</span><br><span class="line"></span><br><span class="line">              mov bx,0</span><br><span class="line">              ret</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start1234567891011121314151617181920212223</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516202038274.png" alt="1012debug_1"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">        db 16 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">    start:</span><br><span class="line">        mov ax,stack</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,16</span><br><span class="line">        mov ax,0</span><br><span class="line">        push cs</span><br><span class="line">        push ax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        mov bx,0</span><br><span class="line">        retf</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start123456789101112131415161718192021222324</span><br></pre></td></tr></table></figure>

<h2 id="检测点-10-1"><a href="#检测点-10-1" class="headerlink" title="检测点 10.1"></a>检测点 10.1</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516202241000.png" alt="检测点10.1"></p>
<h2 id="10-2-call指令"><a href="#10-2-call指令" class="headerlink" title="10.2 call指令"></a>10.2 call指令</h2><ul>
<li>call指令经常跟ret指令配合使用，CPU执行call指令时：<ul>
<li><strong>1、将当前的IP或者CS和IP压入栈；</strong></li>
<li><strong>2、转移(jmp)。</strong></li>
</ul>
</li>
<li>call指令除了不能实现短转移之外，call指令实现转移的方法和jmp指令的原理相同。call指令实现段间的转移(远转移)或近转移。</li>
</ul>
<h2 id="10-3-依据位移进行转移的call指令"><a href="#10-3-依据位移进行转移的call指令" class="headerlink" title="10.3 依据位移进行转移的call指令"></a>10.3 依据位移进行转移的call指令</h2><ul>
<li>call标号(将当前的IP压入栈后转到目标处执行指令)，执行时进行以下操作：<ul>
<li>1、(SP)=(SP)-2<br>((SS)*16+(SP))=(IP)</li>
<li>2、(IP)=(IP)+16位位移；</li>
<li>3、16位位移=标号处的地址减去call指令后的第一个字节的地址。16位位移的范围是-32768~32767，用补码表示。16位位移由编译器编译时算出。</li>
</ul>
</li>
<li>用汇编语法解释call指令：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp near 标号12</span><br></pre></td></tr></table></figure>

<h2 id="检测点-10-2"><a href="#检测点-10-2" class="headerlink" title="检测点 10.2"></a>检测点 10.2</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516202326635.png" alt="检测点10.2"></p>
<h2 id="10-4-转移的目的地址在指令中的call指令"><a href="#10-4-转移的目的地址在指令中的call指令" class="headerlink" title="10.4 转移的目的地址在指令中的call指令"></a>10.4 转移的目的地址在指令中的call指令</h2><ul>
<li>call far ptr 标号 实现的是段间转移，执行时：<ul>
<li>1、CS先自减2；</li>
<li>2、CS的值等于SS的值乘以16加上SP的值，SP自减2，IP的值等于SS的值*16加上SP的值；</li>
<li>3、CS的值等于标号所在的段地址，IP的值等于标号所在的偏移地址.</li>
</ul>
</li>
<li>用汇编语法解释call指令：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp far ptr 标号123</span><br></pre></td></tr></table></figure>

<h2 id="检测点-10-3"><a href="#检测点-10-3" class="headerlink" title="检测点 10.3"></a>检测点 10.3</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516202411776.png" alt="检测点 10.3"></p>
<h2 id="10-5-转移地址在寄存器中的call指令"><a href="#10-5-转移地址在寄存器中的call指令" class="headerlink" title="10.5 转移地址在寄存器中的call指令"></a>10.5 转移地址在寄存器中的call指令</h2><ul>
<li>指令格式是：call 16位寄存器，功能是：<ul>
<li>1、SP的值先自减2；</li>
<li>2、IP的值SS的值乘以16再加上SP的值；</li>
<li>3、 IP的值等于16位寄存器的内容。</li>
</ul>
</li>
<li>用汇编语法解释此种call指令，CPU执行call 16位reg时，相当于：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp 16位寄存器12</span><br></pre></td></tr></table></figure>

<h2 id="检测点-10-4"><a href="#检测点-10-4" class="headerlink" title="检测点 10.4"></a>检测点 10.4</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516202448666.png" alt="检测点 10.4"></p>
<h2 id="10-6-转移地址在内存中的call指令"><a href="#10-6-转移地址在内存中的call指令" class="headerlink" title="10.6 转移地址在内存中的call指令"></a>10.6 转移地址在内存中的call指令</h2><ul>
<li>转移地址在内存中的call指令有两种格式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call word ptr 内存单元地址;段内跳转</span><br><span class="line">call dword ptr 内存单元地址;段间跳转12</span><br></pre></td></tr></table></figure>

<ul>
<li>用汇编语法解释call word ptr 内存单元地址</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp word ptr 内存单元地址12</span><br></pre></td></tr></table></figure>

<ul>
<li>例子：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">call word ptr ds:[0]</span><br><span class="line">;执行后IP的值等于0123H，SP的值等于0EH12345</span><br></pre></td></tr></table></figure>

<ul>
<li>用汇编语法解释call dword ptr 内存单元地址</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp word ptr 内存单元地址123</span><br></pre></td></tr></table></figure>

<ul>
<li>例子：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[0],0</span><br><span class="line">call dword ptr ds:[0]</span><br><span class="line">;执行后IP的值等于0123H，SP的值等于0CH，CS的值等于0123456</span><br></pre></td></tr></table></figure>

<h2 id="检测点-10-5"><a href="#检测点-10-5" class="headerlink" title="检测点 10.5"></a>检测点 10.5</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516202513426.png" alt="检测点10.5"></p>
<h2 id="10-7-call和ret的配合使用"><a href="#10-7-call和ret的配合使用" class="headerlink" title="10.7 call和ret的配合使用"></a>10.7 call和ret的配合使用</h2><ul>
<li>下面的程序返回前，bx中的值是多少？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">      start:</span><br><span class="line">            mov ax,1</span><br><span class="line">            mov cx,3</span><br><span class="line">            call s</span><br><span class="line">            mov bx,ax</span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">          s:</span><br><span class="line">            add ax,ax</span><br><span class="line">            loop s</span><br><span class="line">            ret</span><br><span class="line">code ends</span><br><span class="line">end start123456789101112131415</span><br></pre></td></tr></table></figure>

<ul>
<li>具有一定功能的程序段称为子程序，<strong>用call转去执行，在子程序后面使用ret实现返回。</strong></li>
<li>具有子程序的源程序的框架如下</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516202547067.png" alt="107call"></p>
<h2 id="10-8-mull指令"><a href="#10-8-mull指令" class="headerlink" title="10.8 mull指令"></a>10.8 mull指令</h2><ul>
<li><p>mull指令时乘法指令，</p>
<p>相乘的两个数要么都是8位的，要么都是16位的</p>
<ul>
<li>8位：在AL中和8位寄存器中或内存字节单元中；</li>
<li>16位：在AX中和16位寄存器或内存字单元中。</li>
<li>结果<ul>
<li>8位的存放在AX中；</li>
<li>16位：DX(高位)和AX(低位)中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mull reg</span><br><span class="line"></span><br><span class="line">mull 内存单元</span><br><span class="line">mull byte ptr ds:[0]</span><br><span class="line"></span><br><span class="line">mull word ptr [bx+si+idata]</span><br><span class="line">;(ax)&#x3D;(ax)*((ds)*16+(bx)+(si)+idata)</span><br><span class="line">;(dx)&#x3D;(ax)*((ds)*16+(bx)+(si)+idata)12345678</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">;计算100*10，两个数都小于255，可以做8位乘法</span><br><span class="line">mov ax,100</span><br><span class="line">mov bx,10</span><br><span class="line">mull bl</span><br><span class="line">;结果(ax)&#x3D;1000(03E8H)</span><br><span class="line"></span><br><span class="line">;计算100*1000，1000都大于255，要做16位乘法</span><br><span class="line">mov ax,100;高位自动补零</span><br><span class="line">mov bx,10000</span><br><span class="line">mull bx</span><br><span class="line">;结果(ax)&#x3D;4240H，(dx)&#x3D;000FH，F4240H&#x3D;10000001234567891011</span><br></pre></td></tr></table></figure>

<h2 id="10-9-模块化程序设计"><a href="#10-9-模块化程序设计" class="headerlink" title="10.9 模块化程序设计"></a>10.9 模块化程序设计</h2><ul>
<li>cal和ret指令共同支持汇编语言编程中的模块化设计。</li>
</ul>
<h2 id="10-10-参数和结果传递的问题"><a href="#10-10-参数和结果传递的问题" class="headerlink" title="10.10 参数和结果传递的问题"></a>10.10 参数和结果传递的问题</h2><ul>
<li>用寄存器来存储参数和结果是最常用的方法。对于存放参数的寄存器和存放结果的寄存器，调用者和子程序的读写操作恰恰相反：<ul>
<li>调用者将参数送入参数寄存器，从结果寄存器中取到返回值；</li>
<li>子程序 从参数寄存器中取到参数，将返回值送入结果寄存器。</li>
</ul>
</li>
<li>编程：根据提供的N来计算N^3</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cube:mov ax,bx</span><br><span class="line">               mul bx</span><br><span class="line">               mul bx</span><br><span class="line">               ret1234</span><br></pre></td></tr></table></figure>

<ul>
<li>编程：计算data段中第一组数据的3次方，结果保存在后面一组dword单元中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">          dw 1,2,3,4,5,6,7,8</span><br><span class="line">          dd 8 dup (0)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">          start:</span><br><span class="line">              mov ax,data</span><br><span class="line">              mov ds,ax</span><br><span class="line">              mov si,0;ds:si指向第一组word单元</span><br><span class="line">              mov di,16;ds:di指向第二组dword单元</span><br><span class="line"></span><br><span class="line">              mov cx,8</span><br><span class="line">          s:  mov bx,[si]</span><br><span class="line">              call cube</span><br><span class="line">              mov [di],ax</span><br><span class="line">              mov [di+2],dx</span><br><span class="line">              add si,2;ds:di指向下一个word单元</span><br><span class="line">              add di,4;ds:di指向下一个dword单元</span><br><span class="line">              loop s</span><br><span class="line"></span><br><span class="line">              mov ax,4c00h</span><br><span class="line">              int 21h</span><br><span class="line"></span><br><span class="line">             cube:mov ax,bx</span><br><span class="line">              mul bx</span><br><span class="line">              mul bx</span><br><span class="line">              ret</span><br><span class="line">code ends</span><br><span class="line">end start1234567891011121314151617181920212223242526272829303132</span><br></pre></td></tr></table></figure>

<h2 id="10-11-批量数据的传递"><a href="#10-11-批量数据的传递" class="headerlink" title="10.11 批量数据的传递"></a>10.11 批量数据的传递</h2><ul>
<li>将批量数据放在内存中，然后将他们呢所在内存空间的首地址放在寄存器中，传递给需要的子程序，批量数据的返回结果也是采用同样的方法。除此之外还可以用栈来传递参数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db&#39;conversation&#39;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">    start:</span><br><span class="line">        mov ax,data</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,0;ds:si指向字符串(批量数据)所在空间的首地址</span><br><span class="line"></span><br><span class="line">        mov cx,12;cx存放字符串的长度</span><br><span class="line">        call capital</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">    capital:</span><br><span class="line">        add byte ptr [si],11011111B</span><br><span class="line">        inc si</span><br><span class="line">        loop capital</span><br><span class="line">        ret</span><br><span class="line">code ends1234567891011121314151617181920212223</span><br></pre></td></tr></table></figure>

<h2 id="10-12-寄存器冲突的问题"><a href="#10-12-寄存器冲突的问题" class="headerlink" title="10.12 寄存器冲突的问题"></a>10.12 寄存器冲突的问题</h2><ul>
<li>编程：将一个全是字母，以0结尾的字符串转化为大写</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">capital:</span><br><span class="line">    mov cl,[si];低8位</span><br><span class="line">    mov ch,0;高8位设置为0</span><br><span class="line">    jcxz ok;如果(cx)&#x3D;0则结束，如果不是0则处理</span><br><span class="line">    and byte ptr [si],11011111B</span><br><span class="line">    inc si</span><br><span class="line">    jmp short capital</span><br><span class="line">ok:</span><br><span class="line">    ret123456789</span><br></pre></td></tr></table></figure>

<ul>
<li>编程将data段中的字符串全部转化为大写</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">db&#39;word&#39;,0</span><br><span class="line">db&#39;unix&#39;,0</span><br><span class="line">db&#39;wind&#39;,0</span><br><span class="line">db&#39;good&#39;,0</span><br><span class="line">data ends1234567</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">;此程序有bug，cx有问题</span><br><span class="line">assume cs:code</span><br><span class="line">  </span><br><span class="line">data segment</span><br><span class="line">db&#39;word&#39;,0</span><br><span class="line">db&#39;unix&#39;,0</span><br><span class="line">db&#39;wind&#39;,0</span><br><span class="line">db&#39;good&#39;,0</span><br><span class="line">data ends</span><br><span class="line">  </span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">        mov ax,data</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov bx,0</span><br><span class="line">  </span><br><span class="line">        mov cx,4</span><br><span class="line">    s:</span><br><span class="line">        mov si,bx</span><br><span class="line">        call capital</span><br><span class="line">        add bx,5</span><br><span class="line">        loop s</span><br><span class="line">  </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">  </span><br><span class="line">capital:</span><br><span class="line">        mov cl,[si]</span><br><span class="line">        mov ch,0</span><br><span class="line">        jcxz ok</span><br><span class="line">        and byte ptr [si],11011111b</span><br><span class="line">        inc si</span><br><span class="line">        jmp short capital</span><br><span class="line">    ok:</span><br><span class="line">        ret</span><br><span class="line">  </span><br><span class="line">code ends</span><br><span class="line">end start1234567891011121314151617181920212223242526272829303132333435363738</span><br></pre></td></tr></table></figure>

<h1 id="实验十"><a href="#实验十" class="headerlink" title="实验十"></a>实验十</h1><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522073406637.jfif" alt="test10_1_1"><br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522073441450.jfif" alt="test10_1_2"><br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522073505403.jfif" alt="test10_1_3"></p>
<ul>
<li>实验10.1 显示字符串</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db &#39;welcome to masm!&#39;,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    start:</span><br><span class="line">            mov dh,8;行号</span><br><span class="line">            mov dl,3;列号</span><br><span class="line">            mov cl,2;颜色属性</span><br><span class="line">            mov ax,data</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov si,0</span><br><span class="line">            call show_str</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">        show_str:;子程序</span><br><span class="line">            push cx</span><br><span class="line">            push si</span><br><span class="line"></span><br><span class="line">            mov al,0A0h;每行有80*2&#x3D;160个字节&#x3D;0a0h</span><br><span class="line">            dec dh;行号在显存中下标从0开始，所以减1</span><br><span class="line">            mul dh;相当于从第(n-1)*0a0h个byte单元开始</span><br><span class="line"></span><br><span class="line">            mov bx,ax;定位好的位置偏移地址存放在bx里(行)</span><br><span class="line"></span><br><span class="line">            mov al,2;每个字符占2个字节</span><br><span class="line">            mul dl;定位列，结果ax存放的是定位好的列的位置</span><br><span class="line">            sub ax,2;列号在显存中下标从0开始，又因为是偶字节存放字符，所以减2</span><br><span class="line"></span><br><span class="line">            add bx,ax;此时bx中存放的是行与列的偏移地址</span><br><span class="line"></span><br><span class="line">            mov ax,0B800h;显存开始的地方</span><br><span class="line">            mov es,ax;es中存放的是显存的第0页的起始地段地址</span><br><span class="line"></span><br><span class="line">            mov di,0;di指向显存的偏移地址，确定指向下一个要处理的字符的位置</span><br><span class="line">            mov al,cl;cl存放颜色参数，下边cl要用来临时存放要处理的字符</span><br><span class="line">            mov ch,0;下边cx存放的是每次准备处理的字符</span><br><span class="line">        s:</span><br><span class="line">            mov cl,ds:[si];指向&#39;welcome to masm &#39;,0</span><br><span class="line"></span><br><span class="line">            jcxz ok;cl为0时跳转</span><br><span class="line">            mov es:[bx+di],cl;偶地址存放字符</span><br><span class="line">            mov es:[bx+di+1],al;奇地址存放字符的颜色属性</span><br><span class="line">            inc si</span><br><span class="line">            add di,2;指向了下个字符</span><br><span class="line">            jmp short s ;无条件跳转，jcxz是离开的关键跳</span><br><span class="line"></span><br><span class="line">        ok:</span><br><span class="line">            pop si</span><br><span class="line">            pop cx</span><br><span class="line">            ret;定义结束</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522075507746.png" alt="test101"></p>
<ul>
<li>实验10.2</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ss:stack</span><br><span class="line">  </span><br><span class="line">stack segment</span><br><span class="line">dw 8 dup(0)</span><br><span class="line">stack ends</span><br><span class="line">  </span><br><span class="line">code segment</span><br><span class="line">  </span><br><span class="line">start:</span><br><span class="line">        mov ax,stack</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,10h</span><br><span class="line">        mov ax,4240h</span><br><span class="line">        mov dx,0fh</span><br><span class="line">        mov xx,0ah</span><br><span class="line">  </span><br><span class="line">        call divdw</span><br><span class="line">  </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">  </span><br><span class="line">    divdw:</span><br><span class="line">        push ax;低16位先保存</span><br><span class="line">        mov ax,dx;ax这时是高16位了</span><br><span class="line">        mov dx,0;为了不影响余数位和高位数</span><br><span class="line">        div cx</span><br><span class="line">        mov bx,ax</span><br><span class="line">        pop ax</span><br><span class="line">        div cx</span><br><span class="line">        mov cx,dx</span><br><span class="line">        mov dx,dx</span><br><span class="line">        ret</span><br><span class="line">code ends</span><br><span class="line">end start12345678910111213141516171819202122232425262728293031323334</span><br></pre></td></tr></table></figure>

<ul>
<li>实验10.3</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db 10 dup(0)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,12666</span><br><span class="line">            mov bx,data;指向字符串的首地址</span><br><span class="line">            mov ds,bx</span><br><span class="line">            mov si,0</span><br><span class="line"></span><br><span class="line">            call dtoc;实现将word型整数转化为字符串并存储</span><br><span class="line"></span><br><span class="line">            mov dh,8;打印初始化</span><br><span class="line">            mov dl,3</span><br><span class="line">            mov cl,0cah</span><br><span class="line"></span><br><span class="line">            call show_str;开始打印字符串</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">        dtoc:</span><br><span class="line">            push dx</span><br><span class="line">            push cx</span><br><span class="line">            push ax</span><br><span class="line">            push si</span><br><span class="line"></span><br><span class="line">            mov bx,0;bx在子程序中用来存放位数，用栈来临时存放修改后的字符</span><br><span class="line">        s1:</span><br><span class="line">            mov cx,10d;d表示十进制，cx准备被除，用取余法来取出数字</span><br><span class="line">            mov dx,0</span><br><span class="line"></span><br><span class="line">            div cx;除以十</span><br><span class="line">            mov cx,ax;得到的商复制给cx，要利用jcxz</span><br><span class="line">            jcxz s2;当商为0则跳到s2</span><br><span class="line">            add dx,30h;余数加上30h得到相应的ascii码</span><br><span class="line">            push dx</span><br><span class="line">            inc bx</span><br><span class="line"></span><br><span class="line">            jmp short s1</span><br><span class="line">        s2：</span><br><span class="line">            add ax,30h;当商为0的时候，余数为个位</span><br><span class="line">            push dx</span><br><span class="line"></span><br><span class="line">            inc bx;再进行一次栈操作(补充当商为零而余数不为零时的情况)</span><br><span class="line">            mov cx,bx;总共有bx位进栈，所以循环次数为bx</span><br><span class="line">            mov si,0</span><br><span class="line">        s3:</span><br><span class="line">            pop ax;s3实现将栈中的数据依次出栈放到指定的内存中</span><br><span class="line">            mov [si],al</span><br><span class="line">            inc si</span><br><span class="line">            loop s3</span><br><span class="line"></span><br><span class="line">        okay:</span><br><span class="line">            pop bx</span><br><span class="line">            pop si</span><br><span class="line">            pop ax</span><br><span class="line">            pop dx</span><br><span class="line"></span><br><span class="line">            ret</span><br><span class="line">        show_str:;子程序</span><br><span class="line">            push bx</span><br><span class="line">            push cx</span><br><span class="line">            push si</span><br><span class="line"></span><br><span class="line">            mov al,0A0h;每行有80*2&#x3D;160个字节&#x3D;0a0h</span><br><span class="line">            dec dh;行号在显存中下标从0开始，所以减1</span><br><span class="line">            mul dh;相当于从第(n-1)*0a0h个byte单元开始</span><br><span class="line"></span><br><span class="line">            mov bx,ax;定位好的位置偏移地址存放在bx里(行)</span><br><span class="line">            mov al,2;每个字符占2个字节</span><br><span class="line">            mul dl;定位列，结果ax存放的是定位好的列的位置</span><br><span class="line"></span><br><span class="line">            sub ax,2;列号在显存中下标从0开始，又因为是偶字节存放字符，所以减2</span><br><span class="line">            add bx,ax;此时bx中存放的是行与列的偏移地址</span><br><span class="line"></span><br><span class="line">            mov ax,0B800h;显存开始的地方</span><br><span class="line">            mov es,ax;es中存放的是显存的第0页的起始地段地址</span><br><span class="line"></span><br><span class="line">            mov di,0;di指向显存的偏移地址，确定指向下一个要处理的字符的位置</span><br><span class="line">            mov al,cl;cl存放颜色参数，下边cl要用来临时存放要处理的字符</span><br><span class="line">            mov ch,0;下边cx存放的是每次准备处理的字符</span><br><span class="line">        S:</span><br><span class="line">            mov cl,ds:[si]</span><br><span class="line"></span><br><span class="line">            jcxz ok</span><br><span class="line"></span><br><span class="line">            mov es:[bx+di],cl</span><br><span class="line">            mov es:[bx+di+i],al</span><br><span class="line"></span><br><span class="line">            inc si</span><br><span class="line">            add di,2</span><br><span class="line"></span><br><span class="line">            jmp short s</span><br><span class="line"></span><br><span class="line">        ok:</span><br><span class="line">            pop si</span><br><span class="line">            pop cx</span><br><span class="line">            pop bx</span><br><span class="line">            ret</span><br><span class="line">code ends</span><br><span class="line">end start123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104</span><br></pre></td></tr></table></figure>

<h1 id="十一、标志寄存器"><a href="#十一、标志寄存器" class="headerlink" title="十一、标志寄存器"></a>十一、标志寄存器</h1><h2 id="引言-7"><a href="#引言-7" class="headerlink" title="引言"></a>引言</h2><ul>
<li>CPU内部的寄存器中有一种特殊的寄存器：<ul>
<li>1、用来存储相关指令的某些执行结果；</li>
<li>2、用来为CPU执行相关指令提供行为依据；</li>
<li>3、用来控制CPU的相关工作方式。</li>
</ul>
</li>
<li>8086 CPU的标志寄存器只有16位，其中存储的信息通常被称为程序状态字(PSW)。</li>
<li>本章中的标志寄存器(以下简称为flag)。某些指令将影响标志寄存器中的多个标志位，这些被影响的标记位比较全面地记录ill指令的执行结果，为相关的处理提供了所需的依据。</li>
<li>flag寄存器是按位起作用的，每一位都有专门的含义，记录特定的信息，与其他寄存器不一样。</li>
<li>8086 CPU的flag寄存器的结构：</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522075642999.png" alt="flag"></p>
<ul>
<li>flag的1、3、5、12、13、14、15位在8086 CPU中没有使用，而0、2、4、6、7、8、9、10、11位都具有特殊的含义。</li>
</ul>
<h2 id="11-1-ZF-zero-flag-标志"><a href="#11-1-ZF-zero-flag-标志" class="headerlink" title="11.1 ZF(zero flag)标志"></a>11.1 ZF(zero flag)标志</h2><ul>
<li>flag的第6位是ZF，零标志位，它记录相关指令执行后，结果为0，ZF=1(记录下是0这样的肯定信息)，结果不为0，ZF=0(表示结果非0)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1</span><br><span class="line">  </span><br><span class="line">mov ax,1</span><br><span class="line">and ax,0</span><br><span class="line">;指令执行后，结果为0，则ZF&#x3D;1</span><br><span class="line">  </span><br><span class="line">mov ax,2</span><br><span class="line">sub ax,1</span><br><span class="line">  </span><br><span class="line">mov ax,1</span><br><span class="line">or ax,0</span><br><span class="line">;指令执行后，结果为1，则ZF&#x3D;012345678910111213</span><br></pre></td></tr></table></figure>

<ul>
<li>在8086CPU中,add、sub、mul、div、inc、or、and等它们大多都是运算(逻辑运算或是算术运算)指令，是影响标志寄存器的，而mov、push、pop等传送指令对标志寄存器一般没有影响，因为不会产生结果。</li>
</ul>
<h2 id="11-2-PF标志"><a href="#11-2-PF标志" class="headerlink" title="11.2 PF标志"></a>11.2 PF标志</h2><ul>
<li>flag的第2位是PF，奇偶标志位，记录指令执行后结果所有的二进制位中1的个数。为偶数，PF=1，为奇数PF=0</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">add al,10</span><br><span class="line">;执行结果为00001011B，有3个1，则PF&#x3D;0</span><br><span class="line">  </span><br><span class="line">mov al,1</span><br><span class="line">or al,10</span><br><span class="line">;执行后结果为00000011B，有2个1，则PF&#x3D;11234567</span><br></pre></td></tr></table></figure>

<h2 id="11-3-SF-sign-flag-标志"><a href="#11-3-SF-sign-flag-标志" class="headerlink" title="11.3 SF(sign flag)标志"></a>11.3 SF(sign flag)标志</h2><ul>
<li>flag的第7位是SF符号标志位，记录指令执行后结果为负则SF=1，结果为正，SF=0。<strong>弱国我们将数据当作无符号数来运算，SF的值没有意义，虽然相关的指令影响了它的值。</strong></li>
<li>有符号数与补码<ul>
<li>计算机默认把负数用补码记录。</li>
<li>00000001B，可以看作无符号数1，也可以看作符号数+1；</li>
<li>10000001B，可以看作无符号数129，也可以看作有符号数-127。</li>
</ul>
</li>
<li>补码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,10000001B</span><br><span class="line">add al,1</span><br><span class="line">;执行指令后al的值是10000010B，无符号数130，有符号数-126123</span><br></pre></td></tr></table></figure>

<h2 id="检测点-11-1"><a href="#检测点-11-1" class="headerlink" title="检测点 11.1"></a>检测点 11.1</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522075757000.png" alt="检测点11.1"></p>
<h2 id="11-4-CF-carry-flag-标志"><a href="#11-4-CF-carry-flag-标志" class="headerlink" title="11.4 CF(carry flag)标志"></a>11.4 CF(carry flag)标志</h2><ul>
<li>flag的第0位是CF，进位标志位。一般情况下，在进行无符号运算的时候，它记录了运算结果的最高有效位向更高位的进位值或从更高位的借位值。对于位数为N的无符号数，其对应的二进制信息的最高位为N-1位的最高有效位，假想存在第N位。<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522075820704.png" alt="更高位"></li>
<li>两个8位的数据运算可能产生进位或者借位，由于这个进位值在8位数中无法保存，8086CPU就用flag的CF位来记录这个进位值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov al.98h</span><br><span class="line">add al,al;执行后(al)&#x3D;30h，cf&#x3D;1，cf记录了从最高有效位向更高位的进位值</span><br><span class="line">add al,al;执行后(al)&#x3D;60h，cf&#x3D;0，cf记录了从更高有效位向更高位的进位值</span><br><span class="line">  </span><br><span class="line">mov al,97h</span><br><span class="line">sub al,98h;执行后(al)&#x3D;ffh，cf&#x3D;1，cf记录了向更高位的借位值</span><br><span class="line">sub al,al;执行后(al)&#x3D;0，cf&#x3D;0，cf记录了向更高位的借位值1234567</span><br></pre></td></tr></table></figure>

<h2 id="11-5-OF-overflow-flag-标志"><a href="#11-5-OF-overflow-flag-标志" class="headerlink" title="11.5 OF(overflow flag)标志"></a>11.5 OF(overflow flag)标志</h2><ul>
<li>如果运算结果超出了机器所能表达的范围(对于8位有符号数，机器所能表达的范围是-128~127)将产生溢出，对有符号数而言。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line"></span><br><span class="line">    start:</span><br><span class="line">            mov al,01100010b</span><br><span class="line">            add al,01100011b</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">    code ends</span><br><span class="line">end start123456789101112</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522075847336.png" alt="1150f_1"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">  </span><br><span class="line">code segment</span><br><span class="line">  </span><br><span class="line">start:</span><br><span class="line">        mov al,10001000b</span><br><span class="line">        add al,11110000b</span><br><span class="line">  </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start123456789101112</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522080045212.png" alt="115of2"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov al,98h</span><br><span class="line">            add al,al</span><br><span class="line">            add al,al</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">    code ends</span><br><span class="line">end start</span><br><span class="line">12345678910111213</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522080117865.png" alt="CFdebug"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov al,97h</span><br><span class="line">            sub al,98h</span><br><span class="line">            add al,al</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">    code ends</span><br><span class="line">end start</span><br><span class="line">12345678910111213</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522080147556.png" alt="114cf2"></p>
<ul>
<li><strong>CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位；</strong> CPU用CF位来记录无符号数运算是否产生了进位，用OF位来记录有符号数是否产生了溢出。用SF位来记录结果的符号</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,98d</span><br><span class="line">add al,99d</span><br><span class="line">;对于无符号数运算，98+99没有进位，CF&#x3D;0</span><br><span class="line">;对于有符号数运算，98+99发生溢出，OF&#x3D;11234</span><br></pre></td></tr></table></figure>

<h2 id="检测点-11-2"><a href="#检测点-11-2" class="headerlink" title="检测点 11.2"></a>检测点 11.2</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522080219665.png" alt="检测点11.2"></p>
<h2 id="11-6-adc指令"><a href="#11-6-adc指令" class="headerlink" title="11.6 adc指令"></a>11.6 adc指令</h2><ul>
<li><strong>adc是带有进位加法指令，利用了CF位上记录的进位值。格式:adc操作对象1，操作对象2，功能：操作对象1=操作对象1+操作对象2+CF。</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">mov bx,1</span><br><span class="line">sub bx,ax</span><br><span class="line">adx ax,1</span><br><span class="line">;执行后 (ax)&#x3D;4，相当于计算(ax)+1+CF&#x3D;2+1+1+4</span><br><span class="line">  </span><br><span class="line">mov ax,1</span><br><span class="line">add ax,ax</span><br><span class="line">adc ax,3</span><br><span class="line">;执行后(ax)&#x3D;5，相当于执行(ax)+3+CF&#x3D;2+3+0&#x3D;5</span><br><span class="line">  </span><br><span class="line">mov al,98H</span><br><span class="line">add al,al</span><br><span class="line">adx al,3</span><br><span class="line">;执行后 (ax)&#x3D;34H，相当于执行(ax)+3+CF&#x3D;30H+3+1&#x3D;34H123456789101112131415</span><br></pre></td></tr></table></figure>

<ul>
<li>由adc指令前面的指令决定在执行adc指令的时候加上的CF的值的含义，关键在于所加上的CF的值是被什么指令设置的。如果CF的值是被sub指令设置的，那么它的含义就是借位值；如果是被add指令设置的，那么它的含义就是进位值。加法运算先是低位相加，再高位相加加上低位相加产生的进位值。</li>
<li>编程：计算1EF000H+201000H,结果存放在AX(高16位)和BX(低16位)中。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,001EH</span><br><span class="line">mov bx,0F000H</span><br><span class="line">add bx,1000H</span><br><span class="line">adc ax,0020H1234</span><br></pre></td></tr></table></figure>

<ul>
<li>编程：1EF0001000H+2010001EF0H,结果存放在AX(高16位)、BX(次16位)中和cx(低16位)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,001EH</span><br><span class="line">mov bx,0F000H</span><br><span class="line">mov cx,1000H</span><br><span class="line">add cx,1EF0H</span><br><span class="line">add bx,1000H</span><br><span class="line">adc ax,0020H123456</span><br></pre></td></tr></table></figure>

<ul>
<li>编程：对两个128位数据进行相加</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">    data segment</span><br><span class="line">            db 16 dup(88H)</span><br><span class="line">            db 16 dup(11H)</span><br><span class="line">    data ends</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,data</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov si,0</span><br><span class="line">            mov di,16</span><br><span class="line"></span><br><span class="line">            mov cx,8</span><br><span class="line">            call add128</span><br><span class="line"></span><br><span class="line">            mov ax,4C00H</span><br><span class="line">            int 21H</span><br><span class="line">    add128:</span><br><span class="line">            push ax</span><br><span class="line">            push cx</span><br><span class="line">            push si</span><br><span class="line">            push di</span><br><span class="line"></span><br><span class="line">            sub ax,ax;将CF设置为0</span><br><span class="line">        s:</span><br><span class="line">            mov ax,[si]</span><br><span class="line">            adc ax,[di]</span><br><span class="line">            mov [si],ax</span><br><span class="line">            inc si;不能用add si,2代替</span><br><span class="line">            inc si;因为会影响cf位</span><br><span class="line">            inc di;而loop和inc不会影响</span><br><span class="line">            inc di</span><br><span class="line"></span><br><span class="line">            loop s</span><br><span class="line"></span><br><span class="line">             pop di</span><br><span class="line">             pop si</span><br><span class="line">             pop cx</span><br><span class="line">             pop ax</span><br><span class="line">             ret</span><br><span class="line">    code ends</span><br><span class="line">end start12345678910111213141516171819202122232425262728293031323334353637383940414243</span><br></pre></td></tr></table></figure>

<h2 id="11-7-sbb指令"><a href="#11-7-sbb指令" class="headerlink" title="11.7 sbb指令"></a>11.7 sbb指令</h2><ul>
<li><strong>sbb是带借位减法指令，利用了CF位上记录的借位值。格式：sbb 操作对象1,操作对象2，功能是：操作对象1=操作对象1-操作对象2-CF。</strong></li>
<li>利用sbb指令我们可以对任意大的数据进行减法运算。sbb和adc是基于同样的思想设计的两条指令，在应用思路上sbb和adc类似。</li>
<li>编程：计算003E1000H-00202000H，结果放在ax、bx中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000H</span><br><span class="line">mov ax,003EH</span><br><span class="line">sbb bx,2000H</span><br><span class="line">sbb ax,0020H1234</span><br></pre></td></tr></table></figure>

<h2 id="11-8-cmp指令"><a href="#11-8-cmp指令" class="headerlink" title="11.8 cmp指令"></a>11.8 cmp指令</h2><ul>
<li>cmp是比较指令，功能上相当于减法指令，只是不保存结果。格式：cmp 操作对象1,操作对象2.功能：计算操作对象1-操作对象2但不保存结果，仅仅是根据计算结果对标志寄存器进行设置。</li>
<li>cmp指令运算执行后通过做减法将对标志寄存器产生影响，其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmp ax,ax</span><br><span class="line">;执行后结果为0，ZF&#x3D;1,PF&#x3D;1,SF&#x3D;0,CF&#x3D;0,OF&#x3D;0</span><br><span class="line">  </span><br><span class="line">mov ax,8</span><br><span class="line">mov bx,3</span><br><span class="line">cmp ax,bx</span><br><span class="line">;执行后ax、bx的值不变，ZF&#x3D;0,PF&#x3D;1,SF&#x3D;0,CF&#x3D;0,OF&#x3D;01234567</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp ax,bx1</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522080305742.png" alt="118cmp_1"></p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522080322023.png" alt="118cmp2"></p>
<ul>
<li><p>CPU在执行cmp指令时也包含了对无符号数运算和进行有符号数运算，所以利用cmp指令可以对无符号数进行比较也可以对有符号数进行比较。</p>
</li>
<li><p>单纯地考察SF的值不可能知道结果的正负。因为SF记录的只是可以在计算机中存放的相应位数的结果的正负</p>
<p>(例如：add ah， al执行后，SF记录的是ah中的8位二进制信息所表示的数据的正负)。</p>
<p>如果没有溢出发生的话，实际结果的正负和逻辑上真正结果的正负就一致了。</p>
<p>。例如：22H(34)-0A0H(-96)=130=82H(是-126的补码)，SF=1。</p>
<ul>
<li><strong>1、如果SF=1或SF=0，OF=0，逻辑上真正结果的正负=实际结果的正负。</strong></li>
<li><strong>2、如果SF=1或SF=0，OF=1，逻辑上真正结果的负正=实际结果的正负。</strong></li>
</ul>
</li>
</ul>
<h2 id="11-9-检测比较结果的条件转移指令"><a href="#11-9-检测比较结果的条件转移指令" class="headerlink" title="11.9 检测比较结果的条件转移指令"></a>11.9 检测比较结果的条件转移指令</h2><ul>
<li>与cmp相配使用，根据cmp指令的比较结果(cmp指令执行后相关标志位的值)进行工作的指令。</li>
<li>cmp指令可以同时进行两种比较，无符号数比较和有符号数比较，所以根据cmp指令的比较结果进行转移的指令也分为两种：<ul>
<li>根据无符号数的比较结果进行转移的条件转移指令，它们检测ZF、CF的值；</li>
<li>根据有符号数的比较结果进行转移的条件转移指令，它们检测SF、OF、ZF的值。</li>
</ul>
</li>
<li><strong>它们所检测的标志位都是cmp指令进行无符号数比较时候记录比较结果的标志位。</strong></li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
<th>检测的相关标志位</th>
</tr>
</thead>
<tbody><tr>
<td>je</td>
<td>等于则转移</td>
<td>ZF=1</td>
</tr>
<tr>
<td>jne</td>
<td>不等于则转移</td>
<td>ZF=0</td>
</tr>
<tr>
<td>jb</td>
<td>低于则转移</td>
<td>CF=1</td>
</tr>
<tr>
<td>jnb</td>
<td>不低于则转移</td>
<td>CF=0</td>
</tr>
<tr>
<td>ja</td>
<td>高于则转移</td>
<td>CF=0 and ZF=0</td>
</tr>
<tr>
<td>jna</td>
<td>不高于则转移</td>
<td>CF=1 or ZF=1</td>
</tr>
</tbody></table>
</li>
</ul>
<table>
<thead>
<tr>
<th>j</th>
<th>e</th>
<th>ne</th>
<th>b</th>
<th>nb</th>
<th>a</th>
<th>na</th>
</tr>
</thead>
<tbody><tr>
<td>jump</td>
<td>equal</td>
<td>not equal</td>
<td>below</td>
<td>not below</td>
<td>above</td>
<td>not above</td>
</tr>
</tbody></table>
<ul>
<li><p>编程：如果ah的值等于bh则ah的值等于ah的值加ah的值，否则ah的值等于ah的值加上bh的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    cmp ah,bh</span><br><span class="line">    je s;ZF&#x3D;1则跳转</span><br><span class="line">    add ah,bh</span><br><span class="line">    jmp short ok</span><br><span class="line">s:</span><br><span class="line">    add ah,bh</span><br><span class="line">ok:ret1234567</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>je检测的是ZF的位置，不管je前面是什么指令，只要CPU执行je指令时，ZF=1那么就发生转移。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    mov ax,0</span><br><span class="line">    mov ax,0</span><br><span class="line">    je s</span><br><span class="line">    inc ax</span><br><span class="line">s:</span><br><span class="line">    inc ax</span><br><span class="line">;执行后ax的值等于1，add ax,0使得ZF&#x3D;1，所以je指令将进行转移。1234567</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h3></li>
<li><p>编程:统计data段中数值为8的字节的个数，用ax保存统计结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    ;方案一</span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    data segment</span><br><span class="line">            db 8,11,8,1,8,5,63,38</span><br><span class="line">    data ends</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,data</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov bx,0;ds:bx指向第一个字节</span><br><span class="line">            mov ax,0;初始化累加器</span><br><span class="line">            mov cx,0</span><br><span class="line"></span><br><span class="line">        s:</span><br><span class="line">            cmp byte ptr [bx],8;和8进行比较</span><br><span class="line">            jne next;如果不相等转到next，继续循环</span><br><span class="line">            inc ax;如果相等就计数值加1</span><br><span class="line"></span><br><span class="line">        next:</span><br><span class="line">            inc bx</span><br><span class="line">            loop s;执行后：(ax)&#x3D;3</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">    code ends</span><br><span class="line">end segment 12345678910111213141516171819202122232425262728</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">;方案二</span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    data segment</span><br><span class="line">            db 8,11,8,1,8,5,63,38</span><br><span class="line">    data ends</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,data</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov bx,0;ds:bx指向第一个字节</span><br><span class="line">            mov ax,0;初始化累加器</span><br><span class="line">            mov cx,0</span><br><span class="line"></span><br><span class="line">        s:</span><br><span class="line">            cmp byte ptr [bx],8;和8进行比较</span><br><span class="line">            je ok;如果不相等转到ok，继续循环</span><br><span class="line">            jmp short next;如果不想等就转到next，继续循环</span><br><span class="line"></span><br><span class="line">        ok:</span><br><span class="line">            inc ax;如果相等就计数值加1</span><br><span class="line"></span><br><span class="line">        next:</span><br><span class="line">            inc bx</span><br><span class="line">            loop s;执行后：(ax)&#x3D;3</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">    code ends</span><br><span class="line">end segment12345678910111213141516171819202122232425262728293031</span><br></pre></td></tr></table></figure>
</li>
<li><p>编程:统计data段中数值大于8的字节的个数，用ax保存统计结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    data segment</span><br><span class="line">            db 8,11,8,1,8,5,63,38</span><br><span class="line">    data ends</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,data</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov bx,0;ds:bx指向第一个字节</span><br><span class="line">            mov ax,0;初始化累加器</span><br><span class="line">            mov cx,0</span><br><span class="line"></span><br><span class="line">        s:</span><br><span class="line">            cmp byte ptr [bx],8;和8进行比较</span><br><span class="line">            jna next;如果大于8转到next，继续循环</span><br><span class="line">            inc ax;如果大于就计数值加1</span><br><span class="line"></span><br><span class="line">        next:</span><br><span class="line">            inc bx</span><br><span class="line">            loop s;执行后：(ax)&#x3D;3</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">    code ends</span><br><span class="line">end segment 123456789101112131415161718192021222324252627</span><br></pre></td></tr></table></figure>

<h2 id="检测点-11-3"><a href="#检测点-11-3" class="headerlink" title="检测点 11.3"></a>检测点 11.3</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522080826858.png" alt="检测点11.3"></p>
<h2 id="11-10-DF-direction-flag-标志和串传送指令"><a href="#11-10-DF-direction-flag-标志和串传送指令" class="headerlink" title="11.10 DF(direction flag)标志和串传送指令"></a>11.10 DF(direction flag)标志和串传送指令</h2></li>
<li><p>flag的第10位是DF，方向标志位，在串处理指令中，控制每次操作后si(一般指向原始偏移地址)、di(一般指向目标偏移地址)的增减。</p>
<ul>
<li>DF=0：每次操作后si、di递增；</li>
<li>DF=1，每次操作后so、di递减。</li>
</ul>
</li>
<li><p><strong>movsb(mov string byte)串传送指令，以字节为单位传送。将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器DF位的值将si和di递增1或递减1。movsw，以字为单位传送。将ds:si指向的内存单元中的字送入es:di中，然后根据标志寄存器DF位的值将si和di递增2或递减2。</strong></p>
</li>
<li><p>movsb和movsw进行的是串传送操作中的一个步骤，一般和rep配合使用，格式：rep movsb，rep的作用是根据cx 的值，重复执行后面的串传送指令。</p>
<p>由于每次执行一次movsb指令si和di都会递增或递减指向后一个单元或前个单元，则rep movsb就可以循环实现(cx)个字符的传送。</p>
<ul>
<li>1、传送的原始位置；</li>
<li>2、传送的目的位置；</li>
<li>3、传送的长度；</li>
<li>4、传送的方向。</li>
<li>movsb功能：((es)<em>16+(di))=((ds)</em>16+(si))，如果DF=0，则(si)=(si)+1,(di)=(di)+1;如果DF=1，则(si)=(si)-1，(di)=(di)-1。</li>
</ul>
</li>
<li><p>由于flag的DF位决定着串传送指令执行后，si和di改变的方向，8086CPU提供两条指令对DF位进行设置：</p>
<ul>
<li>cld指令：将标志寄存器的DF位设置为0；</li>
<li>std指令：将标志寄存器的DF位设置为1。</li>
</ul>
<h2 id="11-11-pushf和popf"><a href="#11-11-pushf和popf" class="headerlink" title="11.11 pushf和popf"></a>11.11 pushf和popf</h2></li>
<li><p>pushf的功能 是件标志寄存器的值压栈，popf是从栈中弹出数据m，送入标志寄存器中。pushf和popf为直接访问标志寄存器提供了一种方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;下面的程序执行后ax的值是多少？</span><br><span class="line">mov ax,0</span><br><span class="line">push ax</span><br><span class="line">popf</span><br><span class="line">mov ax,0fff0h</span><br><span class="line">add ax,0010h</span><br><span class="line">pushf</span><br><span class="line">pop ax </span><br><span class="line">and al,11000101b</span><br><span class="line">and ah 00001000b12345678910</span><br></pre></td></tr></table></figure>
</li>
<li><p>编程：用串传送指令将data段总的第一个字符串复制到它后面的空间中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    data segment</span><br><span class="line">            db&#39;welcome to masm!&#39;</span><br><span class="line">            db 16 dup(0)</span><br><span class="line">    data ends</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,data</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov si,0;指向data:0</span><br><span class="line">            mov es,ax</span><br><span class="line">            mov di,16;指向data:16</span><br><span class="line">            mov cx,16;rep循环16次</span><br><span class="line"></span><br><span class="line">            cld;设置DF&#x3D;0，正向传送</span><br><span class="line">            rep movsb</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">    code ends</span><br><span class="line">end start1234567891011121314151617181920212223</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522080919891.png" alt="1110"></p>
</li>
<li><p>用串传送指令将F00H段中的最后16个字符复制到data段中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    data segment</span><br><span class="line">            db 16 dup(0)</span><br><span class="line">    data ends</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,0f00h</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov si,0ffffh;指向f0000:ffff</span><br><span class="line">            mov ax,data</span><br><span class="line">            mov es,ax</span><br><span class="line">            mov di,16;指向data:15</span><br><span class="line">            mov cx,16;rep循环16次</span><br><span class="line"></span><br><span class="line">            std;设置DF&#x3D;1，逆向传送</span><br><span class="line">            rep movsb</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">    code ends</span><br><span class="line">end start1234567891011121314151617181920212223</span><br></pre></td></tr></table></figure>

<h2 id="检测点-11-4"><a href="#检测点-11-4" class="headerlink" title="检测点 11.4"></a>检测点 11.4</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522081015575.png" alt="检测点11.4"></p>
<h2 id="11-12-标志寄存器在Debug中的表示"><a href="#11-12-标志寄存器在Debug中的表示" class="headerlink" title="11.12 标志寄存器在Debug中的表示"></a>11.12 标志寄存器在Debug中的表示</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522081037059.png" alt="debugflag"></p>
<table>
<thead>
<tr>
<th>标志</th>
<th>值为1的标记</th>
<th>值为0的标记</th>
</tr>
</thead>
<tbody><tr>
<td>OF</td>
<td>OV</td>
<td>NV</td>
</tr>
<tr>
<td>SF</td>
<td>NG</td>
<td>PL</td>
</tr>
<tr>
<td>ZF</td>
<td>ZR</td>
<td>NZ</td>
</tr>
<tr>
<td>PF</td>
<td>PE</td>
<td>PO</td>
</tr>
<tr>
<td>CF</td>
<td>CY</td>
<td>NC</td>
</tr>
<tr>
<td>DF</td>
<td>DN</td>
<td>UP</td>
</tr>
</tbody></table>
<h1 id="十二、内中断"><a href="#十二、内中断" class="headerlink" title="十二、内中断"></a>十二、内中断</h1><h2 id="引言-8"><a href="#引言-8" class="headerlink" title="引言"></a>引言</h2></li>
<li><p>中断时CPU处理外部突发事件的一个重要技术。它能使CPU在运行过程中对外部事件发出的中断请求几时进行处理，处理完成后又立即返回断电，基础进行CPU原来的工作。引起中断的原因或是说发出中断请求的来源叫做中断源。根据中断源的不同，可以把中断分为硬件中断和软件中断两大类，而硬件中断又可以分为外部中断和内部中断两类。</p>
</li>
<li><p>外部中断一般是指由计算器外部设备发出的中断请求。如：键盘中断、打印机中断、定时器中断等。外部中断时可以屏蔽的中断，业绩是说利用中断控制器可以屏蔽这些外部设备的中断请求。</p>
</li>
<li><p>内部中断是指因硬件出错(如突然掉电)或运算出错(如除数为0、单步中断)所引起的中断。内部中断是不可屏蔽的。</p>
</li>
<li><p>软件中断其实并不是真正的中断，它们只是可被调用执行的一般程序以及DOS的系统功能调用(int 21)等都是软件中断。</p>
</li>
<li><p>中断的优先权：</p>
<ul>
<li>1、除法出错、溢出中断、软件中断；</li>
<li>2、不可屏蔽中断；</li>
<li>3、可屏蔽中断；</li>
<li>4、单步中断。</li>
</ul>
</li>
<li><p>中断信息中包含有标识中断源的类型码。根据CPU的设计，中断源类型码的作用就是用来定位中断处理程序。</p>
<h2 id="12-1-内中断的产生"><a href="#12-1-内中断的产生" class="headerlink" title="12.1 内中断的产生"></a>12.1 内中断的产生</h2></li>
<li><p>8086CPU内部有以下情况发生时将产生相应的中断信息：</p>
<ul>
<li>1、除法错误；</li>
<li>2、单步执行；</li>
<li>3、执行into指令；</li>
<li>4、执行int指令。</li>
</ul>
</li>
<li><p>8086CPU中的中断类型码如下：</p>
<ul>
<li>1、除法错误：0</li>
<li>2、单步执行：1</li>
<li>3、执行into指令：4</li>
<li>4、执行int指令，该指令格式为int n，n为立即数是提供给CPU的中断类型码。</li>
</ul>
<h2 id="12-2-中断处理程序"><a href="#12-2-中断处理程序" class="headerlink" title="12.2 中断处理程序"></a>12.2 中断处理程序</h2></li>
<li><p>CPU在收到中断信息后立即去执行该中断信息的处理程序。</p>
<h2 id="12-3-中断向量表"><a href="#12-3-中断向量表" class="headerlink" title="12.3 中断向量表"></a>12.3 中断向量表</h2></li>
<li><p>中断向量列表就是中断向量(中断处理程序的入口地址)的列表，其在内存中保存，存放着256个中断源说对应的中断处理程序的入口。8086PC机中断向量表放在内存地址0处。从内存0000:0000到0000:03FF的1024(一个物理地址是由段地址和偏移地址构成，要用4个字节来存放)个单元中存放着中断向量表。</p>
</li>
<li><p>CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址。中断向量表中存放的就是各个类型的处理程序的地址，8位的类型码是个索引。</p>
<h2 id="12-4-中断过程"><a href="#12-4-中断过程" class="headerlink" title="12.4 中断过程"></a>12.4 中断过程</h2></li>
<li><p>用中断码在中断向量表中找到中断处理程序的入口地址，用它来设置CS和IP，使CPU执行中断程序。用中断类型码找到中断向量并用它设置CS和IP，这个工作室由CPU的硬件自动完成的，这个工作的过程被称为中断过程。</p>
</li>
<li><p>8086CPU的中断过程：</p>
<ul>
<li>1、从中断信息中取得中断类型码；</li>
<li>2、标志寄存器的值入栈，以保护标志位；</li>
<li>3、设置标志寄存器的第8位TF和第9位IF的值为0；</li>
<li>4、CS的内容入栈，IP的内容入栈；</li>
<li>5、从内存地址为中断类型码* 4和中断类型码 *4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS。</li>
<li>在最后一步完成后，CPU开始执行由程序员编写的中断处理程序。</li>
</ul>
<h2 id="12-5-中断处理程序和iret指令"><a href="#12-5-中断处理程序和iret指令" class="headerlink" title="12.5 中断处理程序和iret指令"></a>12.5 中断处理程序和iret指令</h2></li>
<li><p>常规的步骤</p>
<ul>
<li>1、保存用到的寄存器；</li>
<li>2、处理中断；</li>
<li>3、 恢复用到的寄存器；</li>
<li>4、 用iret指令返回。</li>
</ul>
</li>
<li><p>iret指令的功能为相应的按顺序恢复之前保存起来的IP、CS地址和标志位寄存器。用汇编语法描述为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br><span class="line">popf123</span><br></pre></td></tr></table></figure>

<h2 id="12-6-除法错误中断的处理"><a href="#12-6-除法错误中断的处理" class="headerlink" title="12.6 除法错误中断的处理"></a>12.6 除法错误中断的处理</h2></li>
<li><p>当CPU执行dvi等处罚指令的时候，如果发生了除法溢出错误，将产生中断类型码为0的中断信息，CPU将检测到这个信息然后引发中断过程，转去执行0号中断所对应的中断处理程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">    codesg segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,1000h</span><br><span class="line">            mov bh,1    </span><br><span class="line">            div bh</span><br><span class="line">    codesg ends</span><br><span class="line"></span><br><span class="line">end start12345678910</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522081718999.png" alt="126"><br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522081751015.png" alt="debug 126"></p>
<h2 id="12-7-编程处理0号中断"><a href="#12-7-编程处理0号中断" class="headerlink" title="12.7 编程处理0号中断"></a>12.7 编程处理0号中断</h2></li>
<li><p>改变0号中断处理程序的功能，在屏幕中间显示字然后再返回操作系统。</p>
<ul>
<li><p>当发生除法溢出时产生0号中断信息，引发中断过程。</p>
<ul>
<li>此时CPU将进行以下工作(中断过程)</li>
<li>当中断0发生时，CPU将转去执行中断处理程序。</li>
<li>先进行相关处理，然后向显示缓冲区送字符串，最后返回。</li>
</ul>
</li>
<li><p>改变后的中断处理程序应该放在内存中，因为除法溢出随时可能发生，CPU随时都可能将CS:IP指向改变后的中断处理程序的入口执行程序。</p>
</li>
<li><p>把程序存入内存，修改向量表(即将内存地址登记在中断向量表的对应表项中)，中断时调用这个内存。</p>
<blockquote>
<p>除法溢出对应的中断类型码为0，它的中断处理程序的入口地址应该从0* 4+2地址单元开始存放，段地址存放在0* 4+2字单元中，偏移地址存放在0*4字单元中。也就是改变后的中断处理程序的段地址0存放在0000:0002字单元中，偏移地址200H存放在0000:0000字单元中。如果要显示的字符串在程序的data段中，那么程序执行完成后返回，它所占用的内存空间被系统释放，在其中存放的信息也可能被别的信息覆盖。</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">          code segment</span><br><span class="line">          start:</span><br><span class="line">                  mov ax,cs</span><br><span class="line">                  mov ds,ax</span><br><span class="line">                  mov si,offset do0;设置ds:di指向源地址</span><br><span class="line">                  mov ax,0</span><br><span class="line">                  mov es,ax</span><br><span class="line">                  mov di,200h;设置es:si指向目的地址</span><br><span class="line">                  mov cx,offset do0end - offset do0;设置cx为传输长度，编译器可以识别加减乘除运算符</span><br><span class="line">                  cld;设置传输方向为正</span><br><span class="line">                  rep movsb</span><br><span class="line"></span><br><span class="line">                  mov ax,0;设置中断向量表</span><br><span class="line">                  mov es,ax</span><br><span class="line">                  mov word ptr es:[0*4],200h</span><br><span class="line">                  mov word ptr es:[0*4+2],0</span><br><span class="line"></span><br><span class="line">                  mov ax,4c00h</span><br><span class="line">                  int 21h</span><br><span class="line">              do0:</span><br><span class="line">                  jmp short do0start</span><br><span class="line">                  db&quot;welcome to masm!&quot;;在代码段中存储数据</span><br><span class="line">              do0start:</span><br><span class="line">                  mov ax,cs</span><br><span class="line">                  mov ds,ax</span><br><span class="line">                  mov si,202h;jmp short do0start这条指令栈两个字节</span><br><span class="line">                  ;显示字符串，设置es:di指向字符串</span><br><span class="line">                  mov ax,0b800h;显存空间，直接显示在显示器上</span><br><span class="line">                  mov es,ax</span><br><span class="line">                  mov di,12*160+36*2;这只es:di指向显存空间的中间位置</span><br><span class="line">                  mov cx,16;设置cx为字符串(welcome to masm！)长度</span><br><span class="line">              s:</span><br><span class="line">                  mov al,[si]</span><br><span class="line">                  mov es:[di],al</span><br><span class="line">                  inc si</span><br><span class="line">                  add di,1</span><br><span class="line">                  mov al,02h</span><br><span class="line">                  mov es:[di],al</span><br><span class="line">                  add di,1</span><br><span class="line">                  loop s</span><br><span class="line"></span><br><span class="line">                  mov ax,4c00h</span><br><span class="line">                  int 21h</span><br><span class="line">              do0end:</span><br><span class="line">                  nop</span><br><span class="line"></span><br><span class="line">          code ends</span><br><span class="line">end start1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522081857031.png" alt="do0"> <img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522081929203.png" alt="do02"></p>
<h2 id="12-8-单步中断"><a href="#12-8-单步中断" class="headerlink" title="12.8 单步中断"></a>12.8 单步中断</h2></li>
<li><p>CPU执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断引发中断过程。单步中断的中断类型码为1，它所引发的中断过程如下：</p>
<ul>
<li>1、取得中断类型码；</li>
<li>2、标志寄存器入栈，TF、IF设置为0；</li>
<li>3、CS、IP入栈；</li>
<li>4、指向指定类型码的中断向量表。</li>
</ul>
<h2 id="12-9-响应中断的特殊情况"><a href="#12-9-响应中断的特殊情况" class="headerlink" title="12.9 响应中断的特殊情况"></a>12.9 响应中断的特殊情况</h2></li>
<li><p>在有些情况下CPU在执行完当前指令后，即便是发生了中断也不会响应。</p>
<blockquote>
<p>在执行完向ss寄存器传送数据的指令后，即便检测到了中断信号CPU也不会响应。因为ss:sp指向栈顶，对他们的设置应该连续完成。如果在执行完设置ss指令后mCPU响应中断引发中断过程，要在栈中压入标志寄存器、CS和IP的值。而ss改变，sp并未改变则ss:sp指向不是正确的栈顶将引发错误。</p>
</blockquote>
</li>
<li><p>我们要将栈顶设置为1000:0，不应该隔开</p>
<table>
<thead>
<tr>
<th>应该</th>
<th>不应该</th>
</tr>
</thead>
<tbody><tr>
<td>mov ax,1000h</td>
<td>mov ax,1000h</td>
</tr>
<tr>
<td>mov ss,ax</td>
<td>mov ss,ax</td>
</tr>
<tr>
<td>mov sp,0</td>
<td>mov ax,0</td>
</tr>
<tr>
<td>mov ax,0</td>
<td>mov sp,0</td>
</tr>
</tbody></table>
<h1 id="十三、int-指令"><a href="#十三、int-指令" class="headerlink" title="十三、int 指令"></a>十三、int 指令</h1><h2 id="引言-9"><a href="#引言-9" class="headerlink" title="引言"></a>引言</h2></li>
<li><p>在第12章中了解中断过程和除法错误中断和单步中断的处理，这章了解int指令。</p>
<h2 id="13-1-int-指令"><a href="#13-1-int-指令" class="headerlink" title="13.1 int 指令"></a>13.1 int 指令</h2></li>
<li><p>int格式：int n，n为中断类型码，它的功能是引发中断过程。CPU执行int n之力量能够，相当引发一个n号的中断过程，可以在程序中使用int指令调用任何一个中断的中断处理程序。执行过程如下：</p>
<ul>
<li><p>中断过程从，此处去执行n号中断的中断处理程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line"></span><br><span class="line">    start:</span><br><span class="line">            mov ax,0b800h</span><br><span class="line">            mov es,ax</span><br><span class="line">            mov byte ptr es:[12*160+40*2],&#39;!&#39;</span><br><span class="line"></span><br><span class="line">            int 0;执行int 0指令，引发中断过程，执行0号中断处理程序</span><br><span class="line">    code ends</span><br><span class="line"> end start123456789101112</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522082205111.png" alt="131dosbox"><br>​</p>
</li>
</ul>
</li>
<li><p>int指令的最终功能和call类似，都是调用一段程序。一般情况下系统将一些具有一定功能的子程序以中断处理程序的方式提供给应用程序调用，也可以自己编写一些中断处理程序供别人使用。</p>
<h2 id="13-2-编写供应用程序调用的中断例程"><a href="#13-2-编写供应用程序调用的中断例程" class="headerlink" title="13.2 编写供应用程序调用的中断例程"></a>13.2 编写供应用程序调用的中断例程</h2></li>
<li><p>中断处理程序简称为中断例程。</p>
</li>
<li><p>实例1：编写、安装中断7ch的中断例程实现求一word型数据的平方。</p>
<ul>
<li>1、编程实现求平方功能的程序；</li>
<li>2、安装程序在0:200处；</li>
<li>3、设置中断向量表将程序的入口地址保存在7ch表项中，使其成为中断7ch的中断例程。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">             ;计算</span><br><span class="line">ssume cs:code</span><br><span class="line">             code segment</span><br><span class="line">             start:</span><br><span class="line">                     mov ax,3456</span><br><span class="line">                     int 7ch</span><br><span class="line">                     add ax,ax</span><br><span class="line">                     adc ax,dx</span><br><span class="line">                     mov ax,4c00h</span><br><span class="line">                     int 21h</span><br><span class="line">             code ends</span><br><span class="line">             end start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             ;安装程序</span><br><span class="line">             assume cs:code</span><br><span class="line">             code segment</span><br><span class="line">             start:</span><br><span class="line">                     mov ax,cs</span><br><span class="line">                     mov ds,ax</span><br><span class="line">                     mov si offset sqr;设置ds:si指向源地址</span><br><span class="line">                     mov ax,0</span><br><span class="line">                     mov es,ax</span><br><span class="line">                     mov di,200h;设置es:di指向目的地址</span><br><span class="line">                     mov cx,offset sqrend- offset sqr;设置cx为传输长度</span><br><span class="line">                     cld;设置传输方向为正</span><br><span class="line">                     rep movsb</span><br><span class="line"></span><br><span class="line">                     mov ax,0</span><br><span class="line">                     mov es,ax</span><br><span class="line">                     mov word ptr es:[7ch*4],200h</span><br><span class="line">                     mov word ptr ws:[7ch*4+2],0</span><br><span class="line">                     mov ax,4c00h</span><br><span class="line">                     int 21h</span><br><span class="line">                 sqr:</span><br><span class="line">                     mul ax</span><br><span class="line">                     iret</span><br><span class="line">                 sqrend:</span><br><span class="line">                     nop</span><br><span class="line">             code ends</span><br><span class="line">end start123456789101112131415161718192021222324252627282930313233343536373839404142</span><br></pre></td></tr></table></figure>
</li>
<li><p>CPU执行int 7ch指令进入中断例程之前，标志寄存器、当前的CS和IP都被压入栈中，在执行完中断例程后，用iret指令恢复int 7ch执行前的标志寄存器和CS和IP的值，从而接着执行应用程序。</p>
</li>
<li><p><strong>int指令和iret指令配合使用与call指令和ret指令配合使用具有相似的思路。</strong></p>
</li>
<li><p>实例2：编写、安装中断7ch的中断例程，实现将一个全是字母，以0为结尾的字符串转化为大写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">             data segment</span><br><span class="line">                     db&#39;conversation&#39;,0</span><br><span class="line">             data ends</span><br><span class="line"></span><br><span class="line">             code segment</span><br><span class="line">             start:</span><br><span class="line">                     mov ax,data</span><br><span class="line">                     mov ds,ax</span><br><span class="line">                     mov si,0</span><br><span class="line">                     int 7ch</span><br><span class="line">                     mov ax,4c00h</span><br><span class="line">                     int 21h</span><br><span class="line">             code ends </span><br><span class="line">             end start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             assume cs:code</span><br><span class="line">             code segment</span><br><span class="line"></span><br><span class="line">             start:</span><br><span class="line">                     mov ax,cs</span><br><span class="line">                     mov ds,ax</span><br><span class="line">                     mov si,offset capital</span><br><span class="line">                     mov ax,0</span><br><span class="line">                     mov es,ax</span><br><span class="line">                     mov di 200h</span><br><span class="line">                     mov cx,offset capitalend - offset capital</span><br><span class="line">                     cld</span><br><span class="line">                     rep movsb</span><br><span class="line"></span><br><span class="line">                     mov ax,0</span><br><span class="line">                     mov es,ax</span><br><span class="line">                     mov word ptr es:[7ch*4],200h</span><br><span class="line">                     mov word ptr es:[7ch*4+2],0</span><br><span class="line"></span><br><span class="line">                     mov ax,4c00h</span><br><span class="line">                     int 21h</span><br><span class="line"></span><br><span class="line">                 capital:</span><br><span class="line">                     push cx</span><br><span class="line">                     push si</span><br><span class="line">                 change:</span><br><span class="line">                     mov cl,[si]</span><br><span class="line">                     mov ch,0</span><br><span class="line">                     jcxz ok</span><br><span class="line">                     and byte ptr [si],11011111b</span><br><span class="line">                     inc si</span><br><span class="line">                     jmp short change</span><br><span class="line">                 ok:</span><br><span class="line">                     pop si</span><br><span class="line">                     pop cx</span><br><span class="line">                     iret</span><br><span class="line"></span><br><span class="line">                 capitalend:</span><br><span class="line">                     nop</span><br><span class="line">             code ends</span><br><span class="line">end start1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162</span><br></pre></td></tr></table></figure>
</li>
<li><p>要注意用到的寄存器冲突。</p>
<h2 id="13-3-对int、iret和栈的深入理解"><a href="#13-3-对int、iret和栈的深入理解" class="headerlink" title="13.3 对int、iret和栈的深入理解"></a>13.3 对int、iret和栈的深入理解</h2></li>
<li><p>中断处理程序和iret指令</p>
</li>
<li><p>编程：用7ch中断例程完成loop指令的功能，在屏幕中间显示80个”!”.</p>
<blockquote>
<p>loop指令需要循环次数和到标号的位移。为了模拟loop指令7ch中断例程应具备下面dec cx和如果cx的值不等于0则转移到标号s处。</p>
</blockquote>
<ul>
<li>int 7ch引发中断过程后，进入7ch中断例程在中断过程中当前的标志寄存器、CS和IP都要压栈。此时压入的CS和IP中的内容分别是调用程序的段地址(可以认为是标号s的段地址)和int 7ch后一条指令的偏移地址(即标号se的偏移地址)。使用iret指令用栈中的内容设置CS、IP，从而实现转移到标号s处。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,0b800h;显存地址</span><br><span class="line">            mov es,ax</span><br><span class="line">            mov di,160*12</span><br><span class="line">            mov bx,offset s- offset se;设置从标号s的转移位移</span><br><span class="line">            mov cx,80</span><br><span class="line">        s:</span><br><span class="line">            mov byte ptr es:[di],&#39;!&#39;</span><br><span class="line">            add di,2</span><br><span class="line">            int 7ch;如果cx的值不等于0则转移到标号s处</span><br><span class="line">        se:</span><br><span class="line">            nop</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ;7ch中断例程</span><br><span class="line">        lp:</span><br><span class="line">            push bp</span><br><span class="line">            mov bp,sp;</span><br><span class="line">            dec cx</span><br><span class="line">            jcxz lpret</span><br><span class="line">            add [bp+2],bx</span><br><span class="line">        lpret:</span><br><span class="line">            pop bp</span><br><span class="line">            iret12345678910111213141516171819202122232425262728293031323334</span><br></pre></td></tr></table></figure>

<h2 id="13-4-BIOD和DOS所提供的中断例程"><a href="#13-4-BIOD和DOS所提供的中断例程" class="headerlink" title="13.4 BIOD和DOS所提供的中断例程"></a>13.4 BIOD和DOS所提供的中断例程</h2></li>
<li><p>bios中主要包含以下几部分内容：</p>
<ul>
<li>1、硬件操作系统的检测和初始化程序；</li>
<li>2、外部中断和内部中断的中断例程；</li>
<li>3、用于对硬件设备进行I\O操作的中断例程；</li>
<li>4、其他和硬件系统相关的中断例程。</li>
</ul>
</li>
<li><p>bios和dos在所提供的中断例程中包含了许多子程序，可以用int指令直接调用。和硬件设备相关的dos中断例程中一般都调用了bios的中断例程</p>
<h2 id="13-5-bios和dos中断例程的安装过程"><a href="#13-5-bios和dos中断例程的安装过程" class="headerlink" title="13.5 bios和dos中断例程的安装过程"></a>13.5 bios和dos中断例程的安装过程</h2></li>
<li><p>1、开机后8086CPU一加电初始化CS和IP，自动执行FFFF:0处指令，转去执行bios中的硬件系统检测和初始化程序。</p>
</li>
<li><p>2、初始化程序将建立bios所支持的中断向量，即将biso提供的中断例程的入口地址登记在中断向量表中。</p>
</li>
<li><p>3、硬件系统检测和初始化完成后，调用int 19h进行操作系统的引导。从此将计算机交由操作系统控制。</p>
</li>
<li><p>4、dos启动后除完成其他工作外，还将它所提供的中断例程装入内存并建立相应的中断向量。</p>
<h2 id="13-6-bios中断例程应用"><a href="#13-6-bios中断例程应用" class="headerlink" title="13.6 bios中断例程应用"></a>13.6 bios中断例程应用</h2></li>
<li><p>bios和dos提供的中断例程douyongah来传递内部子程序的编号。</p>
</li>
<li><p>int 10h中断例程是bios提供的中断例程，其中包含了多个和屏幕输出相关的子程序。int 10h中断例程的设置光标位置功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ah,2;表示调用10h号中断例程的2号子程序，功能为设置光标位置</span><br><span class="line">mov bh,0;页号</span><br><span class="line">mov dh,5;行号</span><br><span class="line">mov dl 12;列号</span><br><span class="line">int 10h;12345</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;功能为在光标位置显示字符功能</span><br><span class="line">mov ah,9;置光标，调用9号子程序</span><br><span class="line">mov al,&#39;a&#39;;字符</span><br><span class="line">mov bl,7;颜色属性，和在显存中的属性字节的格式相同</span><br><span class="line">mov bh,0;第0页</span><br><span class="line">mov cx,3;字符重复个数</span><br><span class="line">int 10h1234567</span><br></pre></td></tr></table></figure>
</li>
<li><p>编程：在屏幕的第5行12列显示3个红底高亮闪烁绿色的’a’</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">  </span><br><span class="line">code segment</span><br><span class="line">        mov ah,2;设置光标</span><br><span class="line">        mov bh,0;第0页</span><br><span class="line">        mov dh,5;dh中放行号</span><br><span class="line">        mov dl,12;dl中放列号</span><br><span class="line">        int 10</span><br><span class="line">  </span><br><span class="line">        mov ah,9;设置光标</span><br><span class="line">        mov al,&#39;a&#39;;字符</span><br><span class="line">        mov bl,11001010b;颜色属性</span><br><span class="line">        mov bh,0;第0页</span><br><span class="line">        mov cx,3;字符重复个数</span><br><span class="line">        int 10h</span><br><span class="line">  </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end1234567891011121314151617181920</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522082758756.png" alt="136"></p>
<h2 id="13-7-dos中断例程应用"><a href="#13-7-dos中断例程应用" class="headerlink" title="13.7 dos中断例程应用"></a>13.7 dos中断例程应用</h2></li>
<li><p>int 21h 中断例程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ah,4ch;程序返回</span><br><span class="line">mov al,0;返回值0是正常返回</span><br><span class="line">;合起来写就是 mov ax,4c00h</span><br><span class="line">int 21h1234</span><br></pre></td></tr></table></figure>
</li>
<li><p>int 2h中断例程还具有在光标位置显示字符串的功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ds:dx;要显示的字符串需要用 $ 作为结束符</span><br><span class="line">mov ah,9;功能号9，表示在光标位置显示字符串</span><br><span class="line">int 21h123</span><br></pre></td></tr></table></figure>

<h1 id="十四、端口"><a href="#十四、端口" class="headerlink" title="十四、端口"></a>十四、端口</h1><h2 id="引言-10"><a href="#引言-10" class="headerlink" title="引言"></a>引言</h2></li>
<li><p>CPU可以直接读写3个地方的数据：</p>
<ul>
<li>1、CPU内部的寄存器；</li>
<li>2、内存单元；</li>
<li>3、 端口。</li>
</ul>
<h2 id="14-1-端口的读写"><a href="#14-1-端口的读写" class="headerlink" title="14.1 端口的读写"></a>14.1 端口的读写</h2></li>
<li><p><strong>mov、push、pop等死内存读写指令。in和out是端口读指令写指令时in是从端口读取数据，out是往端口写入数据。in和out指令只能用ax或al来存放从端口中读入的数据或要发送到端口中的数据，访问8位短空时用al，访问16位端口时用ax。</strong></p>
<ul>
<li><p>访问内存：</p>
<ul>
<li>mov ax,ds:[8+0];假设(ds)=0</li>
<li>执行时，与总线相关的操作：<ul>
<li>1、CPU通过地址线信息8发出；</li>
<li>2、CPU通过控制线发出内存读命令，选中存储器芯片并通知它将要从中读取数据；</li>
<li>3、 存储器将8号单元中的数据通过数据线送入CPU。</li>
</ul>
</li>
</ul>
</li>
<li><p>访问端口：</p>
<ul>
<li><p>in al,60h;从60h号端口读入一个字节。</p>
</li>
<li><p>执行时与总线相关的操作：</p>
<ul>
<li><p>1、CPU通过地址线将地址信息60h发出；</p>
</li>
<li><p>2、CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据；</p>
</li>
<li><p>3、端口所在的芯片将60h端口中的数据通过数据线送入CPU。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;对0~255以内的端口进行读写</span><br><span class="line">in al,20h;从20h端口读入一个字节</span><br><span class="line">out 20h,al;往20h端口写入一个字节</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">;对256~65535的端口进行读写时，端口放在dx中</span><br><span class="line">mov dx,3f8h;将端口号3f8h送入dx</span><br><span class="line">in al,dx;从3f8端口读入一个字节</span><br><span class="line">out 3f8h,al;往3f8h端口写入一个字节123456789</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="14-2-CMOS-RAM芯片"><a href="#14-2-CMOS-RAM芯片" class="headerlink" title="14.2 CMOS RAM芯片"></a>14.2 CMOS RAM芯片</h2></li>
<li><p>CMOA RAM特征：</p>
<ul>
<li><p>1、包含一个实时钟和一个有128个存储单元的RAM存储器。(早期的计算机位64个字节)。</p>
</li>
<li><p>2、该芯片靠电池供电。因此关机后其内部的实时钟仍可正常工作，RAM中的信息不会丢失。</p>
</li>
<li><p>3、128个字节的RAM，内部实时钟占用0~0dh单元来保存时间信息默契与大部分单元用于保存系统配置信息，供系统启动时bios程序读取。</p>
</li>
<li><blockquote>
<p>bios也提供了相关的程序使用户在开机时配置CMOS RAM中的系统信息。</p>
</blockquote>
</li>
<li><p>4、该芯片内部有两个端口，端口地址为70h和71<br>h。CPU通过这两个端口读写CMOS RAM。</p>
</li>
<li><p>5、70h为地址端口，存放要访问的CMOS RAM单元的地址;71h为数据端口，存放从选定的CMOS RAM单元中读取的数据，或要写入到其中的数据。</p>
</li>
</ul>
</li>
<li><p>CPU对CMOS RAM的读写分两步进行，以读2号单元为例：</p>
<ul>
<li>1、将2送入端口70h；</li>
<li>2、从71h读出2号单元的内容。</li>
</ul>
<h2 id="14-3-shl和shr指令"><a href="#14-3-shl和shr指令" class="headerlink" title="14.3 shl和shr指令"></a>14.3 shl和shr指令</h2></li>
<li><p>shl为逻辑左移指令功能为：</p>
<ul>
<li>1、将一个寄存器或内存单元中的数据向左移位；</li>
<li>2、将<strong>最后移出</strong>的一位写入CF中；</li>
<li>3、最低位用0补充。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,01001000b</span><br><span class="line">shl al,1;将al中的数据左移一位</span><br><span class="line">;执行后al的值是10010000b，CF&#x3D;0123</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果移动位数大于1时，必须将移动位数放在cl中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,01010001b</span><br><span class="line">mov cl,3</span><br><span class="line">shl al,cl</span><br><span class="line">;执行后al的值为10001000b，cf&#x3D;01234</span><br></pre></td></tr></table></figure>
</li>
<li><p>二进制逻辑左移一位，相当于执行x=x*2(2是进制位)</p>
<table>
<thead>
<tr>
<th>mov al,00000001b</th>
<th>执行后al的值等于00000001b=1</th>
</tr>
</thead>
<tbody><tr>
<td>shl al,1</td>
<td>执行后al的值等于00000010b=2</td>
</tr>
<tr>
<td>shl al,1</td>
<td>执行后al的值等于00000100b=4</td>
</tr>
<tr>
<td>shl al,1</td>
<td>执行后al的值等于00001000b=8</td>
</tr>
<tr>
<td>mov cl,3</td>
<td></td>
</tr>
<tr>
<td>shl al,cl</td>
<td>执行后al的值等于01000000b=64</td>
</tr>
</tbody></table>
</li>
<li><p>shr为逻辑左移指令功能为：</p>
<ul>
<li>1、将一个寄存器或内存单元中的数据向右移位；</li>
<li>2、将<strong>最后移出</strong>的一位写入CF中；</li>
<li>3、最高位用0补充。</li>
</ul>
</li>
<li><p>二进制逻辑右移一位，相当于执行x=x/2(2是进制位)</p>
<h2 id="14-4-CMOS-RAM中存储的时间信息"><a href="#14-4-CMOS-RAM中存储的时间信息" class="headerlink" title="14.4 CMOS　RAM中存储的时间信息"></a>14.4 CMOS　RAM中存储的时间信息</h2></li>
<li><p>在CMOS RAM中以每个信息一字节存放着当前的时间信息：年09h，月08h，日07h，时04h，分02h，秒00h。这些数据以BCD码的方式存放，BCD码以4位为一位。</p>
</li>
<li><p>数值26BCD码表示为0010 0110，用两个BCD码表示两位十进制，高4位表示十位，低4位表示各位。</p>
</li>
<li><p>编程：在屏幕中间显示当前的月份。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">  </span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">        ;向地址端口70h写入要访问的单元地址，读取CMOS RAM的信息</span><br><span class="line">        mov al,8</span><br><span class="line">        out 70h,al</span><br><span class="line">        in al,71h;从数据端口中取得指定单元中的数据</span><br><span class="line">        mov ah,al;al中为从CMOS RAM的8号端口读出数据</span><br><span class="line">        mov cl,4</span><br><span class="line">        shr ah,cl;ah中为月份的十位数码值</span><br><span class="line">        and al,00001111b;ah中为月份的个位数值码</span><br><span class="line">        add ah,30h;BCD码值+30h(字符&#39;0&#39;)&#x3D;十进制对应的ASCII码</span><br><span class="line">        add al,30h</span><br><span class="line">        ;用BCD码表示的月份以十进制的形式显示到屏幕上。</span><br><span class="line">        mov bx,0b800h;显存</span><br><span class="line">        mov es,bx</span><br><span class="line">        mov byte ptr es:[160*12+40*2],ah;显示月份的十位数码</span><br><span class="line">        mov byte ptr es:[160*12+40*2+2],al;显示月份的个位数码</span><br><span class="line">  </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">  </span><br><span class="line">code ends</span><br><span class="line">end start12345678910111213141516171819202122232425</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522082906398.png" alt="144_1"></p>
<h1 id="十五、外中断"><a href="#十五、外中断" class="headerlink" title="十五、外中断"></a>十五、外中断</h1><h2 id="15-1接口芯片和端口"><a href="#15-1接口芯片和端口" class="headerlink" title="15.1接口芯片和端口"></a>15.1接口芯片和端口</h2></li>
<li><p>CPU通过端口和外设进行联系。在PC系统的接口卡和主板上，装有各种接口芯片。这些外设接口芯片的内部有若干寄存器，CCPU将这些寄存器当作端口来访问。外设的输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中；CPU向外设的输出也不是直接送入到外设而是先送入端口再由相关的芯片送到外设。</p>
<h2 id="15-2外中断信息"><a href="#15-2外中断信息" class="headerlink" title="15.2外中断信息"></a>15.2外中断信息</h2></li>
<li><p>外中断源有两类：</p>
<ul>
<li>1、可屏蔽中断；<ul>
<li>可屏蔽中断时CPU可以不响应的外中断。CPU是否响应可屏蔽中断要看标志寄存器的IF位的设置。</li>
</ul>
</li>
<li>2、不可屏蔽中断</li>
</ul>
</li>
<li><p>当CPU检测到可屏蔽中断信息时：</p>
<ul>
<li>如果IF=1，则CPU在执行完当前指令后响应中断引发中断过程。</li>
<li>如果IF=0，着不响应可屏蔽中断。</li>
<li><a href="https://blog.csdn.net/Gibbs_p/article/details/72257840?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control#12420e4b8ade696ade8bf87e7a88b_139" target="_blank" rel="noopener">内中断过程</a></li>
</ul>
</li>
<li><p>&gt; 可屏蔽中断所引发的中断过程，除在第一步的实现上有所不同外，基本上和内中断的中断过程相同。因为可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU的；而内中断的中断类型码是在CPU内部产生的。在中断过程中将IF置0的原因是在进入中断处理程序后禁止其他的可屏蔽中断。</p>
</li>
<li><p>8086CPU提供的设置IF的指令如下：</p>
<ul>
<li>sti，设置IF=1；</li>
<li>cli，设置if=0.</li>
</ul>
</li>
<li><p>不可屏蔽中断是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后立即响应引发中断过程。对于8086CPU不可屏蔽的中断类型码固定为2。所以中断过程中不需要取中断类型码。几乎所有外设引发的外中断都是可屏蔽中断。</p>
</li>
<li><p>不可屏蔽中断过程：</p>
<ul>
<li>1、标志寄存器入栈，IF=0，TF=0’</li>
<li>2、CS和IP入栈；</li>
<li>3、(IP)=(8)，(CS)=(0AH)</li>
</ul>
<h2 id="15-3PC机及键盘的处理过程"><a href="#15-3PC机及键盘的处理过程" class="headerlink" title="15.3PC机及键盘的处理过程"></a>15.3PC机及键盘的处理过程</h2></li>
<li><p>键盘输入的处理过程：</p>
<ul>
<li>1、键盘输入产生扫描码；</li>
<li>2、扫描码送入60h端口；</li>
<li>3、引发9号中断；</li>
<li>4、执行int 9中断例程。</li>
<li>&gt; 前三步由硬件系统自动完成，第四步用户可以修改int 9中断程序。</li>
</ul>
</li>
<li><p>按下一个键产生的扫描码称为通码，松开一个键产生的扫描码称为断码。扫描码被送入主板上的相关接口芯片端口地址为60h的寄存器中。</p>
</li>
<li><p>扫描码长度为一个字节，通码的第7位为0，断码的第7位为1。即断码=通码+80h。</p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522082937633.png" alt="键盘上部分键的扫描码"></p>
</li>
<li><p>bios提供了int 9中断例程，用来进行基本键盘输入处理，主要的工作如下：</p>
<ul>
<li>1、读出60h端口中的扫描码；</li>
<li>2、如果是字符键的扫描码就将它和它所对应的字符码(ASCII码)送入内存中的bios键盘缓冲区；<ul>
<li>键盘的输入到达60h端口时相关的芯片就会向CPU发出中断类型码为9的可屏蔽中断信息。</li>
<li>CPU检测到该中断信息后，如果IF=1，则相应中断，引发中断过程，转去执行int 9中断例程。</li>
<li>如果是控制键(如ctrl)和切换键(如capslock)的扫描码，则将其转变为状态字节(用为进制位记录控制键和切换键状态的字节)写入内存中存储状态字节的单元</li>
</ul>
</li>
<li>3、键盘系统进行相关的控制。如向相关芯片发出应答信息。</li>
</ul>
</li>
<li><p>bios键盘缓冲区是系统启动后mbios用于存放int 9中断例程所接收的键盘输入的内存区。该内存可以存储15个键盘输入，在bios键盘缓冲区中一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码。0040:17单元存储键盘状态字节该字节记录了控制键和切换键的状态</p>
<ul>
<li>0:置1表表示按下右shift键</li>
<li>1:置1表表示按下左shift键</li>
<li>2:置1表表示按下ctrl</li>
<li>3:置1表表示按下alt</li>
<li>4:置1表表示按下scroll指示灯亮</li>
<li>5:置1表表示按下numlock，小键盘输入的是数字</li>
<li>6:置1表表示按下capslock，输入大写字母</li>
<li>7:置1表表示按下insert。处于删除状态</li>
</ul>
<h2 id="15-4编写int-9中断"><a href="#15-4编写int-9中断" class="headerlink" title="15.4编写int 9中断"></a>15.4编写int 9中断</h2></li>
<li><p>键盘输入的处理过程</p>
</li>
<li><p>编程：在屏幕中间依次显示让人看清的a~z，按下esc键后改变显示的颜色。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    ;显示字符</span><br><span class="line">code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,0b800h</span><br><span class="line">            mov es,ax</span><br><span class="line">            mov ah,&#39;a&#39;</span><br><span class="line">        s:</span><br><span class="line">            mov es:[160*12+40*2],ah</span><br><span class="line">            inc ax</span><br><span class="line">            cmp ah,&#39;z&#39;</span><br><span class="line">            jna s</span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">    code ends</span><br><span class="line">end start123456789101112131415</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    ;延迟显示字符</span><br><span class="line"></span><br><span class="line">assume cs:code</span><br><span class="line">    stack segment</span><br><span class="line">            db 128 dup(0)</span><br><span class="line">    stack ends</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,stack</span><br><span class="line">            mov ss,ax</span><br><span class="line">            mov sp,128</span><br><span class="line">            mov ax,0b800h</span><br><span class="line">            mov es,ax</span><br><span class="line">            mov ah,&#39;a&#39;</span><br><span class="line">        s:</span><br><span class="line">            mov es:[160*12+40*2],ah</span><br><span class="line">            call delay</span><br><span class="line">            inc ah</span><br><span class="line">            cmp ah,&#39;z&#39;</span><br><span class="line">            jna s</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line"></span><br><span class="line">        delay:</span><br><span class="line">            push ax</span><br><span class="line">            push dx</span><br><span class="line">            mov dx,10h;循环100次，延迟的时间和CPU的计算能力成反比</span><br><span class="line">            mov ax,0</span><br><span class="line">        s1:</span><br><span class="line">            sub ax,1</span><br><span class="line">            sbb dx,0</span><br><span class="line">            cmp ax,0</span><br><span class="line">            jne s1</span><br><span class="line">            cmp dx,0</span><br><span class="line">            jne s1</span><br><span class="line">            pop dx</span><br><span class="line">            pop ax</span><br><span class="line">            ret</span><br><span class="line">    code ends</span><br><span class="line">end start123456789101112131415161718192021222324252627282930313233343536373839404142</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;实现IF&#x3D;0，TF&#x3D;0步骤</span><br><span class="line">pushf</span><br><span class="line">pop ax</span><br><span class="line">and ah,11111100b</span><br><span class="line">push ax</span><br><span class="line">popf123456</span><br></pre></td></tr></table></figure>
</li>
<li><p>int指令在执行时CPU进行的工作</p>
</li>
<li><p>完整程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    stack segment</span><br><span class="line">            db 128 dup(0)</span><br><span class="line">    stack ends</span><br><span class="line"></span><br><span class="line">    data segment</span><br><span class="line">            dw 0,0</span><br><span class="line">    data ends</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,stack</span><br><span class="line">            mov ss,ax</span><br><span class="line">            mov sp,128</span><br><span class="line">            mov ax,data</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov ax,0</span><br><span class="line">            mov es,ax</span><br><span class="line"></span><br><span class="line">            push es:[9*4]</span><br><span class="line">            pop ds:[0]</span><br><span class="line">            push es:[9*4+2]</span><br><span class="line">            pop ds:[2];将原来的int9中断例程的入口地址保存</span><br><span class="line"></span><br><span class="line">            mov word ptr es:[9*4+2],offset int9</span><br><span class="line">            mov es:[9*4+2],cs;在中断向量表中设置新的int 9中断例程的入口地址</span><br><span class="line"></span><br><span class="line">            mov ax,0b800h</span><br><span class="line">            mov es,ax</span><br><span class="line">            mov ah,&#39;a&#39;</span><br><span class="line"></span><br><span class="line">        s:</span><br><span class="line">            mov es:[160*12+40*2],ah</span><br><span class="line">            call delay</span><br><span class="line">            inc ah</span><br><span class="line">            cmp ah,&#39;z&#39;</span><br><span class="line">            jna s</span><br><span class="line">            mov ax,0</span><br><span class="line">            mov es,ax</span><br><span class="line"></span><br><span class="line">            push ds:[0]</span><br><span class="line">            pop es:[9*4]</span><br><span class="line">            push ds:[2]</span><br><span class="line">            pop es:[9*4+2];将中断向量表中int9中断例程的入口恢复为原来的地址</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line"></span><br><span class="line">        delay:</span><br><span class="line">            push ax</span><br><span class="line">            push dx</span><br><span class="line">            mov dx,10h;循环100次，延迟的时间和CPU的计算能力成反比</span><br><span class="line">            mov ax,0</span><br><span class="line">        s1:</span><br><span class="line">            sub ax,1</span><br><span class="line">            sbb dx,0</span><br><span class="line">            cmp ax,0</span><br><span class="line">            jne s1</span><br><span class="line">            cmp dx,0</span><br><span class="line">            jne s1</span><br><span class="line">            pop dx</span><br><span class="line">            pop ax</span><br><span class="line">            ret</span><br><span class="line"></span><br><span class="line">            ;新的int 9中断例程</span><br><span class="line"></span><br><span class="line">        int9:</span><br><span class="line">            push ax</span><br><span class="line">            push bx</span><br><span class="line">            push es</span><br><span class="line"></span><br><span class="line">            in al,60h</span><br><span class="line"></span><br><span class="line">            pushf</span><br><span class="line">            pushf</span><br><span class="line">            pop bx</span><br><span class="line">            and bh,11111100b</span><br><span class="line">            push bx</span><br><span class="line">            popf</span><br><span class="line">            call dword ptr ds:[0];对int指令进行模拟，调用原来的int9中断例程</span><br><span class="line"></span><br><span class="line">            cmp al,1;esc键盘扫描码</span><br><span class="line">            jne int9ret</span><br><span class="line"></span><br><span class="line">            mov ax,0b800h</span><br><span class="line">            mov es,ax</span><br><span class="line">            inc byte ptr es:[160*12+40*2+1];改变颜色</span><br><span class="line"></span><br><span class="line">        int9ret:</span><br><span class="line">            pop es</span><br><span class="line">            pop bx</span><br><span class="line">            pop ax</span><br><span class="line">            iret</span><br><span class="line"></span><br><span class="line">    code ends</span><br><span class="line">end start</span><br><span class="line">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798</span><br></pre></td></tr></table></figure>

<h2 id="15-5安装新的int-9中断例程"><a href="#15-5安装新的int-9中断例程" class="headerlink" title="15.5安装新的int 9中断例程"></a>15.5安装新的int 9中断例程</h2></li>
<li><p><strong>小甲鱼版(笔者未成功运行)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    stack segment</span><br><span class="line">            db 128 dup(0)</span><br><span class="line">    stack ends</span><br><span class="line"></span><br><span class="line">    data segment</span><br><span class="line">            dw 0,0</span><br><span class="line">    data ends</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,stack</span><br><span class="line">            mov ss,ax</span><br><span class="line">            mov sp,128</span><br><span class="line">            mov ax,data</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov ax,0</span><br><span class="line">            mov es,ax</span><br><span class="line"></span><br><span class="line">            push es:[9*4]</span><br><span class="line">            pop ds:[0]</span><br><span class="line">            push es:[9*4+2]</span><br><span class="line">            pop ds:[2];将原来的int9中断例程的入口地址保存</span><br><span class="line"></span><br><span class="line">            mov word ptr es:[9*4+2],offset int9</span><br><span class="line">            mov es:[9*4+2],cs;在中断向量表中设置新的int 9中断例程的入口地址</span><br><span class="line"></span><br><span class="line">            mov ax,0b800h</span><br><span class="line">            mov es,ax</span><br><span class="line">            mov ah,&#39;a&#39;</span><br><span class="line"></span><br><span class="line">        s:</span><br><span class="line">            mov es:[160*12+40*2],ah</span><br><span class="line">            call delay</span><br><span class="line">            inc ah</span><br><span class="line">            cmp ah,&#39;z&#39;</span><br><span class="line">            jna s</span><br><span class="line">            mov ax,0</span><br><span class="line">            mov es,ax</span><br><span class="line"></span><br><span class="line">            push ds:[0]</span><br><span class="line">            pop es:[9*4]</span><br><span class="line">            push ds:[2]</span><br><span class="line">            pop es:[9*4+2];将中断向量表中int9中断例程的入口恢复为原来的地址</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line"></span><br><span class="line">        delay:</span><br><span class="line">            push ax</span><br><span class="line">            push dx</span><br><span class="line">            mov dx,10000h;循环100次，延迟的时间和CPU的计算能力成反比</span><br><span class="line">            mov ax,0</span><br><span class="line">        s1:</span><br><span class="line">            sub ax,1</span><br><span class="line">            sbb dx,0</span><br><span class="line">            cmp ax,0</span><br><span class="line">            jne s1</span><br><span class="line">            cmp dx,0</span><br><span class="line">            jne s1</span><br><span class="line">            pop dx</span><br><span class="line">            pop ax</span><br><span class="line">            ret</span><br><span class="line"></span><br><span class="line">            ;新的int 9中断例程</span><br><span class="line"></span><br><span class="line">        int9:</span><br><span class="line">            push ax</span><br><span class="line">            push bx</span><br><span class="line">            push es</span><br><span class="line"></span><br><span class="line">            in al,60h</span><br><span class="line"></span><br><span class="line">            pushf</span><br><span class="line">            pushf</span><br><span class="line">            pop bx</span><br><span class="line">            and bh,11111100b</span><br><span class="line">            push bx</span><br><span class="line">            popf</span><br><span class="line">            call dword ptr ds:[0];对int指令进行模拟，调用原来的int9中断例程</span><br><span class="line"></span><br><span class="line">            cmp al,1;esc键盘扫描码</span><br><span class="line">            jne int9ret</span><br><span class="line"></span><br><span class="line">            mov ax,0b800h</span><br><span class="line">            mov es,ax</span><br><span class="line">            inc byte ptr es:[160*12+40*2+1];改变颜色</span><br><span class="line"></span><br><span class="line">        int9ret:</span><br><span class="line">            pop es</span><br><span class="line">            pop bx</span><br><span class="line">            pop ax</span><br><span class="line">            iret</span><br><span class="line"></span><br><span class="line">    code ends</span><br><span class="line">end start12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>王爽原版(笔者未成功运行)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    stack segment</span><br><span class="line">            db 128 dup(0)</span><br><span class="line">    stack ends</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,stack</span><br><span class="line">            mov ss,ax</span><br><span class="line">            mov sp,128</span><br><span class="line"></span><br><span class="line">            push cs</span><br><span class="line">            pop ds</span><br><span class="line"></span><br><span class="line">            mov ax,0</span><br><span class="line">            mov es,ax</span><br><span class="line"></span><br><span class="line">            mov si,offset int9;设置ds:si指向源地址</span><br><span class="line">            mov di,204h;设置es:di指向目的地址</span><br><span class="line">            mov cx,offset int9end - offset int9;设置cx为传输长度</span><br><span class="line">            cld;设置传输方向</span><br><span class="line">            rep movsb</span><br><span class="line"></span><br><span class="line">            push es:[9*4]</span><br><span class="line">            pop es:[200h]</span><br><span class="line">            push es:[9*4+2]</span><br><span class="line">            pop es:[202h]</span><br><span class="line"></span><br><span class="line">            cli</span><br><span class="line">            mov word ptr es:[9*4],204h</span><br><span class="line">            mov word ptr es:[9*4+2],0</span><br><span class="line">            sti</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line"></span><br><span class="line">        int9:</span><br><span class="line">            push ax</span><br><span class="line">            push bx</span><br><span class="line">            push cx</span><br><span class="line">            push es</span><br><span class="line"></span><br><span class="line">            in al,60h</span><br><span class="line"></span><br><span class="line">            pushf</span><br><span class="line">            call dword ptr cs:[200h];当此中断例程执行时(CS)&#x3D;0</span><br><span class="line"></span><br><span class="line">            cmp al,3bh;f1的扫描码</span><br><span class="line">            jne int9ret</span><br><span class="line"></span><br><span class="line">            mov ax,0b800h</span><br><span class="line">            mov es,ax</span><br><span class="line">            mov bx,1</span><br><span class="line">            mov cx,2000</span><br><span class="line"></span><br><span class="line">        s:</span><br><span class="line">            inc byte ptr es:[bx]</span><br><span class="line">            add bx,2</span><br><span class="line">            loop s</span><br><span class="line"></span><br><span class="line">        int9ret:</span><br><span class="line">            pop es</span><br><span class="line">            pop cx</span><br><span class="line">            pop bx</span><br><span class="line">            pop ax</span><br><span class="line">            iret</span><br><span class="line"></span><br><span class="line">        int9end:</span><br><span class="line">            nop</span><br><span class="line"></span><br><span class="line">    code ends</span><br><span class="line">end start12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273</span><br></pre></td></tr></table></figure>

<h1 id="第16章-直接定址表"><a href="#第16章-直接定址表" class="headerlink" title="第16章 直接定址表"></a>第16章 直接定址表</h1><h2 id="16-1-描述单元长度的标号"><a href="#16-1-描述单元长度的标号" class="headerlink" title="16.1 描述单元长度的标号"></a>16.1 描述单元长度的标号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">cod segment</span><br><span class="line">    a:db 1,2,3,4,5,6,7,8</span><br><span class="line">    b:dw 0</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">        mov si,offset a</span><br><span class="line">        mov bx,offset b</span><br><span class="line">        mov cx,8</span><br><span class="line">    s:</span><br><span class="line">        mov al,cs:[si]</span><br><span class="line">        mov ah,0</span><br><span class="line">        add cs:[bx],ax</span><br><span class="line">        inc si</span><br><span class="line"></span><br><span class="line">    loop s</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;代码中的 s、start等都是标号，表示了内存的地址123456789101112131415161718192021</span><br></pre></td></tr></table></figure>

<p>在code段中使用的标号a，b后面没有：，因此他们可以同时描述内存地址和单元长度的标号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">cod segment</span><br><span class="line">    a db 1,2,3,4,5,6,7,8 ;描述了地址code：0，和从这个地址开始以后的内存单元都是直接单元</span><br><span class="line">    b dw 0 ;则b是code[8]</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">        mov si,0</span><br><span class="line">        mov cx,8</span><br><span class="line">    s:</span><br><span class="line">        mov al,a[si] ;相当于mov al,cs:0[si]</span><br><span class="line">        mov ah,0</span><br><span class="line">        add b,ax</span><br><span class="line">        inc si</span><br><span class="line"></span><br><span class="line">    loop s</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">1234567891011121314151617181920</span><br></pre></td></tr></table></figure>

<h2 id="检测点-16-1"><a href="#检测点-16-1" class="headerlink" title="检测点 16.1"></a>检测点 16.1</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170523225635283.jfif" alt="检测点16.1"></p>
<h2 id="16-2-在其他段中使用数据标号"><a href="#16-2-在其他段中使用数据标号" class="headerlink" title="16.2 在其他段中使用数据标号"></a>16.2 在其他段中使用数据标号</h2></li>
<li><p>注意：在后面加有：的地址标号只能在代码段中使用，不能在其他段中使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">cod segment</span><br><span class="line">a:db 1,2,3,4,5,6,7,8</span><br><span class="line">b:dw 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov si,0</span><br><span class="line">s:</span><br><span class="line">    mov al,a[si]</span><br><span class="line">    mov ah,0</span><br><span class="line">    add b,ax</span><br><span class="line">    inc si</span><br><span class="line"></span><br><span class="line">loop s</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start123456789101112131415161718192021</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果现在代码段中直接用数据标号访问数据，则需要用伪指令assume将标号所在的段和一个段寄存器联系起来。 我们可以将标号当作数据来定义，此时编译器将标号所表示的地址当作数据的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">    a db 1,2,3,4,5,6,7,8</span><br><span class="line">    b dw 0</span><br><span class="line">    c dw a,b</span><br><span class="line">    ;相当于 c dw offset a,offset b</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    a db 1,2,3,4,5,6,7,8</span><br><span class="line">    b dw 0</span><br><span class="line">    c dd a,b</span><br><span class="line">    ;相当于 c dw offset a,seg a,offset b,seg b</span><br><span class="line">    ;seg操作符，功能是取得某一标号的段地址</span><br><span class="line">data ends</span><br><span class="line">123456789101112131415</span><br></pre></td></tr></table></figure>

<h2 id="16-3-直接定址表"><a href="#16-3-直接定址表" class="headerlink" title="16.3 直接定址表"></a>16.3 直接定址表</h2></li>
<li><p>利用表，在两个数据集合之间建立一种映射关系，使我们可以利用查表的方法根据给出的数据得到其在另一集合中对应数据</p>
<ul>
<li>目的：<ol>
<li>为了算法的清晰和简洁</li>
<li>为了加快运算速度</li>
<li>为了使程序易于扩充</li>
</ol>
</li>
</ul>
</li>
<li><p>小练习，编写子程序，以十六进制的形式在屏幕中间显示给定的byte型数据。小技巧，利用映射关系，0-9数值+30h=对应字符的ascii值，10-15和A到F之间的银色关系是：数值+37h=对应字符的ascii的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code:segment</span><br><span class="line">    mov al,0eh</span><br><span class="line"></span><br><span class="line">    call showbyte</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21</span><br><span class="line">    ;子程序，用al传送要显示的数据</span><br><span class="line"></span><br><span class="line">showbyte:</span><br><span class="line">    jmp short show</span><br><span class="line"></span><br><span class="line">    table db &#39;1023456789ABCDEF&#39;;字符表</span><br><span class="line"></span><br><span class="line">show:</span><br><span class="line">    push bx</span><br><span class="line">    push es</span><br><span class="line"></span><br><span class="line">    mov ah,al</span><br><span class="line">    shr ah,1</span><br><span class="line">    shr ah,1</span><br><span class="line">    shr ah,1</span><br><span class="line">    shr ah,1;右移4位，ah中得到高4位的值</span><br><span class="line">    and al,00001111b;al中为低4位</span><br><span class="line"></span><br><span class="line">    mov bl,ah</span><br><span class="line">    mov bh,0</span><br><span class="line">    mov ah,table[bx];用高4位的值作为相对于table的便宜，取得对应的字符</span><br><span class="line"></span><br><span class="line">    mov bx,0b800h</span><br><span class="line">    mov es,bx</span><br><span class="line">    mov es:[160*12+40*2],ah</span><br><span class="line"></span><br><span class="line">    mov bl,al</span><br><span class="line">    mov bh,0</span><br><span class="line">    mov al,table[bx];用低4位的值作为相对于table的偏移，取得对应的字符</span><br><span class="line"></span><br><span class="line">    mov es:[160*12+40*2+2],al</span><br><span class="line"></span><br><span class="line">    pop es</span><br><span class="line">    pop bx</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start 12345678910111213141516171819202122232425262728293031323334353637383940414243444546</span><br></pre></td></tr></table></figure>

<h2 id="16-4-程序入口地址的直接定址表"><a href="#16-4-程序入口地址的直接定址表" class="headerlink" title="16.4 程序入口地址的直接定址表"></a>16.4 程序入口地址的直接定址表</h2></li>
<li><p>小练习</p>
<ol>
<li>清屏：将显存中当前屏幕中的支付设为空格；</li>
<li>设置前景色：设置显存中当前屏幕中处于奇地址的属性字节的第0、1、2位；</li>
<li>设置背景色：设置显存中当前屏幕中处于奇地址的属性字节的第4、5、6位；</li>
<li>向上滚动一行：依次将第n+行的内容复制到第n行处，最后一行为空。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;入口函数1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">;入口函数说明;</span><br><span class="line">;用ah传递功能号，0是清屏，1是设置前景色，2是设置背景色，3是向上滚动一行</span><br><span class="line"></span><br><span class="line">setscreen:</span><br><span class="line">        jmp short set</span><br><span class="line">        table dw sub1,sub2,sub3,sub4</span><br><span class="line"></span><br><span class="line">set:</span><br><span class="line">        push bx</span><br><span class="line">        cmp ah,3;判断传递的功能号是否大于3</span><br><span class="line">        ja sret</span><br><span class="line">        mov bl,ah</span><br><span class="line">        mov bh,0</span><br><span class="line">        add bx,bx;根据ah中的功能号计算对应子程序的地址在table表中的偏移</span><br><span class="line"></span><br><span class="line">        call word ptr table[bx];调用对应的子程序</span><br><span class="line"></span><br><span class="line">sret;</span><br><span class="line">        pop bx</span><br><span class="line">        iret</span><br><span class="line"></span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;入口函数2&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">;入口函数说明;</span><br><span class="line">;用ah传递功能号，0是清屏，1是设置前景色，2是设置背景色，3是向上滚动一行</span><br><span class="line"></span><br><span class="line">setscreen:</span><br><span class="line">        cmp ah,0</span><br><span class="line">        je do1</span><br><span class="line">        cmp ah,1</span><br><span class="line">        je do2</span><br><span class="line">        cmp ah,2</span><br><span class="line">        je do3</span><br><span class="line">        cmp ah,3</span><br><span class="line">        je do4</span><br><span class="line"></span><br><span class="line">        jmp short sret</span><br><span class="line"></span><br><span class="line">do1:</span><br><span class="line">        call sub1</span><br><span class="line">        jmp short sret</span><br><span class="line"></span><br><span class="line">do2:</span><br><span class="line">        call sub2</span><br><span class="line">        jmp short sret</span><br><span class="line"></span><br><span class="line">do3:</span><br><span class="line">        call sub3</span><br><span class="line">        jmp short sret</span><br><span class="line"></span><br><span class="line">do4:</span><br><span class="line">        call sub4</span><br><span class="line">        jmp short sret</span><br><span class="line"></span><br><span class="line">;子功能&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">;清屏</span><br><span class="line">sub1:</span><br><span class="line">        push bx</span><br><span class="line">        push cx</span><br><span class="line">        push es</span><br><span class="line">        mov bx,0b800h</span><br><span class="line">        mov es,bx</span><br><span class="line">        mov bx,0</span><br><span class="line">        mov cx,2000</span><br><span class="line"></span><br><span class="line">sub1s:</span><br><span class="line">        mov byte ptr es:[bx],&#39;&#39;</span><br><span class="line">        add bx,2</span><br><span class="line">    loop sub1s</span><br><span class="line"></span><br><span class="line">        pop es</span><br><span class="line">        pop cx</span><br><span class="line">        pop bx</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">;设置前景色</span><br><span class="line">sub2:</span><br><span class="line">        push bx</span><br><span class="line">        push cx</span><br><span class="line">        push es</span><br><span class="line">        mov bx,0b800h</span><br><span class="line">        mov es,bx</span><br><span class="line">        mov bx,1</span><br><span class="line">        mov cx,2000</span><br><span class="line"></span><br><span class="line">sub2s:</span><br><span class="line">        mov byte ptr es:[bx],11111000b</span><br><span class="line">        or es:[bx],al</span><br><span class="line">        add bx,2</span><br><span class="line">    loop sub2s</span><br><span class="line"></span><br><span class="line">        pop es</span><br><span class="line">        pop cx</span><br><span class="line">        pop bx</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">;设置背景色</span><br><span class="line">sub3:</span><br><span class="line">        push bx</span><br><span class="line">        push cx</span><br><span class="line">        push es</span><br><span class="line">        mov cl,4</span><br><span class="line">        shl al,cl</span><br><span class="line">        mov bx,0b800h</span><br><span class="line">        mov es,bx</span><br><span class="line">        mov bx,1</span><br><span class="line">        mov cx,2000</span><br><span class="line"></span><br><span class="line">sub3s:</span><br><span class="line">        mov byte ptr es:[bx],10001111b</span><br><span class="line">        or es:[bx],al</span><br><span class="line">        add bx,2</span><br><span class="line">    loop sub3s</span><br><span class="line"></span><br><span class="line">        pop es</span><br><span class="line">        pop cx</span><br><span class="line">        pop bx</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">;向上滚动一行</span><br><span class="line">sub4:</span><br><span class="line">        push cx</span><br><span class="line">        push si</span><br><span class="line">        push di</span><br><span class="line">        push es</span><br><span class="line">        push ds</span><br><span class="line"></span><br><span class="line">        mov si,0b800h</span><br><span class="line">        mov es,si</span><br><span class="line">        mov ds,si</span><br><span class="line">        mov si,160;ds：si指向第n+行</span><br><span class="line">        mov di,0;es：di指向第n行</span><br><span class="line">        cld</span><br><span class="line">        mov cx,24;共复制24行</span><br><span class="line"></span><br><span class="line">sub4s:</span><br><span class="line">        push cx</span><br><span class="line">        mov cx,160</span><br><span class="line">        rep movsb;复制</span><br><span class="line">        pop cx</span><br><span class="line">    loop sub4s</span><br><span class="line"></span><br><span class="line">        mov cx,80</span><br><span class="line">        mov si,0</span><br><span class="line"></span><br><span class="line">sub4s1:</span><br><span class="line">        mov byte ptr es:[160*24+si],&#39;&#39;;最后一行清空</span><br><span class="line">        add si,2</span><br><span class="line">    loop sub4s1</span><br><span class="line"></span><br><span class="line">        pop ds</span><br><span class="line">        pop es</span><br><span class="line">        pop di</span><br><span class="line">        pop si</span><br><span class="line">        pop cx</span><br><span class="line">        ret;结束123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157</span><br></pre></td></tr></table></figure>

<h1 id="第十七章-使用BIOS进行键盘输入和磁盘读写"><a href="#第十七章-使用BIOS进行键盘输入和磁盘读写" class="headerlink" title="第十七章 使用BIOS进行键盘输入和磁盘读写"></a>第十七章 使用BIOS进行键盘输入和磁盘读写</h1></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/" rel="tag"># 汇编基础学习</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/" rel="prev" title="汇编语言基础学习汇总2">
      <i class="fa fa-chevron-left"></i> 汇编语言基础学习汇总2
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E6%89%80%E6%9C%89%E6%8C%87%E4%BB%A41/" rel="next" title="汇编语言的所有指令1">
      汇编语言的所有指令1 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一、基础知识"><span class="nav-number">1.</span> <span class="nav-text">一、基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言"><span class="nav-number">1.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-机器语言"><span class="nav-number">1.2.</span> <span class="nav-text">1.1 机器语言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-汇编语言的产生"><span class="nav-number">1.3.</span> <span class="nav-text">1.2 汇编语言的产生</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-汇编语言的组成"><span class="nav-number">1.4.</span> <span class="nav-text">1.3 汇编语言的组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-存储器"><span class="nav-number">1.5.</span> <span class="nav-text">1.4 存储器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-指令和数据"><span class="nav-number">1.6.</span> <span class="nav-text">1.5 指令和数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-存储单元"><span class="nav-number">1.7.</span> <span class="nav-text">1.6 存储单元</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-CPU对存储器的读写"><span class="nav-number">1.8.</span> <span class="nav-text">1.7 CPU对存储器的读写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-8-地址总线"><span class="nav-number">1.9.</span> <span class="nav-text">1.8 地址总线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-9-数据总线"><span class="nav-number">1.10.</span> <span class="nav-text">1.9 数据总线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-10-控制总线"><span class="nav-number">1.11.</span> <span class="nav-text">1.10 控制总线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">1.12.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测点-1-1"><span class="nav-number">1.13.</span> <span class="nav-text">检测点 1.1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-11-内存地址空间-概述"><span class="nav-number">1.14.</span> <span class="nav-text">1.11 内存地址空间(概述)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-12-主板"><span class="nav-number">1.15.</span> <span class="nav-text">1.12 主板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-13-接口卡"><span class="nav-number">1.16.</span> <span class="nav-text">1.13 接口卡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-14-各类存储器"><span class="nav-number">1.17.</span> <span class="nav-text">1.14 各类存储器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-15-内存地址空间"><span class="nav-number">1.18.</span> <span class="nav-text">1.15 内存地址空间</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、寄存器-CPU的工作原理"><span class="nav-number">2.</span> <span class="nav-text">二、寄存器(CPU的工作原理)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言-1"><span class="nav-number">2.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-通用寄存器"><span class="nav-number">2.2.</span> <span class="nav-text">2.1 通用寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-字在寄存器中的存储"><span class="nav-number">2.3.</span> <span class="nav-text">2.2 字在寄存器中的存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-几条汇编指令"><span class="nav-number">2.4.</span> <span class="nav-text">2.3 几条汇编指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测点-2-1"><span class="nav-number">2.5.</span> <span class="nav-text">检测点 2.1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-物理地址"><span class="nav-number">2.6.</span> <span class="nav-text">2.4 物理地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-16位结构的CPU"><span class="nav-number">2.7.</span> <span class="nav-text">2.5 16位结构的CPU</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-8086-CPU给出物理地址的方法"><span class="nav-number">2.8.</span> <span class="nav-text">2.6 8086 CPU给出物理地址的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-段地址-16-偏移地址-物理地址"><span class="nav-number">2.9.</span> <span class="nav-text">2.7 段地址*16+偏移地址&#x3D;物理地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-8-段的概念"><span class="nav-number">2.10.</span> <span class="nav-text">2.8 段的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测点-2-2"><span class="nav-number">2.11.</span> <span class="nav-text">检测点 2.2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-9-段寄存器"><span class="nav-number">2.12.</span> <span class="nav-text">2.9 段寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-10-CS和IP"><span class="nav-number">2.13.</span> <span class="nav-text">2.10 CS和IP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-11-修改CS、IP的指令"><span class="nav-number">2.14.</span> <span class="nav-text">2.11 修改CS、IP的指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-12-代码段"><span class="nav-number">2.15.</span> <span class="nav-text">2.12 代码段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测点-2-3"><span class="nav-number">2.16.</span> <span class="nav-text">检测点 2.3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Debug"><span class="nav-number">2.17.</span> <span class="nav-text">使用Debug</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、寄存器-内存访问"><span class="nav-number">3.</span> <span class="nav-text">三、寄存器(内存访问)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-内存中字的存储"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 内存中字的存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-DS和-address"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 DS和[address]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-字型的传送"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 字型的传送</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-mov、add、sub指令"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 mov、add、sub指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-数据段"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 数据段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测点-3-1"><span class="nav-number">3.6.</span> <span class="nav-text">检测点 3.1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-栈"><span class="nav-number">3.7.</span> <span class="nav-text">3.6 栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-8086-CPU提供的栈机制"><span class="nav-number">3.8.</span> <span class="nav-text">3.7 8086 CPU提供的栈机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8-栈顶越界的问题"><span class="nav-number">3.9.</span> <span class="nav-text">3.8 栈顶越界的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-9-push、pop指令"><span class="nav-number">3.10.</span> <span class="nav-text">3.9 push、pop指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-10-栈段"><span class="nav-number">3.11.</span> <span class="nav-text">3.10 栈段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测点-3-2"><span class="nav-number">3.12.</span> <span class="nav-text">检测点 3.2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四、第一个程序"><span class="nav-number">4.</span> <span class="nav-text">四、第一个程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言-2"><span class="nav-number">4.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-一个源程序从写出到执行的过程"><span class="nav-number">4.2.</span> <span class="nav-text">4.1 一个源程序从写出到执行的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-源程序"><span class="nav-number">4.3.</span> <span class="nav-text">4.2 源程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-编辑源程序"><span class="nav-number">4.4.</span> <span class="nav-text">4.3 编辑源程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-编译"><span class="nav-number">4.5.</span> <span class="nav-text">4.4 编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-连接"><span class="nav-number">4.6.</span> <span class="nav-text">4.5 连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-简化编译和连接"><span class="nav-number">4.7.</span> <span class="nav-text">4.6 简化编译和连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-7-exe的执行"><span class="nav-number">4.8.</span> <span class="nav-text">4.7 exe的执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-8-可执行文件中的程序转入内存并运行的原理"><span class="nav-number">4.9.</span> <span class="nav-text">4.8 可执行文件中的程序转入内存并运行的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-9-程序执行过程的跟踪"><span class="nav-number">4.10.</span> <span class="nav-text">4.9 程序执行过程的跟踪</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#五、-BX-和loop指令"><span class="nav-number">5.</span> <span class="nav-text">五、[BX]和loop指令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言-3"><span class="nav-number">5.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-BX"><span class="nav-number">5.2.</span> <span class="nav-text">5.1 [BX]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-loop指令"><span class="nav-number">5.3.</span> <span class="nav-text">5.2 loop指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-在Debug中跟踪用loop指令实现的循环程序"><span class="nav-number">5.4.</span> <span class="nav-text">5.3 在Debug中跟踪用loop指令实现的循环程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-Debug和汇编编译器Masm对指令的不同处理"><span class="nav-number">5.5.</span> <span class="nav-text">5.4 Debug和汇编编译器Masm对指令的不同处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-loop和-BX-的联合应用"><span class="nav-number">5.6.</span> <span class="nav-text">5.5 loop和[BX]的联合应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-段前缀"><span class="nav-number">5.7.</span> <span class="nav-text">5.6 段前缀</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-7-一段安全的空间"><span class="nav-number">5.8.</span> <span class="nav-text">5.7 一段安全的空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-8-段前缀的使用"><span class="nav-number">5.9.</span> <span class="nav-text">5.8 段前缀的使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#六、包含多个段的程序"><span class="nav-number">6.</span> <span class="nav-text">六、包含多个段的程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1在代码段中使用数据"><span class="nav-number">6.1.</span> <span class="nav-text">6.1在代码段中使用数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-在代码段中使用栈"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 在代码段中使用栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-将数据、代码、栈放入不同的段"><span class="nav-number">6.3.</span> <span class="nav-text">6.3 将数据、代码、栈放入不同的段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测点-6-1"><span class="nav-number">6.4.</span> <span class="nav-text">检测点 6.1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实验五"><span class="nav-number">6.5.</span> <span class="nav-text">实验五</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#七、更灵活的定位内存地址的方法"><span class="nav-number">7.</span> <span class="nav-text">七、更灵活的定位内存地址的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-and和or指令"><span class="nav-number">7.1.</span> <span class="nav-text">7.1 and和or指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-关于ASCII码"><span class="nav-number">7.2.</span> <span class="nav-text">7.2 关于ASCII码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-以字符形式给出数据"><span class="nav-number">7.3.</span> <span class="nav-text">7.3 以字符形式给出数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-大小写转换的问题"><span class="nav-number">7.4.</span> <span class="nav-text">7.4 大小写转换的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-bx-idata"><span class="nav-number">7.5.</span> <span class="nav-text">7.5 [bx+idata]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-6-用-bx-idata-的方式进行数组的处理"><span class="nav-number">7.6.</span> <span class="nav-text">7.6 用[bx+idata]的方式进行数组的处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-7-SI和DI"><span class="nav-number">7.7.</span> <span class="nav-text">7.7 SI和DI</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-8-bx-si-和-bx-di"><span class="nav-number">7.8.</span> <span class="nav-text">7.8 [bx+si]和[bx+di]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-9-bx-si-idata-和-bx-di-idata"><span class="nav-number">7.9.</span> <span class="nav-text">7.9 [bx+si+idata]和[bx+di+idata]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-10-不同的寻址方式的灵活应用"><span class="nav-number">7.10.</span> <span class="nav-text">7.10 不同的寻址方式的灵活应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#八、数据处理的两个基本问题"><span class="nav-number">8.</span> <span class="nav-text">八、数据处理的两个基本问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言-4"><span class="nav-number">8.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-bx、si、di、bp"><span class="nav-number">8.2.</span> <span class="nav-text">8.1 bx、si、di、bp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-机器指令处理的数据所在的位置"><span class="nav-number">8.3.</span> <span class="nav-text">8.2 机器指令处理的数据所在的位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-汇编语言中数据位置的表达"><span class="nav-number">8.4.</span> <span class="nav-text">8.3 汇编语言中数据位置的表达</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-寻址方式总小结"><span class="nav-number">8.5.</span> <span class="nav-text">8.4 寻址方式总小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5-指令要处理的数据有多长"><span class="nav-number">8.6.</span> <span class="nav-text">8.5 指令要处理的数据有多长</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-6-寻址方式的综合应用"><span class="nav-number">8.7.</span> <span class="nav-text">8.6 寻址方式的综合应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-7-div指令"><span class="nav-number">8.8.</span> <span class="nav-text">8.7 div指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-8-伪指令dd"><span class="nav-number">8.9.</span> <span class="nav-text">8.8 伪指令dd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-9-伪指令dup"><span class="nav-number">8.10.</span> <span class="nav-text">8.9 伪指令dup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实验七-寻址方式在结构化数据访问中的应用"><span class="nav-number">8.11.</span> <span class="nav-text">实验七 寻址方式在结构化数据访问中的应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#九、转移指令的原理"><span class="nav-number">9.</span> <span class="nav-text">九、转移指令的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言-5"><span class="nav-number">9.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-操作符offset"><span class="nav-number">9.2.</span> <span class="nav-text">9.1 操作符offset</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-jmp指令"><span class="nav-number">9.3.</span> <span class="nav-text">9.2 jmp指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3-依据位移进行转移的jmp指令"><span class="nav-number">9.4.</span> <span class="nav-text">9.3 依据位移进行转移的jmp指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4-转移的目的地址在指令中的jmp指令"><span class="nav-number">9.5.</span> <span class="nav-text">9.4 转移的目的地址在指令中的jmp指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附注3-汇编编译器-masm-exe-对jmp的相关处理"><span class="nav-number">9.6.</span> <span class="nav-text">附注3 汇编编译器(masm.exe)对jmp的相关处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-5-转移地址在寄存器中的jmp指令"><span class="nav-number">9.7.</span> <span class="nav-text">9.5 转移地址在寄存器中的jmp指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-6-转移地址在内存中的jmp指令"><span class="nav-number">9.8.</span> <span class="nav-text">9.6 转移地址在内存中的jmp指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测点-9-1"><span class="nav-number">9.9.</span> <span class="nav-text">检测点 9.1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-7-jcxz指令"><span class="nav-number">9.10.</span> <span class="nav-text">9.7 jcxz指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测点-9-2"><span class="nav-number">9.11.</span> <span class="nav-text">检测点 9.2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-8-loop指令"><span class="nav-number">9.12.</span> <span class="nav-text">9.8 loop指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测点-9-3"><span class="nav-number">9.13.</span> <span class="nav-text">检测点 9.3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-9-根据位移进行转移的意义"><span class="nav-number">9.14.</span> <span class="nav-text">9.9 根据位移进行转移的意义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-10-编译器对转移位移超界的检测"><span class="nav-number">9.15.</span> <span class="nav-text">9.10 编译器对转移位移超界的检测</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实验8"><span class="nav-number">10.</span> <span class="nav-text">实验8</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实验9"><span class="nav-number">11.</span> <span class="nav-text">实验9</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十、CALL和RET指令"><span class="nav-number">12.</span> <span class="nav-text">十、CALL和RET指令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言-6"><span class="nav-number">12.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-ret和retf指令"><span class="nav-number">12.2.</span> <span class="nav-text">10.1 ret和retf指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测点-10-1"><span class="nav-number">12.3.</span> <span class="nav-text">检测点 10.1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-call指令"><span class="nav-number">12.4.</span> <span class="nav-text">10.2 call指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-3-依据位移进行转移的call指令"><span class="nav-number">12.5.</span> <span class="nav-text">10.3 依据位移进行转移的call指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测点-10-2"><span class="nav-number">12.6.</span> <span class="nav-text">检测点 10.2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-4-转移的目的地址在指令中的call指令"><span class="nav-number">12.7.</span> <span class="nav-text">10.4 转移的目的地址在指令中的call指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测点-10-3"><span class="nav-number">12.8.</span> <span class="nav-text">检测点 10.3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-5-转移地址在寄存器中的call指令"><span class="nav-number">12.9.</span> <span class="nav-text">10.5 转移地址在寄存器中的call指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测点-10-4"><span class="nav-number">12.10.</span> <span class="nav-text">检测点 10.4</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-6-转移地址在内存中的call指令"><span class="nav-number">12.11.</span> <span class="nav-text">10.6 转移地址在内存中的call指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测点-10-5"><span class="nav-number">12.12.</span> <span class="nav-text">检测点 10.5</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-7-call和ret的配合使用"><span class="nav-number">12.13.</span> <span class="nav-text">10.7 call和ret的配合使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-8-mull指令"><span class="nav-number">12.14.</span> <span class="nav-text">10.8 mull指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-9-模块化程序设计"><span class="nav-number">12.15.</span> <span class="nav-text">10.9 模块化程序设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-10-参数和结果传递的问题"><span class="nav-number">12.16.</span> <span class="nav-text">10.10 参数和结果传递的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-11-批量数据的传递"><span class="nav-number">12.17.</span> <span class="nav-text">10.11 批量数据的传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-12-寄存器冲突的问题"><span class="nav-number">12.18.</span> <span class="nav-text">10.12 寄存器冲突的问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实验十"><span class="nav-number">13.</span> <span class="nav-text">实验十</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十一、标志寄存器"><span class="nav-number">14.</span> <span class="nav-text">十一、标志寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言-7"><span class="nav-number">14.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1-ZF-zero-flag-标志"><span class="nav-number">14.2.</span> <span class="nav-text">11.1 ZF(zero flag)标志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2-PF标志"><span class="nav-number">14.3.</span> <span class="nav-text">11.2 PF标志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-3-SF-sign-flag-标志"><span class="nav-number">14.4.</span> <span class="nav-text">11.3 SF(sign flag)标志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测点-11-1"><span class="nav-number">14.5.</span> <span class="nav-text">检测点 11.1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-4-CF-carry-flag-标志"><span class="nav-number">14.6.</span> <span class="nav-text">11.4 CF(carry flag)标志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-5-OF-overflow-flag-标志"><span class="nav-number">14.7.</span> <span class="nav-text">11.5 OF(overflow flag)标志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测点-11-2"><span class="nav-number">14.8.</span> <span class="nav-text">检测点 11.2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-6-adc指令"><span class="nav-number">14.9.</span> <span class="nav-text">11.6 adc指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-7-sbb指令"><span class="nav-number">14.10.</span> <span class="nav-text">11.7 sbb指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-8-cmp指令"><span class="nav-number">14.11.</span> <span class="nav-text">11.8 cmp指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-9-检测比较结果的条件转移指令"><span class="nav-number">14.12.</span> <span class="nav-text">11.9 检测比较结果的条件转移指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#课堂练习"><span class="nav-number">14.12.1.</span> <span class="nav-text">课堂练习</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测点-11-3"><span class="nav-number">14.13.</span> <span class="nav-text">检测点 11.3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-10-DF-direction-flag-标志和串传送指令"><span class="nav-number">14.14.</span> <span class="nav-text">11.10 DF(direction flag)标志和串传送指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-11-pushf和popf"><span class="nav-number">14.15.</span> <span class="nav-text">11.11 pushf和popf</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测点-11-4"><span class="nav-number">14.16.</span> <span class="nav-text">检测点 11.4</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-12-标志寄存器在Debug中的表示"><span class="nav-number">14.17.</span> <span class="nav-text">11.12 标志寄存器在Debug中的表示</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十二、内中断"><span class="nav-number">15.</span> <span class="nav-text">十二、内中断</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言-8"><span class="nav-number">15.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-内中断的产生"><span class="nav-number">15.2.</span> <span class="nav-text">12.1 内中断的产生</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-2-中断处理程序"><span class="nav-number">15.3.</span> <span class="nav-text">12.2 中断处理程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-3-中断向量表"><span class="nav-number">15.4.</span> <span class="nav-text">12.3 中断向量表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-4-中断过程"><span class="nav-number">15.5.</span> <span class="nav-text">12.4 中断过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-5-中断处理程序和iret指令"><span class="nav-number">15.6.</span> <span class="nav-text">12.5 中断处理程序和iret指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-6-除法错误中断的处理"><span class="nav-number">15.7.</span> <span class="nav-text">12.6 除法错误中断的处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-7-编程处理0号中断"><span class="nav-number">15.8.</span> <span class="nav-text">12.7 编程处理0号中断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-8-单步中断"><span class="nav-number">15.9.</span> <span class="nav-text">12.8 单步中断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-9-响应中断的特殊情况"><span class="nav-number">15.10.</span> <span class="nav-text">12.9 响应中断的特殊情况</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十三、int-指令"><span class="nav-number">16.</span> <span class="nav-text">十三、int 指令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言-9"><span class="nav-number">16.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-1-int-指令"><span class="nav-number">16.2.</span> <span class="nav-text">13.1 int 指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-2-编写供应用程序调用的中断例程"><span class="nav-number">16.3.</span> <span class="nav-text">13.2 编写供应用程序调用的中断例程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-3-对int、iret和栈的深入理解"><span class="nav-number">16.4.</span> <span class="nav-text">13.3 对int、iret和栈的深入理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-4-BIOD和DOS所提供的中断例程"><span class="nav-number">16.5.</span> <span class="nav-text">13.4 BIOD和DOS所提供的中断例程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-5-bios和dos中断例程的安装过程"><span class="nav-number">16.6.</span> <span class="nav-text">13.5 bios和dos中断例程的安装过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-6-bios中断例程应用"><span class="nav-number">16.7.</span> <span class="nav-text">13.6 bios中断例程应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-7-dos中断例程应用"><span class="nav-number">16.8.</span> <span class="nav-text">13.7 dos中断例程应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十四、端口"><span class="nav-number">17.</span> <span class="nav-text">十四、端口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言-10"><span class="nav-number">17.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-1-端口的读写"><span class="nav-number">17.2.</span> <span class="nav-text">14.1 端口的读写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-2-CMOS-RAM芯片"><span class="nav-number">17.3.</span> <span class="nav-text">14.2 CMOS RAM芯片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-3-shl和shr指令"><span class="nav-number">17.4.</span> <span class="nav-text">14.3 shl和shr指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-4-CMOS-RAM中存储的时间信息"><span class="nav-number">17.5.</span> <span class="nav-text">14.4 CMOS　RAM中存储的时间信息</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十五、外中断"><span class="nav-number">18.</span> <span class="nav-text">十五、外中断</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#15-1接口芯片和端口"><span class="nav-number">18.1.</span> <span class="nav-text">15.1接口芯片和端口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-2外中断信息"><span class="nav-number">18.2.</span> <span class="nav-text">15.2外中断信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-3PC机及键盘的处理过程"><span class="nav-number">18.3.</span> <span class="nav-text">15.3PC机及键盘的处理过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-4编写int-9中断"><span class="nav-number">18.4.</span> <span class="nav-text">15.4编写int 9中断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-5安装新的int-9中断例程"><span class="nav-number">18.5.</span> <span class="nav-text">15.5安装新的int 9中断例程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第16章-直接定址表"><span class="nav-number">19.</span> <span class="nav-text">第16章 直接定址表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#16-1-描述单元长度的标号"><span class="nav-number">19.1.</span> <span class="nav-text">16.1 描述单元长度的标号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测点-16-1"><span class="nav-number">19.2.</span> <span class="nav-text">检测点 16.1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-2-在其他段中使用数据标号"><span class="nav-number">19.3.</span> <span class="nav-text">16.2 在其他段中使用数据标号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-3-直接定址表"><span class="nav-number">19.4.</span> <span class="nav-text">16.3 直接定址表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-4-程序入口地址的直接定址表"><span class="nav-number">19.5.</span> <span class="nav-text">16.4 程序入口地址的直接定址表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十七章-使用BIOS进行键盘输入和磁盘读写"><span class="nav-number">20.</span> <span class="nav-text">第十七章 使用BIOS进行键盘输入和磁盘读写</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">匡俊桦</p>
  <div class="site-description" itemprop="description">回忆的沙漏将曾经屈指可数的日子渐渐淡去</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">276</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">匡俊桦</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">2.3m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">35:08</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
