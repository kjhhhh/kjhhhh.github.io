<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Java知识——精华总结一、java概述与基础知识1、何为编程？编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编程。 2、Java语言概述，历史、特点是">
<meta property="og:type" content="article">
<meta property="og:title" content="java知识总结">
<meta property="og:url" content="http://yoursite.com/2021/03/26/java%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="KJHの博客">
<meta property="og:description" content="Java知识——精华总结一、java概述与基础知识1、何为编程？编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编程。 2、Java语言概述，历史、特点是">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-26T12:01:43.932Z">
<meta property="article:modified_time" content="2021-03-26T13:53:23.510Z">
<meta property="article:author" content="匡俊桦">
<meta property="article:tag" content="java基础学习">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2021/03/26/java%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>java知识总结 | KJHの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KJHの博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录&回忆</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/java%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java知识总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-26 20:01:43 / 修改时间：21:53:23" itemprop="dateCreated datePublished" datetime="2021-03-26T20:01:43+08:00">2021-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>183k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2:46</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Java知识——精华总结"><a href="#Java知识——精华总结" class="headerlink" title="Java知识——精华总结"></a>Java知识——精华总结</h1><h1 id="一、java概述与基础知识"><a href="#一、java概述与基础知识" class="headerlink" title="一、java概述与基础知识"></a>一、java概述与基础知识</h1><h2 id="1、何为编程？"><a href="#1、何为编程？" class="headerlink" title="1、何为编程？"></a>1、何为编程？</h2><p>编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。<br>为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编程。</p>
<h2 id="2、Java语言概述，历史、特点"><a href="#2、Java语言概述，历史、特点" class="headerlink" title="2、Java语言概述，历史、特点"></a>2、Java语言概述，历史、特点</h2><p>是SUN(Stanford University Network，斯坦福大学网络公司)1995年推出的一门高级语言。<br>是一种面向Internet的编程语言。<br>随着Java技术在web方面的不断成熟，已经成为Web应用程序的首选开发语言。<br>是简单易学，完全面向对象，安全可靠，与平台无关的编程语言。</p>
<p>java5.0之后的三大技术框架<br>J2EE(Java 2 Platform Enterprise Edition)企业版<br>在jdk5.0版本后称为JAVAEE,是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如Servlet Jsp等，主要针对于Web应用程序开发。是传智播客就业班和黑马训练营的主要学习内容之一.。<br>J2SE（Java 2 Platform Standard Edition）标准版<br>在jdk5.0版本后称为JAVASE,这是在java基础阶段主要学习的内容,也是java的基础,以后不管从事Android开发或者是物联网+云计算的开发,等是建立在JSE基础上的,因此该技术是java的最核心技术,是传智播客基础班的主要上课内容.。<br>J2ME(Java 2 Platform Micro Edition)小型版<br>在jdk5.0版本以后称为JAVAME,该技术多应用于一些电子产品的嵌入式开发,以前在手机开发上应用的也比较多,但是随着智能手机的发展,现在手机应用程序(比如Android程序)的开发已经不再使用该技术。</p>
<h2 id="3、什么是跨平台性？原理是什么？JVM"><a href="#3、什么是跨平台性？原理是什么？JVM" class="headerlink" title="3、什么是跨平台性？原理是什么？JVM"></a>3、什么是跨平台性？原理是什么？<a id="more"></a>JVM</h2><p>​    所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。</p>
<p>实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。（注意不是能在所有的平台上运行，关键是该平台是否能安装相应的虚拟机）。<br>我的总结：Java程序之所以能够实现跨平台运行，是因为它根本就不直接运行在任何底层平台上，而是需要在哪里运行，就在哪里(如Windows平台)事先准备好自己的Java平台，而这只是仅仅是安装和配置一个软件而已！</p>
<h2 id="4、Jre和Jdk的区别"><a href="#4、Jre和Jdk的区别" class="headerlink" title="4、Jre和Jdk的区别?"></a>4、Jre和Jdk的区别?</h2><p>JRE：（Java Runtime Environment），java运行环境。包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE 即可。<br>JDK：（Java Development Kit Java）开发工具包。JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。<br>其中的开发工具：编译工具(javac.exe) 打包工具(jar.exe)等</p>
<p>简单而言：使用JDK开发完成的java程序，交给JRE去运行。<br>我的总结：必须熟练的记忆，核心类库，开发工具！</p>
<h2 id="5、java虚拟机JVM"><a href="#5、java虚拟机JVM" class="headerlink" title="5、java虚拟机JVM"></a>5、java虚拟机JVM</h2><p>Java Virtual Machine ，简称JVM;<br>它是运行所有Java程序的抽象计算机,是Java语言的运行环境，它是Java 最具吸引力的特性之一，JVM读取并处理编译过的与平台无关的字节码(class)文件。<br>Java编译器针对JVM产生class文件，因此是独立于平台的。<br>Java解释器负责将JVM的代码在特定的平台上运行。<br>Java虚拟机是不跨平台的.</p>
<h2 id="6、Java程序运行机制"><a href="#6、Java程序运行机制" class="headerlink" title="6、Java程序运行机制"></a>6、Java程序运行机制</h2><p>编译: javac  文件名.文件后缀名<br>运行: java  类名<br>我的总结：Java程序的组成：Java源文件，字节码文件。</p>
<h2 id="7、学习java注意的地方"><a href="#7、学习java注意的地方" class="headerlink" title="7、学习java注意的地方"></a>7、学习java注意的地方</h2><p>Java语言拼写上严格区分大小写；<br>一个Java源文件里可以定义多个Java类，但其中最多只能有一个类被定义成public类；<br>若源文件中包括了public类，源文件必须和该public类同名；<br>一个源文件中包含N个Java类时，编译后会生成N份字节码文件，即每个类都会生成一份单独的class文件，且字节码文件名和<br>其对应的类名相同；</p>
<p>我的总结：一个Java源文件只定义一个类,不同的类使用不同的源文件定义;<br>将每个源文件中单独定义的类都定义成public的;<br>保持Java源文件的主文件名与源文件中的类名一致;</p>
<h2 id="8、Java语法格式"><a href="#8、Java语法格式" class="headerlink" title="8、Java语法格式"></a>8、Java语法格式</h2><p>任何一种语言都有自己的语法规则,Java也一样,既然是规则,那么知道其如何使用就可以了。<br>代码都定义在类中,类由class来定义，区分 public class  和  class;<br>代码严格区分大小写,如main 和 Main  是不一样的;<br>Java中的标识符与关键字;<br>注释;</p>
<p>main方法的作用：<br>程序的入口<br>保证程序的独立运行<br>被JVM调用</p>
<h2 id="9、代码注释：单行-，多行-，文档注释"><a href="#9、代码注释：单行-，多行-，文档注释" class="headerlink" title="9、代码注释：单行//，多行/* /，文档注释/* */"></a>9、代码注释：单行//，多行/* <em>/，文档注释/*</em> */</h2><p>1.单行注释      //:<br>//后到本行结束的所有字符会被编译器忽略;<br>2.多行注释     /* <em>/:<br>/</em>  <em>/之间的所有字符会被编译器忽略<br>3.文档注释     /*</em> <em>/:<br> 在/*</em>  */之间的所有字符会被编译器忽略,java特有的(用于生成文档);<br>我的总结：多行和文档注释都不能嵌套使用。</p>
<h2 id="10、Java中的标识符"><a href="#10、Java中的标识符" class="headerlink" title="10、Java中的标识符"></a>10、Java中的标识符</h2><p>可简单理解为在Java程序中为了增强阅读性自定义的名称。比如：类名，方法名，变量名等。<br>命名规则：<br>    (1) 由字母、数字、下划线、$组成，不能以数字开头<br>        注意:此处的字母还可以是中文,日文等;<br>    (2) 大小写敏感<br>    (3) 不得使用java中的关键字和保留字<br>    (4) 别用Java API里面的类名作为自己的类名。</p>
<h2 id="11、java中的常量和变量"><a href="#11、java中的常量和变量" class="headerlink" title="11、java中的常量和变量"></a>11、java中的常量和变量</h2><p>变量的概念：<br>占据着内存中的某一个存储区域;<br>该区域有自己的名称（变量名）和类型（数据类型）;<br>该区域的数据可以在同一类型范围内不断变化;</p>
<p>为什么要定义变量：<br>用来不断的存放同一类型的常量，并可以重复使用；<br>使用变量注意：<br>变量的作用范围, 初始化值<br>定义变量的格式：<br>数据类型    变量名  =  初始化值；<br>注：格式是固定的，记住格式，以不变应万变。<br>作用范围：定义开始到定义它的代码块结束;<br>同一范围内，不允许多个个局部变量命名冲突</p>
<h2 id="12、Java成员变量和局部变量"><a href="#12、Java成员变量和局部变量" class="headerlink" title="12、Java成员变量和局部变量"></a>12、Java成员变量和局部变量</h2><p>局部变量：不是声明在类体括号里面的变量；<br>局部变量使用前必须初始化值;<br>局部变量没有默认初始化值;<br>局部变量的作用域是从定义开始到定义它的代码块结束;</p>
<p>成员变量:在方法体外,类体内声明的变量，又称字段(Field)或全局变量；（其实Java中没有全局变量，由于Java是面向对象语言，所有变量都是类成员）<br>成员变量的作用域是整个类中;<br>我的总结：注意成员变量和局部变量的区别</p>
<p>package reviewDemo;</p>
<p>public class Demo2 {<br> public static void main(String[] args) {<br>     int i;<br>       System.out.println(i);<br>   }<br>}</p>
<p>备注：局部变量调用前没有初始化，所以编译的时候就会报错！</p>
<p>package reviewDemo;</p>
<p>public class Demo2 {<br>  static int i;<br>    public static void main(String[] args) {<br>     System.out.println(i);<br>   }<br>}</p>
<p>备注：此时i为全局变量，未初始化会被赋予默认的初始化值！程序正确！</p>
<p>我的总结：<br>局部变量是定义在方法中的变量,,,出了该方法就不能访问该变量了….<br>成员变量是在类中定义,,,,并且在类的成员方法中都能访问的变量..</p>
<h2 id="13、基本数据类型"><a href="#13、基本数据类型" class="headerlink" title="13、基本数据类型"></a>13、基本数据类型</h2><p>在数据类型中，最常用也是最基础的数据类型，被称作基本数据类型。可以使用这些类型的值来代表一些简单的状态。<br>Java 语言的基本数据类型总共有以下8 种，下面是按照用途划分出的4 个类别： </p>
<p>定点类型：<br>整数型是一类代表整数值的类型。当需要代表一个整数的值时，可以根据需要从4 种类型中挑选合适的，如果没有特殊要求的话，一般选择int 类型。4 种整数型区别主要在每个数据在内存中占用的空间大小和代表的数值的范围。</p>
<p>浮点类型：<br>小数型是一类代表小数值的类型。当需要代表一个小数的值时，可以根据需要从以下2 种类型中挑选合适的。如果没有特殊要求，一般选择double类型。<br>由于小数的存储方式和整数不同，所以小数都有一定的精度，所以在计算机中运算时不够精确。根据精度和存储区间的不同，设计了两种小数类型。</p>
<p>字符型：<br>字符型代表特定的某个字符，按照前面介绍的知识，计算机中都是以字符集的形式来保存字符的，所以字符型的值实际只是字符集中的编号，而不是实际代表的字符，由计算机完成从编号转换成对应字符的工作。Java 语言中为了更加方便国际化，使用Unicode 字符集作为默认的字符集，该字符集包含各种语言中常见的字符。在程序代码中，字符使用一对单引号加上需要表达的字符来标识，例<br>如’A’、’a’等，当然也可以直接使用字符编码，也就是一个非负整数进行表示。</p>
<p>布尔型：<br>布尔型代表逻辑中的成立和不成立。Java 语言中使用关键字true 代表成立，false 代表不成立。布尔型是存储逻辑值的类型，其实很多程序中都有逻辑值的概念，Java 把逻辑的值用布尔型来进行表达。</p>
<h2 id="14、基本数据类型转换之向上转型和向下转换"><a href="#14、基本数据类型转换之向上转型和向下转换" class="headerlink" title="14、基本数据类型转换之向上转型和向下转换"></a>14、基本数据类型转换之向上转型和向下转换</h2><p>向上转换：<br>整型，字符型，浮点型的数据在混合运算中相互转换，转换时遵循以下原则：<br>容量小的类型可自动转换为容量大的数据类型；<br>byte,short,char → int → long → float → double<br>byte，short，char之间不会相互转换，他们在计算时首先会转换为int类型。<br>boolean 类型是不可以转换为其他基本数据类型。<br>Eg：<br>int i = 123;<br>long l = i;    //自动转换，不需强转<br>float f = 3.14F;<br>double d = f;</p>
<p>向下转换：<br>整型，字符型，浮点型的数据在混合运算中相互转换，转换时遵循以下原则：<br>容量小的类型可自动转换为容量大的数据类型；<br>byte,short,char → int → long → float → double<br>byte，short，char之间不会相互转换，他们在计算时首先会转换为int类型。<br>boolean 类型是不可以转换为其他基本数据类型。<br>Eg：<br>long l = 123L;<br>int i = (int) l;//必须强转<br>double d = 3.14;<br>float f = (float) d;</p>
<p>我的总结：类型转化<br>小转大，自动！自动类型转换（也叫隐式类型转换）<br>大转小，强转！强制类型转换（也叫显式类型转换） </p>
<h2 id="15、Java的运算符"><a href="#15、Java的运算符" class="headerlink" title="15、Java的运算符"></a>15、Java的运算符</h2><p>运算符是一种特殊符号，用以表示数据的运算、赋值和比较等共分以下几种： </p>
<p>算术运算符（+ 、— 、* 、/ 、%）<br>赋值运算符（= 、+=、-=、*=、/=,、%=）<br>关系运算符（&gt;、&gt;=、&lt;、&lt;=、!=）<br>条件运算符（&amp;&amp;、||、！&amp;、|、^）<br>位运算符（&amp;、|、^、~、&gt;&gt;、&lt;&lt;、&lt;&lt;&lt;、&gt;&gt;&gt;）</p>
<p>我的总结：<br>逻辑运算符用于连接布尔型表达式，在Java中不可以写成3&lt;x&lt;6，应该写成x&gt;3 &amp; x&lt;6 。<br>“&amp;”和“&amp;&amp;”的区别：单与时，左边无论真假，右边都进行运算；双与时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。<br>“|”和“||”的区别同理，双或时，左边为真，右边不参与运算。<br>“ ^ ”与“|”不同之处是：当左右都为true时，”^”结果为false。</p>
<h2 id="16、表达式和三目运算符"><a href="#16、表达式和三目运算符" class="headerlink" title="16、表达式和三目运算符"></a>16、表达式和三目运算符</h2><p>是由数字、运算符、数字分组符号(括号)等以能求得数值的有意义排列的序列;<br>a + b<br>3.14 + a<br>(x + y) * z + 100<br>boolean b= i &lt; 10 &amp;&amp; (i%10 != 0)<br>表达式的类型和值：<br>    对表达式中操作数进行运算得到的结果是表达式的值。<br>    表达式值的数据类型即为表达式的类型。<br>表达式的运算顺序<br>应按照运算符的优先级从高到低的顺序进行;<br>优先级相同的运算符按照事先约定的结合方向进行;</p>
<p>“三目运算符”，语法格式：<br>        x ? y : z;<br>其中x为boolean类型表达式，先计算x的值，若为true,则整个三目运算符的结果是表达式y的值，否则就是z的值。</p>
<p>package reviewDemo;</p>
<p>public class Demo2 {<br>    public static void main(String[] args) {<br>        String  s = “lz”;<br>        s = (s == “lz” ? “正确” : “错误”);<br>        System.out.println(s);<br>    }<br>}<br>输出：正确</p>
<h2 id="17、程序流程控制"><a href="#17、程序流程控制" class="headerlink" title="17、程序流程控制"></a>17、程序流程控制</h2><p>顺序结构<br>分支结构（条件结构）<br>循环结构<br>控制循环结构</p>
<p>顺序结构：<br>如果代码里没有流程控制，程序是至上而下一行一行执行的，一条语句执行完之后继续执行下一条语句，直到程序的最后。</p>
<p>if语句:<br>基本语法:if(表达式){方法体}else if(表达式){方法体}else(方法体)<br>几种形式:<br>三种格式：<br>if(条件表达式){执行语句；}<br>if(条件表达式){执行语句；}else{执行语句；}<br>if(条件表达式){执行语句；}else if (条件表达式){执行语句；}……else{执行语句；}</p>
<p>public class If3<br>{<br>    public static void main(String args[])<br>    {<br>        int i = 3;<br>        if (i &gt; 5)<br>        {<br>            System.out.println(“变量i大于5”);<br>        }<br>        else if (i &gt; 4)<br>        {<br>            System.out.println(“变量i小于4”);<br>        }<br>        else<br>        {<br>            System.out.println(“其他”);<br>        }<br>    }<br>}</p>
<p>switch控制语句<br>格式：<br>switch(表达式)<br>{<br>    case 表达式可能的结果值1:<br>            执行语句；<br>    break；<br>    case 表达式可能的结果值2:<br>            执行语句；<br>    break；<br>        …<br>    default:<br>            执行语句；<br>    break；//最后这个一般不写<br>}<br>备注：<br>case之间与default没有顺序。先执行第一个case，都没有匹配的case值执行default。<br>结束switch语句的两种情况：遇到break，switch语句执行结束。<br>如果匹配的case或者default没有对应的break，那么程序会从第一次匹配的case语句开始继续向下执行，运行可以执行的语句，直到遇到break或者switch结束为止。<br>class switch2<br>{<br>    public static void main(String[] args)<br>    {<br>        int a = 7,b = 5;<br>        switch(a-b)<br>        {<br>            case 3://表达式可能的值；<br>            {<br>                System.out.println(“33!”);<br>            }<br>            break;</p>
<pre><code>        case 4:
        {
            System.out.println(&quot;44!&quot;);
            }
            break;
            default://都没有执行则 执行该语句!
                System.out.println(&quot;其它的&quot;);

    }
}</code></pre><p>}<br>注意：switch语句只能使用byte、char、short、int四种基本类型以及它们的包装类和枚举</p>
<h2 id="18、三大循环结构"><a href="#18、三大循环结构" class="headerlink" title="18、三大循环结构:"></a>18、三大循环结构:</h2><p>用于处理需要重复执行的操作；<br>根据判断条件的成立与否，决定程序段落的执行次数，而这个程序段落我们称为循环体；<br>while:事先不需要知道循环执行多少次；<br>do  while:同上，只是至少要执行一次(先做，后判断)；<br>for:需要知道循环次数；</p>
<p>循环结构(while &amp; do while)<br>while语句<br>格式：<br>while(条件表达式值为true)<br>{<br>    执行语句；<br>}</p>
<p>do while语句<br>格式：<br>do<br>{<br>    执行语句；<br>}<br>while(条件表达式值为true);</p>
<p>我的总结：do while特点是无论条件是否满足，循环体至少被执行一次。<br>循环里的条件表达式不能直接写false或直接写结果是false的表达式,不过可以使用变量来传递false值;</p>
<p>循环结构(for)<br>格式：<br>for(初始化表达式（1）；循环条件表达式（2）；循环后的操作表达式（3）)<br>{<br>        执行语句；（4）<br>}<br>    执行顺序：(1) → (2) → (4) → (3) → (2) → (4) → (3)</p>
<p>备注：<br>1, for里面的3个表达式运行的顺序，初始化表达式只读一次，判断循环条件，为真就执行循环体，然后再执行循环后的操作表达式，接着继续判断循环条件，重复找个过程，直到条件不满足为止。<br>2, while与for可以互换，区别在于for为了循环而定义的变量在for循环结束就在内存中释放。而while循环使用的变量在循环结束后还可以继续使用。<br>3, 最简单无限循环格式：while(true) , for(;;),无限循环存在的原因是并不知道循环多少次，而是根据某些条件，来控制循环。</p>
<p>Eg：<br>用三种循环控制求出100以内前5个3的倍数的数字；</p>
<p>class while<br>{<br>    public static void main(String[] args)<br>    {<br>        int i = 1,k = 0;<br>        while(i&lt;=100)<br>        {<br>            if(i%3==0)<br>            {<br>            if(k&lt;5)<br>            System.out.println(i);<br>            k++;<br>            }<br>            i++;<br>        }<br>    }<br>}</p>
<p>class dowhile<br>{<br>    public static void main(String[] args)<br>    {<br>        int i = 1,k = 0;<br>        do{<br>            if(i%3==0)<br>            {<br>            if(k&lt;5)<br>            System.out.println(i);<br>            k++;<br>            }<br>            i++;<br>        }<br>        while(i&lt;=100);<br>    }<br>}</p>
<p>class for<br>{<br>    public static void main(String[] args)<br>    {<br>        int i = 1,k = 0;<br>        for(;i&lt;100;i++)<br>        {<br>            if(i%3==0&amp;&amp;k&lt;5)<br>            {<br>            System.out.println(i);<br>            k++;<br>            }<br>        }<br>    }<br>}</p>
<h2 id="19、嵌套循环与流程控制"><a href="#19、嵌套循环与流程控制" class="headerlink" title="19、嵌套循环与流程控制"></a>19、嵌套循环与流程控制</h2><p>嵌套循环：循环里套循环<br>假设外循环的循环次数是m次,内循环的循环次数是n次，那么内层循环的循环次数需要 m * n次。</p>
<p>Eg：利用for循环语句的嵌套打印出乘法口诀表</p>
<p>class break1<br>{<br>    public static void main(String[] args)<br>    {<br>        for(int i=1;i&lt;=10;i++)//定义i与j的值必须在for循环里面，否则每次跳出循环重新执行就无法取值<br>        {<br>            for(int j=1;j&lt;=10;j++)<br>            {<br>                if(j&lt;=i)<br>                System.out.print(j+”*”+i+”=”+i*j+” “);//小注意:print()括号里面<br>必须传递参数,println()无限制!<br>            }<br>                System.out.println();<br>        }<br>    }<br>}</p>
<p>流程控制</p>
<p>break语句、     continue语句；</p>
<p>break：终止该层循环；<br>continue：跳过该层循环<br>注：<br>①：若这两个语句离开应用范围，存在是没有意义的。<br>②：这个两个语句后面都不能有语句，因为执行不到。<br>③：continue语句是跳过本次循环，继续下次循环。<br>④：标签的出现，可以让这两个语句作用于指定的循环。</p>
<p>Eg：<br>package reviewDemo;</p>
<p>public class Demo2 {<br>    public static void main(String[] args) {<br>        int i = 1;<br>        for (; i &lt; 10; i++) {<br>            System.out.println(i);<br>            if(i == 8){<br>                break;//流程控制，不会完全执行！<br>            }<br>        }<br>    }<br>}</p>
<h1 id="二、方法与数组"><a href="#二、方法与数组" class="headerlink" title="二、方法与数组"></a>二、方法与数组</h1><p>第二篇：</p>
<h2 id="1、什么是方法（Method）？"><a href="#1、什么是方法（Method）？" class="headerlink" title="1、什么是方法（Method）？"></a>1、什么是方法（Method）？</h2><p>方法是一组为了实现特定功能的代码块的集合。方法在语法上的功能主要有以下两个：<br>①：结构化代码<br>将代码按照功能进行组织，使代码的结构比较清晰，容易阅读和修改，也就是程序的可维护性强。<br>②：减少代码重复<br>一个固定的功能，可能会在程序中多次使用，在使用时只需要调用写好的方法，而不用重复书写对应的功能代码。</p>
<p>方法在书写时需要注意以下两点：<br>①：逻辑严谨<br>方法实现的一个完整的功能，所以在书写时要考虑到各种可能的情况，并对每种情况做出恰当的处理。<br>②：通用性强（可重复利用）<br>方法实现的是一种功能，在实际实现时，可以根据需要，使方法具备一定的通用性，除非必要，否则不要写专用的方法。在Java 语言中，恰当的使用方法，将使程序更加优雅，便于阅读和使用。</p>
<p>我的总结：<br>方法：一段可重复使用的代码段；<br>程序中完成独立功能的一段代码的集合。</p>
<h2 id="2、Java中方法的格式："><a href="#2、Java中方法的格式：" class="headerlink" title="2、Java中方法的格式："></a>2、Java中方法的格式：</h2><p>[修饰符] 返回值类型 方法名([参数类型 形式参数1，参数类型 形式参数2，……])<br>{<br>    执行语句;    [return 返回值;]//需要的话<br>}</p>
<p>参数列表（参数的类型 ，参数的个数，参数的顺序）</p>
<p>我的总结：只要上述有一个不一样，那么这个参数列表就不一样！对于方法而言，即使同名也不是同一个方法，也就是下面讲的方法签名。</p>
<h2 id="3、方法里的属性"><a href="#3、方法里的属性" class="headerlink" title="3、方法里的属性"></a>3、方法里的属性</h2><p>访问控制符：访问控制符限定方法的可见范围，或者说是方法被调用的范围。方法的访问控制符有四种，按可见范围从大到小依次是：public、protected，无访问控制符,private。其中无访问控制符不书写关键字即可。具体的范围在后续有详细介绍。<br>形式参数：在方法被调用时用于接收外界输入的数据。<br>实参：调用方法时实际传给方法的数据。<br>返回值：方法在执行完毕后返还给调用它的环境的数据。<br>返回值类型：事先约定的返回值的数据类型，如无返回值，必须给出返回类型 void。<br>方法签名：方法名和方法的参数列表(能区别方法)；//最关键的<br>java语言中调用方法：对象名.方法名（实参列表）。<br>实参的数目、数据类型和次序必须和所调用方法声明的形参列表匹配。<br>return 语句终止方法的运行并指定要返回的数据。</p>
<h2 id="4、方法特点"><a href="#4、方法特点" class="headerlink" title="4、方法特点"></a>4、方法特点</h2><p>它可以实现独立的功能;<br>必须定义在类里面;<br>它只有被调用才会执行;<br>它可以被重复使用;<br>方法结束后方法里的对象失去引用;</p>
<p>如何定义一个功能,并通过方法体现出来：<br>①　明确该功能运算后的结果.明确返回值类型;<br>②　明确在实现该功能过程中是否有未知内容参与运算，确定参数列表;<br>Eg：<br>package reviewDemo;<br>/**</p>
<ul>
<li>player 的值分别是1,2,3或者其他值时，该方法返回“大明”，“二明”，“小明”，“我没有这个孩子”。</li>
<li>/</li>
</ul>
<p>public class Demo2 {<br>    public static void main(String[] args) {<br>        int player = 5;<br>        System.out.println(“返回的结果是：”+show(player));<br>    }</p>
<pre><code>public static String show(int p){
    switch (p) {
    case 1:
        return &quot;大明&quot;;    
    case 2:
        return &quot;二明&quot;;    
    case 3:
        return &quot;小明&quot;;
    default:
        return &quot;我没有这个孩子！&quot;;
    }
}</code></pre><p>}</p>
<h2 id="5、什么是方法的重载（Overload）？"><a href="#5、什么是方法的重载（Overload）？" class="headerlink" title="5、什么是方法的重载（Overload）？"></a>5、什么是方法的重载（Overload）？</h2><p>概念：<br>    在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型或参数顺序不同即可。<br>存在的原因：<br>    屏蔽了一个对象的同一类方法由于参数不同所造成的差异。<br>特点：<br>    与返回值类型无关，只看参数列表。</p>
<p>以下是方法重载的示例：<br>public void a(int a){}<br>public int a(){}<br>public void a(int a,String s){}</p>
<p>Eg：<br>class Chongzai<br>{<br>    public static void main(String[] args)<br>    {<br>        int ret = name(3,4,5);<br>        System.out.println(ret);<br>    }<br>    public static int name(int a, int b)<br>    {<br>        int c = a+b;<br>        return c;<br>    }<br>    public static int name(int a, int b, int m)//这就叫做方法的重载，只要参数列表不一样。好处：用户使用时限制很小；<br>    {<br>        int c = a+b+m;<br>        return c;<br>    }<br>}</p>
<p>我的总结：方法重载，方法名相同，但是参数列表不一致！（和方法覆写不一样，方法覆写的方法名和参数列表都必须一样），注意方法重载和方法覆写的不同！</p>
<h2 id="6、可变参数"><a href="#6、可变参数" class="headerlink" title="6、可变参数"></a>6、可变参数</h2><p>从java5开始出现了可变参数，这是对java方法及数组的拓展！<br>方法中可以接受的参数不再是固定个数的，而是随着具体需求传递的多少来决定。</p>
<p>定义格式： 返回值类型  方法名(参数类型 … 形式参数){    }<br>可变参数的特点：<br>只能出现在参数列表的最后；<br>… 位于变量类型和变量名之间，前后有无空格都可以;<br>调用可变参数的方法时，编译器为该可变参数隐含创建一个数组，在方法体中以数组的形式访问可变参数。</p>
<p>Eg：<br>package reviewDemo;</p>
<p>import java.util.Arrays;</p>
<p>public class Demo6 {<br>    public static void main(String[] args) {<br>        int []age = {1,2,3,69,36,636,459};<br>        show(age);<br>    }</p>
<pre><code>public static void show(int...a){//此时这里写的就是可变参数，和数组的作用一样！
    //把数组给打印出来！
    System.out.println(Arrays.toString(a));
}</code></pre><p>}    </p>
<h2 id="7、数组简介："><a href="#7、数组简介：" class="headerlink" title="7、数组简介："></a>7、数组简介：</h2><p>数组(Array)是Java 语言中内置的一种基本数据存储结构，通俗的理解，就是一组数的集合，目的是用来一次存储多个数据。数组是程序中实现很多算法的基础，可以在一定程度上简化代码的书写。</p>
<p>备注：</p>
<ol>
<li>数组的好处：数组里的每个元素都有编号，编号从0开始，并且依次递增，方便操作这些元素；</li>
<li>使用Java数组：必须先声明数组，再给该数组分配内存；</li>
<li>数组对应在内存中一段连续空间。</li>
<li>数组元素必须是相同数据类型，也可以是引用数据类型，但是同一个数组中的元素必须是同一类数据类型。</li>
</ol>
<p>8、一维数组的声明与初始化：<br>一维数组：可以理解为一列多行、类型相同的数据，其中每个数据被称为数组元素；<br>一维数组的声明方式：<br>         type varName[]; 或 type[] varName;(推荐)<br>Eg：int age[]; int []age;<br>数组的长度一旦确定,就不能改变,也就数组是定长的;<br>我的总结：java语言声明数组的时候不能指定其长度（元素的个数）<br>Eg：int a[5]; //非法</p>
<p>初始化：<br>Java中的数组必先初始化才可以使用，所谓初始化就是为数组的数组元素分配内存，并为每个数组元素赋值；<br>数组初始化的两种方式：<br>静态初始化：初始化时由我们自己指定每个数组元素的初始值，由系统决定需要的数组长度；<br>格式：数组名 = new 数组类型[]{元素1,元素2,元素3…元素n};<br>简化语法：数组名 = {元素1,元素2,元素3…元素n};</p>
<p>动态初始化：初始化时由我们指定数组的长度，由系统为数组元素分配初始值；<br>格式：数组名 = new 数组类型[数组长度];</p>
<p>我的总结：<br>不能静态和动态初始化同时使用：<br>也就是说不能同时指定数组的长度和元素；</p>
<p>Eg:<br>package reviewDemo;<br>/**</p>
<ul>
<li>声明数组及初始化</li>
<li>/<br>public class Demo3 {<br>  public static void main(String[] args) {<pre><code>int []age = new int[10];
//动态初始化
for (int i = 0; i &lt; age.length; i++) {
    age[i] = i;
    System.out.print(age[i]+&quot;     &quot;);
}</code></pre>  }<br>}</li>
</ul>
<p>输出：0     1     2     3     4     5     6     7     8     9     </p>
<h2 id="9、数组的使用："><a href="#9、数组的使用：" class="headerlink" title="9、数组的使用："></a>9、数组的使用：</h2><p>Java语言的数组索引是从0开始的，也就是说数组里的第一个元素的索引是0,第二个元素的索引是1，依次可以类推。<br>常见操作：<br>给数组元素赋值<br>数组名[索引] = 数组类型的值 ;<br>访问数组元素<br>数组类型 变量 = 数组名[索引];<br>得到数组的长度<br>int len  = 数组名.length;    //length是数组的属性<br>遍历数组（备注：length 属性和循环语句）<br>数组元素的索引范围（0，长度—1） </p>
<p>Eg：判断数组是否重复<br>package reviewDemo;<br>/**</p>
<ul>
<li>判断数组是否重复</li>
<li>/<br>public class Demo3 {<br>  public static void main(String[] args) {<pre><code>int []age = {1,2,3,4,5,6,5};
for (int i = 0; i &lt; age.length-1; i++) {//双层循环，定住一个，再考虑下一个！
    for (int j = i+1; j &lt; age.length; j++) {
        if(age[i] == age[j]){
            System.out.println(&quot;有重复的！&quot;+i+&quot;  &quot;+j);
            break;
        }
    }
}</code></pre>  }<br>}</li>
</ul>
<p>求最大值：<br>package reviewDemo;</p>
<p>public class Demo4 {<br>    public static void main(String[] args) {<br>        int age[] = new int[] { 12, 26, 3, 60, 55, 6, 48, 4, 98 };<br>        int max = age[0];<br>        for (int i = 0; i &lt; age.length; i++) {<br>            if (max &lt; age[i]) {<br>                max = age[i];<br>            }<br>        }<br>        System.out.println(max);</p>
<pre><code>}</code></pre><p>}</p>
<p>经典用法：冒泡法排序<br>class Bubblesort<br>{<br>    public static void main(String args[])<br>    {<br>        int [] arr={5,1,6,4,2,8,9};<br>        bubble(arr);<br>        printarray(arr);</p>
<pre><code>}
public static void bubble(int[] arr)
{
    for (int i=0;i&lt;arr.length-1 ;i++ ) 
    {
        for (int y=0;y&lt;arr.length-i-1 ; y++) //让每一次比较的元素减少，-1是为了防止数组角标越界；
        {
            if(arr[y]&gt;arr[y+1])  //相邻两元素相比
            {
                int temp = 0;
                temp = arr[y];
                arr[y] = arr[y+1] ;
                arr[y+1] = temp;
            }
        }
    }
}
public static void printarray(int[] arr)
{

    for (int i=0;i&lt;arr.length ;i++ ) 
    {
        if(i!=arr.length-1)
        System.out.print(arr[i]+&quot;,&quot;);                
        else
            System.out.println(arr[i]);
    }
}</code></pre><p>}<br>//选择排序<br>public class Demo6 {<br>    public static void main(String[] args) {<br>        int []age = {1,2,36,363,56,95,12,32,1232,3263};</p>
<pre><code>    for (int i = 0; i &lt; age.length; i++) {
        for (int j = i+1; j &lt;= age.length-1; j++) {
            if(age[i] &gt; age[j]){
                int temp = age[i];
                age[i] = age[j];
                age[j] = temp;
            }
        }
    }
    System.out.println(Arrays.toString(age));
}</code></pre><p>}<br>//输出为：[1, 2, 12, 32, 36, 56, 95, 363, 1232, 3263]</p>
<h2 id="10、分配内存空间"><a href="#10、分配内存空间" class="headerlink" title="10、分配内存空间"></a>10、分配内存空间</h2><p>分配内存空间<br>数组名=new 数据类型[数组长度]；<br>new关键字用来实现为数组或对象分配内存 （堆内存）<br>数组具有固定的长度。获取数组的长度： 数组名.length</p>
<p>定义数组+分配内存空间<br>数据类型[]数组名=new 数据类型[数组长度];<br>定义数组时不指定长度，分配空间时指定数组长度；如：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> cities[] = <span class="keyword">new</span> <span class="keyword">String</span>[<span class="number">6</span>];</span><br></pre></td></tr></table></figure>

<p>数组元素：<br>数组名[下标值];<br>数组下标从0开始 </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores[<span class="number">0</span>]=<span class="number">75</span>；</span><br></pre></td></tr></table></figure>

<p>数组的内存分配  栈内存和堆内存<br>如定义一个数组 </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[]scores</span><br></pre></td></tr></table></figure>

<p>将在栈内存中为scores 分配内存空间，其值是一个不确定的值。<br>当执行语句scores=new int[5]时，将在堆内存分配连续5个空间，每个空间4个字节，用于存放整型数据，其初始值为0，然后将该段空间首地址，也就是第一个元素的地址，比如0*3000，赋给scores变量。该地址相当于一个指针，指向堆内存中分配的空间。此时堆内存中分配的5个空间可以分别使用scores[0],一直到scores[4]来表示。当执行四个赋值语句时，分别用指定值填充到对应元素位置。如果此时将null值赋给scores时，scores变量将不再指向任何位置，此时堆内存中分配的空间就变成了垃圾，由垃圾回收器在某一时间进行回收。</p>
<p>在方法中定义的变量，包括基本数据类型变量和引用数据类型变量，都将在栈内存中分配空间，当超过变量作用范围后，自动回收</p>
<p>我的总结：初始化=定义数组+分配空间+赋值</p>
<h2 id="11、二维数组："><a href="#11、二维数组：" class="headerlink" title="11、二维数组："></a>11、二维数组：</h2><p>二维数组：(其实是一个一维数组，它的每一个元素又是一个一维数组),<br>可以看做是一张表格。<br>初始化：<br>动态初始化<br>int[ ][ ]  arr = new int[3][2];<br>定义了一个二维数组，其中有3个一维数组，每一个一维数组中有2个元素<br>静态初始化</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[<span class="string"> </span>][<span class="symbol"> </span>]  arr = new int[][]&#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;;</span><br><span class="line">int[<span class="string"> </span>][<span class="symbol"> </span>]  arr = &#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>Eg：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Demo3</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123;</span><br><span class="line">		<span class="built_in">int</span> age[][] = new <span class="built_in">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">System.<span class="keyword">out</span>.println(age[<span class="number">0</span>].length);<span class="comment">//2</span></span><br><span class="line">		System.<span class="keyword">out</span>.println(age[<span class="number">2</span>].length);<span class="comment">//3</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="12、操作数组的工具类-Arrays"><a href="#12、操作数组的工具类-Arrays" class="headerlink" title="12、操作数组的工具类-Arrays"></a>12、操作数组的工具类-Arrays</h2><p>static int binarySearch(type[] a, type key) 使用二分搜索法来搜索key元素在数组中的索引；若a数组不包括key，返回负数。（该方法必须已按升序排列后调用）。<br>static int binarySearch(type[] a, int fromIndex, int toIndex, type key) 使用二分搜索法来搜索key元素在数组中从fromIndex到toIndex的索引；若a数组不包括key，返回负数。（该方法必须已按升序排列后调用）。<br>static boolean[] copyOf(type[] original, int newLength) 复制指定的数组见下面备注<br>static byte[] copyOfRange(type[] original, int from, int to) 将数组的指定范围复制到一个新数组。 </p>
<p>static boolean equals(type[] a, type[] a2) 如果两个数组长度相等和元素一一相等，则返回 true<br>static void fill(type[] a, type val) 将a数组所有元素都赋为val。<br>static void fill(type[] a, int fromIndex, int toIndex, type val) 将a数组从formIndex 到tiondex索引之间的元素都赋为val。<br>static void sort(type[] a) //sort(int[] arr)对指定的数组按数字升序进行排序。<br>static void sort(type[] a, int fromIndex, int toIndex) 对指定数组的从formIndex 到tiondex索引之间的元素按数字升序进行排序。<br>static String toString(type[] a) 返回指定数组内容的字符串表示形式。多个数组元素之间用英文逗号或空格隔开。</p>
<p>我的总结：使用数组工具类可以节省时间，提高效率，注意常查阅api；</p>
<p>Eg：<br>package reviewDemo;</p>
<p>import java.util.Arrays;</p>
<p>//使用Arrays类<br>public class Demo4 {<br>    public static void main(String[] args) {<br>        int[] age = new int[] { 12, 26, 3, 60, 55, 6, 48, 4, 98 };<br>        System.out.println(Arrays.toString(age));//直接打印出数组的方法</p>
<pre><code>    int []age2 = {1,2,3,4,5,6,98,65,23};
    int i = Arrays.binarySearch(age2, 98);
    System.out.println(i);
}</code></pre><p>}</p>
<h2 id="13、Java5新特性对数组的支持："><a href="#13、Java5新特性对数组的支持：" class="headerlink" title="13、Java5新特性对数组的支持："></a>13、Java5新特性对数组的支持：</h2><p>增强for循环 → for-each</p>
<p>for (参数类型 参数名 : 数组名) {<br>        代码块<br>}</p>
<p>Eg：<br>package reviewDemo;</p>
<p>public class Demo6 {<br>    public static void main(String[] args) {<br>        int []age = {1,2,3,69,36,636,459};<br>        for (int i : age) {<br>            System.out.println(i);<br>        }<br>    }<br>}<br>这样就用for-each把数组遍历输出！<br>我的总结：for-each用于数组和Iterable对象！在以后的集合学习中还会经常用到for-each循环。</p>
<h1 id="三、面向对象（1）"><a href="#三、面向对象（1）" class="headerlink" title="三、面向对象（1）"></a>三、面向对象（1）</h1><p>第三篇：</p>
<h2 id="1、什么叫面向对象？"><a href="#1、什么叫面向对象？" class="headerlink" title="1、什么叫面向对象？"></a>1、什么叫面向对象？</h2><p>面向对象(Object-Oriented，简称OO)就是一种常见的程序结构设计方法。<br>面向对象思想的基础是将相关的数据和方法放在一起，组合成一种新的复合数据类型，然后使用新创建的复合数据类型作为项目的基础。</p>
<p>面向对象是一个很抽象的概念，它相对面向过程而言。<br>过程与对象都是一种解决问题的思想。<br>面向过程：强调的是功能行为,一种过程,先干啥,再干啥;<br>面向对象：将功能封装到对象里，强调的是具备某功能的对象;<br>按照面向对象的思想，可以把任何的东西看做对象！</p>
<p>面向对象的三个特征：<br>封装(Encapsulation);<br>继承(Inheritance);<br>多态(Polymorphism)。</p>
<p>我的总结：<br>面向过程：强调的是具体的功能实现；（执行者）<br>面向对象：强调的是具备功能的对象。（管理者）</p>
<h2 id="2、类"><a href="#2、类" class="headerlink" title="2、类"></a>2、类</h2><p>类(class)是Java 语言的最小编程单位，也是设计和实现Java 程序的基础，本部分将深入介绍类的相关知识。<br>类的概念<br>类是一组事物共有特征和功能的描述。类是对于一组事物的总体描述，是按照面向对象技术进行设计时最小的单位，也是组成项目的最基本的模块。类的概念是抽象的，类似于建筑设计中的图纸，是对于现实需要代表的具体内容的抽象。类只包含框架结构，而不包含具体的数据。所以类代表的是总体，而不代表某个特定的个体。</p>
<p>我的总结：类是抽象的，对象是具体的，实实在在的！</p>
<p>类的定义：<br>[修饰符] class  类名{<br>      1<del>n个构造方法；<br>    0</del>n个字段；<br>    0~n个方法<br>}<br>定义类，其实就是定义类里面的对象</p>
<p>对象包含：<br>状态；（属性）<br>功能、行为；（方法）<br>通过类来描述对象；<br>状态——–成员变量；<br>功能、行为——方法；</p>
<p>Eg：<br>class Person{<br>//属性<br>    private String name;<br>    private int age;<br>    private int sal;<br>    //方法<br>    public void show(){<br>        System.out.println(“个人情况：”+name+age+sal);<br>    }<br>}</p>
<h2 id="3、构造方法"><a href="#3、构造方法" class="headerlink" title="3、构造方法"></a>3、构造方法</h2><p>构造方法：用来构造类的实例（每一个类都默认有一个无参的构造方法，得使用new调用）<br>字段：类或对象所包含的数据，对类状态的一种描述；<br>方法：类或对象的特征或行为</p>
<p>作用：<br>给类中的字段进行初始化，可以用来创建对象。</p>
<p>特点：<br>方法名与类名相同<br>不用定义返回值类型<br>不需要写return语句</p>
<p>我的总结：<br>注意：<br>默认构造方法的特点。<br>多个构造方法是以重载的形式存在的。</p>
<p>构造方法的重载:（需要哪个就去适配哪个，调用哪个）<br>        this([实参]);调用当前类的构造方法<br>        注意: this([实参]);必须放在构造器的第一行;</p>
<p>对象的产生格式：<br>类名称  对象名 = new  类名称();<br>因为有(),所以是方法,实际上它就是构造方法，并且是非私有的构造方法。<br>如：CellPhone cp = new CellPhone();</p>
<p>Eg：<br>class Person{<br>    private String name;<br>    private int age;<br>    private int sal;</p>
<pre><code>public void show(){
    System.out.println(&quot;个人情况：&quot;+name+age+sal);
}

public Person(String name) {
    super();
    this.name = name;
}

public Person(String name, int age) {
    super();
    this.name = name;
    this.age = age;
}

public Person(String name, int age, int sal) {
    super();
    this.name = name;
    this.age = age;
    this.sal = sal;
}</code></pre><p>}</p>
<h2 id="4、static关键字"><a href="#4、static关键字" class="headerlink" title="4、static关键字"></a>4、static关键字</h2><p>特点：<br>随着类的加载而加载<br>优先于对象存在<br>被所有对象所共享<br>可以直接被类名调用<br>使用注意：<br>静态方法只能访问静态成员<br>但是非静态成员可以访问静态成员;<br>静态方法中不可以使用this，super关键字<br>主方法（main）是静态的（可以利用类名去调用静态的main方法，很正常！但是会陷入死循环，导致内存溢出，jvm自动停止！）<br>public static void main(String[] agrs){}</p>
<p>可修饰字段,方法。<br>用static 修饰的成员表示它属于这个类共有，而不是属于该类的单个实例。<br>        static 修饰的字段 == 类字段<br>        static 修饰的方法 == 类方法</p>
<p>没使用static修饰的字段和方法，成员属于类的单个实例，<br>    不属于类。<br>        没有static 修饰的字段 == 实例字段<br>        没有static 修饰的方法 == 实例方法</p>
<p>类和实例访问字段和方法的语法：<br>访问类成员：    类.字段         类.方法<br>访问实例成员：    实例.字段         实例.方法</p>
<p>我的总结：<br>static 修饰的字段和方法，既可以通过类调用，也可以使用实例调用；<br>没static 修饰的字段和方法，只能使用实例来调用（建议使用:类名来调用;    其实在底层,对象调用类成员,也会转换类名调用）<br>static关键字不能与this，super同时连用！</p>
<h2 id="5、匿名对象"><a href="#5、匿名对象" class="headerlink" title="5、匿名对象"></a>5、匿名对象</h2><p>一个没有名字的对象,  创建了一个对象出来,没有赋给一个变量;<br>特点：<br>对方法或字段只进行一次调用时；<br>可作为实际参数进行传递；<br>只在堆里面开辟存储区域,<br>只能使用一次,  使用完就被销毁了;<br>何时使用？只拿来用一次！！<br>new Person();表示匿名对象,没有名字的对象<br>new Person().age = 17;//使用一次之后就被销毁了</p>
<h2 id="6、this关键字"><a href="#6、this关键字" class="headerlink" title="6、this关键字"></a>6、this关键字</h2><p>特点：this表示当前对象。<br>当前对象  ←→  当前正在调用实例成员的对象<br>换言之：谁调用了方法，谁就是当前对象。</p>
<p>什么时候使用this关键字呢？<br>方法间的相互调用;<br>this.字段;<br>构造器中相互调用，但是此时this([参数])必须写在构造方法第一行。<br>this不能用在static修饰的方法里和static修饰的代码块里;</p>
<p>Eg：构造方法中的this.name = name;</p>
<h2 id="7、面向对象之封装"><a href="#7、面向对象之封装" class="headerlink" title="7、面向对象之封装"></a>7、面向对象之封装</h2><p>封装的两个含义：<br>1.把对象的状态和行为看成一个统一的整体，将二者存放在一个独立的模块中(类)；<br>2.”信息隐藏”, 把不需要让外界知道的信息隐藏起来,尽可能隐藏对象功能实现细节,字段;</p>
<p>封装机制在程序中的体现是：把描述对象的状态用字段表示，描述对象的行为用方法表示，把字段和方法定义在一个类中，并保证外界不能任意更改其内部的字段值，也不允许任意调动其内部的功能方法。</p>
<p>程序中的一种体现：通常将类中的成员变量私有化(private)，通过对外提供方法（setXxx,getXxx）,可对该变量(xxx)进行访问。<br>boolean 类型的变量没有getXX,只有 isXX;</p>
<p>Eg：<br>class Person1{<br>    private String name;<br>    private int age;<br>    private int sal;</p>
<pre><code>public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}

public int getAge() {
    return age;
}

public void setAge(int age) {
    this.age = age;
}</code></pre><p>}</p>
<h2 id="8、访问修饰符"><a href="#8、访问修饰符" class="headerlink" title="8、访问修饰符"></a>8、访问修饰符</h2><p>private 类访问权限:本类内部可以访问,不能继承到子类;<br>default 什么都不写,包访问权限:本类内部可以访问，同包其他类也可以访问,同包可继承;<br>protected 子类访问权限:本类内部可以访问，不同包的子类也可以访问，同包其他类也可以访问,能继承到子类;<br>public 公共访问权限:任何地方都可以访问,能继承到子类;</p>
<p>我的总结：</p>
<h2 id="9、类的设计分析"><a href="#9、类的设计分析" class="headerlink" title="9、类的设计分析"></a>9、类的设计分析</h2><p>分析思路：<br>根据要求写出类所包含的字段；<br>所有的字段都必须私有化；<br>封装之后的字段可通过setter和getter设值和取得；<br>按需求可添加若干构造方法；<br>根据需求可添加相应的方法；<br>类中的所有方法都不要直接处理(输出打印)，而是交给调用者去处理。</p>
<h2 id="10、面向对象之继承"><a href="#10、面向对象之继承" class="headerlink" title="10、面向对象之继承"></a>10、面向对象之继承</h2><p>首先有反映一般事物特性的类,然后在此基础上反映出特殊事物的类；<br>也就是说：继承是一种从一般到特殊的关系；</p>
<p>特点：<br>1、提高了代码的复用性。<br>2、让类与类之间产生关系，有了这个继承关系才有了多态的特性。<br>3、Java语言中只支持单继承（有别于C语言）。<br>因为多继承容易带来安全隐患（父类多了， 功能相同的话，就会出现调用不确定性吗，覆写一个方法，到底覆写的谁的？）。<br>ps：接口可以实现多继承<br>4、Java支持多层继承，object是每个类的超类，实现树形结构。</p>
<p>我的总结：<br>继承是多态的前提。<br>对类而言，只支持单继承。接口可以实现多继承</p>
<p>格式：<br>    [修饰符] class SubClass extends SuperClass</p>
<p>按照这种关系，我们把SuperClass类称为父类或基类，把SubClass称为子类或派生类或拓展类；</p>
<p>我的总结：<br>java.lang.Object是所有类的父类，<br>    Object要么是直接父类要么是间接父类。</p>
<p>Eg：<br>学生属于人的一种特殊情况,此时我把人的共性写在Person类里面,为了让学生拥有这些共性（别的比如老师也可以有这些共性）,然后我就让学生来拓展Person类。</p>
<p>我的总结：<br>子类与父类的关系:<br>子类拓展父类（子类是父类的一种特殊情况）<br>主要是以父类为基础，然后添加属于自己的字段和方法。</p>
<p>父类的私有成员子类不能继承到;父类的构造方法不能被继承；<br>Java只支持单继承,不支持多继承;//不然的话，比如show方法，继承了多个，不知道到底调用那一个。<br>一个类有且只有一个直接父类;<br>一个类没显示的继承其他的一个类的时候,默认的直接父类就是Object类;<br>Student 的直接父类是Person,Object类也是Student类的父类,但是是间接父类;<br>一旦一个类显示的继承了其他的一个类的时候,此时默认的直接父类Object就会被取消;<br>Java里一个类只能有一个直接父类;java.lang.Object是所有类的父类，Object要么是直接父类要么是间接父类。</p>
<p>子类对象实例化过程<br>在继承操作中，对于子类对象的实例化：<br>子类对象在实例化之前必须首先调用父类中的构造方法之后再调用自身的构造方法。</p>
<h2 id="11、子类访问父类和方法覆写"><a href="#11、子类访问父类和方法覆写" class="headerlink" title="11、子类访问父类和方法覆写"></a>11、子类访问父类和方法覆写</h2><p>子类不能直接访问父类的私有成员；<br>但是子类可以调用父类中的非私有方法来间接访问父类的私有成员。<br>Person类中有私有字段name,Student继承Person<br>new Sudent().name;        ×<br>new Student().getName();    √</p>
<p>子类拓展父类（子类是父类的一种特殊情况）<br>    主要是以父类为基础，然后添加属于自己的字段和方法。</p>
<p>方法覆写产生原因：<br>当父类中某个方法不适合于子类时,子类出现父类一模一样的方法.<br>判断必杀技:子类方法前加上@Override能编译通过,表明是方法的覆写。<br>调用被覆盖的父类方法：使用super.方法名(实参);<br>方法覆写时应遵循的原则(一同两小一大)：<br>(一同):方法签名必须相同;<br>(两小):<br>子类方法的返回值类型比父类方法的返回值类型更小或相等<br>子类方法声明抛出的异常应比父类方法申明抛出的异常更小或相等;<br>(一大):子类方法的访问权限应比父类方法更大或相等;</p>
<p>子类需要覆写父类方法。<br>当父类的某个方法不适合于子类本身的特征行为时就当覆写父类中应当改变的方法。</p>
<h2 id="12、super关键字和调用父类构造方法"><a href="#12、super关键字和调用父类构造方法" class="headerlink" title="12、super关键字和调用父类构造方法"></a>12、super关键字和调用父类构造方法</h2><p>表示父类对象的默认引用<br>如果子类要调用父类被覆盖的实例方法，可用super作为调用者调用父类被覆盖的实例方法。<br>使用super调用父类方法<br>使用super调用父类的构造方法</p>
<p>调用构造方法<br>本类中调用另一个重载构造方法用this(参数列表)<br>子类构造方法调用父类构造方法用super(参数列表)<br>子类调用父类的构造方法时：<br>super必须放在第一句<br>Java在执行子类的构造方法前会先调用父类无参的构造方法，其目的是为了对继承自父类的成员做初始化操作。<br>子类在创建对象的时候，默认调用父类的无参构造方法，要是子类构造方法中显示指定调用父类其他构造方法，就调用指定的父类构造方法，取消调用父类无参构造方法。</p>
<p>Eg：<br>package reviewDemo;</p>
<p>class A{<br>    String name;<br>    A(){<br>        System.out.println(“父类默认隐式的构造方法！”);<br>    }</p>
<pre><code>A(String name){
    System.out.println(&quot;父类显式的构造方法！&quot;);
}</code></pre><p>}</p>
<p>class B extends A{</p>
<pre><code>B(){
    super(null);
    System.out.println(&quot;子类默认隐式的构造方法！&quot;);
}</code></pre><p>}</p>
<p>public class Demo10 {<br>    public static void main(String[] args) {<br>        new B();<br>    }<br>}<br>结果：父类显式的构造方法！<br>     子类默认隐式的构造方法！</p>
<h2 id="13、面向对象之多态"><a href="#13、面向对象之多态" class="headerlink" title="13、面向对象之多态"></a>13、面向对象之多态</h2><p>多态:指同一个实体同时具有多种形式<br>好比,你去面馆吃面,说我要吃面,那么;老板给我牛肉面,鸡蛋面等都可以,<br>这就是说”面”有多种形态,也就是说实体有多种形态;<br>编译时的类型由声明该变量时使用的类型决定,运行时的类型由实际赋给变量的对象决定。<br>如果编译时类型和运行时类型不同，就出现多态。</p>
<p>Eg：<br>前提:Student  extends   Person:</p>
<p>Person p = new Person();<br>Student s = new Student();<br>Person p = new Student();//多态</p>
<p>引用关系:父类变量指向子类实例对象</p>
<p>实现多态的机制:<br>父类的引用变量可以指向子类的实例对象,而程序调用的方法在运行期才动态绑定，就是引用变量所指向的真正实例对象的方法,也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。 </p>
<p>多态的作用：<br>把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。<br>只修改方法的实现，不必修改方法的声明<br>继承是多态产生的前提条件;</p>
<p>分类:<br>编译时多态：方法重载<br>运行时多态：方法覆写</p>
<p>Eg：<br>package test;</p>
<p>class Dog{<br>    void eat(){<br>        System.out.println(“一般的狗吃一般的狗粮！”);<br>    }<br>}</p>
<p>class HashDog extends Dog{<br>    void eat(){<br>        System.out.println(“哈士奇吃哈士奇的狗粮！”);<br>    }<br>}</p>
<p>class ZangAoDog extends Dog{<br>    void eat(){<br>        System.out.println(“藏獒吃藏獒的狗粮！”);<br>    }<br>}</p>
<p>//定义一个动物园喂的方法<br>class Zoo{</p>
<pre><code>void feed(Dog d){
    d.eat();
}</code></pre><p>}</p>
<p>public class Demo11 {<br>    public static void main(String[] args) {</p>
<pre><code>    Dog hd = new HashDog();

    Dog zd = new ZangAoDog();

    Zoo z = new Zoo();
    z.feed(hd);
    z.feed(zd);
}</code></pre><p>}</p>
<p>输出：<br>哈士奇吃哈士奇的狗粮！<br>藏獒吃藏獒的狗粮！</p>
<h2 id="14、引用变量类型转换"><a href="#14、引用变量类型转换" class="headerlink" title="14、引用变量类型转换"></a>14、引用变量类型转换</h2><p>向上转型（子类→父类）：(自动完成)<br>    父类名称 父类对象 = 子类实例 ;    </p>
<p> 向下转型（父类→子类）：(强制完成)<br>    子类名称 子类对象 = （子类名称）父类实例 ;</p>
<p>对象名   instanceof  类</p>
<p>判断指定的变量名此时引用的真正类型是不是当前给出的类或子类；<br>我的总结：对象的类型和类必须有继承关系</p>
<p>Eg：<br>class A extends B{}</p>
<p>B b = new A();<br>If(b instanceof A){    …<br>}</p>
<h1 id="四、面向对象（2）"><a href="#四、面向对象（2）" class="headerlink" title="四、面向对象（2）"></a>四、面向对象（2）</h1><p>第四篇：</p>
<h2 id="1、基本数据类型的包装类"><a href="#1、基本数据类型的包装类" class="headerlink" title="1、基本数据类型的包装类"></a>1、基本数据类型的包装类</h2><p>引言：Java提倡的万物皆对象，但是数据类型的划分出现了基本数据类型和引用数据类型，那么我们怎么能把基本数据类型称为对象呢？</p>
<p>除了Integer和Character定义的名称和对应的基本类型差异大，其他六种都是将首字母大写就可以了。<br>Integer,Byte,Float,Double,Short,Long都是Number类的子类。(Number类后面讲)；<br>Character和Boolean都是Object直接子类；<br>8个类都是final修饰的(不可被继承)。</p>
<h2 id="2、基本数据类型和包装类相互转换"><a href="#2、基本数据类型和包装类相互转换" class="headerlink" title="2、基本数据类型和包装类相互转换"></a>2、基本数据类型和包装类相互转换</h2><p>把基本数据类型 → 包装类：<br>通过对应包装类的构造方法实现<br>除了Character外，其他包装类都可以传入一个字符串参数构建包装类对象。<br>包装类 → 基本数据类型<br>包装类的实例方法xxxValue();    // xxx表示包装类对应的基本数据类型</p>
<p>Eg：<br>boolean bool = false;<br>Boolean b2 = new Boolean(bool);<br>Integer i = new Integer(3);<br>int i2 = i.intValue();<br>Boolean b1 = new Boolean(“TRue”);//true<br>boolean b2 = b1.booleanValue();<br>Float f = new Float(“3.14”);//3.14<br>Integer i2 = new Integer(“123s”);//NumberFormatException</p>
<p>备注：<br>自动装箱&amp;自动拆箱</p>
<p>jdk1.5开始出现的特性：<br>自动装箱：可把一个基本类型变量直接赋给对应的包装类对象或则Object对象<br>自动拆箱：允许把 包装类对象直接赋给对应的基本数据类型</p>
<p>Eg：<br>Integer i = 3;//装箱<br>int i2 = i;//拆箱<br>Object flag = new Boolean(false);<br>if(flag instanceof Boolean){<br>    Boolean b = (Boolean)flag;<br>    boolean b2 = b;<br>}</p>
<p>我的总结：对于基本数据类型和包装类之间的装换，我们可以直接的用，相互转换，因为java5之后的自动拆箱、装箱功能！即便不知道这个，其实使用中也不影响！</p>
<h2 id="3、基本类型和String之间的转换"><a href="#3、基本类型和String之间的转换" class="headerlink" title="3、基本类型和String之间的转换"></a>3、基本类型和String之间的转换</h2><p>String → 基本类型，除了Character外所有的包装类提供parseXxx(String s)静态方法，用于把一个特定的字符串转换成基本类型变量；<br>基本类型 → String，String 类有静态方法valueOf()，用于将基本类型的变量转换成String类型。</p>
<p>String str = “17”;<br>int i = Integer.parseInt(str);//String  –&gt; 基本类型<br>String s1 = String.valueOf(i);//基本类型 –&gt; String</p>
<p>我的总结：这个从后续的学习来看，用处不大，记住有这样的方法就行，查api！</p>
<h2 id="4、Object类"><a href="#4、Object类" class="headerlink" title="4、Object类"></a>4、Object类</h2><p>所有类的公共父类，一旦一个类没有显示地继承一个类则其直接父类一定是Object。<br>一切数据类型都可用Object接收<br>class OOXX  extends Object{}等价于class ooXX {}</p>
<p>常见方法<br>public boolean equals(Object obj)：对象比较<br>public int hashCode()：取得该对象的Hash码<br>public String toString()：对象描述</p>
<p>Object类的 toString()方法：“对象的描述”<br>建议所有类都覆写此方法<br>直接打印输出对象时，会调用该对象的toString()方法。//可以不写出来<br>打印对象的时候,实际调用的对象实际指向的类的自我描述；<br>全限定类名+@+十六进制的hashCode值，等价于<br>全限定类名+@+IntegertoHexString(该对象.hashCode) </p>
<p>equals也是判断是否指向同一个对象<br>没有实际意义，有必要可以重写<br>public boolean equals(Object obj) {}<br>String 覆写了 Object的equals方法：只比较字符的序列是否相同<br>==用于判断两个变量是否相等<br>基本类型：<br>引用类型：必须指向同一个对象，才true<br>只能比较有父子或平级关系的两个对象<br>new String(“1”) == new String(“1”); ？   </p>
<h2 id="5、代码块"><a href="#5、代码块" class="headerlink" title="5、代码块"></a>5、代码块</h2><p>代码块指的是使用”{}”括起来的一段代码，根据代码块存在的位置可以分为4种:<br>普通代码块;<br>构造代码块;<br>静态代码块;<br>同步代码块(线程同步的时候讲解)。<br>代码块里变量的作用域：<br>只在自己所在区域(前后的{})内有效；</p>
<p>普通代码块：<br>普通代码块就是直接定义在方法或语句中定义的代码块：<br>public void show(){<br>普通代码块<br>}</p>
<p>构造代码块：<br>直接写在类中的代码块:<br>优先于构造方法执行，每次实例化对象之前都会执行构造代码块。</p>
<p>Eg：<br>public class Demo {<br>    {<br>         System.out.println(“我是构造代码块”);<br>    }<br>    public Demo(){<br>        System.out.println(“我是构造方法”);<br>    }<br>    public static void main(String[] args) {<br>         Demo d1  = new Demo();<br>         Demo d2  = new Demo();<br>    }<br>}</p>
<p>静态代码块<br>使用static 修饰的构造代码块:<br>优先于主方法执行，优先于构造代码块执行，不管有创建多少对象，静态代码块只执行一次，可用于给静态变量赋值；</p>
<p>Eg：<br>package reviewDemo;<br>/**</p>
<ul>
<li>测试各代码块的优先级</li>
<li>优先级顺序：静态代码块 　＞　构造代码块　＞　普通代码块</li>
<li>备注：无论创建几个对象，静态代码块只执行一次！</li>
<li>/</li>
</ul>
<p>public class Demo13 {<br>    Demo13(){<br>        System.out.println(“我是构造方法！”);<br>    }<br>    {<br>        System.out.println(“我是构造代码块！”);//实例化对象的时候才会去调用！<br>    }<br>    static{<br>        System.out.println(“我是静态代码块！”);<br>    }</p>
<pre><code>public static void main(String[] args) {
    new Demo13();
    new Demo13();//再次创建对象，证明无论创建几次对象，静态代码块都只执行一次
    System.out.println(&quot;我是普通代码块！&quot;);
}</code></pre><p>}</p>
<p>输出：<br>我是静态代码块！<br>我是构造代码块！<br>我是构造方法！<br>我是构造代码块！<br>我是构造方法！<br>我是普通代码块！</p>
<h2 id="6、构造方法的私有化"><a href="#6、构造方法的私有化" class="headerlink" title="6、构造方法的私有化"></a>6、构造方法的私有化</h2><p>有的时候我们为了避免外界创建某类的实例，就将某类的构造方法私有化，即将它的构造方法用private修饰：</p>
<p>外界如何用到？<br>提供get方法！不提供的话外界就没法创建对象！（对反射无效）</p>
<p>Eg：package reviewDemo;</p>
<p>class Stu{<br>    //将构造方法私有化<br>    private Stu(){</p>
<pre><code>}</code></pre><p>}</p>
<p>public class Demo15 {<br>    public static void main(String[] args) {<br>        Stu s = new Stu();<br>    }<br>}</p>
<h2 id="7、Singleton模式-单例模式-饿汉式和懒汉式"><a href="#7、Singleton模式-单例模式-饿汉式和懒汉式" class="headerlink" title="7、Singleton模式(单例模式) 饿汉式和懒汉式"></a>7、Singleton模式(单例模式) 饿汉式和懒汉式</h2><p>目的：整个应用中有且只有一个实例，所有指向该类型实例的引用都指向这个实例。<br>好比一个国家就只有一个皇帝(XXX)，此时每个人叫的“皇帝”都是指叫的XXX本人;</p>
<p>常见单例模式类型：<br>饿汉式单例：直接将对象定义出来<br>懒汉式单例：只给出变量，并不将其初始化；</p>
<p>我的总结：<br>饿汉式，static修饰，随着类的加载而加载，会损耗性能，但是方法相对简单<br>懒汉式  第一次用的时候相对较慢，因为需要加载！线程，不安全！</p>
<p>package reviewDemo;<br>//单例模式</p>
<p>//饿汉式,直接把对象构造出来<br>class SingleDemo{<br>    private static SingleDemo s1 = new SingleDemo();<br>    private SingleDemo(){<br>        //提供私有化的构造方法，那么外界就不能构造对象了！<br>    }</p>
<pre><code>public static SingleDemo getS1() {
    return s1;
}</code></pre><p>}</p>
<p>//懒汉式，先定义，但是不创建对象<br>class SingleDemo2{<br>    private static SingleDemo2 s3 ;</p>
<pre><code>private SingleDemo2(){
    //提供私有化的构造方法，那么外界就不能构造对象了！
}

public static SingleDemo2 getS3() {//这是一个方法，返回值为创建的对象！
    if(s3 == null){
        s3 = new SingleDemo2();
    }//和饿汉式的区别，此时才来创建对象！
    return s3;
}</code></pre><p>}</p>
<p>public class Demo14 {<br>    public static void main(String[] args) {<br>        SingleDemo s1 = SingleDemo.getS1();<br>        SingleDemo s2 = SingleDemo.getS1();</p>
<pre><code>    SingleDemo2 s3 = SingleDemo2.getS3();
    SingleDemo2 s4 = SingleDemo2.getS3();

    System.out.println(s1 == s2);
    System.out.println(s3 == s4);

}</code></pre><p>}</p>
<p>输出：true true</p>
<p>备注：枚举更加安全些<br>package reviewDemo;</p>
<p>enum Stu{<br>    jake;<br>    //将构造方法私有化起来，反射也不能创建对象，安全<br>    private Stu(){</p>
<pre><code>}</code></pre><p>}</p>
<p>public class Demo15 {<br>    public static void main(String[] args) {<br>    }<br>}</p>
<h2 id="8、final-关键字"><a href="#8、final-关键字" class="headerlink" title="8、final 关键字"></a>8、final 关键字</h2><p>①　final可以修饰类,方法,变量。<br>②　final修饰类不可以被继承，但是可以继承其他类。<br>③　final修饰的方法不可以被覆写,但可以覆写父类方法。<br>④　final修饰的变量称为常量，这些变量只能赋值一次。<br>⑤　内部类在局部时，只可以访问被final修饰的局部变量。<br>⑥　final修饰的引用类型变量,表示该变量的引用不能变,而不是该变量的值不能变;</p>
<p>Eg：<br>package reviewDemo;</p>
<p>final class Name{<br>}</p>
<p>class NewName extends Name{//ERROR，报错，因为Name有final修饰<br>}</p>
<p>public class Demo15 {<br>    public static void main(String[] args) {<br>    }<br>}</p>
<h2 id="9、抽象类"><a href="#9、抽象类" class="headerlink" title="9、抽象类"></a>9、抽象类</h2><p>当编写一个类时，我们往往会为该类定义一些方法，这些方法是用来描述该类的行为方式，那么这些方法都有具体的方法体。<br>但是有的时候，某个父类只是知道子类应该包含怎么样的方法，但是无法准确知道子类如何实现这些方法。</p>
<p>抽象方法的定义：通过abstract关键字来修饰的类称为抽象类；</p>
<p>我的总结：<br>抽象类用private修饰，里面可以有用private修饰的方法（没有方法体），强制子类进行覆写；<br>可以理解为：具有某些公共方法的一个总结类。</p>
<p>可以定义被abstract修饰的抽象方法<br>抽象方法只有返回类型和方法签名，没有方法体。</p>
<p>备注：<br>抽象类可以含有普通方法<br>抽象类不能创建实例对象（不能new）<br>需要子类覆盖掉所有的抽象方法后才可以创建子类对象，否则子类也必须作为抽象类<br>列举常见的几个抽象类：<br>流的四个基本父类<br>InputStream，OutputStream，Reader，Writer</p>
<p>我的总结：<br>抽象类是类的一种特殊情况:据有类的一切特点,但是不能实例化;一般的都得带有抽象方法。<br>抽象类不可以实例化，有时看到的近似实例化是多态机制的体现，并不是真正的实例化。<br>Eg：<br>Socket s = new Socket();<br>OutputStream os = s.getOutputStream();<br>左边是OutputStream类型变量的声明，右边是获取抽象类OutputStream的一个实例对象！</p>
<p>package testDemo2;</p>
<p>abstract class Person{<br>}</p>
<p>class Student extends Person{<br>}</p>
<p>public class Demo2 {<br>    public static void main(String[] args) {<br>        Person p = new Student();//体现的是多态，父类声明实例化子类对象。而不是抽象类实例化<br>    }<br>}</p>
<p>abstract方法 </p>
<p>分析事物时，发现了共性内容，就出现向上抽取。会有这样一种特殊情况，就是功能声明相同，但功能主体不同。</p>
<p>那么这时也可以抽取，但只抽取方法声明，不抽取方法主体。那么此方法就是一个抽象方法。</p>
<p>abstract [非private访问修饰符] 返回值类型 方法名称(参数列表);<br>抽象方法要存放在抽象类中。<br>抽象方法也可以存在于接口中</p>
<p>Eg：<br>package reviewDemo;</p>
<p>abstract class Person3{<br>    abstract void show();<br>    abstract void inof();<br>    void turn(){<br>    }<br>}</p>
<p>class NewP extends Person3{<br>    @Override<br>    void show() {<br>    }</p>
<pre><code>@Override
void inof() {
}
//不覆写的话会报错</code></pre><p>}</p>
<p>public class Demo15 {<br>    public static void main(String[] args) {<br>        //new Person3();报错！因为抽象类不可以实例化<br>    }<br>}</p>
<h2 id="10、抽象类的体现-模板模式"><a href="#10、抽象类的体现-模板模式" class="headerlink" title="10、抽象类的体现-模板模式"></a>10、抽象类的体现-模板模式</h2><p>抽象类是多个具体子类抽象出来的父类,具有高层次的抽象性;以该抽象类作为子类的模板可以避免子类设计的随意性;</p>
<p>抽象类的体现主要就是模板模式设计,抽象类作为多个子类的通用模板,子类在抽象类的基础上进行拓展,但是子类在总体上大致保留抽象类的行为方式;<br>编写一个抽象父类,该父类提供了多个子类的通用方法,并把一个或多个抽象方法留给子类去实现,这就是模板设计模式;</p>
<p>模板模式应用的简单规则:<br>1.抽象父类可以只定义需要使用的某些方法,其余留给子类去实现;<br>2.父类提供的方法只是定义了一个通用算法,其实现必须依赖子类的辅助;</p>
<p>我的总结：<br>如果父类的方法不想被子类覆写，那么可以在前面加上final关键字修饰。</p>
<p>Eg：<br>package reviewDemo;<br>//模板模式</p>
<p>//抽象类中包含很多的抽象方法，子类必须去覆写！<br>abstract class Method{<br>    abstract double mul();//返回值类型如果是void的话，下面报错，因为没有返回值，无法引用！<br>    abstract double divid();<br>    void show(){<br>        System.out.println(“面积是：”+mul());//周长<br>        System.out.println(“面积是：”+divid());//面积<br>    }<br>}</p>
<p>class Square extends Method{<br>    double d;</p>
<pre><code>public Square(double d) {
    super();
    this.d = d;
}

@Override
double mul() {
    return d * d;
}

@Override
double divid() {
    return 4 * d;
}</code></pre><p>}</p>
<p>class Cirle extends Method{<br>    double r;</p>
<pre><code>public Cirle(double r) {
    super();
    this.r = r;
}

@Override
double mul() {
    return 2 * 3.14 * r;
}

@Override
double divid() {
    return 3.14 * r * r;
}</code></pre><p>}</p>
<p>public class Demo16 {<br>    public static void main(String[] args) {<br>        Square s = new Square(5);<br>        s.show();<br>        Cirle c = new Cirle(4);<br>        c.show();<br>    }<br>}</p>
<h2 id="11、接口-interface"><a href="#11、接口-interface" class="headerlink" title="11、接口(interface)"></a>11、接口(interface)</h2><p>引入：抽象类是从多个类中抽象出来的模板，若要将这种抽象进行得更彻底，就得用到一种特殊的“抽象类”→ 接口;</p>
<p>例子：<br>生活中听说过的USB接口其实并不是我们所看到的那些插槽,而是那些插槽所遵循的一种规范;而我们看到的那些插槽是根据USB规范设计出来的实例而已,也就说插槽是USB的实例;<br>对应不同型号的USB设备而言,他们各自的USB插槽都需要遵循一个规范,遵守这个规范就可以保证插入插槽的设备能与主板正常通信;</p>
<p>对于同一种型号的主板上的多个USB插槽,他们有相同的数据交换方式,相同的实现细节,可认为他们都是同一个类的不同实例</p>
<p>我的总结：<br>接口只定义了类应当遵循的规范,却不关心这些类的内部数据和其方法内的实现细节.<br>接口只规定了这些类里必须提供的方法;从而分离了规范和实现.增强了系统的可拓展性和维护性;</p>
<p>使用接口的好处,拓展性,维护性更好,所以我们在开发中会经常用到接口.（相当于定义了一种标准）</p>
<p>接口,类,对象示意图</p>
<p>interface定义</p>
<p>接口定义一种规范,规定一个类必须做什么,但它不管如何具体去做;<br>[修饰符] interface 接口名 extends 父接口1,父接口2….<br>没有构造方法,不能实例化;<br>接口只能继承接口,不能继承类<br>接口里没有普通方法,方法全是抽象的;<br>接口里的方法默认修饰符是public abstract；<br>接口里的字段全是全局常量,默认修饰符是public static final;<br>接口里的成员包括(主要是前两个)：</p>
<p>全局常量<br>公共的抽象方法<br>内部类(包括内部类,内部接口,内部枚举类);</p>
<p>我的总结：<br>接口没有构造方法，不能实例化！<br>接口里的方法全部是抽象的，没有普通方法，有默认的修饰符 public abstract，必须全部覆写！</p>
<h2 id="12、接口的使用"><a href="#12、接口的使用" class="headerlink" title="12、接口的使用"></a>12、接口的使用</h2><p>格式:public class SubImpl  extends Super  implements IA,IB<br>接口可以多继承,但是只能继承接口,不能继承类。</p>
<p>实现接口(支持多实现)<br>[修饰符] class 类名 implements 接口1，接口2…<br>接口的实现必须在 extends 之后；<br>实现接口的方法必须是 public 类型</p>
<p>接口不能创建实例，但是可以声明引用类型的变量。<br>此时，引用类型的变量必须指向到其实现类对象。<br>IStudent s = new String();//<br>IStudent s = new StudentImpl();//</p>
<p>接口与类之间的关系：<br>实现关系或者说是继承关系.<br>可以说类实现了接口的方法，也可以说类继承了接口的方法，不同情况下不同的理解！</p>
<h2 id="13、面向接口编程之制定标准和简单工厂模式"><a href="#13、面向接口编程之制定标准和简单工厂模式" class="headerlink" title="13、面向接口编程之制定标准和简单工厂模式"></a>13、面向接口编程之制定标准和简单工厂模式</h2><p>制定一个标准，让别人去实现或者说满足它！<br>Eg：<br>interface USB{//定义USB标准<br>    void useUSB();//USB有使用USB的行为<br>}</p>
<p>简单工厂模式<br>构建一个工厂出来，在里面进行生产，用的时候直接拿</p>
<p>我的总结：<br>好处:屏蔽不同子类实现的差异，提高代码的可拓展性和可维护性;</p>
<p>package reviewDemo;<br>//简单工厂模式</p>
<p>interface Phone{//制定标准，都要实现send()方法<br>    public void send();<br>}</p>
<p>class Iphone implements Phone{<br>    @Override<br>    public void send() {<br>        System.out.println(“Iphone手机在发短信”);<br>    }<br>}</p>
<p>class AndroidPhone implements Phone{<br>    @Override<br>    public void send() {<br>        System.out.println(“AndroidPhone手机在发短信”);<br>    }<br>}</p>
<p>class MyPhone implements Phone{<br>    @Override<br>    public void send() {<br>        System.out.println(“MyPhone手机在发短信”);<br>    }<br>}</p>
<p>class Factory{<br>    public static void show(String type){//传入参数，根据不同的类型个性化定制<br>        if(type.equals(“”)){//为空的情况，不用往下执行<br>            System.out.println(“对不起，类型为空！,请重新输入！”);<br>            return;<br>        }<br>        Phone p = null;<br>        if(“Iphone”.equals(type)){//判断类型<br>            p = new Iphone();<br>        }else if(“AndroidPhone”.equals(type)){<br>            p = new AndroidPhone();<br>        }else{<br>            p = new MyPhone();<br>        }<br>        p.send();<br>    }<br>}</p>
<p>public class FactoryDemo17 {<br>    public static void main(String[] args) {</p>
<pre><code>    new Factory().show(&quot;Iphone&quot;);//调用方法
    new Factory().show(&quot;AndroidPhone&quot;);
    new Factory().show(&quot;MyPhone&quot;);
    new Factory().show(&quot;YourPhone&quot;);
    new Factory().show(&quot;&quot;);
}</code></pre><p>}</p>
<p>输出：<br>Iphone手机在发短信<br>AndroidPhone手机在发短信<br>MyPhone手机在发短信<br>MyPhone手机在发短信<br>对不起，类型为空！</p>
<h2 id="14、面向接口编程之适配器模式"><a href="#14、面向接口编程之适配器模式" class="headerlink" title="14、面向接口编程之适配器模式"></a>14、面向接口编程之适配器模式</h2><p>使用一个现成的类，但是它的接口不完全符合你的需求,我只想要它其中的一个方法，不想覆写其他的方法。</p>
<p>比如,窗体有变大,变小,关闭的行为,但是我现在只需要关闭行为;</p>
<p>package reviewDemo;<br>//适配器模式：只想用其中的某一个方法，用适配器作为中间的过渡</p>
<p>interface Windows{<br>    void max();<br>    void min();<br>    void close();<br>}</p>
<p>//适配器模式，实现接口所有的方法，但是不写方法体！<br>class AdapterWindows implements Windows{</p>
<pre><code>@Override
public void max() {
}

@Override
public void min() {
}

@Override
public void close() {
}</code></pre><p>}</p>
<p>class MyWindows extends AdapterWindows{<br>    //覆写父类的方法<br>    public void close(){<br>        System.out.println(“这个实现的是关闭功能！”);<br>    }<br>}</p>
<p>public class Demo17 {<br>    public static void main(String[] args) {<br>        new MyWindows().close();<br>    }<br>}</p>
<h2 id="15、接口和抽象类的比较"><a href="#15、接口和抽象类的比较" class="headerlink" title="15、接口和抽象类的比较"></a>15、接口和抽象类的比较</h2><p>相同点:<br>都位于继承的顶端,用于被其他实现或继承;<br>都不能实例化;<br>都包含抽象方法,其子类都必须覆写这些抽象方法;</p>
<p>区别:<br>抽象类为部分方法提供实现,避免子类重复实现这些方法,提供代码重用性;接口只能包含抽象方法;<br>一个类只能继承一个直接父类(可能是抽象类),却可以实现多个接口;(接口弥补了Java的单继承)</p>
<p>二者的选用:<br>优先选用接口,尽量少用抽象类;<br>需要定义子类的行为,又要为子类提供共性功能时才选用抽象类;</p>
<p>我的总结：<br>接口不能有构造函数，抽象类是可以有构造函数的，<br>abstract可以定义构造函数（包括带函数的构造函数），因为要保证其子类在创建的时候能够进行正确的初始化，但是Abstract类不能被实例化。</p>
<p>知识点：如果不可以或者没有创建对象，那么我们必须加上static修饰，不能用对象调用，就只好用类去调用。</p>
<h2 id="16、匿名内部类"><a href="#16、匿名内部类" class="headerlink" title="16、匿名内部类"></a>16、匿名内部类</h2><p>适合只使用一次的类<br>不能是抽象类，因为系统在创建匿名内部类的时候，会立即创建匿名内部类的对象。<br>匿名内部类不能定义构造器，因为匿名内部类没有类名。</p>
<p>格式：<br>new 父类构造器([实参列表]) 或 接口()<br>{<br>//匿名内部类的类体部分<br>}</p>
<h2 id="17、枚举类"><a href="#17、枚举类" class="headerlink" title="17、枚举类"></a>17、枚举类</h2><p>使用enum声明,默认直接继承了java.lang.Enum类，而不是Object类；<br>枚举类的对象是固定的,实例个数有限,不可以再new( ),枚举对象后可以跟()。<br>枚举元素必须位于枚举类体中的最开始部分,枚举元素后要有分号与其他成员分隔。<br>枚举类的构造方法的权限修饰符默认是private；<br>一旦枚举对象后面加上{},那么该对象实际是枚举匿名内部类对象;<br>所有枚举类都提供一个静态的values()方法(返回该枚举类所有对象组成的数组),便于遍历所有枚举对象；<br>所有枚举类都提供一个静态的valueOf(String name)方法, 返回枚举类中对象名等于 name的对象。</p>
<p>Eg：public enum Color{<br>    RED(), GREEN(){}, BLUE{};<br>}</p>
<p>package reviewDemo;<br>//枚举</p>
<p>enum Color{<br>    Green,Blue,Yellow;</p>
<pre><code>@Override
public String toString() {
    String ret = super.toString();
    switch (this) {
    case Green:
        ret = &quot;绿色&quot;;
        break;

    case Blue:
        ret = &quot;蓝色&quot;;
        break;

    case Yellow:
        ret = &quot;黄色&quot;;
        break;

    default:
        break;
    }

    return ret;
}</code></pre><p>}</p>
<p>class Personp{<br>    Color c = Color.Blue;<br>    void show(){<br>        System.out.println(c);<br>    }<br>}</p>
<p>public class Demo18 {<br>    public static void main(String[] args) {<br>        Color []color = Color.values();<br>        for (Color c : color) {<br>            System.out.println(c);<br>        }<br>        new Personp().show();<br>    }<br>}<br>输出：<br>绿色<br>蓝色<br>黄色<br>蓝色</p>
<p>枚举类覆写接口抽象方法的两种方式：<br>在枚举类中实现接口的抽象方法；<br>在枚举匿名内部类中实现接口的抽象方法；</p>
<p>interface I{<br>    void show();<br>}</p>
<p>enum Color implements I{<br>    RED(){<br>    public void show(){<br>        }<br>    }, GREEN{<br>    public void show(){<br>        }<br>    }, BLUE{<br>    public void show(){<br>        }<br>    };<br>}</p>
<p>enum Color implements I{<br>    RED(), GREEN, BLUE;<br>    public void show() {<br>    }<br>}</p>
<p>我的总结：<br>枚举不可以new();即便是反射也不可以！</p>
<p>备注：一个类如果没有构造方法，那么一定有相对应的某个方法可以获取对象！</p>
<h1 id="五、异常处理和常用类"><a href="#五、异常处理和常用类" class="headerlink" title="五、异常处理和常用类"></a>五、异常处理和常用类</h1><p>第五篇</p>
<h2 id="1、异常"><a href="#1、异常" class="headerlink" title="1、异常"></a>1、异常</h2><p>异常：就是不正常，是指程序在运行时出现的不正常情况。其实就是程序中出现的问题。这个问题按照面向对象思想进行描述，并封装成了对象。因为问题的产生有产生的原因、有问题的名称、有问题的描述等多个属性信息存在。当出现多属性信息最方便的方式就是将这些信息进行封装。异常就是java按照面向对象的思想将问题进行对象封装。这样就方便于操作问题以及处理问题。</p>
<p>出现的问题有很多种，比如角标越界，空指针等都是。就对这些问题进行分类。而且这些问题都有共性内容比如：每一个问题都有名称，同时还有问题描述的信息，问题出现的位置，所以可以不断的向上抽取。形成了异常体系。 </p>
<p>异常的体系  Throwable<br>Error<br>通常指JVM出现重大问题如：运行的类不存在或者内存溢出等。<br>不需要编写针对代码对其处理，程序无法处理。<br>Exception<br>在运行时运行出现的一些情况，可以通过try,catch,finally处理</p>
<p>异常处理两种方式：<br>1、捕获异常：try catch        直接处理可能出现的异常！<br>2、声明异常：throws            声明告诉调用者可能的异常，暴露问题，调用者自己处理！</p>
<p>我的总结：<br>Exception 和 Error的子类名大都是以父类名作为后缀。<br>Java异常其实是对不正常情况的一种描述,并将其封装成对象;<br>Java在 设计异常体系时，将容易出现的异常情况都封装成了对象。</p>
<h2 id="2、异常处理格式"><a href="#2、异常处理格式" class="headerlink" title="2、异常处理格式"></a>2、异常处理格式</h2><p>异常处理的5个关键字<br>try ,catch,<br>finally<br>throw, throws</p>
<p>我的总结：<br>捕获异常：先捕获小异常再捕获大异常。<br>程序是调出来的，不是写出来的；多测试是程序员的必修课。<br>异常处理后，程序不会因为出现异常而退出!</p>
<p>异常处理格式<br>try{<br>        //可能出异常的代码<br>} catch(异常类  对象){<br>        //处理该异常类型的语句<br>}<br>[finally] {<br>        //一定会执行的代码<br>        //catch块使用System.exit(1);除外<br>}</p>
<p>备注：当try语句块出现异常，程序会自动跳到catch语句块去找匹配的异常类型，并执行异常处理语句，finally语句块是异常的统一出口。</p>
<h2 id="3、多异常处理"><a href="#3、多异常处理" class="headerlink" title="3、多异常处理"></a>3、多异常处理</h2><p>声明异常时尽可能声明具体异常类型,方便更好的处理;<br>方法声明几个异常就对应有几个catch块;<br>若多个catch块中的异常出现继承关系,父类异常catch块放在最后;<br>在catch语句块使用Exception类作为异常类型时：<br>所有子类实例都可以使用父类接收(向上转型)，即所有的异常对象都可以使用Exception接收;<br>注：在java处理多异常时捕获小范围的异常必须放在大范围异常之前。</p>
<p>java7 - 同时捕获多个异常类型<br>Java7之前：<br>try {<br>    int a = Integer.parseInt(“1”);<br>    int b = Integer.parseInt(“0”);<br>    int c = a / b;<br>    System.out.println(c);<br>} catch (NumberFormatException e)<br>{<br>   e.printStackTrace();<br>} catch(ArithmeticException e)<br>{<br>    e.printStackTrace();<br>}</p>
<p>Java7：将多个异常写到了同一个catch代码块<br>try {<br>Integer a = Integer.parseInt(“1”);<br>Integer b = Integer.parseInt(“0”);</p>
<p>Integer c = a / b;</p>
<p>System.out.println(c);</p>
<p>} catch (NumberFormatException<br>    | ArithmeticException  e ) {<br>     e.printStackTrace();<br>}</p>
<h2 id="4、异常的分类"><a href="#4、异常的分类" class="headerlink" title="4、异常的分类"></a>4、异常的分类</h2><p>异常分类:<br>编译时被检查异常;     —&gt; Checked异常<br>在程序中必须使用try…catch处理；<br>编译时不被检测的异常;    —&gt; Runtime异常<br>可以不使用try…catch处理，但一旦出现异常就将由JVM处理。</p>
<p>异常的分类之Runtime异常</p>
<p>RuntimeException(运行时异常)是指因设计或实现方式不当而导致的问题.<br>说白了,就是程序员造成的,程序员小心谨慎是完全可以避免的异常.比如,事先判断对象是否为null就可以避免NullPointerException异常,事先检查除数不为0就可以避免ArithmeticException异常;</p>
<p>特点:<br>这种异常Java编译器不会检查它,也就说程序中出现这类异常的时候,即使不处理也没有问题,但是一旦出现异常,程序将异常终止,若采用异常处理,则会被相应的程序执行处理.</p>
<p>异常的分类之Checked异常</p>
<p>除了RuntimeException以及子类,其他的Exception及其子类都是受检查异常,我们也可以称为非RuntimeException异常.<br>特点:<br>Java编译器会检查它,也就说程序中一旦出现这类异常,要么是没有try-catch语句捕获,或throws语句没有声明抛出它,编译就不会通过,也就说这种异常,程序要求必须处理.</p>
<h2 id="5、声明异常（throws）"><a href="#5、声明异常（throws）" class="headerlink" title="5、声明异常（throws）"></a>5、声明异常（throws）</h2><p>在可能出现异常的方法上声明抛出可能出现异常的类型：<br>声明的时候尽可能声明具体的异常,方便更好的处理.<br>当前方法不知道如何处理这种异常，可将该异常交给上一级调用者来处理(非RuntimeException类型的异常)。<br>方法一旦使用throws声明抛出方法内可能出现的异常类型， 该方法就可以不再过问该异常了；<br>一个方法调用另一个使用throws声明抛出的方法，自己要么try…catch , 要么也throws;</p>
<p>格式：<br>public 返回值类型  方法名(参数列表…)<br>            throws 异常类A,异常类B… {</p>
<p>}</p>
<h2 id="6、throw"><a href="#6、throw" class="headerlink" title="6、throw"></a>6、throw</h2><p>自行抛出一个异常对象，抛出异常类的对象；<br>若throw抛出的是Runtime异常：<br>程序可以显示使用try…catch来捕获并处理，也可以不管，直接交给方法调用者处理；<br>若throw抛出Checked异常：<br>要么放在try里自己处理，要么放在一个throws声明的方法里面，交给调用者处理。</p>
<p>Eg：<br>    public static void main(String[] args) {<br>        try {<br>              fn1(1);<br>        } catch (Exception e) { e.printStackTrace(); }<br>        fn2(2);<br>    }<br>    public static void fn1(int a) throws Exception{<br>        if(a &gt;0) { throw new Exception(“fn1 – a值不合法”); }<br>    }<br>    public static void fn2(int a) {<br>        if(a &gt;0) { throw new RuntimeException(“a值不合法”); }<br>    }</p>
<p>throws &amp; throw</p>
<p>throws用于在方法上声明该方法不需要处理的异常类型。<br>throw用于抛出具体异常类的对象。<br>throws与throw的区别：<br>thorws用在方法上，后面跟异常类名,可以是多个异常类。<br>throw用在方法内，后面跟异常对象,只能是一个。</p>
<h2 id="7、finally"><a href="#7、finally" class="headerlink" title="7、finally"></a>7、finally</h2><p>异常的统一出口：<br>不管try块程序是否异常，也不管哪个catch执行，finally块总会执行。<br>try语句块或会执行的catch语句块使用了JVM系统退出语句例外;//System.exit(1);<br>try块必须和 catch块或和finally同在，不能单独存在，二者必须出现一个。<br>不要在finally中使用return 或throw语句，否则将会导致try、catch中的return或throw失效。</p>
<p>我的总结：finally代码块只在一种情况下不执行：System.exit(0)；</p>
<p>Eg：<br>package reviewDemo;</p>
<p>public class Demo19 {<br>    public static void main(String[] args) {<br>        try{<br>            System.out.println(17/0);<br>        }catch(Exception e){<br>            //e.printStackTrace();<br>            System.out.println(“程序错误，请修正！”);<br>        }finally{<br>            System.out.println(“这是finally代码块！”);<br>        }<br>    }<br>}</p>
<p>输出：<br>程序错误，请修正！<br>这是finally代码块！</p>
<h2 id="8、throw和catch同时使用"><a href="#8、throw和catch同时使用" class="headerlink" title="8、throw和catch同时使用"></a>8、throw和catch同时使用</h2><p>当异常出现在当前方法中,程序只对异常进行部分处理,还有一些处理需要在方法的调用者中才能处理完成,此时还应该再次抛出异常,这样就可以让方法的调用者也能捕获到异常;</p>
<p>Eg：<br>public static void buy(String price) throws Exception {<br>    try {<br>        if(price != null)<br>            Double.parseDouble(price);<br>    } catch (Exception e) {<br>        e.printStackTrace();<br>        throw new Exception(“价格不能只能是数字组成”);<br>    }<br>}<br>public static void main(String[] args)  {<br>    try {<br>        buy(null);<br>    } catch (Exception e) {<br>        System.out.println(e.getMessage());<br>    }<br>}</p>
<h2 id="9、常用类"><a href="#9、常用类" class="headerlink" title="9、常用类"></a>9、常用类</h2><p>String<br>String表示字符串,所谓字符串,就是一连串的字符;<br>String是不可变类，一旦String对象被创建，包含在对象中的字符序列(内容)是不可变的，直到对象被销毁；</p>
<p>常量池:JVM中一块独立的区域存放字符串常量和基本类型常量（public static final）。<br>String使用private final char value[]来实现字符串的存储,也就是说String对象创建之后,就不能再修改此对象中存储的字符串内容,就是因为如此,才说String类型是不可变的.<br>String对象比较:<br>单独使用””引号创建的字符串都是常量,编译期就已经确定存储到常量池中；<br>使用new String(“”)创建的对象会存储到堆内存中,是运行期新创建的；<br>使用只包含常量的字符串连接符如”aa” + “bb”创建的也是常量,编译期就能确定,已经确定存储到常量池中；<br>使用包含变量的字符串连接符如”aa” + s1创建的对象是运行期才创建的,存储在堆中；</p>
<p>Eg：<br>package string;</p>
<p>public class StringDemo {<br>    public static void main(String[] args) {<br>        /*<br>         *  “” 其实表示的是  String的匿名对象<br>         <em>/<br>        String s = “”;<br>        /**<br>         * String()    初始化一个新创建的 String 对象，使其表示一个空字符序列。<br>         *  “”,不是表示 null<br>         *  String(String original)<br>         *  String s = new String(“asd”);// s 的值就是 asd<br>         <em>/<br>        s = new String();//“”<br>        String s1  = new String(“11”);<br>        String s2  = new String(“11”);<br>        System.out.println(s1 == s2);//false<br>        String s3 = “22”;<br>        String s4 = “22”;<br>        System.out.println(s3 == s4);//true<br>        System.out.println(s3 == s2);//false<br>        String  s5 = “2” + “2”;//这句话其实在编译器编译后的class文件中 已经变成  “22”<br>        //s5创建了几个对象?//回答：最多一个，如果常量池里面没有就是创建一个，如果常量池里本来就有就是创建零个！下面的str一样的道理。<br>        String str = “A” +”B”+ “C” +”D” +”E”;//String str = “ABCDE”;<br>        System.out.println(s3 == s5);//true<br>        /*</em><br>         * String特点:      不可变的,  一个String对象的内容不能变,一旦内容变量该对象就变成一个新的String对象了<br>         *     String  str = “AAA”;<br>         *     str = str+”12”;<br>         */<br>        String str1 = “ABCDE”;<br>        System.out.println(str == str1);//true<br>        String str2 = “ABC” + “DE”;<br>        System.out.println(str == str2);//true<br>        String  ss = “AB”;<br>        String str3 = ss + “CDE”;//这里的str3在运行期才能确定内容值<br>        System.out.println(str3 == str2);//false<br>        String str4 = getStr() +”CDE”;//在运行期才能确定 str4的值<br>        System.out.println(str == str4);//false<br>        System.out.println(str3 == str4);//false<br>        /</em><br>         *  String s = “cd”;    //一个String对象<br>            s = s + “itcast”;    //itcast也是String对象, 最后的s的值cditcast,也是一个String对象<br>            System.out.print(s);<br>         * */<br>    }<br>    public static String getStr(){<br>        return “AB”;<br>    }<br>}</p>
<p>Eg:<br>package reviewDemo;</p>
<p>public class Demo20 {<br>    public static void main(String[] args) {<br>        //s1,s2只新建了一个对象<br>        String s1 = “你好”;<br>        String s2 = “你好”;</p>
<pre><code>    //s3,s4新建了两个对象
    String s3 = &quot;你好&quot;;
    String s4 = &quot;你好&quot;;
}</code></pre><p>}</p>
<h2 id="10、String方法"><a href="#10、String方法" class="headerlink" title="10、String方法"></a>10、String方法</h2><p>String():初始化一个新的 String 对象，使其表示一个空字符序列，并不是返回空(不等于 null)。<br>String(StringBuffer buffer):根据StringBuffer对象来创建String对象；<br>String(StringBuilder builder):同上<br>char charAt(int index):取字符串中指定位置的字符，index从0开始计算。<br>String concat(String str):连接字符串，等同于 “+”；<br>boolean contentEquals(StringBuffer buffer):若二者包含的字符序列相同时就返回true;<br>boolean equals(Object obj):将该字符串与指定对象比较，若二者包含的字符序列相等返回true；<br>boolean equalsIgnoreCase(String anotherString) 将此 String 与另一个 String 比较，不考虑大小写;<br>byte[] getBytes():将该字符串转换成byte数组；</p>
<p>int indexOf(String str):找出str字符串在该字符串中第一次出现的位置；<br>int indexOf(String str, int fromIndex) 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始;<br>int lastIndexOf(String str) 返回指定子字符串在此字符串中最后一次出现处的索引;<br>int length():返回当前字符串长度；<br>String replace(char oldChar, char newChar) :返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。<br>String replaceAll(String regex, String replacement) 使用给定的 字符串replacement 替换此字符串所有的regex字符串;<br>boolean startsWith(String prefix) 测试此字符串是否以指定的前缀开始.</p>
<p>String[] split(String regex)： 把字符串按指定的字符串分隔开。<br>String substring(int beginIndex) 返回一个新的字符串，从beginIndex开始截取，它是此字符串的一个子字符串;<br>String substring(int beginIndex, int endIndex) 返回一个新字符串，它是此字符串的一个子字符串;[begin,end)<br>char[] toCharArray() 将此字符串转换为一个新的字符数组。<br>String toLowerCase() 将此 String 中的所有字符都转换为小写;<br>String toUpperCase()转成大写;<br>static String valueOf(基本类型 obj):把基本类型值转成字符串;<br>String trim() ：忽略字符串前导空白和尾部空白。 </p>
<p>String小练习</p>
<p>判断字符串是否由数字组成：</p>
<p>package reviewDemo;</p>
<p>public class Demo20 {<br>    public static void main(String[] args) {</p>
<pre><code>String s1 = &quot;123456789&quot;;
String s2 = &quot;12345  6789&quot;;
System.out.print(isnum(s1));</code></pre><p>System.out.print(isnum(s2));<br>    }</p>
<pre><code>public static boolean isnum(String s){
    char []ch = s.toCharArray();
    for (char c : ch) {
        if(!(c &gt; &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;)){
            return false;
        }
    }
    return true;
}</code></pre><p>}</p>
<p>输出：</p>
<p>true<br>false</p>
<p>判断字符串是否为空：<br>分析：<br>字符串的空有两种情况：1、null；2、””;<br>package reviewDemo;</p>
<p>public class Demo21 {<br>    public static void main(String[] args) {</p>
<pre><code>    String s1 = &quot;&quot;;
    System.out.println(isimpty(s1));

}

public static String isimpty(String s){

    if(s != null &amp; !&quot;&quot;.equals(s)){
        return &quot;不为空&quot;;
    }
    return &quot;为空！&quot;;
}</code></pre><p>}</p>
<h2 id="11、StringBuffer和StringBuild"><a href="#11、StringBuffer和StringBuild" class="headerlink" title="11、StringBuffer和StringBuild"></a>11、StringBuffer和StringBuild</h2><p>String是不可变类，一旦String对象被创建，包含在对象中的字符序列是不可变的，直到对象被销毁；</p>
<p>StringBuffer 与 StringBuilder对象则是可变的！</p>
<p>举例说明这两个的好处：（不用每次新建对象，效率高！）</p>
<p>package reviewDemo;</p>
<p>public class Demo22 {<br>    public static void main(String[] args) {</p>
<pre><code>String s = &quot;&quot;;
long begintime = System.currentTimeMillis();
for(int i = 1;i &lt;= 100000;i++){
    s += i;
}</code></pre><p>​<br>​        long endtime = System.currentTimeMillis();<br>​        long time = endtime - begintime;<br>​        System.out.println(“运行时间为：”+time);<br>​<br>​        StringBuffer s1 = new StringBuffer();<br>​        s = “”;<br>​        begintime = System.currentTimeMillis();<br>​        for(int i = 1;i &lt;= 100000;i++){<br>​            s = “”+i;<br>​            s1 = new StringBuffer(s);<br>​        }<br>​<br>​        endtime = System.currentTimeMillis();<br>​        time = endtime - begintime;<br>​        System.out.println(“运行时间为：”+time);<br>​<br>    }<br>}</p>
<p>输出：<br>运行时间为：82922<br>运行时间为：15<br>可以看得出：StringBuffer这两个效率相当高！</p>
<p>StringBuffer：  是线程安全的；<br>StringBuilder： 是线程不安全的，性能高点，推荐使StringBuilder；(jdk1.5出现)<br>StringBuffer的字符序列是可变的(通过append等方法操作)<br>StringBuffer  和  String之间的转换；<br>String toString() 返回此序列中数据的字符串表示形式。<br>StringBuffer(String str):以指定的字符串创建StringBuffer对象。</p>
<p>StringBuffer方法</p>
<p>public StringBuilder()构造一个不带任何字符的StringBuilder对象。<br>StringBuffer(String str) ：构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容。<br>StringBuffer append(Object o) ：将指定的任意类型对象追加到此StringBuffer 对象。<br>StringBuffer insert(int offset, Object o) :将任意类型参数的字符串表示形式插入此序列中。<br>StringBuffer delete(int start, int end) :移除此序列的子字符串中的字符。<br>StringBuffer deleteCharAt(int index): 移除此序列指定位置的 char。  </p>
<p>Eg：</p>
<p>package reviewDemo;</p>
<p>/**</p>
<ul>
<li>用StringBuilder 或StringBuffer:<br> 把字符串“ABCDE”;<br> 转变成字符串“A,B,C,D”</li>
<li>/</li>
</ul>
<p>public class Demo23 {<br>    public static void main(String[] args) {<br>        //第一种方法：往里面插入；<br>        StringBuilder sb = new StringBuilder(“ABCDE”);<br>        sb.deleteCharAt(sb.length()-1);<br>        System.out.println(sb);<br>        for (int i = 0; i &lt; sb.length(); i+=2) {<br>            sb.insert(i, “,”);<br>        }<br>        sb.deleteCharAt(0);</p>
<pre><code>System.out.println(sb);</code></pre><p>​<br>​        //第二种方法：往里面追加，要追加必须遍历，必须换为数组！<br>​        sb = new StringBuilder(“ABCDE”);<br>​        sb.deleteCharAt(sb.length()-1);<br>​        System.out.println(sb);<br>​        char []cs = sb.toString().toCharArray();<br>​        StringBuilder sb1 = new StringBuilder();<br>​        for (char c : cs) {<br>​            sb1.append(c).append(“,”);<br>​        }<br>​        sb1.deleteCharAt(sb1.length()-1);<br>​        System.out.println(sb1);<br>​    }<br>}</p>
<p>编写一个程序，这个程序把一个整数数组中的每个元素用逗号连接成一个字符串，例如，根据内容为{1，2，3}的数组形成内容为”1,2,3”的字符串。</p>
<p>package reviewDemo;<br>/**</p>
<ul>
<li>编写一个程序，</li>
<li>这个程序把一个整数数组中的每个元素用逗号连接成一个字符串，</li>
<li>例如，根据内容为{1，2，3}的数组形成内容为”1,2,3”的字符串。</li>
<li>/</li>
</ul>
<p>public class Demo24 {<br>    public static void main(String[] args) {<br>        int []i = {1,2,3,4,5};<br>        StringBuilder sb = new StringBuilder();<br>        for (int j : i) {<br>            sb.append(j).append(“,”);<br>        }<br>        sb.deleteCharAt(sb.length()-1);<br>        System.out.println(sb);<br>    }<br>}</p>
<h2 id="12、Math和Random和UUID"><a href="#12、Math和Random和UUID" class="headerlink" title="12、Math和Random和UUID"></a>12、Math和Random和UUID</h2><p>Math类<br>public final class Math extends Object<br>以下X表示double,float,int, long<br>abs(X x):求绝对值<br>max(X x1,X x2):求最大值<br>min(X x1,X x2)：求最小值<br>public static double random()：返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。和使用new java.util.Random一样<br>Math.PI;</p>
<p>Random类<br>负责生成伪随机数；<br>Random() 创建一个新的随机数生成器。<br>int nextInt() 返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的 int 值。<br>int nextInt(int n)  返回一个伪随机数，它是取自此随机数生成器序列的、在 0（包括）和指定值n（不包括）之间均匀分布的 int 值。 </p>
<p>package reviewDemo;</p>
<p>public class Demo26 {<br>    public static void main(String[] args) {<br>        System.out.println(Math.E);//2.718281828459045<br>        int a = 12;<br>        int b = 25;</p>
<pre><code>    System.out.println(Math.max(a,b));//这里可以使用静态导入（导入Math类中的方法，这样的话前面就不用写上Math.）
    System.out.println(Math.min(a,b));
}</code></pre><p>}</p>
<p>package reviewDemo;</p>
<p>import java.util.UUID;</p>
<p>public class Demo27 {<br>    public static void main(String[] args) {<br>        UUID u = UUID.randomUUID();<br>        String s = u.toString();<br>        System.out.println(s);//此时是随机生成的，肯定每次都不一样，全网唯一！</p>
<pre><code>    u = new UUID(1222222222, 12);//根据构造方法来
    s = u.toString();
    System.out.println(s);//这一个的UUID是固定的。
}</code></pre><p>}</p>
<p>我的总结：UUID（用来标示文件名等（免得文件上传因为名字可能一样而被覆盖），可以保证全网唯一！）</p>
<p>UUID类:用唯一标识符 (UUID) 的类。 UUID 表示一个 128 位的值。<br>UUID(Universally Unique Identifier)全局唯一标识符,是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字。由以下几部分的组合：当前日期和时间(UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同)，时钟序列，全局唯一的IEEE机器识别号（如果有网卡，从网卡获得，没有网卡以其他方式获得），UUID的唯一缺陷在于生成的结果串会比较长。<br>标准的UUID格式为：xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxx (8-4-4-4-12),其中每个 x 是 0-9 或 a-f 范围内的一个十六进制的数字;<br>UUID uuid = UUID.randomUUID();<br>String uid = uuid.toString();</p>
<h2 id="13、Date和Calendar"><a href="#13、Date和Calendar" class="headerlink" title="13、Date和Calendar"></a>13、Date和Calendar</h2><p>处理日期，时间；<br>大部分的方法已过时，不推荐使用，但是你使用过时的方法也不会报错。<br>Date() 分配 Date 对象并初始化此对象，以表示分配它的时间（精确到毫秒）。<br>Date(long date)  分配 Date 对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即 1970 年 1 月 1 日 00:00:00 GMT）以来的指定毫秒数。</p>
<p>SimpleDateFormat</p>
<p>java.text.SimpleDateFormat<br>SimpleDateFormat 是一个与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化（日期 -&gt; 文本）、解析（文本 -&gt; 日期）和规范化。<br>SimpleDateFormat(String pattern)  用给定的模式和默认语言环境的日期格式符号构造 SimpleDateFormat。<br>public final String format(Date date)将一个 Date 格式化为日期/时间字符串。<br> public Date parse(String source) throws ParseException：把字符串source表示的时间按source的格式转成Date对象。</p>
<p>练习：String与Date的相互转化</p>
<p>按某种时间格式来输出指定的String类型时间<br>date2String<br>format</p>
<p>把某种时间格式的String时间转成Date类型时间<br>string2Date<br>parse</p>
<p>package reviewDemo;</p>
<p>import java.text.SimpleDateFormat;<br>import java.util.Date;</p>
<p>public class Demo28 {<br>    public static void main(String[] args) throws Exception {</p>
<pre><code>    Date d = new Date();
    System.out.println(d);//获取当前时间

    //格式化
    SimpleDateFormat  sd = new SimpleDateFormat(&quot;yyyy-M-d HH:mm:ss E&quot;);

    String s = sd.format(d);//这个方法继承于SimpleDateFormat的父类DateFormat类！
    System.out.println(s);

    //反格式化
    d = sd.parse(s);
    System.out.println(d);
}</code></pre><p>}</p>
<p>Calendar</p>
<p>推荐使用处理日期和时间的类Calendar;<br>是抽象类，不能实例化，通过<br>static Calendar getInstance() 获得一个Calendar对象。<br>int get(int field):返回指定日历字段值<br>静态常量：<br>YEAR 表示年的字段数字。<br>MONTH 表示月份字段数字,月份范围是[0,11]。<br>DATE 表示一个月中的某天。<br>DAY_OF_MONTH 表示一个月中的某天。<br>DAY_OF_WEEK 表示一个星期中的某天。<br>HOUR_OF_DAY / HOUR 表示第几小时<br>MINUTE  表示第几分钟<br>SECOND     表示第几秒</p>
<p>Date getTime() 返回一个表示此 Calendar 时间值的 Date 对象。<br>void set(int year, int month, int date, int hour, int minute, int second)   设置字段 YEAR、MONTH、DAY_OF_MONTH、HOUR、MINUTE 和 SECOND 的值。<br>abstract void add(int field, int amount) 根据日历的规则，为给定的日历字段添加或减去指定的时间量。<br>若 amount为负数，则减去一天，<br>若 amount为正数 ，则加上一天 </p>
<p>例子<br>package reviewDemo;</p>
<p>import java.util.Calendar;<br>import java.util.Date;</p>
<p>public class Demo29 {<br>    public static void main(String[] args) {<br>        Calendar c = Calendar.getInstance();<br>        System.out.println(c);</p>
<pre><code>    Date d = c.getTime();
    System.out.println(d);

    /**
     * void set(int year, int month, int date, int hour, int minute, int second)   
     * 设置字段 YEAR、MONTH、DAY_OF_MONTH、HOUR、MINUTE 和 SECOND 的值。
     */

    c.set(2015, 07, 15, 12, 24, 55);
    d = c.getTime();
    System.out.println(d);

    c.add(Calendar.DAY_OF_MONTH, 3);
    d = c.getTime();
    System.out.println(d);
}</code></pre><p>}</p>
<p>我的总结：注意常查看api！</p>
<p>Eg：“查询距今最近三天内的记录”，这里的‘三天内’是什么时间段？<br>将当前日期时间转换为 只获取当天的00:00:00<br>如: 2011-08-08 12:12:12 转化为 2011-08-08 00:00:00、</p>
<p>package reviewDemo;</p>
<p>import java.text.SimpleDateFormat;<br>import java.util.Calendar;<br>import java.util.Date;</p>
<p>public class Demo30 {<br>    public static void main(String[] args) {</p>
<pre><code>    Calendar c = Calendar.getInstance();
    Date d = c.getTime();
    System.out.println(d);

    SimpleDateFormat sd = new SimpleDateFormat(&quot;yyyy-M-d HH:mm:ss E&quot;);

    String s = sd.format(d);
    System.out.println(s);

    c.set(2015, 8, 23, 13, 24, 15);
    d = c.getTime();
    System.out.println(sd.format(d));
    c.add(Calendar.DAY_OF_MONTH, -3);
    d = c.getTime();
    System.out.println(sd.format(d));
}</code></pre><p>}</p>
<p>输出：<br>Thu Jul 04 08:56:51 CST 2013<br>2013-7-4 08:56:51 星期四<br>2015-9-23 13:24:15 星期三<br>2015-9-20 13:24:15 星期日</p>
<h2 id="14、System"><a href="#14、System" class="headerlink" title="14、System"></a>14、System</h2><p>System 类包含一些与系统相关的类字段和方法。它不能被实例化，类中所有属性和方法都是static,可直接被System调用。</p>
<p>常用方法：<br>static void exit(int status) 终止虚拟机的运行.对于发生了异常情况而想终止虚拟机的运行,传递一个非0数值,对于正常情况下退出系统传递0值;<br>该方法实际调用的是Runtime.getRuntime().exit(int status)；<br>static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 数组拷贝<br>static long currentTimeMillis() 返回以毫秒为单位的当前时间。<br>String getenv(String name)      获得指定的环境变量;<br>static void gc()  运行垃圾回收器。<br>实际上调用了 Runtime中的gc()方法;<br>Runtime.getRuntime().exec(“notepad “);<br>static Properties getProperties()  取得当前的系统属性。<br>static String getProperty(String key) 取得指定键指示的系统属性。<br>static String getProperty(String key, String def)  获取用指定键描述的系统属性,def表示默认信息。 </p>
<p>Eg：package reviewDemo627;</p>
<p>import java.util.Properties;</p>
<p>public class Demo32 {<br>    public static void main(String[] args) {<br>        Properties p = System.getProperties();<br>        System.out.println(p);</p>
<pre><code>    System.out.println(System.getenv());
}</code></pre><p>}</p>
<h1 id="六、线程技术"><a href="#六、线程技术" class="headerlink" title="六、线程技术"></a>六、线程技术</h1><p>第六篇</p>
<h2 id="1、进程和线程"><a href="#1、进程和线程" class="headerlink" title="1、进程和线程"></a>1、进程和线程</h2><p>进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程中可以有多个线程。比如在Windows系统中，一个运行的xx.exe就是一个进程。<br>Java程序的进程里有几个线程:主线程, 垃圾回收线程(后台线程)<br>线程是指进程中的一个执行任务(控制单元)，一个进程中可以运行多个线程,多个线程可共享数据。<br>多进程:操作系统中同时运行的多个程序;<br>多线程:在同一个进程中同时运行的多个任务;<br>一个进程至少有一个线程，为了提高效率，可以在一个进程中开启多个控制单元。<br>并发运行。如：多线程下载软件。<br>可以完成同时运行，但是通过程序运行的结果发现，虽然同时运行，但是每一次结果都不一致。<br>因为多线程存在一个特性：随机性。<br>造成的原因：CPU在瞬间不断切换去处理各个线程而导致的。<br>可以理解成多个线程在抢cpu资源。  </p>
<p>我的总结：<br>多线程下载:此时线程可以理解为下载的通道，一个线程就是一个文件的下载通道，多线程也就是同时开起好几个下载通道.当服务器提供下载服务时，使用下载者是共享带宽的，在优先级相同的情况下，总服务器会对总下载线程进行平均分配。不难理解，如果你线程多的话，那下载的越快。现流行的下载软件都支持多线程。</p>
<p>多线程是为了同步完成多项任务,不是为了提供运行效率,通过提高资源使用效率来提高系统的效率.<br>线程是在同一时间需要完成多项任务的时候实现的.</p>
<p>线程与进程的比较</p>
<p>线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少需要一个线程。</p>
<p>进程与线程的区别：<br>    1.进程有独立的进程空间，进程中的数据存放空间（堆空间和栈空间）是独立的。<br>    2.线程的堆空间是共享的，栈空间是独立的，线程消耗的资源也比进程小，相互之间可以影响的。</p>
<h2 id="2、创建线程方式"><a href="#2、创建线程方式" class="headerlink" title="2、创建线程方式"></a>2、创建线程方式</h2><p>1、继承Thread类<br>子类覆写父类中的run方法，将线程运行的代码存放在run中。<br>建立子类对象的同时线程也被创建。<br>通过调用start方法开启线程。</p>
<p>2、实现Runnable接口<br>子类覆盖接口中的run方法。<br>通过Thread类创建线程，并将实现了Runnable接口的子类对象作为参数传递给Thread类的构造函数。<br>Thread类对象调用start方法开启线程。<br>可使用匿名内部类来写</p>
<p>Eg：<br>package july7;<br>//线程的两种方法</p>
<p>class MyThread extends Thread{<br>    private String name;</p>
<pre><code>public MyThread(String name) {
    super();
    this.name = name;
}

public void run(){
    System.out.println(name+&quot;启动！&quot;);
}</code></pre><p>}</p>
<p>class YourThread implements Runnable{<br>    private String name;<br>    public YourThread(String name) {<br>        this.name = name;<br>    }</p>
<pre><code>@Override
public void run() {
    for (int i = 0; i &lt; 3; i++) {
        System.out.println(Thread.currentThread().getName()+&quot;第&quot;+i+&quot;次启动！&quot;);
    }
}</code></pre><p>}</p>
<p>public class Demo1 {<br>    public static void main(String[] args) {<br>        for (int i = 0; i &lt; 100; i++) {<br>            if(i == 50){<br>                new MyThread(“刘昭”).start();<br>                new Thread(new YourThread(“”),”章泽天”).start();<br>            }<br>        }<br>    }<br>}</p>
<p>我的总结：<br>Thread类中run()和start()方法的区别如下：<br>run()方法:在本线程内调用该Runnable对象的run()方法，可以重复多次调用；<br>start()方法:启动一个线程，调用该Runnable对象的run()方法，不能多次启动一个<br>线程；</p>
<h2 id="3、两种进程创建方式比较"><a href="#3、两种进程创建方式比较" class="headerlink" title="3、两种进程创建方式比较"></a>3、两种进程创建方式比较</h2><p>A extends Thread：<br>简单<br>不能再继承其他类了(Java单继承)<br>同份资源不共享<br>A implements Runnable:(推荐)<br>多个线程共享一个目标资源，适合多线程处理同一份资源。<br>该类还可以继承其他类，也可以实现其他接口。</p>
<p>我的总结：<br>实现方式，因为避免了单继承的局限性，所以创建线程建议使用第二种方式。</p>
<p>Eg：</p>
<p>package july7;<br>//线程卖票的例子</p>
<p>class SellTicket extends Thread{<br>    private String name;<br>    private int num = 50;<br>    public SellTicket(String name) {<br>        super();<br>        this.name = name;<br>    }</p>
<pre><code>public void run(){
    for (int i = 1; i &lt;= num; i++) {
        System.out.println(name+&quot;卖出了第&quot;+i+&quot;张票！&quot;);
    }
}</code></pre><p>}</p>
<p>class MySell implements Runnable{<br>    private int num = 50;</p>
<pre><code>@Override
public void run() {
    for (int i = 1; i &lt;= num; i++) {
        System.out.println(Thread.currentThread().getName()+&quot;卖出了第&quot;+i+&quot;张票！&quot;);
    }
}</code></pre><p>}</p>
<p>public class Demo2 {<br>    public static void main(String[] args) throws Exception {</p>
<pre><code>    new SellTicket(&quot;A&quot;).start();
    new SellTicket(&quot;B&quot;).start();
    new SellTicket(&quot;C&quot;).start();

    new Thread(new MySell(),&quot;D&quot;).start();
    new Thread(new MySell(),&quot;E&quot;).start();
    new Thread(new MySell(),&quot;F&quot;).start();

    for (int i = 10; i &gt; 0; i--) {
        System.out.println(i);
        Thread.sleep(1000);
    }
}</code></pre><p>}</p>
<p>我的总结：<br>为什么要覆盖run方法呢？<br>Thread类用于描述线程。该类就定义了一个功能，用于存储线程要运行的代码。该存储功能就是run方法.<br>也就是说Thread类中的run方法，用于存储线程要运行的代码。</p>
<h2 id="4、线程的生命周期"><a href="#4、线程的生命周期" class="headerlink" title="4、线程的生命周期"></a>4、线程的生命周期</h2><p>Thread类内部有个public的枚举Thread.State，里边将线程的状态分为：<br>     NEW——-新建状态，至今尚未启动的线程处于这种状态。<br>     RUNNABLE——-运行状态，正在 Java 虚拟机中执行的线程处于这种状态。<br>     BLOCKED——-阻塞状态，受阻塞并等待某个监视器锁的线程处于这种状态。<br>     WAITING——-冻结状态，无限期地等待另一个线程来执行某一特定操作的线程处于这种状态。<br>     TIMED_WAITING——-等待状态，等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态。<br>     TERMINATED——-已退出的线程处于这种状态。</p>
<p>我的总结：<br>如何停止线程？</p>
<p>只有一种，run方法结束。<br>开启多线程运行，运行代码通常是循环结构。<br>只要控制住循环，就可以让run方法结束，也就是线程结束。</p>
<h2 id="5、控制线程"><a href="#5、控制线程" class="headerlink" title="5、控制线程"></a>5、控制线程</h2><p>join方法：调用join方法的线程对象强制运行，该线程强制运行期间，其他线程无法运行，必须等到该线程结束后其他线程才可以运行。<br>有人也把这种方式成为联合线程</p>
<p>join方法的重载方法:<br>join(long millis):<br>join(long millis,int nanos):<br>通常很少使用第三个方法:<br>程序无须精确到一纳秒;<br>计算机硬件和操作系统也无法精确到一纳秒;</p>
<p>Eg：<br>package july7;</p>
<p>class MyThreadDemo implements Runnable{</p>
<pre><code>@Override
public void run() {
    for (int i = 0; i &lt; 50; i++) {
        System.out.println(Thread.currentThread().getName()+&quot;正在运行！&quot;+i);
        if(i == 25){
            try {
                new Thread(new MyThreadDemo(),&quot;刘昭&quot;).join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}</code></pre><p>}</p>
<p>public class DemoRe10 {<br>    public static void main(String[] args) {</p>
<pre><code>    new Thread(new MyThreadDemo(),&quot;刘昭&quot;).start();
    new Thread(new MyThreadDemo(),&quot;章泽天&quot;).start();
}</code></pre><p>}</p>
<p>Daemon</p>
<p>后台线程：处于后台运行，任务是为其他线程提供服务。也称为“守护线程”或“精灵线程”。JVM的垃圾回收就是典型的后台线程。<br>特点：若所有的前台线程都死亡，后台线程自动死亡。<br>设置后台线程：Thread对象setDaemon(true);<br>setDaemon(true)必须在start()调用前。否则出现IllegalThreadStateException异常；<br>前台线程创建的线程默认是前台线程;<br>判断是否是后台线程：使用Thread对象的isDaemon()方法；<br>并且当且仅当创建线程是后台线程时，新线程才是后台线程。 </p>
<p>sleep<br>线程休眠:<br>让执行的线程暂停一段时间，进入阻塞状态。<br>sleep(long milllis) throws InterruptedException：毫秒<br>sleep(long millis,int nanos)<br>        throws     InterruptedException:毫秒，纳秒<br>调用sleep()后，在指定时间段之内，该线程不会获得执行的机会。</p>
<p>控制线程之优先级</p>
<p>每个线程都有优先级，优先级的高低只和线程获得执行机会的次数多少有关。<br>并非线程优先级越高的就一定先执行，哪个线程的先运行取决于CPU的调度;<br>默认情况下main线程具有普通的优先级，而它创建的线程也具有普通优先级。<br>Thread对象的setPriority(int x)和getPriority()来设置和获得优先级。<br>MAX_PRIORITY    :    值是10<br>MIN_PRIORITY    :    值是1<br>NORM_PRIORITY    :    值是5(主方法默认优先级)</p>
<p>yield</p>
<p>线程礼让:<br>暂停当前正在执行的线程对象，并执行其他线程；<br>Thread的静态方法，可以是当前线程暂停，但是不会阻塞该线程，而是进入就绪状态。所以完全有可能：某个线程调用了yield()之后，线程调度器又把他调度出来重新执行。</p>
<p>我的总结：用到时查询api！</p>
<h2 id="6、多线程安全问题"><a href="#6、多线程安全问题" class="headerlink" title="6、多线程安全问题"></a>6、多线程安全问题</h2><p>导致安全问题的出现的原因：<br>多个线程访问出现延迟。<br>线程随机性。<br>注：线程安全问题在理想状态下，不容易出现，但一旦出现对软件的影响是非常大的。<br>我们可以通过Thread.sleep(long time)方法来简单模拟延迟情况。</p>
<p>我的总结：<br>当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导致共享数据的错误。</p>
<p>解决办法：<br>对多条操作共享数据的语句，只能让一个线程都执行完。在执行过程中，其他线程不可以参与执行。</p>
<p>Eg：在前面的卖票例子上，在每卖票的前面加上模拟延时的语句！<br>package july7;</p>
<p>class SellDemo implements Runnable{<br>    private int num = 50;<br>    @Override<br>    public void run() {<br>        for (int i = 0; i &lt; 200; i++) {</p>
<pre><code>            if(num &gt; 0){    
                try {
                //因为它不可以直接调用getName()方法，所以必须要获取当前线程。
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            System.out.println(Thread.currentThread().getName()+&quot;卖出第&quot;+num--+&quot;张票！&quot;);
        }
    }
}</code></pre><p>}</p>
<p>public class Demo3 {<br>    public static void main(String[] args) {<br>        SellDemo s = new SellDemo();<br>        new Thread(s,”A”).start();<br>        new Thread(s,”B”).start();<br>        new Thread(s,”C”).start();<br>    }<br>}</p>
<p>输出：这样的话，会出现买了第0，甚至-1张票的情况！</p>
<h2 id="7、多线程安全问题的解决方法"><a href="#7、多线程安全问题的解决方法" class="headerlink" title="7、多线程安全问题的解决方法"></a>7、多线程安全问题的解决方法</h2><p>三种方法：<br>同步代码块：<br>synchronized(obj)<br>{<br>    //obj表示同步监视器,是同一个同步对象<br>    /**…..<br>        TODO SOMETHING<br>    */<br>}</p>
<p>同步方法<br>格式：<br>在方法上加上synchronized修饰符即可。（一般不直接在run方法上加！）</p>
<p>synchronized 返回值类型 方法名(参数列表)<br>{<br>    /**…..<br>        TODO SOMETHING<br>    */<br>}<br>同步方法的同步监听器其实的是 this</p>
<p>静态方法的同步</p>
<p>同步方法<br>同步代码块<br>static不能和 this连用</p>
<p>静态方法的默认同步锁是当前方法所在类的.class对象</p>
<p>同步锁<br>jkd1.5后的另一种同步机制：<br>通过显示定义同步锁对象来实现同步，这种机制，同步锁应该使用Lock对象充当。<br>在实现线程安全控制中，通常使用ReentrantLock(可重入锁)。使用该对象可以显示地加锁和解锁。<br>具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。</p>
<p>public class X {<br>    private final ReentrantLock lock = new ReentrantLock();<br>    //定义需要保证线程安全的方法<br>    public void  m(){<br>        //加锁<br>        lock.lock();<br>        try{<br>            //… method body<br>        }finally{<br>            //在finally释放锁<br>            lock.unlock();<br>        }<br>    }<br>}</p>
<p>修改后的例子：<br>//同步代码块<br>package july7;</p>
<p>class SellDemo implements Runnable{<br>    private int num = 50;<br>    @Override<br>    public void run() {<br>        for (int i = 0; i &lt; 200; i++) {<br>            synchronized (this) {<br>                if(num &gt; 0){<br>                    try {<br>                    //因为它不可以直接调用getName()方法，所以必须要获取当前线程。<br>                        Thread.sleep(10);<br>                    } catch (InterruptedException e) {<br>                        e.printStackTrace();<br>                    }<br>                System.out.println(Thread.currentThread().getName()+”卖出第”+num–+”张票！”);<br>                }<br>            }<br>        }<br>    }<br>}</p>
<p>public class Demo3 {<br>    public static void main(String[] args) {<br>        SellDemo s = new SellDemo();<br>        new Thread(s,”A”).start();<br>        new Thread(s,”B”).start();<br>        new Thread(s,”C”).start();<br>    }<br>}</p>
<p>//同步方法<br>package july7;</p>
<p>//同步方法</p>
<p>class FinalDemo1 implements Runnable {<br>    private int num = 50;</p>
<pre><code>@Override
public void run() {
    for (int i = 0; i &lt; 100; i++) {
        gen();
    }
}

public synchronized void gen() {
    for (int i = 0; i &lt; 100; i++) {
        if (num &gt; 0) {
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + &quot;卖出了第&quot;
                    + num-- + &quot;张票！&quot;);
        }
    }
}</code></pre><p>}</p>
<p>public class Demo6 {<br>    public static void main(String[] args) {<br>        FinalDemo1 f = new FinalDemo1();</p>
<pre><code>    new Thread(f, &quot;A&quot;).start();
    new Thread(f, &quot;B&quot;).start();
    new Thread(f, &quot;C&quot;).start();

}</code></pre><p>}</p>
<p>//线程同步锁<br>package july7;</p>
<p>import java.util.concurrent.locks.ReentrantLock;</p>
<p>//同步锁</p>
<p>class FinalDemo2 implements Runnable {<br>    private int num = 50;<br>    private final ReentrantLock lock = new ReentrantLock();</p>
<pre><code>@Override
public void run() {
    for (int i = 0; i &lt; 100; i++) {
        gen();
    }
}

public void gen() {
    lock.lock();
    try{
        //for (int i = 0; i &lt; 100; i++) {
            if (num &gt; 0) {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + &quot;卖出了第&quot;
                        + num-- + &quot;张票！&quot;);
            }
        //}
    }finally{
        lock.unlock();
    }
}</code></pre><p>}</p>
<p>public class Demo7 {<br>    public static void main(String[] args) {<br>        FinalDemo2 f = new FinalDemo2();</p>
<pre><code>    new Thread(f, &quot;A&quot;).start();
    new Thread(f, &quot;B&quot;).start();
    new Thread(f, &quot;C&quot;).start();

}</code></pre><p>}</p>
<h2 id="8、线程通信"><a href="#8、线程通信" class="headerlink" title="8、线程通信"></a>8、线程通信</h2><p>有一个数据存储空间,划分为两部分,一部分用于存储人的姓名,另一部分用于存储人的性别;<br>我们的应用包含两个线程,一个线程不停向数据存储空间添加数据(生产者),另一个线程从数据空间取出数据(消费者);<br>因为线程的不确定性，存在于以下两种情况：<br>若生产者线程刚向存储空间添加了人的姓名还没添加人的性别，CPU就切换到了消费者线程，消费者线程把姓名和上一个人的性别联系到一起；<br>生产者放了若干数据，消费者才开始取数据，或者是消费者取完一个数据，还没等到生产者放入新的数据，又重复的取出已取过的数据；</p>
<p>生产者和消费者</p>
<p>wait():让当前线程放弃监视器进入等待，直到其他线程调用同一个监视器并调用notify()或notifyAll()为止。<br>notify():唤醒在同一对象监听器中调用wait方法的第一个线程。<br>notifyAll():唤醒在同一对象监听器中调用wait方法的所有线程。</p>
<p>这三个方法只能让同步监听器调用:<br>在同步方法中:    谁调用<br>在同步代码块中:    谁调用</p>
<p>wait()、notify()、notifyAll()，这三个方法属于Object 不属于 Thread，这三个方法必须由同步监视对象来调用，两种情况：<br>        1.synchronized修饰的方法，因为该类的默认实例(this)就是同步监视器，所以可以在同步方法中调用这三个方法;<br>        2.synchronized修饰的同步代码块，同步监视器是括号里的对象，所以必须使用该对象调用这三个方法;<br>可要是我们使用的是Lock对象来保证同步的,系统中不存在隐式的同步监视器对象,那么就不能使用者三个方法了,那该咋办呢?<br>        此时,Lock代替了同步方法或同步代码块,Condition代替了同步监视器的功能;<br>            Condition对象通过Lock对象的newCondition()方法创建;<br>            里面方法包括:<br>                await():  等价于同步监听器的wait()方法;<br>                signal(): 等价于同步监听器的notify()方法;<br>                signalAll(): 等价于同步监听器的notifyAll()方法;</p>
<p>例子：设置属性<br>容易出现的问题是：<br>名字和性别不对应！</p>
<p>线程通信，很好！<br>package july7;</p>
<p>class Person{<br>    private String name;<br>    private String sex;<br>    private Boolean isimpty = Boolean.TRUE;//内存区为空！<br>    public String getName() {<br>        return name;<br>    }<br>    public void setName(String name) {<br>        this.name = name;<br>    }<br>    public String getSex() {<br>        return sex;<br>    }<br>    public void setSex(String sex) {<br>        this.sex = sex;<br>    }</p>
<pre><code>public void set(String name,String sex){
    synchronized (this) {
        while(!isimpty.equals(Boolean.TRUE)){//不为空的话等待消费者消费！
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        this.name = name;//为空的话生产者创造！
        this.sex = sex;
        isimpty = Boolean.FALSE;//创造结束后修改属性！
        this.notifyAll();
    }
}

public void get(){
    synchronized (this) {
        while(!isimpty.equals(Boolean.FALSE)){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(&quot;姓名&quot;+getName()+ &quot;,  &quot;+&quot;性别&quot;+getSex());
        isimpty = Boolean.TRUE;
        this.notifyAll();
    }
}</code></pre><p>}</p>
<p>class Producer implements Runnable{<br>    private Person p;</p>
<pre><code>public Producer(Person p) {
    super();
    this.p = p;
}

@Override
public void run() {
    for (int i = 0; i &lt; 100; i++) {
        if( i % 2 == 0){
            p.set(&quot;刘昭&quot;, &quot;男&quot;);
        }else{
            p.set(&quot;章泽天&quot;, &quot;女&quot;);
        }
    }
}</code></pre><p>}</p>
<p>class Consumer implements Runnable{<br>    private Person p;</p>
<pre><code>public Consumer(Person p) {
    super();
    this.p = p;
}

@Override
public void run() {
    for (int i = 0; i &lt; 100; i++) {
        p.get();
    }
}</code></pre><p>}</p>
<p>public class Demo9 {<br>    public static void main(String[] args) {<br>        Person p = new Person();</p>
<pre><code>    new Thread(new Producer(p)).start();
    new Thread(new Consumer(p)).start();
}</code></pre><p>}</p>
<h1 id="七、集合框架（1）"><a href="#七、集合框架（1）" class="headerlink" title="七、集合框架（1）"></a>七、集合框架（1）</h1><p>第七篇    集合框架（1）</p>
<h2 id="1、集合类-amp-容器"><a href="#1、集合类-amp-容器" class="headerlink" title="1、集合类 &amp;  容器"></a>1、集合类 &amp;  容器</h2><p>为什么出现集合类？<br>面向对象语言对事物的体现都是以对象的形式，所以为了方便对多个对象的操作，就要对对象进行存储，集合就是存储对象最常用的一种方式。<br>数组和集合类同是容器，有何不同？<br>数组虽然也可以存储对象，但长度是固定的；集合长度是可变的。数组中可以存储任意数据类型，集合只能存储对象。<br>集合类的特点<br>集合只用于存储对象，集合长度是可变的，集合可以存储不同类型的对象。</p>
<p>我的总结：集合类比数组强大，类似于包装类与基本数据类型！</p>
<p>集合框架的构成及分类</p>
<p>两大接口<br>Java集合类主要由两个接口派生出来：<br>Collection<br>Set        ：不能存放重复对象<br>List        ：可存放重复对象，有序<br>Queue    ：队列<br>SortedSet    ：可对集合数据排序<br>Map<br>SortedMap    ：可对集合数据排序</p>
<h2 id="2、Collection接口"><a href="#2、Collection接口" class="headerlink" title="2、Collection接口"></a>2、Collection接口</h2><p>方法：<br>boolean add(Object o):该方法用于向集合里面添加一个元素，若集合对象被添加操作改变了，返回true.<br>boolean addAll(Collection c):把集合c里面的所有元素添加到指定集合里面去，如果集合对象被添加操作改变了返回true.<br>void clear():清除集合里面的所有元素，将集合长度变为0。<br>boolean contains(Object o):返回集合里是否包含指定的元素。<br>boolean containsAll(Collection c):返回集合里是否包含集合c内所有的元素。<br>boolean isEmpty()：返回集合是否为空（长度是否为0）。<br>Iterator iterator():返回一个Iterator对象，用于遍历集合里的元素。<br>boolean remove(Object o)：删除集合中指定元素o。<br>boolean removeAll(Collection c):从集合中删除集合c里面的元素。若删除一个或以上返回true。<br>boolean retainAll(Collection c):从集合中删除集合c里不包含的元素。<br>int size()：得到集合元素的个数。<br>Object[] toArray():把集合转成一个数组，所有集合元素编程数组元素。<br>Eg：<br>public class Demo10 {<br>    public static void main(String[] args) {<br>        Collection<String> c = new ArrayList<String>();</String></String></p>
<pre><code>c.add(&quot;A&quot;);
c.add(&quot;A&quot;);
c.add(&quot;A&quot;);
c.add(&quot;A&quot;);
//c.add(new Date());上面写了泛型，这个语句就是错误的了，因为泛型规定了加进来的类型！
System.out.println(c);</code></pre><p>}<br>}</p>
<h2 id="3、Iterator接口"><a href="#3、Iterator接口" class="headerlink" title="3、Iterator接口"></a>3、Iterator接口</h2><p>Iterator主要遍历Collection集合中的元素，也有称为迭代器或迭代精灵。<br>boolean hasNext()：若被迭代的集合元素还没有被遍历，返回true.<br>Object  next():返回集合的下一个元素.<br>void remove():删除集合上一次next()方法返回的元素。(若集合中有多个相同的元素，都可以删掉)<br>iterator对于集合才能用，for不同，只要是循环都可用。</p>
<p>迭代是取出集合中元素的一种方式。<br>因为Collection中有iterator方法，所以每一个子类集合对象都具备迭代器。<br>迭代器在Collcection接口中是通用的，它替代了Vector类中的Enumeration(枚举)。迭代器的next方法是自动向下取元素，要避免出现NoSuchElementException。<br>迭代器的next方法返回值类型是Object，所以要记得类型转换。（学到泛型就可以消除强转！）</p>
<p>Eg：Iterator iter = l.iterator();<br>while(iter.hasNext()){<br>    System.out.println(iter.next());<br>}</p>
<h2 id="4、集合遍历输出方式"><a href="#4、集合遍历输出方式" class="headerlink" title="4、集合遍历输出方式"></a>4、集合遍历输出方式</h2><p>Iterator：迭代输出<br>一旦操作集合的遍历输出，首选Iterator接口;<br>ListIterator:Iterator子接口，专门输出List中的元素;<br>Enumeration:古老的输出方式，迭代Vector元素，被Iterator取代;<br>foreach:可输出数组和Iterable对象;</p>
<p>我的总结：<br>集合遍历输出方式：</p>
<ol>
<li>Iterable接口（迭代遍历）  注：优先选择Iterator接口，遍历Collection里所有元素，也称为迭代器和迭代精灵；迭代是取出集合中元素的一种推荐方式。</li>
<li>Foreach循环  注：可以直接用，使用场合：数组和Iterable对象！</li>
<li>For循环      注：在（）内实例化Iterable对象，进行遍历！</li>
<li>先用toArray方法输出成为数组，再用Foreach循环！<br>第一个和第三个很类似，第二个和第四个很类似！</li>
</ol>
<p>很好<br>Eg：<br>package july7;<br>//遍历输出的四种方式</p>
<p>import java.util.ArrayList;<br>import java.util.Iterator;<br>import java.util.List;</p>
<p>public class Demo11 {<br>    public static void main(String[] args) {</p>
<pre><code>    List&lt;String&gt; l = new ArrayList();

    l.add(&quot;1&quot;);
    l.add(&quot;2&quot;);
    l.add(&quot;3&quot;);
    l.add(&quot;4&quot;);

    System.out.println(l);
    /**
     * 遍历输出：四种方式
     */

    // 1、推荐使用的Iterator对象，迭代输出！
    Iterator it = l.iterator();
    while (it.hasNext()) {
        System.out.println(&quot;迭代输出：&quot; + it.next());
    }

    // 2、对集合进行fore循环！
    for (String str : l) {
        System.out.println(&quot;fore集合迭代输出：&quot; + str);
    }

    // 3、for循环迭代，在for方法体内部实例化Iterator对象！
    int i = 0;// for方法体内定义项不能出现多种不同类型
    for (Iterator iter = l.iterator(); i &lt; l.size(); i++) {
        System.out.println(&quot;for循环迭代实例化输出：&quot; + iter.next());
    }

    // 4、先将集合转换为数组，再利用数组的遍历输出；
    Object[] o = l.toArray();
    for (Object object : o) {
        System.out.println(&quot;转换数组迭代输出：&quot; + object);
    }
}</code></pre><p>}</p>
<h2 id="5、Set接口（元素不可以重复）"><a href="#5、Set接口（元素不可以重复）" class="headerlink" title="5、Set接口（元素不可以重复）"></a>5、Set接口（元素不可以重复）</h2><p>Set是Collection子接口；<br>Set和Collection基本上一样，一点除外：<br>Set无法记住添加的顺序，不允许包含重复的元素。<br>当试图添加两个相同元素进Set集合，添加操作失败，add()方法返回false。<br>Set判断两个对象是否相等用equals,而不是使用==。<br>也就是说两个对象equals比较返回true，Set集合是不会接受这个两个对象的。<br>常用子类：<br>HashSet:散列存放<br>TreeSet:有序存放</p>
<p>hashCode方法对于HashSet的作用</p>
<p>HashSet类是Set接口最常用的实现类,采用hash算法存储数据,具有良好的存储和查找功能。<br>散列存储:不记录添加顺序;排列顺序时，顺序有可能发生变化;<br>线程不安全的，多个线程访问一个HashSet要使用同步代码;<br>HashSet集合元素值允许是null,但是最多只能有一个;//因为Set集合就不可以装重复的对象！<br>hash(翻译为哈希,或散列)算法的功能:<br>保证通过一个对象快速找到另一个对象;<br>其算法价值体现在速度,可以保证查询快速执行;<br>当从HashSet中访问元素时,HashSet先计算该元素的hashCode(也就是该对象的hashCode方法返回值),然后直接到该HashCode对应的位置取出该元素;<br>在这里对象的hashCode就好比是数组里的索引,但是不是索引;</p>
<p>HashSet元素添加</p>
<p>当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值,判断已经存储在集合中的对象的hashCode值是否与添加的对象的hashCode值一致:若不一致:直接添加进去;若一致,再进行equals方法比较,equals方法如果返回true,表明对象已经添加进去了,就不会再添加新的对象了,否则添加进去;<br>如果我们重写了equals方法,也要重写hashCode方法,反之亦然;。<br>HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode方法返回值也相等。<br>如果需要某个类的对象保存到HashSet集合中，覆写该类的equals()和hashCode()方法，应该尽量保证两个对象通过equals比较返回true时,他们的hashCode返回也相等。</p>
<p>我的总结：<br>很重要的一点：理解！往HashSet集合里面存入数据，要先后调用两个方法：hashCode方法和equals方法！！！<br>备注：使用eclipse添加这两个方法。</p>
<p>Eg：<br>package july7;<br>//hashset方法和equals方法判断输入的对象是否重复！</p>
<p>import java.util.HashSet;<br>import java.util.Set;</p>
<p>class PersonDemo{<br>    private String name;</p>
<pre><code>public PersonDemo(String name) {
    super();
    this.name = name;
}

@Override
public String toString() {
    return &quot;name= &quot; + name ;
}
//没有覆写hashcode和equals方法前，显示三次（一样的）。覆写后，只剩下一个了！说明覆写后方法起作用了，重复的输入不进去！
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    return result;
}

@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    PersonDemo other = (PersonDemo) obj;
    if (name == null) {
        if (other.name != null)
            return false;
    } else if (!name.equals(other.name))
        return false;
    return true;
}</code></pre><p>}</p>
<p>public class Demo12 {<br>    public static void main(String[] args) {</p>
<pre><code>    Set s = new HashSet();

    s.add(new PersonDemo(&quot;章泽天&quot;));
    s.add(new PersonDemo(&quot;章泽天&quot;));
    s.add(new PersonDemo(&quot;章泽天&quot;));
    System.out.println(s);
}</code></pre><p>}    </p>
<h2 id="6、TreeSet"><a href="#6、TreeSet" class="headerlink" title="6、TreeSet"></a>6、TreeSet</h2><p>TreeSet是SortedSet接口唯一的实现，与HashSet相比额外的方法有：<br>Comparator comparator():返回当前Set使用的Comparator,若返回null,表示以自然顺序排序。<br>Object first() 返回此 set 中当前第一个(最低)元素。<br>Object last() 返回此 set 中当前最后一个(最高)元素。<br>SortedSet subSet(Object  fromElement, E toElement) 返回此 set 的部子集，其元素从 fromElement（包括）到 toElement（不包括）。<br>SortedSet headSet(Object  toElement)返回此 set 的部分子集，其元素严格小于 toElement。<br>SortedSet tailSet(Object  fromElement) 返回此 set 的部分子集，其元素大于等于 fromElement。 </p>
<p>TreeSet的排序之自然排序</p>
<p>TreeSet会调用元素的compareTo(Object o)方法来比较元素之间的大小关系,然后将集合里的元素按升序排列.此时需要排序元素的类必须实现Compareble接口,并覆写其int compareTo(Object o)方法;<br>该方法用于比较对象,若:obj1,compareTo(obj2),返回0,表示两个对象相等,若返回一个正整数,表示obj1大于obj2,若返回一个负整数,表示obj1小于obj2;<br>对于TreeSet集合而言,判断两个对象相等的标准是:<br>compareTo()方法比较返回 0;</p>
<p>package july7;<br>//TreeSet可以自动进行排序！最简单的情况</p>
<p>import java.util.Set;<br>import java.util.TreeSet;</p>
<p>public class Demo13 {<br>    public static void main(String[] args) {</p>
<pre><code>    Set&lt;Integer&gt; s = new TreeSet&lt;Integer&gt;();
    s.add(1);
    s.add(192);
    s.add(123);

    s.add(56);
    s.add(13);
    s.add(96);
    System.out.println(s);//[1, 13, 56, 96, 123, 192]
}</code></pre><p>}</p>
<p>稍复杂点的</p>
<p>package july7;<br>//TreeSet的自然排序，升序</p>
<p>import java.util.Set;<br>import java.util.TreeSet;</p>
<p>class Student implements Comparable{//必须实现接口<br>    private Integer age;</p>
<pre><code>public Student(Integer age) {
    super();
    this.age = age;
}

@Override
public int compareTo(Object o) {//比较的规则，运用泛型可以消除强转！
    if(o instanceof Student){
        Student s = (Student)o;
        return this.age.compareTo(s.age);
    }
    return 0;
}

@Override
public String toString() {
    return age+&quot;&quot; ;
}</code></pre><p>}</p>
<p>public class Demo14 {<br>    public static void main(String[] args) {</p>
<pre><code>    Set&lt;Student&gt; s = new TreeSet();
    s.add(new Student(140));
    s.add(new Student(15));
    s.add(new Student(11));
    s.add(new Student(63));
    s.add(new Student(96));
    System.out.println(s);//[11, 15, 63, 96, 140]
}</code></pre><p>}</p>
<p>TreeSet的排序之定制排序</p>
<p>TreeSet的自然排序是根据元素的大小进行升序排序的,若想自己定制排序,比如降序排序,就可以使用Comparator接口了:<br>该接口包含int compare(Object o1,Object o2)方法,用于比较两个对象的大小,比较结果和compareTo方法一致;<br>要实现定制排序,需要在创建TreeSet集合对象时,提供一个一个Comparator对象,该对象里负责集合元素的排序逻辑;<br>TreeSet(Comparator comparator) </p>
<p>Eg：<br>package july7;<br>//定制排序的话，必须在创建TreeSet集合对象的时候提供一个Comparator方法</p>
<p>import java.util.Comparator;<br>import java.util.Set;<br>import java.util.TreeSet;</p>
<p>class Student1{<br>    private Integer age;</p>
<pre><code>public Student1(Integer age) {
    super();
    this.age = age;
}

public Integer getAge() {
    return age;
}

public void setAge(Integer age) {
    this.age = age;
}

@Override
public String toString() {
    return age + &quot;&quot;;
}</code></pre><p>}</p>
<p>class MyComparator implements Comparator{</p>
<pre><code>@Override
public int compare(Object o1, Object o2) {
    if(o1 instanceof Student1 &amp; o2 instanceof Student1){
        Student1 s1 = (Student1)o1;
        Student1 s2 = (Student1)o2;
        if(s1.getAge() &gt; s2.getAge()){
            return -1;
        }else if(s1.getAge() &lt; s2.getAge()){
            return 1;
        }
    }
    return 0;
}</code></pre><p>}</p>
<p>public class Demo15 {<br>    public static void main(String[] args) {<br>        Set<Student1> s = new TreeSet(new MyComparator());<br>        /**<br>         * 要实现定制排序,需要在创建TreeSet集合对象时,提供一个一个Comparator对象,<br>         * 该对象里负责集合元素的排序逻辑;<br>         */<br>        s.add(new Student1(140));<br>        s.add(new Student1(15));<br>        s.add(new Student1(11));<br>        s.add(new Student1(63));<br>        s.add(new Student1(96));</Student1></p>
<pre><code>    System.out.println(s);
}</code></pre><p>}</p>
<h2 id="7、List接口"><a href="#7、List接口" class="headerlink" title="7、List接口"></a>7、List接口</h2><p>Collection子接口；<br>List是有序的集合，集合中每个元素都有对应的顺序序列。List集合可使用重复元素，可以通过索引来访问指定位置的集合元素（顺序索引从0开始）,List集合默认按元素的添加顺序设置元素的索引,比如第一个元素的索引就是0,好似数组。<br>List作为Collection子接口当然拥有其所有方法，同时也有自己的方法：</p>
<p>void add(int index,Object e):将元素e添加到List集合中的index处；<br>boolean addAll(int index,Collection c):将集合c所包含的所有元素都插入在List集合的index处；<br>Object get(int index):返回集合index索引处的元素；<br>int indexOf(Object o):返回对象o在List集合中第一次出现位置的索引；<br>int lastIndexOf(object o):返回对象o在List集合中最后一次出现的位置索引；<br>Object remove(int index)：删除并返回index索引处的元素；<br>Object set(int index,Object e):把集合index处的元素替换为e对象，返回以前在指定位置的元素；<br>List subList(int fromIndex,int toIndex):返回从所有fromIndex(包括)到toIndex(不包括)处所有集合元素的子集合。</p>
<p>ListIterator</p>
<p>Iterator的子接口，专门用于操作List集合的输出；<br>List自己还有一个listIterator()方法，该方法返回ListIterator对象，ListIterator继承了Iterator接口，提供了专门操作List的方法。在Iterator上额外增加的方法：<br>支持双向输出：<br>boolean hasPrevious():返回该迭代器关联集合是否还有上一个元素；<br>Object previous():返回该迭代器的上一个元素；</p>
<p>我的总结：这是相对更加特殊的一个接口，只用于List集合，可以完成逆序输出！</p>
<p>Eg：<br>package july7;</p>
<p>import java.util.ArrayList;<br>import java.util.List;<br>import java.util.ListIterator;</p>
<p>public class Demo16 {<br>    public static void main(String[] args) {<br>        List<Integer> l = new ArrayList<Integer>();<br>        l.add(12);<br>        l.add(24);<br>        l.add(36);<br>        l.add(23);<br>        l.add(37);</Integer></Integer></p>
<pre><code>    System.out.println(l);

    ListIterator&lt;Integer&gt; it = l.listIterator();
    while(it.hasNext()){
        System.out.println(&quot;正序：&quot;+it.next());
    }
    System.out.println(&quot;==================================&quot;);
    //使用向前迭代前必须将游标（指针）移动到后边！
    while(it.hasPrevious()){
        System.out.println(&quot;逆序：&quot;+it.previous());
    }
}</code></pre><p>}</p>
<p>输出：<br>[12, 24, 36, 23, 37]<br>正序：12<br>正序：24<br>正序：36<br>正序：23<br>正序：37<br>==================================<br>逆序：37<br>逆序：23<br>逆序：36<br>逆序：24<br>逆序：12</p>
<h2 id="8、List接口中常用类"><a href="#8、List接口中常用类" class="headerlink" title="8、List接口中常用类"></a>8、List接口中常用类</h2><p>Vector：线程安全，但速度慢，已被ArrayList替代。<br>ArrayList：线程不安全，查询速度快。<br>LinkedList：链表结构，增删速度快。取出List集合中元素的方式：<br>get(int  index)：通过脚标获取元素。<br>iterator()：通过迭代方法获取迭代器对象。<br>ArrayList和Vector类都是基于数组实现的List类,Vector比较古老,被ArrayList取代了;<br>ArrayList是线程不安全的,而Vector是线程安全的,但是即使这样,也不推荐使用Vector,因为Collections有方法可以得到线程安全的ArrayList对象;<br>Collections类: static  List synchronizedList(List list) 返回指定列表支持的同步（线程安全的）列表。 </p>
<p>Queue接口</p>
<p>继承Collection接口<br>模拟队列：先进先出(FIFO);<br>void add(Object e):将e插入到队列尾部；<br>Object element():获取队列头部的元素；<br>boolean offer(Object e):将e插入到队列的尾部，当使用有容量限制的队列时，此方法比add(Object e)方法更好。<br>Object peek():获取队列头部的元素。如果此双端队列为空，则返回 null。<br>Object poll():获取并删除队列头部的元素。如果此双端队列为空，则返回 null。<br>Object remove():获取并删除队列头部的元素。</p>
<p>Eg：练习：List的使用</p>
<p>设计Department  和 Employee 对象类(按照开发的样式没有写在一个文件里面)<br>//一个员工只可以有一个部门，所以按照普通的写法<br>//一个部门可以有许多员工，所以按照集合的写法；</p>
<p>//员工<br>package re538.Department;</p>
<p>public class Emp {<br>    private Dept dept;//一个员工只可以有一个部门，所以按照普通的写法<br>    private String name;<br>    public Dept getDept() {<br>        return dept;<br>    }<br>    public void setDept(Dept dept) {<br>        this.dept = dept;<br>    }<br>    public Emp(String name) {<br>        super();<br>        this.name = name;<br>    }<br>    public String toString(){//覆写toString方法<br>        return this.name+””;<br>    }<br>}</p>
<p>//部门<br>package re538.Department;</p>
<p>import java.util.List;<br>public class Dept {<br>    private String name;<br>    private List emp;//一个部门可以有许多员工，所以按照集合的写法；部门里的属性，员工！<br>    public Dept(String name) {<br>        super();<br>        this.name = name;<br>    }<br>    public String getName() {<br>        return name;<br>    }<br>    public void setName(String name) {<br>        this.name = name;<br>    }<br>    public List getEmp() {<br>        return emp;<br>    }<br>    public void setEmp(List emp) {<br>        this.emp = emp;<br>    }<br>    private Dept parent;//一个部门只有一个直接主管部门，所以普通写法<br>    private List children;//但是一个部门可以管理很多部门，充当很多部门的直接主管部门，所以使用集合<br>    public Dept getParent() {<br>        return parent;<br>    }<br>    public void setParent(Dept parent) {<br>        this.parent = parent;<br>    }<br>    public List getChildren() {<br>        return children;<br>    }<br>    public void setChildren(List children) {<br>        this.children = children;<br>    }<br>    public String toString(){<br>        return this.name.toString();<br>    }<br>}</p>
<p>//测试类，主方法！</p>
<p>package re538.Department;</p>
<p>import java.util.ArrayList;<br>import java.util.Iterator;<br>import java.util.List;</p>
<p>public class TestDemo {</p>
<pre><code>public static void main(String[] args) {
    Emp e1 = new Emp(&quot;刘亦菲&quot;);
    Emp e2 = new Emp(&quot;章泽天&quot;);
    Emp e3 = new Emp(&quot;张月娟&quot;);
    Emp e4 = new Emp(&quot;王二五&quot;);
    Emp e5 = new Emp(&quot;刘昭&quot;);
    List list = new ArrayList();//把员工丢尽集合去
    list.add(e1);
    list.add(e2);
    list.add(e3);
    list.add(e4);
    list.add(e5);
    for (Object object : list) {//把员工给遍历出来，使用的是直接的foreach（四种方法之一）
        System.out.println(&quot;-----&gt;&quot;+object);
    }
    System.out.println(&quot;-------------------&quot;);
    Dept d = new Dept(&quot;部门&quot;);//定义出一个部门来接收员工
    d.setEmp(list);//把员工这个集合丢到部门去。
    Dept d1 = new Dept(&quot;itcast&quot;);
    Dept cditcast = new Dept(&quot;成都传智播客&quot;);
    Dept gzitcast = new Dept(&quot;广州传智播客&quot;);
    Dept d4 = new Dept(&quot;CSDN&quot;);
    System.out.println(d4);
    List children = new ArrayList();
    children.add(cditcast);
    children.add(gzitcast);
    d1.setChildren(children);//定义直接被主管部门（集合）
    d1.setParent(d4);//定义直接主管部门
    Iterator it = children.iterator();//运用到了迭代遍历，四种之一！
    while(it.hasNext()){
        System.out.println(it.next());
    }
}</code></pre><p>}</p>
<h2 id="9、Map接口"><a href="#9、Map接口" class="headerlink" title="9、Map接口"></a>9、Map接口</h2><p>映射关系,也有人称为字典,Map集合里存在两组值，一组是key,一组是value。Map里的key不允许重复。通过key总能找到唯一的value与之对应。<br>Map里的key集存储方式和对应的Set集合中的元素存储方式一致;<br>学生都有一个学号，我们能点学号就能找到某个学生，好比这个学号就是key，学生就是value。<br>Map.Entry是Map接口的内部接口，专门用来保存key-value内容：</p>
<p>Map常用方法</p>
<p>void clear():删除该Map对象中所有的key-value对。也就是清理该集合；<br>boolean containsKey(Object key):查询Map中是否包含指定的key；<br>boolean containsValue(Object  value):查询Map中是否包含至少一个value;<br>Set entrySet():返回Map所包含的key-value对所组成的Set集合，每个集合元素都是Map.Entry对象(Entry是Map内部类)；<br>Object get(Object key):返回指定key所对应的value,若此Map中不包含该key,返回null;<br>boolean isEmpty():判断Map集合是否为空；<br>Set keySet():返回该Map中所有key所组成的Set集合；<br>Object put(Object key,Object value):添加一个key-value对，若Map中已有与key相等的key-value对，则新的key-value对覆盖原来的key-value对；<br>void putAll(Map m):将m中的key-value赋值到调用该方法的Map对象中；<br>Object remove(Object key):删除指定key所对应的key-value对，返回本删除key所关联的value,若key不存在，返回null;<br>int size():返回该Map里面key-value对的个数；<br>Collection values():返回Map里所有value组成的Collection。</p>
<p>Eg：package july7;</p>
<p>import java.util.Collection;<br>import java.util.HashMap;<br>import java.util.Map;<br>import java.util.Set;</p>
<p>public class Demo17 {<br>    public static void main(String[] args) {</p>
<pre><code>    Map m = new HashMap();

    m.put(1, &quot;jack&quot;);
    m.put(2, &quot;rose&quot;);
    m.put(3, &quot;lucy&quot;);

    System.out.println(m);//{1=jack, 2=rose, 3=lucy}

    Set s = m.entrySet();
    System.out.println(s);//[1=jack, 2=rose, 3=lucy]

    s = m.keySet();
    System.out.println(s);//[1, 2, 3]

    for (Object key : s) {
        System.out.println(key);//Key
        System.out.println(m.get(key));//Value
    }

    Collection c = m.values();
    System.out.println(c);
}</code></pre><p>}</p>
<p>Map.Entry</p>
<p>Entry是Map接口里面的一个内部接口.<br>该接口用于封装key- value,有3个方法:<br>Object getKey();返回Entry里包含的key值<br>Object getValue();返回Entry里包含的value值<br>Object setValue(Object value):设置Entry里包含的value值,并返回新设置的value值;</p>
<p>Map集合的输出</p>
<p>按照最正统的做法，所有的Map集合的内容都要依靠Iterator输出，以上虽然是完成了输出，但是完成的不标准，Map集合本身并不能直接为Iterator实例化，如果此时非要使用Iterator输出Map集合中内容的话，则要采用如下的步骤：</p>
<p>方法一：<br>1.通过entrySet方法变成Set对象<br>2.调用Set的Iterator方法，此时每个Iterator对象是Map.Entry对象<br>3.对Map.Entry分离出 key - value<br>方法二：<br>1.通过keySet得到Map集合多有key的Set集合<br>2.调用Set的Iterator方法，此时每个Iterator对象是key值<br>3.通过Map的getValue(key)得到value值</p>
<p>Eg：<br>package july7;<br>//把Map中的元素取出来</p>
<p>import java.util.HashMap;<br>import java.util.Iterator;<br>import java.util.Map;<br>import java.util.Map.Entry;<br>import java.util.Set;</p>
<p>public class Demo18 {<br>    public static void main(String[] args) {</p>
<pre><code>    Map&lt;Integer, String&gt; m = new HashMap&lt;Integer, String&gt;();

    m.put(1, &quot;jack&quot;);
    m.put(2, &quot;rose&quot;);
    m.put(3, &quot;lucy&quot;);

    //第一种方法
    Set s = m.entrySet();
    Iterator it = s.iterator();
    while(it.hasNext()){
        Map.Entry me = (Entry) it.next();
        System.out.println(me.getKey()+&quot;  &quot;+me.getValue());
    }

    //第二种方法

    s = m.keySet();//得到的是key的集合
    it = s.iterator();//然后将key迭代出来
    while(it.hasNext()){
        int i = (int)it.next();
        System.out.println(i+&quot;   &quot;+m.get(i));
    }
}</code></pre><p>}</p>
<h1 id="八、集合框架（2）"><a href="#八、集合框架（2）" class="headerlink" title="八、集合框架（2）"></a>八、集合框架（2）</h1><p>第八篇    集合框架（2）</p>
<h2 id="1、Collections类"><a href="#1、Collections类" class="headerlink" title="1、Collections类"></a>1、Collections类</h2><p>操作集合的工具类：<br>static void reverse(List list):反转指定List集合中的顺序；（和ListItertor的逆序排列一样！）<br>static void shuffle(List list):对集合元素随机排序<br>static void sort(List list):自然升序排序<br>static vois swap(List list,int i, int j):将指定的List集合i处元素和j处元素进行交换；<br>static void rotate(List list, int distance):<br>    若distance为正数，将list集合后的distance个元素移到前面；<br>    当distance为负数，将list集合前的distance个元素移到后面；<br>static  int binarySearch(List list, Object key) 使用二分搜索法搜索指定列表，以获得指定对象。<br>调用之前 必须调用 Collections.sort(List list)(完成自然排序);</p>
<p>static Object max(Collection coll) 根据元素的自然顺序，返回给定 collection 的最大元素。<br>static Object min(Collection coll) 根据元素的自然顺序，返回给定 collection 的最小元素。<br>static  void fill(List list, Object obj)  使用指定元素替换指定列表中的所有元素。<br>static int frequency(Collection c, Object o)  返回指定 collection 中等于指定对象的元素数。<br>static int indexOfSubList(Listsource, List target) 返回指定源列表中第一次出现指定目标列表的起始位置；如果没有出现这样的列表，则返回 -1。<br>static int lastIndexOfSubList(List source, List target)  返回指定源列表中最后一次出现指定目标列表的起始位置；如果没有出现这样的列表，则返回 -1。<br>static boolean  replaceAll(List list, Object oldVal, Object newVal)  使用另一个值替换列表中出现的所有某一指定值。<br>同步集合 </p>
<p>Eg：<br>import static java.util.Collections.binarySearch;<br>import static java.util.Collections.shuffle;<br>import static java.util.Collections.sort;</p>
<p>import java.util.ArrayList;<br>import java.util.List;</p>
<p>public class CollectionsDemo {<br>    public static void main(String[] args) {<br>        /**<br>         * static int binarySearch(List list, Object ele) 使用二分搜索法搜索指定列表，以获得指定对象。<br>         *<br>         * static void sort(List<T> list) 根据元素的自然顺序 对指定列表按升序进行排序。<br>         */<br>        List list = new ArrayList();<br>        list.add(1);<br>        list.add(-3);<br>        list.add(5);<br>        list.add(-99);</T></p>
<pre><code>    System.out.println(list);
    sort(list);
    System.out.println(list);
    int index = binarySearch(list, 0);
    System.out.println(index);

    /*
     * static void copy(List dest, List src) 将所有元素从一个列表复制到另一个列表。
     * 
     * static void fill(List list, Object obj) 使用指定元素替换指定列表中的所有元素。
     * 
     * static boolean replaceAll(List list, Object oldVal, Object newVal)
     * 使用另一个值替换列表中出现的所有某一指定值。
     * 
     * static void shuffle(List list) 使用默认随机源对指定列表进行置换。
     */
    System.out.println(&quot;好的顺序&quot; + list);
    shuffle(list);
    System.out.println(&quot;随机&quot; + list);

    /*
     * static void swap(List list, int i, int j) 在指定列表的指定位置处交换元素。
     */

}</code></pre><p>}</p>
<h2 id="2、Arrays"><a href="#2、Arrays" class="headerlink" title="2、Arrays"></a>2、Arrays</h2><p>public static  List asList(Object… a)返回一个受指定数组支持的固定大小的列表(返回的是不可变的List(长度固定))。<br>（对返回列表的更改会“直接写”到数组。）此方法同 Collection.toArray() 一起，充当了基于数组的 API 与基于 collection 的 API 之间的桥梁。返回的列表是可序列化的，并且实现了 RandomAccess。<br>    此方法还提供了一个创建固定长度的列表的便捷方法，该列表被初始化为包含多个元素：<br>List<String> list= Arrays.asList(“Larry”, “Moe”, “Curly”);<br>list.add(“Will”);×</String></p>
<p>Eg：<br>import java.util.Arrays;<br>import java.util.List;</p>
<p>public class ArraysDemo {<br>    public static void main(String[] args) {</p>
<pre><code>    /*
     * static  List  asList(Object... a) 
                  返回一个固定长度的列表。 
     * */
    List list = Arrays.asList(&quot;will&quot;,&quot;Lucy&quot;,&quot;小强&quot;);

    System.out.println(list);
    list.set(0, &quot;你好&quot;);
    //list.add(&quot;22&quot;);//错误，返回一个受指定数组支持的固定大小的列表。不可以再添加！
    //list.remove(0);
    System.out.println(list);
}</code></pre><p>}</p>
<h2 id="3、泛型-Generic"><a href="#3、泛型-Generic" class="headerlink" title="3、泛型(Generic)"></a>3、泛型(Generic)</h2><p>引入：我想使用List集合装公司的员工，却装了一条狗进来；<br>使用TreeSet的时候,只能存放同一种数据类型,可惜存了不同的数据类型,依然没有报错,可是运行时出错.</p>
<p>泛型定义：<br>java5开始出现的一种对Java语言类型的一种拓展,以支持创建可以按类型进行参数化的类.可以把类型参数看作是使用参数类型时指定的类型占位符,就好比方法的形式参数是实际参数的占位符一样.<br>泛型能保证大型应用程序的类型安全和良好的维护性;</p>
<p>使用泛型的优势:<br>类型安全,使编译器对泛型定义的类型做判断限制.如保证TreeSet里的元素类型必须一致;消除强制类型的转换,如,使用Comparable比较时每次都需要类型强转；</p>
<h2 id="4、泛型的使用"><a href="#4、泛型的使用" class="headerlink" title="4、泛型的使用"></a>4、泛型的使用</h2><p>泛型类</p>
<p>在类声明时通过一个标识符表示类中某个字段的类型或者某个方法的返回值或参数的类型，这样在类声明或实例化的时候只要指定自己需要的类型就ok。</p>
<p>声明带泛型的类:<br>class 类名&lt;泛型类型1,泛型类型2……&gt;{<br>    泛型类型  变量名；<br>    泛型类型  方法名(){}<br>    返回值类型 方法名(泛型类型 变量名){}<br>}<br>使用带泛型的类：<br>类名&lt;具体类&gt; 对象名 = new 类名&lt;具体类&gt;();</p>
<p>类型参数规范：推荐使用规范-常见的泛型,泛型只保存在源文件中,class文件中不存在;也就是说在编译阶段就会丢失,基本数据类型不能作为泛型类型;<br>K     键，比如映射的键  key的类型<br>V    值，比如Map的值 value类型<br>E    元素，比如Set<E>  Element表示元素,元素的类型<br>T     泛型，Type的意思</E></p>
<p>我的总结：泛型好处：限定添加类型和消除强转转换的麻烦！</p>
<p>泛型使用</p>
<p>public class Point<Q> {    //声明任意符号的标识符<br>    private Q x;    //变量类型由外部组成<br>    private Q y;</Q></p>
<pre><code>public Q getX() {
    return x;
}
public void setX(Q x) {    //类型由外部决定
    this.x = x;
}
//..........................</code></pre><p>}</p>
<p>……………..main………<br>{<br>    Point<Double> p = new Point<Double>();    //定义具体类型<br>    p.setX(1.1);<br>    p.setY(2.2);<br>}</Double></Double></p>
<p>练习例子<br>需求：设计一个表示点的类Point,该类有两个字段，一个是横坐标x,一个纵坐标y,要求坐标有3种表达形式（Integer，Double，String）：</p>
<p>如果不使用泛型的话可以新建多个类，但是内部方法体只有参数类型不一样，所以用泛型的话更加简单，给定一个占位符，并不明确表示到底是什么类型，在实际运用的时候才确定类型！！</p>
<p>很好的例子！<br>package generic;</p>
<p>class Point<T>{</T></p>
<pre><code>private T t1;
private T t2;
public T getT1() {
    return t1;
}
public void setT1(T t1) {
    this.t1 = t1;
}
public T getT2() {
    return t2;
}
public void setT2(T t2) {
    this.t2 = t2;
}</code></pre><p>}</p>
<p>public class GenericDemo {<br>    public static void main(String[] args) {<br>        //String 类型的<br>        Point<String> p = new Point<String>();<br>        p.setT1(“2”);<br>        p.setT2(“3”);<br>        System.out.println(p.getT1());<br>        System.out.println(p.getT2());<br>        //Integer 类型的<br>        Point<Integer> p2 = new Point<Integer>();<br>        p2.setT1(23);<br>        p2.setT2(24);<br>        System.out.println(p2.getT1());<br>        System.out.println(p2.getT2());<br>        //Double 类型的<br>        Point<Double> p3 = new Point<Double>();<br>        p3.setT1(23.00);<br>        p3.setT2(24.00);<br>        System.out.println(p3.getT1());<br>        System.out.println(p3.getT2());<br>//============================<br>        Set<String> s = new HashSet<String>();//创建一个容器对象,应该在创建的时候就明确是装什么的<br>        s.add(“a”);<br>        //s.add(1);//此时就加不进去了，因为已经限制了容器内参数类型！<br>        //此时就能保证集合里元素类型一致,<br>        Set<Integer> treeSet = new  TreeSet<Integer>();<br>        //规定key只能是String,value是Date<br>        Map&lt;String,Date&gt; map = new HashMap&lt;String,Date&gt;();<br>        // V put(K key, V value)<br>        Date v = map.put(“”, new Date());//和上面定义的类型一样<br>        //V get(Object key)<br>        Date val = map.get(“”);<br>    }<br>}</Integer></Integer></String></String></Double></Double></Integer></Integer></String></String></p>
<p>运行结果<br>2<br>3<br>23<br>24<br>23.0<br>24.0<br>这样的话借助泛型一个类就可以表达多个不同类型的参数！</p>
<p>要求<br>消除强制类型的转换,如,使用Comparable比较时每次都需要类型强转;</p>
<p>1、没有加上泛型，最初的需要强制类型转换</p>
<p>package generic;</p>
<p>import java.util.Set;<br>import java.util.TreeSet;</p>
<p>class Person implements Comparable{//需要进行排序的类要实现Comparable</p>
<pre><code>private Integer age;
public Person(Integer age) {
    super();
    this.age = age;
}
@Override
public int compareTo(Object o) {
    Person p = (Person)o;//强制类型转换
    return this.age.compareTo(p.age);
}
public String toString(){
    return this.age.toString();    
}</code></pre><p>}</p>
<p>public class GenericDemo2 {<br>    public static void main(String[] args) {<br>        Set set = new TreeSet();<br>        set.add(new Person(15));<br>        set.add(new Person(12));<br>        set.add(new Person(19));<br>        set.add(new Person(53));<br>        set.add(new Person(62));<br>        System.out.println(set);<br>    }<br>}<br>第二步：加上泛型，不再需要强转（因为类型已经固定了）！</p>
<p>package generic;</p>
<p>import java.util.Set;<br>import java.util.TreeSet;</p>
<p>class Person implements Comparable<Person>{//<br>    private Integer age;<br>    public Person(Integer age) {<br>        super();<br>        this.age = age;<br>    }<br>    @Override<br>        public int compareTo(Person o) {<br>            return this.age.compareTo(o.age);//按照什么排序<br>        }<br>    public String toString(){<br>        return this.age.toString();<br>    }<br>}</Person></p>
<p>public class GenericDemo2 {<br>    public static void main(String[] args) {<br>        Set<Person> set = new TreeSet<Person>();<br>        set.add(new Person(15));<br>        set.add(new Person(12));<br>        set.add(new Person(19));<br>        set.add(new Person(53));<br>        set.add(new Person(62));<br>        System.out.println(set);<br>    }<br>}</Person></Person></p>
<h2 id="5、声明多个泛型类型和通配符"><a href="#5、声明多个泛型类型和通配符" class="headerlink" title="5、声明多个泛型类型和通配符"></a>5、声明多个泛型类型和通配符</h2><p>若一个类中多个字段需要不同的泛型声明，则在声明类的时候指定多个泛型类型即可；</p>
<p>格式：<br>public interface IDAO&lt;PK, T&gt; {</p>
<pre><code>PK add(T t);

void remove(PK id);

void update(PK id, T t);

T get(PK id);</code></pre><p>}</p>
<p>在进行引用传递的时候泛型类型必须匹配才可以传递，否则编译不通过；<br>使用 ？ ，表示未知类型的泛型对象：<br>List<?> 表示未知元素的List集合；
这种带通配符的List仅表示各种泛型List的父类，并不能把元素添加入集合中；
List<?> list = new ArrayList&lt;&gt;(); list.add(1);//ERROR<br>public void show(List&lt;?&gt; list){}<br>//表示可接受任意类型的List集合</p>
<h2 id="6、泛型的上限与下限"><a href="#6、泛型的上限与下限" class="headerlink" title="6、泛型的上限与下限"></a>6、泛型的上限与下限</h2><p>设置泛型对象的上限使用extends,表示参数类型只能是该类型或该类型的子类：<br>声明对象：类名&lt;? extends 类&gt; 对象名<br>定义类：类名&lt;泛型标签 extends 类&gt;{}<br>设置泛型对象的下限使用super,表示参数类型只能是该类型或该类型的父类：<br>声明对象：类名&lt;? super 类&gt; 对象名称<br>定义类：类名&lt;泛型标签 extends类&gt;{}</p>
<p>public static void  show(List&lt;? extends Number&gt; l){</p>
<p>}<br>public static void  show(List&lt;? super String&gt; l){</p>
<p>}<br>public static void show(List&lt;? extends Number&gt; l){}<br>public static void show(List&lt;? super String&gt; l){}</p>
<p>泛型的上限</p>
<p>public static void main(String[] args) {<br>        Person<Integer> p1 = new Person&lt;&gt;();<br>        p1.setVal(99);<br>        Person<Double> p2 = new Person&lt;&gt;();<br>        p2.setVal(3.14);<br>        Person<String> p3 = new Person&lt;&gt;();<br>        p3.setVal(“007”);<br>        show(p1);//√<br>        show(p2);//√<br>        show(p3);//×<br>    }<br>    public static void show(Person&lt;? extends Number&gt; p){//此处限定了Person的参数类型只能是Number或者是其子类，而String并不属于Number。<br>        System.out.println(p.getVal());<br>    }</String></Double></Integer></p>
<p>泛型的下限</p>
<pre><code>public static void main(String[] args) {
    Person&lt;Integer&gt; p1 = new Person&lt;&gt;();
    p1.setVal(99);//Integer
    Person&lt;Double&gt; p2 = new Person&lt;&gt;();
    p2.setVal(3.14);//Double

    Person&lt;String&gt; p3 = new Person&lt;&gt;();
    p3.setVal(&quot;007&quot;);//String
    Person&lt;Object&gt; p4 = new Person&lt;&gt;();
    p4.setVal(new Object());//Object

    show(p1);//×
    show(p2);//×
    show(p3);//√
    show(p4);//√
}
public static void show(Person&lt;? super String&gt; p){
    System.out.println(p.getVal());
}</code></pre><p>很好的例子！<br>package generic;</p>
<p>import java.util.ArrayList;<br>import java.util.List;</p>
<p>public class GenericDemo3 {<br>    public static void main(String[] args) {<br>        //因为show方法是用List&lt;?&gt;通配符接收的，所以可以是任意类型！<br>        List<String> l1 = new ArrayList&lt;&gt;();//new ArrayList<String>()<br>        show(l1);<br>        List<Double> l2 = new ArrayList&lt;&gt;();<br>        show(l2);<br>        List<Number> l3 = new ArrayList&lt;&gt;();<br>        show(l3);<br>        List<Object> l4 = new ArrayList&lt;&gt;();<br>        show(l4);<br>        //使用up方法的话接收类型为Number或者其子类<br>        //up(l1);//错误，因为up方法接收类型为Number或者其子类，l1（String）不符合！<br>        up(l2);<br>        up(l3);<br>        //使用down方法的话接收类型为Number或者其父类<br>        //down(l2);error<br>        down(l3);<br>        down(l4);<br>    }<br>public static void down(List&lt;? super Number&gt; l){</Object></Number></Double></String></String></p>
<pre><code>    for (Object object : l) {
        System.out.println(object);
    }
}</code></pre><p>public static void up(List&lt;? extends Number&gt; l){</p>
<pre><code>    for (Object object : l) {
        System.out.println(object);
    }
}
public static void show(List&lt;?&gt; l){

    for (Object object : l) {
        System.out.println(object);
    }
}</code></pre><p>}</p>
<h2 id="7、泛型接口和方法"><a href="#7、泛型接口和方法" class="headerlink" title="7、泛型接口和方法"></a>7、泛型接口和方法</h2><p>java5后，可以声明泛型接口，声明方式和声明泛型类是一样的。<br>public interface IDAO<T>{}<br>泛型接口子类有两种方式：<br>直接在子类后申明泛型；<br>在子类实现的接口中给出具体的泛型类型<br>public class DaoImpl<T> implements IDAO<T>{}<br>public class DaoImpl implements IDAO<String>{}</String></T></T></T></p>
<p>泛型方法</p>
<p>方法中可定义泛型参数，形参的参数类型就是实参的类型。<br>格式：<br>&lt;泛型标签&gt; 返回值类型 方法名([泛型标签 参数]…)</p>
<p>public static <T extends number> List<T> show(T……t){<br>    return null;<br>}<br>…..main…..{<br>    //Show(new Object[]{});不可以，因为方法参数类型的限定<br>Show(new Number[]{});<br>Show(new Integer[]{});<br>}</T></T></p>
<p>8、泛型的嵌套（map例子）</p>
<p>package july7;<br>//泛型加Map的输出！</p>
<p>import java.util.Iterator;<br>import java.util.Map;<br>import java.util.Map.Entry;<br>import java.util.Set;<br>import java.util.TreeMap;</p>
<p>public class Demo20 {<br>    public static void main(String[] args) {<br>        Map&lt;Integer, String&gt; m = new TreeMap&lt;Integer, String&gt;();</p>
<pre><code>m.put(1, &quot;周冬雨&quot;);
m.put(2, &quot;章子怡&quot;);
m.put(3, &quot;章泽天&quot;);

System.out.println(m);

//第一种方式，用到了entrySet方法
Set&lt;Entry&lt;Integer, String&gt;&gt; s = m.entrySet();
Iterator&lt;Entry&lt;Integer, String&gt;&gt; it = s.iterator();
while(it.hasNext()){
    Entry&lt;Integer, String&gt; e = it.next();//用到了泛型，这里消除了 强转！
    System.out.println(e.getKey()+&quot;  &quot;+e.getValue());
}</code></pre><p>​<br>​        //第二种方法，用到了keySet方法<br>​        Set<Integer> set = m.keySet();<br>​        Iterator<Integer> iter = set.iterator();<br>​        while(iter.hasNext()){<br>​            Integer i = iter.next();//直接写到输出语句，出错！<br>​            System.out.println(i+”  “+m.get(i));<br>​        }<br>​    }<br>}</Integer></Integer></p>
<h1 id="九、IO操作（1）"><a href="#九、IO操作（1）" class="headerlink" title="九、IO操作（1）"></a>九、IO操作（1）</h1><p>第九篇    IO文件操作（1）</p>
<h2 id="1、IO的概述和File方法"><a href="#1、IO的概述和File方法" class="headerlink" title="1、IO的概述和File方法"></a>1、IO的概述和File方法</h2><p>IO流用来处理设备之间的数据传输<br>    Java对数据的操作是通过流的方式<br>    Java用于操作流的对象都在IO包中</p>
<p>File类在整个IO包中与文件本身有关的操作类，所有的与文件本身有关指的是创建、删除文件等操作。在java.io包中的File类本身是一个跨平台的文件操作类，所以在操作中要更多的考虑到各个操作系统的区别。<br>File 即指文件也指文件夹。</p>
<p>File类构造方法和字段摘要<br>static String pathSeparator  路径分隔符，window下是”;”。<br>static char pathSeparatorChar   路径分隔符，window下是”;”。<br>static String separator  路径分隔符，window下是”&quot;。<br>static char separatorChar  路径分隔符，window下是”&quot;。<br>File(File parent, String child) 根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。<br>File(String pathname)  通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例。<br>File(String parent, String child) 根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。<br>File(URI uri)  通过将给定的 file: /URI 转换为一个抽象路径名来创建一个新的 File 实例。 </p>
<p>File的相关方法</p>
<p>String getName():返回文件名或路径名（若是路径，返回最后一级子路径名）<br>String getPath():返回对象对应的路径名<br>File  getAbsoluteFile():返回绝对路径<br>String getAbsolutePath():返回对象对应的绝对路径<br>String getParent():返回文件目录的上一级目录名<br>boolean renameTo(File newName):重命名此File对象对应的文件或目录，若重命名成功返回true;<br>boolean exists():判断对象对应的文件或目录是否存在；<br>boolean canWrite():判断对象对应文件或目录是否可写；<br>boolean canRead():判断对象对应文件或目录是否可读；<br>boolean isFile():判断对象是文件，不是目录；<br>boolean isDirectory()  判断对象的文件是否是一个目录；<br>boolean isAbsolute() 判断对象对应文件或目录是否为绝对路径名； </p>
<p>boolean createNewFile() 当且仅当不存在，该方法创建一个该File对象所指定的新文件，创建成功返回true。<br>boolean delete():删除File对象所对应的文件或路径；<br>boolean mkdir() 创建File对象所对应的目录，调用该方法的File对象必须对应路径，而不是文件。<br>String[] list():列出File对象的所有子文件名和路径名。<br>File[] listFiles():列出File对象的所有子文件和路径。<br>static File[] listRoots():列出系统所有的根路径；</p>
<p>我的总结：IO这一章节最应该记住的关键字：读进来，写进去！</p>
<p>Eg：<br>package july7file;</p>
<p>import java.io.File;<br>import java.io.IOException;</p>
<p>public class Demo1 {<br>    public static void main(String[] args) throws IOException {</p>
<pre><code>    File f = new File(&quot;E:/你好.txt&quot;);
    System.out.println(f.createNewFile());
    System.out.println(f.getName());
    System.out.println(f.getParent());
    System.out.println(f.length());
}</code></pre><p>}</p>
<p>输出：<br>false<br>你好.txt<br>E:<br>6905</p>
<h2 id="2、递归-Recursion"><a href="#2、递归-Recursion" class="headerlink" title="2、递归(Recursion)"></a>2、递归(Recursion)</h2><p>现在要求输出一个给定目录中的全部文件的路径。<br>本程序肯定只能依靠递归的操作完成，因为在一个给定的路径下有可能还是文件夹，那么如果是文件夹的话则肯定要继续列出，重复判断。<br>递归：程序调用自身的编程技巧<br>递归就是在方法里调用自身；<br>在使用递归时，必须有一个明确的递归结束条件，称为递归出口。</p>
<p>练习：列出文件夹下所有文件（包含子文件夹内）<br>package july7file;</p>
<p>//利用递归遍历输出</p>
<p>import java.io.File;</p>
<p>public class Demo2 {<br>    public static void main(String[] args) {<br>        File f = new File(“D:/V5”);</p>
<pre><code>    mylist(f);
}

public static void mylist(File f) {
    System.out.println(f);// 先输出一下，因为不能确定接受来的文件是否是文件夹！
    if (f.isDirectory()) {
        File[] file = f.listFiles();
        for (File file2 : file) {
            mylist(file2);
        }
    }
}</code></pre><p>}</p>
<p>练习：删除一个目录（注意：要删除目录必须删除目录下的文件和子目录)<br>package july7file;</p>
<p>import java.io.File;</p>
<p>public class Demo11 {<br>    public static void main(String[] args) {</p>
<pre><code>    File f = new File(&quot;D:/V5&quot;);
    deleter(f);

    System.out.println(&quot;删除成功 ！&quot;);
}

public static void deleter(File f){//程序简陋，就没有判断空引用！
    if(f.isFile()){
        f.delete();
    }else if(f.isDirectory()){
        File []file = f.listFiles();
        for (File file2 : file) {
            deleter(file2);//调用自身，递归！
            file2.delete();//删除子文件夹（内部没有文件的时候可以删除），如果这里写上f.delete();那么V5这个文件夹也没有了
        }
    }
}</code></pre><p>}</p>
<h2 id="3、文件过滤器-java-io-FilenameFilter"><a href="#3、文件过滤器-java-io-FilenameFilter" class="headerlink" title="3、文件过滤器 java.io.FilenameFilter"></a>3、文件过滤器 java.io.FilenameFilter</h2><p>File 类里有方法： String[] list(FilenameFilter filter)    返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录。<br>FilenameFilter(文件过滤器)该接口里包含accept(File dir,String name)方法，该方法依次对指定File的所有子目录，子文件夹进行迭代。<br>dir - 被找到的文件所在的目录。<br>name - 文件的名称。<br>当且仅当该名称应该包含在文件列表中时返回 true；否则返回 false</p>
<p>Eg：<br>package july7file;</p>
<p>//构造过滤器，只输出需要的文件！</p>
<p>import java.io.File;<br>import java.io.FilenameFilter;</p>
<p>class MyFilter implements FilenameFilter {<br>    private String ext;</p>
<pre><code>public MyFilter(String ext) {
    super();
    this.ext = ext;
}

@Override
public boolean accept(File dir, String name) {
    return name.endsWith(ext);// 真正起作用的还是这里的ext
}</code></pre><p>}</p>
<p>public class Demo3 {<br>    public static void main(String[] args) {</p>
<pre><code>    File f = new File(&quot;D:/V5/牛/水牛&quot;);

    File[] file = f.listFiles(new MyFilter(&quot;.txt&quot;));
    for (File file2 : file) {
        System.out.println(file2);
    }
}</code></pre><p>}</p>
<h2 id="4、流"><a href="#4、流" class="headerlink" title="4、流"></a>4、流</h2><p>数据流是一串连续不断的数据的集合,就像水管里的水流,在水管的一端一点一点地供水,而在水管的另一端看到的是一股连续不断的水流.<br>数据写入程序可以使一段一段地向数据流管道中写入数据,这些数据段会按先后顺序形成一个长的数据流.</p>
<p>在程序中所有的数据都是以流的方法进行传输和保存的。<br>Java 的IO是实现输入和输出的基础。<br>Java把所有传统的流类型(类或抽象类)都放在java.io包中，用以实现输入输出功能。<br>输入和输出是一个相对的概念，我们一般站在程序的角度来分析和处理问题的。<br>程序需要数据 –&gt; 读进来    –&gt;    输入<br>程序保存数据 –&gt; 写出去    –&gt;    输出<br>水流</p>
<p>我的总结：最重要的：从程序的角度出发，读进来，写出去！（在储存数据的时候是把数据写出去，这时候数据就储存在了文件里面，在需要调用数据的时候就把数据读进来，这样数据就又到了程序中！）</p>
<p>流的分类（面试常考）</p>
<p>从不同角度分类：<br>按流动方向的不同可以分为输入流和输出流；<br>按处理数据的单位不同分为字节流和字符流；<br>按功能的不同可分为节点流和处理流；<br>     节点流：直接操作目标设备，例如：磁盘或一块内存区域。<br>     处理流：通过操作节点流,从而间接完成输入或输出功能的流。处理流是的存在是建立在一个已经存在的输入流或输出流的基础之上的。</p>
<p>所有流都继承于以下四种抽象流类型的某一种：（抽象流）</p>
<h2 id="5、操作流的步骤（重点）"><a href="#5、操作流的步骤（重点）" class="headerlink" title="5、操作流的步骤（重点）"></a>5、操作流的步骤（重点）</h2><p>File类本身是与文件操作有关，但是如果要想操作内容则必须使用字节流或字符流完成，但是不管是使用何种的输入输出流，其基本的操作原理是一样的（以文件流为准）:<br>一、使用File类找到一个文件对象,得到IO操作的源或目标<br>二、通过字节流或字符流的子类创建对象,(得到IO操作的通道)<br>三、进行读或写的操作,(IO操作)<br>四、关闭输入/输出,(打完收工,注意节约资源,关掉)<br>由于流的操作属于资源操作，所以在操作的最后一定要关闭以释放资源。</p>
<p>其实上面的流操作步骤可以联系生活中的例子:比如想把水井里的水弄到家里的大水缸去,怎么搞呢?<br>1.找到水井在哪里;2.找根管子一头接在水井里,一头接在家里的大水缸里;3.打开管子上的龙头,放水;4.水放满了,关掉水龙头.</p>
<p>计算机访问外部设备,要比直接访问内存慢得多,若我们每一次write方法调用都是直接写到外部设备(比如磁盘上的一个文件),CPU就要花费更多的时间去等待外部设备;我们可以开辟一个内存缓冲区,程序每一次的write方法都是写到这个内存缓冲区中,只有这个缓冲区装满了之后,系统才将这个缓冲区的内容一次集中写到外部设备.</p>
<p>我的总结：<br>好处:1.有效提高了CPU的使用率;2.write方法并没有马上真正写入到外部设备,我们还有机会回滚部分写入的数据;</p>
<p>Eg：<br>package july7file;<br>//构建输入流，读进来，输出到控制台！</p>
<p>import java.io.FileInputStream;<br>import java.io.InputStream;</p>
<p>public class Demo4 {<br>    public static void main(String[] args) throws Exception {<br>        //第一步：创建源！<br>        String filename = “6.4”;//这个文件是在工作空间里面，没有后缀名！</p>
<pre><code>    //第二步：创建管道！
    InputStream ips = new FileInputStream(filename);

    //第三步：操作！

    byte []buff = new byte[1024];
    int len;//定义缓冲区
    while((len = ips.read(buff)) != -1){
        System.out.println(new String(buff,0,buff.length));//输出到控制台！此时的输出流就是打印流！
        System.out.println(&quot;==========================================&quot;);//打印下，看哪里在1024。1024的地方被隔开了
    }

    //第四步：关闭资源(字符流必须关闭资源，因为它中间有缓冲区！对于字节流可以不用关闭，但是还是建议写上，习惯！)
    ips.close();
}</code></pre><p>}</p>
<p>输出：就将文件6.4中的数据打印到了控制台！</p>
<h2 id="6、字节流和字符流"><a href="#6、字节流和字符流" class="headerlink" title="6、字节流和字符流"></a>6、字节流和字符流</h2><p>二者仅仅是操作单位不一样。<br>InputStream和Reader是所有输入流的基类，他们都是抽象类，本身不能创建实例，但是他们是所有输入流的模板。<br>一般来说处理字符或字符串时使用字符流，处理字节或二进制对象时应使用字节流；<br>备注：字符流必须关闭资源，因为它中间有缓冲区！而字节流不需要！但是一般都会（最后）关闭资源！</p>
<p>字节流<br>字节流主要是操作byte(字节)的类型数据:<br>字节输出流：OutputStream<br>字节输入流：InputStream</p>
<p>字符流<br>Java中的字符是Unicode编码,是双字节的,1个字符 等于 2个字节;<br>使用字节来处理字符文本就不太方便了,此时可以考虑使用字符流;<br>字符流主要是操作char的类型数据:<br>字符输出流：Writer<br>字符输入流：Reader</p>
<p>字节流和字符流的区别</p>
<p>字节流和字符流在使用上的代码结构都是非常类似的，但是其内部本身也是有区别的，因为在进行字符流操作的时候会使用到缓冲区（内存中），而字节流操作的时候是不会使用到缓冲区的。<br>在输出的时候，OutputStream类即使最后没有关闭内容也可以输出。但是如果是Writer的话，则如果不关闭，最后一条内容是无法输出的，因为所有的内容都是保存在了缓冲区之中，每当调用了close()方法就意味着清空缓冲区了。那么可以证明字符流确实使用了缓冲区：<br>字节流：程序 → 文件<br>字符流：程序 → 缓冲区（内存中） → 文件</p>
<p>如果现在字符流即使不关闭也可以完成输出的话，则必须强制性清空缓冲区：<br>方法：public void flush() throws IOException</p>
<p>我的总结：<br>两者相比，肯定使用字节流更加的方便，而且在程序中像图片、MP3等都是采用字节的方式的保存，那么肯定字节流会比字符流使用的更广泛。<br>但是需要说明的是，但是如果要是想操作中文的话，字符流肯定是最好使的。（字节流的话可能会出现乱码（一个汉字分成了两份）！）</p>
<p>Eg：<br>package july7file;<br>//字符流读出来，这时候就不会出现乱码的情况，在进行文字操作的时候最好使用字符流！</p>
<p>import java.io.File;<br>import java.io.FileNotFoundException;<br>import java.io.FileReader;<br>import java.io.IOException;<br>import java.io.Reader;</p>
<p>public class Demo6 {<br>    public static void main(String[] args) {</p>
<pre><code>    File src = new File(&quot;6.4&quot;);
    read(src);
}

public static void read(File src){
    Reader r = null;
    try {
        r = new FileReader(src);
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    }

    char []c = new char[1024];
    int len;
    try {
        while((len = r.read(c)) != -1){
            System.out.println(new String(c,0,c.length));//打印到控制台
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
    try {
        r.close();
    } catch (IOException e) {
        e.printStackTrace();
    }
}</code></pre><p>}</p>
<h2 id="7、文件拷贝"><a href="#7、文件拷贝" class="headerlink" title="7、文件拷贝"></a>7、文件拷贝</h2><p>需求：源和目标！<br>那么我们需要源文件和目标文件！<br>构建管道的时候就需要两个：输出流和输入流管道！</p>
<p>Eg：<br>package july7file;</p>
<p>//java7开始的自动关闭资源</p>
<p>import java.io.File;<br>import java.io.FileInputStream;<br>import java.io.FileOutputStream;<br>import java.io.IOException;<br>import java.io.InputStream;<br>import java.io.OutputStream;</p>
<p>public class Demo8 {<br>    public static void main(String[] args) throws IOException {</p>
<pre><code>    File src = new File(&quot;E:/自荐信.doc&quot;);
    File tar = new File(&quot;E:/自荐信1.doc&quot;);

    copy(src, tar);
    System.out.println(&quot;Well done ！&quot;);
}

public static void copy(File src, File tar) throws IOException {
    try (InputStream is = new FileInputStream(src);
            OutputStream os = new FileOutputStream(tar);) {
        byte[] b = new byte[1024];
        int len;
        while ((len = is.read(b)) != -1) {
            os.write(b);
        }

    } catch (IOException e) {
        e.printStackTrace();
    }
}</code></pre><p>}</p>
<p>题目：复制图片！<br>package july7file;<br>/**</p>
<ul>
<li>文件的复制！对于本题而言，因为是图片，所以要想读出来，必须使用字节流！</li>
<li>字符流必须关闭资源，而字节流可以不关闭资源！但是还是建议全部的关闭，因为也不会出错，这是关闭资源的习惯！</li>
<li>另外：最常用的是字节流，因为字节流在内存中不需要缓冲区，图片，mp3等都是字节流！但是对于文字的话还是字符流比较好；</li>
<li>因为字符流可以避免在字节流操作文字时出现的乱码现象（正好读取到了自定义缓冲区的分割处）；</li>
<li>/</li>
</ul>
<p>import java.io.File;<br>import java.io.FileInputStream;<br>import java.io.FileOutputStream;<br>import java.io.InputStream;<br>import java.io.OutputStream;</p>
<p>public class Demo7 {<br>    public static void main(String[] args) throws Exception {<br>        File src = new File(“D:/java.jpg”);</p>
<pre><code>    File tar = new File(&quot;D:/meinv.jpg&quot;);

    copy(src,tar);
    System.out.println(&quot;复制完成！&quot;);
}
public static void copy(File src,File tar) throws Exception{</code></pre><p>/*        Reader r = new FileReader(src);<br>        Writer w = new FileWriter(tar);<em>/<br>        /*if(!src.exists()){<br>            throw new Exception(“对不起，源文件不存在！”);<br>        }</em>/<br>        InputStream in = new FileInputStream(src);<br>        OutputStream os = new FileOutputStream(tar);</p>
<pre><code>    byte []c = new byte[1024];
    int len;
    while((len = in.read(c)) != -1){
        os.write(c);
    }

/*    w.close();
    r.close();*/
}</code></pre><p>}</p>
<p>我的总结：对于图片的复制，可以使用字符流，但是这样的话文件可以复制成功但是无法读取！</p>
<h2 id="8、字节→字符转换流"><a href="#8、字节→字符转换流" class="headerlink" title="8、字节→字符转换流"></a>8、字节→字符转换流</h2><p>OutputStreamWriter:把字节输出流对象转成字符输出流对象<br>InputStreamReader:把字节输入流对象转成字符输入流对象<br>FileWriter和FileReader分别是OutputStreamWriter和InputStreamReader的直接子类，而不是Writer和Reader的直接子类，区别于FileInputStream 和InputStream。</p>
<p>我的总结：无论使用字节流还是字符流实际上在内存中最终都是通过字节的形式来操作流的。<br>所以并没有字符流转换字节流。</p>
<p>Eg：<br>//构建一个字节输出流对象<br>OutputStream out = new FileOutputStream(“”);<br>//把字节输出流转成字符输出流<br>Writer w  = new OutputStreamWriter(out);<br>//然后的操作和使用字符输出流的操作一样</p>
<hr>
<p>//构建一个字节输入流对象<br>InputStream is = new FileInputStream(“”);<br>//把字节输入流转成字符输入流<br>Reader r = new InputStreamReader(is);<br>//然后的操作和使用字符输入流的操作一样</p>
<p>9、自动关闭资源的try语句</p>
<p>Java 7简化资源清理(try-with-resources)自动关闭资源的try语句</p>
<p>自动关闭资源格式：<br>try(    )//此处多了圆括号，（）圆括号内写打开资源的代码，在这里创建的对象必须实现Autocloseable接口<br>{<br>IO操作<br>}<br>catch（）{<br>处理异常的代码<br>}</p>
<p>Eg：package july7file;</p>
<p>//java7开始的自动关闭资源</p>
<p>import java.io.File;<br>import java.io.FileInputStream;<br>import java.io.FileOutputStream;<br>import java.io.IOException;<br>import java.io.InputStream;<br>import java.io.OutputStream;</p>
<p>public class Demo8 {<br>    public static void main(String[] args) throws IOException {</p>
<pre><code>    File src = new File(&quot;E:/自荐信.doc&quot;);
    File tar = new File(&quot;E:/自荐信1.doc&quot;);

    copy(src, tar);
    System.out.println(&quot;Well done ！&quot;);
}

public static void copy(File src, File tar) throws IOException {
    try (InputStream is = new FileInputStream(src);
            OutputStream os = new FileOutputStream(tar);) //圆括号内写打开资源的操作
        {
        byte[] b = new byte[1024];
        int len;
        while ((len = is.read(b)) != -1) {
            os.write(b);
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
}</code></pre><p>}</p>
<h1 id="十、IO文件操作（2）"><a href="#十、IO文件操作（2）" class="headerlink" title="十、IO文件操作（2）"></a>十、IO文件操作（2）</h1><h2 id="1、内存操作流"><a href="#1、内存操作流" class="headerlink" title="1、内存操作流"></a>1、内存操作流</h2><p>操作内存流的时候（从读取出来，注意一定要把真正的数据用toByteArray或者toCharArray将数据读出来）<br>之前的文件操作流是以文件的输入输出为主的，当输出的位置变成了内存，那么就称为内存操作流。此时要使用内存流完成内存的输入和输出操作。<br>如果程序运行过程中要产生一些临时文件，可采用虚拟文件方式实现；<br>直接操作磁盘的文件很耗性能,使用内存流可以提升性能;jdk里提供了内存流可实现类似于内存虚拟文件的功能。<br>ByteArrayInputStream：将内容写到内存中     CharArrayReader<br>ByteArrayOutputStream：将内存中的数据写出      CharArrayWriter<br>ByteArrayInputStream：构造方法：<br>public ByteArrayInputStream(byte[] buf):全部内容<br>public ByteArrayInputStream(byte[] buf,int offset,int length)：指定范围的内容<br>ByteArrayOutputStream:<br>public ByteArrayOutputStream()</p>
<p>我的总结：内存流操作：先把数据写到内存中去，然后再从内存中读取出来！提升了性能！</p>
<p>例子<br>//此处用的是内存字节流（写入加输出）<br>package june6D;</p>
<p>import java.io.ByteArrayInputStream;<br>import java.io.ByteArrayOutputStream;<br>import java.io.IOException;</p>
<p>public class ByteArrayDemo7 {<br>    public static void main(String[] args) throws IOException {<br>        String s = “java is a good language”;<br>        ByteArrayOutputStream bos = new ByteArrayOutputStream();//输出流<br>        bos.write(s.getBytes());<br>        // 已经把信息写到了内存中</p>
<pre><code>    byte[] bys = bos.toByteArray();// 得到真正的数据
    ByteArrayInputStream bis = new ByteArrayInputStream(bys);//输入流，需要源。
    byte[] b = new byte[1024];
    int len;
    while ((len = bis.read(b)) != -1) {
        String data = new String(b, 0, len);
        System.out.println(data);
    }
}</code></pre><p>}</p>
<p>package june6D;</p>
<p>import java.io.CharArrayReader;<br>import java.io.CharArrayWriter;</p>
<p>public class CharArrayDemo8 {</p>
<pre><code>public static void main(String[] args) throws Exception {
    // 用内存字符流先把数据保存到内存中，然后从内存中取出数据
    String s = &quot;河南城建学院&quot;;
    CharArrayWriter cw = new CharArrayWriter();
    cw.write(s);// 数据写到了内存中
    char[] ch = cw.toCharArray();
    CharArrayReader cr = new CharArrayReader(ch);
    char[] b = new char[1024];
    int len;
    while ((len = cr.read(b)) != -1) {
        String data = new String(b, 0, len);
        System.out.println(data);
    }
}</code></pre><p>}</p>
<h2 id="2、打印流"><a href="#2、打印流" class="headerlink" title="2、打印流"></a>2、打印流</h2><p>（只有两个，PrintWriter和PrintStream）<br>思考：如果现在要想完成一个字符串或者是boolean型或者是字符型的数据输出使用OutputStream是否方便？<br>肯定是不方便的，因为OutputStream中只能操作字节数据，所以其他的数据类型很难操作，那么在Java的IO包中为了解决这种问题增加了两种类：PrintStream、PrintWriter。<br>打印流有非常好的打印功能，可以打印任何的数据类型。如，整数，小数，字符串等。<br>观察PrintStream类的构造：<br>    public PrintStream(File file) throws FileNotFoundException<br>    public PrintStream(OutputStream out)<br>虽然PrintStream是OutputStream的子类，但是在实例化的时候依然需要一个OutputStream的对象。</p>
<p>PrintWriter和PrintStream都属于输出流，分别针对字符和字节。<br>PrintWriter和PrintStream重载的print()和println()用于多种数据类型的输出。<br>print()里的参数不能为空；println()可以<br>PrintWriter和PrintStream输出操作不抛出异常<br>PrintStream调用println方法有自动flush功能;</p>
<p>Eg：<br>package june6D;</p>
<p>import java.io.FileWriter;<br>import java.io.PrintStream;<br>import java.io.PrintWriter;</p>
<p>public class PrintDemo9 {<br>    public static void main(String[] args) throws Exception {</p>
<pre><code>    PrintStream ps = new PrintStream(&quot;out.txt&quot;);
    // ps.write(12);
    ps.println(10086);
    ps.println(false);
    // ps.print();针对print而言，不可以出现这样的（无参）
    ps.println();// 此时就可以

    //备注：System.out.println();想当于ps = System.out;

    ps = System.out;
    ps.println(&quot;您好！&quot;);// 控制台操作，注意上一句
    // 字符打印流
    PrintWriter pr = new PrintWriter(&quot;out2.txt&quot;);
    // PrintWriter(OutputStream out, boolean autoFlush) 通过现有的 OutputStream，创建新的 PrintWriter。（构造方法）

    pr = new PrintWriter(new FileWriter(&quot;out2.txt&quot;), true);// 自动刷新,否则的话需要关闭资源！
    // 与PrintStream不同，若PrintWriter使用了自动刷新方法，那么必须调用println，print，format这些方法的其中一个才可以实现操作
    pr.println(&quot;呼哈哈哈哈&quot;);
    pr.println(false);

    pr = new PrintWriter(System.out, true);// 打印在控制台上
    pr.println(false);
    pr.println(&quot;河南城建学院&quot;);
    pr.println(376430645);
    // pr.close();//因为使用了自动刷新。
}</code></pre><p>}</p>
<h2 id="3、格式化输出"><a href="#3、格式化输出" class="headerlink" title="3、格式化输出"></a>3、格式化输出</h2><p>Java5后，PrintStream类多了printf()方法用于格式化输出操作。但是格式化输出的时候必须指定输出数据的类型：</p>
<p>（构造方法）<br>PrintStream format(String fo, Object… args) 使用指定格式字符串和参数将格式化字符串写入此输出流中。 </p>
<p>备注：当然你也可以全部使用“%s”来表示所有的数据类型！<br>格式：<br>需要格式 % 占位符</p>
<p>Eg：<br>package july7file;</p>
<p>import java.io.FileWriter;<br>import java.io.PrintStream;<br>import java.io.PrintWriter;</p>
<p>public class Demo9 {<br>    public static void main(String[] args) throws Exception {</p>
<pre><code>    PrintStream ps = new PrintStream(&quot;E:/name.txt&quot;);

    ps.write(&quot;123456&quot;.getBytes());

    ps.println(false);
    ps.print(false);

    PrintWriter pw = new PrintWriter(new FileWriter(&quot;E:/name1.txt&quot;),true);

    pw.println(&quot;我们的未来！&quot;);//write不可以

    pw = new PrintWriter(System.out,true);
    pw.println(&quot;我们的未来！&quot;);//打印在控制台上

    String name = &quot;刘昭&quot;;
    int age = 13;
    char score = &apos;A&apos;;

    String format = &quot;姓名=%s,年龄=%d,成绩=%c&quot;;

    System.out.printf(format,name,age,score);

    int i = System.in.read();//流的重定向
    System.out.println((char)i);
}</code></pre><p>}</p>
<h2 id="4、标准流"><a href="#4、标准流" class="headerlink" title="4、标准流"></a>4、标准流</h2><pre><code>标准输入流:  System.in   默认表示的是键盘录入
标准输出流:  System.out  默认表示的是屏幕输出</code></pre><p>Eg：<br>package june6D;</p>
<p>import java.io.FileInputStream;<br>import java.io.IOException;<br>import java.io.PrintStream;</p>
<p>public class SyetemDemo {<br>    public static void main(String[] args) throws IOException {<br>        /**<br>         *  标准流: 标准输入流: System.in 默认表示的是键盘录入<br>标准输出流: System.out 默认表示的是屏幕输出<br>         *<br>         * 若现在我输出不想打印在屏幕上,怎么办?<br>         * 若现在我不想通过键盘来录入数据,有怎么办?<br>         *<br>         * 流的重定向: static void setOut(PrintStream out) 重新分配“标准”输出流。 static void<br>         * setIn(InputStream in) 重新分配“标准”输入流。<br>         */<br>        System.out.println(“123456789”);//最普通的打印<br>        System.err.println(“123652”);// 同样是一种输出流,打印出的是123652</p>
<pre><code>    /**
     * static void setOut(PrintStream out) 重新分配“标准”输出流。
     */

    // 输出流就被重新定义到了文件，而不是屏幕
    System.setOut(new PrintStream(&quot;68Demo.txt&quot;));// 只有在定义过后才生效，所以上面的还是会输出到控制台
    System.out.println(&quot;AAAA&quot;);
    System.out.println(&quot;BBBB&quot;);//就输出了在文件里

    int i = System.in.read();// 接受从键盘输入的数据，写在最前面（没有任何重新分配）才有效
    System.out.println(&quot;i所对应的是：&quot; + (char) i);// 把它转换为字符型
    System.out.println(i);
    /**
     * 重新分配，由标准键盘输入变为由文件输入
     */
    System.setIn(new FileInputStream(&quot;copy6.4&quot;));//备注：打印的是文件copy6.4中的数据，而且打印在文件68Demo.txt中。
    byte[] buff = new byte[1024];
    int len = 0;
    while ((len = System.in.read(buff)) != -1) {
        System.out.println(new String(buff, 0, len));// 此时不会打印在控制台上，因为上面已经重新定义了由打印到屏幕上转换为打印到文件里
    }
}</code></pre><p>}</p>
<h2 id="5、Scanner-简单文本扫描器"><a href="#5、Scanner-简单文本扫描器" class="headerlink" title="5、Scanner(简单文本扫描器)"></a>5、Scanner(简单文本扫描器)</h2><p>Scanner(File source)  构造一个新的 Scanner，它生成的值是从指定文件扫描的。<br>备注：实现了Iterable接口</p>
<p>package june6D;</p>
<p>import java.io.File;<br>import java.io.PrintStream;<br>import java.util.Scanner;</p>
<p>public class ScannerDemo18 {<br>    public static void main(String[] args) throws Exception {</p>
<pre><code>    // 参照api
    Scanner sc = new Scanner(System.in);// 从键盘输入
    // int i = System.in.read();
    /*  连着进行了三次，没有完成的话不停止运行
        System.out.println(sc.next());                                                                                                                                       System.out.println(sc.next());
     *  System.out.println(sc.next());
     */
    System.setOut(new PrintStream(&quot;Scanner.txt&quot;));// 流的重定向（打印到哪里）
    sc = new Scanner(new File(&quot;copy6.4&quot;));// 扫描位置
    int line = 1;
    while (sc.hasNextLine()) {// 是否有下一行 //一行一行的读取，这样的话格式好看
        System.out.println(line + &quot; &quot; + sc.nextLine());// 读取下一行
        line++;
    }
}</code></pre><p>}</p>
<p>例子：<br>猜数字游戏：</p>
<ol>
<li>系统随机生成一个数字[1,100]; </li>
<li>从键盘录入一个数字,[1,100] </li>
<li>判断输入的数字和随机数比较:<br>随机数 &gt; 输入数:你输入太小了<br>随机数 &lt; 输入数:输入太大了<br>随机数 = 输入数: 恭喜哦</li>
</ol>
<p>思考：先想怎么生成一个随机数；然后怎么在键盘中录入一个随机数，第三步就是比较了；但是注意的是：需要确保输入的数据为数字，而且有范围的限制！</p>
<p>package july7file;</p>
<p>import java.util.Random;<br>import java.util.Scanner;</p>
<p>public class Demo12 {<br>    public static void main(String[] args) {</p>
<pre><code>    guess();
}

public static void guess(){
    int i = new Random().nextInt(100)+1;

    System.out.println(i);
    System.out.println(&quot;请输入随机数来匹配，您有五次机会！&quot;);
    Scanner sc = new Scanner(System.in);//键盘录入

    for (int j = 0; j &lt; 5; j++) {
        String s = sc.nextLine();

        if(!s.matches(&quot;\\d+&quot;)){
            System.out.println(&quot;请确认您输入的是数字&quot;);
            break;
        }
        Integer in = new Integer(s);
        if(in &gt; 100 | in &lt; 0){
            System.out.println(&quot;请确认您输入的数字在0到100之间！&quot;);
        }

        switch (in.compareTo(i)) {
        case 1:
            System.out.println(&quot;您输入的数字过大！&quot;);
            System.out.println(&quot;请输入:&quot;);
            break;

        case -1:
            System.out.println(&quot;您输入的数字过小！&quot;);
            System.out.println(&quot;请输入:&quot;);
            break;

        default:
            System.out.println(&quot;恭喜您，您输入的数字正好匹配！&quot;);
            return;
        }
    }
}</code></pre><p>}</p>
<h2 id="6、缓冲流"><a href="#6、缓冲流" class="headerlink" title="6、缓冲流"></a>6、缓冲流</h2><p>缓冲流要“套接”在相应的节点流之上，对读写的数据提供了缓冲的功能，提高了读写效率，同时增加了一些新的方法。<br>四种缓冲流<br>BufferedReader(Reader in)<br>BufferedReader(Reader in,int sz)//sz表示自定义缓冲区大小<br>BufferedWriter(Writer out)<br>BufferedWriter(Writer out,int sz)<br>BufferedInputStream(InputStream in)<br>BufferedInputStream(InputStream in,int sz)<br>BufferedOutputStream(OutputStream out)<br>BufferedOutputStream(OutputStream out,int sz)</p>
<p>BufferedReader提供readLine方法用于读取一行字符串。<br>BufferedWriter提供了newLine方法用于写入一个行分隔符。等价于//.writer(“\r\n”);<br>对于输出的缓冲流，写出的数据会先在内存中缓冲，使用flush方法将会使内存中的数据立刻写出。</p>
<p>Eg：<br>package june6D;</p>
<p>import java.io.BufferedReader;<br>import java.io.BufferedWriter;<br>import java.io.FileReader;<br>import java.io.FileWriter;<br>import java.io.IOException;</p>
<p>//用缓冲流，性能相对高些<br>public class BufferedInputStreamDemo22 {<br>    public static void main(String[] args) throws IOException {<br>        /*<br>         * BufferedInputStream bis = new BufferedInputStream(new<br>         * FileInputStream(“68.txt”)); BufferedOutputStream bos = new<br>         * BufferedOutputStream(new FileOutputStream(“buffer.txt”));<br>         *<br>         * int len = 0;<br>         * while((len = bis.read()) != -1){<br>         * bos.write(len);<br>         * }<br>         * bos.close();<br>         * bis.close();<br>         */</p>
<pre><code>try (</code></pre><p>BufferedReader br = new BufferedReader(new FileReader(“68.txt”));<br>    BufferedWriter bw = new BufferedWriter(new FileWriter(<br>                        “bufferWriter.txt”)))<br>{//java7新特性，自动关闭资源<br>            String Line = null;<br>            while ((Line = br.readLine()) != null) {<br>                bw.write(Line);<br>                bw.newLine();//此时必须加上换行操作，注意这是个新用法（方法）<br>            }<br>        } catch (Exception e) {<br>            e.printStackTrace();<br>        }<br>    }<br>}</p>
<p>我的总结：在后续的学习中，缓冲流用到的会很多，因为效率高！</p>
<h2 id="7、合并流（SequenceInputStream）"><a href="#7、合并流（SequenceInputStream）" class="headerlink" title="7、合并流（SequenceInputStream）"></a>7、合并流（SequenceInputStream）</h2><p>需要两个源文件，还有输出的目标文件</p>
<p>SequenceInputStream：<br>将两个文件的内容合并成一个文件<br>该类提供的方法：<br>SequenceInputStream(InputStream s1, InputStream s2) ：根据两个字节输入流对象来创建合并流对象。</p>
<p>备注：谁放在前面，谁就先打印出来</p>
<p>Eg：<br>package june6D;</p>
<p>import java.io.FileInputStream;<br>import java.io.FileOutputStream;<br>import java.io.IOException;<br>import java.io.OutputStream;<br>import java.io.SequenceInputStream;</p>
<p>//和并两个文件的合并流<br>public class SequenceInputStreamDemo24 {<br>    public static void main(String[] args) throws IOException {</p>
<pre><code>    SequenceInputStream si = new SequenceInputStream(
            new FileInputStream(&quot;6.4&quot;),
            new FileInputStream(&quot;hello.java&quot;));

    OutputStream os = new FileOutputStream(&quot;sequence.txt&quot;);
    int len;
    byte []b = new byte[1024];
    while((len = si.read(b)) != -1){
        os.write(b, 0, len);
    }
}</code></pre><p>}</p>
<h1 id="十一、网络编程"><a href="#十一、网络编程" class="headerlink" title="十一、网络编程"></a>十一、网络编程</h1><h2 id="1、什么是网络编程？"><a href="#1、什么是网络编程？" class="headerlink" title="1、什么是网络编程？"></a>1、什么是网络编程？</h2><p>网络编程的本质是两个设备之间的数据交换，当然，在计算机网络中，设备主要指计算机。数据传递本身没有多大的难度，不就是把一个设备中的数据发送给两外一个设备，然后接受另外一个设备反馈的数据。现在的网络编程基本上都是基于请求/响应方式的，也就是一个设备发送请求数据给另外一个，然后接收另一个设备的反馈。在网络编程中，发起连接程序，也就是发送第一次请求的程序，被称作客户端(Client)，等待其他程序连接的程序被称作服务器(Server)。客户端程序可以在需要的时候启动，而服务器为了能够时刻相应连接，则需要一直启动。<br>例如以打电话为例，首先拨号的人类似于客户端，接听电话的人必须保持电话畅通类似于服务器。连接一旦建立以后，就客户端和服务器端就可以进行数据传递了，而且两者的身份是等价的。在一些程序中，程序既有客户端功能也有服务器端功能，最常见的软件就是BT、emule 这类软件了。</p>
<p>网络模型<br>OSI参考模型<br>TCP/IP参考模型</p>
<h2 id="2、网络通讯要素"><a href="#2、网络通讯要素" class="headerlink" title="2、网络通讯要素"></a>2、网络通讯要素</h2><p>IP地址<br>端口号<br>传输协议</p>
<p>IP地址:InetAddress<br>网络中设备的标识<br>不易记忆，可用主机名<br>本地回环地址：127.0.0.1  主机名：localhost<br>端口号<br>用于标识进程的逻辑地址，不同进程的标识<br>有效端口：0<del>65535，其中0</del>1024系统使用或保留端口。<br>备注：不是所谓的物理端口！<br>传输协议<br>通讯的规则<br>常见协议：TCP，UDP</p>
<h2 id="3、TCP和UDP的联系和用途"><a href="#3、TCP和UDP的联系和用途" class="headerlink" title="3、TCP和UDP的联系和用途"></a>3、TCP和UDP的联系和用途</h2><p>一.区别<br>    二者都是有用的和常用的，如果纯粹从概念上区分二者就比较费解了，我们直接从功能上进行区分，简单明了：<br>    这两种传输协议也就是合于适配不同的业务和不同的硬件终端。<br>    在使用中，类似于图像、声音等对可靠性要求没有那么高的业务可以用UDP，他们不需要准确存储对准确性无要求但要求速度快。<br>    类似于文本、程序、文件等要求可靠的数据最好就用TCP，但会牺牲一些速度。<br>    对系统资源的要求：CP较多，UDP少。<br>    程序结构：UDP程序结构较简单，TCP复杂。<br>    流模式与数据报模式:TCP保证数据正确性，UDP可能丢包; TCP保证数据顺序，UDP不保证</p>
<p>二.用途<br>    TCP是面向连接的，有比较高的可靠性，一些要求比较高的服务一般使用这个协议，如FTP、Telnet、SMTP、HTTP、POP3等，而 UDP是面向无连接的，使用这个协议的常见服务有DNS、SNMP、QQ等。对于QQ必须另外说明一下，QQ2003以前是只使用UDP协议的，其服务器 使用8000端口，侦听是否有信息传来，客户端使用4000端口，向外发送信息（这也就不难理解在一般的显IP的QQ版本中显示好友的IP地址信息中端口 常为4000或其后续端口的原因了），即QQ程序既接受服务又提供服务，在以后的QQ版本中也支持使用TCP协议了。<br>    Udp是一种面向无连接的通信协议，该协议使得数据传输的速度得到大幅度的提高。视频聊天语音聊天基本都是用UPD协议。 </p>
<p>我的总结：<br>一、UDP:<br>                1、将数据源和目的地封装到数据包中，不需要建立连接<br>                2、每个数据包的大小限制在64k以内<br>                3、因无连接，是不可靠协议<br>                4、不需要建立连接，速度快</p>
<p>例子：聊天、对讲机就是UDP的，面向无连接（不管在不在，知不知道，只管发送，求速度），丢数据也不管。速度快。数据被分成包</p>
<p>二、TCP:<br>                1、建立连接，形成传输数据的通道<br>                2、在连接中进行大量数据的传输<br>                3、通过三次握手完成连接、是可靠协议<br>                4、必须建立连接，效率会稍低</p>
<p>例子：电话通话，必须连接，对方同意才可以发送数据（不然就等待），不能丢失数据。</p>
<h2 id="4、InetAddress与Socket"><a href="#4、InetAddress与Socket" class="headerlink" title="4、InetAddress与Socket"></a>4、InetAddress与Socket</h2><p>InetAddress：构造方法私有，不能直接创建对象。<br>InetAddress getByName(String host):在给定主机名的情况下确定主机的ip地址。<br>InetAddress getLocalHost()：返回本地主机。<br>InetAddress[] getAllByName(String host)<br>ip.getHostAddress(),<br>ip.getHostName()</p>
<p>Eg：<br>package july76net;</p>
<p>import java.net.InetAddress;</p>
<p>public class Demo1 {<br>    public static void main(String[] args) throws Exception {</p>
<pre><code>    InetAddress i = InetAddress.getLocalHost();
    System.out.println(i);

    i = InetAddress.getByName(&quot;www.baidu.com&quot;);
    System.out.println(i);
    System.out.println(i.getHostAddress());

    System.out.println(i.getHostName());
}</code></pre><p>}</p>
<p>输出：<br>XP-201304252326/10.6.147.2<br><a href="http://www.baidu.com/61.135.169.105" target="_blank" rel="noopener">www.baidu.com/61.135.169.105</a><br>61.135.169.105<br><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p>
<p>Socket<br>Socket就是为网络服务提供的一种机制。<br>通信的两端都有Socket。<br>网络通信其实就是Socket间的通信。<br>数据在两个Socket间通过IO传输。</p>
<h2 id="5、UDP传输"><a href="#5、UDP传输" class="headerlink" title="5、UDP传输"></a>5、UDP传输</h2><p>①：只要是网络传输，必须有socket 。<br>②：数据一定要封装到数据包中，数据包中包括目的地址、端口、数据等信息。</p>
<p>直接操作udp不可能，对于java语言应该将udp封装成对象，易于我们的使用，这个对象就是DatagramSocket. 封装了udp传输协议的socket对象。</p>
<p>因为数据包中包含的信息较多，为了操作这些信息方便，也一样会将其封装成对象。这个数据包对象就是：DatagramPacket.通过这个对象中的方法，就可以获取到数据包中的各种信息。</p>
<p>DatagramSocket具备发送和接受功能，在进行udp传输时，需要明确一个是发送端，一个是接收端。</p>
<p>udp的发送端：<br>①：建立udp的socket服务，创建对象时如果没有明确端口，系统会自动分配一个未被使用的端口。<br>②：明确要发送的具体数据。<br>③：将数据封装成了数据包。<br>④：用socket服务的send方法将数据包发送出去。<br>⑤：关闭资源。</p>
<p>udp的接收端：<br>①：创建udp的socket服务，必须要明确一个端口，作用在于，只有发送到这个端口的数据才是这个接收端可以处理的数据。<br>②：定义数据包，用于存储接收到数据。<br>③：通过socket服务的接收方法将收到的数据存储到数据包中。<br>④：通过数据包的方法获取数据包中的具体数据内容，比如ip、端口、数据等等。<br>⑤：关闭资源。</p>
<p>Eg：<br>发送端（客户端）<br>import java.net.*;<br>class  UdpSend{<br>        public static void main(String[] args)throws Exception {<br>                // 1，建立udp的socket服务。<br>                DatagramSocket ds = new DatagramSocket(8888);//指定发送端口，这个可以不指定，系统会随机分配。<br>                // 2，明确要发送的具体数据。<br>                String text = “udp传输演示 哥们来了”;<br>                byte[] buf = text.getBytes();<br>                // 3，将数据封装成了数据包。<br>                DatagramPacket dp = new DatagramPacket(buf,buf.length,InetAddress.getByName(“10.1.31.127”),10000);<br>                // 4，用socket服务的send方法将数据包发送出去。<br>                ds.send(dp);<br>                // 5，关闭资源。<br>                ds.close();<br>        }<br>}</p>
<p>接收端（服务器端）</p>
<p>import java.net.*;<br>class UdpRece {<br>        public static void main(String[] args) throws Exception{<br>                // 1，创建udp的socket服务。<br>                DatagramSocket ds = new DatagramSocket(10000);//必须指定，并且和上面的端口号一样！<br>                // 2，定义数据包，用于存储接收到数据。先定义字节数组，数据包会把数据存储到字节数组中。<br>                byte[] buf = new byte[1024];<br>                DatagramPacket dp = new DatagramPacket(buf,buf.length);<br>                // 3，通过socket服务的接收方法将收到的数据存储到数据包中。<br>                ds.receive(dp);//该方法是阻塞式方法。<br>                // 4，通过数据包的方法获取数据包中的具体数据内容，比如ip，端口，数据等等。<br>                String ip = dp.getAddress().getHostAddress();<br>                int port = dp.getPort();<br>                String text = new String(dp.getData(),0,dp.getLength());//将字节数组中的有效部分转成字符串。<br>                System.out.println(ip+”:”+port+”–”+text);<br>                // 5，关闭资源。<br>                ds.close();<br>        }<br>}</p>
<p>练习：<br>通过键盘录入获取要发送的信息。<br>将发送和接收分别封装到两个线程中。</p>
<p>package july76net;<br>//一个聊天的例子，利用UDP传输协议</p>
<p>import java.io.BufferedReader;<br>import java.io.IOException;<br>import java.io.InputStreamReader;<br>import java.net.DatagramPacket;<br>import java.net.DatagramSocket;<br>import java.net.InetAddress;</p>
<p>//客户端，发送端<br>class Send implements Runnable {<br>    private DatagramSocket ds;</p>
<pre><code>public Send(DatagramSocket ds) {
    super();
    this.ds = ds;
}

@Override
public void run() {
    try {
        BufferedReader br = new BufferedReader(new InputStreamReader(
                System.in));//数据源是键盘录入
        String line;
        while ((line = br.readLine()) != null) {
            byte[] buf = line.getBytes();
            DatagramPacket dp = new DatagramPacket(buf, buf.length,
                    InetAddress.getByName(&quot;localhost&quot;), 10225);

            ds.send(dp);
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
}</code></pre><p>}</p>
<p>// 服务器端，接收端<br>class Rece implements Runnable {<br>    private DatagramSocket ds;</p>
<pre><code>public Rece(DatagramSocket ds) {
    super();
    this.ds = ds;
}

@Override
public void run() {
    try {
        while (true) {
            byte[] buf = new byte[1024];

            DatagramPacket dp = new DatagramPacket(buf, 0, buf.length);
            ds.receive(dp);

            String ip = dp.getAddress().getHostAddress();
            String data = new String(dp.getData(), 0, dp.getLength());

            System.out.println(ip + &quot;     &quot; + data);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}</code></pre><p>}</p>
<p>public class Demo6 {<br>    public static void main(String[] args) throws Exception {<br>        DatagramSocket sendDs = new DatagramSocket();<br>        DatagramSocket receDs = new DatagramSocket(10225);<br>        new Thread(new Send(sendDs)).start();<br>        new Thread(new Rece(receDs)).start();<br>    }<br>}</p>
<p>输出：<br>你好<br>127.0.0.1     你好<br>你好<br>127.0.0.1     你好</p>
<h2 id="6、TCP传输"><a href="#6、TCP传输" class="headerlink" title="6、TCP传输"></a>6、TCP传输</h2><p>两个端点的建立连接后会有一个传输数据的通道，这通道称为流，而且是建立在网络基础上的流，称之为socket流。该流中既有读取，也有写入。</p>
<p>tcp的两个端点：一个是客户端，一个是服务端。<br>客户端：对应的对象，Socket<br>服务端：对应的对象，ServerSocket</p>
<p>TCP客户端：<br>①：建立tcp的socket服务，最好明确具体的地址和端口。这个对象在创建时，就已经可以对指定ip和端口进行连接(三次握手)。<br>②：如果连接成功，就意味着通道建立了，socket流就已经产生了。只要获取到socket流中的读取流和写入流即可，只要通过getInputStream和getOutputStream就可以获取两个流对象。<br>③：关闭资源。</p>
<p>import java.net.<em>;<br>import java.io.</em>;<br>//需求：客户端给服务器端发送一个数据。<br>class  TcpClient{<br>        public static void main(String[] args) throws Exception{<br>                Socket s = new Socket(“10.1.31.69”,10002);<br>                OutputStream out = s.getOutputStream();//获取了socket流中的输出流对象。<br>                out.write(“tcp演示，哥们又来了!”.getBytes());<br>                s.close();<br>}<br>}</p>
<p>TCP服务端：<br>①：创建服务端socket服务，并监听一个端口。<br>②：服务端为了给客户端提供服务，获取客户端的内容，可以通过accept方法获取连接过来的客户端对象。<br>③：可以通过获取到的socket对象中的socket流和具体的客户端进行通讯。<br>④：如果通讯结束，关闭资源。注意：要先关客户端，再关服务端。</p>
<p>我的总结：对于UDP和TCP，既可以定义输出流也可以创建输入流，具体情况根据需要构建；比如：我们需要客户端给服务器端发送数据，服务器端再给客户端反馈数据；那么就要在客户端和服务器端分别多加一个输入流和输出流！否则，发不出去，收不到！</p>
<p>class  TcpServer{<br>        public static void main(String[] args) throws Exception{<br>                ServerSocket ss = new ServerSocket(10002);//建立服务端的socket服务<br>                Socket s = ss.accept();//获取客户端对象<br>                String ip = s.getInetAddress().getHostAddress();<br>                System.out.println(ip+”…..connected”);//打印下作为连接上的标志</p>
<pre><code>        // 可以通过获取到的socket对象中的socket流和具体的客户端进行通讯。
        InputStream in = s.getInputStream();//读取客户端的数据，使用客户端对象的socket读取流
        byte[] buf = new byte[1024];
        int len = in.read(buf);
        String text = new String(buf,0,len);
        System.out.println(text);
        // 如果通讯结束，关闭资源。注意：要先关客户端，在关服务端。
        s.close();
        ss.close();
}</code></pre><p>}</p>
<p>备注:这个例子只是单方面的输入！</p>
<p>Eg：双向对话</p>
<p>客户端:<br>package july76net;<br>//TCP双向对话</p>
<p>import java.io.InputStream;<br>import java.io.OutputStream;<br>import java.net.Socket;</p>
<p>public class Demo10 {<br>    public static void main(String[] args) throws Exception {<br>        Socket s = new Socket(“localhost”,10036);</p>
<pre><code>    OutputStream out = s.getOutputStream();

    out.write(&quot;你好，服务器！我是刘昭！&quot;.getBytes());
    s.shutdownOutput();//注意！！！关闭标签
    InputStream is = s.getInputStream();
    byte []buf = new byte[1024];
    int len = is.read(buf);
        System.out.println(new String(buf,0,len));
    s.close();
}</code></pre><p>}</p>
<p>服务器端</p>
<p>package july76net;<br>//TCP双向输入输出</p>
<p>import java.io.InputStream;<br>import java.io.OutputStream;<br>import java.net.ServerSocket;<br>import java.net.Socket;</p>
<p>public class Demo11 {<br>    public static void main(String[] args) throws Exception {<br>        ServerSocket ss = new ServerSocket(10036);<br>        Socket s = ss.accept();</p>
<pre><code>    String ip = s.getInetAddress().getHostAddress();
    System.out.println(ip+&quot;..........connected!&quot;);

    InputStream in = s.getInputStream();
    byte[] buf = new byte[1024];
    /*int len = in.read(buf);
    System.out.println(new String(buf,0,len));*/
    int len;
    while((len = in.read(buf)) != -1){
        System.out.println(new String(buf,0,len));
    }
    OutputStream os = s.getOutputStream();

    os.write(&quot;刘昭你好！我是服务器！&quot;.getBytes());

    s.close();
    ss.close();
}</code></pre><p>}</p>
<h2 id="7、利用TCP上传文件"><a href="#7、利用TCP上传文件" class="headerlink" title="7、利用TCP上传文件"></a>7、利用TCP上传文件</h2><p>从客户端上传到服务器端，其实本质上也就是复制！</p>
<p>package july76net;<br>//上传文件(文本)</p>
<p>import java.io.BufferedReader;<br>import java.io.FileReader;<br>import java.io.InputStreamReader;<br>import java.io.PrintWriter;<br>import java.net.Socket;</p>
<p>public class Demo14 {<br>    public static void main(String[] args) throws Exception {<br>        Socket s = new Socket(“localhost”,12362);</p>
<pre><code>    BufferedReader br  = new BufferedReader(new FileReader(&quot;E:/你好.txt&quot;));
    PrintWriter pw = new PrintWriter(s.getOutputStream(),true);
    String line;
    while((line = br.readLine()) != null){
        pw.println(line);
    }
    s.shutdownOutput();//阻塞式方法的应对，否则会一直等待！

    BufferedReader br2 = new BufferedReader(new InputStreamReader(s.getInputStream()));
    String str = br2.readLine();//服务器端反馈的数据
    System.out.println(str);

    br.close();
    s.close();
}</code></pre><p>}</p>
<p>服务器端<br>package july76net;</p>
<p>import java.io.BufferedReader;<br>import java.io.FileWriter;<br>import java.io.InputStreamReader;<br>import java.io.PrintWriter;<br>import java.net.ServerSocket;<br>import java.net.Socket;</p>
<p>public class Demo15 {<br>    public static void main(String[] args) throws Exception {<br>        ServerSocket ss = new ServerSocket(12362);<br>        Socket s = ss.accept();</p>
<pre><code>    String ip = s.getInetAddress().getHostAddress();
    System.out.println(ip+&quot;.....connected!&quot;);

    BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));
    PrintWriter pw = new PrintWriter(new FileWriter(&quot;E:/你好2.txt&quot;),true);//建议打印时都用打印流
    String line;
    while((line = br.readLine()) != null){
        pw.println(line);//不可以写成是write();
    }

    PrintWriter out = new PrintWriter(s.getOutputStream(),true);
    out.println(&quot;上传成功！&quot;);
    s.close();
    ss.close();
}</code></pre><p>}</p>
<p>上传图片（注意图片是2进制文件，必须是字节流，否则读取不出来！）；</p>
<p>客户端<br>package july76net;</p>
<p>import java.io.FileInputStream;<br>import java.io.InputStream;<br>import java.io.OutputStream;<br>import java.net.Socket;</p>
<p>public class Demo16 {<br>    public static void main(String[] args) throws Exception {<br>        Socket s = new Socket(“localhost”,10256);<br>        FileInputStream fis = new FileInputStream(“E:/DSC_2451.jpg”); </p>
<pre><code>    OutputStream os = s.getOutputStream();

    byte []buf = new byte[1024];
    int len;
    while((len = fis.read(buf)) != -1){
        os.write(buf);
    }
    s.shutdownOutput();
    InputStream in = s.getInputStream();
    byte []b = new byte[1024];
    int i = in.read(b);
    System.out.println(new String(b,0,i));
    fis.close();
    s.close();
}</code></pre><p>}    </p>
<p>服务器端<br>package july76net;</p>
<p>import java.io.FileOutputStream;<br>import java.io.InputStream;<br>import java.io.OutputStream;<br>import java.net.ServerSocket;<br>import java.net.Socket;</p>
<p>public class Demo17 {<br>    public static void main(String[] args) throws Exception {</p>
<pre><code>    ServerSocket ss = new ServerSocket(10256);
    Socket s = ss.accept();

    String ip = s.getInetAddress().getHostAddress();
    System.out.println(ip+&quot;.........connected&quot;);

    InputStream is = s.getInputStream();
    FileOutputStream fos = new FileOutputStream(&quot;E:/我的照片0.jpg&quot;);

    byte []b = new byte[1024];
    int len;
    while((len = is.read(b)) != -1){
        fos.write(b);
    }

    OutputStream os = s.getOutputStream();
    os.write(&quot;上传成功！&quot;.getBytes());

    s.close();
    ss.close();
}</code></pre><p>}</p>
<p>我的总结：<br>对于网络编程而言，重要的是理解其步骤，按照步骤的需要，一步步搭建根基！<br>客户端和服务端需要交互，那么就要构建相对应的流，供其输入和输出！<br>对于阻塞式方法，一定要注意，提供停止标签！<br>对于PrintWriter ,记得用println而不是write;不要忘了加上true，自动刷新！</p>
<p>8、小例子</p>
<p>题目：上传文件，多客户端上传，并且保证不会因为文件的名称而重复！</p>
<p>客户端：<br>package july76net;</p>
<p>import java.io.BufferedReader;<br>import java.io.FileReader;<br>import java.io.InputStreamReader;<br>import java.io.PrintWriter;<br>import java.net.Socket;</p>
<p>public class Demo22 {<br>    public static void main(String[] args) throws Exception {<br>        Socket s = new Socket(“localhost”, 12036);</p>
<pre><code>BufferedReader br = new BufferedReader(new FileReader(&quot;E:/你好.txt&quot;));
PrintWriter pw = new PrintWriter(s.getOutputStream(),true);

BufferedReader br2 = new BufferedReader(new InputStreamReader(s.getInputStream()));</code></pre><p>​<br>​        String line;<br>​        while((line = br.readLine()) != null){<br>​            pw.println(line);<br>​        }<br>​        s.shutdownOutput();<br>​<br>​        String str = br2.readLine();<br>​        System.out.println(str);<br>​        s.close();<br>​    }<br>}</p>
<p>服务器端：<br>package july76net;</p>
<p>import java.io.BufferedReader;<br>import java.io.File;<br>import java.io.FileWriter;<br>import java.io.InputStreamReader;<br>import java.io.PrintWriter;<br>import java.net.ServerSocket;<br>import java.net.Socket;</p>
<p>class MyUpdate implements Runnable{<br>    private Socket s;</p>
<pre><code>public MyUpdate(Socket s) {
    super();
    this.s = s;
}

@Override
public void run() {

    String ip = s.getInetAddress().getHostAddress();
    System.out.println(ip+&quot;.........connected!&quot;);
    int count = 0;
    try {
        BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));
        File file = new File(&quot;E:/&quot;);
        File f = new File(file,&quot;你好&quot;+count+&quot;.txt&quot;);
        while(f.exists()){//如果写成if，就不可以！
            f = new File(file,&quot;你好&quot;+(++count)+&quot;.txt&quot;); 
        }
        PrintWriter pw = new PrintWriter(new FileWriter(f),true);
        PrintWriter pw2 = new PrintWriter(s.getOutputStream(),true);

        String line;
        while((line = br.readLine()) != null){
            pw.println(line);
        }

        pw2.println(&quot;恭喜您，上传成功！&quot;);
        s.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
}</code></pre><p>}</p>
<p>public class Demo23 {<br>    public static void main(String[] args) throws Exception {</p>
<pre><code>    ServerSocket ss = new ServerSocket(12036);
    while(true){
        Socket s = ss.accept();
        new Thread(new MyUpdate(s)).start();
    }
}</code></pre><p>}</p>
<h1 id="十二、反射机制"><a href="#十二、反射机制" class="headerlink" title="十二、反射机制"></a>十二、反射机制</h1><h2 id="1、反射的概念"><a href="#1、反射的概念" class="headerlink" title="1、反射的概念"></a>1、反射的概念</h2><p>反射的引入：<br>Object obj = new Student();<br>        若程序运行时接收到外部传入的一个对象，该对象的编译类型是Object，但程序又需要调用该对象运行类型的方法：<br>        1.若编译和运行类型都知道，使用 instanceof判断后，强转。<br>        2.编译时根本无法预知该对象属于什么类，程序只能依靠运行时信息来发现对象的真实信息，这时就必须使用反射了。<br>        3.要是想得到对象真正的类型，就得使用反射。</p>
<p>什么是反射机制？<br>        简单的来说，反射机制指的是程序在运行时能够获取自身的信息。在java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息。</p>
<p>反射机制的优点与缺点：<br>        为什么要用反射机制？直接创建对象不就可以了吗，这就涉及到了动态与静态的概念，<br>        静态编译：在编译时确定类型，绑定对象,即通过。<br>        动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了java的灵活性，体现了多态的应用，有以降低类之间的藕合性。<br>        一句话，反射机制的优点就是可以实现动态创建对象和编译，体现出很大的灵活性，特别是在J2EE的开发。<br>它的缺点是对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于只直接执行相同的操作。</p>
<p>Class类和Class类实例</p>
<p>Java程序中的各个Java类属于同一类事物,描述这类事物的Java类就是Class类。<br>对比提问：众多的人用一个什么类表示？众多的Java类用一个什么类表示？<br>人  Person<br>Java类  Class<br>对比提问： Person类代表人，它的实例对象就是张三，李四这样一个个具体的人，Class类代表Java类，它的各个实例对象又分别对应什么呢？<br>对应各个类在内存中的字节码，例如，Person类的字节码，ArrayList类的字节码，等等；<br>一个类被类加载器加载到内存中，占用一片存储空间，这个空间里面的内容就是类的字节码，不同的类的字节码是不同的，所以它们在内存中的内容是不同的；</p>
<p>用类来描述对象，类：描述数据的结构<br>用元数据来描述Class，MetaData(元数据):描述数据结构的结构;<br>反射就是得到元数据的行为; </p>
<p>备注：一个类在虚拟机中只有一份字节码；</p>
<h2 id="2、获得Class对象"><a href="#2、获得Class对象" class="headerlink" title="2、获得Class对象"></a>2、获得Class对象</h2><p>如何得到各个字节码对应的实例对象？<br>每个类被加载后，系统会为该类生成对应的Class对象，通过Class对象可以访问到JVM中的这个类，<br>3种方式：<br>1、调用某个类的class属性获取Class对象，如Date.class会返回Date类对应的Class对象(其实就是得到一个类的一份字节码文件)；<br>2、使用Class类的forName(String className)静态方法，className表示全限定名；如String的全限定名:java.lang.String;<br>3、调用某个对象的getClass()方法。该方法属于Object类；<br>Class&lt;?&gt; clz = new Date().getClass();</p>
<p>Eg：<br>package junereflect624;</p>
<p>public class ClassDemo1 {<br>    public static void main(String[] args) throws Exception {<br>        //获得Class对象的方法（三种）<br>        //一：调用属性<br>        Class<String> c = String.class;<br>        System.out.println(c);//打印结果：class java.lang.String                    String.class就表示JVM中一份表示String类的字节码<br>        Class<String> c2 = String.class;<br>        System.out.println(c == c2);//true都是String类的字节码          一个类在虚拟机中只有一份字节码；</String></String></p>
<pre><code>    //二：使用forName()方法
    //Class cla = Class.forName(&quot;String&quot;);//ERROR,
    Class&lt;String&gt; cla =                                                             (Class&lt;String&gt;)Class.forName(&quot;java.lang.String&quot;);//必须用上全限定名，否则报错
    System.out.println(c == cla);//true

    //三：利用对象调用Object的getClass方法；
    Class c3 = new String().getClass();
    System.out.println(c == c3);//ture
}</code></pre><p>}</p>
<p>我的总结：获取Class对象最常用的是利用属性的方法！</p>
<h2 id="3、九个预定义Class对象"><a href="#3、九个预定义Class对象" class="headerlink" title="3、九个预定义Class对象"></a>3、九个预定义Class对象</h2><p>基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void通过class属性也表示为 Class 对象；<br>Class类中boolean isPrimitive() :判定指定的 Class 对象是否表示一个基本类型。<br>包装类和Void类的静态TYPE字段；<br>Integer.TYPE == int.class ;<br>Integer.class == int.class;<br> 数组类型的Class实例对象：<br>Class&lt;String[]&gt; clz = String[].class;<br>数组的Class对象如何比较是否相等? 数组的维数和数组的类型;<br>Class类中 boolean isArray() ：判定此 Class 对象是否表示一个数组类型。 </p>
<p>package junereflect624;</p>
<p>public class PreClassDemo2 {<br>    public static void main(String[] args) {</p>
<pre><code>    Class&lt;?&gt; in = int.class;
    System.out.println(in);//int
    Class&lt;?&gt; in2 = Integer.class;
    //包装类都有一个常量TYPE，用来表示其基本数据类型的字节码
    Class&lt;?&gt; in3 = Integer.TYPE;

    System.out.println(in2);//class java.lang.Integer
    System.out.println(in3);//int
    System.out.println(in3 == in);//true 包装类都有一个常量TYPE，用来表示其基本数据类型的字节码，所以这里会相等！
    System.out.println(in3 == in2);//false
    Class&lt;String[]&gt; s = String [].class;
    Class&lt;int[]&gt; i = int [].class;
    //System.out.println(i ==s);//编译根本就通过不了，一个是int，一个是String
}
//这两个自定义的方法是可以的，一个int，一个Integer//包装类与基本数据类型的字节码是不一样的
public void show(int i){}
public void show(Integer i){}</code></pre><p>}</p>
<h2 id="4、利用Class获取类的属性信息"><a href="#4、利用Class获取类的属性信息" class="headerlink" title="4、利用Class获取类的属性信息"></a>4、利用Class获取类的属性信息</h2><p>package junereflect624;</p>
<p>import java.lang.reflect.Modifier;</p>
<p>class A {<br>}<br>interface B{<br>}<br>interface C{<br>}</p>
<p>public class BaseDemo3 extends A implements B,C{</p>
<pre><code>//内部类
public class C{}
public interface D{}
public static void main(String[] args) {
    //类可以，接口也可以
    Class&lt;BaseDemo3&gt; c = BaseDemo3.class;
    System.out.println(c);//class junereflect624.BaseDemo3

    //得到包名
    System.out.println(c.getPackage());//package junereflect624

    //得到全限定名
    System.out.println(c.getName());//junereflect624.BaseDemo3

    //得到类的简称
    System.out.println(c.getSimpleName());//BaseDemo3

    //得到父类
    /**
     * Class&lt;? super T&gt; getSuperclass() 此处super表示下限
              返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class。 
     */
    System.out.println(c.getSuperclass().getSimpleName());//A,先获取父类，再获取父类的简称

    //得到接口
    System.out.println(c.getInterfaces());//[Ljava.lang.Class;@1b60280
    Class[] arr = c.getInterfaces();
    for (Class cla : arr) {
        System.out.println(cla);//interface junereflect624.B   interface junereflect624.C
    }

    //获得public修饰的类
    /**
     * Class&lt;?&gt;[] getClasses() 
                 返回一个包含某些 Class 对象的数组，这些对象表示属于此 Class 对象所表示的类的成员的所有公共类和接口。 （如果内部类前面没有加上public的话那么得不到！）
     */
    Class[] cl = c.getClasses();
    System.out.println(cl.length);//在内部类没有加上public修饰的时候长度为0，加上就是2(获取的是公共的)
    for (Class class1 : cl) {
        System.out.println(class1);
    }

    //获得修饰符
    int i = c.getModifiers();
    System.out.println(i);//常量值1表示public
    System.out.println(Modifier.toString(i));//直接打印出public
}</code></pre><p>}</p>
<h2 id="5、Class中得到构造方法Constructor、方法Method、字段Field"><a href="#5、Class中得到构造方法Constructor、方法Method、字段Field" class="headerlink" title="5、Class中得到构造方法Constructor、方法Method、字段Field"></a>5、Class中得到构造方法Constructor、方法Method、字段Field</h2><p>常用方法：<br>Constructor类用于描述类中的构造方法：<br>Constructor<T> getConstructor(Class<?>... parameterTypes) 
返回该Class对象表示类的指定的public构造方法; 
Constructor<?>[] getConstructors()<br>返回该Class对象表示类的所有public构造方法;<br>Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)
返回该Class对象表示类的指定的构造方法,和访问权限无关;
Constructor<?>[] getDeclaredConstructors()<br>返回该Class对象表示类的所有构造方法,和访问权限无关;</T></T></p>
<p>Method类用于描述类中的方法：<br>Method getMethod(String name, Class<?> ... parameterTypes) 
返回该Class对象表示类和其父类的指定的public方法; 
Method[] getMethods()：  
返回该Class对象表示类和其父类的所有public方法; 
Method getDeclaredMethod(String name, Class<?>… parameterTypes)<br>返回该Class对象表示类的指定的方法。和访问权限无关，但不包括继承的方法;<br>Method[] getDeclaredMethods(): 获得类所有的方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法;</p>
<p>Eg：<br>package junereflect624;</p>
<p>import java.lang.reflect.Constructor;</p>
<p>class Emp{<br>    private String name;<br>    private int age;<br>    private Emp() {<br>    }<br>    Emp(String name){<br>    }<br>    public Emp(String name,int age){<br>    }<br>}</p>
<p>public class ConstructorDemo4 {<br>    public static void main(String[] args) throws Exception {<br>        //得到所有的构造器（先得到类）<br>        Class<Emp> c = Emp.class;<br>        /**<br>         * Constructor&lt;?&gt;[] getConstructors()<br>                  返回一个包含某些 Constructor 对象的数组，这些对象反映此 Class 对象所表示的类的所有公共构造方法。<br>         <em>/<br>        Constructor[] con = c.getConstructors();//前面的修饰符必须是public才可以在这个方法下获取到<br>        for (Constructor cons : con) {<br>            System.out.println(“c.getConstructors()”+cons);//如果上面的某构造器public去掉，则显示不出<br>            /*</em>打印<br>                public junereflect624.Emp(java.lang.String,int)<br>             */<br>        }</Emp></p>
<pre><code>//得到指定的构造器,也是必须public
Constructor c1 = c.getConstructor(String.class,int.class);
System.out.println(c1);//public junereflect624.Emp(java.lang.String,int)</code></pre><p>System.out.println(“====================================”);<br>    //现在想获得不受public影响的,getDeclaredConstructors(),暴力反射</p>
<pre><code>con = c.getDeclaredConstructors();
for (Constructor cons : con) {</code></pre><p>System.out.println(“c.getDeclaredConstructors()==”+cons);//此时不受修饰符的影响<br>            /**打印<br>             *  public junereflect624.Emp()<br>                public junereflect624.Emp(java.lang.String)<br>                public junereflect624.Emp(java.lang.String,int)<br>             */<br>        }<br>    }<br>}</p>
<p>package junereflect624;</p>
<p>import java.lang.annotation.Annotation;<br>import java.lang.reflect.Field;<br>import java.lang.reflect.Method;</p>
<p>class AB{<br>    protected String name;<br>    protected String id;<br>}<br>@Deprecated<br>public class MethodDemo5 extends AB{<br>    void show(){}<br>    public void say(){}<br>    private int age;<br>    public char c;<br>    private boolean b;<br>    public static void main(String[] args) throws Exception {<br>        Class<MethodDemo5> c = MethodDemo5.class;<br>        //获取所有的（包含父类的方法）public修饰的方法<br>        Method[] m = c.getMethods();<br>        for (Method method : m) {<br>            System.out.println(method);<br>        }<br>        //总结：4个方法，获取全部，获取特定；不受修饰符影响的全部，不受修饰符影响的特定；（前两个都还是受限制的）</MethodDemo5></p>
<pre><code>    //获取指定的方法
    Method me = c.getMethod(&quot;main&quot;, String[].class);
    System.out.println(&quot;main &quot;+me);//main public static void junereflect624.MethodDemo5.main(java.lang.String[]) throws java.lang.Exception

    //访问所有方法，不受访问权限影响
    m = c.getDeclaredMethods();
    for (Method method : m) {
        System.out.println(&quot;不受影响的：&quot;+method);
    }

    me = c.getDeclaredMethod(&quot;show&quot;);
    System.out.println(me);//void junereflect624.MethodDemo.show()

    me = c.getMethod(&quot;toString&quot;);
    System.out.println(me);//public java.lang.String java.lang.Object.toString()

    /**
     * Method[] getDeclaredMethods() 
              返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，
              包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法,只可以对当前类有效
     */
    /*me = c.getDeclaredMethod(&quot;toString&quot;);//ERROR,c.getDeclaredMethod()不能得到继承的方法
    System.out.println(me);//public java.lang.String java.lang.Object.toString()
     */    
    //得到字段
    Field[] f = c.getFields();
    for (Field field : f) {//只得到了public的
        System.out.println(&quot;字段&quot;+field);
    }

    //特定字段
    Field fi = c.getField(&quot;c&quot;);//&quot;&quot;里面是名称
    System.out.println(fi);//public char junereflect624.MethodDemo.c

    //得到不受限定名限定的全部字段
    f = c.getDeclaredFields();
    for (Field field : f) {//得到不受修饰符限定的字段，但是只对当前类有效
        System.out.println(&quot;全部字段：&quot;+field);
        /**
         *  全部字段：private int junereflect624.MethodDemo.age
            全部字段：public char junereflect624.MethodDemo.c
            全部字段：private boolean junereflect624.MethodDemo.b
         */
    }
    //注释  Annotation
     Annotation[] a = c.getAnnotations();
     System.out.println(a.length);
     for (Annotation annotation : a) {
        System.out.println(annotation);
    }

     //特定注解
     Deprecated d = c.getAnnotation(Deprecated.class);
     System.out.println(d);
}</code></pre><p>}</p>
<p>获取当前对象的字段：<br>package july78javaEnhance;</p>
<p>import java.lang.reflect.Field;</p>
<p>class Stu{<br>    public String name;<br>    public String sex;<br>    public int age;</p>
<pre><code>public Stu(String name, String sex, int age) {
    super();
    this.name = name;
    this.sex = sex;
    this.age = age;
}</code></pre><p>}</p>
<p>public class ReflectDemo6 {<br>    public static void main(String[] args) throws Exception {<br>        Stu s = new Stu(“刘昭”, “男”, 12);</p>
<pre><code>Class&lt;Stu&gt; c = Stu.class;

Field f = c.getField(&quot;name&quot;);
System.out.println(f.get(s));////从哪个对象身上取！此时显示刘昭！</code></pre><p>//    修改对象的值<br>/**<br>Field f = c.getField(“name”);<br>        f.set(s,”章泽天”);<br>System.out.println(f.get(s));//从哪个对象身上取！//此时显示章泽天<br>*/<br>    }<br>}</p>
<p>我的总结：对于方法，字段，构造方法之类用类获取记住四个：获取全部，获取特定，暴力获取全部，暴力获取特定！</p>
<h2 id="6、利用反射创建对象"><a href="#6、利用反射创建对象" class="headerlink" title="6、利用反射创建对象"></a>6、利用反射创建对象</h2><p>创建对象：<br>1、使用Class对象的newInstance()方法创建该Class对象的实例，此时该Class对象必须要有无参数的构造方法。<br>2、使用Class对象获取指定的Constructor对象，再调用Constructor的newInstance（）方法创建对象类的实例，此时可以选择使用某个构造方法。如果这个构造方法被私有化起来，那么必须先申请访问，将可以访问设置为true；</p>
<p>Eg：<br>最简单的：<br>package junereflect624;</p>
<p>class User{<br>    /<em>private User(){//将默认的构造方法私有化的话就不可以再创建对象，两种方法都是这样<br>    }</em>/<br>    public String toString() {<br>        return “User对象创建成功！”;<br>    }<br>}</p>
<p>public class NewInstanceDemo6 {<br>    public static void main(String[] args) throws Exception {<br>        //传统方式创建对象<br>         System.out.println(new User());</p>
<pre><code>     //使用反射的方式
     Class&lt;User&gt; c = User.class;
     User u = c.newInstance();（直接newInstance的话必须保证默认的构造方法正常存在，也就是没有被私有化！这是前提条件）
     System.out.println(u);
}</code></pre><p>}</p>
<p>复杂点的：更强大的第二种：</p>
<p>使用指定构造方法来创建对象:<br>获取该类的Class对象。<br>利用Class对象的getConstructor()方法来获取指定的构造方法。<br>调用Constructor的newInstance()方法创建对象。</p>
<p>AccessibleObject对象的setAccessible(boolean flag)方法,当flag为true的时候，就会忽略访问权限(可访问私有的成员)。<br>其子类有Field, Method, Constructor;<br>若要访问对象private的成员？<br>在调用之前使用setAccessible(true),<br>    Xxx x = getDeclaredXxxx();//才能得到私有的类字段.</p>
<p>总结步骤：</p>
<ol>
<li>获取该类的Class对象。</li>
<li>利用Class对象的getConstructor()方法来获取指定的构造方法。</li>
<li>申请访问（设置为可访问）</li>
<li>调用Constructor（构造方法）的newInstance()方法创建对象。</li>
</ol>
<p>例子<br>package junereflect624;</p>
<p>import java.lang.reflect.Constructor;</p>
<p>class Per{<br>    private String name;<br>    private int age;<br>    private Per(){<br>    }<br>    private Per(String name){<br>    }<br>    public String toString() {<br>        return “对象！！！”;<br>    }<br>}</p>
<p>public class NewInstanceDemo7 {<br>    public static void main(String[] args) throws Exception {<br>        Class<Per> c = Per.class;<br>        //System.out.println(c.newInstance());;//证明利用无参的可以</Per></p>
<pre><code>    ////先获得需要被调用的构造器(private 修饰的构造方法)
    Constructor&lt;Per&gt; con = c.getDeclaredConstructor();//调用默认的，什么都不要写
    System.out.println(con);//private junereflect624.Per()
    /*con = c.getDeclaredConstructor(String.class);获取指定的构造方法
    System.out.println(con);//private junereflect624.Per(java.lang.String)*/        
    //现在只需要执行这个构造器，
    /**
     *  T newInstance(Object... initargs) 
             使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。 
     */

    //私有的成员是受保护的,不能直接访问
    //若要访问私有的成员,得先申请一下
    con.setAccessible(true);//允许访问
    Per p = con.newInstance();//成功，通过私有的受保护的构造方法创建了对象
    System.out.println(&quot;无参构造方法&quot;+p);

    con = c.getDeclaredConstructor(String.class);
    System.out.println(con);//private junereflect624.Per(java.lang.String)

    con.setAccessible(true);//允许访问
    p = con.newInstance(&quot;liuzhao&quot;);//成功，通过私有的受保护的构造方法创建了对象
    System.out.println(&quot;String构造方法&quot;+p);
}</code></pre><p>}<br>备注：对于此时的话，单例模式就不再安全了！反射可破之！！</p>
<p>验证：对于枚举而言，反射依然没有办法重新创建对象<br>对于枚举，安全！</p>
<p>package junereflect624;</p>
<p>import java.lang.reflect.Constructor;</p>
<p>enum Color{<br>    RED,BLUE,GREEN;<br>    private Color(){<br>    }<br>}</p>
<p>public class EnumDemo8 {<br>    public static void main(String[] args) throws Exception {<br>        Class<Color> c = Color.class;</Color></p>
<pre><code>    Constructor&lt;Color&gt; con = c.getDeclaredConstructor();//（错误在这一行发生，就是说对枚举而言这种方法连构造器都获得不了，）编译可以通过，但是运行就通不过了！
    Color co = (Color) con.newInstance();
    System.out.println(co);//失败，证明对枚举而言不行，所以枚举的单例模式更加安全
    System.out.println(c.isEnum());//true是枚举
}</code></pre><p>}</p>
<h2 id="7、使用反射调用方法"><a href="#7、使用反射调用方法" class="headerlink" title="7、使用反射调用方法"></a>7、使用反射调用方法</h2><p>每个Method的对象对应一个具体的底层方法。获得Method对象后，程序可以使用Method里面的invoke方法来执行该底层方法。<br>Object invoke(Object obj,Object … args):obj表示调用底层方法的对象，后面的args表示传递的实际参数。<br>如果底层方法是静态的，那么可以忽略指定的 obj 参数。该参数可以为 null,想想为什么?<br>如果底层方法所需的形参个数为 0，则所提供的 args 数组长度可以为 0 或 null。<br>不写,null,或 new Object[]{}<br>若底层方法返回的是数组类型,invoke方法返回的不是底层方法的值,而是底层方法的返回类型;</p>
<p>package junereflect624;</p>
<p>import java.lang.reflect.Method;</p>
<p>class Dept{<br>    public String show(String name){//用反射的方法来调用正常的方法<br>        return name+”，您好！”;<br>    }</p>
<pre><code>private void privateshow(){//用反射来实现对私有化方法的调用
    System.out.println(&quot;privateshow&quot;);
}

public static void staticshow(){
    System.out.println(&quot;staticshow&quot;);
}</code></pre><p>}</p>
<p>public class InvokeDemo9 {<br>    public static void main(String[] args) throws Exception {</p>
<p>/*    传统方式：<br>String name = new Dept().show(“刘昭”);<br>        System.out.println(name);*/</p>
<p>/**<br>         * Method getMethod(String name, Class&lt;?&gt;… parameterTypes)<br>                  返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指            定公共成员方法。<br>            name - 方法名<br>            parameterTypes - 参数列表<br>         */<br>        //想要通过反射来调用Dept中的方法<br>        Class<Dept> c = Dept.class;<br>        Method m = c.getMethod(“show”, String.class);<br>        Object o = m.invoke(c.newInstance(), “刘昭”);<br>        System.out.println(o);</Dept></p>
<pre><code>    //私有化的方法
    m = c.getDeclaredMethod(&quot;privateshow&quot;);//无参方法
    m.setAccessible(true);
    o = m.invoke(c.newInstance());

    //静态方法的调用
    m = c.getMethod(&quot;staticshow&quot;);
    m.invoke(null);//staticshow为静态方法，不需创建对象，所以这里会是null
}</code></pre><p>}<br>打印<br>刘昭，您好！<br>privateshow<br>staticshow</p>
<h2 id="8、使用反射调用可变参数方法"><a href="#8、使用反射调用可变参数方法" class="headerlink" title="8、使用反射调用可变参数方法"></a>8、使用反射调用可变参数方法</h2><p>使用反射操作对象-调用可变参数方法</p>
<p>要把可变参数都当做是其对应的数组类型参数;<br>如 show(XX… is)作为show(XX[] is)调用;</p>
<p>若可变参数元素类型是引用类型:<br>JDK内部接收到参数之后,会自动拆包取出参数再分配给该底层方法,为此我们需要把这个数组实参先包装成一个Object对象或把实际参数作为一个Object一维数组的元素再传递。</p>
<p>若可变参数元素类型是基本类型:<br>JDK内部接收到参数之后,不会拆包,所以可以不必再封装.不过封装了也不会错.所以建议,不管基本类型还是引用类型都使用Object[]封装一层,保证无误.</p>
<p>例子<br>package junereflect624;<br>//可变参数的方法调用</p>
<p>import java.lang.reflect.Method;</p>
<p>class VaryMethod{<br>    public static void show(int …args){<br>        System.out.println(“基本数据类型传递过来了！”);<br>    }<br>    /<em>public static void show(int[] args){//这是一样的<br>    }</em>/<br>    public static void show(String …args){<br>        System.out.println(“引用数据类型传递过来了！”);<br>    }<br>}</p>
<p>public class InvokeVaryDemo10 {<br>    public static void main(String[] args) throws Exception{<br>        Class<VaryMethod> c = VaryMethod.class;</VaryMethod></p>
<pre><code>    Method m = c.getMethod(&quot;show&quot;,int[].class);
    m.invoke(null,new int[]{1,2,3});
    m = c.getMethod(&quot;show&quot;,String[].class);
    //m.invoke(null,new String[]{&quot;A&quot;,&quot;B&quot;,&quot;C&quot;});//ERROR
    m.invoke(null,(Object)new String[]{&quot;A&quot;,&quot;B&quot;,&quot;C&quot;});//YES,强转为Object类型
    m.invoke(null,new Object[]{new String[]{&quot;A&quot;,&quot;B&quot;,&quot;C&quot;}});//推荐写法
}</code></pre><p>}</p>
<h2 id="9、使用反射操作字段"><a href="#9、使用反射操作字段" class="headerlink" title="9、使用反射操作字段"></a>9、使用反射操作字段</h2><p>Field提供两组方法操作字段：<br>xxx getXxx(Object obj):获取obj对象该Field的字段值，此处的xxx表示8个基本数据类型。若该字段的类型是引用数据类型则使用，Object get(Object obj);<br>void setXxx(Object obj,xxx val):将obj对象的该Field字段设置成val值，此处的xxx表示8个基本数据类型。若该字段的类型是引用数据类型则使用，void set(Object obj, Object value);</p>
<p>package junereflect624;<br>//获取字符，并且赋值，然后再取出来（对应的去查看api，比如这个是Field，别的比如Constructor，Method）<br>步骤：<br>1．获取类<br>2．获取字段<br>3．赋值(set(c.newInstance(),””));{如果为私有的话设置可接受}<br>import java.lang.reflect.Field;</p>
<p>class Cat{<br>    private String name;<br>    public int age;<br>    private String color;<br>}</p>
<p>public class FieldDemo12 {<br>    public static void main(String[] args) throws Exception {<br>        Class<Cat> clz = Cat.class;<br>        Field[] f = clz.getDeclaredFields();</Cat></p>
<pre><code>for (Field field : f) {
    System.out.println(field);
}

Field fi = clz.getDeclaredField(&quot;name&quot;);
System.out.println(fi);

System.out.println(fi.getName());//name

//核心开始
/**
 *  void set(Object obj, Object value) </code></pre><p>将指定对象变量上此 Field 对象表示的字段设置为指定的新值。<br>         */<br>        Cat c = clz.newInstance();<br>        fi.setAccessible(true);<br>        fi.set(c, “刘昭”);//赋值成功<br>        Object o = fi.get(c);<br>        System.out.println(o);//取出成功 </p>
<pre><code>    fi = clz.getDeclaredField(&quot;age&quot;);
    fi.setAccessible(true);
    fi.set(c, 21);
    int i = fi.getInt(c);//左边的接受类型已经写成了int，右边的返回类型就也必须是int
    System.out.println(i);//获取成功
}</code></pre><p>}</p>
<p>打印<br>private java.lang.String junereflect624.Cat.name<br>public int junereflect624.Cat.age<br>private java.lang.String junereflect624.Cat.color<br>private java.lang.String junereflect624.Cat.name<br>name<br>刘昭<br>21</p>
<h2 id="10、反射和泛型-反射来获取泛型信息"><a href="#10、反射和泛型-反射来获取泛型信息" class="headerlink" title="10、反射和泛型-反射来获取泛型信息"></a>10、反射和泛型-反射来获取泛型信息</h2><p>通过指定对应的Class对象，程序可以获得该类里面所有的Field，不管该Field使用private 方法public。获得Field对象后都可以使用getType()来获取其类型。<br>Class&lt;?&gt; type = f.getType();//获得字段的类型<br>但此方法只对普通Field有效,若该Field有泛型修饰,则不能准确得到该Field的泛型参数,如Map&lt;String,Integer&gt;;<br>为了获得指定Field的泛型类型，我们采用：<br>Type gType = f.getGenericType();得到泛型类型<br>然后将Type对象强转为ParameterizedType,其表示增加泛型后的类型<br>Type getRawType()//返回被泛型限制的类型;<br>Type[]  getActualTypeArguments()//返回泛型参数类型;</p>
<p>利用反射来获取泛型的类型（泛型信息）<br>步骤：<br>1．获取当前类<br>2．获取目标字段<br>3．获取包含泛型类型的类型 getGenericType()<br>4．强转至子类ParameterizedType     因为Type没有任何对应的方法<br>5．获得泛型真正的类型 getActualTypeArguments()</p>
<p>例子<br>package junereflect624;</p>
<p>import java.lang.reflect.Field;<br>import java.lang.reflect.ParameterizedType;<br>import java.lang.reflect.Type;<br>import java.util.HashMap;<br>import java.util.Map;</p>
<p>public class GetGenericTypeDemo14 {<br>    Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();</p>
<pre><code>public static void main(String[] args) throws Exception {
    Class c = GetGenericTypeDemo14.class;
    Field f = c.getDeclaredField(&quot;map&quot;);
    System.out.println(f);
    System.out.println(f.getName());//map

    // Class&lt;?&gt; getType()  返回一个 Class 对象，它标识了此 Field 对象所表示字段的声明类型。 
    Class cl = f.getType();
    System.out.println(&quot;获得其类型：&quot;+cl);</code></pre><p>//获得其类型：interface java.util.Map</p>
<pre><code>/**
 *  Type getGenericType() 返回一个 Type 对象，它表示此 Field 对象所表示字段的声明类型。 
 *  Type是Class的接口;
 */
Type t = f.getGenericType();//包含泛型的类型
System.out.println(t);</code></pre><p>//java.util.Map&lt;java.lang.String, java.lang.Integer&gt;</p>
<pre><code>    /**
     * Type这个类里面没有任何的方法，所以需要调用子类的方法，那么大的类型转到小的类型，需要强转！
     */
    ParameterizedType pt = (ParameterizedType)t;//强转到其子类
    /**
     *  Type[] getActualTypeArguments() 
                  返回表示此类型实际类型参数的 Type对象的数组。 
         Type getOwnerType() 
                  返回 Type 对象，表示此类型是其成员之一的类型。 
         Type getRawType() 
                  返回 Type 对象，表示声明此类型的类或接口。 
     */

    t = pt.getRawType();//类型的类或接口
    System.out.println(t);

    Type[] ts = pt.getActualTypeArguments();
    for (Type type : ts) {
        System.out.println(type);
        /**
         *  class java.lang.String
            class java.lang.Integer
         */
    }
}</code></pre><p>}<br>打印：<br>java.util.Map junereflect624.GetGenericTypeDemo14.map<br>map<br>获得其类型：interface java.util.Map<br>java.util.Map&lt;java.lang.String, java.lang.Integer&gt;<br>interface java.util.Map<br>class java.lang.String<br>class java.lang.Integer</p>
<p>我的总结：多查找api，参考api中方法使用的限制，比如是否静态、返回值类型等。</p>
<h1 id="十三、反射机制"><a href="#十三、反射机制" class="headerlink" title="十三、反射机制"></a>十三、反射机制</h1><h2 id="1、GUI-图形用户界面"><a href="#1、GUI-图形用户界面" class="headerlink" title="1、GUI(图形用户界面)"></a>1、GUI(图形用户界面)</h2><p>GUI<br>Graphical User Interface(图形用户接口)。<br>用图形的方式，来显示计算机操作的界面，这样更方便更直观。<br>CLI<br>Command line User Interface (命令行用户接口）<br>就是常见的Dos命令行操作。<br>需要记忆一些常用的命令，操作不直观。<br>举例：<br>比如：创建文件夹，或者删除文件夹等<br>Java为GUI提供的对象都存在java.Awt和javax.Swing两个包中。</p>
<p>Act和Swing<br>Awt与 Swing<br>java.Awt：Abstract Window ToolKit (抽象窗口工具包)，需要调用本地系统方法实现功能。属重量级控件。<br>javax.Swing：在AWT的基础上，建立的一套图形界面系统，其中提供了更多的组件，而且完全由Java实现。增强了移植性，属轻量级控件。</p>
<h2 id="2、布局管理器"><a href="#2、布局管理器" class="headerlink" title="2、布局管理器"></a>2、布局管理器</h2><p>容器中的组件的排放方式，就是布局。<br>常见的布局管理器：<br>FlowLayout（流式布局管理器）//目前最常用的<br>从左到右的顺序排列。<br>Panel默认的布局管理器。<br>BorderLayout（边界布局管理器）<br>东，南，西，北，中<br>Frame默认的布局管理器。<br>GridLayout（网格布局管理器）<br>规则的矩阵<br>CardLayout（卡片布局管理器）<br>选项卡<br>GridBagLayout（网格包布局管理器）<br>非规则的矩阵</p>
<p>使用方法：new frame().setLayout(new FlowLayout());</p>
<p>创建图形化界面：</p>
<p>1，创建frame窗体。</p>
<p>2，对窗体进行基本设置。<br>    比如大小，位置，布局。</p>
<p>3，定义组件。</p>
<p>4，将组件通过窗体的add方法添加到窗体中。</p>
<p>5，让窗体显示，通过setVisible(true)</p>
<p>Eg：一个简单的窗体</p>
<p>import java.awt.<em>;<br>import java.awt.event.</em>;</p>
<p>import javax.swing.<em>;<br>import javax.swing.event.</em>;</p>
<p>class  SwingDemo<br>{<br>    public static void main(String[] args)<br>    {<br>        JFrame f = new JFrame();</p>
<pre><code>    f.setBounds(300,100,500,400);

    f.setLayout(new FlowLayout());

    JButton but = new JButton(&quot;我是一个按钮&quot;);

    f.add(but);

    f.addWindowListener(new WindowAdapter()
    {
        public void windowClosing(WindowEvent e)
        {
            System.exit(0);
        }
    });
    f.setVisible(true);
}</code></pre><p>}</p>
<h2 id="3、事件监听机制组成"><a href="#3、事件监听机制组成" class="headerlink" title="3、事件监听机制组成"></a>3、事件监听机制组成</h2><p>事件源（组件）<br>事件（Event）<br>监听器（Listener）<br>事件处理（引发事件后处理方式）</p>
<p>事件监听机制流程图</p>
<p>务必记牢：<br>确定事件源（容器或组件）<br>通过事件源对象的addXXXListener()方法将侦听器注册到该事件源上。<br>该方法中接收XXXListener的子类对象，或者XXXListener的子类XXXAdapter的子类对象。<br>一般用匿名内部类来表示。<br>在覆盖方法的时候，方法的参数一般是XXXEvent类型的变量接收。<br>事件触发后会把事件打包成对象传递给该变量。（其中包括事件源对象。通过getSource()或者，getComponent()获取。）</p>
<p>事件源：就是awt包或者swing包中的那些图形界面组件。</p>
<p>事件：每一个事件源都有自己特有的对应事件和共性事件。</p>
<p>监听器：将可以触发某一个事件的动作（不只一个动作）都已经封装到了监听器中。</p>
<p>以上三者，在java中都已经定义好了。直接获取其对象来用就可以了。</p>
<p>我们要做的事情是，就是对产生的动作进行处理。</p>
<p>Eg:<br>package june610;</p>
<p>import java.awt.Button;<br>import java.awt.FlowLayout;<br>import java.awt.Frame;<br>import java.awt.TextField;<br>import java.awt.event.ActionEvent;<br>import java.awt.event.ActionListener;<br>import java.awt.event.KeyAdapter;<br>import java.awt.event.KeyEvent;<br>import java.awt.event.MouseAdapter;<br>import java.awt.event.MouseEvent;<br>import java.awt.event.WindowAdapter;<br>import java.awt.event.WindowEvent;</p>
<p>class MyWin extends WindowAdapter{<br>    public void windowClosing(WindowEvent e){<br>        System.out.println(“hahahha”);<br>        System.exit(0);<br>    }<br>}</p>
<p>public class FrameDemo {//如果写成内部类的形式那么前面必须加上public static，因为主方法是静态的，不能调用动态类或者方法<br>    public static void main(String[] args) {<br>        //设置窗体<br>        Frame f = new Frame(“窗体”);<br>        f.setSize(400, 300);<br>        f.setLocation(500, 300);//距离左侧，距离上面<br>        /**可以用这个方法一次性设置<br>         * setBounds(int x, int y, int width, int height) 移动组件并调整其大小。<br>         */<br>        Button b = new Button(“按钮”);<br>        Button b2 = new Button(“按钮2”);<br>        TextField tf = new TextField(20);<br>        f.add(b);//把按钮添加到窗体上<br>        f.add(b2);//把按钮添加到窗体上<br>        f.add(tf);//在窗体上的的顺序按照添加的顺序</p>
<pre><code>    f.setLayout(new FlowLayout());//设置容器的布局管理器
    //f.addWindowListener(new MyWin());

    b.addActionListener(new ActionListener(){//通过匿名内部类，方便      添加动作监听器

        public void actionPerformed(ActionEvent e) {
            System.out.println(&quot;按钮把界面关闭了&quot;);
            //System.exit(0);
        }
    }); 

    //鼠标
    b.addMouseListener(new MouseAdapter() {//鼠标动作监听器
        int count = 1;
        public void mouseEntered(MouseEvent e){
            System.out.println(&quot;鼠标进入&quot;+(count++)+&quot;次！&quot;);
        } 
    });

    b.addMouseListener(new MouseAdapter(){//和上面的一样，可以写在一起
        int clickCount = 1;
        public void mouseClicked(MouseEvent e){
            if(e.getClickCount() == 2){
            System.out.println(&quot;双击动作&quot;+clickCount++);    
            }
        }
    });

    /*
    f.addWindowListener(new WindowAdapter()//匿名内部类的写法
    {
        public void windowClosing(WindowEvent e)
        {
            System.out.println(&quot;我关&quot;);
            System.exit(0);
        }
        public void windowActivated(WindowEvent e) 
        {
            System.out.println(&quot;我活了。&quot;);

        }

        public void windowOpened(WindowEvent e) 
        {
            System.out.println(&quot;我被打开了,hahahhahah&quot;);
        }

    });*/

    //键盘：
    b2.addKeyListener(new KeyAdapter() {

        public void keyPressed(KeyEvent e)
        {
            System.out.println(&quot;键盘的作用&quot;);//用鼠标按没反应，
            System.out.println(e.getKeyChar()+&quot;---&quot;+e.getKeyCode());//f---70等、
            if(e.getKeyCode() == 27){//按住esc键退出
                System.out.println(&quot;ESC键把我关闭了！&quot;);
                System.exit(0);
            }
            //组合键去关闭 CTRL + ENTER
            if(e.isControlDown() &amp;&amp; e.getKeyCode() == KeyEvent.VK_ENTER){
                System.out.println(&quot;CTRL + ENTER组合键把我关闭了！&quot;);
                System.exit(0);
            }
        } 
    });
    //文本框
    tf.addKeyListener(new KeyAdapter() {
        public void keyPressed(KeyEvent e){
            if(!(e.getKeyCode()&gt;=KeyEvent.VK_0 &amp;&amp; e.getKeyCode()&lt;=KeyEvent.VK_9)){
                System.out.println(e.getKeyChar()+&quot;不符合是数字！&quot;);
            }
        }
    });

    f.setVisible(true);//设置可见性

}</code></pre><p>}</p>
<p>Eg://列出文件夹内全部的文件<br>package june610;</p>
<p>import java.awt.Button;<br>import java.awt.FlowLayout;<br>import java.awt.Frame;<br>import java.awt.TextArea;<br>import java.awt.TextField;<br>import java.awt.event.ActionEvent;<br>import java.awt.event.ActionListener;<br>import java.awt.event.KeyAdapter;<br>import java.awt.event.KeyEvent;<br>import java.awt.event.WindowAdapter;<br>import java.awt.event.WindowEvent;<br>import java.io.File;</p>
<p>class MyFrame {<br>    private Frame f;<br>    private Button b;<br>    private TextField tf;<br>    private TextArea ta;</p>
<pre><code>MyFrame() {
    init();
}

void init() {
    f = new Frame(&quot;我的电脑&quot;);
    f.setBounds(300, 100, 600, 500);
    f.setLayout(new FlowLayout());
    b = new Button(&quot;转到&quot;);
    tf = new TextField(60);
    ta = new TextArea(25, 70);

    f.add(tf);
    f.add(b);
    f.add(ta);
    f.setVisible(true);
    action();
}

//窗体上的操作
void action() {
    f.addWindowListener(new WindowAdapter() {
        public void windowClosing(WindowEvent e) {
            System.exit(0);
        }
    });

    buttonAction();
    keyAction();
}
void keyAction(){
    //设置键盘监听器，当输入enter键的时候实现和点击鼠标同样的功能！
    b.addKeyListener(new KeyAdapter() {
        public void keyPressed(KeyEvent e){
            //if(e.getKeyCode() == 10){
                //buttonAction();
            //}

            String dirPath = tf.getText();// 获取文本（我们想验证的是路径），接下来获取文件
            File file = new File(dirPath);// 获取文件
            if (file.exists() &amp;&amp; file.isDirectory()) {// 判断，存在否以及是否是文件夹
                ta.setText(&quot;&quot;);// 如果符合条件的话，清空以前的数据；
                String[] names = file.list();
                for (String name : names) {
                    ta.append(name + &quot;\r\n&quot;);
                }
                System.out.println(&quot;=======&quot;);
            } else {
                ta.setText(&quot;&quot;);
                ta.append(&quot;对不起，请确认您输入的是路径！&quot;);
            }

            System.out.println(e.getKeyCode());
        }
    });

    tf.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            String dirPath = tf.getText();// 获取文本（我们想验证的是路径），接下来获取文件
            File file = new File(dirPath);// 获取文件
            if (file.exists() &amp;&amp; file.isDirectory()) {// 判断，存在否以及是否是文件夹
                ta.setText(&quot;&quot;);// 如果符合条件的话，清空以前的数据；
                String[] names = file.list();
                for (String name : names) {
                    ta.append(name + &quot;\r\n&quot;);
                }
                System.out.println(&quot;=======&quot;);
            } else {
                ta.setText(&quot;&quot;);
                ta.append(&quot;对不起，请确认您输入的是路径！&quot;);
            }
        }
    });
}

void buttonAction() {
    b.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            String dirPath = tf.getText();// 获取文本（我们想验证的是路径），接下来获取文件
            File file = new File(dirPath);// 获取文件
            if (file.exists() &amp;&amp; file.isDirectory()) {// 判断，存在否以及是否是文件夹
                ta.setText(&quot;&quot;);// 如果符合条件的话，清空以前的数据；
                String[] names = file.list();
                for (String name : names) {
                    ta.append(name + &quot;\r\n&quot;);
                }
                System.out.println(&quot;=======&quot;);
            } else {
                ta.setText(&quot;&quot;);
                ta.append(&quot;对不起，请确认您输入的是路径！&quot;);
            }
        }
    });
}</code></pre><p>}</p>
<p>public class FrameDemo3 {<br>    public static void main(String[] args) {<br>        new MyFrame();<br>    }<br>}</p>
<h2 id="4、Dialog"><a href="#4、Dialog" class="headerlink" title="4、Dialog"></a>4、Dialog</h2><p>Dialog构造方法<br>         * Dialog(Frame owner, String title, boolean modal)<br>          构造一个最初不可见的 Dialog，它带有指定的所有者 Frame、标题和模式。</p>
<p>备注：Dialog的模式区别在于：<br>true的话对话框依附于窗体，不取消Dialog不可以操作窗体，<br>    false的话，不取消Dialog可以操作窗体！<br>package june610;</p>
<p>import java.awt.Button;<br>import java.awt.Dialog;<br>import java.awt.FlowLayout;<br>import java.awt.Frame;<br>import java.awt.Label;<br>import java.awt.TextArea;<br>import java.awt.TextField;<br>import java.awt.event.ActionEvent;<br>import java.awt.event.ActionListener;<br>import java.awt.event.KeyAdapter;<br>import java.awt.event.KeyEvent;<br>import java.awt.event.WindowAdapter;<br>import java.awt.event.WindowEvent;<br>import java.io.File;</p>
<p>public class FrameDemo4 {<br>    public static void main(String[] args) {<br>        final Frame f = new Frame(“我的电脑”);<br>        f.setBounds(300, 100, 600, 500);<br>        f.setLayout(new FlowLayout());<br>        Button b = new Button(“转到”);<br>        Button okBut = new Button(“确定”);<br>        final TextField tf = new TextField(60);<br>        final TextArea ta = new TextArea(25, 70);</p>
<pre><code>    f.add(tf);
    f.add(b);
    f.add(ta);
    f.setVisible(true);

    final Dialog d = new Dialog(f,&quot;提示信息&quot;,true);
    final Label lab = new Label();//没有给出内容，用到的时候再给出！
    d.add(lab);//label标签加到Dialog上去！
    d.setBounds(400, 200, 240, 150);
    d.setLayout(new FlowLayout());
    d.add(okBut);

    okBut.addKeyListener(new KeyAdapter() {
        public void keyPressed(KeyEvent e){
            d.setVisible(false);
        }
    });

    //只可以对鼠标有作用！
    okBut.addActionListener(new ActionListener(){

        public void actionPerformed(ActionEvent e) {
            d.setVisible(false);
        }
    });

    d.addWindowListener(new WindowAdapter() {
        public void windowClosing(WindowEvent e) {
            d.setVisible(false);//对话框不显示
        }
    });

    //窗体上的操作
    f.addWindowListener(new WindowAdapter() {
        public void windowClosing(WindowEvent e) {
            System.exit(0);
        }
    });

    //设置键盘监听器，当输入enter键的时候实现和点击鼠标同样的功能！
    /*tf.addKeyListener(new KeyAdapter() {
        public void keyPressed(KeyEvent e) {
            if (e.getKeyCode() == 10) {
                // buttonAction();
                run(tf,ta,f,d,lab);
            }
            System.out.println(e.getKeyCode());
        }
    });*/

    //和上面被注释的代码实现的是同样的功能，也是键盘控制，不过不能设定哪个键，只有enter！
    tf.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            run(tf,ta,f,d,lab);
            // System.out.println(text);
        }
    });

    //给转到添加键盘和鼠标双控制
    b.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            run(tf,ta,f,d,lab);
            // System.out.println(text);
        }
    });

    b.addKeyListener(new KeyAdapter() {
        public void keyPressed(KeyEvent e){
            run(tf,ta,f,d,lab);
        }
    });
}

//封装这一方法，为了方便使用(注意这个时候传递参数太多了，尽量避免这种情况的发生！
//在一个方法内部创建的对象只有在自己方法体里面才可以直接调用，而在外部方法必须传递参数)
public static void run(TextField tf,TextArea ta,Frame f,Dialog d,Label lab){

    String dirPath = tf.getText();// 获取文本（我们想验证的是路径），接下来获取文件
    File file = new File(dirPath);// 获取文件
    if (file.exists() &amp;&amp; file.isDirectory()) {// 判断，存在否以及是否是文件夹
        ta.setText(&quot;&quot;);// 如果符合条件的话，清空以前的数据；
        String[] names = file.list();
        for (String name : names) {
            ta.append(name + &quot;\r\n&quot;);
        }
    } else {
        //备注：应该在这里构建对话框，为了内存的优化，用到的时候才创建对象，用不到就不创建！
        String info = &quot;您输入的信息：&quot;+dirPath+&quot;有误，请重新输入！&quot;;

        lab.setText(info);
        d.setVisible(true);

        /**可以这样写，但是不专业，现在弹出对话框!
         * ta.setText(&quot;&quot;);
           ta.append(&quot;对不起，请确认您输入的是路径！&quot;);
         */
    }
}</code></pre><p>}</p>
<h2 id="5、菜单"><a href="#5、菜单" class="headerlink" title="5、菜单"></a>5、菜单</h2><p>继承体系</p>
<p>MenuBar,Menu,MenuItem之间的关系：<br>先创建菜单条，再创建菜单，每一个菜单中建立菜单项。<br>也可以菜单添加到菜单中，作为子菜单。<br>通过setMenuBar()方法，将菜单添加到Frame中。</p>
<p>package june610;</p>
<p>import java.awt.FileDialog;<br>import java.awt.Frame;<br>import java.awt.Menu;<br>import java.awt.MenuBar;<br>import java.awt.MenuItem;<br>import java.awt.TextArea;<br>import java.awt.event.ActionEvent;<br>import java.awt.event.ActionListener;<br>import java.awt.event.WindowAdapter;<br>import java.awt.event.WindowEvent;<br>import java.io.BufferedReader;<br>import java.io.BufferedWriter;<br>import java.io.File;<br>import java.io.FileReader;<br>import java.io.FileWriter;<br>import java.io.IOException;</p>
<p>//最后导出jar包，用eclipse，必须要指定main函数！！不能直接点击finished！！！</p>
<p>/**</p>
<ul>
<li><p>菜单的结构MenuBar(相当于一个环境，f.set、、)</p>
</li>
<li><p>–&gt;Menu(菜单，m.add、、可以添加自己，也可以添加Item)</p>
</li>
<li><p>–&gt;MenuItem(条目 )</p>
</li>
<li><p>/<br>class MyMenuDemo{<br>  private Frame f;//首先声明对象的好处，全局可以调用！<br>  private MenuBar mb;<br>  private Menu m,subm;<br>  private MenuItem mi,close,save,open;<br>  private FileDialog openDia,saveDia;<br>  private TextArea ta;<br>  private File file;</p>
<p>  MyMenuDemo(){</p>
<pre><code>f = new Frame(&quot;我的电脑&quot;);
f.setBounds(400, 150, 500, 500);
//备注：此时没有设置布局管理器类型（因为不设置的话下面的TextArea会很爽！）
mb = new MenuBar();
m = new Menu(&quot;文件&quot;);
save = new MenuItem(&quot;保存&quot;);
open = new MenuItem(&quot;打开&quot;);
subm = new Menu(&quot;子菜单&quot;);
close = new MenuItem(&quot;退出&quot;);
mi = new MenuItem(&quot;子菜单2&quot;);
openDia = new FileDialog(f, &quot;我的打开&quot;, FileDialog.LOAD);//加载
saveDia = new FileDialog(f, &quot;我的保存&quot;, FileDialog.SAVE);//保存
ta = new TextArea();

f.setMenuBar(mb);//添加
mb.add(m);
subm.add(mi);
m.add(subm);
m.add(open);
m.add(save);
m.add(close);
f.add(ta);

f.setVisible(true);</code></pre></li>
</ul>
<pre><code>​    
​    init();
}

public  void init(){

    //打开文件，弹出对话框
    open.addActionListener(new ActionListener(){
        public void actionPerformed(ActionEvent e) {
            openDia.setVisible(true);
            String path = openDia.getDirectory();
            String name = openDia.getFile();
            //ta.append(path+&quot;-----&quot;+name+&quot;\n&quot;);
            if(path==null || name==null)
            return ;

        ta.setText(&quot;&quot;);//每次开始都清空

            file = new File(path, name);
            try {
                BufferedReader br = new BufferedReader(new FileReader(file));//缓冲流
                String line = null;
                while((line = br.readLine()) != null){
                    ta.append(line+&quot;\n&quot;);
                }
                br.close();
            } catch (IOException e1) {
                e1.printStackTrace();
            }

        }
    });

    //保存文件，弹出对话框！
    save.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            //注意问题：只有文件第一次保存（不存在）的时候才需要你去弹出对话框，以后只保存，不弹出！
            if(file == null){
                saveDia.setVisible(true);//不存在才弹，创建文件
                String path = saveDia.getDirectory();
                String name = saveDia.getFile();

                if(name == null || path == null)
                    return;

                //目录和名字正确，但是文件不存在，就新建一个文件！
                file = new File(path,name);
            }

            try {
                BufferedWriter bw = new BufferedWriter(new FileWriter(file));

                String s = ta.getText();
                bw.write(s);
                bw.close();

            } catch (IOException e1) {
                e1.printStackTrace();
            }
        }
    });

    f.addWindowListener(new WindowAdapter(){
        public void windowClosing(WindowEvent e){
            System.exit(0);
        }
    });

    close.addActionListener(new ActionListener(){
        public void actionPerformed(ActionEvent e) {
            System.exit(0);
        }
    });</code></pre><p>}<br> }</p>
<p>public class MenuDemo {<br>    public static void main(String[] args) {<br>        new MyMenuDemo();<br>    }<br>}</p>
<h3 id="1、Eclipse的使用技巧"><a href="#1、Eclipse的使用技巧" class="headerlink" title="1、Eclipse的使用技巧"></a>1、Eclipse的使用技巧</h3><p>eclipse与myeclipse的关系(都属于java开发的工具)：<br>后者是前者的一个插件，后来为了方便使用，myeclipse集合了eclipse，后者是收费的。<br>可大部分人都是用 eclipse 等常用的免费软件。最好用的因为别人都在用。这就是市场。</p>
<p>eclipse是java的一种IDE开发工具。</p>
<p>我的总结：请注意一些英文简写的含义，对应的每个单词。平时积累！</p>
<p>什么叫一个工程（project）：<br>我的看法是，一个独立的项目就是一个工程，一个工程包含多个源文件，运行环境，需要的资源。</p>
<p>IDE（Integrated Drive Electronics）开发工具都支持使用工程化方式管理一个项目的程序开发过程，一般来说一个相对独立的项目就是一个工程，一个项目中涉及的多个java文件，资源文件等用一个工程进行管理。（在这里可以看看以前工作间中的某个工程的结构），在不使用工程管理的情况下，如果一个项目中包括多个Java源文件，编程人员需要精心维护这些源文件之间、以及源文件与其它文件的目录关系，需要逐一编译这些源文件，需要手工启动运行编译后的结果。如果将一个程序的所有源文件用一个工程来组织，开发工具能对所有源文件集中管理，记住每个源文件的位置和相互关系。 工程中有哪几个源文件、启动类是哪个、启动参数设置等配置信息在工程中都记录。</p>
<p>工作间（workspace）：<br>一个工作间包含多个工程，工作间与工作间之间可以独立配置信息</p>
<p>  （编译、运行的版本、快捷键之类的）必须注意：不同的jre对应的效果可能不一样，例如java5新特性你用之前的版本，就会报错！</p>
<pre><code>一个workspace可以包含多个project，一个workspace保留了eclipse的一套环境选项的配置，例如，所使用的javac和java命令，等等，细节请查看window-&gt;preferences。如果要为eclispe再配置一套环境选项，可以再创        </code></pre><p>建一个workspace。Package explorer视图窗口中的filters菜单项，可以显示空的父包（此功能默认是关闭的）。</p>
<p>设置快捷键、工作间。</p>
<pre><code>快捷键使用技巧（经常出现软件之间快捷键冲突）：</code></pre><p>快捷键的位置：window-&gt;preferences-&gt;General-&gt;keys，设置alt+/键进行内容提示时，要注意解除alt+/键原来的绑定关系，直接输入alt+/就可以找到它的绑定关系，删除绑定关系时也可以使用remove binding这个按钮，课后必须教会大家在eclipse中。</p>
<p>代码模板的设置位置：java-&gt;editor-&gt;Templates<br>         代码模板(template)的作用<br> 自己可以添加，自定义，例如设置tryf  方便敲出try{}finally{};<br>多想一想：eclipse工作台中的所有工程继承工作台的配置，其中某个工程也可以覆盖工作台的配置！这是不是java面向对象的思想啊？</p>
<p>设置单个工程的javac和java<br>选择工程，右键-&gt;properties可以设置javac，右键-&gt;run asàopen run dialog可以设置java。 </p>
<p>例子：<br>先用新的工作间，然后创建新工程，默认的语言即为5.0。先使用Integer  x = 3;调整编译器的语法版本为1.4，看到eclipse窗口报错了。然后将这个工程的语言设置为6.0，马上又看到bad version .class运行错误了，这是因为myeclise自带的java为1.5 。然后再将整个工作间的javac设置为6.0（eclipse自带的是jdk1.5），然后看新建工程的javac，也随之改成了6.0，运行则又报bad version .class错误。将工程的编译语言再单独改为5.0，运行则没了问题。整个工作间的语言设置为6.0后，再将整个工作间的java也设置为自己安装的java6。</p>
<p>Perspective与view（透视图与视图）<br>1）所谓的不同的透视图：不同的小窗口（view）构成的大窗口（perspective），便于进行特有的操作，通过window的b按钮选择不同的view。<br>2）在eclipse中怎么调试？先双击最左边设置断点，然后回到代码区点右键出现debug，<br>出现的debug视图后选择需要调试的数据进行watch。</p>
<p>关于工作间配置javac（编译版本）和java（运行版本），简单来说就是高版本运行同级或低版本编译的源文件。向下兼容。</p>
<p>怎么导入工程<br>找到需要导入的工程，然后粘贴到所需要的工作台，import导入（看是否需要设置jre）,buildpath中设置。</p>
<h3 id="2、静态导入（1-5特性，好处是不用写类名）"><a href="#2、静态导入（1-5特性，好处是不用写类名）" class="headerlink" title="2、静态导入（1.5特性，好处是不用写类名）"></a>2、静态导入（1.5特性，好处是不用写类名）</h3><p>import语句可以导入一个类或某个包中的所有类<br>import static语句导入一个类中的某个静态方法或所有静态方法<br>语法举例：<br>import static java.lang.Math.sin;<br>import static java.lang.Math.*; </p>
<p>例子：<br>原来的：<br>package reviewDemo76;</p>
<p>public class Demo12 {<br>    public static void main(String[] args) {<br>        System.out.println(Math.max(12, 15));<br>    }<br>}</p>
<p>使用静态导入的：<br>package reviewDemo76;<br>import static java.lang.Math.*;</p>
<p>public class Demo12 {<br>    public static void main(String[] args) {<br>        System.out.println(max(12, 15));<br>    }<br>}</p>
<h3 id="3、可变参数"><a href="#3、可变参数" class="headerlink" title="3、可变参数"></a>3、可变参数</h3><p>是为了解决一个简单的方法在参数不同时多个重载的问题，用带可变参数的一个函数就能解决。<br>可变参数的特点：<br>1)只能出现在参数列表的最后；<br>2)  …  位于变量类型和变量名之间，前后有无空格都可以;<br>3)调用可变参数的方法时，编译器为该可变参数隐含创建一个数组，在方法体中以数组      的形式访问可变参数。<br>Public int add(int  x, int… args){//也可以直接（int..args）就是说传不传都可以<br>Int sum = x;<br>For(int i = 0; i&lt;=args.lengrth;i++){<br>Sum+=args[i];<br>}<br>return sum;<br>}</p>
<h3 id="4、增强for循环"><a href="#4、增强for循环" class="headerlink" title="4、增强for循环"></a>4、增强for循环</h3><p>语法：<br>     for ( type 变量名：集合变量名 )  { … }<br>注意事项：<br>     迭代变量必须在( )中定义！<br> 集合变量可以是数组或实现了Iterable接口的集合类</p>
<p>举例：<br>   public static int add(int x,int …args) {<br>       int sum = x;<br>       for(int arg:args) {<br>        sum += arg;<br>         }<br>         return sum;<br>   }</p>
<p>我的总结：这些都是java5出现的新特性！</p>
<h3 id="5、基本数据类型的自动拆箱与装箱"><a href="#5、基本数据类型的自动拆箱与装箱" class="headerlink" title="5、基本数据类型的自动拆箱与装箱"></a>5、基本数据类型的自动拆箱与装箱</h3><p>——&gt;  -128~127之间的特殊性。为什么要这样设计，好处？<br>——&gt;  享元模式（Flyweight Pattern）：享元模式的特点是，复用我们内存中已存在的对象，降低系统创建对象实例。</p>
<p>自动装箱：<br>Integer num1 = 12;</p>
<p>自动拆箱：<br>System.out.println(num1 + 12);<br>基本数据类型的对象缓存：<br>Integer num1 = 12;<br>Integer num2 = 12;<br>System.out.println(num1 == num2);</p>
<p>Integer num3 = 129;<br>Integer num4 = 129;<br>System.out.println(num3 == num4);//false</p>
<p>Integer num5 = Integer.valueOf(12);<br>Integer num6 = Integer.valueOf(12);<br>System.out.println(num5 == num6);//false</p>
<p>我的总结：对于享元模式，将最常用的封装以便于我们可以复用！</p>
<h2 id="6、枚举"><a href="#6、枚举" class="headerlink" title="6、枚举"></a>6、枚举</h2><p>​      为什么要有枚举？<br>​      问题：要定义星期几或性别的变量，该怎么定义？假设用1-7分别表示星期一到星期日，但有人可能会写成int weekday = 0;或即使使用常量方式也无法阻止意外。<br>枚举就是要让某个类型的变量的取值只能为若干个固定值中的一个，否则，编译器就会报错。枚举可以让编译器在编译时就可以控制源程序中填写的非法值，普通变量的方式在开发阶段无法实现这一目标。</p>
<pre><code>用普通类如何实现枚举功能，定义一个Weekday的类来模拟枚举功能。 
1、私有的构造方法。
2、每个元素分别用一个公有的静态成员变量表示。
 可以有若干公有方法或抽象方法。采用抽象方法定义nextDay就将大量的if.else语句转移成了一个个独立的类</code></pre><p>Eg：package july78javaEnhance;<br>//很好的一道题目。</p>
<p>enum TrafficLamp{<br>    /**<br>     * 对于这道题目而言，使用的其实是匿名对象内部类！<br>     * 枚举最简单的创建对象方法：RED，YELLOW，GREEN<br>     * 对于普通的类而言，创建对象：Person p = new Person();<br>     *<br>     */</p>
<pre><code>RED(30){

    @Override
    public TrafficLamp nextLamp() {
        return YELLOW;
    }

},

YELLOW(40){

    @Override
    public TrafficLamp nextLamp() {
        return GREEN;
    }

},

GREEN(45){

    @Override
    public TrafficLamp nextLamp() {
        return RED;
    }

};
public abstract TrafficLamp nextLamp();
private int time;
private TrafficLamp(int time){
    this.time = time;
}
public int getTime() {
    return time;
}
public void setTime(int time) {
    this.time = time;
}</code></pre><p>}</p>
<p>public class EnumDemo4 {<br>    public static void main(String[] args) {<br>        System.out.println(TrafficLamp.RED.nextLamp());<br>        System.out.println(TrafficLamp.RED.nextLamp().getTime());</p>
<pre><code>}</code></pre><p>}</p>
<h2 id="7、反射实现框架功能"><a href="#7、反射实现框架功能" class="headerlink" title="7、反射实现框架功能"></a>7、反射实现框架功能</h2><p>框架与框架要解决的核心问题<br>我做房子卖给用户住，由用户自己安装门窗和空调，我做的房子就是框架，用户需要使用我的框架，把门窗插入进我提供的框架中。框架与工具类有区别，工具类被用户的类调用，而框架则是调用用户提供的类。<br>框架要解决的核心问题<br>我在写框架（房子）时，你这个用户可能还在上小学，还不会写程序呢？我写的框架程序怎样能调用到你以后写的类（门窗）呢？<br>因为在写才程序时无法知道要被调用的类名，所以，在程序中无法直接new 某个类的实例对象了，而要用反射方式来做。</p>
<p>综合案例<br>先直接用new语句创建ArrayList和HashSet的实例对象，演示用eclipse自动生成 ReflectPoint类的equals和hashcode方法，比较两个集合的运行结果差异。<br>然后改为采用配置文件加反射的方式创建ArrayList和HashSet的实例对象，比较观察运行结果差异。<br>引入了elipse对资源文件的管理方式的讲解。</p>
<p>Eg：<br>package july78javaEnhance;<br>//利用资源文件加上反射操作！</p>
<p>import java.io.FileInputStream;<br>import java.io.InputStream;<br>import java.util.Collection;<br>import java.util.Properties;</p>
<p>public class ReflectPropertiesDemo8 {<br>    public static void main(String[] args) throws Exception {<br>        //写出来的三个全部是可以的，但是相对又不一样！</p>
<pre><code>    //可以的绝对路径InputStream ips = new FileInputStream(&quot;src/july78javaEnhance/MyPro.properties&quot;);//将这个文件加载进来！

    //可以的InputStream ips = ReflectPropertiesDemo8.class.getResourceAsStream(&quot;MyPro.properties&quot;);
    InputStream ips = ReflectPropertiesDemo8.class.getClassLoader().getResourceAsStream(&quot;july78javaEnhance/MyPro.properties&quot;);
    Properties pro = new Properties();
    pro.load(ips);
    ips.close();

    String className = pro.getProperty(&quot;className&quot;);

    Collection col = (Collection) Class.forName(className).newInstance();

    //Collection col = new TreeSet();//这样的做法也可以但是现在不想通过在等号右边具体的新建名称来做！

    col.add(12);
    col.add(13);
    col.add(12);
    col.add(23);
    col.add(36);
    System.out.println(col);
}</code></pre><p>}</p>
<h2 id="1、内省了解JavaBean"><a href="#1、内省了解JavaBean" class="headerlink" title="1、内省了解JavaBean"></a>1、内省了解JavaBean</h2><p>JavaBean是一种特殊的Java类，主要用于传递数据信息，这种java类中的方法主要用于访问私有的字段，且方法名符合某种命名规则。<br>如果要在两个模块之间传递多个信息，可以将这些信息封装到一个JavaBean中，这种JavaBean的实例对象通常称之为值对象（Value Object，简称VO）。这些信息在类中用私有字段来存储，如果读取或设置这些字段的值，则需要通过一些相应的方法来访问，大家觉得这些方法的名称叫什么好呢？JavaBean的属性是根据其中的setter和getter方法来确定的，而不是根据其中的成员变量。如果方法名为setId，中文意思即为设置id，至于你把它存到哪个变量上，用管吗？如果方法名为getId，中文意思即为获取id，至于你从哪个变量上取，用管吗？去掉set前缀，剩余部分就是属性名，如果剩余部分的第二个字母是小写的，则把剩余部分的首字母改成小的。</p>
<p>setId()的属性名id<br>isLast()的属性名last<br>setCPU的属性名是什么?CPU<br>getUPS的属性名是什么？UPS</p>
<p>总之，一个类被当作javaBean使用时，JavaBean的属性是根据方法名推断出来的，它根本看不到java类内部的成员变量。<br>一个符合JavaBean特点的类可以当作普通类一样进行使用，但把它当JavaBean用肯定需要带来一些额外的好处，我们才会去了解和应用JavaBean！好处如下：<br>在Java EE开发中，经常要使用到JavaBean。很多环境就要求按JavaBean方式进行操作，别人都这么用和要求这么做，那你就没什么挑选的余地！<br>JDK中提供了对JavaBean进行操作的一些API，这套API就称为内省。如果要你自己去通过getX方法来访问私有的x，怎么做，有一定难度吧？用内省这套api操作JavaBean比用普通类的方式更方便。</p>
<h2 id="2、内省综合案例和Beanutils工具包"><a href="#2、内省综合案例和Beanutils工具包" class="headerlink" title="2、内省综合案例和Beanutils工具包"></a>2、内省综合案例和Beanutils工具包</h2><p>演示用eclipse自动生成 ReflectPoint类的setter和getter方法。<br>直接new一个PropertyDescriptor对象的方式来让大家了解JavaBean API的价值，先用一段代码读取JavaBean的属性，然后再用一段代码设置JavaBean的属性。<br>演示用eclipse将读取属性和设置属性的流水帐代码分别抽取成方法：<br>只要调用这个方法，并给这个方法传递了一个对象、属性名和设置值，它就能完成属性修改的功能。<br>得到BeanInfo最好采用“obj.getClass()”方式，而不要采用“类名.class”方式，这样程序更通用。<br>采用遍历BeanInfo的所有属性方式来查找和设置某个RefectPoint对象的x属性。在程序中把一个类当作JavaBean来看，就是调用IntroSpector.getBeanInfo方法， 得到的BeanInfo对象封装了把这个类当作JavaBean看的结果信息。</p>
<p>演示用eclipse如何加入jar包，先只是引入beanutils包，等程序运行出错后再引入logging包。<br>在前面内省例子的基础上，用BeanUtils类先get原来设置好的属性，再将其set为一个新值。<br>get属性时返回的结果为字符串，set属性时可以接受任意类型的对象，通常使用字符串。<br>用PropertyUtils类先get原来设置好的属性，再将其set为一个新值。<br>get属性时返回的结果为该属性本来的类型，set属性时只接受该属性本来的类型。<br>演示去掉JavaBean（ReflectPoint）的public修饰符时，BeanUtils工具包访问javabean属性时出现的问题。</p>
<p>Eg：package javaBean.cn.itcast;  </p>
<p>import java.beans.BeanInfo;<br>import java.beans.IntrospectionException;<br>import java.beans.Introspector;<br>import java.beans.PropertyDescriptor;<br>import java.lang.reflect.InvocationTargetException;<br>import java.lang.reflect.Method;  </p>
<p>import org.apache.commons.beanutils.BeanUtils;  </p>
<p>public class BeansTest {  </p>
<pre><code>public static void main(String[] args) throws Exception {  
    // TODO Auto-generated method stub  
    Person p = new Person();  
    p.setName(&quot;刘昭&quot;);  

    String propertiesName = &quot;name&quot;;  
     String name = extracted(p, propertiesName);//演示了用eclipse抽取方法  
     System.out.println(name);  

    String propertiesAge = &quot;age&quot;;  
    int age = 23;  
    SetAge(p, propertiesAge, age);  

    String name1 = BeanUtils.getProperty(p, &quot;name&quot;);//使用beanUtils工具包进行获取和设置属性（尽管这些属性是私有的，可是有方法啊，是不是很方便）  
    System.out.println(BeanUtils.getProperty(p, &quot;name&quot;).getClass().getName());  
    System.out.println(name1);  

    BeanUtils.setProperty(p, &quot;age&quot;, 19);  
    System.out.println(p.getAge());  

    /*打印结果  
     * 刘昭  
       23  
       java.lang.String  
              刘昭  
      19*/  

}  

private static void SetAge(Person p, String propertiesAge, int age)  
        throws IntrospectionException, IllegalAccessException,  
        InvocationTargetException {  
    PropertyDescriptor bp1 = new PropertyDescriptor(propertiesAge, p.getClass());  
    Method methodSetAge = bp1.getWriteMethod();  
    methodSetAge.invoke(p,age);  
    System.out.println(p.getAge());  

}  

private static String  extracted(Object p, String propertiesName)  
        throws IntrospectionException, IllegalAccessException,  
        InvocationTargetException {  
    /*PropertyDescriptor bp = new PropertyDescriptor(propertiesName, p.getClass());  
    Method methodGetName = bp.getReadMethod();  
    Object readVal = methodGetName.invoke(p);  
    System.out.println(readVal);*/  

    BeanInfo beanInfo =  Introspector.getBeanInfo(p.getClass());  
    PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors();  
    Object retVal = null;  
    for(PropertyDescriptor pd : pds){  
        if(pd.getName().equals(propertiesName))  
        {  
            Method methodGetX = pd.getReadMethod();  
            retVal = (String)methodGetX.invoke(p);  
            break;  
        }  
    }  
    return (String) retVal;  

}  </code></pre><p>}  </p>
<h2 id="3、注解（Annotation）"><a href="#3、注解（Annotation）" class="headerlink" title="3、注解（Annotation）"></a>3、注解（Annotation）</h2><p>注解相当于一种标记，在程序中加了注解就等于为程序打上了某种标记，没加，则等于没有某种标记。<br>    以后，javac编译器，开发工具和其他程序可以用反射来了解你的类及各种元素上有无何种标记，看你有什么标记，就去干相应的事。<br>标记可以加在包，类，字段，方法，方法的参数以及局部变量上。<br>一个注解相当于一个类。</p>
<p>看java.lang包，可看到JDK中提供的最基本的annotation。<br>@SuppressWarning(”deprecation”)—&gt;压制警告</p>
<p>SupressWarning是告知编译器或开发工具等提示指定的编译器警告；</p>
<p>“deprecation”是告知具体的信息即方法已过时。</p>
<p>@Deprecated（过时的方法，对于不再使用的方法，可能别人或别的地方有调用这个方法，不能删除完事）<br>直接在刚才的类中增加一个方法，并加上@Deprecated标注，在另外一个类中调用这个方法。测试一下。<br>@SuppressWarnings(“deprecation”) （用这个可以告诉 程序说，我知道调用的方法过时了）<br>@Override—&gt;提示覆盖（父类方法）<br>public boolean equals(Reflect other)方法与HashSet结合讲解<br>   像person类，覆盖父类的equals 和hashCode方法，人家接收的参数是Object，人们习惯总是传入自己的对象，造成覆盖失败，变成重载！</p>
<p>注解的应用结构图</p>
<p>演示和讲解@Target元注解</p>
<p>Target（告诉编译器，自定义的注解类可以用在方法还是类….），设置Target等于ElementType.METHOD，原来加在类上的注解就报错了，改为用数组方式设置{ElementType.METHOD,ElementType.TYPE}就可以了。</p>
<p>元注解以及其枚举属性值不用记，只要会看jdk提供那几个基本注解的API帮助文档的定义或其源代码，按图索骥即可查到，或者直接看java.lang.annotation包下面的类。</p>
<p>（自定义注解）示例代码：<br>@Retention(RetentionPolicy.RUNTIME)//告诉程序说，这个注解要保存到运行时期<br>@Target({ElementType.METHOD,ElementType.TYPE})//告诉编译器，这个注解可以用在方法上，也可以用在类上  </p>
<p>public @interface MyAnnotation {<br>    String color() default “yellow”;//默认缺省值为yellow<br>    String value() ;//不指定<br>    int [] arrayAttr() default {1,2};//默认为{1,2}<br>    EnumTest.TrafficLamp lamp() default EnumTest.TrafficLamp.RED;//枚举类<br>    MetaAnnotation annotationAttr() default @MetaAnnotation(“xxx”);//属性中加注解，用@。可以在对别的类加注解时，改变值<br>} </p>
<p>为注解增加基本属性<br>（可以是八种基本数据类型，String ，数组，枚举，注解，Class）</p>
<p>什么是注解的属性?<br>一个注解相当于一个胸牌，如果你胸前贴了胸牌，就是传智播客的学生，否则，就不是。如果还想区分出是传智播客哪个班的学生，这时候可以为胸牌在增加一个属性来进行区分。加了属性的标记效果为：@MyAnnotation(color=”red”)</p>
<p>定义基本类型的属性和应用属性：<br>在注解类中增加String color();<br>@MyAnnotation(color=”red”)<br>用反射方式获得注解对应的实例对象后，再通过该对象调用属性对应的方法<br>MyAnnotation a = (MyAnnotation)AnnotationTest.class.getAnnotation(MyAnnotation.class);<br>System.out.println(a.color());</p>
<p>可以认为上面这个@MyAnnotation是MyAnnotaion类的一个实例对象<br>如果注解中有一个名称为value的属性，且你只想设置value属性（即其他属性都采用默认值或者你只有一个value属性），那么可以省略value=部分，例如：@MyAnnotation(“lhm”)。<br>枚举和注解都是特殊的类，不能用new 创建它们的实例对象，创建枚举的实例对象就是在其中增加元素。<br>在程序中如何创建出一个注解的实例对象啊？直接用@放上一个标记即可</p>
<p>Eg：package july78javaEnhance;</p>
<p>import java.lang.annotation.Retention;<br>import java.lang.annotation.RetentionPolicy;</p>
<p>@Retention(RetentionPolicy.RUNTIME)//元注解：信息的信息就是元信息 RUNTIME，保留到运行期间<br>/**</p>
<ul>
<li><p>指示注释类型的注释要保留多久。如果注释类型声明中不存在 Retention 注释，</p>
</li>
<li><p>则保留策略默认为 RetentionPolicy.CLASS。</p>
</li>
<li><p>/<br>//@Target(ElementType.METHOD)如果加上这句的话（只能作用于方法），那边就会报错！<br>public @interface AnnotationDemo12 {//注解</p>
<p>  String color() default “blue”;//相当于构造方法一样,如果给了它默认的初值，可以不用再设置（有默认的）<br>  String value();<br>  int []age();//数组和枚举类型的注解<br>  //还有注解类型的注解，暂时没学会<br>  MetaAnnotation annotation();<br>  //上面的MetaAnnotation是自己定义的一个注解类型，这样的话对于应用了当前注解的AnnotationDemo11类，就必须写上注解类型的属性<br>}</p>
</li>
</ul>
<p>package july78javaEnhance;</p>
<p>import java.util.Arrays;</p>
<p>//备注：应用注解后，它的属性你你没有写上，它会给予提醒！missing attribution<br>@AnnotationDemo12(color = “red”,value = “j2ee”,age = {1,2,3}, annotation = @MetaAnnotation(sex = “男”))//注解加注解<br>public class AnnotationDemo11 {<br>    @SuppressWarnings(“deprecation”)//压缩注解，一个注解就是一个类，用到的一个注解就相当于是调用的实例对象<br>    @AnnotationDemo12(value = “jase”,age = {1,2,3}, annotation = @MetaAnnotation(sex = “女”))//备注：如果别的属性有默认值，只有一个属性需要你设置，那么你就不需要写上全部的<br>    //赋值表达式，如上直接写上”jase”就行<br>    public static void main(String[] args) {</p>
<pre><code>    System.runFinalizersOnExit(true);//表示已经过时的方法，开发工具会给它中间加上一天横线
    /**
     *  boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 
         如果指定类型的注释存在于此元素上，则返回 true，否则返回 false。 
     */
    if(AnnotationDemo11.class.isAnnotationPresent(AnnotationDemo12.class)){
        AnnotationDemo12 annocation = (AnnotationDemo12)AnnotationDemo11.class
                .getAnnotation(AnnotationDemo12.class);//证明这里面有你的注解

        System.out.println(annocation.color());//调用属性
        System.out.println(Arrays.toString(annocation.age()));//将数组打印出来
        System.out.println(annocation.annotation().sex());//相当于调用属性的属性
    }
}</code></pre><p>}</p>
<h2 id="4、泛型"><a href="#4、泛型" class="headerlink" title="4、泛型"></a>4、泛型</h2><p>Jdk 1.5以前的集合类中存在什么问题<br>ArrayList collection = new ArrayList();<br>collection.add(1);<br>collection.add(1L);<br>collection.add(“abc”);<br>int i = (Integer) collection.get(1);//编译要强制类型转换且运行时出错！<br>Jdk 1.5的集合类希望你在定义集合时，明确表示你要向集合中装哪种类型的数据，无法加入指定类型以外的数据<br>ArrayList<Integer> collection2 = new ArrayList<Integer>();<br>collection2.add(1);<br>/<em>collection2.add(1L);<br>collection2.add(“abc”);</em>///这两行代码编译时就报告了语法错误<br>int i2 = collection2.get(0);//不需要再进行类型转换</Integer></Integer></p>
<p>泛型是提供给javac编译器使用的，<br>利用反射穿透泛型限制 （暴力反射）<br>泛型能绝对保证集合中存入数据都是它限定的类型吗？先看下边的代码 </p>
<p>package july78javaEnhance;</p>
<p>import java.util.ArrayList;</p>
<p>public class Demo23 {<br>    public static void main(String[] args) {<br>        ArrayList<Integer> collection2 = new ArrayList<Integer>();<br>        System.out.println(collection1.getClass()==collection2.getClass());<br>        collection2.add（“真暴力”）；//这句会报错<br>        collection2.getClass().getMethod(“add”, Object.class).invoke(collection2, “真暴力”);<br>        System.out.println(collection2.get(0)); //结果却为真暴力<br>        //已经限制集合中元素的类型为Integer，可用反射却能将String存入，为什么？ 这是因为泛型是给编译器用的，运行时就没有这些泛型信息了，这叫做“去泛型化”，所以可以通过反射，获取集合字节码加入非指定的类型。<br>    }<br>}</Integer></Integer></p>
<p>泛型中的？通配符的扩展<br>  限定通配符的上边界：<br>正确：Vector&lt;? extends Number&gt; x = new Vector<Integer>();<br>错误：Vector&lt;? extends Number&gt; x = new Vector<String>();<br>  限定通配符的下边界：<br>正确：Vector&lt;? super Integer&gt; x = new Vector<Number>();<br>错误：Vector&lt;? super Integer&gt; x = new Vector<Byte>();<br>提示：<br>限定通配符总是包括自己。<br>?只能用作引用，不能用它去给其他变量赋值<br>Vector&lt;? extends Number&gt; y = new Vector<Integer>();<br>Vector<Number> x = y;<br>上面的代码错误，原理与Vector<Object> x11 = new Vector<String>();相似，<br>只能通过强制类型转换方式来赋值。</String></Object></Number></Integer></Byte></Number></String></Integer></p>
<p>Eg：<br>泛型集合类的综合案例<br>能写出下面的代码即代表掌握了Java的泛型集合类：<br> HashMap&lt;String,Integer&gt; hm = new HashMap&lt;String,Integer&gt;();<br>  hm.put(“zxx”,19);<br>  hm.put(“lis”,18);  </p>
<p>  Set&lt;Map.Entry&lt;String,Integer&gt;&gt; mes= hm.entrySet();<br>  for(Map.Entry&lt;String,Integer&gt; me : mes) {<br>   System.out.println(me.getKey() + “:” + me.getValue());<br>  }<br>由C++的模板函数引入自定义泛型<br>如下函数的结构很相似，仅类型不同：<br>int add(int x,int y) {<br>            return x+y;<br>     }<br>float add(float x,float y) {<br>            return x+y;<br>    }<br>double add(double x,double y) {<br>            return x+y;<br>    }<br>C++用模板函数解决，只写一个通用的方法，它可以适应各种类型，示意代码如下：<br>    template<class t><br>    T add(T x,T y) {<br>            return (T) (x+y);<br>    }  </class></p>
<h2 id="类型参数的类型推断"><a href="#类型参数的类型推断" class="headerlink" title="类型参数的类型推断"></a>类型参数的类型推断</h2><p>l 编译器判断范型方法的实际类型参数的过程称为类型推断，类型推断是相对于知觉推断的，其实现方法是一种非常复杂的过程。<br>l 根据调用泛型方法时实际传递的参数类型或返回值的类型来推断，具体规则如下：<br>1．当某个类型变量只在整个参数列表中的所有参数和返回值中的一处被应用了，那么根据调用方法时该处的实际应用类型来确定，这很容易凭着感觉推断出来，即直接根据调用方法时传递的参数类型或返回值来决定泛型参数的类型，例如：<br> swap(new String[3],3,4)   à    static <E> void swap(E[] a, int i, int j)<br>2．当某个类型变量在整个参数列表中的所有参数和返回值中的多处被应用了，如果调用方法时这多处的实际应用类型都对应同一种类型来确定，这很容易凭着感觉推断出来，例如：<br> add(3,5)   à static <T> T add(T a, T b)<br>3．当某个类型变量在整个参数列表中的所有参数和返回值中的多处被应用了，如果调用方法时这多处的实际应用类型对应到了不同的类型，且没有使用返回值，这时候取多个参数中的最大交集类型，例如，下面语句实际对应的类型就是Number了，编译没问题，只是运行时出问题：<br> fill(new Integer[3],3.5f)   à static <T> void fill(T[] a, T v)<br>4．当某个类型变量在整个参数列表中的所有参数和返回值中的多处被应用了，如果调用方法时这多处的实际应用类型对应到了不同的类型， 并且使用返回值，这时候优先考虑返回值的类型，例如，下面语句实际对应的类型就是Integer了，编译将报告错误，将变量x的类型改为float，对比eclipse报告的错误提示，接着再将变量x类型改为Number，则没有了错误：<br> int x =(3,3.5f)   à static <T> T add(T a, T b)<br>5．参数类型的类型推断具有传递性，下面第一种情况推断实际参数类型为Object，编译没有问题，而第二种情况则根据参数化的Vector类实例将类型变量直接确定为String类型，编译将出现问题：<br>copy(new Integer[5],new String[5]) à static <T> void copy(T[] a,T[]  b);<br>copy(new Vector<String>(), new Integer[5]) à static <T> void copy(Collection<T> a , T[] b);</T></T></String></T></T></T></T></E></p>
<p>定义泛型类型<br>    如果类的实例对象中的多处都要用到同一个泛型参数，即这些地方引用的泛型类型要保持同一个实际类型时，这时候就要采用泛型类型的方式进行定义，也就是类级别的泛型，语法格式如下：<br>public class GenericDao<T> {<br>private T field1;<br>public void save(T obj){}<br>public T getById(int id){}<br>}<br>    类级别的泛型是根据引用该类名时指定的类型信息来参数化类型变量的，例如，如下两种方式都可以：<br>GenericDao<String> dao = null;<br>new genericDao<String>();</String></String></T></p>
<pre><code>注意：</code></pre><p>在对泛型类型进行参数化时，类型参数的实例必须是引用类型，不能是基本类型。<br>当一个变量被声明为泛型时，只能被实例变量、方法和内部类调用，而不能被静态变量和静态方法调用。因为静态成员是被所有参数化的类所共享的，所以静态成员不应该有类级别的类型参数。<br>    问题：类中只有一个方法需要使用泛型，是使用类级别的泛型，还是使用方法级别的泛型？</p>
<p>(Create)、查询(Retrieve)（重新得到数据）、更新(Update)和删除(Delete)几个单词的首字母简写  </p>
<p>import java.util.Set;  </p>
<p>//dao data access object（数据访问对象）—&gt;crud<br>public class GenericDao<E>  {<br>    public void add(E x){<br>    }<br>    public E findById(int id){<br>        return null;<br>    }<br>    public void delete(E obj){<br>    }<br>    public void delete(int id){<br>    }<br>    public void update(E obj){<br>    }<br>    public static <E> void update2(E obj){<br>    }<br>    public E findByUserName(String name){<br>        return null;<br>    }<br>    public Set<E> findByConditions(String where){<br>        return null;<br>    }<br>}  </E></E></E></p>
<h2 id="1、类加载器"><a href="#1、类加载器" class="headerlink" title="1、类加载器"></a>1、类加载器</h2><p>一、概述：</p>
<p>1、定义：简单说，类加载器就是加载类的工具。<br>当出现一个类，用到此类的时候，Java虚拟机首先将类字节码加载进内存，通常字节码的原始信息放在硬盘上的classpath指定的目录下。<br>2、类加载器作用：将.class文件中的内容加载进内存进行处理，处理完后的结果就是字节码。<br>3、默认类加载器：<br>1）Java虚拟机中可安装多个类加载器，系统默认的有三个主要的，每个类负责加载特定位置的类：BootStrap、ExtClassLoader、AppClassLoader<br>2）BootStrap–顶级类加载器：<br>类加载器本身也是Java类，因为它是Java类，本身也需要加载器加载，显然必须有第一个类加载器而不是java类的，这正是BootStrap。它是嵌套在Java虚拟机内核中的，已启动即出现在虚拟机中，是用c++写的一段二进制代码。所以不能通过java程序获取其名字，获得的只能是null。</p>
<p>4、Java虚拟机中的所有类加载器采用子父关系的树形结构进行组织，在实例化每个类加载器对象或默认采用系统类加载器作为其父级类加载器。</p>
<h2 id="2、类加载器的委托机制"><a href="#2、类加载器的委托机制" class="headerlink" title="2、类加载器的委托机制"></a>2、类加载器的委托机制</h2><p>l 当Java虚拟机要加载一个类时，到底派出哪个类加载器去加载呢？<br>1．首先当前线程的类加载器去加载线程中的第一个类。<br>2．如果类A中引用了类B，Java虚拟机将使用加载类A的类装载器来加载类B。<br>3．还可以直接调用ClassLoader.loadClass()方法来指定某个类加载器去加载某个类。<br>l 每个类加载器加载类时，又先委托给其上级类加载器。<br>1．当所有祖宗类加载器没有加载到类，回到发起者类加载器，还加载不了，则抛ClassNotFoundException，不是再去找发起者类加载器的儿子，因为没有getChild方法，即使有，那有多个儿子，找哪一个呢？<br>2．对着类加载器的层次结构图和委托加载原理，解释先前将ClassLoaderTest输出成jre/lib/ext目录下的itcast.jar包中后，运行结果为ExtClassLoader的原因。</p>
<p>每个ClassLoader本身只能分别加载特定位置和目录中的类，但它们可以委托其他的类装载器去加载类，这就是类加载器的委托模式。类装载器一级级委托到BootStrap类加载器，当BootStrap无法加载当前所要加载的类时，然后才一级级回退到子孙类装载器去进行真正的加载。当回退到最初的类装载器时，如果它自己也不能完成类的装载，那就应报告ClassNotFoundException异常。</p>
<p>有一道面试，能不能自己写个类叫java.lang.System，为了不让我们写System类，类加载采用委托机制，这样可以保证爸爸们优先，也就是总是使用爸爸们能找到的类，这样总是使用java系统提供的System。</p>
<p>把先前编写的类加入到jdk的rt.jar中，会有怎样的效果呢？不行!!!看来是不能随意将自己的class文件加入进rt.jar文件中的。</p>
<p>编写自己的类加载器(需要再仔细看一遍，不是太懂)</p>
<p>知识讲解：<br>自定义的类加载器的必须继承ClassLoader<br>loadClass方法（直接继承，省去委托机制的编写）与findClass方法（覆盖这个就行了）<br>defineClass方法<br>编程步骤：<br>编写一个对文件内容进行简单加密的程序。<br>编写了一个自己的类装载器，可实现对加密过的类进行装载和解密。<br>编写一个程序调用类加载器加载类，在源程序中不能用该类名定义引用变量，因为编译器无法识别这个类。程序中可以除了使用ClassLoader.load方法之外，还可以使用设置线程的上下文类加载器或者系统类加载器，然后再使用Class.forName。<br>实验步骤：<br>对不带包名的class文件进行加密，加密结果存放到另外一个目录，例如： java MyClassLoader MyTest.class F:\itcast<br>运行加载类的程序，结果能够被正常加载，但打印出来的类装载器名称为AppClassLoader：java MyClassLoader MyTest F:\itcast<br>用加密后的类文件替换CLASSPATH环境下的类文件，再执行上一步操作就出问题了，错误说明是AppClassLoader类装载器装载失败。<br>删除CLASSPATH环境下的类文件，再执行上一步操作就没问题了。</p>
<p>import java.io.<em>;<br>import java.lang.reflect.</em>;<br>public class MyClassLoader extends ClassLoader<br>{<br>    private String path = null;<br>    public MyClassLoader(String path) throws Exception//检查文件是否存在<br>    {<br>        File f = new File(path);<br>        if(!f.isDirectory())<br>        {<br>            throw new RuntimeException(path + “ is not a directory”);<br>        }<br>        this.path = path;<br>    }  </p>
<pre><code>public Class findClass(String name) //throws Exception //为什么不能抛出  
{  
    try  
    {  
        File f = new File(path,name.substring(name.lastIndexOf(&apos;.&apos;)+1) + &quot;.class&quot;);  
        FileInputStream fis = new FileInputStream(f);  
        ByteArrayOutputStream bos = new ByteArrayOutputStream();  
        cypher(fis,bos);  
        byte [] buf = bos.toByteArray();  
        fis.close();  
        bos.close();  
        return defineClass(name,buf,0,buf.length);  
    }catch(Exception e)  
    {  
        throw new ClassNotFoundException(name + &quot; is not found!&quot;);  
    }  
    return null;  
}  </code></pre><p>​<br>​    public static void cypher(InputStream istream,OutputStream ostream) throws Exception<br>​    {<br>​        //下面这段代码可能遇到255的字节，当成byte就成了-1<br>​        /<em>byte b = 0;<br>​        while((b = (byte)istream.read()) != -1)<br>​        {<br>​            ostream.write(b ^ 0xff);<br>​        }</em>/<br>​<br>​        int b = 0;<br>​        while((b = istream.read()) != -1)<br>​        {<br>​            ostream.write(((byte)b) ^ 0xff);<br>​        }<br>​    }<br>​<br>​    public static void main(String [] args) throws Exception<br>​    {<br>​<br>        //下面省略了错误检查<br>        if(!args[0].endsWith(“class”))<br>        {<br>            ClassLoader loader = new MyClassLoader(args[1]);<br>            Class cls = loader.loadClass(args[0]);  </p>
<pre><code>        /*  
        让自定义类继承Date类  
        System.out.println(cls.getClassLoader().getClass().getName());  
            java.util.Date d = (java.util.Date)cls.newInstance();  
            System.out.println(d.toString());  
            */  

        //Method m = cls.getMethod(&quot;test&quot;,null);//在jdk1.5中报警告，为什么？  
        Method m = cls.getMethod(&quot;test&quot;);  
        //m.invoke(cls.newInstance(),null);  
        m.invoke(cls.newInstance());  
        //((Test)cls.newInstance()).test();  
        return;  
    }  
    else  
    {         
        FileInputStream fis = new FileInputStream(args[0]);       
        File f = new File(args[1], new File(args[0]).getName());//不用检查目录最后是否有目录分割符  
        FileOutputStream fos = new FileOutputStream(f);       
        cypher(fis,fos);  
        fis.close();  
        fos.close();  
    }  
}  </code></pre><p>}  </p>
<p>//类加载器不能加载这种非public的类<br>/*<br>Exception in thread “main” java.lang.IllegalAccessException: Class MyClassLoader<br> can not access a member of class MyTest with modifiers “”<br><em>/<br>/</em><br>class MyTest<br>{<br>    public void test()<br>    {<br>        System.out.println(“hello,<a href="http://www.it315.org&quot;" target="_blank" rel="noopener">www.it315.org&quot;</a>);<br>    }<br>}<br>*/  </p>
<h2 id="3、一个类加载器的高级问题分析"><a href="#3、一个类加载器的高级问题分析" class="headerlink" title="3、一个类加载器的高级问题分析"></a>3、一个类加载器的高级问题分析</h2><p>编写一个能打印出自己的类加载器名称和当前类加载器的父子结构关系链的MyServlet，正常发布后，看到打印结果为WebAppClassloader。<br>把MyServlet.class文件打jar包，放到ext目录中，重启tomcat，发现找不到HttpServlet的错误。<br>把servlet.jar也放到ext目录中，问题解决了，打印的结果是ExtclassLoader 。<br>父级类加载器加载的类无法引用只能被子级类加载器加载的类，原理如下图：</p>
<h2 id="4、代理的概念与作用"><a href="#4、代理的概念与作用" class="headerlink" title="4、代理的概念与作用"></a>4、代理的概念与作用</h2><p>1、引入:<br>为已存在的多个具有相同接口的目标类的各个方法增加一些系统功能，例如，异常处理、日志、计算方法的运行时间、事务管理、等等，你准备如何做？<br>编写一个与目标类具有相同接口的代理类，代理类的每个方法调用目标类的相同方法，并在调用方法时加上系统功能的代码。 </p>
<p>2、代理类的优点：<br>如果采用工厂模式和配置文件的方式进行管理，则不需要修改客户端程序，在配置文件中配置是使用目标类、还是代理类，这样以后很容易切换，譬如，想要日志功能时就配置代理类，否则配置目标类，这样，增加系统功能很容易，以后运行一段时间后，又想去掉系统功能也很容易。</p>
<p>目标类：                              代理类：</p>
<p>class X{                               Xproxy{</p>
<p>  void sayHello(){                       void sayHello(){</p>
<p>syso:Hello;                            startTime</p>
<p>}                                           X. sayHello();</p>
<p>}                                      endTime;}}</p>
<p>一般用接口来引用其子类，如：Collectioncoll = new ArrayList();</p>
<p>AOP<br>系统中存在交叉业务，一个交叉业务就是要切入到系统中的一个方面，如下所示：<br>                              安全       事务         日志<br>StudentService  ——|———-|————|————-<br>CourseService   ——|———-|————|————-<br>MiscService       ——|———-|————|————-<br>用具体的程序代码描述交叉业务：<br>method1         method2          method3<br>{                      {                       {<br>——————————————————切面<br>….            ….              ……<br>——————————————————切面<br>}                       }                       }<br>交叉业务的编程问题即为面向方面的编程（Aspect oriented program ,简称AOP），AOP的目标就是要使交叉业务模块化。可以采用将切面代码移动到原始方法的周围，这与直接在方法中编写切面代码的运行效果是一样的，如下所示：<br>——————————————————切面<br>func1         func2            func3<br>{             {                {<br>….            ….              ……<br>}             }                }<br>——————————————————切面<br>使用代理技术正好可以解决这种问题，代理是实现AOP功能的核心和关键技术。</p>
<p>安全，事务，日志等功能要贯穿到好多个模块中，所以，它们就是交叉业务<br>重要原则：不要把供货商暴露给你的客户</p>
<h2 id="5、动态代理技术"><a href="#5、动态代理技术" class="headerlink" title="5、动态代理技术"></a>5、动态代理技术</h2><p>1、要为系统中的各种接口的类增加代理功能，那将需要太多的代理类，全部采用静态代理方式，将是一件非常麻烦的事情！写成百上千个代理类，是不是太累！<br>2、JVM可以在运行期动态生成出类的字节码，这种动态生成的类往往被用作代理类，即动态代理类。<br>3、JVM生成的动态类必须实现一个或多个接口，所以，JVM生成的动态类只能用作具有相同接口的目标类的代理。<br>4、CGLIB库可以动态生成一个类的子类，一个类的子类也可以用作该类的代理，所以，如果要为一个没有实现接口的类生成动态代理类，那么可以使用CGLIB库。<br>5、代理类的各个方法中通常除了要调用目标的相应方法和对外返回目标返回的结果外，还可以在代理方法中的如下四个位置加上系统功能代码：<br>1）在调用目标方法之前<br>2）在调用目标方法之后<br>3）在调用目标方法前后<br>4）在处理目标方法异常的catch块中</p>
<h2 id="6、分析JVM动态生成的类"><a href="#6、分析JVM动态生成的类" class="headerlink" title="6、分析JVM动态生成的类"></a>6、分析JVM动态生成的类</h2><p>总结思考：让jvm创建动态类及其实例对象，需要给它提供哪些信息?<br>三个方面：<br>1、生成的类中有哪些方法，通过让其实现哪些接口的方式进行告知；<br>2、产生的类字节码必须有个一个关联的类加载器对象；<br>3、生成的类中的方法的代码是怎样的，也得由我们提供。把我们的代码写在一个约定好了接口对象的方法中，把对象传给它，它调用我的方法，即相当于插入了我的代码。提供执行代码的对象就是那个InvocationHandler对象，它是在创建动态类的实例对象的构造方法时传递进去的。在上面的InvocationHandler对象的invoke方法中加一点代码，就可以看到这些代码被调用运行了。<br>用newProxyInstance（）方法直接一步就创建出代理对象。</p>
<p>总结分析动态代理类的统计原理和结构：</p>
<p>1、怎样将目标传进去：</p>
<p>1）直接在InvocationHandler实现类中创建目标类的实例对象，可看运行效果和加入日志代码，但是毫无意义。</p>
<p>2）为InvocationHandler实现类注入目标的实例对象，不能采用匿名内部类的形式了。</p>
<p>3）让匿名内部类的InvocationHandler实现类访问外面的方法中的目标类实例对象的final类型的引用变量。</p>
<p>2、动态代理的工作原理：</p>
<p>1）Client(客户端)调用代理，代理的构造方法接受一个InvocationHandler，client调用代理的各个方法，代理的各个方法请求转发给刚才通过构造方法传入的handler对象，又把各请求分发给目标的相应的方法。就是将handler封装起来，其中this引用了当前的放(发来什么请求就接受哪个方法)。<br>猜想分析动态生成的类的内部代码：<br>1、动态生成的类实现了Collection接口（可以实现若干接口），生成的类有Collection接口中的所有方法和一个如下接受InvocationHandler参数的构造方法。<br>2、构造方法接受一个InvocationHandler对象，接受对象了要干什么用呢？该方法内部的代码会是怎样的呢？<br>实现Collection接口的动态类中的各个方法的代码又是怎样的呢？InvocationHandler接口中定义的invoke方法接受的三个参数又是什么意思？图解说明如下：</p>
<p>分析为什么动态类的实例对象的getClass()方法返回了正确结果呢？<br>为何动态类的实例对象的getClass()方法返回了正确结果，而没调用invoke方法：<br>因为代理类从Object上继承了许多方法，其中只对三个方法（hashCode、equals和toString）进行开发，委托给handler去自行处理，对于它身上其他方法不会交给代理类去实现，所以对于getClass()方法，还是由Object本身实现的。即proxy3.getClass()，该是什么结果还是什么结果，并不会交给invoke方法处理。</p>
<h2 id="7、综合示例代码："><a href="#7、综合示例代码：" class="headerlink" title="7、综合示例代码："></a>7、综合示例代码：</h2><p>package javaenhance.src.cn.itcast.day3;  </p>
<p>import java.lang.reflect.Constructor;<br>import java.lang.reflect.InvocationHandler;<br>import java.lang.reflect.Method;<br>import java.lang.reflect.Proxy;<br>import java.util.ArrayList;<br>import java.util.Collection;<br>public class ProxyTest {  </p>
<pre><code>/**  
 * @param args  
 */  
public static void main(String[] args) throws Exception{  
    // TODO Auto-generated method stub  
    //接收两个参数，一个是后边参数的字节码的加载器，一个是所要实现代理的接口的字节码  
    Class clazzProxy1 = Proxy.getProxyClass(Collection.class.getClassLoader(), Collection.class);  
    System.out.println(clazzProxy1.getName());//打印代理的名字     $Proxy0  

    System.out.println(&quot;----------begin constructors list----------&quot;);  
    /*想打印出如下格式：  
     * $Proxy0()  
    $Proxy0(InvocationHandler,int)*/  
    Constructor[] constructors = clazzProxy1.getConstructors();//获取代理的构造函数  
    for(Constructor constructor : constructors){  
        String name = constructor.getName();//获取代理的构造函数的name  
        StringBuilder sBuilder = new StringBuilder(name);  
        sBuilder.append(&apos;(&apos;);  
        Class[] clazzParams = constructor.getParameterTypes();//获取代理的构造函数的参数  
        for(Class clazzParam : clazzParams){  
            sBuilder.append(clazzParam.getName()).append(&apos;,&apos;);  
        }  
        if(clazzParams!=null &amp;&amp; clazzParams.length != 0)//稳妥的判断是否是一个参数，不是就删掉最后的，  
            sBuilder.deleteCharAt(sBuilder.length()-1);  
        sBuilder.append(&apos;)&apos;);  
        System.out.println(sBuilder.toString());    //$Proxy0(java.lang.reflect.InvocationHandler)        
    }  

    System.out.println(&quot;----------begin methods list----------&quot;);  
    /*$Proxy0()  
    $Proxy0(InvocationHandler,int)*/  
    Method[] methods = clazzProxy1.getMethods();//获取代理身上的方法  
    for(Method method : methods){  
        String name = method.getName();  
        StringBuilder sBuilder = new StringBuilder(name);  
        sBuilder.append(&apos;(&apos;);  
        Class[] clazzParams = method.getParameterTypes();  
        for(Class clazzParam : clazzParams){  
            sBuilder.append(clazzParam.getName()).append(&apos;,&apos;);  
        }  
        if(clazzParams!=null &amp;&amp; clazzParams.length != 0)  
            sBuilder.deleteCharAt(sBuilder.length()-1);  
        sBuilder.append(&apos;)&apos;);  
        System.out.println(sBuilder.toString());              
    }  

    System.out.println(&quot;----------begin create instance object----------&quot;);  
    //Object obj = clazzProxy1.newInstance();  
           //方式一：通过接口的子类创建对象    
    Constructor constructor =  </code></pre><p>clazzProxy1.getConstructor(InvocationHandler.class);<br>        //获取代理身上的构造函数<br>        //创建内部类MyInvocationHandler1，目的是传递给代理的构造器<br>        class MyInvocationHandler1 implements InvocationHandler{  </p>
<pre><code>    public Object invoke(Object proxy, Method method, Object[] args)  
            throws Throwable {  
        // TODO Auto-generated method stub  
        return null;  
    }  

}  
//方式二：匿名内部类   
Collection proxy1 = (Collection)constructor.newInstance(new MyInvocationHandler1());  

System.out.println(proxy1);//没有错误  
proxy1.clear();//没有错误  
//proxy1.size();报错，因为，代理调用size方法，其实是调用了MyInvocationHandler1中的invoke，他的返回值是null  
//System.out.println(&quot;111111111111111&quot;);//调试用的  

//用了匿名内部类的方法实现  
Collection proxy2 = (Collection)constructor.newInstance(new InvocationHandler(){  

    public Object invoke(Object proxy, Method method, Object[] args)  
            throws Throwable {  
        return null;  
    }  

});  </code></pre><p>​<br>​        /<em>下边这部分代码非常重要和精辟</em>/<br>​        final ArrayList target = new ArrayList();<br>​        Collection proxy3 = (Collection)getProxy(target,new MyAdvice());<br>​        proxy3.add(“zxx”);<br>​        proxy3.add(“lhm”);<br>​        proxy3.add(“bxd”);<br>​        System.out.println(proxy3.size());<br>​        System.out.println(proxy3.getClass().getName());<br>​    }<br>​<br>​    private static Object getProxy(final Object target,final Advice advice) {<br>​<br>​        //方式三，newProxyInstance这个方法需要三个参数，可以直接创建target的代理对象<br>​        Object proxy3 = Proxy.newProxyInstance(<br>​                target.getClass().getClassLoader(),<br>​                /<em>new Class[]{Collection.class},</em>/<br>​<br>                //获取target上的接口<br>                target.getClass().getInterfaces(),<br>                new InvocationHandler(){  </p>
<pre><code>                public Object invoke(Object proxy, Method method, Object[] args)  
                        throws Throwable {  

                    /*long beginTime = System.currentTimeMillis();  
                    Object retVal = method.invoke(target, args);  
                    long endTime = System.currentTimeMillis();  
                    System.out.println(method.getName() + &quot; running time of &quot; + (endTime - beginTime));  
                    return retVal;*/  

                    //把上边的代码封装到一个类中，让后调用该类的方法，就实现了方法的封装  
                    advice.beforeMethod(method);  
                    Object retVal = method.invoke(target, args);  
                    advice.afterMethod(method);  
                    return retVal;                        

                }  
            }  
            );  
    return proxy3;  
}  </code></pre><p>}  </p>
<p>/<em>$Proxy0<br>———-begin constructors list———-<br>$Proxy0(java.lang.reflect.InvocationHandler)<br>———-begin methods list———-<br>hashCode()<br>equals(java.lang.Object)<br>toString()<br>add(java.lang.Object)<br>contains(java.lang.Object)<br>isEmpty()<br>size()<br>toArray()<br>toArray([Ljava.lang.Object;)<br>addAll(java.util.Collection)<br>iterator()<br>remove(java.lang.Object)<br>clear()<br>containsAll(java.util.Collection)<br>removeAll(java.util.Collection)<br>retainAll(java.util.Collection)<br>getProxyClass(java.lang.ClassLoader,[Ljava.lang.Class;)<br>newProxyInstance(java.lang.ClassLoader,[Ljava.lang.Class;,java.lang.reflect.InvocationHandler)<br>isProxyClass(java.lang.Class)<br>getInvocationHandler(java.lang.Object)<br>getClass()<br>notify()<br>notifyAll()<br>wait(long)<br>wait(long,int)<br>wait()<br>———-begin create instance object———-<br>null<br>到传智播客来学习啦！<br>从传智播客毕业上班啦！<br>add running time of 0<br>到传智播客来学习啦！<br>从传智播客毕业上班啦！<br>add running time of 0<br>到传智播客来学习啦！<br>从传智播客毕业上班啦！<br>add running time of 0<br>到传智播客来学习啦！<br>从传智播客毕业上班啦！<br>size running time of 0<br>3<br>$Proxy1</em>/  </p>
<hr>
<p>import java.lang.reflect.Method;  </p>
<p>public interface Advice {<br>    void beforeMethod(Method method);<br>    void afterMethod(Method method);<br>}  </p>
<hr>
<p>package javaenhance.src.cn.itcast.day3;  </p>
<p>import java.lang.reflect.Method;<br>//创建实现Advice接口的子类<br>public class MyAdvice implements Advice {<br>    long beginTime = 0;<br>    public void afterMethod(Method method) {<br>        // TODO Auto-generated method stub<br>        System.out.println(“从传智播客毕业上班啦！”);<br>        long endTime = System.currentTimeMillis();<br>        System.out.println(method.getName() + “ running time of “ + (endTime - beginTime));  </p>
<pre><code>}  

public void beforeMethod(Method method) {  
    // TODO Auto-generated method stub  
    System.out.println(&quot;到传智播客来学习啦！&quot;);  
    beginTime = System.currentTimeMillis();  
}  </code></pre><p>} </p>
<h2 id="8、实现类似spring的可配置的AOP框架"><a href="#8、实现类似spring的可配置的AOP框架" class="headerlink" title="8、实现类似spring的可配置的AOP框架"></a>8、实现类似spring的可配置的AOP框架</h2><p>一、工厂类BeanFactory：</p>
<p>1、工厂类BeanFactory负责创建目标类或代理类的实例对象，并通过配置文件实现切换。</p>
<p>2、getBean方法根据参数字符串返回一个相应的实例对象，如果参数字符串在配置文件中对应的类名不是ProxyFactoryBean，则直接返回该类的实例对象，否则返回该类示例对象的getProxy方法返回的对象。</p>
<p>3、BeanFactory的构造方法接收代表配置文件的输入流对象的配置文件格式如下：</p>
<p>#xxx=java.util.ArrayList</p>
<p>xxx=cn.itcast.test3.aopframework.ProxyFactoryBean</p>
<p>xxx.advice=cn.itcast.test3.MyAdvice</p>
<p>xxx.target=java.util. ArrayList<br>注意：其中的#代表注释当前行。</p>
<p>4、ProxyFactoryBean充当封装成动态的工厂，需为工厂提供的配置参数信息包括：</p>
<p>目标（target）</p>
<p>通告（advice）</p>
<p>5、BeanFactory和ProxyFactoryBean：</p>
<p>1）BeanFactory是一个纯粹的bean工程，就是创建bean即相应的对象的工厂。</p>
<p>2）ProxyfactoryBean是BeanFactory中的一个特殊的Bean，是创建代理的工厂。</p>
<h2 id="二、实现类似spring的可配置的AOP框架的思路："><a href="#二、实现类似spring的可配置的AOP框架的思路：" class="headerlink" title="二、实现类似spring的可配置的AOP框架的思路："></a>二、实现类似spring的可配置的AOP框架的思路：</h2><p>1、创建BeanFactory类：</p>
<p>1）构造方法：接受一个配置文件，通过Properties对象加载InputStream流对象获得。</p>
<p>2）创建getBean(String name)方法，接收Bean的名字，从上面加载后的对象获得。</p>
<p>3）通过其字节码对象创建实例对象bean。</p>
<p>4）判断bean是否是特殊的Bean即ProxyFactoryBean，如果是，就要创建代理类，并设置目标和通告，分别得到各自的实例对象，并返回代理类实例对象。如果不是在返回普通类的实例对象。</p>
<p>2、创建ProxyFactoryBean(接口)，此处用类做测试，其中有一个getProxy方法，用于获得代理类对象。</p>
<p>3、对配置文件进行配置，如上面配置一样。</p>
<p>4、作一个测试类：AopFrameworkTest进行测试。</p>
<p>//创建BeanFactory类<br>package cn.itcast.test3.aopframework;<br>import java.io.IOException;<br>import java.io.InputStream;<br>import java.lang.reflect.InvocationHandler;<br>import java.lang.reflect.Method;<br>import java.lang.reflect.Proxy;<br>import java.util.Properties;<br>public class BeanFactory {<br>    Properties prop = new Properties();<br>    //创建对象时需要传入一个配置文件中的数据，所以需要在构造方法中接受一个参数<br>    public BeanFactory(InputStream ips) {<br>        try {<br>            //将配置文件加载进来<br>            prop.load(ips);<br>        } catch (IOException e) {<br>            e.printStackTrace();<br>        }<br>    }<br>    //创建getBean方法，通过配置文件中的名字获取bean对象<br>    public Object getBean(String name){<br>        //从配置文件中读取类名<br>        String className = prop.getProperty(name);<br>        Object bean = null;<br>        try {<br>            //由类的字节码获取对象<br>            Class clazz = Class.forName(className);<br>            bean = clazz.newInstance();<br>        } catch (Exception e) {<br>            e.printStackTrace();<br>        }<br>        //判断bean是特殊的bean即ProxyFactoryBean还是普通的bean<br>        if(bean instanceof ProxyFactoryBean){<br>            Object proxy = null;<br>            try {<br>                //是ProxyFactoryBean的话，强转，并获取目标和通告<br>                ProxyFactoryBean proxyFactoryBean = (ProxyFactoryBean)bean;<br>                //获取advice和target<br>                Advice advice = (Advice)Class.forName(prop.getProperty(name + “.advice”)).newInstance();<br>                Object target = Class.forName(prop.getProperty(name + “.target”)).newInstance();<br>                //设置目标和通告<br>                proxyFactoryBean.setAdvice(advice);<br>                proxyFactoryBean.setTarget(target);<br>                //通过类ProxyFactoryBean（开发中是作为接口存在）中获得proxy对象<br>                proxy = proxyFactoryBean.getProxy();<br>            } catch (Exception e) {<br>                // TODO Auto-generated catch block<br>                e.printStackTrace();<br>            }<br>            //是ProxyFactoryBean的话，返回proxy对象<br>            return proxy;<br>        }<br>        //否则返回普通bean对象<br>        return bean;<br>    }<br>}    </p>
<p>//创建ProxyFactoryBean类<br>package cn.itcast.test3.aopframework;<br>import java.lang.reflect.*;<br>import cn.itcast.test3.Advice;<br>public class ProxyFactoryBean {<br>    private Object target;<br>    private Advice advice;<br>    public Object getTarget() {<br>        return target;<br>    }<br>    public void setTarget(Object target) {<br>        this.target = target;<br>    }<br>    public Advice getAdvice() {<br>        return advice;<br>    }<br>    public void setAdvice(Advice advice) {<br>        this.advice = advice;<br>    }<br>    public Object getProxy() {<br>        Object proxy = Proxy.newProxyInstance(<br>                target.getClass().getClassLoader(),<br>                //这里的接口要和target实现相同的接口<br>                target.getClass().getInterfaces(),<br>                new InvocationHandler() {<br>                    public Object invoke(Object proxy, Method method, Object[] args)<br>                            throws Throwable {<br>                        //通过契约，使用其方法–before和after方法<br>                        advice.beforeMethod(method);<br>                        Object value = method.invoke(target, args);<br>                        advice.afterMethod(method);<br>                        return value;<br>                    }<br>                }<br>                );<br>        return proxy;<br>    }<br>}<br>//创建测试类AopFrameworkTest<br>package cn.itcast.test3.aopframework;<br>import java.io.InputStream;<br>public class AopFramewrorkTest {<br>    public static void main(String[] args)throws Exception {<br>        //读取配置文件的数据<br>        InputStream ips =<br>                AopFramewrorkTest.class.getResourceAsStream(“config.property”);<br>        //获取bean对象<br>        Object bean = new BeanFactory(ips).getBean(“xxx”);<br>        System.out.println(bean.getClass().getName());<br>    }<br>}   </p>
<p>黑马程序员——面试题之交通灯管理系统</p>
<p>需求：<br>交通灯管理系统的项目需求<br>Ø 异步随机生成按照各个路线行驶的车辆。<br>例如：<br>       由南向而来去往北向的车辆 —- 直行车辆<br>       由西向而来去往南向的车辆 —- 右转车辆<br>       由东向而来去往南向的车辆 —- 左转车辆<br>       。。。<br>Ø 信号灯忽略黄灯，只考虑红灯和绿灯。<br>Ø 应考虑左转车辆控制信号灯，右转车辆不受信号灯控制。<br>Ø 具体信号灯控制逻辑与现实生活中普通交通灯控制逻辑相同，不考虑特殊情况下的控制逻辑。<br>注：南北向车辆与东西向车辆交替放行，同方向等待车辆应先放行直行车辆而后放行左转车辆。<br>Ø 每辆车通过路口时间为1秒（提示：可通过线程Sleep的方式模拟）。<br>Ø 随机生成车辆时间间隔以及红绿灯交换时间间隔自定，可以设置。<br>Ø 不要求实现GUI，只考虑系统逻辑实现，可通过Log方式展现程序运行结果。</p>
<p>1、面向对象的分析与设计</p>
<p>1、每条路线上都会出现多辆车，路线上要随机增加新的车，在灯绿期间还要每秒钟减少一辆车。<br>设计一个Road类来表示路线，每个Road对象代表一条路线，总共有12条路线，即系统中总共要产生12个Road实例对象。<br>每条路线上随机增加新的车辆，增加到一个集合中保存。<br>每条路线每隔一秒都会检查控制本路线的灯是否为绿，是则将本路线保存车的集合中的第一辆车移除，即表示车穿过了路口。<br>每条路线每隔一秒都会检查控制本路线的灯是否为绿，一个灯由绿变红时，应该将下一个方向的灯变绿。<br>2、设计一个Lamp类来表示一个交通灯，每个交通灯都维护一个状态：亮（绿）或不亮（红），每个交通灯要有变亮和变黑的方法，并且能返回自己的亮黑状态。<br>总共有12条路线，所以，系统中总共要产生12个交通灯。右拐弯的路线本来不受灯的控制，但是为了让程序采用统一的处理方式，故假设出有四个右拐弯的灯，只是这些灯为常亮状态，即永远不变黑。<br>3、除了右拐弯方向的其他8条路线的灯，它们是两两成对的，可以归为4组，所以，在编程处理时，只要从这4组中各取出一个灯，对这4个灯依次轮询变亮，与这4个灯方向对应的灯则随之一同变化，因此Lamp类中要有一个变量来记住自己相反方向的灯，在一个Lamp对象的变亮和变黑方法中，将对应方向的灯也变亮和变黑。每个灯变黑时，都伴随者下一个灯的变亮，Lamp类中还用一个变量来记住自己的下一个灯。<br>4、无论在程序的什么地方去获得某个方向的灯时，每次获得的都是同一个实例对象，所以Lamp类改用枚举来做显然具有很大的方便性，永远都只有代表12个方向的灯的实例对象。<br>设计一个LampController类，它定时让当前的绿灯变红。</p>
<p>2、Road类的编写</p>
<p>每个Road对象都有一个name成员变量来代表方向，有一个vehicles成员变量来代表方向上的车辆集合。<br>在Road对象的构造方法中启动一个线程每隔一个随机的时间向vehicles集合中增加一辆车（用一个“路线名_id”形式的字符串进行表示）。<br>在Road对象的构造方法中启动一个定时器，每隔一秒检查该方向上的灯是否为绿，是则打印车辆集合和将集合中的第一辆车移除掉</p>
<p>import java.util.ArrayList;<br>import java.util.List;<br>import java.util.Random;<br>import java.util.concurrent.ExecutorService;<br>import java.util.concurrent.Executors;<br>import java.util.concurrent.ScheduledExecutorService;<br>import java.util.concurrent.TimeUnit;  </p>
<p>/**  </p>
<ul>
<li><p>每个Road对象代表一条路线，总共有12条路线，即系统中总共要产生12个Road实例对象。  </p>
</li>
<li><p>每条路线上随机增加新的车辆，增加到一个集合中保存。  </p>
</li>
<li><p>每条路线每隔一秒都会检查控制本路线的灯是否为绿，是则将本路线保存车的集合中的第一辆车移除，即表示车穿过了路口。  </p>
</li>
<li></li>
<li><p>/<br>public class Road {<br>  private List<String> vechicles = new ArrayList<String>();  </String></String></p>
<p>  private String name =null;<br>/<em>在这个构造函数中,传回哪个方向的车,<br>先开启一个线程池用于产生车辆,一个定时器用于观察交通灯状态</em>/<br>  public Road(String name){  </p>
<pre><code> this.name = name;  

 //模拟车辆不断随机上路的过程   
//使用线程池，通过产生单个线程的方法，创建一个线程池    
 ExecutorService pool = Executors.newSingleThreadExecutor();  </code></pre><p>　　//  </p>
<pre><code>pool.execute(new Runnable(){  
    public void run(){  
        for(int i=1;i&lt;1000;i++){  
            try {  
                Thread.sleep((new Random().nextInt(10) + 1) * 1000);  
            } catch (InterruptedException e) {  
                e.printStackTrace();  
            }  
            vechicles.add(Road.this.name + &quot;_&quot; + i);  
        }                 
    }  

});  

//每隔一秒检查对应的灯是否为绿，是则放行一辆车      </code></pre><p>　　 //产生一个单线程，创建定时器    </p>
<pre><code>ScheduledExecutorService timer =  Executors.newScheduledThreadPool(1);  
timer.scheduleAtFixedRate(  
        new Runnable(){  
            public void run(){  </code></pre><p>　　 //判断路上是否有车，有则进行相应的操作  </p>
<pre><code>if(vechicles.size()&gt;0){  
    boolean lighted = Lamp.valueOf(Road.this.name).isLighted();  </code></pre><p>//每隔1秒让车通行，通行前要先判断灯是否亮，亮了才能通行，即从集合中移除    </p>
<pre><code>            if(lighted){  
                System.out.println(vechicles.remove(0) + &quot; is traversing !&quot;);  
            }  
        }  

    }  
},  
1,  
1,  
TimeUnit.SECONDS);  </code></pre><p>  }<br>}  </p>
</li>
</ul>
<p>3、Lamp类的编写</p>
<p>系统中有12个方向上的灯，在程序的其他地方要根据灯的名称就可以获得对应的灯的实例对象，综合这些因素，将Lamp类用java5中的枚举形式定义更为简单。<br>1、每个Lamp对象中的亮黑状态用lighted变量表示，选用S2N、S2W、E2W、E2N这四个方向上的Lamp对象依次轮询变亮，Lamp对象中还要有一个oppositeLampName变量来表示它们相反方向的灯，再用一个nextLampName变量来表示此灯变亮后的下一个变亮的灯。这三个变量用构造方法的形式进行赋值，因为枚举元素必须在定义之后引用，所以无法再构造方法中彼此相互引用，所以，相反方向和下一个方向的灯用字符串形式表示。<br>2、增加让Lamp变亮和变黑的方法：light和blackOut，对于S2N、S2W、E2W、E2N这四个方向上的Lamp对象，这两个方法内部要让相反方向的灯随之变亮和变黑，blackOut方法还要让下一个灯变亮。<br>3、除了S2N、S2W、E2W、E2N这四个方向上的Lamp对象之外，其他方向上的Lamp对象的nextLampName和oppositeLampName属性设置为null即可，并且S2N、S2W、E2W、E2N这四个方向上的Lamp对象的nextLampName和oppositeLampName属性必须设置为null，以便防止light和blackOut进入死循环。</p>
<p>代码：<br>/**  </p>
<ul>
<li>每个Lamp元素代表一个方向上的灯，总共有12个方向，所有总共有12个Lamp元素。  </li>
<li>有如下一些方向上的灯,每两个形成一组，一组灯同时变绿或变红，所以，  </li>
<li>程序代码只需要控制每组灯中的一个灯即可：  </li>
<li>s2n,n2s      </li>
<li>s2w,n2e  </li>
<li>e2w,w2e  </li>
<li>e2s,w2n  </li>
<li>s2e,n2w  </li>
<li>e2n,w2s  </li>
<li>上面最后两行的灯是虚拟的，由于从南向东和从西向北、以及它们的对应方向不受红绿灯的控制，  </li>
<li>所以，可以假想它们总是绿灯。  </li>
<li>@author 张孝祥 <a href="http://www.it315.org" target="_blank" rel="noopener">www.it315.org</a>  </li>
<li></li>
<li>/<br>/**/  </li>
</ul>
<p>public enum Lamp {<br>    /<em>每个枚举元素各表示一个方向的控制灯</em>/<br>    S2N(“N2S”,”S2W”,false),S2W(“N2E”,”E2W”,false),E2W(“W2E”,”E2S”,false),E2S(“W2N”,”S2N”,false),<br>    /<em>下面元素表示与上面的元素的相反方向的灯，它们的“相反方向灯”和“下一个灯”应忽略不计！</em>/<br>    N2S(null,null,false),N2E(null,null,false),W2E(null,null,false),W2N(null,null,false),<br>    /<em>由南向东和由西向北等右拐弯的灯不受红绿灯的控制，所以，可以假想它们总是绿灯</em>/<br>    S2E(null,null,true),E2N(null,null,true),N2W(null,null,true),W2S(null,null,true);  </p>
<pre><code>private Lamp(String opposite,String next,boolean lighted){  
    this.opposite = opposite;  
    this.next = next;  
    this.lighted = lighted;  
}  






/*当前灯是否为绿*/   
private boolean lighted;  
/*与当前灯同时为绿的对应方向*/     
private String opposite;  
/*当前灯变红时下一个变绿的灯*/     
private String next;  
//灯的判断是否亮的方法  
public boolean isLighted(){  
    return lighted;  
}  

/**让这个方向的等亮起来  
 * 某个灯变绿时，它对应方向的灯也要变绿  
 */   
public void light(){  
    this.lighted = true;  
    if(opposite != null){  
        Lamp.valueOf(opposite).light();  
    }  
    System.out.println(name() + &quot; lamp is green，下面总共应该有6个方向能看到汽车穿过！&quot;);  

}  

/**  
 * 某个灯变红时，对应方向的灯也要变红，并且下一个方向的灯要变绿  
 * @return 下一个要变绿的灯  
 */   
public Lamp blackOut(){  
    this.lighted = false;  
    if(opposite != null){  
        Lamp.valueOf(opposite).blackOut();  
    }         

    Lamp nextLamp= null;  
    if(next != null){  </code></pre><p>　　 //当前灯变绿了，让对应的灯也变绿<br>            nextLamp = Lamp.valueOf(next);<br>            System.out.println(“绿灯从” + name() + “——–&gt;切换为” + next);<br>            nextLamp.light();<br>        }<br>        return nextLamp;<br>    }<br>}  </p>
<p>4、LampController类的编写</p>
<p>import java.util.concurrent.Executors;<br>import java.util.concurrent.ScheduledExecutorService;<br>import java.util.concurrent.TimeUnit;  </p>
<p>public class LampController {<br>    private Lamp currentLamp;  </p>
<pre><code>public LampController(){  
    //刚开始让由南向北的灯变绿;       
    currentLamp = Lamp.S2N;  
    currentLamp.light();  

    /*每隔10秒将当前绿灯变为红灯，并让下一个方向的灯变绿*/        
    ScheduledExecutorService timer =  Executors.newScheduledThreadPool(1);  
    timer.scheduleAtFixedRate(  
            new Runnable(){  
                public  void run(){  
                    System.out.println(&quot;来啊&quot;);  
                    currentLamp = currentLamp.blackOut();  
            }  
            },  
            10,  
            10,  
            TimeUnit.SECONDS);  
}  </code></pre><p>5、MainClass类的编写</p>
<p>1、用for循环创建出代表12条路线的对象。<br>2、接着再获得LampController对象并调用其start方法。</p>
<p>public class MainClass {  </p>
<pre><code>/**  
 * @param args  
 */  
public static void main(String[] args) {  

    /*产生12个方向的路线*/        
    String [] directions = new String[]{  
            &quot;S2N&quot;,&quot;S2W&quot;,&quot;E2W&quot;,&quot;E2S&quot;,&quot;N2S&quot;,&quot;N2E&quot;,&quot;W2E&quot;,&quot;W2N&quot;,&quot;S2E&quot;,&quot;E2N&quot;,&quot;N2W&quot;,&quot;W2S&quot;       
    };  
    for(int i=0;i&lt;directions.length;i++){  
        new Road(directions[i]);  
    }  

    /*产生整个交通灯系统*/         
    new LampController();  
}  </code></pre><p>}  </p>
<p>打印结果：/*N2S lamp is green—–有六个方向的车经过<br>S2N lamp is green—–有六个方向的车经过<br>N2S_1 is traversing !<br>S2N_1 is traversing !<br>N2W_1 is traversing !<br>S2N_2 is traversing !<br>E2N_1 is traversing !<br>S2E_1 is traversing !<br>S2N_3 is traversing !<br>N2S_2 is traversing !<br>S2N_4 is traversing !<br>开始跑吧<br>绿灯从S2N——–&gt;切换为S2W<br>N2E lamp is green—–有六个方向的车经过<br>S2W lamp is green—–有六个方向的车经过<br>W2S_1 is traversing !<br>S2E_2 is traversing !<br>N2W_2 is traversing !<br>S2W_1 is traversing !<br>W2S_2 is traversing !<br>N2E_1 is traversing !<br>N2E_2 is traversing !<br>N2E_3 is traversing !<br>S2W_2 is traversing !<br>W2S_3 is traversing !<br>E2N_2 is traversing !<br>S2E_3 is traversing !<br>E2N_3 is traversing !<br>S2E_4 is traversing !<br>开始跑吧<br>绿灯从S2W——–&gt;切换为E2W<br>W2E lamp is green—–有六个方向的车经过<br>E2W lamp is green—–有六个方向的车经过<br>E2W_1 is traversing !<br>N2W_3 is traversing !<br>E2W_2 is traversing !<br>W2E_1 is traversing !<br>E2W_3 is traversing !<br>W2E_2 is traversing !<br>W2S_4 is traversing !<br>E2W_4 is traversing !<br>N2W_4 is traversing !<br>W2E_3 is traversing !<br>S2E_5 is traversing !<br>E2N_4 is traversing !<br>E2W_5 is traversing !<br>W2S_5 is traversing !<br>N2W_5 is traversing !<br>W2E_4 is traversing !<br>*/  </p>
<p>面试题之银行业务系统</p>
<p>1、需求<br>模拟实现银行业务调度系统逻辑，具体需求如下：<br>    银行内有6个业务窗口，1 - 4号窗口为普通窗口，5号窗口为快速窗口，6号窗口为VIP窗口。<br>    有三种对应类型的客户：VIP客户，普通客户，快速客户（办理如交水电费、电话费之类业务的客户）。<br>    异步随机生成各种类型的客户，生成各类型用户的概率比例为：<br>    VIP客户 ：普通客户 ：快速客户  =  1 ：6 ：3。<br>    客户办理业务所需时间有最大值和最小值，在该范围内随机设定每个VIP客户以及普通客户办理业务所需的时间，快速客户办理业务所需时间为最小值（提示：办理业务的过程可通过线程Sleep的方式模拟）。<br>    各类型客户在其对应窗口按顺序依次办理业务。<br>    当VIP（6号）窗口和快速业务（5号）窗口没有客户等待办理业务的时候，这两个窗口可以处理普通客户的业务，而一旦有对应的客户等待办理业务的时候，则优先处理对应客户的业务。<br>    随机生成客户时间间隔以及业务办理时间最大值和最小值自定，可以设置。<br>    不要求实现GUI，只考虑系统逻辑实现，可通过Log方式展现程序运行结果。</p>
<p>2、需求分析</p>
<p>面向对象的分析与设计<br>1、有三种对应类型的客户：VIP客户，普通客户，快速客户 ，异步随机生成各种类型的客户，各类型客户在其对应窗口按顺序依次办理业务 。<br>1）首先，每一个客户其实就是由银行的一个取号机器产生号码的方式来表示的。所以，我想到要有一个号码管理器对象，让这个对象不断地产生号码，就等于随机生成了客户。<br>2）由于有三类客户，每类客户的号码编排都是完全独立的，所以，我想到本系统一共要产生三个号码管理器对象，各自管理一类用户的排队号码。这三个号码管理器对象统一由一个号码机器进行管理，这个号码机器在整个系统中始终只能有一个，所以，它要被设计成单例。<br>2、各类型客户在其对应窗口按顺序依次办理业务 ，准确地说，应该是窗口依次叫号。<br>      各个窗口怎么知道该叫哪一个号了呢？<br>      它一定是问的相应的号码管理器，即服务窗口每次找号码管理器获取当前要被服务的号码。</p>
<p>3、NumberManager类</p>
<p>1、定义一个用于存储上一个客户号码的成员变量和用于存储所有等待服务的客户号码的队列集合。<br>2、定义一个产生新号码的方法和获取马上要为之服务的号码的方法，这两个方法被不同的线程操作了相同的数据，所以，要进行同步。</p>
<p>import java.util.ArrayList;<br>import java.util.List;  </p>
<p>public class NumberManager {<br>    private int lastNumber = 0;<br>    private List queueNumbers = new ArrayList();  </p>
<pre><code>public synchronized Integer generateNewNumber(){//为客户服务,客户来了取走一个队号  
    queueNumbers.add(++lastNumber);  
    return lastNumber;  
}  

public synchronized Integer fetchNumber(){//服务于窗口,服务完一个叫下一个  
    if(queueNumbers.size()&gt;0){  
        return (Integer)queueNumbers.remove(0);  
    }else{  
        return null;  
    }  
}  </code></pre><p>}  </p>
<p>4、NumberMachine类</p>
<p>定义三个成员变量分别指向三个NumberManager对象，分别表示普通、快速和VIP客户的号码管理器，定义三个对应的方法来返回这三个NumberManager对象。<br>将NumberMachine类设计成单例。</p>
<p>public class NumberMachine {  </p>
<pre><code>private NumberMachine(){}  
private static NumberMachine instance = new NumberMachine();  
public static NumberMachine getInstance(){  
    return instance;  
}  

private NumberManager commonManager = new NumberManager();  
private NumberManager expressManager = new NumberManager();  
private NumberManager vipManager = new NumberManager();  
public NumberManager getCommonManager() {  
    return commonManager;  
}  
public NumberManager getExpressManager() {  
    return expressManager;  
}  
public NumberManager getVipManager() {  
    return vipManager;  
}  </code></pre><p>}  </p>
<p>5、CustomerType枚举类</p>
<p>系统中有三种类型的客户，所以用定义一个枚举类，其中定义三个成员分别表示三种类型的客户。<br>重写toString方法，返回类型的中文名称。这是在后面编码时重构出来的，刚开始不用考虑。</p>
<p>public enum CustomerType {<br>    COMMON,EXPRESS,VIP;<br>    public String toString(){<br>        String name = null;<br>        switch(this){<br>        case COMMON:<br>            name = “普通”;<br>            break;<br>        case EXPRESS:<br>            name = “快速”;<br>            break;<br>        case VIP:<br>            name = name();<br>            break;<br>        }<br>        return name;<br>    }<br>}  </p>
<p>6、ServiceWindow类</p>
<p>定义一个start方法，内部启动一个线程，根据服务窗口的类别分别循环调用三个不同的方法。<br>定义三个方法分别对三种客户进行服务，为了观察运行效果，应详细打印出其中的细节信息。</p>
<p>import java.util.Random;<br>import java.util.concurrent.Executors;<br>import java.util.logging.Logger;  </p>
<p>/**  </p>
<ul>
<li><p>没有把VIP窗口和快速窗口做成子类，是因为实际业务中的普通窗口可以随时被设置为VIP窗口和快速窗口。  </p>
</li>
<li><p>*/<br>public class ServiceWindow {<br> private static Logger logger = Logger.getLogger(“cn.itcast.bankqueue”);<br> private CustomerType type = CustomerType.COMMON;<br> private int number = 1;  </p>
<p> public CustomerType getType() {  </p>
<pre><code>return type;  </code></pre><p> }  </p>
<p> public void setType(CustomerType type) {  </p>
<pre><code>this.type = type;  </code></pre><p> }  </p>
<p> public void setNumber(int number){  </p>
<pre><code>this.number = number;  </code></pre><p> }  </p>
<p> public void start(){  </p>
<pre><code>Executors.newSingleThreadExecutor().execute(  
        new Runnable(){  
            public void run(){  
                //下面这种写法的运行效率低，最好是把while放在case下面  
                while(true){  
                    switch(type){  
                        case COMMON:  
                            commonService();  
                            break;  
                        case EXPRESS:  
                            expressService();  
                            break;  
                        case VIP:  
                            vipService();  
                            break;  
                    }  
                }  
            }  
        }  
);  </code></pre><p> }  </p>
<p> private void commonService(){  </p>
<pre><code>String windowName = &quot;第&quot; + number + &quot;号&quot; + type + &quot;窗口&quot;;         
System.out.println(windowName + &quot;开始获取普通任务!&quot;);  
Integer serviceNumber = NumberMachine.getInstance().getCommonManager().fetchNumber();         
if(serviceNumber != null ){  
    System.out.println(windowName + &quot;开始为第&quot; + serviceNumber + &quot;号普通客户服务&quot;);          
    int maxRandom = Constants.MAX_SERVICE_TIME - Constants.MIN_SERVICE_TIME;  
    int serviceTime = new Random().nextInt(maxRandom)+1 + Constants.MIN_SERVICE_TIME;  

    try {  
        Thread.sleep(serviceTime);  
    } catch (InterruptedException e) {  
        e.printStackTrace();  
    }     
    System.out.println(windowName + &quot;完成为第&quot; + serviceNumber + &quot;号普通客户服务，总共耗时&quot; + serviceTime/1000 + &quot;秒&quot;);        
}else{  
    System.out.println(windowName + &quot;没有取到普通任务，正在空闲一秒&quot;);       
    try {  
        Thread.sleep(1000);  
    } catch (InterruptedException e) {  
        e.printStackTrace();  
    }                 
}  </code></pre><p> }  </p>
<p> private void expressService(){  </p>
<pre><code>Integer serviceNumber = NumberMachine.getInstance().getExpressManager().fetchNumber();  
String windowName = &quot;第&quot; + number + &quot;号&quot; + type + &quot;窗口&quot;;     
System.out.println(windowName + &quot;开始获取快速任务!&quot;);         
if(serviceNumber !=null){  
    System.out.println(windowName + &quot;开始为第&quot; + serviceNumber + &quot;号快速客户服务&quot;);              
    int serviceTime = Constants.MIN_SERVICE_TIME;  
    try {  
        Thread.sleep(serviceTime);  
    } catch (InterruptedException e) {  
        e.printStackTrace();  
    }         
    System.out.println(windowName + &quot;完成为第&quot; + serviceNumber + &quot;号快速客户服务，总共耗时&quot; + serviceTime/1000 + &quot;秒&quot;);        
}else{  
    System.out.println(windowName + &quot;没有取到快速任务！&quot;);                 
    commonService();  
}  </code></pre><p> }  </p>
<p> private void vipService(){  </p>
<pre><code>Integer serviceNumber = NumberMachine.getInstance().getVipManager().fetchNumber();  
String windowName = &quot;第&quot; + number + &quot;号&quot; + type + &quot;窗口&quot;;     
System.out.println(windowName + &quot;开始获取VIP任务!&quot;);            
if(serviceNumber !=null){  
    System.out.println(windowName + &quot;开始为第&quot; + serviceNumber + &quot;号VIP客户服务&quot;);             
    int maxRandom = Constants.MAX_SERVICE_TIME - Constants.MIN_SERVICE_TIME;  
    int serviceTime = new Random().nextInt(maxRandom)+1 + Constants.MIN_SERVICE_TIME;  
    try {  
        Thread.sleep(serviceTime);  
    } catch (InterruptedException e) {  
        e.printStackTrace();  
    }         
    System.out.println(windowName + &quot;完成为第&quot; + serviceNumber + &quot;号VIP客户服务，总共耗时&quot; + serviceTime/1000 + &quot;秒&quot;);       
}else{  
    System.out.println(windowName + &quot;没有取到VIP任务！&quot;);                
    commonService();  
}     </code></pre><p> }<br>}  </p>
</li>
</ul>
<p>7、MainClass类与Constants类</p>
<p>MainClass类<br>用for循环创建出4个普通窗口，再创建出1个快速窗口和一个VIP窗口。<br>接着再创建三个定时器，分别定时去创建新的普通客户号码、新的快速客户号码、新的VIP客户号码。<br>Constants类<br>定义三个常量：MAX_SERVICE_TIME、MIN_SERVICE_TIME、COMMON_CUSTOMER_INTERVAL_TIME</p>
<p>import java.util.concurrent.Executors;<br>import java.util.concurrent.TimeUnit;<br>import java.util.logging.Logger;  </p>
<p>public class MainClass {  </p>
<pre><code>private static Logger logger = Logger.getLogger(&quot;cn.itcast.bankqueue&quot;);  






public static void main(String[] args) {  
    //产生4个普通窗口  
    for(int i=1;i&lt;5;i++){  
        ServiceWindow window =  new ServiceWindow();  
        window.setNumber(i);  
        window.start();  
    }  

    //产生1个快速窗口  
    ServiceWindow expressWindow =  new ServiceWindow();  
    expressWindow.setType(CustomerType.EXPRESS);  
    expressWindow.start();  

    //产生1个VIP窗口       
    ServiceWindow vipWindow =  new ServiceWindow();  
    vipWindow.setType(CustomerType.VIP);  
    vipWindow.start();        

    //普通客户拿号  
    Executors.newScheduledThreadPool(1).scheduleAtFixedRate(  
            new Runnable(){  
                public void run(){  
                    Integer serviceNumber = NumberMachine.getInstance().getCommonManager().generateNewNumber();  
                    /**  
                     * 采用logger方式，无法看到直观的运行效果，因为logger.log方法内部并不是直接把内容打印出出来，  
                     * 而是交给内部的一个线程去处理，所以，打印出来的结果在时间顺序上看起来很混乱。  
                     */  
                    //logger.info(&quot;第&quot; + serviceNumber + &quot;号普通客户正在等待服务！&quot;);  
                    System.out.println(&quot;第&quot; + serviceNumber + &quot;号普通客户正在等待服务！&quot;);                         
                }  
            },  
            0,  
            Constants.COMMON_CUSTOMER_INTERVAL_TIME,   
            TimeUnit.SECONDS);  

    //快速客户拿号  
    Executors.newScheduledThreadPool(1).scheduleAtFixedRate(  
            new Runnable(){  
                public void run(){  
                    Integer serviceNumber = NumberMachine.getInstance().getExpressManager().generateNewNumber();  
                    System.out.println(&quot;第&quot; + serviceNumber + &quot;号快速客户正在等待服务！&quot;);  
                }  
            },  
            0,  
            Constants.COMMON_CUSTOMER_INTERVAL_TIME * 2,   
            TimeUnit.SECONDS);  

    //VIP客户拿号  
    Executors.newScheduledThreadPool(1).scheduleAtFixedRate(  
            new Runnable(){  
                public void run(){  
                    Integer serviceNumber = NumberMachine.getInstance().getVipManager().generateNewNumber();  
                    System.out.println(&quot;第&quot; + serviceNumber + &quot;号VIP客户正在等待服务！&quot;);  
                }  
            },  
            0,  
            Constants.COMMON_CUSTOMER_INTERVAL_TIME * 6,   
            TimeUnit.SECONDS);  
}  </code></pre><p>}  </p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/" rel="tag"># java基础学习</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/21/java%E6%9B%B4%E5%A4%9A%E7%9A%84%E7%B1%BB%E8%B0%9C%E9%A2%98/" rel="prev" title="javag更多的类谜题">
      <i class="fa fa-chevron-left"></i> javag更多的类谜题
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/22/C%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95100%E9%A2%98/" rel="next" title="C语言面试100题">
      C语言面试100题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java知识——精华总结"><span class="nav-number">1.</span> <span class="nav-text">Java知识——精华总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一、java概述与基础知识"><span class="nav-number">2.</span> <span class="nav-text">一、java概述与基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、何为编程？"><span class="nav-number">2.1.</span> <span class="nav-text">1、何为编程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、Java语言概述，历史、特点"><span class="nav-number">2.2.</span> <span class="nav-text">2、Java语言概述，历史、特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、什么是跨平台性？原理是什么？JVM"><span class="nav-number">2.3.</span> <span class="nav-text">3、什么是跨平台性？原理是什么？JVM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、Jre和Jdk的区别"><span class="nav-number">2.4.</span> <span class="nav-text">4、Jre和Jdk的区别?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、java虚拟机JVM"><span class="nav-number">2.5.</span> <span class="nav-text">5、java虚拟机JVM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、Java程序运行机制"><span class="nav-number">2.6.</span> <span class="nav-text">6、Java程序运行机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、学习java注意的地方"><span class="nav-number">2.7.</span> <span class="nav-text">7、学习java注意的地方</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8、Java语法格式"><span class="nav-number">2.8.</span> <span class="nav-text">8、Java语法格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9、代码注释：单行-，多行-，文档注释"><span class="nav-number">2.9.</span> <span class="nav-text">9、代码注释：单行&#x2F;&#x2F;，多行&#x2F;* &#x2F;，文档注释&#x2F;* *&#x2F;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10、Java中的标识符"><span class="nav-number">2.10.</span> <span class="nav-text">10、Java中的标识符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11、java中的常量和变量"><span class="nav-number">2.11.</span> <span class="nav-text">11、java中的常量和变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12、Java成员变量和局部变量"><span class="nav-number">2.12.</span> <span class="nav-text">12、Java成员变量和局部变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13、基本数据类型"><span class="nav-number">2.13.</span> <span class="nav-text">13、基本数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14、基本数据类型转换之向上转型和向下转换"><span class="nav-number">2.14.</span> <span class="nav-text">14、基本数据类型转换之向上转型和向下转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15、Java的运算符"><span class="nav-number">2.15.</span> <span class="nav-text">15、Java的运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16、表达式和三目运算符"><span class="nav-number">2.16.</span> <span class="nav-text">16、表达式和三目运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17、程序流程控制"><span class="nav-number">2.17.</span> <span class="nav-text">17、程序流程控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18、三大循环结构"><span class="nav-number">2.18.</span> <span class="nav-text">18、三大循环结构:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19、嵌套循环与流程控制"><span class="nav-number">2.19.</span> <span class="nav-text">19、嵌套循环与流程控制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、方法与数组"><span class="nav-number">3.</span> <span class="nav-text">二、方法与数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、什么是方法（Method）？"><span class="nav-number">3.1.</span> <span class="nav-text">1、什么是方法（Method）？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、Java中方法的格式："><span class="nav-number">3.2.</span> <span class="nav-text">2、Java中方法的格式：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、方法里的属性"><span class="nav-number">3.3.</span> <span class="nav-text">3、方法里的属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、方法特点"><span class="nav-number">3.4.</span> <span class="nav-text">4、方法特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、什么是方法的重载（Overload）？"><span class="nav-number">3.5.</span> <span class="nav-text">5、什么是方法的重载（Overload）？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、可变参数"><span class="nav-number">3.6.</span> <span class="nav-text">6、可变参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、数组简介："><span class="nav-number">3.7.</span> <span class="nav-text">7、数组简介：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9、数组的使用："><span class="nav-number">3.8.</span> <span class="nav-text">9、数组的使用：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10、分配内存空间"><span class="nav-number">3.9.</span> <span class="nav-text">10、分配内存空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11、二维数组："><span class="nav-number">3.10.</span> <span class="nav-text">11、二维数组：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12、操作数组的工具类-Arrays"><span class="nav-number">3.11.</span> <span class="nav-text">12、操作数组的工具类-Arrays</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13、Java5新特性对数组的支持："><span class="nav-number">3.12.</span> <span class="nav-text">13、Java5新特性对数组的支持：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、面向对象（1）"><span class="nav-number">4.</span> <span class="nav-text">三、面向对象（1）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、什么叫面向对象？"><span class="nav-number">4.1.</span> <span class="nav-text">1、什么叫面向对象？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、类"><span class="nav-number">4.2.</span> <span class="nav-text">2、类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、构造方法"><span class="nav-number">4.3.</span> <span class="nav-text">3、构造方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、static关键字"><span class="nav-number">4.4.</span> <span class="nav-text">4、static关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、匿名对象"><span class="nav-number">4.5.</span> <span class="nav-text">5、匿名对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、this关键字"><span class="nav-number">4.6.</span> <span class="nav-text">6、this关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、面向对象之封装"><span class="nav-number">4.7.</span> <span class="nav-text">7、面向对象之封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8、访问修饰符"><span class="nav-number">4.8.</span> <span class="nav-text">8、访问修饰符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9、类的设计分析"><span class="nav-number">4.9.</span> <span class="nav-text">9、类的设计分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10、面向对象之继承"><span class="nav-number">4.10.</span> <span class="nav-text">10、面向对象之继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11、子类访问父类和方法覆写"><span class="nav-number">4.11.</span> <span class="nav-text">11、子类访问父类和方法覆写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12、super关键字和调用父类构造方法"><span class="nav-number">4.12.</span> <span class="nav-text">12、super关键字和调用父类构造方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13、面向对象之多态"><span class="nav-number">4.13.</span> <span class="nav-text">13、面向对象之多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14、引用变量类型转换"><span class="nav-number">4.14.</span> <span class="nav-text">14、引用变量类型转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四、面向对象（2）"><span class="nav-number">5.</span> <span class="nav-text">四、面向对象（2）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、基本数据类型的包装类"><span class="nav-number">5.1.</span> <span class="nav-text">1、基本数据类型的包装类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、基本数据类型和包装类相互转换"><span class="nav-number">5.2.</span> <span class="nav-text">2、基本数据类型和包装类相互转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、基本类型和String之间的转换"><span class="nav-number">5.3.</span> <span class="nav-text">3、基本类型和String之间的转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、Object类"><span class="nav-number">5.4.</span> <span class="nav-text">4、Object类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、代码块"><span class="nav-number">5.5.</span> <span class="nav-text">5、代码块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、构造方法的私有化"><span class="nav-number">5.6.</span> <span class="nav-text">6、构造方法的私有化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、Singleton模式-单例模式-饿汉式和懒汉式"><span class="nav-number">5.7.</span> <span class="nav-text">7、Singleton模式(单例模式) 饿汉式和懒汉式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8、final-关键字"><span class="nav-number">5.8.</span> <span class="nav-text">8、final 关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9、抽象类"><span class="nav-number">5.9.</span> <span class="nav-text">9、抽象类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10、抽象类的体现-模板模式"><span class="nav-number">5.10.</span> <span class="nav-text">10、抽象类的体现-模板模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11、接口-interface"><span class="nav-number">5.11.</span> <span class="nav-text">11、接口(interface)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12、接口的使用"><span class="nav-number">5.12.</span> <span class="nav-text">12、接口的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13、面向接口编程之制定标准和简单工厂模式"><span class="nav-number">5.13.</span> <span class="nav-text">13、面向接口编程之制定标准和简单工厂模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14、面向接口编程之适配器模式"><span class="nav-number">5.14.</span> <span class="nav-text">14、面向接口编程之适配器模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15、接口和抽象类的比较"><span class="nav-number">5.15.</span> <span class="nav-text">15、接口和抽象类的比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16、匿名内部类"><span class="nav-number">5.16.</span> <span class="nav-text">16、匿名内部类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17、枚举类"><span class="nav-number">5.17.</span> <span class="nav-text">17、枚举类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#五、异常处理和常用类"><span class="nav-number">6.</span> <span class="nav-text">五、异常处理和常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、异常"><span class="nav-number">6.1.</span> <span class="nav-text">1、异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、异常处理格式"><span class="nav-number">6.2.</span> <span class="nav-text">2、异常处理格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、多异常处理"><span class="nav-number">6.3.</span> <span class="nav-text">3、多异常处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、异常的分类"><span class="nav-number">6.4.</span> <span class="nav-text">4、异常的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、声明异常（throws）"><span class="nav-number">6.5.</span> <span class="nav-text">5、声明异常（throws）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、throw"><span class="nav-number">6.6.</span> <span class="nav-text">6、throw</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、finally"><span class="nav-number">6.7.</span> <span class="nav-text">7、finally</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8、throw和catch同时使用"><span class="nav-number">6.8.</span> <span class="nav-text">8、throw和catch同时使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9、常用类"><span class="nav-number">6.9.</span> <span class="nav-text">9、常用类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10、String方法"><span class="nav-number">6.10.</span> <span class="nav-text">10、String方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11、StringBuffer和StringBuild"><span class="nav-number">6.11.</span> <span class="nav-text">11、StringBuffer和StringBuild</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12、Math和Random和UUID"><span class="nav-number">6.12.</span> <span class="nav-text">12、Math和Random和UUID</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13、Date和Calendar"><span class="nav-number">6.13.</span> <span class="nav-text">13、Date和Calendar</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14、System"><span class="nav-number">6.14.</span> <span class="nav-text">14、System</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#六、线程技术"><span class="nav-number">7.</span> <span class="nav-text">六、线程技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、进程和线程"><span class="nav-number">7.1.</span> <span class="nav-text">1、进程和线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、创建线程方式"><span class="nav-number">7.2.</span> <span class="nav-text">2、创建线程方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、两种进程创建方式比较"><span class="nav-number">7.3.</span> <span class="nav-text">3、两种进程创建方式比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、线程的生命周期"><span class="nav-number">7.4.</span> <span class="nav-text">4、线程的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、控制线程"><span class="nav-number">7.5.</span> <span class="nav-text">5、控制线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、多线程安全问题"><span class="nav-number">7.6.</span> <span class="nav-text">6、多线程安全问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、多线程安全问题的解决方法"><span class="nav-number">7.7.</span> <span class="nav-text">7、多线程安全问题的解决方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8、线程通信"><span class="nav-number">7.8.</span> <span class="nav-text">8、线程通信</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#七、集合框架（1）"><span class="nav-number">8.</span> <span class="nav-text">七、集合框架（1）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、集合类-amp-容器"><span class="nav-number">8.1.</span> <span class="nav-text">1、集合类 &amp;  容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、Collection接口"><span class="nav-number">8.2.</span> <span class="nav-text">2、Collection接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、Iterator接口"><span class="nav-number">8.3.</span> <span class="nav-text">3、Iterator接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、集合遍历输出方式"><span class="nav-number">8.4.</span> <span class="nav-text">4、集合遍历输出方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、Set接口（元素不可以重复）"><span class="nav-number">8.5.</span> <span class="nav-text">5、Set接口（元素不可以重复）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、TreeSet"><span class="nav-number">8.6.</span> <span class="nav-text">6、TreeSet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、List接口"><span class="nav-number">8.7.</span> <span class="nav-text">7、List接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8、List接口中常用类"><span class="nav-number">8.8.</span> <span class="nav-text">8、List接口中常用类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9、Map接口"><span class="nav-number">8.9.</span> <span class="nav-text">9、Map接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#八、集合框架（2）"><span class="nav-number">9.</span> <span class="nav-text">八、集合框架（2）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、Collections类"><span class="nav-number">9.1.</span> <span class="nav-text">1、Collections类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、Arrays"><span class="nav-number">9.2.</span> <span class="nav-text">2、Arrays</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、泛型-Generic"><span class="nav-number">9.3.</span> <span class="nav-text">3、泛型(Generic)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、泛型的使用"><span class="nav-number">9.4.</span> <span class="nav-text">4、泛型的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、声明多个泛型类型和通配符"><span class="nav-number">9.5.</span> <span class="nav-text">5、声明多个泛型类型和通配符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、泛型的上限与下限"><span class="nav-number">9.6.</span> <span class="nav-text">6、泛型的上限与下限</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、泛型接口和方法"><span class="nav-number">9.7.</span> <span class="nav-text">7、泛型接口和方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#九、IO操作（1）"><span class="nav-number">10.</span> <span class="nav-text">九、IO操作（1）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、IO的概述和File方法"><span class="nav-number">10.1.</span> <span class="nav-text">1、IO的概述和File方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、递归-Recursion"><span class="nav-number">10.2.</span> <span class="nav-text">2、递归(Recursion)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、文件过滤器-java-io-FilenameFilter"><span class="nav-number">10.3.</span> <span class="nav-text">3、文件过滤器 java.io.FilenameFilter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、流"><span class="nav-number">10.4.</span> <span class="nav-text">4、流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、操作流的步骤（重点）"><span class="nav-number">10.5.</span> <span class="nav-text">5、操作流的步骤（重点）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、字节流和字符流"><span class="nav-number">10.6.</span> <span class="nav-text">6、字节流和字符流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、文件拷贝"><span class="nav-number">10.7.</span> <span class="nav-text">7、文件拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8、字节→字符转换流"><span class="nav-number">10.8.</span> <span class="nav-text">8、字节→字符转换流</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十、IO文件操作（2）"><span class="nav-number">11.</span> <span class="nav-text">十、IO文件操作（2）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、内存操作流"><span class="nav-number">11.1.</span> <span class="nav-text">1、内存操作流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、打印流"><span class="nav-number">11.2.</span> <span class="nav-text">2、打印流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、格式化输出"><span class="nav-number">11.3.</span> <span class="nav-text">3、格式化输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、标准流"><span class="nav-number">11.4.</span> <span class="nav-text">4、标准流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、Scanner-简单文本扫描器"><span class="nav-number">11.5.</span> <span class="nav-text">5、Scanner(简单文本扫描器)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、缓冲流"><span class="nav-number">11.6.</span> <span class="nav-text">6、缓冲流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、合并流（SequenceInputStream）"><span class="nav-number">11.7.</span> <span class="nav-text">7、合并流（SequenceInputStream）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十一、网络编程"><span class="nav-number">12.</span> <span class="nav-text">十一、网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、什么是网络编程？"><span class="nav-number">12.1.</span> <span class="nav-text">1、什么是网络编程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、网络通讯要素"><span class="nav-number">12.2.</span> <span class="nav-text">2、网络通讯要素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、TCP和UDP的联系和用途"><span class="nav-number">12.3.</span> <span class="nav-text">3、TCP和UDP的联系和用途</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、InetAddress与Socket"><span class="nav-number">12.4.</span> <span class="nav-text">4、InetAddress与Socket</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、UDP传输"><span class="nav-number">12.5.</span> <span class="nav-text">5、UDP传输</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、TCP传输"><span class="nav-number">12.6.</span> <span class="nav-text">6、TCP传输</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、利用TCP上传文件"><span class="nav-number">12.7.</span> <span class="nav-text">7、利用TCP上传文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十二、反射机制"><span class="nav-number">13.</span> <span class="nav-text">十二、反射机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、反射的概念"><span class="nav-number">13.1.</span> <span class="nav-text">1、反射的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、获得Class对象"><span class="nav-number">13.2.</span> <span class="nav-text">2、获得Class对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、九个预定义Class对象"><span class="nav-number">13.3.</span> <span class="nav-text">3、九个预定义Class对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、利用Class获取类的属性信息"><span class="nav-number">13.4.</span> <span class="nav-text">4、利用Class获取类的属性信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、Class中得到构造方法Constructor、方法Method、字段Field"><span class="nav-number">13.5.</span> <span class="nav-text">5、Class中得到构造方法Constructor、方法Method、字段Field</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、利用反射创建对象"><span class="nav-number">13.6.</span> <span class="nav-text">6、利用反射创建对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、使用反射调用方法"><span class="nav-number">13.7.</span> <span class="nav-text">7、使用反射调用方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8、使用反射调用可变参数方法"><span class="nav-number">13.8.</span> <span class="nav-text">8、使用反射调用可变参数方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9、使用反射操作字段"><span class="nav-number">13.9.</span> <span class="nav-text">9、使用反射操作字段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10、反射和泛型-反射来获取泛型信息"><span class="nav-number">13.10.</span> <span class="nav-text">10、反射和泛型-反射来获取泛型信息</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十三、反射机制"><span class="nav-number">14.</span> <span class="nav-text">十三、反射机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、GUI-图形用户界面"><span class="nav-number">14.1.</span> <span class="nav-text">1、GUI(图形用户界面)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、布局管理器"><span class="nav-number">14.2.</span> <span class="nav-text">2、布局管理器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、事件监听机制组成"><span class="nav-number">14.3.</span> <span class="nav-text">3、事件监听机制组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、Dialog"><span class="nav-number">14.4.</span> <span class="nav-text">4、Dialog</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、菜单"><span class="nav-number">14.5.</span> <span class="nav-text">5、菜单</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、Eclipse的使用技巧"><span class="nav-number">14.5.1.</span> <span class="nav-text">1、Eclipse的使用技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、静态导入（1-5特性，好处是不用写类名）"><span class="nav-number">14.5.2.</span> <span class="nav-text">2、静态导入（1.5特性，好处是不用写类名）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、可变参数"><span class="nav-number">14.5.3.</span> <span class="nav-text">3、可变参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、增强for循环"><span class="nav-number">14.5.4.</span> <span class="nav-text">4、增强for循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、基本数据类型的自动拆箱与装箱"><span class="nav-number">14.5.5.</span> <span class="nav-text">5、基本数据类型的自动拆箱与装箱</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、枚举"><span class="nav-number">14.6.</span> <span class="nav-text">6、枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、反射实现框架功能"><span class="nav-number">14.7.</span> <span class="nav-text">7、反射实现框架功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1、内省了解JavaBean"><span class="nav-number">14.8.</span> <span class="nav-text">1、内省了解JavaBean</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、内省综合案例和Beanutils工具包"><span class="nav-number">14.9.</span> <span class="nav-text">2、内省综合案例和Beanutils工具包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、注解（Annotation）"><span class="nav-number">14.10.</span> <span class="nav-text">3、注解（Annotation）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、泛型"><span class="nav-number">14.11.</span> <span class="nav-text">4、泛型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型参数的类型推断"><span class="nav-number">14.12.</span> <span class="nav-text">类型参数的类型推断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1、类加载器"><span class="nav-number">14.13.</span> <span class="nav-text">1、类加载器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、类加载器的委托机制"><span class="nav-number">14.14.</span> <span class="nav-text">2、类加载器的委托机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、一个类加载器的高级问题分析"><span class="nav-number">14.15.</span> <span class="nav-text">3、一个类加载器的高级问题分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、代理的概念与作用"><span class="nav-number">14.16.</span> <span class="nav-text">4、代理的概念与作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、动态代理技术"><span class="nav-number">14.17.</span> <span class="nav-text">5、动态代理技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、分析JVM动态生成的类"><span class="nav-number">14.18.</span> <span class="nav-text">6、分析JVM动态生成的类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、综合示例代码："><span class="nav-number">14.19.</span> <span class="nav-text">7、综合示例代码：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8、实现类似spring的可配置的AOP框架"><span class="nav-number">14.20.</span> <span class="nav-text">8、实现类似spring的可配置的AOP框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、实现类似spring的可配置的AOP框架的思路："><span class="nav-number">14.21.</span> <span class="nav-text">二、实现类似spring的可配置的AOP框架的思路：</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">匡俊桦</p>
  <div class="site-description" itemprop="description">回忆的沙漏将曾经屈指可数的日子渐渐淡去</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">276</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">匡俊桦</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">2.3m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">35:08</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
