<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Java 谜题 Java 谜题 4——异常谜题谜题 36：优柔寡断下面这个可怜的小程序并不能很好地做出其自己的决定。它的 decision 方法将 返回 true，但是它还返回了 false。那么，它到底打印的是什么呢？甚至，它是 合法的吗？  1234567891011121314151617181920212223public class Indecisive &amp;#123;  public s">
<meta property="og:type" content="article">
<meta property="og:title" content="java异常谜题">
<meta property="og:url" content="http://yoursite.com/2021/03/20/java%E5%BC%82%E5%B8%B8%E8%B0%9C%E9%A2%98/index.html">
<meta property="og:site_name" content="KJHの博客">
<meta property="og:description" content="Java 谜题 Java 谜题 4——异常谜题谜题 36：优柔寡断下面这个可怜的小程序并不能很好地做出其自己的决定。它的 decision 方法将 返回 true，但是它还返回了 false。那么，它到底打印的是什么呢？甚至，它是 合法的吗？  1234567891011121314151617181920212223public class Indecisive &amp;#123;  public s">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-20T14:36:01.688Z">
<meta property="article:modified_time" content="2021-03-21T14:38:17.847Z">
<meta property="article:author" content="匡俊桦">
<meta property="article:tag" content="java进阶学习">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2021/03/20/java%E5%BC%82%E5%B8%B8%E8%B0%9C%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>java异常谜题 | KJHの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KJHの博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录&回忆</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/20/java%E5%BC%82%E5%B8%B8%E8%B0%9C%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java异常谜题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-20 22:36:01" itemprop="dateCreated datePublished" datetime="2021-03-20T22:36:01+08:00">2021-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-21 22:38:17" itemprop="dateModified" datetime="2021-03-21T22:38:17+08:00">2021-03-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Java-谜题-Java-谜题-4——异常谜题"><a href="#Java-谜题-Java-谜题-4——异常谜题" class="headerlink" title="Java 谜题 Java 谜题 4——异常谜题"></a>Java 谜题 Java 谜题 4——异常谜题</h1><h2 id="谜题-36：优柔寡断"><a href="#谜题-36：优柔寡断" class="headerlink" title="谜题 36：优柔寡断"></a>谜题 36：优柔寡断</h2><p>下面这个可怜的小程序并不能很好地做出其自己的决定。它的 decision 方法将</p>
<p>返回 true，但是它还返回了 false。那么，它到底打印的是什么呢？甚至，它是</p>
<p>合法的吗？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Indecisive</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(decision()); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">decision</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line"></span><br><span class="line"> &#125; finally &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>你可能会认为这个程序是不合法的。毕竟，decision 方法不能同时返回 true 和</p>
<p>false。如果你尝试一下，就会发现它编译时没有任何错误，并且它所打印的是</p>
<p>false。为什么呢？ </p>
<p>原因就是在一个 try-finally 语句中，finally 语句块总是在控制权离开 try 语</p>
<p>句块时执行的[JLS 14.20.2]。无论 try 语句块是正常结束的，还是意外结束的，</p>
<p>情况都是如此。一条语句或一个语句块在它抛出了一个异常，或者对某个封闭型</p>
<p>语句执行了一个 break 或 continue，或是象这个程序一样在方法中执行了一个</p>
<p>return 时，将发生意外结束。它们之所以被称为意外结束，是因为它们阻止程</p>
<p>序去按顺序执行下面的语句。 当 try 语句块和 finally 语句块都意外结束时，在 try 语句块中引发意外结束的</p>
<p>原因将被丢弃，而整个 try-finally 语句意外结束的原因将于 finally 语句块意</p>
<p>外结束的原因相同。在这个程序中，在 try 语句块中的 return 语句所引发的意</p>
<p>外结束将被丢弃，而 try-finally 语句意外结束是由 finally 语句块中的 return</p>
<p>造成的。简单地讲，程序尝试着（try）返回（return）true，但是它最终（finally）</p>
<p>返回（return）的是 false。 </p>
<p>丢弃意外结束的原因几乎永远都不是你想要的行为，因为意外结束的最初原因可</p>
<p>能对程序的行为来说会显得更重要。对于那些在 try 语句块中执行 break、</p>
<p>continue 或 return 语句，只是为了使其行为被 finally 语句块所否决掉的程序，</p>
<p>要理解其行为是特别困难的。 </p>
<p>总之，每一个 finally 语句块都应该正常结束，除非抛出的是不受检查的异常。</p>
<p>千万不要用一个 return、break、continue 或 throw 来退出一个 finally 语句块，</p>
<p>并且千万不要允许将一个受检查的异常传播到一个 finally 语句块之外去。 </p>
<p>对于语言设计者，也许应该要求 finally 语句块在未出现不受检查的异常时必须</p>
<p>正常结束。朝着这个目标，try-finally 结构将要求 finally 语句块可以正常结</p>
<p>束[JLS 14.21]。return、break 或 continue 语句把控制权传递到 finally 语句</p>
<p>块之外应该是被禁止的，任何可以引发将被检查异常传播到 finally 语句块之外</p>
<p>的语句也同样应该是被禁止的。 </p>
<h2 id="谜题-37：极端不可思议"><a href="#谜题-37：极端不可思议" class="headerlink" title="谜题 37：极端不可思议"></a>谜题 37：极端不可思议</h2><p>本谜题测试的是你对某些规则的掌握程度，这些规则用于声明从方法中抛出并被</p>
<p>catch 语句块所捕获的异常。下面的三个程序每一个都会打印些什么？不要假设</p>
<p>它们都可以通过编译： </p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Arcane1 &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println(<span class="string">"Hello world"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span>(IOException e) &#123; </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println(<span class="string">"I've never seen </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> println fail!"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Arcane2 &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// If you have nothing nice to say, say nothing</span></span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span>(Exception e) &#123; System.<span class="keyword">out</span>.println(<span class="string">"This can't </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> happen"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Type1 &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> f() throws CloneNotSupportedException; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Type2 &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> f() throws InterruptedException; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Type3 extends Type1, Type2 &#123; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Arcane3 implements Type3 &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> f() &#123; </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println(<span class="string">"Hello world"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123; </span><br><span class="line"></span><br><span class="line"> Type3 t3 = <span class="keyword">new</span> Arcane3(); </span><br><span class="line"></span><br><span class="line"> t3.f(); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个程序，Arcane1，展示了被检查异常的一个基本原则。它看起来应该是可</p>
<p>以编译的：try 子句执行 I/O，并且 catch 子句捕获 IOException 异常。但是这</p>
<p>个程序不能编译，因为 println 方法没有声明会抛出任何被检查异常，而</p>
<p>IOException 却正是一个被检查异常。语言规范中描述道：如果一个 catch 子句</p>
<p>要捕获一个类型为 E 的被检查异常，而其相对应的 try 子句不能抛出 E 的某种子</p>
<p>类型的异常，那么这就是一个编译期错误[JLS 11.2.3]。 </p>
<p>基于同样的理由，第二个程序，Arcane2，看起来应该是不可以编译的，但是它</p>
<p>却可以。它之所以可以编译，是因为它唯一的 catch 子句检查了 Exception。尽</p>
<p>管 JLS 在这一点上十分含混不清，但是捕获 Exception 或 Throwble 的 catch 子</p>
<p>句是合法的，不管与其相对应的 try 子句的内容为何。尽管 Arcane2 是一个合法</p>
<p>的程序，但是 catch 子句的内容永远的不会被执行，这个程序什么都不会打印。 </p>
<p>第三个程序，Arcane3，看起来它也不能编译。方法 f 在 Type1 接口中声明要抛</p>
<p>出被检查异常 CloneNotSupportedException，并且在 Type2 接口中声明要抛出</p>
<p>被检查异常 InterruptedException。Type3 接口继承了 Type1 和 Type2，因此，</p>
<p>看起来在静态类型为Type3的对象上调用方法f时，有潜在可能会抛出这些异常。</p>
<p>一个方法必须要么捕获其方法体可以抛出的所有被检查异常，要么声明它将抛出这些异常。Arcane3 的 main 方法在静态类型为 Type3 的对象上调用了方法 f，但</p>
<p>它对 CloneNotSupportedException 和 InterruptedExceptioin 并没有作这些处</p>
<p>理。那么，为什么这个程序可以编译呢？ </p>
<p>上述分析的缺陷在于对“Type3.f 可以抛出在 Type1.f 上声明的异常和在</p>
<p>Type2.f 上声明的异常”所做的假设。这并不正确，因为每一个接口都限制了方</p>
<p>法 f 可以抛出的被检查异常集合。一个方法可以抛出的被检查异常集合是它所适</p>
<p>用的所有类型声明要抛出的被检查异常集合的交集，而不是合集。因此，静态类</p>
<p>型为 Type3 的对象上的 f 方法根本就不能抛出任何被检查异常。因此，Arcane3</p>
<p>可以毫无错误地通过编译，并且打印 Hello world。 </p>
<p>总之，第一个程序说明了一项基本要求，即对于捕获被检查异常的 catch 子句，</p>
<p>只有在相应的 try 子句可以抛出这些异常时才被允许。第二个程序说明了这项要</p>
<p>求不会应用到的冷僻案例。第三个程序说明了多个继承而来的 throws 子句的交</p>
<p>集，将减少而不是增加方法允许抛出的异常数量。本谜题所说明的行为一般不会</p>
<p>引发难以捉摸的 bug，但是你第一次看到它们时，可能会有点吃惊。 </p>
<h2 id="谜题-38：不受欢迎的宾客-不受欢迎的宾客"><a href="#谜题-38：不受欢迎的宾客-不受欢迎的宾客" class="headerlink" title="谜题 38：不受欢迎的宾客 不受欢迎的宾客"></a>谜题 38：不受欢迎的宾客 不受欢迎的宾客</h2><p>本谜题中的程序所建模的系统，将尝试着从其环境中读取一个用户 ID，如果这</p>
<p>种尝试失败了，则缺省地认为它是一个来宾用户。该程序的作者将面对有一个静</p>
<p>态域的初始化表达式可能会抛出异常的情况。因为 Java 不允许静态初始化操作</p>
<p>抛出被检查异常，所以初始化必须包装在 try-finally 语句块中。那么，下面的</p>
<p>程序会打印出什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnwelcomeGuest</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> GUEST_USER_ID = <span class="number">-1</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> USER_ID; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> USER_ID = getUserIdFromEnvironment(); </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (IdUnavailableException e) &#123; </span><br><span class="line"></span><br><span class="line"> USER_ID = GUEST_USER_ID; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"Logging in as guest"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getUserIdFromEnvironment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> throws IdUnavailableException </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> IdUnavailableException(); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"User ID: "</span> + USER_ID); </span><br><span class="line"></span><br><span class="line"> &#125; &#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IdUnavailableException</span> <span class="title">extends</span> <span class="title">Exception</span> &#123;</span> </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序看起来很直观。对 getUserIdFromEnvironment 的调用将抛出一个异常，</p>
<p>从而使程序将 GUEST_USER_ID(-1L)赋值给 USER_ID，并打印 Loggin in as guest。</p>
<p>然后 main 方法执行，使程序打印 User ID: -1。表象再次欺骗了我们，该程序</p>
<p>并不能编译。如果你尝试着去编译它，你将看到和下面内容类似的一条错误信息： </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">UnwelcomeGuest.java:10</span>: </span><br><span class="line"></span><br><span class="line">variable USER_ID might already have been assigned </span><br><span class="line"></span><br><span class="line"> USER_ID = GUEST_USER_ID; </span><br><span class="line"></span><br><span class="line"> ^</span><br></pre></td></tr></table></figure>

<p>问题出在哪里了？USER_ID 域是一个空 final（blank final），它是一个在声明</p>
<p>中没有进行初始化操作的 final 域[JLS 4.12.4]。很明显，只有在对 USER_ID</p>
<p>赋值失败时，才会在 try 语句块中抛出异常，因此，在 catch 语句块中赋值是相</p>
<p>当安全的。不管怎样执行静态初始化操作语句块，只会对 USER_ID 赋值一次，这</p>
<p>正是空 final 所要求的。为什么编译器不知道这些呢？ </p>
<p>要确定一个程序是否可以不止一次地对一个空 final 进行赋值是一个很困难的</p>
<p>问题。事实上，这是不可能的。这等价于经典的停机问题，它通常被认为是不可</p>
<p>能解决的[Turing 36]。为了能够编写出一个编译器，语言规范在这一点上采用</p>
<p>了保守的方式。在程序中，一个空 final 域只有在它是明确未赋过值的地方才可</p>
<p>以被赋值。规范长篇大论，对此术语提供了一个准确的但保守的定义[JLS 16]。</p>
<p>因为它是保守的，所以编译器必须拒绝某些可以证明是安全的程序。这个谜题就</p>
<p>展示了这样的一个程序。 </p>
<p>幸运的是，你不必为了编写 Java 程序而去学习那些骇人的用于明确赋值的细节。</p>
<p>通常明确赋值规则不会有任何妨碍。如果碰巧你编写了一个真的可能会对一个空</p>
<p>final 赋值超过一次的程序，编译器会帮你指出的。只有在极少的情况下，就像</p>
<p>本谜题一样，你才会编写出一个安全的程序，但是它并不满足规范的形式化要求。</p>
<p>编译器的抱怨就好像是你编写了一个不安全的程序一样，而且你必须修改你的程</p>
<p>序以满足它。 </p>
<p>解决这类问题的最好方式就是将这个烦人的域从空 final 类型改变为普通的</p>
<p>final 类型，用一个静态域的初始化操作替换掉静态的初始化语句块。实现这一</p>
<p>点的最佳方式是重构静态语句块中的代码为一个助手方法： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnwelcomeGuest</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> GUEST_USER_ID = <span class="number">-1</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> USER_ID = getUserIdOrGuest; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> getUserIdOrGuest &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> getUserIdFromEnvironment(); &#125; <span class="keyword">catch</span> (IdUnavailableException e) &#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"Logging in as guest"</span>); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> GUEST_USER_ID; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> ...<span class="comment">// The rest of the program is unchanged </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的这个版本很显然是正确的，而且比最初的版本根据可读性，因为它为了域</p>
<p>值的计算而增加了一个描述性的名字，而最初的版本只有一个匿名的静态初始化</p>
<p>操作语句块。将这样的修改作用于程序，它就可以如我们的期望来运行了。 </p>
<p>总之，大多数程序员都不需要学习明确赋值规则的细节。该规则的作为通常都是</p>
<p>正确的。如果你必须重构一个程序，以消除由明确赋值规则所引发的错误，那么</p>
<p>你应该考虑添加一个新方法。这样做除了可以解决明确赋值问题，还可以使程序</p>
<p>的可读性提高。 </p>
<h2 id="谜题-39：您好，再见！"><a href="#谜题-39：您好，再见！" class="headerlink" title="谜题 39：您好，再见！"></a>谜题 39：您好，再见！</h2><p>下面的程序在寻常的 Hello world 程序中添加了一段不寻常的曲折操作。那么，</p>
<p>它将会打印出什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloGoodbye</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"Hello world"</span>); </span><br><span class="line"></span><br><span class="line"> System.<span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"> &#125; finally &#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"Goodbye world"</span>);</span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序包含两个 println 语句：一个在 try 语句块中，另一个在相应的 finally</p>
<p>语句块中。try 语句块执行它的 println 语句，并且通过调用 System.exit 来提</p>
<p>前结束执行。在此时，你可能希望控制权会转交给 finally 语句块。然而，如果</p>
<p>你运行该程序，就会发现它永远不会说再见：它只打印了 Hello world。这是否</p>
<p>违背了谜题 36 中所解释的原则呢？ </p>
<p>不论 try 语句块的执行是正常地还是意外地结束，finally 语句块确实都会执行。</p>
<p>然而在这个程序中，try 语句块根本就没有结束其执行过程。System.exit 方法</p>
<p>将停止当前线程和所有其他当场死亡的线程。finally 子句的出现并不能给予线</p>
<p>程继续去执行的特殊权限。 当 System.exit 被调用时，虚拟机在关闭前要执行两项清理工作。首先，它执行</p>
<p>所有的关闭挂钩操作，这些挂钩已经注册到了 Runtime.addShutdownHook 上。这</p>
<p>对于释放 VM 之外的资源将很有帮助。务必要为那些必须在 VM 退出之前发生的行</p>
<p>为关闭挂钩。下面的程序版本示范了这种技术，它可以如我们所期望地打印出</p>
<p>Hello world 和 Goodbye world： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloGoodbye1</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"Hello world"</span>); </span><br><span class="line"></span><br><span class="line"> Runtime.getRuntime().addShutdownHook( </span><br><span class="line"></span><br><span class="line"> <span class="keyword">new</span> Thread() &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"Goodbye world"</span>);</span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125;); </span><br><span class="line"></span><br><span class="line"> System.<span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VM 执行在 System.exit 被调用时执行的第二个清理任务与终结器有关。如果</p>
<p>System.runFinalizerOnExit 或它的魔鬼双胞胎 Runtime.runFinalizersOnExit</p>
<p>被调用了，那么 VM 将在所有还未终结的对象上面调用终结器。这些方法很久以</p>
<p>前就已经过时了，而且其原因也很合理。无论什么原因，永远不要调用</p>
<p>System.runFinalizersOnExit 和 Runtime.runFinalizersOnExit：它们属于 Java</p>
<p>类库中最危险的方法之一[ThreadStop]。调用这些方法导致的结果是，终结器会</p>
<p>在那些其他线程正在并发操作的对象上面运行，从而导致不确定的行为或导致死</p>
<p>锁。 </p>
<p>总之，System.exit 将立即停止所有的程序线程，它并不会使 finally 语句块得</p>
<p>到调用，但是它在停止 VM 之前会执行关闭挂钩操作。当 VM 被关闭时，请使用关</p>
<p>闭挂钩来终止外部资源。通过调用 System.halt 可以在不执行关闭挂钩的情况下</p>
<p>停止 VM，但是这个方法很少使用。 </p>
<h2 id="谜题-40：不情愿的构造器-不情愿的构造器"><a href="#谜题-40：不情愿的构造器-不情愿的构造器" class="headerlink" title="谜题 40：不情愿的构造器 不情愿的构造器"></a>谜题 40：不情愿的构造器 不情愿的构造器</h2><p>尽管在一个方法声明中看到一个 throws 子句是很常见的，但是在构造器的声明</p>
<p>中看到一个 throws 子句就很少见了。下面的程序就有这样的一个声明。那么，</p>
<p>它将打印出什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reluctant</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Reluctant internalInstance = <span class="keyword">new</span> Reluctant(); </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Reluctant</span><span class="params">()</span> throws Exception </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"I'm not coming out"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; Reluctant b = <span class="keyword">new</span> Reluctant(); </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"Surprise!"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (Exception ex) &#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"I told you so"</span>);</span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main 方法调用了 Reluctant 构造器，它将抛出一个异常。你可能期望 catch 子</p>
<p>句能够捕获这个异常，并且打印 I told you so。凑近仔细看看这个程序就会发</p>
<p>现，Reluctant 实例还包含第二个内部实例，它的构造器也会抛出一个异常。无</p>
<p>论抛出哪一个异常，看起来 main 中的 catch 子句都应该捕获它，因此预测该程</p>
<p>序将打印 I told you 应该是一个安全的赌注。但是当你尝试着去运行它时，就</p>
<p>会发现它压根没有去做这类的事情：它抛出了 StackOverflowError 异常，为什</p>
<p>么呢？ </p>
<p>与大多数抛出 StackOverflowError 异常的程序一样，本程序也包含了一个无限</p>
<p>递归。当你调用一个构造器时，实例变量的初始化操作将先于构造器的程序体而</p>
<p>运行[JLS 12.5]。在本谜题中， internalInstance 变量的初始化操作递归调用</p>
<p>了构造器，而该构造器通过再次调用 Reluctant 构造器而初始化该变量自己的</p>
<p>internalInstance 域，如此无限递归下去。这些递归调用在构造器程序体获得</p>
<p>执行机会之前就会抛出 StackOverflowError 异常，因为 StackOverflowError</p>
<p>是 Error 的子类型而不是 Exception 的子类型，所以 catch 子句无法捕获它。 </p>
<p>对于一个对象包含与它自己类型相同的实例的情况，并不少见。例如，链接列表</p>
<p>节点、树节点和图节点都属于这种情况。你必须非常小心地初始化这样的包含实</p>
<p>例，以避免 StackOverflowError 异常。 </p>
<p>至于本谜题名义上的题目：声明将抛出异常的构造器，你需要注意，构造器必须</p>
<p>声明其实例初始化操作会抛出的所有被检查异常。下面这个展示了常见的“服务</p>
<p>提供商”模式的程序，将不能编译，因为它违反了这条规则： </p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Class engineClass = ...; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Engine engine = </span><br><span class="line"></span><br><span class="line"> (Engine)enginClass.<span class="keyword">new</span><span class="type">Instance</span>(); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> Car()&#123; &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管其构造器没有任何程序体，但是它将抛出两个被检查异常，</p>
<p>InstantiationException 和 IllegalAccessException。它们是 Class.Instance</p>
<p>抛出的，该方法是在初始化 engine 域的时候被调用的。订正该程序的最好方式</p>
<p>是创建一个私有的、静态的助手方法，它负责计算域的初始值，并恰当地处理异</p>
<p>常。在本案中，我们假设选择 engineClass 所引用的 Class 对象，保证它是可访</p>
<p>问的并且是可实例化的。 </p>
<p>下面的 Car 版本将可以毫无错误地通过编译： //Fixed - instance initializers don’t throw checked exceptions </p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Class engineClass = ...; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Engine engine = <span class="keyword">new</span><span class="type">Engine</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Engine <span class="keyword">new</span><span class="type">Engine</span>() &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> (Engine)engineClass.<span class="keyword">new</span><span class="type">Instance</span>(); </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">AssertionError</span>(e); </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (InstantiationException e) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">AssertionError</span>(e); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> Car()&#123; &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，实例初始化操作是先于构造器的程序体而运行的。实例初始化操作抛出的</p>
<p>任何异常都会传播给构造器。如果初始化操作抛出的是被检查异常，那么构造器</p>
<p>必须声明也会抛出这些异常，但是应该避免这样做，因为它会造成混乱。最后，</p>
<p>对于我们所设计的类，如果其实例包含同样属于这个类的其他实例，那么对这种</p>
<p>无限递归要格外当心。 </p>
<h2 id="谜题-41：域和流"><a href="#谜题-41：域和流" class="headerlink" title="谜题 41：域和流"></a>谜题 41：域和流</h2><p>下面的方法将一个文件拷贝到另一个文件，并且被设计为要关闭它所创建的每一</p>
<p>个流，即使它碰到 I/O 错误也要如此。遗憾的是，它并非总是能够做到这一点。</p>
<p>为什么不能呢，你如何才能订正它呢？ </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span>(<span class="params">String src, String dest</span>) throws IOException</span> &#123; </span><br><span class="line"></span><br><span class="line"> InputStream <span class="keyword">in</span> = <span class="literal">null</span>; </span><br><span class="line"></span><br><span class="line"> OutputStream <span class="keyword">out</span> = <span class="literal">null</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">in</span> = <span class="keyword">new</span> FileInputStream(src); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">out</span> = <span class="keyword">new</span> FileOutputStream(dest); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>]; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> n; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> ((n = <span class="keyword">in</span>.read(buf)) &gt; <span class="number">0</span>) </span><br><span class="line"></span><br><span class="line"> <span class="keyword">out</span>.write(buf, <span class="number">0</span>, n); </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">in</span> != <span class="literal">null</span>) <span class="keyword">in</span>.close(); </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">out</span> != <span class="literal">null</span>) <span class="keyword">out</span>.close(); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序看起来已经面面俱到了。其流域（in 和 out）被初始化为 null，并且</p>
<p>新的流一旦被创建，它们马上就被设置为这些流域的新值。对于这些域所引用的流，如果不为空，则 finally 语句块会将其关闭。即便在拷贝操作引发了一个</p>
<p>IOException 的情况下，finally 语句块也会在方法返回之前执行。出什么错了</p>
<p>呢？ </p>
<p>问题在 finally 语句块自身中。close 方法也可能会抛出 IOException 异常。如</p>
<p>果这正好发生在 in.close 被调用之时，那么这个异常就会阻止 out.close 被调</p>
<p>用，从而使输出流仍保持在开放状态。 </p>
<p>请注意，该程序违反了谜题 36 的建议：对 close 的调用可能会导致 finally 语</p>
<p>句块意外结束。遗憾的是，编译器并不能帮助你发现此问题，因为 close 方法抛</p>
<p>出的异常与 read 和 write 抛出的异常类型相同，而其外围方法（copy）声明将</p>
<p>传播该异常。 </p>
<p>解决方式是将每一个 close 都包装在一个嵌套的 try 语句块中。下面的 finally</p>
<p>语句块的版本可以保证在两个流上都会调用 close： </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#125; finally &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">in</span> != <span class="keyword">null</span>) &#123; </span><br><span class="line"></span><br><span class="line"> try &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">in</span>.<span class="keyword">close</span>(); </span><br><span class="line"></span><br><span class="line"> &#125; catch (IOException ex) &#123; </span><br><span class="line"></span><br><span class="line"> // There <span class="keyword">is</span> <span class="keyword">nothing</span> we can <span class="keyword">do</span> <span class="keyword">if</span> <span class="keyword">close</span> fails </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">out</span> != <span class="keyword">null</span>) </span><br><span class="line"></span><br><span class="line"> try &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">out</span>.<span class="keyword">close</span>(); </span><br><span class="line"></span><br><span class="line"> &#125; catch (IOException ex) &#123; </span><br><span class="line"></span><br><span class="line"> // There <span class="keyword">is</span> <span class="keyword">nothing</span> we can <span class="keyword">do</span> <span class="keyword">if</span> <span class="keyword">close</span> fails </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">从 <span class="number">5.0</span> 版本开始，你可以对代码进行重构，以利用 Closeable 接口： </span><br><span class="line"></span><br><span class="line">&#125; finally &#123; </span><br><span class="line"></span><br><span class="line"> closeIgnoringException(<span class="keyword">in</span>); </span><br><span class="line"></span><br><span class="line"> closeIgnoringEcception(<span class="keyword">out</span>); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeIgnoringException</span><span class="params">(Closeable c)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (c != null) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> c.<span class="built_in">close</span>(); </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (IOException ex) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// There is nothing we can do if close fails </span></span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，当你在 finally 语句块中调用 close 方法时，要用一个嵌套的 try-catch</p>
<p>语句来保护它，以防止 IOException 的传播。更一般地讲，对于任何在 finally</p>
<p>语句块中可能会抛出的被检查异常都要进行处理，而不是任其传播。这是谜题</p>
<p>36 中的教训的一种特例，而对语言设计着的教训情况也相同。 </p>
<h2 id="谜题-42：异常为循环而抛-异常为循环而抛"><a href="#谜题-42：异常为循环而抛-异常为循环而抛" class="headerlink" title="谜题 42：异常为循环而抛 异常为循环而抛"></a>谜题 42：异常为循环而抛 异常为循环而抛</h2><p>下面的程序循环遍历了一个 int 类型的数组序列，并且记录了满足某个特定属性</p>
<p>的数组个数。那么，该程序会打印出什么呢？ </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Loop</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="built_in">int</span>[][] tests = &#123; &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">2</span> &#125;,</span><br><span class="line"></span><br><span class="line"> &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;, &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="number">1</span> &#125; &#125;; </span><br><span class="line"></span><br><span class="line"> <span class="built_in">int</span> successCount = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="built_in">int</span> i = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (thirdElementIsThree(tests[i++])) </span><br><span class="line"></span><br><span class="line"> successCount ++; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// No more tests to process </span></span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> System.<span class="keyword">out</span>.println(successCount); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> static <span class="built_in">bool</span>ean thirdElementIsThree(<span class="built_in">int</span>[] a) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> a.length &gt;= <span class="number">3</span> &amp; a[<span class="number">2</span>] == <span class="number">3</span>; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序用 thirdElementIsThree 方法测试了 tests 数组中的每一个元素。遍历这</p>
<p>个数组的循环显然是非传统的循环：它不是在循环变量等于数组长度的时候终</p>
<p>止，而是在它试图访问一个并不在数组中的元素时终止。尽管它是非传统的，但</p>
<p>是这个循环应该可以工作。如果传递给 thirdElementIsThree 的参数具有 3 个或</p>
<p>更多的元素，并且其第三个元素等于 3，那么该方法将返回 true。对于 tests</p>
<p>中的 5 个元素来说，有 2 个将返回 true，因此看起来该程序应该打印 2。如果你</p>
<p>运行它，就会发现它打印的时 0。肯定是哪里出了问题，你能确定吗？ </p>
<p>事实上，这个程序犯了两个错误。第一个错误是该程序使用了一种可怕的循环惯</p>
<p>用法，该惯用法依赖的是对数组的访问会抛出异常。这种惯用法不仅难以阅读，</p>
<p>而且运行速度还非常地慢。不要使用异常来进行循环控制；应该只为异常条件而使用异常[EJ Item 39]。为了纠正这个错误，可以将整个 try-finally 语句块替</p>
<p>换为循环遍历数组的标准惯用法： </p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (<span class="name">int</span> i = <span class="number">0</span><span class="comment">; i &lt; test.length; i++) </span></span><br><span class="line"></span><br><span class="line"> if (<span class="name">thirdElementIsThree</span>(<span class="name">tests</span>[i])) </span><br><span class="line"></span><br><span class="line"> successCount++<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>如果你使用的是 5.0 或者是更新的版本，那么你可以用 for 循环结构来代替： </p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (<span class="name">int</span>[] test : tests) </span><br><span class="line"></span><br><span class="line"> if(<span class="name">thirdElementIsThree</span>(<span class="name">test</span>)) </span><br><span class="line"></span><br><span class="line"> successCount++<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>就第一个错误的糟糕情况来说，只有它自己还不足以产生我们所观察到的行为。</p>
<p>然而，订正该错误可以帮助我们找到真正的 bug，它更加深奥： </p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> </span><br><span class="line"></span><br><span class="line">java.lang.ArrayIndexOutOfBoundsException: <span class="number">2</span></span><br><span class="line"></span><br><span class="line"> at <span class="module-access"><span class="module"><span class="identifier">Loop1</span>.</span></span>third<span class="constructor">ElementIsThree(Loop1.<span class="params">java</span>:19)</span> </span><br><span class="line"></span><br><span class="line"> at <span class="module-access"><span class="module"><span class="identifier">Loop1</span>.</span></span>main(<span class="module-access"><span class="module"><span class="identifier">Loop1</span>.</span></span>java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure>

<p>很明显，在 thirdElementIsThree 方法中有一个 bug：它抛出了一个</p>
<p>ArrayIndexOutOfBoundsException 异常。这个异常先前伪装成了那个可怕的基</p>
<p>于异常的循环的终止条件。 </p>
<p>如果传递给 thirdElementIsThree 的参数具有 3 个或更多的元素，并且其第三个</p>
<p>元素等于 3，那么该方法将返回 true。问题是在这些条件不满足时它会做些什么</p>
<p>呢。如果你仔细观察其值将会被返回的那个布尔表达式，你就会发现它与大多数</p>
<p>布尔 AND 操作有一点不一样。这个表达式是 a.length &gt;= 3 &amp; a[2] == 3。通常，</p>
<p>你在这种情况下看到的是 &amp;&amp; 操作符，而这个表达式使用的是 &amp; 操作符。那是</p>
<p>一个位 AND 操作符吗？ </p>
<p>事实证明 &amp; 操作符有其他的含义。除了常见的被当作整型操作数的位 AND 操作</p>
<p>符之外，当被用于布尔操作数时，它的功能被重载为逻辑 AND 操作符[JLS</p>
<p>15.22.2]。这个操作符与更经常被使用的条件 AND 操作符有所不同，&amp; 操作符总</p>
<p>是要计算它的两个操作数，而 &amp;&amp; 操作符在其左边的操作数被计算为 false 时，</p>
<p>就不再计算右边的操作数了[JLS 15.23]。因此，thirdElementIsThree 方法总</p>
<p>是要试图访问其数组参数的第三个元素，即使该数组参数的元素不足 3 个也是如</p>
<p>此。订正这个方法只需将 &amp; 操作符替换为 &amp;&amp; 操作符即可。通过这样的修改，</p>
<p>这个程序就可以打印出我们所期望的 2 了： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="built_in">bool</span>ean thirdElementIsThree(<span class="built_in">int</span>[] a) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> a.length &gt;= <span class="number">3</span> &amp;&amp; a[<span class="number">2</span>] == <span class="number">3</span>; </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>正像有一个逻辑 AND 操作符伴随着更经常被使用的条件 AND 操作符一样，还有一</p>
<p>个逻辑 OR 操作符(|)也伴随着条件 OR 操作符(||)[JLS 15.22.2，15.24]。| 操</p>
<p>作符总是要计算它的两个操作数，而 || 操作符在其左边的操作数被计算为</p>
<p>true 时，就不再计算右边的操作数了。我们一不注意，就很容易使用了逻辑操</p>
<p>作符而不是条件操作符。遗憾的是，编译器并不能帮助你发现这种错误。有意识</p>
<p>地使用逻辑操作符的情形非常少见，少到了我们对所有这样使用的程序都应该持怀疑态度的地步。如果你真的想使用这样的操作符，为了是你的意图清楚起见，</p>
<p>请加上注释。 </p>
<p>总之，不要去用那些可怕的使用异常而不是使用显式的终止测试的循环惯用法，</p>
<p>因为这种惯用法非常不清晰，而且会掩盖 bug。要意识到逻辑 AND 和 OR 操作符</p>
<p>的存在，并且不要因无意识的误用而受害。对语言设计者来说，这又是一个操作</p>
<p>符重载会导致混乱的明证。对于在条件 AND 和 OR 操作符之外还要提供逻辑 AND</p>
<p>和 OR 操作符这一点，并没有很明显的理由。如果这些操作符确实要得到支持的</p>
<p>话，它们应该与其相对应的条件操作符存在着视觉上的明显差异。 </p>
<h2 id="谜题-43：异常地危险"><a href="#谜题-43：异常地危险" class="headerlink" title="谜题 43：异常地危险"></a>谜题 43：异常地危险</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在 JDK1.<span class="number">2</span> 中，<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>stop、<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>suspend 以及其他许多线程相关的方法都</span><br><span class="line"></span><br><span class="line">因为它们不安全而不推荐使用了<span class="literal">[T<span class="identifier">hreadStop</span>]</span>。下面的方法展示了你用</span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>stop 可以实现的可怕事情之一。 </span><br><span class="line"></span><br><span class="line"> <span class="comment">// Don’t do this - circumvents exception checking! </span></span><br><span class="line"></span><br><span class="line"> public static void sneaky<span class="constructor">Throw(Throwable <span class="params">t</span>)</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.stop(t); <span class="comment">// Deprecated!! </span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这个讨厌的小方法所做的事情正是 throw 语句要做的事情，但是它绕过了编译器</p>
<p>的所有异常检查操作。你可以（卑鄙地）在你的代码的任意一点上抛出任何受检</p>
<p>查的或不受检查的异常，而编译器对此连眉头都不会皱一下。 </p>
<p>不使用任何不推荐的方法，你也可以编写出在功能上等价于 sneakyThrow 的方</p>
<p>法。事实上，至少有两种方式可以这么实现这一点，其中一种只能在 5.0 或更新</p>
<p>的版本中运行。你能够编写出这样的方法吗？它必须是用 Java 而不是用 JVM 字</p>
<p>节码编写的，你不能在其客户对它编译完之后再去修改它。你的方法不必是完美</p>
<p>无瑕的：如果它不能抛出一两个 Exception 的子类，也是可以接受的。 </p>
<p>本谜题的一种解决之道是利用 Class.newInstance 方法中的设计缺陷，该方法通</p>
<p>过反射来对一个类进行实例化。引用有关该方法的文档中的话[Java-API]：“请</p>
<p>注意，该方法将传播从空的[换句话说，就是无参数的]构造器所抛出的任何异常，</p>
<p>包括受检查的异常。使用这个方法可以有效地绕开在其他情况下都会执行的编译</p>
<p>期异常检查。”一旦你了解了这一点，编写一个 sneakyThrow 的等价方法就不是</p>
<p>太难了。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thrower</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Throwable t; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">Thrower</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> t; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sneakyThrow</span><span class="params">(Throwable t)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> Thrower.t = t; <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> Thrower<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>; </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (InstantiationException e) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(); </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(); </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line"></span><br><span class="line"> Thrower.t = <span class="keyword">null</span>; <span class="comment">// Avoid memory leak</span></span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个解决方案中将会发生许多微妙的事情。我们想要在构造器执行期间所抛出</p>
<p>的异常不能作为一个参数传递给该构造器，因为 Class.newInstance 调用的是一</p>
<p>个类的无参数构造器。因此，sneakyThrow 方法将这个异常藏匿于一个静态变量</p>
<p>中。为了使该方法是线程安全的，它必须被同步，这使得对其的并发调用将顺序</p>
<p>地使用静态域 t。 </p>
<p>要注意的是，t 这个域在从 finally 语句块中出来时是被赋为空的：这只是因为</p>
<p>该方法虽然是卑鄙的，但这并不意味着它还应该是内存泄漏的。如果这个域不是</p>
<p>被赋为空出来的，那么它阻止该异常被垃圾回收。最后，请注意，如果你让该方</p>
<p>法抛出一个 InstantiationException 或是一个 IllegalAccessException 异常，</p>
<p>它将以抛出一个 IllegalArgumentException 而失败。这是这项技术的一个内在</p>
<p>限制。 </p>
<p>Class.newInstance 的文档继续描述道“Constructor.newInstance 方法通过将</p>
<p>构造器抛出的任何异常都包装在一个（受检查的）InvocationTargetException</p>
<p>异常中而避免了这个问题。”很明显，Class.newInstance 应该是做了相同的处</p>
<p>理，但是纠正这个缺陷已经为时过晚，因为这么做将引入源代码级别的不兼容性，</p>
<p>这将使许多依赖于 Class.newInstance 的程序崩溃。而弃用这个方法也不切实</p>
<p>际，因为它太常用了。当你在使用它时，一定要意识到 Class.newInstance 可以</p>
<p>抛出它没有声明过的受检查异常。 </p>
<p>被添加到 5.0 版本中的“通用类型（generics）”可以为本谜题提供一个完全不</p>
<p>同的解决方案。为了实现最大的兼容性，通用类型是通过类型擦除（type </p>
<p>erasure）来实现的：通用类型信息是在编译期而非运行期检查的[JLS 4.7]。 </p>
<p>下面的解决方案就利用了这项技术： </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Don't do this either - circumvents exception checking! </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TigerThrower&lt;T</span> <span class="keyword">extends</span> <span class="title">Throwable&gt;</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> public static void sneakyThrow(<span class="type">Throwable</span> t) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">new</span> <span class="type">TigerThrower</span>&lt;<span class="type">Error</span>&gt;().sneakyThrow2(t); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> void sneakyThrow2(<span class="type">Throwable</span> t) <span class="keyword">throws</span> <span class="type">T</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> (<span class="type">T</span>) t; &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序在编译时将产生一条警告信息： </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">TigerThrower</span><span class="selector-class">.java</span><span class="selector-pseudo">:7</span><span class="selector-pseudo">:warning</span>: <span class="selector-attr">[unchecked]</span> <span class="selector-tag">unchecked</span> <span class="selector-tag">cast</span> </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">found</span> : <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Throwable</span>, <span class="selector-tag">required</span>: <span class="selector-tag">T</span> </span><br><span class="line"></span><br><span class="line"> <span class="selector-tag">throw</span> (<span class="selector-tag">T</span>) <span class="selector-tag">t</span>; </span><br><span class="line"></span><br><span class="line"> ^</span><br></pre></td></tr></table></figure>

<p>警告信息是编译器所采用的一种手段，用来告诉你：你可能正在搬起石头砸自己</p>
<p>的脚，而且事实也正是如此。“不受检查的转型”警告告诉你这个有问题的转型</p>
<p>将不会在运行时刻受到检查。当你获得了一个不受检查的转型警告时，你应该修</p>
<p>改你的程序以消除它，或者你可以确信这个转型不会失败。如果你不这么做，那</p>
<p>么某个其他的转型可能会在未来不确定的某个时刻失败，而你也就很难跟踪此错</p>
<p>误到其源头了。对于本谜题所示的情况，其情况更糟糕：在运行期抛出的异常可</p>
<p>能与方法的签名不一致。sneakyThrow2 方法正是利用了这一点。 </p>
<p>对平台设计者来说，有好几条教训。在设计诸如反射类库之类在语言之外实现的</p>
<p>类库时， 要保留语言所作的所有承诺。当从头设计一个支持通用类型的平台时，</p>
<p>要考虑强制要求其在运行期的正确性。Java 通用类型工具的设计者可没有这么</p>
<p>做，因为他们受制于通用类库必须能够与现有客户进行互操作的要求。对于违反</p>
<p>方法签名的异常，为了消除其产生的可能性，应该考虑强制在运行期进行异常检</p>
<p>查。 </p>
<p>总之，Java 的异常检查机制并不是虚拟机强制执行的。它只是一个编译期工具，</p>
<p>被设计用来帮助我们更加容易地编写正确的程序，但是在运行期可以绕过它。要</p>
<p>想减少你因为这类问题而被曝光的次数，就不要忽视编译器给出的警告信息。 </p>
<h2 id="谜题-44：切掉类"><a href="#谜题-44：切掉类" class="headerlink" title="谜题 44：切掉类"></a>谜题 44：切掉类</h2><p>请考虑下面的两个类： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Strange1</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> Missing m = <span class="keyword">new</span> Missing(); </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (java.lang.NoClassDefFoundError ex) &#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"Got it!"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Strange2</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> Missing m; <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> m = <span class="keyword">new</span> Missing(); </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (java.lang.NoClassDefFoundError ex) &#123; </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"Got it!"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Strange1 和 Strange2 都用到了下面这个类： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Missing</span> &#123; </span><br><span class="line"></span><br><span class="line"> Missing() &#123; &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你编译所有这三个类，然后在运行 Strange1 和 Strange2 之前删除</p>
<p>Missing.class 文件，你就会发现这两个程序的行为有所不同。其中一个抛出了</p>
<p>一个未被捕获的 NoClassDefFoundError 异常，而另一个却打印出了 Got it! 到</p>
<p>底哪一个程序具有哪一种行为，你又如何去解释这种行为上的差异呢？ </p>
<p>程序 Strange1 只在其 try 语句块中提及 Missing 类型，因此你可能会认为它捕</p>
<p>获 NoClassDefFoundError 异常，并打印 Got it！另一方面，程序 Strange2 在</p>
<p>try 语句块之外声明了一个 Missing 类型的变量，因此你可能会认为所产生的</p>
<p>NoClassDefFoundError 异常不会被捕获。如果你试着运行这些程序，就会看到</p>
<p>它们的行为正好相反：Strange1 抛出了未被捕获的 NoClassDefFoundError 异常，</p>
<p>而 Strange2 却打印出了 Got it！怎样才能解释这些奇怪的行为呢？ </p>
<p>如果你去查看 Java 规范以找出应该抛出 NoClassDefFoundError 异常的地方，那</p>
<p>么你不会得到很多的指导信息。该规范描述道，这个错误可以“在（直接或间接）</p>
<p>使用某个类的程序中的任何地方”抛出[JLS 12.2.1]。当 VM 调用 Strange1 和</p>
<p>Strange2 的 main 方法时，这些程序都间接使用了 Missing 类，因此，它们都在</p>
<p>其权利范围内于这一点上抛出了该错误。 </p>
<p>于是，本谜题的答案就是这两个程序可以依据其实现而展示出各自不同的行为。</p>
<p>但是这并不能解释为什么这些程序在所有我们所知的 Java 实现上的实际行为，</p>
<p>与你所认为的必然行为都正好相反。要查明为什么会是这样，我们需要研究一下</p>
<p>由编译器生成的这些程序的字节码。 </p>
<p>如果你去比较 Strange1 和 Strange2 的字节码，就会发现几乎是一样的。除了类</p>
<p>名之外，唯一的差异就是 catch 语句块所捕获的参数 ex 与 VM 本地变量之间的映</p>
<p>射关系不同。尽管哪一个程序变量被指派给了哪一个 VM 变量的具体细节会因编</p>
<p>译器的不同而有所差异，但是对于和上述程序一样简单的程序来说，这些细节不</p>
<p>太可能会差异很大。下面是通过执行 javap -c Strange1 命令而显示的</p>
<p>Strange1.main 的字节码： </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0</span>: new</span><br><span class="line"></span><br><span class="line"><span class="attribute">3</span>: dup </span><br><span class="line"></span><br><span class="line"><span class="attribute">4</span>: invokespecial #3; //Method Missing."&lt;init&gt;":()V</span><br><span class="line"></span><br><span class="line"><span class="attribute">7</span>: astore_1 8: goto 20 </span><br><span class="line"></span><br><span class="line"><span class="attribute">11</span>: astore_1 </span><br><span class="line"></span><br><span class="line"><span class="attribute">12</span>: getstatic #5; // Field System.out:Ljava/io/PrintStream; </span><br><span class="line"></span><br><span class="line"><span class="attribute">15</span>: ldc #6; // String "Got it!"</span><br><span class="line"></span><br><span class="line"><span class="attribute">17</span>: invokevirtual #7;//Method PrintStream.println: (String); V</span><br><span class="line"></span><br><span class="line"><span class="attribute">20</span>: return </span><br><span class="line"></span><br><span class="line">Exception table:</span><br><span class="line"></span><br><span class="line">from to target type </span><br><span class="line"></span><br><span class="line"> 0 8 11 Class java/lang/NoClassDefFoundError</span><br></pre></td></tr></table></figure>

<p>Strange2.main 相对应的字节码与其只有一条指令不同： </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>: astore_2</span><br></pre></td></tr></table></figure>

<p>这是一条将 catch 语句块中的捕获异常存储到捕获参数 ex 中的指令。在</p>
<p>Strange1 中，这个参数是存储在 VM 变量 1 中的，而在 Strange2 中，它是存储</p>
<p>在 VM 变量 2 中的。这就是两个类之间唯一的差异，但是它所造成的程序行为上</p>
<p>的差异是多么地大呀！ </p>
<p>为了运行一个程序，VM 要加载和初始化包含 main 方法的类。在加载和初始化之</p>
<p>间，VM 必须链接（link）类[JLS 12.3]。链接的第一阶段是校验，校验要确保</p>
<p>一个类是良构的，并且遵循语言的语法要求。校验非常关键，它维护着可以将像</p>
<p>Java 这样的安全语言与像 C 或 C++这样的不安全语言区分开的各种承诺。 </p>
<p>在 Strange1 和 Strange2 这两个类中，本地变量 m 碰巧都被存储在 VM 变量 1 中。</p>
<p>两个版本的 main 都有一个连接点，从两个不同位置而来的控制流汇聚于此。该</p>
<p>连接点就是指令 20，即从 main 返回的指令。在正常结束 try 语句块的情况下，</p>
<p>我们执行到指令 8，即 goto 20，从而可以到达指令 20；而对于在 catch 语句块</p>
<p>中结束的情况，我们将执行指令 17，并按顺序执行下去，到达指令 20。 </p>
<p>连接点的存在使得在校验 Strange1 类时产生异常，而在校验 Strange2 类时并不</p>
<p>会产生异常。当校验去执行对 Strange1.main 的流分析（flow analysis）[JLS</p>
<p>12.3.1]时，由于指令 20 可以通过两条不同的路径到达，因此校验器必须合并在</p>
<p>变量 1 中的类型。两种类型是通过计算它们的首个公共超类（first common </p>
<p>superclass）[JVMS 4.9.2]而合并的。两个类的首个公共超类是它们所共有的最</p>
<p>详细而精确的超类。 </p>
<p>在 Strange1.main 方法中，当从指令 8 到达指令 20 时，VM 变量 1 的状态包含了</p>
<p>一个 Missing 类的实例。当从指令 17 到达时，它包含了一个</p>
<p>NoClassDefFoundError 类的实例。为了计算首个公共超类，校验器必须加载</p>
<p>Missing 类以确定其超类。因为 Missing.class 文件已经被删除了，所以校验器</p>
<p>不能加载它，因而抛出了一个 NoClassDefFoundError 异常。请注意，这个异常</p>
<p>是在校验期间、在类被初始化之前，并且在 main 方法开始执行之前很早就抛出</p>
<p>的。这就解释了为什么没有打印出任何关于这个未被捕获异常的跟踪栈信息。 </p>
<p>要想编写一个能够探测出某个类是否丢失的程序，请使用反射来引用类而不要使</p>
<p>用通常的语言结构[EJ Item35]。 下面展示了用这种技巧重写的程序： </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Strange</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> Exception</span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> Object m = Class.forName(<span class="string">"Missing"</span>).</span><br><span class="line"></span><br><span class="line"> newInstance(); </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123; </span><br><span class="line"></span><br><span class="line"> System.err.<span class="built_in">println</span>(<span class="string">"Got it!"</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，不要对捕获 NoClassDefFoundError 形成依赖。语言规范非常仔细地描述</p>
<p>了类初始化是在何时发生的[JLS 12.4.1]，但是类被加载的时机却显得更加不可</p>
<p>预测。更一般地讲，捕获 Error 及其子类型几乎是完全不恰当的。这些异常是为</p>
<p>那些不能被恢复的错误而保留的。 </p>
<h2 id="谜题-45：令人疲惫不堪的测验"><a href="#谜题-45：令人疲惫不堪的测验" class="headerlink" title="谜题 45：令人疲惫不堪的测验"></a>谜题 45：令人疲惫不堪的测验</h2><p>本谜题将测试你对递归的了解程度。下面的程序将做些什么呢？ </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Workout</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> workHard(); </span><br><span class="line"></span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"It's nap time."</span>); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">workHard</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> workHard(); </span><br><span class="line"></span><br><span class="line"> &#125; finally &#123; </span><br><span class="line"></span><br><span class="line"> workHard(); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要不是有 try-finally 语句，该程序的行为将非常明显：workHard 方法递归地</p>
<p>调用它自身，直到程序抛出 StackOverflowError，在此刻它以这个未捕获的异</p>
<p>常而终止。但是，try-finally 语句把事情搞得复杂了。当它试图抛出</p>
<p>StackOverflowError 时，程序将会在 finally 语句块的 workHard 方法中终止，</p>
<p>这样，它就递归调用了自己。这看起来确实就像是一个无限循环的秘方，但是这</p>
<p>个程序真的会无限循环下去吗？如果你运行它，它似乎确实是这么做的，但是要</p>
<p>想确认的唯一方式就是分析它的行为。 Java 虚拟机对栈的深度限制到了某个预设的水平。当超过这个水平时，VM 就抛</p>
<p>出 StackOverflowError。为了让我们能够更方便地考虑程序的行为，我们假设</p>
<p>栈的深度为 3，这比它实际的深度要小得多。现在让我们来跟踪其执行过程。 </p>
<p>main 方法调用 workHard，而它又从其 try 语句块中递归地调用了自己，然后它</p>
<p>再一次从其 try 语句块中调用了自己。在此时，栈的深度是 3。当 workHard 方</p>
<p>法试图从其 try 语句块中再次调用自己时，该调用立即就会以</p>
<p>StackOverflowError 而失败。这个错误是在最内部的 finally 语句块中被捕获</p>
<p>的，在此处栈的深度已经达到了 3。在那里，workHard 方法试图递归地调用它自</p>
<p>己，但是该调用却以 StackOverflowError 而失败。这个错误将在上一级的</p>
<p>finally 语句块中被捕获，在此处站的深度是 2。该 finally 中的调用将与相对</p>
<p>应的 try 语句块具有相同的行为：最终都会产生一个 StackOverflowError。这</p>
<p>似乎形成了一种模式，而事实也确实如此。 </p>
<p>WorkOut 的运行过程如左面的图所示。在这张图中，对 workHard 的调用用</p>
<p>箭头表示，workHard 的执行用圆圈表示。所有的调用除了一个之外，都是递归</p>
<p>的。会立即产生 StackOverflowError 异常的调用用由灰色圆圈前导的箭头表示，</p>
<p>try 语句块中的调用用向左边的向下箭头表示，finally 语句块中的调用用向右</p>
<p>边的向下箭头表示。箭头上的数字描述了调用的顺序。 </p>
<p>这张图展示了一个深度为 0 的调用（即 main 中的调用），两个深度为 1 的调用，</p>
<p>四个深度为 2 的调用，和八个深度为 3 的调用，总共是 15 个调用。那八个深度</p>
<p>为 3 的调用每一个都会立即产生 StackOverflowError。至少在把栈的深度限制</p>
<p>为 3 的 VM 上，该程序不会是一个无限循环：它在 15 个调用和 8 个异常之后就会</p>
<p>终止。但是对于真实的 VM 又会怎样呢？它仍然不会是一个无限循环。其调用图</p>
<p>与前面的图相似，只不过要大得多得多而已。 </p>
<p>那么，究竟大到什么程度呢？有一个快速的试验表明许多 VM 都将栈的深度限制</p>
<p>为 1024，因此，调用的数量就是 1+2+4+8…+21,024=21,025-1，而抛出的异常的</p>
<p>数量是 21,024。假设我们的机器可以在每秒钟内执行 1010 个调用，并产生 1010</p>
<p>个异常，按照当前的标准，这个假设的数量已经相当高了。在这样的假设条件下，</p>
<p>程序将在大约 1.7×10291 年后终止。为了让你对这个时间有直观的概念，我告</p>
<p>诉你，我们的太阳的生命周期大约是 1010 年，所以我们可以很确定，我们中没</p>
<p>有任何人能够看到这个程序终止的时刻。尽管它不是一个无限循环，但是它也就</p>
<p>算是一个无限循环吧。 </p>
<p>从技术角度讲，调用图是一棵完全二叉树，它的深度就是 VM 的栈深度的上限。</p>
<p>WorkOut 程序的执行过程等于是在先序遍历这棵树。在先序遍历中，程序先访问</p>
<p>一个节点，然后递归地访问它的左子树和右子树。对于树中的每一条边，都会产</p>
<p>生一个调用，而对于树中的每一个节点，都会抛出一个异常。 </p>
<p>本谜题没有很多关于教训方面的东西。它证明了指数算法对于除了最小输入之外</p>
<p>的所有情况都是不可行的，它还表明了你甚至可以不费什么劲就可以编写出一个</p>
<p>指数算法。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0/" rel="tag"># java进阶学习</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/20/java%E5%BE%AA%E7%8E%AF%E8%B0%9C%E9%A2%98/" rel="prev" title="java循环谜题">
      <i class="fa fa-chevron-left"></i> java循环谜题
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/20/java%E7%B1%BB%E8%B0%9C%E9%A2%98/" rel="next" title="java类谜题">
      java类谜题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-谜题-Java-谜题-4——异常谜题"><span class="nav-number">1.</span> <span class="nav-text">Java 谜题 Java 谜题 4——异常谜题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#谜题-36：优柔寡断"><span class="nav-number">1.1.</span> <span class="nav-text">谜题 36：优柔寡断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谜题-37：极端不可思议"><span class="nav-number">1.2.</span> <span class="nav-text">谜题 37：极端不可思议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谜题-38：不受欢迎的宾客-不受欢迎的宾客"><span class="nav-number">1.3.</span> <span class="nav-text">谜题 38：不受欢迎的宾客 不受欢迎的宾客</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谜题-39：您好，再见！"><span class="nav-number">1.4.</span> <span class="nav-text">谜题 39：您好，再见！</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谜题-40：不情愿的构造器-不情愿的构造器"><span class="nav-number">1.5.</span> <span class="nav-text">谜题 40：不情愿的构造器 不情愿的构造器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谜题-41：域和流"><span class="nav-number">1.6.</span> <span class="nav-text">谜题 41：域和流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谜题-42：异常为循环而抛-异常为循环而抛"><span class="nav-number">1.7.</span> <span class="nav-text">谜题 42：异常为循环而抛 异常为循环而抛</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谜题-43：异常地危险"><span class="nav-number">1.8.</span> <span class="nav-text">谜题 43：异常地危险</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谜题-44：切掉类"><span class="nav-number">1.9.</span> <span class="nav-text">谜题 44：切掉类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谜题-45：令人疲惫不堪的测验"><span class="nav-number">1.10.</span> <span class="nav-text">谜题 45：令人疲惫不堪的测验</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">匡俊桦</p>
  <div class="site-description" itemprop="description">回忆的沙漏将曾经屈指可数的日子渐渐淡去</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">238</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">匡俊桦</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">29:03</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
