<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:type" content="website">
<meta property="og:title" content="KJHの博客">
<meta property="og:url" content="http://yoursite.com/page/27/index.html">
<meta property="og:site_name" content="KJHの博客">
<meta property="og:description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="匡俊桦">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/27/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>KJHの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KJHの博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录&回忆</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/" class="post-title-link" itemprop="url">C++对象模型深入探索</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-27 15:11:15" itemprop="dateCreated datePublished" datetime="2020-12-27T15:11:15+08:00">2020-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-02 00:30:52" itemprop="dateModified" datetime="2021-02-02T00:30:52+08:00">2021-02-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面简单的论述过<a href="http://blog.csdn.net/wenqian1991/article/details/19205505" target="_blank" rel="noopener">C++对象模型</a>，总觉得不够深入，现近闲来进一步挖掘C++对象内存布局情况。主要讨论：单一继承，多重继承，钻石继承的有无虚函数以及虚拟继承的情况。贴出测试程序，并给出测试结论以及对应的类对象的大小计算。（PS：类对象的内存布局取决于编译器，这里的测试都是基于Visual Studio）</p>
<p><strong><em>\</em>单一的类对象**</strong></p>
<p>单一的类对象主要考虑有虚函数的情况，前面提及的博文已有介绍，类中定义了虚函数，就会产生一个虚函数表（实质就是一个函数指针数组，虚函数表不在类中，VS编译环境下，虚函数表位于常量段，虚表指针在类对象中），类每定义一个对象，便会在对象的最前面安插一个虚表指针，指向虚函数表，这样该类定义的对象会多出4 Byte（32位）。</p>
<p>可以在Visual Studio C++ 编译输出中直接看C++内存布局：工程项目——右键“属性”——配置属性——C/C++——命令行——其他选项里添加“/d1reportAllClassLayout ”，即可在编译输出中查看定义的类的内存布局，上面是输出所有定义的类对象，你可以搜索你自己定义的对象。（最好不要把名字定为base，不然一大堆）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//public:</span></span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"parent: fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*virtual void fun2()</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; "parent: fun2" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	parent obj_b;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面便是定义的类对象内存布局情况：vfptr 即表示虚表指针，static 成员不在类对象中</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class parent	size(8):</span><br><span class="line">1&gt;  	+---</span><br><span class="line">1&gt;   0	| &#123;vfptr&#125;</span><br><span class="line">1&gt;   4	| b</span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>



<p>如果类中不定义为虚函数，类对象的大小是4，如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class parent	size(4):</span><br><span class="line">1&gt;  	+---</span><br><span class="line">1&gt;   0	| b</span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>

<p>下面我们来考虑类继承的情况：</p>
<p><strong><em>\</em>单一继承**</strong></p>
<p><strong>*\</strong>*1）一般继承，无虚函数**<em>**</em></p>
<p><strong><em>\</em>1.1 继承一个基类**</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//public:</span></span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="comment">/*virtual void fun1()</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; "parent: fun1" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span>:</span> <span class="keyword">public</span> parent</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	child obj_b;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存布局：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class child	size(8):</span><br><span class="line">1&gt;  	+---</span><br><span class="line">1&gt;  	| +--- (base class parent)</span><br><span class="line">1&gt;   0	| | b</span><br><span class="line">1&gt;  	| +---</span><br><span class="line">1&gt;   4	| a</span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>

<p><strong><em>\</em>1.2 再考虑继承两个基类的情况**</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//public:</span></span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="comment">/*virtual void fun1()</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; "parent: fun1" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span>:</span> <span class="keyword">public</span> parent, <span class="keyword">public</span> parent1</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	child obj_b;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存布局：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class child	size(12):</span><br><span class="line">1&gt;  	+---</span><br><span class="line">1&gt;  	| +--- (base class parent)</span><br><span class="line">1&gt;   0	| | b</span><br><span class="line">1&gt;  	| +---</span><br><span class="line">1&gt;  	| +--- (base class parent1)</span><br><span class="line">1&gt;   4	| | c</span><br><span class="line">1&gt;  	| +---</span><br><span class="line">1&gt;   8	| a</span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>



<p>可以看出，一般继承无虚函数的情况下，派生类对象的内存布局为，先存放基类成员，再存放自身成员变量，其大小是简单的基类对象大小与自身成员大小之和。继承多个基类时，数据成员按继承声明的前后顺序放置。</p>
<p><strong><em>\</em>2）存在虚函数的情况**</strong></p>
<p><strong><em>\</em>2.1 基类定义虚函数，派生类本身无虚函数**</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//public:</span></span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"parent: fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span>:</span> <span class="keyword">public</span> parent<span class="comment">/*, public parent1*/</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	child obj_b;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存布局：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class child	size(12):</span><br><span class="line">1&gt;  	+---</span><br><span class="line">1&gt;  	| +--- (base class parent)</span><br><span class="line">1&gt;   0	| | &#123;vfptr&#125;</span><br><span class="line">1&gt;   4	| | b</span><br><span class="line">1&gt;  	| +---</span><br><span class="line">1&gt;   8	| a</span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>

<p>这个和上面的一般继承没啥区别，只不过是基类中定义了虚表指针，然后被派生类一股脑继承下来</p>
<p><strong><em>\</em>2.2 继承多个基类**</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"parent: fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"parent1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span>:</span> <span class="keyword">public</span> parent, <span class="keyword">public</span> parent1</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	child obj_b;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存布局</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class child	size(20):</span><br><span class="line">1&gt;  	+---</span><br><span class="line">1&gt;  	| +--- (base class parent)</span><br><span class="line">1&gt;   0	| | &#123;vfptr&#125;</span><br><span class="line">1&gt;   4	| | b</span><br><span class="line">1&gt;  	| +---</span><br><span class="line">1&gt;  	| +--- (base class parent1)</span><br><span class="line">1&gt;   8	| | &#123;vfptr&#125;</span><br><span class="line">1&gt;  12	| | c</span><br><span class="line">1&gt;  	| +---</span><br><span class="line">1&gt;  16	| a</span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>

<p>可以看到，继承多个基类也和无虚函数的情况一样，这里和继承单个的区别在于，派生类会产生两个虚表指针，后面我们会用程序验证，这两个虚表指针指向不同的两个虚函数表，可以顺便总结一下，非虚继承下，派生类继承几个含有虚函数的基类，那么派生类的实例对象就会有几个虚表指针。</p>
<p><strong><em>\</em>2.3 含虚函数情况**</strong></p>
<p><strong><em>\</em>1.基类无虚函数，派生类自身定义有虚函数**</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="comment">/*virtual void fun2()</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; "parent" &lt;&lt; endl</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span>:</span> <span class="keyword">public</span> parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"child"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存布局</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class child	size(12):</span><br><span class="line">1&gt;  	+---</span><br><span class="line">1&gt;   0	| &#123;vfptr&#125;</span><br><span class="line">1&gt;  	| +--- (base class parent)</span><br><span class="line">1&gt;   4	| | b</span><br><span class="line">1&gt;  	| +---</span><br><span class="line">1&gt;   8	| a</span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>

<p>可以看出，虚表指针总是放在对象的最前面，哪怕它是定义在派生类中。</p>
<p>基类有虚函数，派生类无虚函数，这个简单，不赘述了</p>
<p><strong>*\</strong>*2.当基类，派生类自身都定义虚函数的情况**<em>**</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"parent"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span>:</span> <span class="keyword">public</span> parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"child"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存布局：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class child	size(12):</span><br><span class="line">1&gt;  	+---</span><br><span class="line">1&gt;  	| +--- (base class parent)</span><br><span class="line">1&gt;   0	| | &#123;vfptr&#125;</span><br><span class="line">1&gt;   4	| | b</span><br><span class="line">1&gt;  	| +---</span><br><span class="line">1&gt;   8	| a</span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>

<p>这个一开始以为派生类也会占据一个自身虚表指针空间的，一看发现错了。细看布局，你会发现子类对象中虚表指针是继承的父类对象的，那么子类对象本身就不会产生虚函数指针么？答案是肯定的。那么子类对象的虚函数指针在哪呢？位于同一个虚函数表中。下面我们通过程序验证一下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	child obj;</span><br><span class="line">	fun pFun = <span class="literal">NULL</span>;</span><br><span class="line">	pFun = (fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;obj));</span><br><span class="line">	pFun();</span><br><span class="line">	pFun = (fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;obj)+<span class="number">1</span>);</span><br><span class="line">	pFun();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>output：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parent</span><br><span class="line">child</span><br></pre></td></tr></table></figure>

<p>上面的语句 pFun = (fun)<em>((int</em>)<em>(int</em>)(&amp;obj)); 前面说过虚函数表实质是一个函数指针数组，数组里面存放的是虚函数指针。对象中只存放指向虚函数表的虚表指针，并且位于对象的最前面，也就是说虚表指针与对象是同一个地址。回过头看这条程序：(int<em>)(&amp;obj) 对对象地址也就是虚表指针（虚函数表的地址）强制转换，(int</em>)<em>(int</em>)(&amp;obj) 解引用虚表指针，定位到了虚函数表（函数指针数组），这指向了数组（首位置）。(fun)<em>((int</em>)<em>(int</em>)(&amp;obj)) 有了前面这个就好理解了，取数组首元素得到虚函数指针，然后强制转换。</p>
<p>从上面的测试输出可以看出，这种情况下派生类对象中只有一个虚表指针，派生类的虚函数指针位于同一个虚函数表中，且位于基类虚函数指针的后面。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  child::$vftable@:</span><br><span class="line">1&gt;  	| &amp;child_meta</span><br><span class="line">1&gt;  	|  0</span><br><span class="line">1&gt;   0	| &amp;parent::fun2 </span><br><span class="line">1&gt;   1	| &amp;child::fun1</span><br></pre></td></tr></table></figure>

<p>如果派生类中的虚函数名为fun2，自然的就同名覆盖了基类的。</p>
<p><strong>*\</strong>*2.3 多重继承情况**<em>**</em></p>
<p><strong><em>\</em>1）继承多个基类**</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_p</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"parent"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">adopter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"adopter"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span> :</span> <span class="keyword">public</span> parent, <span class="keyword">public</span> adopter</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_c</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"child"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存布局：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class child	size(20):</span><br><span class="line">1&gt;  	+---</span><br><span class="line">1&gt;  	| +--- (base class parent)</span><br><span class="line">1&gt;   0	| | &#123;vfptr&#125;</span><br><span class="line">1&gt;   4	| | a</span><br><span class="line">1&gt;  	| +---</span><br><span class="line">1&gt;  	| +--- (base class adopter)</span><br><span class="line">1&gt;   8	| | &#123;vfptr&#125;</span><br><span class="line">1&gt;  12	| | b</span><br><span class="line">1&gt;  	| +---</span><br><span class="line">1&gt;  16	| c</span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>

<p>由于两个基类都有虚函数，这样继承下来，子类对象便会有两个虚表指针，也就是说子类会有两个虚函数表。子类对象中的虚函数指针是存放在继承的第一个父类的虚函数表中</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  child::$vftable@parent@:</span><br><span class="line">1&gt;  	| &amp;child_meta</span><br><span class="line">1&gt;  	|  0</span><br><span class="line">1&gt;   0	| &amp;parent::fun_p </span><br><span class="line">1&gt;   1	| &amp;child::fun_c </span><br><span class="line">1&gt;  </span><br><span class="line">1&gt;  child::$vftable@adopter@:</span><br><span class="line">1&gt;  	| -8</span><br><span class="line">1&gt;   0	| &amp;adopter::fun_a</span><br></pre></td></tr></table></figure>

<p>那如果父类中只有一个有虚函数呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="comment">/*virtual*/</span> <span class="function"><span class="keyword">void</span> <span class="title">fun_p</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"parent"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">adopter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"adopter"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span> :</span> <span class="keyword">public</span> parent, <span class="keyword">public</span> adopter</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_c</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"child"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内存布局</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>&gt;  <span class="function">class child	<span class="title">size</span><span class="params">(<span class="number">16</span>)</span>:</span></span><br><span class="line">1&gt;  	+---</span><br><span class="line"><span class="number">1</span>&gt;  	| +--- (base class adopter)</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>	| | &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">4</span>	| | b</span><br><span class="line"><span class="number">1</span>&gt;  	| +---</span><br><span class="line"><span class="number">1</span>&gt;  	| +--- (base class parent)</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">8</span>	| | a</span><br><span class="line"><span class="number">1</span>&gt;  	| +---</span><br><span class="line"><span class="number">1</span>&gt;  <span class="number">12</span>	| c</span><br><span class="line"><span class="number">1</span>&gt;  	+---</span><br></pre></td></tr></table></figure>

<p>这里故意不在第一个父类定义虚函数，看内存布局会发现，父类adopter处于子类对象的最前面，因为它定义有虚函数，Visual Studio 编译器保证了虚表指针位于对象最前面的原则，这样如果继承的多个父类均有虚函数，那么存放位置根据继承顺序来，如果有个没有定义虚函数，则不管继承的顺序，均按照虚函数优先原则来，有虚函数的放置在最前面。</p>
<p><strong>*\</strong>*2）累积继承**<em>**</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_p</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"parent"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span> :</span> <span class="keyword">public</span> parent</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_c</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"child"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">grandchild</span> :</span> <span class="keyword">public</span> child</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_g</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"grandchild"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	grandchild obj_b;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内存布局</span></span><br><span class="line"><span class="number">1</span>&gt;  <span class="function">class grandchild	<span class="title">size</span><span class="params">(<span class="number">16</span>)</span> :</span></span><br><span class="line">1&gt;  	+-- -</span><br><span class="line"><span class="number">1</span>&gt; | +-- - (base class child)</span><br><span class="line"><span class="number">1</span>&gt; | | +-- - (base class parent)</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span> | | | &#123;vfptr&#125;</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">4</span> | | | a</span><br><span class="line"><span class="number">1</span>&gt; | | +-- -</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">8</span> | | b</span><br><span class="line"><span class="number">1</span>&gt; | +-- -</span><br><span class="line"><span class="number">1</span>&gt;  <span class="number">12</span> | c</span><br><span class="line"><span class="number">1</span>&gt;  	+-- -</span><br><span class="line"></span><br><span class="line"><span class="comment">//虚函数表</span></span><br><span class="line"><span class="number">1</span>&gt;  grandchild::$vftable@:</span><br><span class="line"><span class="number">1</span>&gt; | &amp;grandchild_meta</span><br><span class="line"><span class="number">1</span>&gt; | <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span> | &amp;parent::fun_p</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">1</span> | &amp;child::fun_c</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">2</span> | &amp;grandchild::fun_g</span><br></pre></td></tr></table></figure>

<p>从上面看，以及综合前面基类中含有虚函数的情况可以看出，子类对象中的虚表指针取决于继承的定义有虚函数的父类的个数（非虚拟继承），当然如果父类没有虚函数那就取决于本身有没有虚函数了。如果上面的这个子类（应该叫孙类），再继承parent，那么它会多一个虚表指针。而子类若自身也定义虚函数，则它不会产生虚表指针（继承的父类有虚表指针的情况下），而是把它的虚函数指针放置在继承的父类的虚函数表中，这是出于利用虚函数实现多态的目的，这里我们主要讨论内存布局情况，虚函数继承与多态，后面再说。 </p>
<p>在介绍钻石型继承前，我们再考虑上面论述的其中几种情况的虚拟继承下的类对象的内存布局：</p>
<p><strong><em>\</em>虚拟继承（虚基类）**</strong></p>
<p>我们就以上面的这个累积继承为例并扩展，阐述一下虚拟继承是如何影响类对象内存布局的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_p</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"parent"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> parent</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_c</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"child"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">grandchild</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> child</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"grandchild"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一看内存布局，可不是发生了一点点的微秒变化</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class child	size(20):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   0	| &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   4	| &#123;vbptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   8	| b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+--- (virtual base parent)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  12	| &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  16	| a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  class grandchild	size(32):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   0	| &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   4	| &#123;vbptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   8	| c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+--- (virtual base parent)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  12	| &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  16	| a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+--- (virtual base child)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  20	| &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  24	| &#123;vbptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  28	| b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>

<p>先看类child，对比2.3.2，一般继承，基类派生类均含虚函数的情况（sizeof(child_obj) = 12），这里虚拟继承，瞬间多了8 Byte，</p>
<p>首先虚拟继承，子类对象中自然会多出一个虚基类指针vbptr，但虚表指针还是在对象的最前面，还有一个最大的改变就是子类会产生两个虚函数表，这样实例化的对象便会有两个虚表指针，这颠覆了前面得出的结论，不能简单的按继承的含虚函数的父类的个数来判定了。</p>
<p>这里阐述的情况是虚拟继承的情况，对于前面子类含虚表指针个数与含虚函数父类个数的关系限于非虚拟继承情况下。对于虚拟继承，可以看出，它是全盘继承某个子类。</p>
<p>可以看出，</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  child::$vftable@child@:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| &amp;child_meta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	|  0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   0	| &amp;child::fun_c </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  child::$vbtable@:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   0	| -4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   1	| 8 (childd(child+4)parent)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  child::$vftable@parent@:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| -12</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   0	| &amp;parent::fun_p</span><br></pre></td></tr></table></figure>

<p>中间是虚基类指针。上面两个虚表指针指向不同的两个虚函数表，我们可以通过程序验证一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	child obj;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	fun pFun = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pFun = (fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;obj));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pFun();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pFun = (fun)*((<span class="keyword">int</span>*)*((<span class="keyword">int</span>*)(&amp;obj)+<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pFun();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">child</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parent</span><br></pre></td></tr></table></figure>

<p>对于上面的指针，注意与前面提到的相区别：虚函数表的地址位移和对象内的地址位移。</p>
<p><strong>*\</strong>*3、钻石型继承**<em>**</em></p>
<p>所谓钻石型继承就是继承方式形如下面的“菱形”结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  A</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> / \</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">B   C</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> \ /</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  D</span><br></pre></td></tr></table></figure>

<p>下面演示这样一种情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class_A</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"a"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class_B</span> :</span> <span class="keyword">public</span> class_A</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun_b</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"b"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class_C</span> :</span> <span class="keyword">public</span> class_A</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun_c</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"c"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class_D</span> :</span> <span class="keyword">public</span> class_B, <span class="keyword">public</span> class_C</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> d;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun_d</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"d"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	class_D obj;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存布局如下</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class class_D	size(20):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| +--- (base class class_B)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| | +--- (base class class_A)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   0	| | | a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| | +---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   4	| | b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| +---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| +--- (base class class_C)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| | +--- (base class class_A)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   8	| | | a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| | +---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  12	| | c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| +---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  16	| d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>

<p>上面的程序有问题，从内存布局就可以看出，如果调用基类成员a，就会产生二义性，究竟是调用哪个，因为BC内部都继承有A的成员变量，最后的子类对象都有a的两份拷贝。这时候虚基类就横空出世了，前面有讲到虚拟继承。如果上面采用虚继承，那么最后的子类D的实例只会拥有一个，看下面</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class_A</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"a"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class_B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> class_A</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_b</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"b"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class_C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> class_A</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_c</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"c"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class_D</span> :</span> <span class="keyword">public</span> class_B, <span class="keyword">public</span> class_C</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> d;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_d</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"d"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	class_D obj;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看内存布局前，先分析下这个派生类class_D的实例会占用多少内存。按照前面总结的来，class_D 非虚继承两个含有虚函数的基类，那么其对象中便会有两个虚表指针（自身的虚函数指针就放在第一个虚函数表中），一股脑继承下来，并且自身不会产生虚表指针。可以直接看继承的class_B，虚继承A，那么class_B就会占用12 Bytes（虚表指针，虚基类指针以及int成员变量），同理 class_C也会占用12 Bytes（虚继承自身也会产生多余的虚表指针），再考虑共继承的A，本身会有虚表指针，然后成员变量会放在派生类的最后，A的成员只会在派生类D中存在一份拷贝（* bytes），这是虚基类的目的，避免二义性，然后class_D，由于是一般继承，自身就是int 型4 Byte。总的下来就是 12+12+8+4 = 36 Bytes。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class class_D	size(36):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| +--- (base class class_B)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   0	| | &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   4	| | &#123;vbptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   8	| | b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| +---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| +--- (base class class_C)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  12	| | &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  16	| | &#123;vbptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  20	| | c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| +---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  24	| d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+--- (virtual base class_A)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  28	| &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  32	| a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>

<p>如果把最后的class_D 也虚继承 B和C（两个都虚继承才行），那么最后的大小会是多少呢？虚继承首先会多出虚基类指针，然后自身也会多余产生一个虚表指针，那么会多出8Bytes，最后的大小就是44 Bytes，挺大的。<br>如果只是class_D 只是虚继承其中一个基类，好吧，表示已经凌乱了，在Visual Studio 下，虽然大小不会改变，不会多出虚表指针和虚基类指针，但是内存布局却改变了，</p>
<p>代码不贴了，直接看内存布局也会知道继承关系：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class class_D	size(36):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| +--- (base class class_C)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   0	| | &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   4	| | &#123;vbptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   8	| | c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| +---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  12	| d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+--- (virtual base class_A)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  16	| &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  20	| a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+--- (virtual base class_B)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  24	| &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  28	| &#123;vbptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  32	| b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>

<p>结合前面的虚继承内存布局会发现，虚继承的东西都是放在后面。进一步深究就没意义了。</p>
<p>下面的程序告诉你，虚表指针不一定总是在对象的最前面：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class_A</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"a"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class_B</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> class_A</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun_b</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"b"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	class_B obj;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	fun pFun = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pFun = (fun)*((<span class="keyword">int</span>*)*((<span class="keyword">int</span>*)(&amp;obj)+<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pFun();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//内存布局</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&gt;  <span class="function">class class_B	<span class="title">size</span><span class="params">(<span class="number">16</span>)</span> :</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">1&gt;  	+-- -</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span> | &#123;vbptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">4</span> | b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&gt;  	+-- -</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&gt;  	+-- - (<span class="keyword">virtual</span> base class_A)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">8</span> | &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &gt; <span class="number">12</span> | a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &gt; +-- -</span><br></pre></td></tr></table></figure>



<p>前面啰嗦了一大片，我们可以得出以下几点：</p>
<ol>
<li>一般继承下（无虚函数），派生类的内存布局是先放基类成员，多个基类的按继承的顺序放置，最后是派生类自身的成员变量，函数和static变量不在类对象中。这样派生类对象的大小便是继承的基类的大小与自身变量的大小之和。</li>
<li>一般继承下（含虚函数），与上面的区别就是考虑虚表指针了。1、派生类只继承一个基类的情况下，不管是基类定义有虚函数还是派生类本身有虚函数，或是两个都有虚函数，最后的派生类对象中只会有一个虚表指针，并且是位于对象的最前面。两个都有虚函数的话，派生类的虚函数指针会存放在虚函数表（数组）中基类的虚函数指针的后面。2、当派生类继承多个基类时，如果多个基类中只有一个基类有虚函数，那就和前面的一样。多个基类都有虚函数，那么派生类对象就会产生多个虚表指针，虚表指针的个数与继承的含虚函数的基类的个数一样，派生类的虚函数指针放在第一个虚函数表中。</li>
<li>虚继承下（有虚函数），虚继承除了多出一个虚基类指针外，整个对象的内存布局也会随之改变。只要是虚继承，那么对应的派生类就会产生一个虚基类指针。另外只要是虚继承，那么基类会并且只会在派生类对象中存在一份拷贝，并且虚继承的东西是放在后面，哪怕它带有虚表指针（虚表指针不一定都是在对象的最前面）。进一步总结虚继承下的虚表指针情况，由于虚继承，派生类会存在基类的一份完整拷贝，这样派生类会产生多余的自身的虚表指针。</li>
</ol>
<p>计算类对象大小的时候，考虑以上几点便很容易得出。附带一句，上面的测试和总结都是基于Visual Studio 编译器。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">C++对象模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-27 15:07:17 / 修改时间：15:09:47" itemprop="dateCreated datePublished" datetime="2020-12-27T15:07:17+08:00">2020-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在C++对象模型中，Nonstatic data members 被配置于每一个 class object 之内，static data members 则被存放在个别 class object 之外。Static 和nonstatic function members 也被放在个别的class object 之外。存在 virtual function 时，每个class 会产生出一堆指向 virtual function 的指针，这些指针存放在一个表中，称之为虚函数表 virtual table。其实质就是一个函数指针数组，里面存放的是虚函数指针。每一个 class object 被安插一个虚表指针 vptr，指向相关的 virtual table，虚表指针通常置于 class object 的第一位置。另外，当子类虚继承父类时，子类对象中还会安插虚基类指针。注意此处 class 和 class object 的区别。如此说来一个类实例当中存放的就是 nonstatic data member，虚表指针（存在虚函数时或父类中含有虚函数），虚基类指针（虚拟继承时）。类继承时体积会变大，但在虚拟继承的情况下，基类永远只存在一个实例。</p>
<p>每一个 static data member 只有一个实例，存放在程序的 data segment 之中，视作是全局变量，static成员独立于任何对象而存在，不是类类型对象的组成部分，(非const类型)必须在类定义体的外部定义，不同于普通数据成员，static成员不是通过类构造函数进行初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>   //测试</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//virtual void prin()&#123; return ; &#125;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> x;  <span class="comment">//编译时不分配内存</span></span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::x = <span class="number">0</span>;  <span class="comment">//此时分配内存</span></span><br><span class="line">                  <span class="comment">//将此语句注释，程序出错</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; &amp;Base::x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类中 static成员在编译时并不分配内存，把它当成全局函数在类外进行初始化时才分配内存，在类外初始化时记得标上数据类型，这样编译器才知道应该为该 static成员分配多大内存。</p>
<p>当类中申明或定义虚函数时，该类会产生出一堆指向虚函数的指针，放在虚函数表中，该类中有多少个虚函数，那个对应的虚函数指针一次存放在该虚函数表中，当类被实例化时，每个实例 class object 会被安插一个虚函数表指针，一般是在 class object 的第一个位置(visual studio C++ 环境)，指向相关虚函数表。</p>
<p>换言之，每个含有虚函数的类有一张虚函数表vtbl，其中每一项是一个虚函数地址，指向虚表的指针 vptr 是被安插在类实例 class object 中，并且它指向对象所属的类的虚表，这样的话即使类中申明了多个虚函数，那么class object 中只会占用一个指针大小的空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>    //测试</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> ; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> ; &#125;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *str = <span class="string">"sunburn"</span>;      <span class="comment">//常量区</span></span><br><span class="line">	Base b;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt; (<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b) &lt;&lt; <span class="built_in">endl</span>;         <span class="comment">//虚函数表地址</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>*)*(<span class="keyword">int</span> *)*(<span class="keyword">int</span>*)(&amp;b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//虚函数表中的第一个函数地址</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>那么虚函数表究竟存放在哪呢？看上面程序的测试结果</p>
<p><img src="/2020/12/27/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/20140216210542500" alt="img"></p>
<p>可以看出，虚函数表的地址为：0x0089cc64，常量字符串的地址为：0x0089cc70.所以在visual studio C++中，虚函数表示存放在常量段，不同的编译器可能会有区别。</p>
<p>所以虚函数表是属于一个类所有对象的，不是某个对象特有的，是一个类所有对象共有的。</p>
<p>如果一个子类虚继承父类，即虚继承时，需要一个虚基类表来记录需继承关系，这样子类就会多一个虚基类表指针，不管多重还是单一继承，子类虚基类表指针只有一个。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> ; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> ; &#125;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span>&#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">	<span class="keyword">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DDriver</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> Driver<span class="comment">/*,virtual public Base*/</span> <span class="comment">//添加该注释代码不会影响sizeof(dd)的大小</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base b;</span><br><span class="line"></span><br><span class="line">	Driver d;</span><br><span class="line"></span><br><span class="line">	DDriver dd;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(b) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//8 = 4(int) + 4(虚表指针)</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(d) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//20 = 4(int) + 4(虚基类表指针) + 4(虚表指针) + 8(父类b)</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(dd) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//28 = 4(int) + 4(虚基类表指针) + 20(父类d)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类对象 d 中由于申明了一个与父类 Base 不同名的虚函数，所以在虚继承时会额外安插一个虚表指针，虚继承时会出现子类中持有多个虚函数表的情况，非虚继承时则不会。如果改为非虚继承，那么该类中就只会持有一个虚函数表，且没有虚基类指针，则 sizeof(d) = 12。</p>
<p>class DDriver 中如果再虚继承 Base，其实例对象的大小不变，也就是说虚继承情况下，基类只存在一个实例。</p>
<p>这样，<strong>一个类的对象的内存大小包括</strong>：</p>
<ul>
<li>所有非静态数据成员的大小</li>
<li>由内存对齐而填补的内存大小</li>
<li>为了支持 virtual，由内部产生的额外负担</li>
</ul>
<p>在VC中数据成员的布局为 [C++对象模型很大部分取决于编译器] ：</p>
<ol>
<li>vptr 部分(如果基类有，则继承基类的)</li>
<li>vbptr (虚继承)</li>
<li>基类成员 (如果继承)</li>
<li>自身数据成员</li>
<li>虚基类数据成员 (按声明顺序)</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">C语言指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-27 15:04:46 / 修改时间：15:06:11" itemprop="dateCreated datePublished" datetime="2020-12-27T15:04:46+08:00">2020-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>指针是一个特殊的变量，它里面存储的数值被解释成为内存（用户空间的虚拟内存）里的一个地址。</p>
<h3 id="一、指针的属性"><a href="#一、指针的属性" class="headerlink" title="一、指针的属性"></a><strong>一、指针的属性</strong></h3><p>一个指针包含四个方面的内容：<strong>指针的类型、指针所指向的类型、指针所指向的内存区、指针本身所占据的内存区。</strong></p>
<p>接下来就下面几个例子作说明：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、 <span class="built_in">int</span> *p;</span><br><span class="line"><span class="number">2</span>、 char *p；</span><br><span class="line"><span class="number">3</span>、 <span class="built_in">int</span> **p;</span><br><span class="line"><span class="number">4</span>、 <span class="built_in">int</span> (*p)[<span class="number">3</span>];</span><br><span class="line"><span class="number">5</span>、 <span class="built_in">int</span> *(*p)[<span class="number">4</span>];<span class="number">12345</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-1、指针的类型"><a href="#1-1、指针的类型" class="headerlink" title="1.1、指针的类型"></a><strong>1.1、指针的类型</strong></h4><p><strong>从语法的角度，只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型，即指针本身所具有的类型。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、 <span class="keyword">int</span> *p;        <span class="comment">//指针的类型是 int*</span></span><br><span class="line"><span class="number">2</span>、 <span class="keyword">char</span> *p；      <span class="comment">//指针的类型是  char*</span></span><br><span class="line"><span class="number">3</span>、 <span class="keyword">int</span> **p;       <span class="comment">//指针的类型是 int**</span></span><br><span class="line"><span class="number">4</span>、 <span class="keyword">int</span> (*p)[<span class="number">3</span>];   <span class="comment">//指针的类型是 int(*)[3]</span></span><br><span class="line"><span class="number">5</span>、 <span class="keyword">int</span> *(*p)[<span class="number">4</span>];  <span class="comment">//指针的类型是 int*(*)[3]12345</span></span><br></pre></td></tr></table></figure>

<p>然后有的人还是不知道怎么读…（后面再说）<br>插播：指针类型说明原则：<strong>从变量名处起，根据运算符优先级结合，一步一步分析。</strong></p>
<hr>
<h4 id="1-2、指针所指向的类型"><a href="#1-2、指针所指向的类型" class="headerlink" title="1.2、指针所指向的类型"></a><strong>1.2、指针所指向的类型</strong></h4><p><strong>通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么看待，简而言之，就是编译器会在内存中预留出多大的内存空间给这个指针</strong></p>
<p>从语法上，把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、 <span class="keyword">int</span> *p;        <span class="comment">//指针所指向的类型是 int</span></span><br><span class="line"><span class="number">2</span>、 <span class="keyword">char</span> *p；      <span class="comment">//指针所指向的类型是 char</span></span><br><span class="line"><span class="number">3</span>、 <span class="keyword">int</span> **p;       <span class="comment">//指针所指向的类型是 int*</span></span><br><span class="line"><span class="number">4</span>、 <span class="keyword">int</span> (*p)[<span class="number">3</span>];   <span class="comment">//指针所指向的类型是 int()[3]</span></span><br><span class="line"><span class="number">5</span>、 <span class="keyword">int</span> *(*p)[<span class="number">4</span>];  <span class="comment">//指针所指向的类型是 int*()[3]12345</span></span><br></pre></td></tr></table></figure>

<p>注意指针的类型和指针所指向的类型是两个概念，当然第一个其实没什么卵用，后面这个概念才是重点。</p>
<p>指针所指向的类型，表示了编译器为给这个指针所指向的区域分配了多大内存，这个概念是非常重要的，尤其在指针进行自增自减，以及加减常数运算的时候。<br>比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、 <span class="keyword">int</span> *p;        <span class="comment">//对于这个编译器为p所指向的类型预留了4个字节的空间(int类型)，p++的时候，</span></span><br><span class="line">                  <span class="comment">//是以4个字节为单位进行递增的（p+2，实则是偏移了2*4个字节的位置）</span></span><br><span class="line"><span class="number">2</span>、 <span class="keyword">char</span> *p；      <span class="comment">//以一个字节为单位（char占用1个字节）</span></span><br><span class="line"><span class="number">3</span>、 <span class="keyword">int</span> **p;       <span class="comment">//以4个字节为单位（int * 占用4个字节）</span></span><br><span class="line"><span class="number">4</span>、 <span class="keyword">int</span> (*p)[<span class="number">3</span>];   <span class="comment">//首先这是个数组指针（指向一个大小为3的数组，里面存放的是int类型），以12个字节为单位</span></span><br><span class="line"><span class="number">5</span>、 <span class="keyword">int</span> *(*p)[<span class="number">4</span>];  <span class="comment">//同样12个字节为单位，数组里面存放的是int*类型（4个字节）</span></span><br><span class="line"><span class="number">6</span>、 <span class="class"><span class="keyword">struct</span> <span class="title">str</span> *<span class="title">p</span>;</span> <span class="comment">//就是以sizeof(struct str)为单位了</span></span><br><span class="line"><span class="number">7</span>、 <span class="keyword">void</span> *p;       <span class="comment">//p++,就出错了，因为p所指向的类型是未定义的，即编译器不知道该为这个p所指向的类型分配多大空间     12345678</span></span><br></pre></td></tr></table></figure>

<p>这个概念非常重要，尤其在处理指针偏移量的时候，是以该指针所指向的数据类型为单位。</p>
<p>在32位系统下，任何指针变量所占用的空间都是4个字节（32位），包括void*，这样意味着每个指针变量的寻址空间是0~2^32-1（即4G的寻址空间）。</p>
<hr>
<h4 id="1-3、指针所指向的内存区域地址"><a href="#1-3、指针所指向的内存区域地址" class="headerlink" title="1.3、指针所指向的内存区域地址"></a><strong>1.3、指针所指向的内存区域地址</strong></h4><p><strong>指针的值就是指针本身存储的数值，这个值被编译器当做一个地址，指针所指向的内存区就是从指针的数值所表示的那个内存地址开始，长度为 sizeof(指针所指向的类型)的一片内存区。</strong></p>
<p>结合上面的第二点（指针所指向的类型），定义一个指针，我们就可以知道这个指针的有效区域，什么意思呢，看下面</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、 <span class="keyword">int</span> *p; <span class="comment">//p数值表示这块区域的首地址，哪个地方结束呢，（unsigned long）p+sizeof(int)1</span></span><br></pre></td></tr></table></figure>

<p>编译器会划定长度为 sizeof(指针所指向的类型)的一片内存区给这个指针变量，就是说用户程序使用这个指针变量（解引用*）时，编译器得知道p所表示的地址后面还有多少的空间数据是属于这个指针变量的，不多也不少。</p>
<hr>
<h4 id="1-4、指针本身所占据的内存区"><a href="#1-4、指针本身所占据的内存区" class="headerlink" title="1.4、指针本身所占据的内存区"></a><strong>1.4、指针本身所占据的内存区</strong></h4><p>前面说了，32位平台里，指针本身占据了4个字节的长度。<br><strong>一个指针本身占据有内存的话，那么这个指针是一个左值，否则就不是一个左值。</strong></p>
<p>用哲学的观点解释就是，世界是物质的，一个变量要作为左值，它得自身占据一个内存空间， 不然赋值给它的对象放在哪</p>
<p>如果一个表达式的结果是一个指针，那么这个表达式就叫指针表达式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> *pa;</span><br><span class="line">pa = &amp;a;<span class="comment">//&amp;a是一个指针，但是它不能作为左值，因为&amp;a它本身没有占据明确的内存123</span></span><br></pre></td></tr></table></figure>

<p>x=y;<br><strong>左值</strong>：在这个上下文环境中，编译器认为 x 的含义是 x 所代表的地址。这个地址只有编译器知道，在编译的时候确定，编译器在一个特定的区域保存这个地址，我们无需知道；<br><strong>右值</strong>，在这个上下文环境中，编译器认为 y 的含义是 y 所代表的地址里面的内容，这个内容是什么，只有到运行时才知道。</p>
<p>pa 与 &amp;a 在编译器看来是不一样的。编译器没有为 &amp;a 这个东东分配一块内存来存其地址，皮之不存毛将安附焉。</p>
<hr>
<h3 id="二、指针的算术运算"><a href="#二、指针的算术运算" class="headerlink" title="二、指针的算术运算"></a><strong>二、指针的算术运算</strong></h3><h4 id="2-1、指针的加减整数"><a href="#2-1、指针的加减整数" class="headerlink" title="2.1、指针的加减整数"></a><strong>2.1、指针的加减整数</strong></h4><p>指针可以加上或减去一个整数。但是它加减的单位不是单纯的整数，而是整数*sizeof(指针所指向的类型)，这个在前面的第2点讲述了，这里不赘述。</p>
<p>强制类型转换不会改变原有指针的类型</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="keyword">str</span>[<span class="number">20</span>] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="keyword">str</span>;  <span class="comment">//str的类型不变</span></span><br><span class="line">++p;  <span class="comment">// *p的值？123</span></span><br></pre></td></tr></table></figure>

<p>str的类型不变是什么意思呢，就是str++还是以sizeof(char)为单位进行运算的。</p>
<p>p 被初始化为指向整型变量str，我们知道str表示这个char数组的首地址，第二行语句就是把这个首地址赋值给p，进行强制转换的意图就是重新把str所指向的这块区域进行细分，原来是char类型，是以1个字节为单位划分的，现在是int类型，就成了以4个字节为单位划分的。</p>
<p><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/20160116184402036" alt="这里写图片描述"></p>
<p>所以++p之后，p就到了图中p+1的位置处，那么++p之后<em>p的值呢？<br>为方便说明，我们令 pt = p+1; 那么pt对应的区域就是 o wo这四个字符占据的空间，然后转换为asscii码就是（十六进制） 6F,20,77,6F, *pt的值还需要考虑你测试机器的大小端模式，X86是小端模式，所以 *pt = 0x6F77206F = 1870078063<br>\</em> ((char*)p) = ‘o’</p>
<p>对此，我们要清楚的认识到，<strong>指针的运算实值是地址的偏移，加往后偏移，减则往前面偏移</strong>， 所以 a[-1]是正确的，当然前提是这个位置是定义了的，而不是未映射区域。由此可以导出一点，指针的偏移操作不能超出范围（指针语义上没错，但一旦应用程序中这样使用，保你崩溃）</p>
<p>另外，<strong>两个指针不能进行加法运算</strong>，进行加法后，得到的结构指向一个不知所向的地方；<strong>两个指针可以进行减法操作，但必须类型相同</strong>，一般用于确定两个同类型指针变量之间的偏移量，linux内核数据结构 list 就是很好的应用这一特性的典范。</p>
<hr>
<h4 id="2-2、运算符-amp-和"><a href="#2-2、运算符-amp-和" class="headerlink" title="2.2、运算符&amp;和*"></a><strong>2.2、运算符&amp;和*</strong></h4><p>这里讨论是C语言中的指针，&amp; 不涉及到C++中的引用语义。<br>这里 &amp; 是取地址运算符，之前我们说过世界是物质的，在计算机内存中也不例外，一个有效变量它总会在内存的某个地方占据一个对应的空间大小，用于存放这个数值，而&amp;则是获取这个变量存放的地址。</p>
<p>&amp;a 的结果自然是一个指针，<em>习惯称之为解引用，</em>p就是获取p所指向的内容。</p>
<hr>
<h3 id="三、指针和数组"><a href="#三、指针和数组" class="headerlink" title="三、指针和数组"></a><strong>三、指针和数组</strong></h3><p><strong>指针是指针，数组是数组，两个是不一样的东西</strong></p>
<ul>
<li>指针就是指针，指针变量在32位系统下，永远占4个byte，其值为某一个内存的地址，指针可以指向任何地方，但不是任何地方你都能通过这个指针访问到。</li>
<li>数组就是数组，其大小与元素的类型和个数有关，定义数组时，必须指定其元素的类型和个数、数组可以存任何类型的数据，但不能存函数，可以存函数指针。</li>
</ul>
<p><strong>指针与数组之间的恩恩怨怨起源于，数组名表示数组首元素的地址</strong></p>
<blockquote>
<p>C语言中，当一维数组作为函数参数的时候，编译器总是把它解析成一个指向其首元素首地址的指针。（仅限于一维数组）</p>
</blockquote>
<p>这也是为什么无法向函数传递一个数组，而必须在传递的同时指定数组的长度。</p>
<p>看下面</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//a  表示数组首元素的地址，即a[0]的地址，*a = 1</span></span><br><span class="line"><span class="comment">//&amp;a 表示数组的首地址</span></span><br><span class="line"><span class="comment">//&amp;a[0] 也表示数组首元素的地址1234</span></span><br></pre></td></tr></table></figure>

<p>有趣的事，上面三个变量的数值是一样的，其数值就是数组的首位置地址。但是意义是不同的，用前面第一章第2点的说法（指针所指的数据类型）来解释就是，这三个变量代表的意义是不同的，这就表示它们自增之后的数值就不一样了。<br><strong>a+n 的值是 &amp;a[0] + n * sizeof(int)；</strong><br><strong>&amp;a+1 的值是 &amp;a[0] + 1 * sizeof(a) = &amp;a[0] + 1*5*sizeof(int);</strong></p>
<p>那么 a 和 &amp;a[0] 的区别在哪呢，这两个变量作为右值的话，是没有区别的，都是表示数组首元素的地址，而不是数组的地址。</p>
<p>但是，a 不能作为左值，编译器没有为数组a分配一块内存来存其地址，另外我们只能访问数组的某个元素而无法把数组当一个总体进行访问。</p>
<p>因为数组名表示该数组首元素的地址，所以我们可以用指针获取这个地址值，然后增加偏移量来读取数组元素</p>
<p>就一维数组和一级指针而言，二者在一定程度上是等效的，根据上面的分析，很好理解应用。</p>
<hr>
<h4 id="二维数组与指针"><a href="#二维数组与指针" class="headerlink" title="二维数组与指针"></a><strong>二维数组与指针</strong></h4><p>看看二维数组，首先把内存看做是一个连续的一维大数组，二维只是我们为了方便处理把它意识形态上的划分为二维，其本质还是一维的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>];<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>上面声明了一个二维数组，三行四列，<br><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/20160116201704585" alt="这里写图片描述"></p>
<p>然后尝试用指针对这个二维数组进行元素访问。由上图可知，<strong>编译器总是将二维数组看成一个一维数组（更高维数也是一样的），而一维数组的每一个元素又都是一个数组。</strong><br>a[0]这个一维数组的三个元素分别为 a[0],a[1],a[2]，而这个a[0],a[1],a[2]又都是一个有四个元素的一维数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/20160116202758886" alt="这里写图片描述"></p>
<p>所以上面后面的a[0],a[1],a[2]的首地址分别为 &amp;a[0], &amp;a[0] + 1<em>sizeof(a[0]), &amp;a[0] + 2</em>sizeof(a[0]);</p>
<p>也就是说 a[i] 的首地址为 &amp;a[0] + i * sizeof(a[0]); 而后a[i] 中有是个int 类型的元素，其每个元素的首地址分别为 &amp;a[i], &amp;a[i] + sizeof(int),&amp;a[i] + 2<em>sizeof(int),&amp;a[i] + 3</em>sizeof(int);<br>所以 a[i][j] 的首地址为 &amp;a[i]+j*sizeof(int) ，在把 &amp;a[i] 的值用 &amp;a[0] 表示：</p>
<p>a[i][j]元素的首地址为 &amp;a[0] + i * sizeof(a[0]) + j<em>sizeof(int) , &amp;a[0] 和 a 作为右值是一样的，所以上面就等于 a + i * sizeof(a[0]) + j</em>sizeof(int) ;其中的a[0]就是上图中的包含4个int变量的一维数组。</p>
<p>再回到第一章的第二点（指针所指向的数据类型），a[0] 是一个一维数组，a 等效于 &amp;a[0]，a+i 就等同于 &amp;a[0] + i + sizeof(a[0]) //把a[0]当做一个整体元素看待，这里 a+i 就表示了a这个二维数组中的第i个一维数组，<em>(a+i) 就是取这个二维数组的第i个元素，这个元素是个一维数组，所以取到的值是这个一维数组的首地址，上面后面 + j*sizeof(int)，就是这个一维数组偏移 j*sizeof(int) 个字节位置，等效于</em> (a+i)+j，定位到了这个一维数组的第j个元素的首地址，所以再取这个元素值就是 * ( *(a+i)+j)。</p>
<p>所以，由此会衍生一个问题，就是二维数组的初始化声明的时候，第一个数字是可以不填写的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[][<span class="number">4</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;<span class="comment">//correct</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;<span class="comment">//error12</span></span><br></pre></td></tr></table></figure>

<p>原因相信你们都知道，看到第一个知道怎么划分，第二个声明呢，你会知道怎么划分么？3<em>4，3</em>5…</p>
<hr>
<h3 id="四、二级指针"><a href="#四、二级指针" class="headerlink" title="四、二级指针"></a><strong>四、二级指针</strong></h3><p>二级指针也是经常用的，比如函数传参，一级指针传参是为了修改其值，二级指针传值就是为了修改其一级指针，比如C语言实现链表结构，创建链表不带返回值时，就需要借助二级指针。</p>
<p>二级指针它终究是指针，它表示的也还是一个地址，只是这个地址里面的内容仍然是一个地址，对于一维数组需要 * 解引用一次，对于二维数组则需要 * 解引用两次。</p>
<hr>
<h4 id="二维数组和二级指针"><a href="#二维数组和二级指针" class="headerlink" title="二维数组和二级指针"></a><strong>二维数组和二级指针</strong></h4><p>首先，指针和数组是两个概念，一维数组和一级指针在一定程度上可以等效，因为，然后二维数组和二级指针就真没什么关系了。</p>
<p>事实上，我们可以利用一维数组与一级指针的某种等效关系，将两个“降维”处理再进行等效。</p>
<p>上一节说到，二维数组必须指定维数，必须指定后面的维数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[][<span class="number">4</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>] = a;<span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>看到“降维”了吧，p 是一个数组指针，指向一个数组，每个数组里面有4个int变量。<br>p 是一个数组指针，指向的是一个有4个 int 变量的数组，这里是{0,1,2,3} 四个元素，p+1 指向的数组里面的元素就是{4,5,6,7}</p>
<p>p+1 地址偏移了多少个字节，就看 p 这个指针指向的数据是什么类型的，这里是 一个存放四个 int 变量的数组，所以 p+1 偏移的字节数就是 4 * sizeof(int) bytes。<br><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/20160117125236102" alt="这里写图片描述"></p>
<p>那么回过头，可以不可以用 指针数组 替代呢？<br>回答这个问题前，我们先来了解下 数组指针 和 指针数组</p>
<hr>
<h3 id="五、复杂指针类型"><a href="#五、复杂指针类型" class="headerlink" title="五、复杂指针类型"></a><strong>五、复杂指针类型</strong></h3><h4 id="5-1、数组指针和指针数组"><a href="#5-1、数组指针和指针数组" class="headerlink" title="5.1、数组指针和指针数组"></a><strong>5.1、数组指针和指针数组</strong></h4><ul>
<li><strong>数组指针：首先它是一个指针，它指向一个数组。在32位系统下永远是占4个字节，至于它指向的数组占多少个字节，看声明。它是“指向数组的指针”的简称。</strong></li>
<li><strong>指针数组：首先他是一个数组，数组的元素都是指针，数组占多少字节由数组本身决定（指针本身占用的字节是固定的），它是“存储指针的数组”的简称。</strong></li>
</ul>
<p>到底如何判断是数组指针还是指针数组，以及后面的函数指针，函数指针数组等等更为复杂的指针类型，就涉及到<em>复杂指针的读法</em>了。<br>原则上：<strong>从变量名处起，根据运算符优先级结合，一步一步分析。</strong></p>
<p>这里先看数组指针和指针数组：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> *p1[<span class="number">10</span>];    <span class="comment">//A</span></span><br><span class="line"><span class="built_in">int</span> (*p2)[<span class="number">10</span>];  <span class="comment">//B12</span></span><br></pre></td></tr></table></figure>

<p>根据上面的元组，根据运算符优先级结合<br>对于A，[] 的优先级高于 * ，所以 p1 首先跟[] 结合，p1 是一个数组，这个数组存储的元素是什么类型的呢？ int<em>，所以 p1 是一个指针数组，且存放了10个这样的 int</em> 。<br>对于B，()的优先级高于[]，看()里面，* 与p2构成一个指针，所以p2首先是一个指针，再看外头的[]，这个指针指向一个数组，所以p2是一个数组指针，那么这个数组里面存放的数据类型是什么呢，int。</p>
<p><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/20160117131117792" alt="这里写图片描述"></p>
<p>从上面的分析步骤，我们看到一个指针也好看到一个数组也好，首先要有这么个概念：<strong>看到指针要分析它的四要素，其实主要就是第二个，即这个指针指向的数据类型是什么，看到数组要分析这个数组存放的数据类型是什么，看到函数要分析这个函数的参数和返回值是什么类型的。</strong></p>
<p>ok，再回到前面，我们得知，可以用数组指针代替一个二维数组，那么可否用指针数组来代替一个二维数组呢？</p>
<p>但是不行的，其实看了上面的指针数组和数组指针的内存布局，你就知道原因了，上图的第二个数组指针的内存布局和二维数组的内存布局是一样的，一个线性连续数组里面存放的都是int型变量，但是数组指针就不是了，里面存放的是 int*，数据类型都不一样了，你说能替代么？</p>
<p>那么很显然，<strong>二维数组也是不能通过二级指针替代的</strong>，二维数组需要明确知道第二维的维数(即第二个数字)，你用二级指针替代，编译器完全不知道内部内存的划分细节了，二级指针变量解引用一次后自增，编译器不知道该偏移多少字节位置。</p>
<hr>
<h4 id="5-2、函数指针"><a href="#5-2、函数指针" class="headerlink" title="5.2、函数指针"></a><strong>5.2、函数指针</strong></h4><p>函数指针顾名思义就是函数的指针，即指向一个函数的指针。<br>这个应用相当广泛，游览 linux kernel 的源码，随处可见，内核协议栈，VFS，文件操作函数等等充当各种接口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* (*fun1)(<span class="keyword">char</span> *p1, <span class="keyword">char</span> *p2);</span><br><span class="line"><span class="function"><span class="keyword">char</span>** <span class="title">fun2</span><span class="params">(<span class="keyword">char</span> *p1, <span class="keyword">char</span> *p2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fun3</span><span class="params">(<span class="keyword">char</span> *p1, <span class="keyword">char</span> *p2)</span></span>;<span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>根据上面的优先级结合原则，和另一原则，看到指针分析它指向数据类型，看到函数分析它的形参和返回值类型。</p>
<p>对于fun1，首先它是一个指针，从变量名处开始，()锁定优先级高，然后<em>与fun1结合，这个指针指向什么类型呢，看到后面有个()，说明这个指针指向一个函数，那麽这个函数的类型的，括号里面是函数形参，两个 char*</em>，返回值也是char<em>；<br>对于fun2，首先人家是一个函数（看优先级()高于 * ），不是指针类型，这个函数的返回值类型是char*</em>；<br>对于fun3，很普通的函数。</p>
<p>那么函数指针有何用处？最大的好处就是增加函数调用的灵活性，最常用于函数接口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment"> * read, write, poll, fsync, readv, writev can be called</span></span><br><span class="line"><span class="comment"> *   without the big kernel lock held in all filesystems.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">int</span> (*readdir) (struct file *, <span class="keyword">void</span> *, <span class="keyword">filldir_t</span>);</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> (*ioctl) (struct inode *, struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">    <span class="keyword">int</span> (*open) (struct inode *, struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*flush) (struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*release) (struct inode *, struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*fsync) (struct file *, struct dentry *, <span class="keyword">int</span> datasync);</span><br><span class="line">    <span class="keyword">int</span> (*fasync) (<span class="keyword">int</span>, struct file *, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*lock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*readv) (struct file *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*writev) (struct file *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">&#125;;<span class="number">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure>

<p>上面就是linux 内核中文件系统部分的源码，文件操作函数集，定义这个通用函数接口，编写内核驱动的时候，你可以自己实现对应的函数，然后把你的函数名赋值给上面的函数指针，这样就会调用你自己实现的函数了，这样就实现了，同样的函数接口可以通过调用不同的函数来实现不同的驱动。</p>
<hr>
<h4 id="5-3、函数指针数组"><a href="#5-3、函数指针数组" class="headerlink" title="5.3、函数指针数组"></a><strong>5.3、函数指针数组</strong></h4><p>首先它是一个数组，数组里面存放的是函数指针。<br>怎么定义一个函数指针数组？<br>层层封装，首先是一个数组 pf[3]，然后是指针数组 <em>pf[3]，再然后是函数指针数组 (</em>pf[3])()；ok 到了函数了，是什么形参什么返回值，个人需求了。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>* (*pf[<span class="number">3</span>])(<span class="built_in">int</span> *p);</span><br><span class="line"><span class="comment">//pf 是一个存放3个指针类型的数组，这个指针指向一个函数，这个函数的形参和返回值均是int* 类型12</span></span><br></pre></td></tr></table></figure>

<p>学过C++的一定知道，C++实现多态的虚函数表，实际上是一个函数指针数组。详见<a href="http://blog.csdn.net/wenqian1991/article/details/19205505" target="_blank" rel="noopener">C++对象模型</a></p>
<p>至于函数指针数组的指针，我们就不说了，举一反三，层层抽离、封装即可。</p>
<p>另外，函数名跟数组名是一个调调，都会被编译器解析为地址</p>
<hr>
<h4 id="5-4、复杂指针类型读法牛刀小试"><a href="#5-4、复杂指针类型读法牛刀小试" class="headerlink" title="5.4、复杂指针类型读法牛刀小试"></a><strong>5.4、复杂指针类型读法牛刀小试</strong></h4><h5 id="5-4-1-void-0"><a href="#5-4-1-void-0" class="headerlink" title="5.4.1 ( * (void(*) () )0 )();"></a><strong>5.4.1 ( * (void(*) () )0 )();</strong></h5><p>这是《C Traps and Pitfalls》这本经典书中的一个例子。怎么分析，读是层层剥离（优先级顺序），定义是层层封装（从右到左）</p>
<ol>
<li>void(*)()，这是一个函数指针，无参无返回值；</li>
<li>（void(*)()）0，这是将 0 强制转换为函数指针类型，0 是一个地址，就是说，这个函数保存在首地址为 0 的一段区域内（32平台下，这段区域长度是4个字节）；</li>
<li>（* （void(* ) ()）0），增加一个解引用符号 *，即取 0 地址开始的一段内存里面的内容，其内容就是保存在首地址为 0 的一段区域内的函数，直白点，内容就是一个函数；</li>
<li>( * (void(*) () )0 )()，函数调用。</li>
</ol>
<p>上面虽然没有看到习惯上的变量名，但是有 0 这个变量，常数也是变量啊</p>
<hr>
<h3 id="六、指针与结构体"><a href="#六、指针与结构体" class="headerlink" title="六、指针与结构体"></a><strong>六、指针与结构体</strong></h3><p>指针可以指向任何数据类型，自然也包括结构类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma pack(1)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> <span class="title">ss</span> = &#123;</span> <span class="number">20</span>, <span class="string">'w'</span>, <span class="number">40</span> &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> *<span class="title">pss</span> = &amp;<span class="title">ss</span>;</span></span><br><span class="line">    <span class="keyword">int</span> *ptr = (<span class="keyword">int</span> *) &amp;ss;<span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<p>上面的注释我就免了，如果看到这里，你还不知道，我只好说，你不适合走编程这条路。</p>
<p>我们都知道访问结构体成员的时候，我们都是这样的访问的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ss.a;</span><br><span class="line">pss-&gt;b;<span class="comment">//建议用这种，也最常用12</span></span><br></pre></td></tr></table></figure>

<p>那么后面我们可以不可以通过 ptr 指针来访问呢，答案是否定的，这是因为结构体成员对齐的原因。<br><strong>编译器在存放结构体对象的时候，一般会考虑字节对齐或双字节对齐等等，则需要在相邻两个非对齐成员（不同类型）之间补上若干个“填充字节”用于对齐。</strong><br>因为结构体是把不同个数据类型成员捆绑在一起，不像数组里面的元素都是同一种类型。</p>
<p>回到上面，为何不能用 ptr 指针访问？<br>首先你可以通过 <em>*ptr 获得第一个int 成员的值，</em> <em>ptr == 20；<br>第二个char成员呢，你可以这样获得 * (((char</em>)ptr)+1) ==’w’;<br>那么后面的成员b，你怎么通过 ptr 获得，由 ptr 偏移 sizeof(int) + sizeof(char) 个字节？你可以试试，但是我会告诉你得到的结果绝对不是40，除非你的编译器是对结构器不对齐的，或者你添加了 #pragma pack(1)</p>
<p><strong>看内存布局：</strong><br>默认对齐方式下：</p>
<p><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/20160117144211853" alt="这里写图片描述"></p>
<p>不对齐方式下（以1byte对齐），不注释#pragma pack(1)</p>
<p><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/20160117144345249" alt="这里写图片描述"></p>
<p>其余的不用看，直接看两种方式下，结构体中的成员的地址。</p>
<hr>
<h3 id="七、指针类型转换"><a href="#七、指针类型转换" class="headerlink" title="七、指针类型转换"></a><strong>七、指针类型转换</strong></h3><p>其实前面我们或多或少的讲到了指针类型转换，记住一个原则，你在应用指针类型转换的时候，你要清楚转换对象与被转换对象的内存布局，上面的指针与结构类型一节就涉及到了。</p>
<p><strong>强制类型转换之后，原来的指针的一切属性都没有被修改，转换后的指针，它所运算（指针加减）的单位变了。</strong></p>
<p>char* 强制转换为 int*，转换后加减的单位成了4个字节，但是原来的指针还是不变的。</p>
<p>指针类型转换，在linux 内核网络协议栈中尤为常见，而且那里还是结构体类型的强制转换，不过人家大神在写那些结构体的时候，设计的时候都是严格按照成员对齐方式的，即使从链路层抽离网络层的ip首部，之后还是可以正确访问到ip首部数据的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面代码来源于linux kernel 源码，以及博文中发送skb代码</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct iphdr *<span class="title">ip_hdr</span><span class="params">(<span class="keyword">const</span> struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (struct iphdr *)skb_network_header(skb);</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">    udph = (struct udphdr*)skb_push(skb, <span class="keyword">sizeof</span>(struct udphdr));</span><br><span class="line">    iph = (struct iphdr*)skb_push(skb, <span class="keyword">sizeof</span>(struct iphdr));</span><br><span class="line">    ethdr = (struct ethhdr*)skb_push(skb, <span class="keyword">sizeof</span>(struct ethhdr));<span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p>突然发现，linux kernel 源码真是一个学习C语言的好项目啊。</p>
<hr>
<h3 id="八、指针安全"><a href="#八、指针安全" class="headerlink" title="八、指针安全"></a><strong>八、指针安全</strong></h3><p>前面一到七章，从各个层面分析了C语言中指针的好处，这也是C语言风靡至今屹立不倒的一个重要原因，但技术总是一把双刃剑，在带来强大功能的同时，也会带来一些列安全问题。</p>
<p>正因为指针可以指向用户空间内存的任意位置，这就意味着，我们可以读取甚至修改用户空间中用户程序可以访问的任一内存。</p>
<p>这是比较恐怖的，万一你通过指针去修改的那块内存，恰恰是一个代码段，或者另一个线程空间，那么程序就会崩溃。</p>
<p>为什么说一个进程下的某一个线程崩溃了，就会导致进程崩溃？首先确定这个崩溃是由于内存访问造成的。因为线程没有自己独立的内存地址空间，一个进程下的所有线程都是共享进程下的内存地址空间的，在一个线程中把另外一个线程的栈空间写坏是再正常不过的事情了。因为一个线程都可以通过内存地址（指针）访问到其他线程的栈空间，所以指针数据的错误可以导致任何同地址空间内其他线程的崩溃，当然也可以导致进程崩溃。</p>
<p>所以编写程序，在使用指针时，程序员心里必须非常清楚：我的指针究竟指向了哪里，用指针访问数组的时候，注意不要越界。换言之，你要确保你用指针访问的内存区域是安全的，对它进行访问不会产生安全隐患，不要去访问未定义区域。</p>
<hr>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a><strong>结束语</strong></h3><p>至此，算是把C语言中的指针剖析的差不多了吧，本人做技术比较喜欢追溯内部细节和底层原理，知其然并知其所以然。</p>
<p>建议大家在学习C语言指针的时候，一定要手动编写程序逐个测试，做技术忌眼高手低。我个人初学（几年前了）的时候，比较喜欢调试，不是直接运行看结果，监视各个变量以及地址，再者就是通过反汇编看起汇编代码，熟悉内部原理。</p>
<p>visual studio 2013 这个 IDE 用于学习C和C++内部原理还是非常方便的，个人不打Windows和Linux的口水仗，但我还是喜欢在 linux下开发</p>
<p>阅读一些优秀的开源项目 linux kernel、STL（C++）等，在Windows下用SourceInsight看源码，然后在linux下开发，怪不得开发人员都要有两台电脑。</p>
<p>另外，由于 MarkDown 编辑器的原因，符号‘<em>’在该编辑器中是一个操作符，所以在可能在某些地方声明指针的时候，可能会出现</em> 被编辑器当作操作符处理了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/25/C++%E6%96%87%E4%BB%B61/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/25/C++%E6%96%87%E4%BB%B61/" class="post-title-link" itemprop="url">C++文件1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-25 22:05:04 / 修改时间：22:06:46" itemprop="dateCreated datePublished" datetime="2020-12-25T22:05:04+08:00">2020-12-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>基于C的文件操作<br>　　在ANSI C中，对文件的操作分为两种方式，即流式文件操作和I/O文件操作，下面就分别介绍之。</p>
<p>一、流式文件操作<br>这种方式的文件操作有一个重要的结构FILE，FILE在stdio.h中定义如下：</p>
<p><img src="/2020/12/25/C++%E6%96%87%E4%BB%B61/48304ba5e6f9fe08f3fa1abda7d326ab.png" alt="复制代码"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line"></span><br><span class="line">　　<span class="keyword">int</span> level;　　　　　　　　　　　<span class="comment">/* fill/empty level of buffer */</span> </span><br><span class="line"></span><br><span class="line">　　<span class="keyword">unsigned</span> flags; 　　　　　　 <span class="comment">/* File status flags */</span> </span><br><span class="line"></span><br><span class="line">　　<span class="keyword">char</span> fd;　　　　　　　　　　　 <span class="comment">/* File descriptor */</span> </span><br><span class="line"></span><br><span class="line">　　<span class="keyword">unsigned</span> <span class="keyword">char</span> hold;　　　　  <span class="comment">/* Ungetc char if no buffer */</span> </span><br><span class="line"></span><br><span class="line">　　<span class="keyword">int</span> bsize;　　　　　　　　　　 <span class="comment">/* Buffer size */</span> </span><br><span class="line"></span><br><span class="line">　　<span class="keyword">unsigned</span> <span class="keyword">char</span> _FAR *<span class="built_in">buffer</span>;　<span class="comment">/* Data transfer buffer */</span> </span><br><span class="line"></span><br><span class="line">　　<span class="keyword">unsigned</span> <span class="keyword">char</span> _FAR *curp;　　<span class="comment">/* Current active pointer */</span> </span><br><span class="line"></span><br><span class="line">　　<span class="keyword">unsigned</span> istemp;　　　　　　<span class="comment">/* Temporary file indicator */</span> </span><br><span class="line"></span><br><span class="line">　　short token;　　　　　　　　  <span class="comment">/* Used for validity checking */</span> </span><br><span class="line"></span><br><span class="line">&#125; FILE;　　　　　　　　　　　　  <span class="comment">/* This is the FILE object */</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/48304ba5e6f9fe08f3fa1abda7d326ab.png" alt="复制代码"></p>
<p>　　FILE这个结构包含了文件操作的基本属性，对文件的操作都要通过这个结构的指针来进行，此种文件操作常用的函数见下表 函数 功能 </p>
<p>　　fopen() 打开流<br>　　fclose() 关闭流<br>　　fputc() 写一个字符到流中<br>　　fgetc() 从流中读一个字符<br>　　fseek() 在流中定位到指定的字符<br>　　fputs() 写字符串到流<br>　　fgets() 从流中读一行或指定个字符<br>　　fprintf() 按格式输出到流<br>　　fscanf() 从流中按格式读取<br>　　feof() 到达文件尾时返回真值<br>　　ferror() 发生错误时返回其值<br>　　rewind() 复位文件定位器到文件开始处<br>　　remove() 删除文件<br>　　fread() 从流中读指定个数的字符<br>　　fwrite() 向流中写指定个数的字符<br>　　tmpfile() 生成一个临时文件流<br>　　tmpnam() 生成一个唯一的文件名</p>
<p>下面就介绍一下这些函数</p>
<p>1.fopen()<br>　　fopen的原型是：FILE *fopen(const char *filename,const char *mode)，fopen实现三个功能</p>
<p>　　为使用而打开一个流<br>　　把一个文件和此流相连接<br>　　给此流返回一个FILR指针<br>　　参数filename指向要打开的文件名，mode表示打开状态的字符串，其取值如下表</p>
<p>　　字符串 含义<br>　　“r” 以只读方式打开文件<br>　　“w” 以只写方式打开文件<br>　　“a” 以追加方式打开文件<br>　　“r+” 以读/写方式打开文件，如无文件出错<br>　　“w+” 以读/写方式打开文件，如无文件生成新文件</p>
<p>　　一个文件可以以文本模式或二进制模式打开，这两种的区别是：在文本模式中回车被当成一个字符’/n’，而二进制模式认为它是两个字符0x0D,0x0A；如果在文件中读到0x1B，文本模式会认为这是文件结束符，也就是二进制模型不会对文件进行处理，而文本方式会按一定的方式对数据作相应的转换。</p>
<p>　　系统默认的是以文本模式打开，可以修改全部变量_fmode的值来修改这个设置，例如_fmode=O_TEXT；就设置默认打开方式为文本模式；而_fmode=O_BINARY；则设置默认打开方式是二进制模式。</p>
<p>　　我们也可以在模式字符串中指定打开的模式，如”rb”表示以二进制模式打开只读文件，”w+t”或”wt+”表示以文本模式打开读/写文件。</p>
<p>　　此函数返回一个FILE指针，所以申明一个FILE指针后不用初始化，而是用fopen()来返回一个指针并与一个特定的文件相连，如果成败，返回NULL。</p>
<p>　　例:</p>
<p>　　FILE *fp;<br>　　if(fp=fopen(“123.456”,”wb”))<br>　　puts(“打开文件成功”);<br>　　else<br>　　puts(“打开文件成败”);</p>
<p>2.fclose()<br>　　fclose()的功能就是关闭用fopen()打开的文件，其原型是：int fclose(FILE *fp);如果成功，返回0,失败返回EOF。</p>
<p>　　在程序结束时一定要记得关闭打开的文件，不然可能会造成数据丢失的情况，我以前就经常犯这样的毛病。</p>
<p>　　例：fclose(fp);</p>
<p>3.fputc()<br>　　向流写一个字符，原型是int fputc(int c, FILE *stream); 成功返回这个字符,失败返回EOF。</p>
<p>　　例：fputc(‘X’,fp);</p>
<p>4.fgetc()<br>　　从流中读一个字符，原型是int fputc(FILE *stream); 成功返回这个字符,失败返回EOF。</p>
<p>　　例：char ch1=fgetc(fp);</p>
<p>\5. fseek()<br>　　此函数一般用于二进制模式打开的文件中，功能是定位到流中指定的位置，原型是int fseek(FILE *stream, long offset, int whence);如果成功返回0，参数offset是移动的字符数，whence是移动的基准，取值是</p>
<p>　　符号常量 值 基准位置<br>　　SEEK_SET 0 文件开头<br>　　SEEK_CUR 1 当前读写的位置<br>　　SEEK_END 2 文件尾部</p>
<p>　　例：fseek(fp,1234L,SEEK_CUR);//把读写位置从当前位置向后移动1234字节(L后缀表示长整数)</p>
<p>　　fseek(fp,0L,2);//把读写位置移动到文件尾</p>
<p>6.fputs()<br>　　写一个字符串到流中，原型int fputs(const char *s, FILE *stream);</p>
<p>　　例：fputs(“I Love You”,fp);</p>
<p>7.fgets()<br>　　从流中读一行或指定个字符，原型是char *fgets(char *s, int n, FILE *stream); 从流中读取n-1个字符，除非读完一行，参数s是来接收字符串，如果成功则返回s的指针，否则返回NULL。</p>
<p>　　例：如果一个文件的当前位置的文本如下</p>
<p>　　Love ,I Have</p>
<p>　　But ……..</p>
<p>　　如果用</p>
<p>　　fgets(str1,4,file1);</p>
<p>　　则执行后str1=”Lov”，读取了4-1=3个字符，而如果用</p>
<p>　　fgets(str1,23,file1);</p>
<p>　　则执行str=”Love ,I Have”，读取了一行(不包括行尾的’/n’)。</p>
<p>8.fprintf()<br>　　按格式输入到流，其原型是int fprintf(FILE *stream, const char *format[, argument, …]);其用法和printf()相同，不过不是写到控制台，而是写到流罢了</p>
<p>　　例：fprintf(fp,”%2d%s”,4,”Hahaha”);</p>
<p>9.fscanf()<br>　　从流中按格式读取，其原型是int fscanf(FILE *stream, const char *format[, address, …]);其用法和scanf()相同，不过不是从控制台读取，而是从流读取罢了。</p>
<p>　　例：fscanf(fp,”%d%d” ,&amp;x,&amp;y);</p>
<p>10.feof()<br>　　检测是否已到文件尾，是返回真，否则返回0，其原型是int feof(FILE *stream);</p>
<p>　　例：if(feof(fp))printf(“已到文件尾”);</p>
<p>11.ferror()<br>　　原型是int ferror(FILE *stream);返回流最近的错误代码，可用clearerr()来清除它，clearerr()的原型是void clearerr(FILE *stream);</p>
<p>　　例：printf(“%d”,ferror(fp));</p>
<p>12.rewind()<br>　　把当前的读写位置回到文件开始，原型是void rewind(FILE *stream);其实本函数相当于fseek(fp,0L,SEEK_SET);</p>
<p>　　例：rewind(fp);</p>
<p>13.remove()<br>　　删除文件，原型是int remove(const char *filename); 参数就是要删除的文件名，成功返回0。</p>
<p>　　例：remove(“c://io.sys”);</p>
<p>14.fread()<br>　　从流中读指定个数的字符，原型是size_t fread(void <em>ptr, size_t size, size_t n, FILE *stream);参数ptr是保存读取的数据，void</em>的指针可用任何类型的指针来替换，如char*、int *等等来替换；size是每块的字节数；n是读取的块数，如果成功，返回实际读取的块数(不是字节数)，本函数一般用于二进制模式打开的文件中。</p>
<p>　　例：</p>
<p>　　char x[4230];<br>　　FILE <em>file1=fopen(“c://msdos.sys”,”r”);<br>　　fread(x,200,12 ,file1);//共读取200</em>12=2400个字节</p>
<p>15.fwrite()<br>　　与fread对应，向流中写指定的数据，原型是size_t fwrite(const void <em>ptr, size_t size, size_t n, FILE *stream);参数ptr是要写入的数据指针，void</em>的指针可用任何类型的指针来替换，如char*、int *等等来替换；size是每块的字节数；n是要写的块数，如果成功，返回实际写入的块数(不是字节数)，本函数一般用于二进制模式打开的文件中。</p>
<p>　　例：</p>
<p>　　char x[]=”I Love You”;<br>　　fwire(x, 6,12,fp);//写入6*12=72字节</p>
<p>　　将把”I Love”写到流fp中12次，共72字节</p>
<p>16.tmpfile()<br>　　其原型是FILE *tmpfile(void); 生成一个临时文件，以”w+b”的模式打开，并返回这个临时流的指针，如果失败返回NULL。在程序结束时，这个文件会被自动删除。</p>
<p>　　例：FILE *fp=tmpfile();</p>
<p>17.tmpnam();<br>　　其原型为char *tmpnam(char *s); 生成一个唯一的文件名，其实tmpfile()就调用了此函数，参数s用来保存得到的文件名，并返回这个指针，如果失败，返回NULL。</p>
<p>borland c++ bulder的文件操作总结２</p>
<p>二、直接I/O文件操作<br>　　这是C提供的另一种文件操作，它是通过直接存/取文件来完成对文件的处理，而上篇所说流式文件操作是通过缓冲区来进行；流式文件操作是围绕一个FILE指针来进行，而此类文件操作是围绕一个文件的”句柄”来进行，什么是句柄呢？它是一个整数，是系统用来标识一个文件(在WINDOWS中，句柄的概念扩展到所有设备资源的标识)的唯一的记号。此类文件操作常用的函数如下表，这些函数及其所用的一些符号在io.h和fcntl.h中定义，在使用时要加入相应的头文件。</p>
<p>　　函数 说明<br>　　open() 打开一个文件并返回它的句柄<br>　　close() 关闭一个句柄<br>　　lseek() 定位到文件的指定位置<br>　　read() 块读文件<br>　　write() 块写文件<br>　　eof() 测试文件是否结束<br>　　filelength() 取得文件长度<br>　　rename() 重命名文件<br>　　chsize() 改变文件长度</p>
<p>下面就对这些函数一一说明：</p>
<p>1.open()<br>　　打开一个文件并返回它的句柄，如果失败，将返回一个小于0的值，原型是int open(const char *path, int access [, unsigned mode]); 参数path是要打开的文件名，access是打开的模式，mode是可选项。表示文件的属性，主要用于UNIX系统中，在DOS/WINDOWS这个参数没有意义。其中文件的打开模式如下表。</p>
<p>　　符号 含义 符号 含义 符号 含义<br>　　O_RDONLY 只读方式 O_WRONLY 只写方式 O_RDWR 读/写方式<br>　　O_NDELAY 用于UNIX系统 O_APPEND 追加方式 O_CREAT 如果文件不存在就创建<br>　　O_TRUNC 把文件长度截为0 O_EXCL 和O_CREAT连用，如果文件存在返回错误 O_BINARY 二进制方式<br>　　O_TEXT 文本方式</p>
<p>　　对于多个要求，可以用”|”运算符来连接，如O_APPEND|O_TEXT表示以文本模式和追加方式打开文件。</p>
<p>　　例：int handle=open(“c://msdos.sys”,O_BINARY|O_CREAT|O_WRITE)</p>
<p>2.close()<br>　　关闭一个句柄，原型是int close(int handle);如果成功返回0</p>
<p>　　例：close(handle)</p>
<p>3.lseek()<br>　　定位到指定的位置，原型是：long lseek(int handle, long offset, int fromwhere);参数offset是移动的量，fromwhere是移动的基准位置，取值和前面讲的fseek()一样，SEEK_SET：文件首部；SEEK_CUR：文件当前位置；SEEK_END：文件尾。此函数返回执行后文件新的存取位置。</p>
<p>　　例：</p>
<p>　　lseek(handle,-1234L,SEEK_CUR);//把存取位置从当前位置向前移动1234个字节。<br>　　x=lseek(hnd1,0L,SEEK_END);//把存取位置移动到文件尾，x=文件尾的位置即文件长度</p>
<p>4.read()<br>　　从文件读取一块，原型是int read(int handle, void *buf, unsigned len);参数buf保存读出的数据，len是读取的字节。函数返回实际读出的字节。</p>
<p>　　例：char x[200];read(hnd1,x,200);</p>
<p>5.write()<br>　　写一块数据到文件中，原型是int write(int handle, void *buf, unsigned len);参数的含义同read()，返回实际写入的字节。</p>
<p>　　例：char x[]=”I Love You”;write(handle,x,strlen(x));</p>
<p>6.eof()<br>　　类似feof()，测试文件是否结束，是返回1，否则返回0;原型是：int eof(int handle);</p>
<p>　　例：while(!eof(handle1)){……};</p>
<p>7.filelength()<br>　　返回文件长度，原型是long filelength(int handle);相当于lseek(handle,0L,SEEK_END)</p>
<p>　　例：long x=filelength(handle);</p>
<p>8.rename()<br>　　重命名文件，原型是int rename(const char *oldname, const char *newname); 参数oldname是旧文件名，newname是新文件名。成功返回0</p>
<p>　　例：rename(“c://config.sys”,”c://config.w40”);</p>
<p>9.chsize();<br>　　改变文件长度，原型是int chsize(int handle, long size);参数size表示文件新的长度，成功返回0，否则返回-1，如果指定的长度小于文件长度，则文件被截短；如果指定的长度大于文件长度，则在文件后面补’/0’。</p>
<p>　　例：chsize(handle,0x12345);</p>
<p>-——————————————————————————-</p>
<p>　　如果熟悉汇编可能会发现这种方式和汇编语言的DOS功能调用句柄式文件操作很像，比如open()就像DOS服务的3CH号功能调用，其实这种操作还有两种类型的函数就是直接用DOS功能来完成的，如_open()，_dos_open()等等。有兴趣可自已查询BCB的帮助。</p>
<p>　　同流式文件操作相同，这种也提供了Unicode字符操作的函数，如_wopen()等等，用于9X/NT下的宽字符编程，有兴趣可自已查询BCB的帮助。</p>
<p>　　另外，此种操作还有lock(),unlock(),locking()等用于多用户操作的函数，但在BCB中用得并不多，我就不介绍了，但如果要用C来写CGI，这些就必要的常识了，如果你有这方面的要求，那就得自已好好看帮助了。</p>
<p>　　到这里，我就把基于C的文件操作介绍完了，下一篇将介绍基于C++的文件操作，敬请期待。</p>
<p>在C++中，有一个stream这个类，所有的I/O都以这个”流”类为基础的，包括我们要认识的文件I/O，stream这个类有两个重要的运算符：</p>
<p>1、插入器(&lt;&lt;)<br>　　向流输出数据。比如说系统有一个默认的标准输出流(cout)，一般情况下就是指的显示器，所以，cout&lt;&lt;”Write Stdout”&lt;&lt;’/n’;就表示把字符串”Write Stdout”和换行字符(‘/n’)输出到标准输出流。</p>
<p>2、析取器(&gt;&gt;)<br>　　从流中输入数据。比如说系统有一个默认的标准输入流(cin)，一般情况下就是指的键盘，所以，cin&gt;&gt;x;就表示从标准输入流中读取一个指定类型(即变量x的类型)的数据。</p>
<p>在C++中，对文件的操作是通过stream的子类fstream(file stream)来实现的，所以，要用这种方式操作文件，就必须加入头文件fstream.h。下面就把此类的文件操作过程一一道来。</p>
<p>一、打开文件<br>　　在fstream类中，有一个成员函数open()，就是用来打开文件的，其原型是：</p>
<p>　　void open(const char* filename,int mode,int access);</p>
<p>　　参数：</p>
<p>　　filename：　　要打开的文件名<br>　　mode：　　　　要打开文件的方式<br>　　access：　　　打开文件的属性<br>　　打开文件的方式在类ios(是所有流式I/O类的基类)中定义，常用的值如下：</p>
<p>　　ios::app：　　　以追加的方式打开文件<br>　　ios::ate：　　　文件打开后定位到文件尾，ios:app就包含有此属性<br>　　ios::binary： 　以二进制方式打开文件，缺省的方式是文本方式。两种方式的区别见前文<br>　　ios::in：　　　 文件以输入方式打开<br>　　ios::out：　　　文件以输出方式打开<br>　　ios::nocreate： 不建立文件，所以文件不存在时打开失败　<br>　　ios::noreplace：不覆盖文件，所以打开文件时如果文件存在失败<br>　　ios::trunc：　　如果文件存在，把文件长度设为0<br>　　可以用”或”把以上属性连接起来，如ios::out|ios::binary</p>
<p>　　打开文件的属性取值是：</p>
<p>　　0：普通文件，打开访问<br>　　1：只读文件<br>　　2：隐含文件<br>　　4：系统文件<br>　　可以用”或”或者”+”把以上属性连接起来 ，如3或1|2就是以只读和隐含属性打开文件。</p>
<p>　　例如：以二进制输入方式打开文件c:/config.sys</p>
<p>　　fstream file1;<br>　　file1.open(“c://config.sys”,ios::binary|ios::in,0);</p>
<p>　　如果open函数只有文件名一个参数，则是以读/写普通文件打开，即：</p>
<p>　　file1.open(“c://config.sys”);&lt;=&gt;file1.open(“c://config.sys”,ios::in|ios::out,0);</p>
<p>　　另外，fstream还有和open()一样的构造函数，对于上例，在定义的时侯就可以打开文件了：</p>
<p>　　fstream file1(“c://config.sys”);</p>
<p>　　特别提出的是，fstream有两个子类：ifstream(input file stream)和ofstream(outpu file stream)，ifstream默认以输入方式打开文件，而ofstream默认以输出方式打开文件。</p>
<p>　　ifstream file2(“c://pdos.def”);//以输入方式打开文件<br>　　ofstream file3(“c://x.123”);//以输出方式打开文件</p>
<p>　　所以，在实际应用中，根据需要的不同，选择不同的类来定义：如果想以输入方式打开，就用ifstream来定义；如果想以输出方式打开，就用ofstream来定义；如果想以输入/输出方式来打开，就用fstream来定义。</p>
<p>二、关闭文件<br>　　打开的文件使用完成后一定要关闭，fstream提供了成员函数close()来完成此操作，如：file1.close();就把file1相连的文件关闭。</p>
<p>三、读写文件<br>　　读写文件分为文本文件和二进制文件的读取，对于文本文件的读取比较简单，用插入器和析取器就可以了；而对于二进制的读取就要复杂些，下要就详细的介绍这两种方式</p>
<p>　　1、文本文件的读写<br>　　文本文件的读写很简单：用插入器(&lt;&lt;)向文件输出；用析取器(&gt;&gt;)从文件输入。假设file1是以输入方式打开，file2以输出打开。示例如下：</p>
<p>　　file2&lt;&lt;”I Love You”;//向文件写入字符串”I Love You”<br>　　int i;<br>　　file1&gt;&gt;i;//从文件输入一个整数值。</p>
<p>　　这种方式还有一种简单的格式化能力，比如可以指定输出为16进制等等，具体的格式有以下一些</p>
<p>　　操纵符 功能 输入/输出<br>　　dec 格式化为十进制数值数据 输入和输出<br>　　endl 输出一个换行符并刷新此流 输出<br>　　ends 输出一个空字符 输出<br>　　hex 格式化为十六进制数值数据 输入和输出<br>　　oct 格式化为八进制数值数据 输入和输出<br>　　setpxecision(int p) 设置浮点数的精度位数 输出</p>
<p>　　比如要把123当作十六进制输出：file1&lt;<br>　　2、二进制文件的读写<br>　　①put()<br>　　put()函数向流写入一个字符，其原型是ofstream &amp;put(char ch)，使用也比较简单，如file1.put(‘c’);就是向流写一个字符’c’。</p>
<p>　　②get()<br>　　get()函数比较灵活，有3种常用的重载形式：</p>
<p>　　一种就是和put()对应的形式：ifstream &amp;get(char &amp;ch);功能是从流中读取一个字符，结果保存在引用ch中，如果到文件尾，返回空字符。如file2.get(x);表示从文件中读取一个字符，并把读取的字符保存在x中。</p>
<p>　　另一种重载形式的原型是： int get();这种形式是从流中返回一个字符，如果到达文件尾，返回EOF，如x=file2.get();和上例功能是一样的。</p>
<p>　　还有一种形式的原型是：ifstream &amp;get(char *buf,int num,char delim=’/n’)；这种形式把字符读入由 buf 指向的数组，直到读入了 num 个字符或遇到了由 delim 指定的字符，如果没使用 delim 这个参数，将使用缺省值换行符’/n’。例如：</p>
<p>　　file2.get(str1,127,’A’);//从文件中读取字符到字符串str1，当遇到字符’A’或读取了127个字符时终止。</p>
<p>　　③读写数据块<br>　　要读写二进制数据块，使用成员函数read()和write()成员函数，它们原型如下：</p>
<p>　　read(unsigned char *buf,int num);<br>　　write(const unsigned char *buf,int num);</p>
<p>　　read()从文件中读取 num 个字符到 buf 指向的缓存中，如果在还未读入 num 个字符时就到了文件尾，可以用成员函数 int gcount();来取得实际读取的字符数；而 write() 从buf 指向的缓存写 num 个字符到文件中，值得注意的是缓存的类型是 unsigned char *，有时可能需要类型转换。</p>
<p>　　例：</p>
<p>　　unsigned char str1[]=”I Love You”;<br>　　int n[5];<br>　　ifstream in(“xxx.xxx”);<br>　　ofstream out(“yyy.yyy”);<br>　　out.write(str1,strlen(str1));//把字符串str1全部写到yyy.yyy中<br>　　in.read((unsigned char*)n,sizeof(n));//从xxx.xxx中读取指定个整数，注意类型转换<br>　　in.close();out.close();</p>
<p>四、检测EOF<br>　　成员函数eof()用来检测是否到达文件尾，如果到达文件尾返回非0值，否则返回0。原型是int eof();</p>
<p>　　例：　　if(in.eof())ShowMessage(“已经到达文件尾！”);</p>
<p>五、文件定位<br>　　和C的文件操作方式不同的是，C++ I/O系统管理两个与一个文件相联系的指针。一个是读指针，它说明输入操作在文件中的位置；另一个是写指针，它下次写操作的位置。每次执行输入或输出时，相应的指针自动变化。所以，C++的文件定位分为读位置和写位置的定位，对应的成员函数是 seekg()和 seekp()，seekg()是设置读位置，seekp是设置写位置。它们最通用的形式如下：</p>
<p>　　istream &amp;seekg(streamoff offset,seek_dir origin);<br>　　ostream &amp;seekp(streamoff offset,seek_dir origin);</p>
<p>　　streamoff定义于 iostream.h 中，定义有偏移量 offset 所能取得的最大值，seek_dir 表示移动的基准位置，是一个有以下值的枚举：</p>
<p>　　ios::beg：　　文件开头<br>　　ios::cur：　　文件当前位置<br>　　ios::end：　　文件结尾<br>　　这两个函数一般用于二进制文件，因为文本文件会因为系统对字符的解释而可能与预想的值不同。</p>
<p>　　例：</p>
<p>　　file1.seekg(1234,ios::cur);//把文件的读指针从当前位置向后移1234个字节<br>　　file2.seekp(1234,ios::beg);//把文件的写指针从文件开头向后移1234个字节</p>
<p>-—————————————————————————————————————————————–</p>
<p>在BCB中也提供了文件操作的函数，这些函数的功能和前面所介绍的大致相同，但这类函数和BCB关系紧密，能使用BCB中的AnsiString等数据类型，在BCB中用这种方式的文件操作是最方便的，下面我就把这种文件操作详细介绍。</p>
<p>在BCB提供的这组文件操作函数中，可分为三种类型，就是：1、文件名函数，2、文件管理函数；3、文件I/O函数。</p>
<p>1、文件名函数<br>　　文件名函数可以对文件的名称、所在子目录、驱动器和扩展名等进行操作。下表列出这些函数及其功能。</p>
<p>　　函数 说明<br>　　ExpandFileName() 返回文件的全路径(含驱动器、路径)<br>　　ExtractFileExt() 从文件名中抽取扩展名<br>　　ExtractFileName() 从文件名中抽取不含路径的文件名<br>　　ExtractFilePath() 从文件名中抽取路径名<br>　　ExtractFileDir() 从文件名中抽取目录名<br>　　ExtractFileDrive() 从文件名中抽取驱动器名<br>　　ChangeFileExt() 改变文件的扩展名<br>　　ExpandUNCFileName() 返回含有网络驱动器的文件全路径<br>　　ExtractRelativePath() 从文件名中抽取相对路径信息<br>　　ExtractShortPathName() 把文件名转化为DOS的8·3格式<br>　　MatchesMask() 检查文件是否与指定的文件名格式匹配</p>
<p>　　下面就把这些函数作一一介绍：</p>
<p>　　⑴ExpandFileName()<br>　　原型：extern PACKAGE AnsiString __fastcall ExpandFileName(const AnsiString FileName);</p>
<p>　　功能：返回文件的全路径(含驱动器、路径)</p>
<p>　　参数：FileName:要处理的文件名</p>
<p>　　例：ShowMessage(ExpandFileName(Application-&gt;ExeName));//显示你的程序文件名，如C:/MyBCB/Sample1.EXE</p>
<p>　　⑵ExtractFileExt()<br>　　原型：extern PACKAGE AnsiString __fastcall ExtractFileExt(const AnsiString FileName);</p>
<p>　　功能：从文件名中抽取扩展名</p>
<p>　　参数：FileName:要处理的文件名（全路径）</p>
<p>　　例：ShowMessage(ExtractFileExt(Application-&gt;ExeName));//显示”.exe”</p>
<p>　　⑶ExtractFileName()<br>　　原型：extern PACKAGE AnsiString __fastcall ExtractFileName(const AnsiString FileName);</p>
<p>　　功能：从文件名中抽取不含路径的文件名</p>
<p>　　参数：FileName:要处理的文件名</p>
<p>　　例：ShowMessage(ExtractFileExt(“c://Winnt//SOL.EXE”));//显示”SOL.EXE”</p>
<p>　　⑷ExtractFilePath()<br>　　原型：extern PACKAGE AnsiString __fastcall ExtractFilePath(const AnsiString FileName);</p>
<p>　　功能：从文件名中抽取路径名</p>
<p>　　参数：FileName:要处理的文件名</p>
<p>　　例：ShowMessage(ExtractFilePath(“Winnt//SOL.EXE”));//显示”Winnt/“</p>
<p>　　⑸ExtractFileDir()<br>　　原型：extern PACKAGE AnsiString __fastcall ExtractFileDir(const AnsiString FileName);</p>
<p>　　功能：从文件名中抽取目录名(和上个函数不同，不包括最后的”/“)</p>
<p>　　参数：FileName:要处理的文件名</p>
<p>　　例：ShowMessage(ExtractFileDir(“Winnt//SOL.EXE”));//显示”Winnt”,注意和上个函数的区别</p>
<p>　　⑹ExtractFileDrive()<br>　　原型：extern PACKAGE AnsiString __fastcall ExtractFileDrive(const AnsiString FileName);</p>
<p>　　功能：从文件名中抽取驱动器名</p>
<p>　　参数：FileName:要处理的文件名</p>
<p>　　例：ShowMessage(ExtractFileDrive(“c://Winnt//SOL.EXE”));//显示”c:”</p>
<p>　　⑺ChangeFileExt()<br>　　原型：extern PACKAGE System::AnsiString __fastcall ChangeFileExt(const System::AnsiString FileName, const System::AnsiString Extension);</p>
<p>　　功能：更改文件名的扩展名，不是对真正的文件进行改名，只是对文件名这个字符串进行处理</p>
<p>　　参数：FileName:要改名的文件名，Extension：新的扩展名</p>
<p>　　例：ShowMessage(ChangeFileExt(“c://Winnt//SOL.EXE”,”.OOO”));//显示”c:/winnt/SOL.OOO”</p>
<p>　　⑻ExpandUNCFileName()<br>　　原型：extern PACKAGE AnsiString __fastcall ExpandUNCFileName(const AnsiString FileName);</p>
<p>　　功能：返回含有网络驱动器的文件全路径，格式为：//机器名/共享名/文件名</p>
<p>　　参数：FileName:要处理的文件名</p>
<p>　　例：ShowMessage(ExpandUNCFileName(“F://Winnt//SOL.EXE”));/<em>如果F:是映射的网络驱动器//NT40/WINNT，则显示”//NT40/WINNT/SOL.EXE”</em>/</p>
<p>　　⑼ExtractRelativePath()<br>　　原型：extern PACKAGE AnsiString __fastcall ExtractRelativePath(const AnsiString BaseName, const AnsiString DestName);</p>
<p>　　功能：从文件名中抽取相对路径信息，如”../sss/ss.asd”这种形式</p>
<p>　　参数：BaseName：基准文件名；DestName：目标文件名</p>
<p>　　例：ShowMessage(ExtractRelativePath(“D://Source//c//1.123”,”D://Source//Asm//dz.asm”));/<em>显示”../asm/dz.asm”</em>/</p>
<p>　　(10) ExtractShortPathName()<br>　　原型：extern PACKAGE AnsiString __fastcall ExtractShortPathName(const AnsiString FileName);</p>
<p>　　功能：把文件名转换为DOS的8、3格式</p>
<p>　　参数：FileName:要处理的文件名</p>
<p>　　例：ShowMessage(ExtractShortPathName(“E://Program Files//Dual Wheel Mouse//4dmain.exe”));/<em>显示”E:/Progra<del>1/dualwh</del>1/4dmain.exe”</em>/</p>
<p>　　⑾MatchesMask()<br>　　原型：extern PACKAGE bool __fastcall MatchesMask(const AnsiString Filename, const AnsiString Mask);</p>
<p>　　功能：检查文件是否与指定的文件名格式匹配</p>
<p>　　参数：FileName:要处理的文件名；Mask:文件名格式，支持通配符</p>
<p>　　例：ShowMessage(MatchesMask(“Lxf.exe”,”*.?x?));//显示”true”</p>
<p>2、文件管理函数<br>　　这类函数包括设置和读取驱动器、子目录和文件的有关的各种操作，下表列出这类操作常用的函数及其功能。</p>
<p>　　函数 功能<br>　　CreateDir() 创建新的子目录<br>　　DeleteFile() 删除文件<br>　　DirectoryExists() 判断目录是否存在<br>　　DiskFree() 获取磁盘剩余空间<br>　　DiskSize() 获取磁盘容量<br>　　FileExists() 判断文件是否存在<br>　　FileGetAttr() 获取文件属性<br>　　FileGetDate() 获取文件日期<br>　　GetCurrentDir() 获取当前目录<br>　　RemoveDir() 删除目录<br>　　SetCurrentDir() 设置当前目录</p>
<p>　　下面就把这些函数作一一介绍：</p>
<p>　　⑴CreateDir()<br>　　原型：extern PACKAGE bool __fastcall CreateDir(const System::AnsiString Dir);</p>
<p>　　功能：建立子目录，如果成功返回true，否则返回false</p>
<p>　　参数：Dir:要建立的子目录的名字</p>
<p>　　例：Create(“ASM”);//在当前目录下建立一个名为ASM的子目录</p>
<p>　　⑵DeleteFile()<br>　　原型：extern PACKAGE bool __fastcall DeleteFile(const System::AnsiString FileName);</p>
<p>　　功能：删除文件，如果成功返回true，否则返回false</p>
<p>　　参数：FileName:要删除的文件名</p>
<p>　　例：if(OpenDialog1-&gt;Execute())DeleteFile(OpenDialog1-&gt;FileName);</p>
<p>　　⑶DirectoryExists()<br>　　原型：extern PACKAGE bool __fastcall DirectoryExists(const System:: AnsiString Name);</p>
<p>　　功能：检测目录是否存在，如果存在返回true，否则返回false</p>
<p>　　参数：Name:要检测的目录名</p>
<p>　　例：if(!DirectoryExists(“ASM”))CreateDir(“ASM”);//如果ASM这个目录不存在则创建之</p>
<p>　　⑷DiskFree()<br>　　原型：extern PACKAGE __int64 __fastcall DiskFree(Byte Drive);</p>
<p>　　功能：检测磁盘剩余空间，返回值以字节为单位，如果指定的磁盘无效，返回-1</p>
<p>　　参数：Drive：磁盘的代号，0表示当前盘, 1=A,2=B,3=C 以此类推</p>
<p>　　例：ShowMessage(DiskFree(0));//显示当前盘的剩余空间</p>
<p>　　⑸DiskSize()<br>　　原型：extern PACKAGE __int64 __fastcall DiskSize(Byte Drive);</p>
<p>　　功能：检测磁盘容量，返回值以字节为单位，如果指定的磁盘无效，返回-1</p>
<p>　　参数：Drive：磁盘的代号，0表示当前盘, 1=A,2=B,3=C 以此类推</p>
<p>　　例：ShowMessage(DiskFree(0));//显示当前盘的容量</p>
<p>　　⑹FileExists()<br>　　原型：extern PACKAGE bool __fastcall FileExists(const AnsiString FileName);</p>
<p>　　功能：检测文件是否存在，如果存在返回true，否则返回false</p>
<p>　　参数：FileName:要检测的文件名</p>
<p>　　例：if(FileExists(“AAA.ASM”))DeleteFile(“AAA.ASM”);</p>
<p>　　⑺FileGetAttr()<br>　　原型：extern PACKAGE int __fastcall FileGetAttr(const AnsiString FileName);</p>
<p>　　功能：取得文件属性，如果出错返回-1</p>
<p>　　返回值如下表，如果返回$00000006表示是一个具有隐含和系统属性的文件(4+2)</p>
<p>　　常量 值 含义<br>　　faReadOnly $00000001 只读文件<br>　　faHidden $00000002 隐含文件<br>　　faSysFile $00000004 系统文件<br>　　faVolumeID $00000008 卷标<br>　　faDirectory $00000010 目录<br>　　faArchive $00000020 归档文件</p>
<p>　　例：if(FileGetAttr(“LLL.TXT”)&amp;0x2)ShowMessage(“这是一个有隐含属性的文件”);</p>
<p>　　与此对应的有FileSetAttr() ，请自已查阅帮助系统</p>
<p>　　⑻FileGetDate()<br>　　原型：extern PACKAGE int __fastcall FileGetDate(int Handle);</p>
<p>　　功能：返回文件的建立时间到1970-1-1日0时的秒数</p>
<p>　　参数：Handle:用FileOpen()打开的文件句柄。</p>
<p>　　例：</p>
<p>　　int i=FileOpen(“C://autoexec.bat”,fmOpenRead);<br>　　ShowMessage(FileGetDate(i));<br>　　FileClose(i);</p>
<p>　　与此对应的有FileSetDate()，请自已查阅帮助系统</p>
<p>　　⑼GetCurrentDir()<br>　　原型：extern PACKAGE AnsiString __fastcall GetCurrentDir();</p>
<p>　　功能：取得当前的目录名</p>
<p>　　例：ShowMessage(GetCurrentDir());</p>
<p>　　⑽RemoveDir()<br>　　原型：extern PACKAGE bool __fastcall RemoveDir(const AnsiString Dir);</p>
<p>　　功能：删除目录，如果成功返回true，否则返回false</p>
<p>　　参数：Dir:要删除的目录名</p>
<p>　　例：if(DiectoryExists(“ASM”))RemoveDir(“ASM”);</p>
<p>　　⑾SetCurrentDir()<br>　　原型：extern PACKAGE bool __fastcall SetCurrentDir(const AnsiString Dir);</p>
<p>　　功能：设置当前目录，如果成功返回true，否则返回false</p>
<p>　　参数：Dir:要切换到的目录名</p>
<p>　　例：SetCurrentDir(“C://WINDOWS”);</p>
<p>3、文件I/O函数<br>　　这类函数完成对文件的读写相关的操作，这种类型的操作和C的基于I/O文件操作类似，下表列出这类操作常用的函数及其功能。</p>
<p>　　FileOpen() 打开文件<br>　　FileClose() 关闭文件<br>　　FileRead() 读文件<br>　　FileSeek() 文件定位<br>　　FileWrite() 写文件<br>　　FileCreate() 创建文件</p>
<p>　　下面就对这些函数作详细介绍。</p>
<p>　　⑴FileOpen()<br>　　原型：extern PACKAGE int __fastcall FileOpen(const AnsiString FileName, int Mode);</p>
<p>　　功能：打开文件，如果成功返回其句柄，否则返回-1</p>
<p>　　参数：FileName:要打开的文件名；Mode：打开的方式，取值如下表，可用”或”(“|”)运算符连接。</p>
<p>　　常量 值 说明<br>　　————————————————————-<br>　　fmOpenRead 0 以只读属性打开<br>　　fmOpenWrite 1 以只写属性打开<br>　　fmOpenReadWrite 2 以读/写属性打开<br>　　fmShareCompat 0 兼容FCB方式(汇编中有相应的DOS功能调用，感兴趣自已查阅相关资料)<br>　　fmShareExclusive 16 共享方式：以独占方式打开，在关闭以前，别人不能访问<br>　　fmShareDenyWrite 32 共享方式：拒绝写访问<br>　　fmShareDenyRead 48 共享方式：拒绝读访问<br>　　fmShareDenyNone 64 共享方式：无限制，允许读写<br>　　例：int i=FileOpen(“C://WINDOWS//Win.ini”,fmOpenReadWrite|fmShareExclusive);</p>
<p>　　⑵FileClose()<br>　　原型：extern PACKAGE void __fastcall FileClose(int Handle);</p>
<p>　　功能：关闭打开的句柄。</p>
<p>　　参数：Handle:要关闭的句柄</p>
<p>　　例：FileClose(i);</p>
<p>　　⑶FileRead()<br>　　原型：extern PACKAGE int __fastcall FileRead(int Handle, void *Buffer, int Count);</p>
<p>　　功能：读文件，返回实际读取的字节数，句柄必须首先由FileOpen或FileCreate创建。</p>
<p>　　参数：Handle:要读取的句柄；Buffer:存放读取的数据的缓冲区；Count:想读取的字节数</p>
<p>　　例：char str[400];FileRead(hnd1,str,400);</p>
<p>　　⑷FileSeek()<br>　　原型：extern PACKAGE int __fastcall FileSeek(int Handle, int Offset, int Origin);</p>
<p>　　功能：移动文件读取指针，成功返回文件指针的位置，失败返回-1</p>
<p>　　参数：Handle:相关联的句柄；Offset:移动的量；Orgin:移动的基准，0=文件头，1=当前位置，2=文件尾。</p>
<p>　　例：ShowMessage(FileSeek(hnd1,0,2));//取得文件的长度</p>
<p>　　⑸FileWrite()<br>　　原型：extern PACKAGE int __fastcall FileWrite(int Handle, const void *Buffer, int Count);</p>
<p>　　功能：写文件，返回实际写入的字节数，句柄必须首先由FileOpen或FileCreate创建。</p>
<p>　　参数：Handle:要写入的句柄；Buffer:存放写入数据的缓冲区；Count:想写入的字节数</p>
<p>　　例：char str[]=”I Love You”;FileWrite(hnd1,str,strlen(str));</p>
<p>　　⑹FileCreate()<br>　　原型：extern PACKAGE int __fastcall FileCreate(const AnsiString FileName);</p>
<p>　　功能：创建文件。成功返回其句柄，否则返回-1</p>
<p>　　参数：FileName:要创建的文件名</p>
<p>　　例：if(!FileExists(“KC.C”))hnd1=FileCreate(“KC.C”);</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/24/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/24/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">游戏框架搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-24 23:04:50 / 修改时间：23:23:18" itemprop="dateCreated datePublished" datetime="2020-12-24T23:04:50+08:00">2020-12-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="游戏框架搭建"><a href="#游戏框架搭建" class="headerlink" title="游戏框架搭建"></a>游戏框架搭建</h1><p><strong>目标</strong> —— 使用 <strong>面相对象</strong> 设计 <strong>飞机大战游戏类</strong></p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>明确主程序职责</li>
<li>实现主程序类</li>
<li>准备游戏精灵组</li>
</ul>
<h2 id="01-明确主程序职责"><a href="#01-明确主程序职责" class="headerlink" title="01. 明确主程序职责"></a>01. 明确主程序职责</h2><ul>
<li>回顾 <strong>快速入门案例</strong>，一个游戏主程序的 <strong>职责</strong> 可以分为两个部分：<ul>
<li>游戏初始化</li>
<li>游戏循环</li>
</ul>
</li>
<li>根据明确的职责，设计 <code>PlaneGame</code> 类如下：</li>
</ul>
<p><img src="/2020/12/24/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/009_%E6%B8%B8%E6%88%8F%E4%B8%BB%E7%A8%8B%E5%BA%8F.png" alt></p>
<blockquote>
<p><strong>提示</strong> 根据 <strong>职责</strong> 封装私有方法，可以避免某一个方法的代码写得太过冗长</p>
<p>如果某一个方法编写的太长，既不好阅读，也不好维护！</p>
</blockquote>
<ul>
<li><strong>游戏初始化</strong> ——  <code>__init__()</code> 会调用以下方法： </li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td><code>__create_sprites(self)</code></td>
<td>创建所有精灵和精灵组</td>
</tr>
</tbody></table>
<ul>
<li><strong>游戏循环</strong> —— <code>start_game()</code> 会调用以下方法：</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td><code>__event_handler(self)</code></td>
<td>事件监听</td>
</tr>
<tr>
<td><code>__check_collide(self)</code></td>
<td>碰撞检测 —— 子弹销毁敌机、敌机撞毁英雄</td>
</tr>
<tr>
<td><code>__update_sprites(self)</code></td>
<td>精灵组更新和绘制</td>
</tr>
<tr>
<td><code>__game_over()</code></td>
<td>游戏结束</td>
</tr>
</tbody></table>
<h2 id="02-实现飞机大战主游戏类"><a href="#02-实现飞机大战主游戏类" class="headerlink" title="02. 实现飞机大战主游戏类"></a>02. 实现飞机大战主游戏类</h2><h3 id="2-1-明确文件职责"><a href="#2-1-明确文件职责" class="headerlink" title="2.1 明确文件职责"></a>2.1 明确文件职责</h3><p><img src="/2020/12/24/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/011_%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6%E8%81%8C%E8%B4%A3.png" alt></p>
<ul>
<li><code>plane_main</code> <ol>
<li>封装 <strong>主游戏类</strong></li>
<li>创建 <strong>游戏对象</strong></li>
<li><strong>启动游戏</strong></li>
</ol>
</li>
<li><code>plane_sprites</code><ul>
<li>封装游戏中 <strong>所有</strong> 需要使用的 <strong>精灵子类</strong></li>
<li>提供游戏的 <strong>相关工具</strong></li>
</ul>
</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul>
<li>新建 <code>plane_main.py</code> 文件，并且设置为可执行</li>
<li>编写 <strong>基础代码</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="keyword">from</span> plane_sprites <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlaneGame</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""飞机大战主游戏"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"游戏初始化"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_game</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"开始游戏..."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建游戏对象</span></span><br><span class="line">    game = PlaneGame()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始游戏</span></span><br><span class="line">    game.start_game()</span><br></pre></td></tr></table></figure>

<h3 id="2-3-游戏初始化部分"><a href="#2-3-游戏初始化部分" class="headerlink" title="2.3 游戏初始化部分"></a>2.3 游戏初始化部分</h3><ul>
<li>完成 <code>__init__()</code> 代码如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"游戏初始化"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 1. 创建游戏的窗口</span></span><br><span class="line">    self.screen = pygame.display.set_mode((<span class="number">480</span>, <span class="number">700</span>))</span><br><span class="line">    <span class="comment"># 2. 创建游戏的时钟</span></span><br><span class="line">    self.clock = pygame.time.Clock()</span><br><span class="line">    <span class="comment"># 3. 调用私有方法，精灵和精灵组的创建</span></span><br><span class="line">    self.__create_sprites()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__create_sprites</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h4 id="使用-常量-代替固定的数值"><a href="#使用-常量-代替固定的数值" class="headerlink" title="使用 常量 代替固定的数值"></a>使用 常量 代替固定的数值</h4><blockquote>
<ul>
<li>常量 —— 不变化的量</li>
<li>变量 —— 可以变化的量</li>
</ul>
</blockquote>
<p><strong>应用场景</strong></p>
<ul>
<li>在开发时，可能会需要使用 <strong>固定的数值</strong>，例如 <strong>屏幕的高度</strong> 是 <code>700</code></li>
<li>这个时候，建议 <strong>不要</strong> 直接使用固定数值，而应该使用 <strong>常量</strong></li>
<li>在开发时，为了保证代码的可维护性，尽量不要使用 <strong>魔法数字</strong> </li>
</ul>
<p><strong>常量的定义</strong></p>
<ul>
<li>定义 <strong>常量</strong> 和 定义 <strong>变量</strong> 的语法完全一样，都是使用 <strong>赋值语句</strong></li>
<li><strong>常量</strong> 的 <strong>命名</strong> 应该 <strong>所有字母都使用大写</strong>，<strong>单词与单词之间使用下划线连接</strong></li>
</ul>
<p><strong>常量的好处</strong></p>
<ul>
<li>阅读代码时，通过 <strong>常量名</strong> <strong>见名之意</strong>，不需要猜测数字的含义</li>
<li>如果需要 <strong>调整值</strong>，只需要 <strong>修改常量定义</strong> 就可以实现 <strong>统一修改</strong></li>
</ul>
<blockquote>
<p>提示：Python 中并没有真正意义的常量，只是通过命名的约定 —— 所有字母都是大写的就是常量，开发时不要轻易的修改！</p>
</blockquote>
<p><strong>代码调整</strong></p>
<ul>
<li>在 <code>plane_sprites.py</code> 中增加常量定义</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"></span><br><span class="line"><span class="comment"># 游戏屏幕大小</span></span><br><span class="line">SCREEN_RECT = pygame.Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">480</span>, <span class="number">700</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>plane_main.py</code> 中的窗口大小</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.screen = pygame.display.set_mode(SCREEN_RECT.size)</span><br></pre></td></tr></table></figure>

<h3 id="2-4-游戏循环部分"><a href="#2-4-游戏循环部分" class="headerlink" title="2.4 游戏循环部分"></a>2.4 游戏循环部分</h3><ul>
<li>完成 <code>start_game()</code> 基础代码如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_game</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""开始游戏"""</span></span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"开始游戏..."</span>)</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 1. 设置刷新帧率</span></span><br><span class="line">        self.clock.tick(<span class="number">60</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 事件监听</span></span><br><span class="line">        self.__event_handler()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 3. 碰撞检测</span></span><br><span class="line">        self.__check_collide()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 4. 更新精灵组</span></span><br><span class="line">        self.__update_sprites()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 5. 更新屏幕显示</span></span><br><span class="line">        pygame.display.update()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__event_handler</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""事件监听"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> event.type == pygame.QUIT:</span><br><span class="line">            PlaneGame.__game_over()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__check_collide</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""碰撞检测"""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__update_sprites</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""更新精灵组"""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__game_over</span><span class="params">()</span>:</span></span><br><span class="line">   <span class="string">"""游戏结束"""</span></span><br><span class="line"></span><br><span class="line">   print(<span class="string">"游戏结束"</span>)</span><br><span class="line">   pygame.quit()</span><br><span class="line">   exit()</span><br></pre></td></tr></table></figure>

<h2 id="03-准备游戏精灵组"><a href="#03-准备游戏精灵组" class="headerlink" title="03. 准备游戏精灵组"></a>03. 准备游戏精灵组</h2><h3 id="3-1-确定精灵组"><a href="#3-1-确定精灵组" class="headerlink" title="3.1 确定精灵组"></a>3.1 确定精灵组</h3><p><img src="/2020/12/24/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/010_%E7%B2%BE%E7%81%B5%E7%BB%84%E7%A1%AE%E5%AE%9A.png" alt></p>
<h3 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h3><ul>
<li>创建精灵组方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__create_sprites</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""创建精灵组"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 背景组</span></span><br><span class="line">    self.back_group = pygame.sprite.Group()</span><br><span class="line">    <span class="comment"># 敌机组</span></span><br><span class="line">    self.enemy_group = pygame.sprite.Group()</span><br><span class="line">    <span class="comment"># 英雄组</span></span><br><span class="line">    self.hero_group = pygame.sprite.Group()</span><br></pre></td></tr></table></figure>

<ul>
<li>更新精灵组方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__update_sprites</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""更新精灵组"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> group <span class="keyword">in</span> [self.back_group, self.enemy_group, self.hero_group]:</span><br><span class="line">    </span><br><span class="line">        group.update()</span><br><span class="line">        group.draw(self.screen)</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/26/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><span class="page-number current">27</span><a class="page-number" href="/page/28/">28</a><span class="space">&hellip;</span><a class="page-number" href="/page/48/">48</a><a class="extend next" rel="next" href="/page/28/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">匡俊桦</p>
  <div class="site-description" itemprop="description">回忆的沙漏将曾经屈指可数的日子渐渐淡去</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">238</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">匡俊桦</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">29:11</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
