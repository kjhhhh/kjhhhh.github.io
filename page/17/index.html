<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:type" content="website">
<meta property="og:title" content="KJHの博客">
<meta property="og:url" content="http://yoursite.com/page/17/index.html">
<meta property="og:site_name" content="KJHの博客">
<meta property="og:description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="匡俊桦">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/17/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>KJHの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KJHの博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录&回忆</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day33%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day33%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记33</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:14" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:14+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:14:44" itemprop="dateModified" datetime="2020-12-23T23:14:44+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、类加载器<br>2、反射构造方法<br>3、反射成员变量<br>4、反射成员方法<br>5、反射配置文件运行类中的方法</p>
<p>第一节课 类加载器<br>###01类的加载.avi(11:08)<br>###02类的加载时机.avi(06:19)<br>###03三种类的加载器.avi(05:14)</p>
<p>第二节课 反射<br>###01反射的概念以及作用.avi(09:23)<br>###02class文件的产生过程.avi(05:27)</p>
<p>###03获取class文件对象三种方式.avi(11:57)<br>###04反射获取空参数构造方法并运行.avi(15:55)<br>###05反射获取有参数的构造方法并运行.avi(06:27)<br>###06反射获取构造方法并运行的快速的方式.avi(06:14)</p>
<p>###07反射获取私有构造方法并运行.avi(09:41)<br>###08反射获取成员变量并改值.avi(09:22)<br>###09反射获取空参数成员方法并运行.avi(11:23)<br>###10反射获取有参数的成员方法并运行.avi(03:43)</p>
<p>###11反射泛型擦除.avi(10:29)<br>###12反射通过配置文件运行的步骤.avi(07:05)<br>###13反射通过配置文件运行功能实现.avi(09:12)</p>
<p>============上面的内容,方便我们只做ppt,word教案以及书写下面的简要的笔记=================</p>
<p>###01类加载器<br>    * A.类的加载<br>        当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。<br>        * a 加载<br>            * 就是指将class文件读入内存，并为之创建一个Class对象。<br>            * 任何类被使用时系统都会建立一个Class对象<br>        * b 连接<br>            * 验证 是否有正确的内部结构，并和其他类协调一致<br>            * 准备 负责为类的静态成员分配内存，并设置默认初始化值<br>            * 解析 将类的二进制数据中的符号引用替换为直接引用<br>        * c 初始化<br>            * 就是我们以前讲过的初始化步骤（new 对象）<br>        * 注：简单的说就是：把.class文件加载到内存里，并把这个.class文件封装成一个Class类型的对象。<br>    * B.类的加载时机<br>        以下的情况，会加载这个类。<br>        * a. 创建类的实例<br>        * b. 类的静态变量，或者为静态变量赋值<br>        * c. 类的静态方法<br>        * d. 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象<br>        * e. 初始化某个类的子类<br>        * f. 直接使用java.exe命令来运行某个主类</p>
<pre><code>* C: 类加载器(了解)
    负责将.class文件加载到内在中，并为之生成对应的Class对象。
    * a. Bootstrap ClassLoader 根类加载器
        * 也被称为引导类加载器，负责Java核心类的加载
        * 比如System,String等。在JDK中JRE的lib目录下rt.jar文件中</code></pre><p>        * b. Extension ClassLoader 扩展类加载器<br>            * 负责JRE的扩展目录中jar包的加载。<br>            * 在JDK中JRE的lib目录下ext目录<br>        * c. System ClassLoader 系统类加载器<br>            * 负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径。<br>            * 我们用的是System ClassLoader 系统类加载器</p>
<p>###02反射<br>    * A. 反射定义<br>        * a. JAVA反射机制是在运行状态中，<br>                对于任意一个类，都能够知道这个类的所有属性和方法；<br>                对于任意一个对象，都能够调用它的任意一个方法和属性；<br>            这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<pre><code>    * b.反射技术
        条件：运行状态
        已知：一个类或一个对象(根本是已知.class文件)
        结果：得到这个类或对象的所有方法和属性

    * 注: 要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象。
* B. Class类
    * a. Class类及Class对象的了解
        要想解剖一个类，必须先了解Class对象。
        阅读API的Class类得知，Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的。
    * b. 得到Class对象
        * 1. 有三个方法
            方式一: 通过Object类中的getClass()方法
                Person person = new Person();
                Class clazz = person.getClass();
            方式二: 通过 类名.class 获取到字节码文件对象（任意数据类型都具备一个class静态属性,看上去要比第一种方式简单）。
                Class clazz = Person.class;
            方式三: 通过Class类中的方法（将类名作为字符串传递给Class类中的静态方法forName即可）。
                Class c3 = Class.forName(&quot;Person&quot;);
            注：第三种和前两种的区别是：
                    前两种你必须明确Person类型.
                    后面是指定这种类型的字符串就行.这种扩展更强.我不需要知道你的类.我只提供字符串,按照配置文件加载就可以了

        * 2. 得到Class对象的三个方法代码演示：
            代码演示
            /*
             * 获取.class字节码文件对象的方式
             *         1：通过Object类中的getObject()方法
             *         2: 通过 类名.class 获取到字节码文件对象
             *         3: 反射中的方法,
             *             public static Class&lt;?&gt; forName(String className) throws ClassNotFoundException
             *             返回与带有给定字符串名的类或接口相关联的 Class 对象 
             */
            public class ReflectDemo {
                public static void main(String[] args) throws ClassNotFoundException {
                    // 1： 通过Object类中的getObject()方法
                    // Person p1 = new Person();
                    // Class c1 = p1.getClass();
                    // System.out.println(&quot;c1 = &quot;+ c1);

                    // 2: 通过 类名.class 获取到字节码文件对象
                    // Class c2 = Person.class;
                    // System.out.println(&quot;c2 = &quot;+ c2);

                    // 3: 反射中的方法
                    Class c3 = Class.forName(&quot;cn.itcast_01_Reflect.Person&quot;);// 包名.类名
                    System.out.println(&quot;c3 = &quot; + c3);
                }
            }</code></pre><p>                Person类<br>                package cn.itcast_01_Reflect;<br>                public class Person {<br>                    //成员变量<br>                    public String name;<br>                    public int age;<br>                    private String address;</p>
<pre><code>                //构造方法
                public Person() {
                    System.out.println(&quot;空参数构造方法&quot;);
                }

                public Person(String name) {
                    this.name = name;
                    System.out.println(&quot;带有String的构造方法&quot;);
                }
                //私有的构造方法
                private Person(String name, int age){
                    this.name = name;
                    this.age = age;
                    System.out.println(&quot;带有String，int的构造方法&quot;);
                }

                public Person(String name, int age, String address){
                    this.name = name;
                    this.age = age;
                    this.address = address;
                    System.out.println(&quot;带有String, int, String的构造方法&quot;);
                }

                //成员方法
                //没有返回值没有参数的方法
                public void method1(){
                    System.out.println(&quot;没有返回值没有参数的方法&quot;);
                }
                //没有返回值，有参数的方法
                public void method2(String name){
                    System.out.println(&quot;没有返回值，有参数的方法 name= &quot;+ name);
                }
                //有返回值，没有参数
                public int method3(){
                    System.out.println(&quot;有返回值，没有参数的方法&quot;);
                    return 123;
                }
                //有返回值，有参数的方法
                public String method4(String name){
                    System.out.println(&quot;有返回值，有参数的方法&quot;);
                    return &quot;哈哈&quot; + name;
                }
                //私有方法
                private void method5(){
                    System.out.println(&quot;私有方法&quot;);
                }

                @Override
                public String toString() {
                    return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;, address=&quot; + address+ &quot;]&quot;;
                }
            }
        * 注: Class类型的唯一性
            因为一个.class文件在内存里只生成一个Class对象，所以无论那一种方法得到Class对象，得到的都是同一个对象。
* C.通过反射获取无参构造方法并使用
    * a. 得到无参构造方法
        public Constructor&lt;?&gt;[] getConstructors() 
            获取所有的public 修饰的构造方法。
            选择无参构造方法，不建议使用。
        public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) 
            获取public修饰, 指定参数类型所对应的构造方法。
            不传参数得到无参构造方法。
    * b. 运行无参构造方法
        public T newInstance(Object... initargs) 
            使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。 
            因为是无参构造，所以不传参数。
    * c. 通过反射获取无参构造方法并使用的代码演示：
            package cn.itcast.demo1;

            import java.lang.reflect.Constructor;

            /*
             *  通过反射获取class文件中的构造方法,运行构造方法
             *  运行构造方法,创建对象
             *    获取class文件对象
             *    从class文件对象中,获取需要的成员
             *    
             *  Constructor 描述构造方法对象类
             */
            public class ReflectDemo1 {
                public static void main(String[] args) throws Exception {

                    Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);
                    //使用class文件对象,获取类中的构造方法
                    //  Constructor[]  getConstructors() 获取class文件对象中的所有公共的构造方法
                    /*Constructor[] cons = c.getConstructors();
                    for(Constructor con : cons){
                        System.out.println(con);
                    }*/
                    //获取指定的构造方法,空参数的构造方法
                    Constructor con =  c.getConstructor();
                    //运行空参数构造方法,Constructor类方法 newInstance()运行获取到的构造方法
                    Object obj = con.newInstance();
                    System.out.println(obj.toString());
                }
            }
* D. 通过反射获取有参构造方法并使用
    * a. 得到有参的构造方法
        public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) 
            获取public修饰, 指定参数类型所对应的构造方法。
            传相应的参数类型得到有参构造方法。
    * b. 运行无参构造方法
        public T newInstance(Object... initargs) 
            使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。 
            因为是有参构造，所以传相应的参数值。
    * c. 通过反射获取有参构造方法并使用的代码演示：
        package cn.itcast.demo1;

        import java.lang.reflect.Constructor;

        /*
         *  通过反射,获取有参数的构造方法并运行
         *  方法getConstructor,传递可以构造方法相对应的参数列表即可
         */
        public class ReflectDemo2 {
            public static void main(String[] args)throws Exception {
                Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);
                //获取带有,String和int参数的构造方法
                //Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)  
                //Class&lt;?&gt;... parameterTypes 传递要获取的构造方法的参数列表
                Constructor con = c.getConstructor(String.class,int.class);
                //运行构造方法
                // T newInstance(Object... initargs)  
                //Object... initargs 运行构造方法后,传递的实际参数
                Object obj = con.newInstance(&quot;张三&quot;,20);
                System.out.println(obj);
            }
        }
* E. 通过反射获取有参构造方法并使用快捷方式
    * a. 使用的前提
        类有空参的公共构造方法。（如果是同包，默认权限也可以）
    * b. 使用的基础
        Class类的 public T newInstance() 方法
             创建此 Class 对象所表示的类的一个新实例。
    * c. 通过反射获取有参构造方法并使用快捷方式的代码演示：
        package cn.itcast.demo1;
        /*
         * 反射获取构造方法并运行,有快捷点的方式
         * 有前提:
         *   被反射的类,必须具有空参数构造方法
         *   构造方法权限必须public
         */
        public class ReflectDemo3 {
            public static void main(String[] args) throws Exception {
                Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);
                // Class类中定义方法, T newInstance() 直接创建被反射类的对象实例
                Object obj = c.newInstance();
                System.out.println(obj);
            }
        }
* F. 通过反射获取私有构造方法并使用
    * a. 得到私有的构造方法
        public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) 
            获取指定参数类型所对应的构造方法(包含私有的)。
        public Constructor&lt;?&gt;[] getDeclaredConstructors() 
            获取所有的构造方法(包含私有的)。
    * b. 运行私有构造方法
        public void setAccessible(boolean flag)
            将此对象的 accessible 标志设置为指示的布尔值。
            设置为true,这个方法保证我们得到的私有构造方法的运行。（取消运行时期的权限检查。）
        public T newInstance(Object... initargs) 
            使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。 
    * c. 通过反射获取私有构造方法并使用的代码演示：
        package cn.itcast.demo1;

        import java.lang.reflect.Constructor;

        /*
         *  反射获取私有的构造方法运行
         *  不推荐,破坏了程序的封装性,安全性
         *  暴力反射
         */
        public class ReflectDemo4 {
            public static void main(String[] args) throws Exception{
                Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);
                //Constructor[] getDeclaredConstructors()获取所有的构造方法,包括私有的
                /*Constructor[] cons = c.getDeclaredConstructors();
                for(Constructor con : cons){
                    System.out.println(con);
                }*/
                //Constructor getDeclaredConstructor(Class...c)获取到指定参数列表的构造方法
                Constructor con = c.getDeclaredConstructor(int.class,String.class);

                //Constructor类,父类AccessibleObject,定义方法setAccessible(boolean b)
                con.setAccessible(true);

                Object obj = con.newInstance(18,&quot;lisi&quot;);
                System.out.println(obj);
            }
        }
    * 注：不推荐，破坏了程序的封装性,安全性。
* G. 反射获取成员变量并改值
    * a. 获取成员变量
        * 得到公共的成员变量
            public Field getField(String name) 
                返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定公共成员字段。 
            public Field[] getFields() 
                返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问公共字段。 
        * 得到所有的成员变量(包括私有的，如果要进行修改私有成员变量，要先进行public void setAccessible(boolean flag) 设置。)
            public Field getDeclaredField(String name) 
                返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段。 
            public Field[] getDeclaredFields() 
                返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段。 
    * b. 修改成员变量(Field)的值
        * 修改公共的成员变量
            public void set(Object obj, Object value) 
                将指定对象变量上此 Field 对象表示的字段设置为指定的新值。 
                obj指的是修改的是那个对象的这个成员变量值。
    * c. 反射获取成员变量并改值的代码演示
        package cn.itcast.demo1;
        import java.lang.reflect.Field;
        /*
         *  反射获取成员变量,并修改值
         *  Person类中的成员String name
         */
        public class ReflectDemo5 {
            public static void main(String[] args) throws Exception{
                Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);
                Object obj = c.newInstance();
                //获取成员变量 Class类的方法 getFields() class文件中的所有公共的成员变量
                //返回值是Field[]    Field类描述成员变量对象的类
                /*Field[] fields = c.getFields();
                for(Field f : fields){
                    System.out.println(f);
                }*/

                //获取指定的成员变量 String name
                //Class类的方法  Field getField(传递字符串类型的变量名) 获取指定的成员变量
                Field field = c.getField(&quot;name&quot;);

                //Field类的方法 void set(Object obj, Object value) ,修改成员变量的值
                //Object obj 必须有对象的支持,  Object value 修改后的值
                field.set(obj,&quot;王五&quot;);
                System.out.println(obj);

            }
        }
* H. 反射获取空参数成员方法并运行
    * a. 获取空参数成员方法
        * 得到公共的成员方法
            public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 
                返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。 
            public Method[] getMethods()
                返回一个包含某些 Method 对象的数组，这些对象反映此 Class对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。
        * 得到全部的成员方法(包括私有的，如果要使用私有成员方法，要先进行public void setAccessible(boolean flag) 设置。)
            public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) 
                返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。 
            public Method[] getDeclaredMethods() 
                返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 
    * b. 使用Method方法对象
        public Object invoke(Object obj, Object... args) 
            对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。 
            obj 指的是调这个方法的对象。
            args 指的是调用这个方法所要用到的参数列表。
            返回值Object就是方法的返回对象。如果方法没有返回值 ，返回的是null.
    * c. 反射获取空参数成员方法并运行代码演示
        package cn.itcast.demo1;

        import java.lang.reflect.Method;

        /*
         *  反射获取成员方法并运行
         *  public void eat(){}
         */
        public class ReflectDemo6 {
            public static void main(String[] args) throws Exception{
                Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);
                Object obj = c.newInstance();
                //获取class对象中的成员方法
                // Method[] getMethods()获取的是class文件中的所有公共成员方法,包括继承的
                // Method类是描述成员方法的对象
                /*Method[] methods = c.getMethods();
                for(Method m : methods){
                    System.out.println(m);
                }*/

                //获取指定的方法eat运行
                // Method getMethod(String methodName,Class...c)
                // methodName获取的方法名  c 方法的参数列表
                Method method = c.getMethod(&quot;eat&quot;);
                //使用Method类中的方法,运行获取到的方法eat
                //Object invoke(Object obj, Object...o)
                method.invoke(obj);
            }
        }

* I. 反射获取有参数成员方法并运行
    * a. 获取有参数成员方法
        * 得到公共的成员方法
            public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 
                返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。 
            public Method[] getMethods()
                返回一个包含某些 Method 对象的数组，这些对象反映此 Class对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。
        * 得到全部的成员方法(包括私有的，如果要使用私有成员方法，要先进行public void setAccessible(boolean flag) 设置。)
            public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) 
                返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。 
            public Method[] getDeclaredMethods() 
                返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 
    * b. 使用Method方法对象
        public Object invoke(Object obj, Object... args) 
            对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。 
            obj 指的是调这个方法的对象。
            args 指的是调用这个方法所要用到的参数列表。
            返回值Object就是方法的返回对象。如果方法没有返回值 ，返回的是null.
    * c. 反射获取有参数成员方法并运行代码演示
        package cn.itcast.demo1;
        import java.lang.reflect.Method;

        /*
         *  反射获取有参数的成员方法并执行
         *  public void sleep(String,int,double){}
         */
        public class ReflectDemo7 {
            public static void main(String[] args) throws Exception{
                Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);
                Object obj = c.newInstance();
                //调用Class类的方法getMethod获取指定的方法sleep
                Method method = c.getMethod(&quot;sleep&quot;, String.class,int.class,double.class);
                //调用Method类的方法invoke运行sleep方法
                method.invoke(obj, &quot;休眠&quot;,100,888.99);
            }
        }
* J. 反射泛型擦除
    * a. 使用情况
        例如：在泛型为String的集合里，添加Integer的数据
        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(100);
    * b. 能用泛型擦除的理论
        伪泛型：在编译后的.class文件里面是没有泛型的。类型为Object。
        用反射的方法绕过编译，得到Class文件对象，直接调用add方法。
    * c. 反射泛型擦除的代码演示
        package cn.itcast.demo2;
        import java.lang.reflect.Method;
        import java.util.ArrayList;

        /*
         *   定义集合类,泛型String
         *   要求向集合中添加Integer类型
         *   
         *   反射方式,获取出集合ArrayList类的class文件对象
         *   通过class文件对象,调用add方法
         *   
         *   对反射调用方法是否理解
         */
        public class ReflectTest {
            public static void main(String[] args)throws Exception {
                ArrayList&lt;String&gt; array  = new ArrayList&lt;String&gt;();
                array.add(&quot;a&quot;);
                //反射方式,获取出集合ArrayList类的class文件对象
                Class c = array.getClass();
                //获取ArrayList.class文件中的方法add
                Method method = c.getMethod(&quot;add&quot;,Object.class);
                //使用invoke运行ArrayList方法add
                method.invoke(array, 150);
                method.invoke(array, 1500);
                method.invoke(array, 15000);
                System.out.println(array);</code></pre><p>​<br>                }<br>            }<br>    * K. 反射通过配置文件来决定运行的步骤<br>        * a. 操作依据<br>                通过配置文件得到类名和要运行的方法名,用反射的操作类名得到对象和调用方法<br>        * b. 实现步骤:<br>             *    1. 准备配置文件,键值对<br>             *    2. IO流读取配置文件  Reader<br>             *    3. 文件中的键值对存储到集合中 Properties<br>             *        集合保存的键值对,就是类名和方法名<br>             *    4. 反射获取指定类的class文件对象<br>             *    5. class文件对象,获取指定的方法<br>             *    6. 运行方法<br>        * c. 代码演示<br>            代码：<br>            package cn.itcast.demo3;</p>
<pre><code>import java.io.FileReader;
import java.lang.reflect.Method;
import java.util.Properties;

/*
 *  调用Person方法,调用Student方法,调用Worker方法
 *  类不清楚,方法也不清楚
 *  通过配置文件实现此功能
 *    运行的类名和方法名字,以键值对的形式,写在文本中
 *    运行哪个类,读取配置文件即可
 *  实现步骤:
 *    1. 准备配置文件,键值对
 *    2. IO流读取配置文件  Reader
 *    3. 文件中的键值对存储到集合中 Properties
 *        集合保存的键值对,就是类名和方法名
 *    4. 反射获取指定类的class文件对象
 *    5. class文件对象,获取指定的方法
 *    6. 运行方法
 */
public class Test {
    public static void main(String[] args) throws Exception{
        //IO流读取配置文件
        FileReader r = new FileReader(&quot;config.properties&quot;);
        //创建集合对象
        Properties pro = new Properties();
        //调用集合方法load,传递流对象
        pro.load(r);
        r.close();
        //通过键获取值
        String className = pro.getProperty(&quot;className&quot;);
        String methodName = pro.getProperty(&quot;methodName&quot;);
        //反射获取指定类的class文件对象
        Class c = Class.forName(className);
        Object obj = c.newInstance();
        //获取指定的方法名
        Method method = c.getMethod(methodName);
        method.invoke(obj);
    }
}
配置文件：
#className=cn.itcast.demo3.Student
#methodName=study
className=cn.itcast.demo3.Person
methodName=eat
#className=cn.itcast.demo3.Worker
#methodName=job</code></pre><p>###3总结</p>
<ul>
<li>把今天的知识点总结一遍。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day32%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day32%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记32</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:14:35" itemprop="dateModified" datetime="2020-12-23T23:14:35+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day31%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day31%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记31</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:14:20" itemprop="dateModified" datetime="2020-12-23T23:14:20+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、管家婆项目</p>
<p>###01项目训练目标<br>    * A: 项目训练目标<br>        * a: 项目目标<br>            * 综合运用前面所学习的知识点<br>            * 熟练View层、Service层、Dao层之间的方法相互调用操作、<br>            * 熟练dbutils操作数据库表完成增删改查<br>            * 了解公司项目开发的流程，充分的掌握项目需求分析、设计与功能的代码实现。提高同学们独立分析需求与功能实现的能力。            </p>
<p>###02项目中的功能模块<br>    * A: 项目中的功能模块<br>        * a: 五大模块<br>            * 查询账务<br>            * 多条件组合查询账务<br>            * 添加账务<br>            * 编辑账务<br>            * 删除账务</p>
<p>###03技术的选择和相关jar包<br>    * A: 技术的选择和相关jar包<br>        * a: apache的commons组件：<br>            * commons-dbutils-1.4.jar：封装并简化了JDBC；<br>            * commons-dbcp-1.4.jar：apache commons提供的数据库连接池组件，命名为DBCP；<br>        * b: commons.pool-1.3.jar：DBCP连接池依赖该jar包；<br>            * mysql-connector-java-5.1.28-bin.jar：MySQL的JDBC驱动包，用JDBC连接MySQL数据库必须使用该JAR包。</p>
<p>###04项目中的工具类<br>    * A: 项目中的工具类<br>        * a: 工具类的介绍<br>            * 每个项目中都会有很多个工具类，不要求每个工具类对能独立写出来，但是要会使用工具类<br>            * JDBCUtils：用来创建数据库连接池对象</p>
<p>###05数据表的设计<br>    * A: 数据表的设计<br>        * a: 数据表的设计(详见：day34_source/表关系.JPG)<br>            * 表与表之间是有关系的<br>            * 主表和从表的关系<br>            * 主表中的主键作为从表中的外键</p>
<p>​<br>###06创建数据库数据表写入测试数据<br>    * A: 创建数据库数据表写入测试数据<br>        * a: 创建数据库数据表<br>            /*<br>              创建管家婆的数据库<br>              名字 gjp<br>            */<br>            CREATE DATABASE gjp;</p>
<pre><code>    USE gjp;

    /*
      创建数据表,表名账务
      字段,列
      主键
      分类名称  可变字符
      金额  double
      账户  可变字符 (支付,收入方法)
      创建日期 date
      账务描述 可变字符
    */

    CREATE TABLE gjp_zhangwu(
       -- 主键
       zwid INT PRIMARY KEY AUTO_INCREMENT,
       -- 分类名称   
       flname VARCHAR(200),
       -- 金额
       money DOUBLE,
       -- 账户
       zhanghu VARCHAR(100),
       -- 创建日期
       createtime DATE,
       -- 账务描述
       description  VARCHAR(1000)
    );
    SELECT * FROM gjp_zhangwu;
* b: 写入数据
    -- 写入测试的数据
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (1,&apos;吃饭支出&apos;,247,&apos;交通银行&apos;,&apos;2016-03-02&apos;,&apos;家庭聚餐&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (2,&apos;工资收入&apos;,12345,&apos;现金&apos;,&apos;2016-03-15&apos;,&apos;开工资了&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (3,&apos;服装支出&apos;,1998,&apos;现金&apos;,&apos;2016-04-02&apos;,&apos;买衣服&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (4,&apos;吃饭支出&apos;,325,&apos;现金&apos;,&apos;2016-06-18&apos;,&apos;朋友聚餐&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (5,&apos;股票收入&apos;,8000,&apos;工商银行&apos;,&apos;2016-10-28&apos;,&apos;股票大涨&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (6,&apos;股票收入&apos;,5000,&apos;工商银行&apos;,&apos;2016-10-28&apos;,&apos;股票又大涨&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (7,&apos;工资收入&apos;,5000,&apos;交通银行&apos;,&apos;2016-10-28&apos;,&apos;又开工资了&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (8,&apos;礼金支出&apos;,5000,&apos;现金&apos;,&apos;2016-10-28&apos;,&apos;朋友结婚&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (9,&apos;其他支出&apos;,1560,&apos;现金&apos;,&apos;2016-10-29&apos;,&apos;丢钱了&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (10,&apos;交通支出&apos;,2300,&apos;交通银行&apos;,&apos;2016-10-29&apos;,&apos;油价还在涨啊&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (11,&apos;吃饭支出&apos;,1000,&apos;工商银行&apos;,&apos;2016-10-29&apos;,&apos;又吃饭&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (12,&apos;工资收入&apos;,1000,&apos;现金&apos;,&apos;2016-10-30&apos;,&apos;开资&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (13,&apos;交通支出&apos;,2000,&apos;现金&apos;,&apos;2016-10-30&apos;,&apos;机票好贵&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (14,&apos;工资收入&apos;,5000,&apos;现金&apos;,&apos;2016-10-30&apos;,&apos;又开资&apos;);</code></pre><p>###07项目中的分层设计<br>    * A: 项目中的分层设计<br>        * a: 各层功能介绍<br>            * view层作用: 视图层,即项目中的界面<br>            * controller层作用: 控制层, 获取界面上的数据,为界面设置数据; 将要实现的功能交给业务层处理<br>            * service层作用: 业务层, 功能的实现, 与controller控制层和数据访问层DAO交互, 将对数据库的操作交给DAO数据访问层来处理<br>            * dao层作用: 数据访问层, 用来操作数据库表的数据<br>            * db数据库: 这里指MySQL<br>            * domain 实体包: 存放JavaBean<br>            * tools工具包:存放项目中使用到的工具类<br>            * test 测试包: 存放项目功能测试的代码</p>
<p>​<br>###08创建项目_分层_导入jar包<br>    * A: 创建项目_分层_导入jar包<br>        * a: 创建工程包<br>            * cn.itcast.gjp.app: 存放main方法类；<br>            * cn.itcast.gjp.domain: 存放JavaBean；<br>            * cn.itcast.gjp.view: 存放界面，及表现层类；<br>            * cn.itcast.gjp.service: 存放业务层类；<br>            * cn.itcast.gjp.dao: 存放数据访问层类;<br>            * cn.itcast.gjp.tools:存放工具类<br>        * b: 导入jar包<br>            * 在项目根路径下建立文件夹lib<br>            * 导入以下jar包<br>                * mysql-connector-java-5.1.37-bin.jar：数据库驱动<br>                * commons-dbutils-1.6.jar：提供QueryRunner类方便进行增删改查操作<br>                * commons-dbcp-1.4.jar：<br>                * commons-pool-1.5.6.jar：提供高效的数据库连接池技术<br>            * 拷贝以上jar包，选定拷贝的jar包/右键/Build Path/Add to Build Path</p>
<p>###09创建domain包中的类<br>    * A: 创建domain包中的类<br>        * a: 案例代码<br>            public class ZhangWu {<br>                 private int  zwid;</p>
<pre><code>     private String flname; 

     private double  money; 

     private String zhanghu;

     private String createtime; 

     private String description;
     //注意生成空参构造、有参构造、set和get方法、toString方法等
}</code></pre><p>###10创建JDBCUtils工具类<br>    * A：创建JDBCUtils工具类<br>        * a: 案例代码<br>            public class JDBCUtils{<br>                //创建BasicDataSource对象<br>                private static BasicDataSource datasource = new BasicDataSource();<br>                //静态代码块,实现必要参数设置<br>                static{<br>                    datasource.setDriverClassName(“com.mysql.jdbc.Driver”);<br>                    datasource.setUrl(“jdbc:mysql://localhost:3306/gjp”);<br>                    datasource.setUsername(“root”);<br>                    datasource.setPassword(“123”);<br>                    datasource.setMaxActive(10);<br>                    datasource.setMaxIdle(5);<br>                    datasource.setMinIdle(2);<br>                    datasource.setInitialSize(10);<br>                }<br>                public static DataSource getDataSource(){<br>                    return datasource;<br>                }<br>            }</p>
<p>​<br>###11创建其他包中的类</p>
<pre><code>* A: 创建其他包中的类
    * a: cn.itcast.gjp.dao包中创建ZhangWuDao类
        /*
         *  实现对数据表 gjp_zhangwu 数据增删改查操作
         *  dbuils工具类完成,类成员创建QueryRunner对象,指定数据源
         */
        public class ZhangWuDao {
            private QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource());
        }
    * b: cn.itcast.gjp.service包中创建ZhangWuService类
        /*
         *  业务层类
         *  接收上一层,控制层controller的数据
         *  经过计算,传递给dao层,操作数据库
         *  调用dao层中的类,类成员位置,创建Dao类的对象
         */
        public class ZhangWuService {
            private ZhangWuDao dao = new ZhangWuDao();

        }
    * c: cn.itcast.gjp.controller包中建立ZhangWuController类
        /*
         *  控制器层
         *  接收视图层的数据,数据传递给service层
         *  成员位置,创建service对象
         */
        public class ZhangWuController {
            private ZhangWuService service = new ZhangWuService();                
        }
    * d: cn.itcast.gjp.view包中建立MainView类
        /*
         *  试图层,用户看到和操作的界面
         *  数据传递给controller层实现
         *  成员位置,创建controller对象
         */
        public class MainView {
            private ZhangWuController controller = new ZhangWuController();

        }
    * e: cn.itcast.gjp.app包中建立MainApp类
        /*
         *  主程序类,作用,开启软件程序
         */
        public class MainApp {
            public static void main(String[] args) {
                new MainView().run();
            }
        }</code></pre><p>###12实现用户的界面菜单<br>    * A: 实现用户的界面菜单<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.view包中建立MainView类中添加run方法<br>            /*<br>             *  实现界面效果<br>             *  接收用户的输入<br>             *  根据数据,调用不同的功能方法<br>             */<br>            public void run(){<br>                //创建Scanner类对象,反复键盘输入<br>                Scanner sc = new Scanner(System.in);<br>                while(true){<br>                    System.out.println(“—————管家婆家庭记账软件—————“);<br>                    System.out.println(“1.添加账务　2.编辑账务　3.删除账务　4.查询账务　5.退出系统”);<br>                    System.out.println(“请输入要操作的功能序号[1-5]:”);<br>                    //接收用户的菜单选择<br>                    int choose = sc.nextInt();<br>                    //对选择的菜单判断,调用不同的功能<br>                    switch(choose){<br>                    case 1:<br>                       // 选择添加账务,调用添加账务的方法<br>                        break;<br>                    case 2:<br>                        // 选择的编辑账务,调用编辑账务方法<br>                        break;<br>                    case 3:<br>                        // 选择的删除账务,调用删除账务方法<br>                        break;<br>                    case 4:<br>                        // 选择的是查询账务,调用查询方法<br>                        //selectZhangWu();<br>                        break;<br>                    case 5:<br>                        System.exit(0);<br>                        break;<br>                    }<br>                }<br>            }</p>
<p>​            </p>
<p>###13实现查询的界面菜单<br>    * A: 实现查询的界面菜单<br>        * a: 案例核心代码<br>            *  cn.itcast.gjp.view包中建立MainView类中添加selectZhangWu方法、selectAll方法、select方法<br>                /*<br>                 * 定义方法 selectZhangWu()<br>                 * 显示查询的方式 1 所有查询   2 条件查询<br>                 * 接收用户的选择<br>                 <em>/<br>                 public void selectZhangWu(){<br>                     System.out.println(“1. 查询所有    2. 条件查询”);<br>                     Scanner sc = new Scanner(System.in);<br>                     int selectChooser = sc.nextInt();<br>                     //判断根据用户的选择,调用不同的功能<br>                     switch(selectChooser){<br>                     case 1:<br>                         //选择的查询所有,调用查询所有的方法<br>                         selectAll();<br>                         break;<br>                     case 2:<br>                         //选的条件查询,调用带有查询条件的方法<br>                         select();<br>                         break;<br>                     }<br>                 }<br>                 /</em><br>                  * 定义方法,实现查询所有的账务数据<br>                  */<br>                 public void selectAll(){</p>
<pre><code>}

/*
 * 定义方法,实现条件查询账务数据
 * 提供用户的输入日期,开始日期结束日期
 * 就2个日期,传递到controller层
 * 调用controller的方法,传递2个日期参数
 * 获取到controller查询的结果集,打印出来
 */
public void select(){

}</code></pre><p>###14实现查询所有账务的控制,业务层的实现<br>    * A: 实现查询所有账务的控制,业务层的实现<br>        * a: 案例核心代码<br>            * a: cn.itcast.gjp.dao包中创建ZhangWuDao类<br>            /*<br>             *  实现对数据表 gjp_zhangwu 数据增删改查操作<br>             *  dbuils工具类完成,类成员创建QueryRunner对象,指定数据源<br>             <em>/<br>            public class ZhangWuDao {<br>                private QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource());<br>                /</em><br>                 * 定义方法,查询数据库,获取所有的账务数据<br>                 * 方法,由业务层调用<br>                 * 结果集,将所有的账务数据,存储到Bean对象中,存储到集合中<br>                 <em>/<br>                public List<ZhangWu> selectAll(){<br>                    return null;<br>                }<br>            }<br>            * b: cn.itcast.gjp.service包中创建ZhangWuService类<br>                /</ZhangWu></em><br>                 *  业务层类<br>                 *  接收上一层,控制层controller的数据<br>                 *  经过计算,传递给dao层,操作数据库<br>                 *  调用dao层中的类,类成员位置,创建Dao类的对象<br>                 <em>/<br>                public class ZhangWuService {<br>                    private ZhangWuDao dao = new ZhangWuDao();<br>                    /</em><br>                     *  定义方法,实现查询所有的账务数据<br>                     *  此方法,由控制层调用, 去调用dao层的方法<br>                     *  返回存储ZhangWu对象的List集合<br>                     <em>/<br>                    public List<ZhangWu> selectAll(){<br>                        return dao.selectAll();<br>                    }<br>                }<br>            * c: cn.itcast.gjp.controller包中建立ZhangWuController类<br>                /</ZhangWu></em><br>                 *  控制器层<br>                 *  接收视图层的数据,数据传递给service层<br>                 *  成员位置,创建service对象<br>                 <em>/<br>                public class ZhangWuController {<br>                    private ZhangWuService service = new ZhangWuService();<br>                    /</em><br>                     * 控制层类定义方法,实现查询所有的账务数据<br>                     * 方法由试图层调用,方法调用service层<br>                     */<br>                    public List<ZhangWu> selectAll(){<br>                        return service.selectAll();<br>                    }<br>                }</ZhangWu></p>
<p>###15实现查询所有账务的dao层的实现<br>    * A: 实现查询所有账务的dao层的实现<br>        * a: 案例核心代码<br>            * a: cn.itcast.gjp.dao包中创建ZhangWuDao类selectAll方法<br>            /*<br>             *  实现对数据表 gjp_zhangwu 数据增删改查操作<br>             *  dbuils工具类完成,类成员创建QueryRunner对象,指定数据源<br>             <em>/<br>            public class ZhangWuDao {<br>                private QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource());<br>                /</em><br>                 * 定义方法,查询数据库,获取所有的账务数据<br>                 * 方法,由业务层调用<br>                 * 结果集,将所有的账务数据,存储到Bean对象中,存储到集合中<br>                 */<br>                public List<ZhangWu> selectAll(){<br>                    try{<br>                        //查询账务数据的SQL语句<br>                            String sql = “SELECT * FROM gjp_zhangwu”;<br>                            //调用qr对象的方法,query方法,结果集BeanListHandler<br>                            List<ZhangWu> list = qr.query(sql, new BeanListHandler&lt;&gt;(ZhangWu.class));<br>                            return list;<br>                        }catch(SQLException ex){<br>                            System.out.println(ex);<br>                            throw new RuntimeException(“查询所有账务失败”);<br>                        }<br>                }<br>            }</ZhangWu></ZhangWu></p>
<p>​<br>###16实现查询所有账务的view层的实现<br>    * A: 实现查询所有账务的view层的实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.view包中建立MainView类selectAll方法<br>            /*<br>              * 定义方法,实现查询所有的账务数据<br>              */<br>             public void selectAll(){<br>                 //调用控制层中的方法,查询所有的账务数据<br>                 List<ZhangWu> list = controller.selectAll();<br>                //输出表头<br>                 System.out.println(“ID\t\t类别\t\t账户\t\t金额\t\t时间\t\t说明”);<br>                 //遍历集合,结果输出控制台<br>                 for(ZhangWu zw : list){<br>                     System.out.println(zw.getZwid()+”\t\t”+zw.getFlname()+”\t\t”+zw.getZhanghu()+”\t\t”+<br>                     zw.getMoney()+”\t\t”+zw.getCreatetime()+”\t”+zw.getDescription());<br>                 }<br>             }</ZhangWu></p>
<p>###17实现条件查询账务的菜单实现<br>    * A: 实现条件查询账务的菜单实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.view包中建立MainView类select方法<br>              /*<br>              * 定义方法,实现条件查询账务数据<br>              * 提供用户的输入日期,开始日期结束日期<br>              * 就2个日期,传递到controller层<br>              * 调用controller的方法,传递2个日期参数<br>              * 获取到controller查询的结果集,打印出来<br>              */<br>             public void select(){<br>                 System.out.println(“选择条件查询,输入日期格式XXXX-XX-XX”);<br>                 Scanner sc = new Scanner(System.in);<br>                 System.out.print(“请输入开始日期:”);<br>                 String startDate = sc.nextLine();<br>                 System.out.print(“请输入结果日期:”);<br>                 String endDate = sc.nextLine();<br>                 //调用controller层的方法,传递日期,获取查询结果集</p>
<pre><code>}</code></pre><p>###18实现条件查询账务的控制层,业务层实现<br>    * A: 实现条件查询账务的控制层,业务层实现<br>        * a: 案例核心代码<br>            * a: cn.itcast.gjp.dao包中创建ZhangWuDao类<br>                /*<br>                 *  实现对数据表 gjp_zhangwu 数据增删改查操作<br>                 *  dbuils工具类完成,类成员创建QueryRunner对象,指定数据源<br>                 <em>/<br>                public class ZhangWuDao {<br>                    private QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource());<br>                    /</em><br>                     * 定义方法,查询数据库,带有条件去查询账务表<br>                     * 由业务层调用,查询结果集存储到Bean对象,存储到List集合<br>                     * 调用者传递2个日期字符串<br>                     <em>/<br>                    public List<ZhangWu> select(String startDate,String endDate){<br>                        return null;<br>                    }<br>                }<br>            * b: cn.itcast.gjp.service包中创建ZhangWuService类<br>                /</ZhangWu></em><br>                 *  业务层类<br>                 *  接收上一层,控制层controller的数据<br>                 *  经过计算,传递给dao层,操作数据库<br>                 *  调用dao层中的类,类成员位置,创建Dao类的对象<br>                 <em>/<br>                public class ZhangWuService {<br>                    private ZhangWuDao dao = new ZhangWuDao();<br>                    /</em><br>                     * 定义方法,实现条件查询账务<br>                     * 方法由控制层调用,传递2个日期字符串<br>                     * 调用dao层的方法,传递2个日期字符串<br>                     * 获取到查询结果集<br>                     <em>/<br>                    public List<ZhangWu> select(String startDate,String endDate){<br>                        return dao.select(startDate, endDate);<br>                    }<br>                }<br>            * c: cn.itcast.gjp.controller包中建立ZhangWuController类<br>                /</ZhangWu></em><br>                 *  控制器层<br>                 *  接收视图层的数据,数据传递给service层<br>                 *  成员位置,创建service对象<br>                 <em>/<br>                public class ZhangWuController {<br>                    private ZhangWuService service = new ZhangWuService();<br>                    /</em><br>                     * 定义方法,实现条件查询账务<br>                     * 方法由试图层调用,传递两个日期的字符串<br>                     * 调用service层的方法,传递两个日期字符串,获取结果集<br>                     * 结果集返回给试图<br>                     <em>/<br>                    public List<ZhangWu> select(String startDate,String endDate){<br>                        return service.select(startDate, endDate);<br>                    }<br>                }<br>###19实现条件查询账务的dao层实现<br>    * A: 实现条件查询账务的dao层实现<br>        * a: 案例核心代码<br>            * a: cn.itcast.gjp.dao包中创建ZhangWuDao类select方法<br>                /</ZhangWu></em><br>                 *  实现对数据表 gjp_zhangwu 数据增删改查操作<br>                 *  dbuils工具类完成,类成员创建QueryRunner对象,指定数据源<br>                 <em>/<br>                public class ZhangWuDao {<br>                    private QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource());<br>                    /</em><br>                     * 定义方法,查询数据库,带有条件去查询账务表<br>                     * 由业务层调用,查询结果集存储到Bean对象,存储到List集合<br>                     * 调用者传递2个日期字符串<br>                     */<br>                    public List<ZhangWu> select(String startDate,String endDate){<br>                        try{<br>                            //拼写条件查询的SQL语句<br>                            String sql = “SELECT * FROM gjp_zhangwu WHERE createtime BETWEEN ? AND ?”;<br>                            //定义对象数组,存储?占位符<br>                            Object[] params = {startDate,endDate};<br>                            //调用qr对象的方法query查询数据表,获取结果集<br>                            return qr.query(sql, new BeanListHandler&lt;&gt;(ZhangWu.class),params);<br>                        }catch(SQLException ex){<br>                            System.out.println(ex);<br>                            throw new RuntimeException(“条件查询失败”);<br>                        }<br>                    }<br>                }</ZhangWu></p>
<p>###20实现条件查询账务的view层实现<br>    * A: 实现条件查询账务的view层实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.view包中建立MainView类selectAll方法优化、抽取print方法、select方法<br>            /*<br>              * 定义方法,实现查询所有的账务数据<br>              */<br>             public void selectAll(){<br>                 //调用控制层中的方法,查询所有的账务数据<br>                 List<ZhangWu> list = controller.selectAll();<br>                 if(list.size()!=0)<br>                     print(list);<br>                 else<br>                     System.out.println(“没有查询到数据”);<br>             }</ZhangWu></p>
<pre><code>/*
 * 定义方法,实现条件查询账务数据
 * 提供用户的输入日期,开始日期结束日期
 * 就2个日期,传递到controller层
 * 调用controller的方法,传递2个日期参数
 * 获取到controller查询的结果集,打印出来
 */
public void select(){
    System.out.println(&quot;选择条件查询,输入日期格式XXXX-XX-XX&quot;);
    Scanner sc = new Scanner(System.in);
    System.out.print(&quot;请输入开始日期:&quot;);
    String startDate = sc.nextLine();
    System.out.print(&quot;请输入结果日期:&quot;);
    String endDate = sc.nextLine();
    //调用controller层的方法,传递日期,获取查询结果集
    List&lt;ZhangWu&gt; list = controller.select(startDate, endDate);
    if(list.size()!=0)
        print(list);
    else
        System.out.println(&quot;没有查询到数据&quot;);
}

//输出账务数据方法,接收List集合,遍历集合,输出表格
private void print(List&lt;ZhangWu&gt; list) {
       //输出表头
        System.out.println(&quot;ID\t\t类别\t\t账户\t\t金额\t\t时间\t\t说明&quot;);
        //遍历集合,结果输出控制台
        for(ZhangWu zw : list){
            System.out.println(zw.getZwid()+&quot;\t\t&quot;+zw.getFlname()+&quot;\t\t&quot;+zw.getZhanghu()+&quot;\t\t&quot;+
            zw.getMoney()+&quot;\t\t&quot;+zw.getCreatetime()+&quot;\t&quot;+zw.getDescription());
        }
   }</code></pre><p>###21添加账务功能分析<br>    * A: 添加账务功能分析<br>        * a: 编写MainView类中addZhangWu方法<br>            * 键盘输入新添加的账务信息<br>            * 调用ZhangWuService类中addZhangWu方法，用来指定账务的添加<br>            * 添加完毕后，使用输出语句，提示“添加账务成功！”<br>        * b: 编写ZhangWuService类中addZhangWu方法<br>            * 调用ZhangWuDao类中addZhangWu方法，用来指定账务的添加<br>        * c: 编写ZhangWuDao类中addZhangWu方法<br>            * 通过QueryRunner对象，调用update方法更新数据库表gjp_zhangwu，完成指定账务添加到数据库表中</p>
<p>​<br>###22添加账务功能菜单和输入功能实现<br>    * A: 添加账务功能菜单和输入功能实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.view包中建立MainView类addZhangWu方法<br>            /*<br>             * 定义方法addZhangWu<br>             * 添加账务的方法，用户在界面中选择菜单1的时候调用、<br>             * 实现思想：<br>             *       接收键盘输入，5项输入，调用controller层方法<br>             */<br>            public void addZhangWu() {<br>                System.out.println(“选择的添加账务功能，请输入以下内容”);<br>                Scanner sc = new Scanner(System.in);<br>                System.out.println(“输入分类名称”);<br>                String flname = sc.next();<br>                System.out.println(“输入金额”);<br>                double money = sc.nextDouble();<br>                System.out.println(“输入账户”);<br>                String zhanghu = sc.next();<br>                System.out.println(“输入日期：格式XXXX-XX-xx”);<br>                String createtime = sc.next();<br>                System.out.println(“输入具体描述”);<br>                String description = sc.next();<br>                //将接收到的数据，调用controller层的方法，传递参数，实现数据添加</p>
<pre><code>}</code></pre><p>###23添加账务功能控制层,业务层实现<br>    * A: 添加账务功能控制层,业务层实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.controller包中的ZhangWuController类addZhangWu方法<br>                /*<br>                 * 定义方法，实现账务添加功能<br>                 * 由视图层调用，传递参数(传递过来的参数不能是5个数据，传递的是一个ZhangWu类型的对象)<br>                 * 本方法调用service层的方法，传递ZhangWu对象，获取到添加后的结果集(添加成功影响的行数，int)<br>                 *<br>                 <em>/<br>                public void addZhangWu(ZhangWu zw) {<br>                    service.addZhangWu(zw);<br>                }<br>            * cn.itcast.gjp.service包中的ZhangWuService类addZhangWu方法<br>                /</em><br>                 * 定义方法，实现添加账务<br>                 * 是由控制层调用，传递ZhangWu对象<br>                 <em>/<br>                public void addZhangWu(ZhangWu zw) {<br>                    dao.addZhangWu(zw);<br>                }<br>            * cn.itcast.gjp.dao包中的ZhangWuDao类addZhangWu方法<br>                /</em><br>                 * 定义方法，实现添加账务功能<br>                 * 由业务层调用，传递ZhangWu对象<br>                 * 将ZhangWu对象中的数据，添加到数据库<br>                 */<br>                public void addZhangWu(ZhangWu zw) {</p>
<pre><code>}</code></pre><p>###24添加账务功能dao层实现<br>    * A: 添加账务功能dao层实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.dao包中的ZhangWuDao类的addZhangWu方法<br>                public void addZhangWu(ZhangWu zw) {<br>                    try{<br>                         //拼接添加数据的sql<br>                        String sql = “INSERT INTO gjp_zhangwu (flname,money,zhanghu,createtime,description) VALUES(?,?,?,?,?)”;<br>                        //创建对象数组，处处5个占位符的实际参数<br>                        //实际参数来源是传递过来的对象ZhangWu<br>                        Object[] params = {zw.getFlname(),zw.getMoney(),zw.getZhanghu(),zw.getCreatetime(),zw.getDescription()};<br>                        //调用qr对象中的方法update执行添加<br>                        qr.update(sql, params);<br>                    }catch(SQLException ex) {<br>                        System.out.println(ex);<br>                        throw new RuntimeException(“账务添加失败”);<br>                    }<br>                }</p>
<p>###25添加账务功能view层实现<br>    * A: 添加账务功能view层实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.view包中建立MainView类addZhangWu方法<br>                public void addZhangWu() {<br>                    System.out.println(“选择的添加账务功能，请输入以下内容”);<br>                    Scanner sc = new Scanner(System.in);<br>                    System.out.println(“输入分类名称”);<br>                    String flname = sc.next();<br>                    System.out.println(“输入金额”);<br>                    double money = sc.nextDouble();<br>                    System.out.println(“输入账户”);<br>                    String zhanghu = sc.next();<br>                    System.out.println(“输入日期：格式XXXX-XX-xx”);<br>                    String createtime = sc.next();<br>                    System.out.println(“输入具体描述”);<br>                    String description = sc.next();<br>                    //将接收到的数据，调用controller层的方法，传递参数，实现数据添加<br>                    //将用户输入的所有参数，封装成ZhangWu对象<br>                    ZhangWu zw = new ZhangWu(0, flname, money, zhanghu, createtime, description);<br>                    controller.addZhangWu(zw);<br>                    System.out.println(“恭喜添加账务成功”);<br>                }</p>
<p>​<br>###26编辑账务功能分析<br>    * A: 编辑账务功能分析<br>        * a: 编写MainView类中editZhangWu方法<br>            * 键盘输入要编辑的账务信息ID号<br>            * 键盘输入要修改的账务信息内容<br>            * 调用ZhangWuService类中editZhangWu方法，用来将指定的账务信息进行更新<br>            * 更新完毕后，使用输出语句，提示 “编辑账务成功！”<br>        * b: 编写ZhangWuService类中editZhangWu方法<br>            * 调用ZhangWuDao类中editZhangWu方法，用来将指定的账务信息进行更新<br>        * c: 编写ZhangWuDao类中editZhangWu方法<br>            * 通过QueryRunner对象，调用update方法更新数据库表gjp_zhangwu，完成数据库表中指定账务更新操作</p>
<p>###27编辑账务功能功能之前实现查询所有<br>    * A: 编辑账务功能功能之前实现查询所有<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.view包中建立MainView类editZhangWu方法<br>                public void editZhangWu() {<br>                    //调用查询所有账务数据的功能，显示出来<br>                    //看到所有数据，从中选择一项，进行修改<br>                    selectAll();<br>                    System.out.println(“选择的是编辑功能，请输入数据”);</p>
<p>​<br>                }</p>
<p>###28编辑账务功能菜单实现<br>    * A: 编辑账务功能菜单实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.view包中建立MainView类editZhangWu方法<br>                public void editZhangWu() {<br>                    //调用查询所有账务数据的功能，显示出来<br>                    //看到所有数据，从中选择一项，进行修改<br>                    selectAll();<br>                    System.out.println(“选择的是编辑功能，请输入数据”);<br>                    Scanner sc = new Scanner(System.in);<br>                    System.out.print(“请输入ID”);<br>                    int zwid = sc.nextInt();<br>                    System.out.println(“输入分类名称”);<br>                    String flname = sc.next();<br>                    System.out.println(“输入金额”);<br>                    double money = sc.nextDouble();<br>                    System.out.println(“输入账户”);<br>                    String zhanghu = sc.next();<br>                    System.out.println(“输入日期：格式XXXX-XX-xx”);<br>                    String createtime = sc.next();<br>                    System.out.println(“输入具体描述”);<br>                    String description = sc.next();<br>                    //将用户输入的数据，封装到ZhangWu对象中<br>                    //用户输入的ID，必须封装到到对象中<br>                    ZhangWu zw = new ZhangWu(zwid, flname, money, zhanghu, createtime, description);<br>                    //调用controller层中的方法，实现编辑账务<br>                }            </p>
<p>###29编辑账务功能控制层,业务层实现<br>    * A: 编辑账务功能控制层,业务层实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.controller包中的ZhangWuController类editZhangWu方法<br>                /*<br>                 * 定义方法，实现编辑账务功能<br>                 * 由视图层调用，传递参数，也是ZhangWu对象<br>                 * 调用service层的方法，也是ZhangWu对象<br>                 <em>/<br>                public void editZhangWu(ZhangWu zw) {<br>                    service.editZhangWu(zw);<br>                }<br>            * cn.itcast.gjp.service包中的ZhangWuService类editZhangWu方法<br>                /</em><br>                 * 定义方法，实现编辑账务<br>                 * 由控制层调用，传递ZhangWu对象<br>                 * 调用dao层的方法，传递ZhangWu对象<br>                 */<br>                public void editZhangWu(ZhangWu zw) {<br>                    dao.editZhangWu(zw);<br>                }<br>            * cn.itcast.gjp.dao包中的ZhangWuDao类editZhangWu方法<br>                public void editZhangWu(ZhangWu zw) {<br>                    // TODO Auto-generated method stub</p>
<pre><code>}</code></pre><p>###30编辑账务功能dao层实现<br>    * A：编辑账务功能dao层实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.dao包中的ZhangWuDao类editZhangWu方法<br>                /*<br>                 * 定义方法，实现编辑功能<br>                 * 由业务层调用，传递ZhangWu对象<br>                 * 将对象中的数据，更新到数据表<br>                 */<br>                public void editZhangWu(ZhangWu zw) {<br>                    try {<br>                        //更新数据的SQL<br>                        String sql = “UPDATE zhangwu SET flname=?,money=?,zhanghu=?,createtime=?,description=? WHERE zwid=?”;<br>                        //定义对象数组，封装所有数据<br>                        Object[] params = {zw.getFlname(),zw.getMoney(),zw.getZhanghu(),zw.getCreatetime(),zw.getDescription(),zw.getZwid()};<br>                        //调用qr对象方法update执行更新<br>                        qr.update(sql, params);<br>                    } catch (SQLException ex) {<br>                        System.out.println(ex);<br>                        throw new RuntimeException(“编辑账务失败”);<br>                    }</p>
<pre><code>}</code></pre><p>​<br>###31编辑账务功能view层实现<br>    * A: 编辑账务功能view层实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.view包中建立MainView类editZhangWu方法<br>                /*<br>                 * 定义方法，实现对账务的编辑功能<br>                 * 实现思想：<br>                 *     接收用户的输入的信息<br>                 *  封装成ZhangWu对象<br>                 *  调用控制层的方法，传递ZhangWu对象，实现编辑<br>                 *<br>                 */<br>                public void editZhangWu() {<br>                    //调用查询所有账务数据的功能，显示出来<br>                    //看到所有数据，从中选择一项，进行修改<br>                    selectAll();<br>                    System.out.println(“选择的是编辑功能，请输入数据”);<br>                    Scanner sc = new Scanner(System.in);<br>                    System.out.print(“请输入ID”);<br>                    int zwid = sc.nextInt();<br>                    System.out.println(“输入分类名称”);<br>                    String flname = sc.next();<br>                    System.out.println(“输入金额”);<br>                    double money = sc.nextDouble();<br>                    System.out.println(“输入账户”);<br>                    String zhanghu = sc.next();<br>                    System.out.println(“输入日期：格式XXXX-XX-xx”);<br>                    String createtime = sc.next();<br>                    System.out.println(“输入具体描述”);<br>                    String description = sc.next();<br>                    //将用户输入的数据，封装到ZhangWu对象中<br>                    //用户输入的ID，必须封装到到对象中<br>                    ZhangWu zw = new ZhangWu(zwid, flname, money, zhanghu, createtime, description);<br>                    //调用controller层中的方法，实现编辑账务<br>                    controller.editZhangWu(zw);<br>                    System.out.println(“账务编辑成功”);<br>                }</p>
<p>###32删除账务功能分析<br>    * A: 删除账务功能分析<br>        * a: 编写MainView类中deleteZhangWu方法<br>            * 键盘输入要删除的账务信息ID号<br>            * 调用ZhangWuService类中deleteZhangWu方法，用来将指定的账务信息删除<br>            * 删除完毕后，使用输出语句，提示 “删除账务成功！”<br>        * b: 编写ZhangWuService类中deleteZhangWu方法<br>            * 调用ZhangWuDao类中deleteZhangWu方法，用来将指定的账务信息删除<br>        * c: 编写ZhangWuDao类中deleteZhangWu方法<br>            * 通过QueryRunner对象，调用update方法更新数据库表gjp_zhangwu，完成数据库表中指定账务删除操作</p>
<p>​            </p>
<p>###33删除账务功能菜单实现<br>    * A: 删除账务功能菜单实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.view包中建立MainView类deleteZhangWu方法<br>                /*<br>                 * 定义方法，实现账务删除<br>                 * 实现思想：<br>                 *     接收用户的输入，输入一个主键数据<br>                 *  调用控制层方法，传递一个主键<br>                 */<br>                public void deleteZhangWu() {<br>                    //调用查询所有账务数据的功能，显示出来<br>                    //看到所有数据，从中选择一项，进行修改<br>                    selectAll();<br>                    System.out.println(“选择的是删除功能，请输入序号即可”);<br>                    int zwid = new Scanner(System.in).nextInt();<br>                    //调用控制层方法，传递主键id即可<br>                }</p>
<p>###34删除账务功能控制层,业务层实现<br>    * A: 删除账务功能控制层,业务层实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.controller包中的ZhangWuController类deleteZhangWu方法<br>                /*<br>                 * 定义方法，实现删除功能<br>                 * 视图层调用，传递int类型主键<br>                 * 调用service层方法，传递int主键<br>                 <em>/<br>                public void deleteZhangWu(int zwid) {<br>                    service.deleteZhangWu(zwid);<br>                }<br>            * cn.itcast.gjp.service包中的ZhangWuService类deleteZhangWu方法<br>                /</em><br>                 * 定义方法，实现删除账务功能<br>                 * 由控制层调用，传递主键id<br>                 * 调用dao层方法，传递主键id<br>                 */<br>                public void deleteZhangWu(int zwid) {<br>                    dao.deleteZhangWu(zwid);<br>                }<br>            * cn.itcast.gjp.dao包中的ZhangWuDao类deleteZhangWu方法<br>                public void deleteZhangWu(int zwid) {</p>
<pre><code>}</code></pre><p>###35删除账务功能dao实现<br>    * A: 删除账务功能dao实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.dao包中的ZhangWuDao类deleteZhangWu方法<br>                /*<br>                 * 定义方法，实现删除业务<br>                 * 业务层调用，传递主键id<br>                 */<br>                public void deleteZhangWu(int zwid) {<br>                    try {<br>                        //拼写删除数据SQL<br>                        String sql = “DELETE FROM gjp_zhangwu WHERE zwid=?”;<br>                        qr.update(sql, zwid);<br>                    } catch (SQLException ex) {<br>                        System.out.println(ex);<br>                        throw new RuntimeException(“删除账务失败”);<br>                    }<br>                }</p>
<p>​<br>###36删除账务功能view层实现<br>    * A: 删除账务功能view层实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.view包中建立MainView类editZhangWu方法<br>                /*<br>                 * 定义方法，实现账务删除<br>                 * 实现思想：<br>                 *     接收用户的输入，输入一个主键数据<br>                 *  调用控制层方法，传递一个主键<br>                 */<br>                public void deleteZhangWu() {<br>                    //调用查询所有账务数据的功能，显示出来<br>                    //看到所有数据，从中选择一项，进行修改<br>                    selectAll();<br>                    System.out.println(“选择的是删除功能，请输入序号即可”);<br>                    int zwid = new Scanner(System.in).nextInt();<br>                    //调用控制层方法，传递主键id即可<br>                    controller.deleteZhangWu(zwid);<br>                    System.out.println(“删除账务成功”);</p>
<p>###37总结<br>    * 把今天的知识点总结一遍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day30%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day30%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记30</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:14:03" itemprop="dateModified" datetime="2020-12-23T23:14:03+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、DBUtils<br>2、连接池                        </p>
<p>###01DButils工具类的介绍个三个核心类<br>    * A: DButils工具类的介绍个三个核心类<br>        * a: 概述<br>            * DBUtils是java编程中的数据库操作实用工具，小巧简单实用。<br>            * DBUtils封装了对JDBC的操作，简化了JDBC操作，可以少写代码。<br>            * DBUtils就是JDBC的简化开发工具包。需要项目导入commons-dbutils-1.6.jar才能够正常使用DBUtils工具。<br>        * b: Dbutils三个核心功能介绍<br>            * QueryRunner中提供对sql语句操作的API.<br>                * update(Connection conn, String sql, Object… params) ，用来完成表数据的增加、删除、更新操作<br>                * query(Connection conn, String sql, ResultSetHandler<T> rsh, Object… params) ，用来完成表数据的查询操作<br>            * ResultSetHandler接口，用于定义select操作后，怎样封装结果集.<br>            * DbUtils类，它就是一个工具类,定义了关闭资源与事务处理的方法</T></p>
<p>###02事务的简单介绍(此知识点简单了解，难度较大，就业班会详细 讲解)<br>    * A: 事务的简单介绍<br>        * a: 见day32/day32_source/事务.jgp</p>
<p>###03QueryRunner类的update方法介绍<br>    * A：QueryRunner类的update方法介绍<br>        * a: 方法介绍<br>            * update(Connection conn, String sql, Object… params) ，用来完成表数据的增加、删除、更新操作<br>            *  使用QueryRunner类,实现对数据表的insert delete update<br>            *  调用QueryRunner类的方法 update (Connection con,String sql,Object…param)<br>                *  Object…param 可变参数,Object类型,SQL语句会出现?占位符<br>                *  数据库连接对象,自定义的工具类传递</p>
<p>​<br>###04QueryRunner类实现insert添加数据<br>    * A: QueryRunner类实现insert添加数据<br>        * a: 案例代码<br>            public class QueryRunnerDemo {<br>                private static Connection con = JDBCUtilsConfig.getConnection();<br>                public static void main(String[] args)throws SQLException {<br>                    insert();<br>                }<br>                /*<br>                 * 定义方法,使用QueryRunner类的方法update向数据表中,添加数据<br>                 */<br>                public static void insert()throws SQLException{<br>                    //创建QueryRunner类对象<br>                    QueryRunner qr = new QueryRunner();<br>                    String sql = “INSERT INTO sort (sname,sprice,sdesc)VALUES(?,?,?)”;<br>                    //将三个?占位符的实际参数,写在数组中<br>                    Object[] params = {“体育用品”,289.32,”购买体育用品”};<br>                    //调用QueryRunner类的方法update执行SQL语句<br>                    int row = qr.update(con, sql, params);<br>                    System.out.println(row);<br>                    DbUtils.closeQuietly(con);<br>                }<br>            }</p>
<p>###05QueryRunner类实现update修改数据<br>    * A: QueryRunner类实现update修改数据<br>        * a: 案例代码<br>            public class QueryRunnerDemo {<br>                private static Connection con = JDBCUtilsConfig.getConnection();<br>                public static void main(String[] args)throws SQLException {<br>                    update();<br>                }<br>                /*<br>                 *  定义方法,使用QueryRunner类的方法update将数据表的数据修改<br>                 */<br>                public static void update()throws SQLException{<br>                    //创建QueryRunner类对象<br>                    QueryRunner qr = new QueryRunner();<br>                    //写修改数据的SQL语句<br>                    String sql = “UPDATE sort SET sname=?,sprice=?,sdesc=? WHERE sid=?”;<br>                    //定义Object数组,存储?中的参数<br>                    Object[] params = {“花卉”,100.88,”情人节玫瑰花”,4};<br>                    //调用QueryRunner方法update<br>                    int row = qr.update(con, sql, params);<br>                    System.out.println(row);<br>                    DbUtils.closeQuietly(con);<br>                }<br>            }</p>
<p>​            </p>
<p>###06QueryRunner类实现delete删除数据<br>    * A: QueryRunner类实现delete删除数据<br>        * a: 案例代码<br>            public class QueryRunnerDemo {<br>                private static Connection con = JDBCUtilsConfig.getConnection();<br>                public static void main(String[] args)throws SQLException {<br>                    delete();<br>                }<br>                /*<br>                 *  定义方法,使用QueryRunner类的方法delete将数据表的数据删除<br>                 <em>/<br>                public static void delete()throws SQLException{<br>                    //创建QueryRunner类对象<br>                    QueryRunner qr = new QueryRunner();<br>                    //写删除的SQL语句<br>                    String sql = “DELETE FROM sort WHERE sid=?”;<br>                    //调用QueryRunner方法update<br>                    int row = qr.update(con, sql, 8);<br>                    System.out.println(row);<br>                    /</em><br>                     *  判断insert,update,delete执行是否成功<br>                     *  对返回值row判断<br>                     *  if(row&gt;0) 执行成功<br>                     */<br>                    DbUtils.closeQuietly(con);<br>                }<br>            }</p>
<p>###07JavaBean类<br>    * A: JavaBean类<br>        * a: 概念<br>            * JavaBean就是一个类，在开发中常用封装数据。具有如下特性<br>                1.    需要实现接口：java.io.Serializable ，通常实现接口这步骤省略了，不会影响程序。<br>                2.    提供私有字段：private 类型 字段名;<br>                3.    提供getter/setter方法：<br>                4.    提供无参构造</p>
<p>###08DBUtils工具类结果集处理的方式<br>    * A: DBUtils工具类结果集处理的方式<br>        * a: QueryRunner实现查询操作<br>            *    query(Connection conn, String sql, ResultSetHandler<T> rsh, Object… params) ，用来完成表数据的查询操作<br>        * b: ResultSetHandler结果集处理类<br>            * ArrayHandler    将结果集中的第一条记录封装到一个Object[]数组中，数组中的每一个元素就是这条记录中的每一个字段的值<br>            * ArrayListHandler    将结果集中的每一条记录都封装到一个Object[]数组中，将这些数组在封装到List集合中。<br>            * BeanHandler    将结果集中第一条记录封装到一个指定的javaBean中。<br>            * BeanListHandler    将结果集中每一条记录封装到指定的javaBean中，将这些javaBean在封装到List集合中<br>            * ColumnListHandler    将结果集中指定的列的字段值，封装到一个List集合中<br>            * ScalarHandler    它是用于单数据。例如select count(*) from 表操作。<br>            * MapHandler    将结果集第一行封装到Map集合中,Key 列名, Value 该列数据<br>            * MapListHandler    将结果集第一行封装到Map集合中,Key 列名, Value 该列数据,Map集合存储到List集合</T></p>
<p>###09QueryRunner类的方法query<br>    * A: QueryRunner类的方法query<br>        * a: QueryRunner数据查询操作<br>            * 调用QueryRunner类方法query(Connection con,String sql,ResultSetHandler r, Object..params)<br>            *  ResultSetHandler r 结果集的处理方式,传递ResultSetHandler接口实现类<br>            *  Object..params SQL语句中的?占位符<br>            *  注意: query方法返回值,返回的是T 泛型, 具体返回值类型,跟随结果集处理方式变化<br>        * b: 案例代码<br>            public class QueryRunnerDemo1 {<br>                private static Connection con = JDBCUtilsConfig.getConnection();<br>            }</p>
<p>###10结果集处理ArrayHandler<br>    * A: 结果集处理ArrayHandler<br>        * 案例代码<br>            public class QueryRunnerDemo1 {<br>                private static Connection con = JDBCUtilsConfig.getConnection();<br>                public static void main(String[] args) throws SQLException{<br>                    arrayHandler();<br>                }<br>                /*<br>                 *  结果集第一种处理方法, ArrayHandler<br>                 *  将结果集的第一行存储到对象数组中  Object[]<br>                 */<br>                public static void arrayHandler()throws SQLException{<br>                    QueryRunner qr = new QueryRunner();<br>                    String sql = “SELECT * FROM sort”;<br>                    //调用方法query执行查询,传递连接对象,SQL语句,结果集处理方式的实现类<br>                    //返回对象数组<br>                    Object[] result = qr.query(con, sql, new ArrayHandler());<br>                    for(Object obj : result){<br>                        System.out.print(obj);<br>                    }<br>                }<br>            }</p>
<p>###11结果集处理ArrayListHandler<br>    * A: 结果集处理ArrayListHandler<br>        * a: 案例代码<br>            public class QueryRunnerDemo1 {<br>                private static Connection con = JDBCUtilsConfig.getConnection();<br>                public static void main(String[] args) throws SQLException{<br>                    arrayListHandler();<br>                }<br>                /*<br>                 *  结果集第二种处理方法,ArrayListHandler<br>                 *  将结果集的每一行,封装到对象数组中, 出现很多对象数组<br>                 *  对象数组存储到List集合<br>                 */<br>                public static void arrayListHandler()throws SQLException{<br>                    QueryRunner qr = new QueryRunner();<br>                    String sql = “SELECT * FROM sort”;<br>                    //调用query方法,结果集处理的参数上,传递实现类ArrayListHandler<br>                    //方法返回值 每行是一个对象数组,存储到List<br>                    List&lt;Object[]&gt; result=  qr.query(con, sql, new ArrayListHandler());</p>
<pre><code>        //集合的遍历
        for( Object[] objs  : result){
            //遍历对象数组
            for(Object obj : objs){
                System.out.print(obj+&quot;  &quot;);
            }
            System.out.println();
        }
    }
}</code></pre><p>​<br>###12结果集处理BeanHandler<br>    * A: 结果集处理BeanHandler<br>        * a: 案例代码<br>            public class QueryRunnerDemo1 {<br>                private static Connection con = JDBCUtilsConfig.getConnection();<br>                public static void main(String[] args) throws SQLException{<br>                    beanHandler();<br>                }<br>                /*<br>                 *  结果集第三种处理方法,BeanHandler<br>                 *  将结果集的第一行数据,封装成JavaBean对象<br>                 *  注意: 被封装成数据到JavaBean对象, Sort类必须有空参数构造<br>                 */<br>                public static void beanHandler()throws SQLException{<br>                    QueryRunner qr = new QueryRunner();<br>                    String sql = “SELECT * FROM sort “;<br>                    //调用方法,传递结果集实现类BeanHandler<br>                    //BeanHandler(Class<T> type)<br>                    Sort s = qr.query(con, sql, new BeanHandler<Sort>(Sort.class));<br>                    System.out.println(s);<br>                }<br>            }</Sort></T></p>
<p>###13结果集处理BeanListHandler<br>    * A: 结果集处理BeanListHandler<br>        * a: 案例代码<br>        public class QueryRunnerDemo1 {<br>            private static Connection con = JDBCUtilsConfig.getConnection();<br>            public static void main(String[] args) throws SQLException{<br>                beanListHander();<br>            }<br>            /*<br>             *  结果集第四种处理方法, BeanListHandler<br>             *  结果集每一行数据,封装JavaBean对象<br>             *  多个JavaBean对象,存储到List集合<br>             */<br>            public static void beanListHander()throws SQLException{<br>                QueryRunner qr = new QueryRunner();<br>                String sql = “SELECT * FROM sort “;<br>                //调用方法query,传递结果集处理实现类BeanListHandler<br>                List<Sort> list = qr.query(con, sql, new BeanListHandler<Sort>(Sort.class));<br>                for(Sort s : list){<br>                    System.out.println(s);<br>                }<br>            }<br>        }</Sort></Sort></p>
<p>​<br>###14结果集处理ColumnListHandler<br>    * A: 结果集处理ColumnListHandler<br>        * a: 案例代码<br>            public class QueryRunnerDemo1 {<br>                private static Connection con = JDBCUtilsConfig.getConnection();<br>                public static void main(String[] args) throws SQLException{<br>                    columnListHandler();<br>                }<br>                /*<br>                 *  结果集第五种处理方法,ColumnListHandler<br>                 *  结果集,指定列的数据,存储到List集合<br>                 *  List<Object> 每个列数据类型不同<br>                 */<br>                public static void columnListHandler()throws SQLException{<br>                    QueryRunner qr = new QueryRunner();<br>                    String sql = “SELECT * FROM sort “;<br>                    //调用方法 query,传递结果集实现类ColumnListHandler<br>                    //实现类构造方法中,使用字符串的列名<br>                    List<Object> list = qr.query(con, sql, new ColumnListHandler<Object>(“sname”));<br>                    for(Object obj : list){<br>                        System.out.println(obj);<br>                    }<br>                }<br>            }</Object></Object></Object></p>
<p>​<br>###15结果集处理ScalarHandler<br>    * A: 结果集处理ScalarHandler<br>        * a: 案例代码<br>            public class QueryRunnerDemo1 {<br>                private static Connection con = JDBCUtilsConfig.getConnection();<br>                public static void main(String[] args) throws SQLException{<br>                    scalarHandler();<br>                }<br>                /*<br>                 *  结果集第六种处理方法,ScalarHandler<br>                 *  对于查询后,只有1个结果<br>                 <em>/<br>                public static void scalarHandler()throws SQLException{<br>                    QueryRunner qr = new QueryRunner();<br>                    String sql = “SELECT COUNT(</em>) FROM sort”;<br>                    //调用方法query,传递结果集处理实现类ScalarHandler<br>                    long count = qr.query(con, sql, new ScalarHandler<Long>());<br>                    System.out.println(count);<br>                }<br>            }</Long></p>
<p>###16结果集处理MapHandler<br>    * A: 结果集处理MapHandler<br>        * a: 案例代码<br>            public class QueryRunnerDemo1 {<br>                private static Connection con = JDBCUtilsConfig.getConnection();<br>                public static void main(String[] args) throws SQLException{<br>                    mapHandler();<br>                }<br>                /*<br>                 *  结果集第七种处理方法,MapHandler<br>                 *  将结果集第一行数据,封装到Map集合中<br>                 *  Map&lt;键,值&gt; 键:列名  值:这列的数据<br>                 */<br>                public static void mapHandler()throws SQLException{<br>                    QueryRunner qr = new QueryRunner();<br>                    String sql = “SELECT  * FROM sort”;<br>                    //调用方法query,传递结果集实现类MapHandler<br>                    //返回值: Map集合,Map接口实现类, 泛型<br>                    Map&lt;String,Object&gt; map = qr.query(con, sql, new MapHandler());<br>                    //遍历Map集合<br>                    for(String key : map.keySet()){<br>                        System.out.println(key+”..”+map.get(key));<br>                    }<br>                }<br>            }</p>
<p>###17结果集处理MapListHandler<br>    * A: 结果集处理MapListHandlerr<br>        * a: 案例代码<br>            public class QueryRunnerDemo1 {<br>                private static Connection con = JDBCUtilsConfig.getConnection();<br>                public static void main(String[] args) throws SQLException{<br>                    mapListHandler();<br>                }<br>                /*<br>                 *  结果集第八种处理方法,MapListHandler<br>                 *  将结果集每一行存储到Map集合,键:列名,值:数据<br>                 *  Map集合过多,存储到List集合<br>                 */<br>                public static void mapListHandler()throws SQLException{<br>                    QueryRunner qr = new QueryRunner();<br>                    String sql = “SELECT  * FROM sort”;<br>                    //调用方法query,传递结果集实现类MapListHandler<br>                    //返回值List集合, 存储的是Map集合<br>                    List&lt;Map&lt;String,Object&gt;&gt; list = qr.query(con, sql, new MapListHandler());<br>                    //遍历集合list<br>                    for( Map&lt;String,Object&gt; map : list ){<br>                        for(String key : map.keySet()){<br>                            System.out.print(key+”…”+map.get(key));<br>                        }<br>                        System.out.println();<br>                    }</p>
<pre><code>    }
}</code></pre><p>###18连接池介绍<br>    * A: 连接池介绍<br>        * a: 连接池介绍<br>            * 实际上就是存放连接的池子(容器)<br>            * 在开发中“获得连接”或“释放资源”是非常消耗系统资源的两个过程<br>            * 为了解决此类性能问题，通常情况我们采用连接池技术，来共享连接Connection。<br>            * 这样我们就不需要每次都创建连接、释放连接了，这些操作都交给了连接池            </p>
<p>###19连接池概念规范和DataSource接口<br>    * A: 连接池概念规范和DataSource接口<br>        * a: 连接池概念规范<br>            * 用池来管理Connection，这样可以重复使用Connection。<br>            * 不用自己来创建Connection，而是通过池来获取Connection对象<br>            * 使用完Connection后，调用Connection的close()方法也不会真的关闭Connection，而是把Connection“归还”给池<br>            * 连接池技术可以完成Connection对象的再次利用<br>        * b: DataSource接口<br>            * Java为数据库连接池提供了公共的接口：javax.sql.DataSource<br>            * 各个厂商需要让自己的连接池实现这个接口。这样应用程序可以方便的切换不同厂商的连接池<br>            * 常见的连接池：DBCP、C3P0<br>###20DBCP连接池介绍<br>    * A: DBCP连接池介绍<br>        * a: DBCP连接池介绍<br>            * DBCP也是一个开源的连接池，是Apache Common成员之一，在企业开发中也比较常见，tomcat内置的连接池<br>        * tomcat服务器简单介绍    </p>
<p>###21导入jar包<br>    * A: 导入jar包<br>        * a: jar包介绍<br>            * mysql-connector-java-5.1.37-bin.jar：数据库驱动<br>            * commons-dbutils-1.6.jar：提供QueryRunner类方便进行增删改查操作<br>            * commons-dbcp-1.4.jar：<br>            * commons-pool-1.5.6.jar：提供高效的数据库连接池技术<br>        * b: 导入jar包<br>            * 在项目根路径下建立文件夹lib<br>            * 拷贝以上jar包，选定拷贝的jar包/右键/Build Path/Add to Build Path</p>
<p>###22BasicDataSource类的使用<br>    * A: BasicDataSource类的使用<br>        * a: 案例代码<br>            /*<br>             *  连接池jar包中,定义好一个类 BasicDataSource<br>             *  实现类数据源的规范接口 javax.sql.DataSource<br>             */<br>            public class DataSoruceDemo {<br>                public static void main(String[] args) {<br>                    //创建DataSource接口的实现类对象<br>                    //实现类, org.apache.commons.dbcp<br>                    BasicDataSource dataSource = new BasicDataSource();<br>                    //连接数据库的4个最基本信息,通过对象方法setXXX设置进来<br>                    dataSource.setDriverClassName(“com.mysql.jdbc.Driver”);<br>                    dataSource.setUrl(“jdbc:mysql://localhost:3306/mybase”);<br>                    dataSource.setUsername(“root”);<br>                    dataSource.setPassword(“123”);</p>
<pre><code>        try{
        //调用对象方法getConnection获取数据库的连接
            Connection con = dataSource.getConnection();
            System.out.println(con);
        }catch(SQLException ex){
//            System.out.println(ex);
            ex.printStackTrace();
            throw new RuntimeException(&quot;数据库连接失败&quot;);
        }
    }
}</code></pre><p>​<br>###23BasicDataSource类的常见配置<br>    * A: BasicDataSource类的常见配置<br>        * a: 常见配置<br>            分类    属性            描述<br>            必须项<br>                    driverClassName    数据库驱动名称<br>                    url                数据库的地址<br>                    username        用户名<br>                    password        密码<br>            基本项（扩展）<br>                    maxActive        最大连接数量<br>                    minIdle            最小空闲连接<br>                    maxIdle         最大空闲连接<br>                    initialSize        初始化连接</p>
<p>​<br>###24实现数据库连接池工具类<br>    * A: 实现数据库连接池工具类<br>        * a: 案例代码<br>            /*<br>             *  使用DBCP实现数据库的连接池<br>             *  连接池配置,自定义类,<br>             *  最基本四项完整<br>             *  对于数据库连接池其他配置,自定义<br>             */</p>
<pre><code>import javax.sql.DataSource;

import org.apache.commons.dbcp.BasicDataSource;
public class JDBCUtils{
    //创建出BasicDataSource类对象
    private static BasicDataSource datasource = new BasicDataSource();

    //静态代码块,对象BasicDataSource对象中的配置,自定义
    static{
        //数据库连接信息,必须的
        datasource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
        datasource.setUrl(&quot;jdbc:mysql://localhost:3306/day33_user&quot;);
        datasource.setUsername(&quot;root&quot;);
        datasource.setPassword(&quot;123&quot;);
        //对象连接池中的连接数量配置,可选的
        datasource.setInitialSize(10);//初始化的连接数
        datasource.setMaxActive(8);//最大连接数量
        datasource.setMaxIdle(5);//最大空闲数
        datasource.setMinIdle(1);//最小空闲
    }</code></pre><p>​<br>                //定义静态方法,返回BasicDataSource类的对象<br>                public static DataSource getDataSource(){<br>                    return datasource;<br>                }<br>            }</p>
<p>​<br>###25工具类的测试<br>    * A: 工具类的测试<br>        * a: 案例代码<br>            /*<br>             *  测试写好的工具类,<br>             *  提供的是一个DataSource接口的数据源<br>             *  QueryRunner类构造方法,接收DataSource接口的实现类<br>             *  后面,调用方法update,query,无需传递他们Connection连接对象<br>             */</p>
<pre><code>import java.sql.SQLException;
import java.util.List;

import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.ArrayListHandler;

import cn.itcast.jdbcutils.JDBCUtils;
public class QueryRunnerDemo{
    public static void main(String[] args) {
        select();
    }
    //定义2个方法,实现数据表的添加,数据表查询
    //QueryRunner类对象,写在类成员位置
    private static QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource()); 

    //数据表查询
    public static void select(){
        String sql = &quot;SELECT * FROM sort&quot;;
        try{
        List&lt;Object[]&gt; list = qr.query(sql, new ArrayListHandler());
        for(Object[] objs : list){
            for(Object obj : objs){
                System.out.print(obj+&quot;\t&quot;);
            }
            System.out.println();
        }
        }catch(SQLException ex){
            throw new RuntimeException(&quot;数据查询失败&quot;);
        }
    }

    //数据表添加数据
    public static void insert(){
        String sql = &quot;INSERT INTO sort (sname,sprice,sdesc)VALUES(?,?,?)&quot;;
        Object[] params = {&quot;水果&quot;,100.12,&quot;刚刚上市的核桃&quot;};
        try{
            int row = qr.update(sql, params);
            System.out.println(row);
        }catch(SQLException ex){
            throw new RuntimeException(&quot;数据添加失败&quot;);
        }
    }

}</code></pre><p>###26总结<br>    * 把今天的知识点总结一遍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day29%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day29%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记29</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:13:30" itemprop="dateModified" datetime="2020-12-23T23:13:30+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、JDBC<br>2、DBUtils</p>
<p>###01JDBC概念和数据库驱动程序<br>    * A: JDBC概念和数据库驱动程序<br>        * a: JDBC概述<br>            * JDBC（Java Data Base Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，<br>                可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。是Java访问数据库的标准规范<br>            * JDBC提供了一种基准,据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。<br>            * JDBC需要连接驱动，驱动是两个设备要进行通信，满足一定通信数据格式，数据格式由设备提供商规定，<br>                设备提供商为设备提供驱动软件，通过软件可以与该设备进行通信。<br>            * 我们使用的是mysql的驱动mysql-connector-java-5.1.39-bin.jar<br>        * b: 总结<br>            * JDBC是java提供给开发人员的一套操作数据库的接口<br>            * 数据库驱动就是实现该接口的实现类</p>
<p>###02JDBC原理<br>    * A: JDBC原理<br>        * a: 描述<br>            * Java提供访问数据库规范称为JDBC，而生产厂商提供规范的实现类称为驱动<br>            * DBC是接口，驱动是接口的实现，没有驱动将无法完成数据库连接，从而不能操作数据库！<br>                每个数据库厂商都需要提供自己的驱动，用来连接自己公司的数据库，也就是说驱动一般都由数据库生成厂商提供。<br>            * 图解见day29_source/JDBC实现原理.JPG</p>
<p>###03准备数据<br>    * A: 准备数据<br>        * a: 创建数据库和表结构<br>            #创建数据库<br>            create database mybase;<br>            #使用数据库<br>            use mybase;<br>            ###创建分类表<br>            create table sort(<br>              sid int PRIMARY KEY AUTO_INCREMENT,<br>              sname varchar(100),<br>              sprice DOUBLE,<br>              sdesc VARCHAR(500)<br>            );</p>
<pre><code>* b: 向表中插入数据
    #初始化数据
    insert into sort(sname,sprice,sdesc) values(&apos;家电&apos;,2000, &apos;优惠的促销&apos;);
    insert into sort(sname,sprice,sdesc) values(&apos;家具&apos;,8900, &apos;家具价格上调,原材料涨价&apos;);
    insert into sort(sname,sprice,sdesc) values(&apos;儿童玩具&apos;,290, &apos;赚家长的钱&apos;);
    insert into sort(sname,sprice,sdesc) values(&apos;生鲜&apos;,500.99, &apos;生鲜商品&apos;);
    insert into sort(sname,sprice,sdesc) values(&apos;服装&apos;,24000, &apos;换季销售&apos;);
    insert into sort(sname,sprice,sdesc) values(&apos;洗涤&apos;,50, &apos;洗发水促销&apos;);            </code></pre><p>###04JDBC的开发步骤<br>    * A: JDBC的开发步骤<br>        * a: 步骤介绍<br>            1.注册驱动<br>                告知JVM使用的是哪一个数据库的驱动<br>            2.获得连接<br>                使用JDBC中的类,完成对MySQL数据库的连接<br>            3.获得语句执行平台<br>                通过连接对象获取对SQL语句的执行者对象<br>            4.执行sql语句<br>                使用执行者对象,向数据库执行SQL语句<br>                获取到数据库的执行后的结果<br>            5.处理结果<br>            6.释放资源  一堆close()</p>
<p>###05导入mysql数据库驱动程序jar包<br>    * A: 导入mysql数据库驱动程序jar包<br>        * a: 步骤<br>            * 创建lib目录，用于存放当前项目需要的所有jar包<br>            * 选择jar包，右键执行build path / Add to Build Path</p>
<p>###06注册数据库驱动程序<br>    * A: 注册数据库驱动程序<br>        * a: 案例代码<br>            public class JDBCDemo {<br>                public static void main(String[] args)throws ClassNotFoundException,SQLException{<br>                    //1.注册驱动 反射技术,将驱动类加入到内容<br>                    // 使用java.sql.DriverManager类静态方法 registerDriver(Driver driver)<br>                    // Diver是一个接口,参数传递,MySQL驱动程序中的实现类<br>                    //DriverManager.registerDriver(new Driver());<br>                    //驱动类源代码,注册2次驱动程序<br>                    Class.forName(“com.mysql.jdbc.Driver”);<br>                }<br>            }</p>
<p>​<br>​<br>###07获取数据库的连接对象<br>    * A：获取数据库的连接对象<br>        * a: 案例代码<br>            public class JDBCDemo {<br>                public static void main(String[] args)throws ClassNotFoundException,SQLException{<br>                    //1.注册驱动 反射技术,将驱动类加入到内容<br>                    // 使用java.sql.DriverManager类静态方法 registerDriver(Driver driver)<br>                    // Diver是一个接口,参数传递,MySQL驱动程序中的实现类<br>                    //DriverManager.registerDriver(new Driver());<br>                    //驱动类源代码,注册2次驱动程序<br>                    Class.forName(“com.mysql.jdbc.Driver”);</p>
<pre><code>        //2.获得数据库连接  DriverManager类中静态方法
        //static Connection getConnection(String url, String user, String password)  
        //返回值是Connection接口的实现类,在mysql驱动程序
        //url: 数据库地址  jdbc:mysql://连接主机IP:端口号//数据库名字
        String url = &quot;jdbc:mysql://localhost:3296/mybase&quot;;
        //用户名和密码用自己的
        String username=&quot;root&quot;;
        String password=&quot;123&quot;;
        Connection con = DriverManager.getConnection(url, username, password);
        System.out.println(con);                    
    }
}</code></pre><p>​<br>###08获取SQL语句的执行对象对象<br>    * A: 获取SQL语句的执行对象对象<br>        * a: 案例代码<br>            public class JDBCDemo {<br>                public static void main(String[] args)throws ClassNotFoundException,SQLException{<br>                    //1.注册驱动 反射技术,将驱动类加入到内容<br>                    // 使用java.sql.DriverManager类静态方法 registerDriver(Driver driver)<br>                    // Diver是一个接口,参数传递,MySQL驱动程序中的实现类<br>                    //DriverManager.registerDriver(new Driver());<br>                    //驱动类源代码,注册2次驱动程序<br>                    Class.forName(“com.mysql.jdbc.Driver”);</p>
<pre><code>        //2.获得数据库连接  DriverManager类中静态方法
        //static Connection getConnection(String url, String user, String password)  
        //返回值是Connection接口的实现类,在mysql驱动程序
        //url: 数据库地址  jdbc:mysql://连接主机IP:端口号//数据库名字
        String url = &quot;jdbc:mysql://localhost:3296/mybase&quot;;
        String username=&quot;root&quot;;
        String password=&quot;123&quot;;
        Connection con = DriverManager.getConnection(url, username, password);

        //3.获得语句执行平台, 通过数据库连接对象,获取到SQL语句的执行者对象
        // con对象调用方法   Statement createStatement() 获取Statement对象,将SQL语句发送到数据库
        // 返回值是 Statement接口的实现类对象,,在mysql驱动程序
        Statement stat = con.createStatement();
        System.out.println(stat);
    }
}</code></pre><p>###09执行insert语句获取结果集<br>    * A: 执行insert语句获取结果集<br>        * a: 案例代码<br>            public class JDBCDemo {<br>                public static void main(String[] args)throws ClassNotFoundException,SQLException{<br>                    //1.注册驱动 反射技术,将驱动类加入到内容<br>                    // 使用java.sql.DriverManager类静态方法 registerDriver(Driver driver)<br>                    // Diver是一个接口,参数传递,MySQL驱动程序中的实现类<br>                    //DriverManager.registerDriver(new Driver());<br>                    //驱动类源代码,注册2次驱动程序<br>                    Class.forName(“com.mysql.jdbc.Driver”);</p>
<pre><code>        //2.获得数据库连接  DriverManager类中静态方法
        //static Connection getConnection(String url, String user, String password)  
        //返回值是Connection接口的实现类,在mysql驱动程序
        //url: 数据库地址  jdbc:mysql://连接主机IP:端口号//数据库名字
        String url = &quot;jdbc:mysql://localhost:3296/mybase&quot;;
        String username=&quot;root&quot;;
        String password=&quot;123&quot;;
        Connection con = DriverManager.getConnection(url, username, password);

        //3.获得语句执行平台, 通过数据库连接对象,获取到SQL语句的执行者对象
        // con对象调用方法   Statement createStatement() 获取Statement对象,将SQL语句发送到数据库
        // 返回值是 Statement接口的实现类对象,,在mysql驱动程序
        Statement stat = con.createStatement();
        //    4.执行sql语句
        // 通过执行者对象调用方法执行SQL语句,获取结果
        // int executeUpdate(String sql)  执行数据库中的SQL语句, insert delete update
        // 返回值int,操作成功数据表多少行
        int row = stat.executeUpdate
                (&quot;INSERT INTO sort(sname,sprice,sdesc) VALUES(&apos;汽车用品&apos;,50000,&apos;疯狂涨价&apos;)&quot;);
        System.out.println(row);

        //6.释放资源  一堆close()
        stat.close();
        con.close();
    }
}</code></pre><p>###10执行select语句获取结果集<br>    * A: 执行select语句获取结果集<br>        * a: 案例代码<br>            public class JDBCDemo1 {<br>                public static void main(String[] args) throws Exception{<br>                    //1. 注册驱动<br>                    Class.forName(“com.mysql.jdbc.Driver”);<br>                    //2. 获取连接对象<br>                    String url = “jdbc:mysql://localhost:3296/mybase”;<br>                    String username=”root”;<br>                    String password=”123”;<br>                    Connection con = DriverManager.getConnection(url, username, password);<br>                    //3 .获取执行SQL 语句对象<br>                    Statement stat = con.createStatement();<br>                    // 拼写查询的SQL<br>                    String sql = “SELECT * FROM sort”;<br>                    //4. 调用执行者对象方法,执行SQL语句获取结果集<br>                    // ResultSet executeQuery(String sql)  执行SQL语句中的select查询<br>                    // 返回值ResultSet接口的实现类对象,实现类在mysql驱动中<br>                    ResultSet rs = stat.executeQuery(sql);<br>                    //5 .处理结果集<br>                    // ResultSet接口方法 boolean next() 返回true,有结果集,返回false没有结果集<br>                    while(rs.next()){<br>                        //获取每列数据,使用是ResultSet接口的方法 getXX方法参数中,建议写String列名<br>                        System.out.println(rs.getInt(“sid”)+”   “+rs.getString(“sname”)+<br>                                “   “+rs.getDouble(“sprice”)+”   “+rs.getString(“sdesc”));<br>                    }</p>
<pre><code>        rs.close();
        stat.close();
        con.close();
    }
}</code></pre><p>​<br>###11SQL注入攻击<br>    * A: SQL注入攻击<br>        * a: 注入问题<br>            * 假设有登录案例SQL语句如下:<br>            * SELECT * FROM 用户表 WHERE NAME = 用户输入的用户名 AND PASSWORD = 用户输的密码;<br>            * 此时，当用户输入正确的账号与密码后，查询到了信息则让用户登录。<br>                但是当用户输入的账号为XXX 密码为：XXX’  OR ‘a’=’a时，则真正执行的代码变为：<br>                * SELECT * FROM 用户表 WHERE NAME = ‘XXX’ AND PASSWORD =’ XXX’  OR ’a’=’a’;<br>            * 此时，上述查询语句时永远可以查询出结果的。那么用户就直接登录成功了，显然我们不希望看到这样的结果，这便是SQL注入问题。<br>        * b: 案例演示<br>            CREATE TABLE users(<br>                 id INT PRIMARY KEY AUTO_INCREMENT,<br>                 username VARCHAR(100),<br>                 PASSWORD VARCHAR(100)<br>            );</p>
<pre><code>INSERT INTO users (username,PASSWORD) VALUES (&apos;a&apos;,&apos;1&apos;),(&apos;b&apos;,&apos;2&apos;);

SELECT * FROM users;

-- 登录查询
SELECT * FROM users WHERE username=&apos;dsfsdfd&apos; AND PASSWORD=&apos;wrethiyu&apos;1 
OR 1=1

SELECT * FROM users WHERE username=&apos;a&apos; AND PASSWORD=&apos;1&apos;OR&apos;1=1&apos;
键盘录入：
1
1&apos;OR&apos; 1=1</code></pre><p>​<br>###12SQL注入攻击用户登录案例<br>    * A: SQL注入攻击用户登录案例<br>        * a: 案例代码<br>            public class JDBCDemo2 {<br>                public static void main(String[] args)throws Exception {<br>                    Class.forName(“com.mysql.jdbc.Driver”);<br>                    String url = “jdbc:mysql://localhost:3296/mybase”;<br>                    String username = “root”;<br>                    String password = “123”;<br>                    Connection con = DriverManager.getConnection(url, username, password);<br>                    Statement stat = con.createStatement();</p>
<pre><code>        Scanner sc = new Scanner(System.in);
        String user = sc.nextLine();
        String pass = sc.nextLine();

        //执行SQL语句,数据表,查询用户名和密码,如果存在,登录成功,不存在登录失败
//        String sql = &quot;SELECT * FROM users WHERE username=&apos;dsfsdfd&apos; AND PASSWORD=&apos;wrethiyu&apos; OR 1=1&quot;;
        String sql = &quot;SELECT * FROM users WHERE username=&apos;&quot;+user+&quot;&apos; AND PASSWORD=&apos;&quot;+pass+&quot;&apos;&quot;;
        System.out.println(sql);
        ResultSet rs = stat.executeQuery(sql);
        while(rs.next()){
            System.out.println(rs.getString(&quot;username&quot;)+&quot;   &quot;+rs.getString(&quot;password&quot;));
        }

        rs.close();
        stat.close();
        con.close();
    }
}</code></pre><p>​<br>###13PrepareStatement接口预编译SQL语句<br>    * A: PrepareStatement接口预编译SQL语句<br>        * a: 预处理对象<br>            * 使用PreparedStatement预处理对象时，建议每条sql语句所有的实际参数，都使用逗号分隔。<br>            * String sql = “insert into sort(sid,sname) values(?,?)”;;<br>            * PreparedStatement预处理对象代码：<br>            * PreparedStatement psmt = conn.prepareStatement(sql)</p>
<pre><code>* b: 执行SQL语句的方法介绍
    * int executeUpdate(); --执行insert update delete语句.
    * ResultSet executeQuery(); --执行select语句.
    * boolean execute(); --执行select返回true 执行其他的语句返回false.
* c: 设置实际参数
    * void setXxx(int index, Xxx xx) 将指定参数设置为给定Java的xx值。在将此值发送到数据库时，驱动程序将它转换成一个 SQL Xxx类型值。
    * 例如：
        * setString(2, &quot;家用电器&quot;) 把SQL语句中第2个位置的占位符？ 替换成实际参数 &quot;家用电器&quot;
* d: 案例代码
    /*
     *  Java程序实现用户登录,用户名和密码,数据库检查
     *  防止注入攻击
     *  Statement接口实现类,作用执行SQL语句,返回结果集
     *  有一个子接口PreparedStatement  (SQL预编译存储,多次高效的执行SQL) 
     *  PreparedStatement的实现类数据库的驱动中,如何获取接口的实现类
     *  
     *  是Connection数据库连接对象的方法
     *  PreparedStatement prepareStatement(String sql) 

     */
    public class JDBCDemo3 {
        public static void main(String[] args)throws Exception {
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            String url = &quot;jdbc:mysql://localhost:3296/mybase&quot;;
            String username = &quot;root&quot;;
            String password = &quot;123&quot;;
            Connection con = DriverManager.getConnection(url, username, password);
            Scanner sc = new Scanner(System.in);
            String user = sc.nextLine();
            String pass = sc.nextLine();

            //执行SQL语句,数据表,查询用户名和密码,如果存在,登录成功,不存在登录失败
            String sql = &quot;SELECT * FROM users WHERE username=? AND PASSWORD=?&quot;;
            //调用Connection接口的方法prepareStatement,获取PrepareStatement接口的实现类
            //方法中参数,SQL语句中的参数全部采用问号占位符
            PreparedStatement pst =  con.prepareStatement(sql);
            System.out.println(pst);
            //调用pst对象set方法,设置问号占位符上的参数
            pst.setObject(1, user);
            pst.setObject(2, pass);

            //调用方法,执行SQL,获取结果集
            ResultSet rs = pst.executeQuery();
            while(rs.next()){
                System.out.println(rs.getString(&quot;username&quot;)+&quot;   &quot;+rs.getString(&quot;password&quot;));
            }

            rs.close();
            pst.close();
            con.close();
        }
    }</code></pre><p>​<br>###14PrepareStatement接口预编译SQL语句执行修改<br>    * A: PrepareStatement接口预编译SQL语句执行修改<br>        * 案例代码<br>            /*<br>             *  使用PrepareStatement接口,实现数据表的更新操作<br>             */<br>            public class JDBCDemo {<br>                public static void main(String[] args) throws Exception{<br>                    Class.forName(“com.mysql.jdbc.Driver”);<br>                    String url = “jdbc:mysql://localhost:3296/mybase”;<br>                    String username=”root”;<br>                    String password=”123”;<br>                    Connection con = DriverManager.getConnection(url, username, password);    </p>
<pre><code>        //拼写修改的SQL语句,参数采用?占位
        String sql = &quot;UPDATE sort SET sname=?,sprice=? WHERE sid=?&quot;;
        //调用数据库连接对象con的方法prepareStatement获取SQL语句的预编译对象
        PreparedStatement pst = con.prepareStatement(sql);
        //调用pst的方法setXXX设置?占位
        pst.setObject(1, &quot;汽车美容&quot;);
        pst.setObject(2, 49988);
        pst.setObject(3, 7);
        //调用pst方法执行SQL语句
        pst.executeUpdate();

        pst.close();
        con.close();
    }
}</code></pre><p>​<br>###15PrepareStatement接口预编译SQL语句执行查询<br>    * A: PrepareStatement接口预编译SQL语句执行查询<br>        * a: 案例代码<br>            /*<br>             *  PrepareStatement接口实现数据表的查询操作<br>             */<br>            public class JDBCDemo1 {<br>                public static void main(String[] args) throws Exception{<br>                    Class.forName(“com.mysql.jdbc.Driver”);<br>                    String url = “jdbc:mysql://localhost:3296/mybase”;<br>                    String username=”root”;<br>                    String password=”123”;<br>                    Connection con = DriverManager.getConnection(url, username, password);    </p>
<pre><code>        String sql = &quot;SELECT * FROM sort&quot;;

        PreparedStatement pst = con.prepareStatement(sql);

        //调用pst对象的方法,执行查询语句,Select
        ResultSet rs=pst.executeQuery();
        while(rs.next()){
            System.out.println(rs.getString(&quot;sid&quot;)+&quot;  &quot;+rs.getString(&quot;sname&quot;)+&quot;  &quot;+rs.getString(&quot;sprice&quot;)+&quot;  &quot;+rs.getString(&quot;sdesc&quot;));
        }
        rs.close();
        pst.close();
        con.close();
    }
}</code></pre><p>​<br>###16JDBC的工具类和测试<br>    * A: JDBC的工具类和测试<br>        * a: 案例代码<br>            //JDBCUtils工具类代码<br>            public class JDBCUtils {<br>                private JDBCUtils(){}<br>                private static Connection con ;</p>
<pre><code>static{
    try{
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        String url = &quot;jdbc:mysql://localhost:3296/mybase&quot;;
        String username=&quot;root&quot;;
        String password=&quot;123&quot;;
        con = DriverManager.getConnection(url, username, password);
    }catch(Exception ex){
        throw new RuntimeException(ex+&quot;数据库连接失败&quot;);
    }
}

/*
 * 定义静态方法,返回数据库的连接对象
 */
public static Connection getConnection(){
    return con;
}</code></pre><p>​<br>                public static void close(Connection con,Statement stat){</p>
<pre><code>     if(stat!=null){
         try{
             stat.close();
         }catch(SQLException ex){}
     }

     if(con!=null){
         try{
             con.close();
         }catch(SQLException ex){}
     }

}</code></pre><p>​<br>                public static void close(Connection con,Statement stat , ResultSet rs){<br>                     if(rs!=null){<br>                         try{<br>                             rs.close();<br>                         }catch(SQLException ex){}<br>                     }</p>
<pre><code>             if(stat!=null){
                 try{
                     stat.close();
                 }catch(SQLException ex){}
             }

             if(con!=null){
                 try{
                     con.close();
                 }catch(SQLException ex){}
             }

        }
    }
//测试JDBCUtils工具类的代码
public class TestJDBCUtils {
    public static void main(String[] args)throws Exception {
        Connection con = JDBCUtils.getConnection();
        PreparedStatement pst = con.prepareStatement(&quot;SELECT sname FROM sort&quot;);
        ResultSet rs = pst.executeQuery();
        while(rs.next()){
            System.out.println(rs.getString(&quot;sname&quot;));
        }
        JDBCUtils.close(con, pst, rs);
    }
}</code></pre><p>###17数据表数据存储对象<br>    * A: 数据表数据存储对象<br>        * a: 准备工作<br>            * 导入jar包<br>            * 拷贝day32定义的工具类JDBCUtils</p>
<pre><code>* b: 案例代码
    //定义实体类Sort
    public class Sort {
        private int sid;
        private String sname;
        private double sprice;
        private String sdesc;
        public Sort(int sid, String sname, double sprice, String sdesc) {
            this.sid = sid;
            this.sname = sname;
            this.sprice = sprice;
            this.sdesc = sdesc;
        }
        public Sort(){}
        public int getSid() {
            return sid;
        }
        public void setSid(int sid) {
            this.sid = sid;
        }
        public String getSname() {
            return sname;
        }
        public void setSname(String sname) {
            this.sname = sname;
        }
        public double getSprice() {
            return sprice;
        }
        public void setSprice(double sprice) {
            this.sprice = sprice;
        }
        public String getSdesc() {
            return sdesc;
        }
        public void setSdesc(String sdesc) {
            this.sdesc = sdesc;
        }
        @Override
        public String toString() {
            return &quot;Sort [sid=&quot; + sid + &quot;, sname=&quot; + sname + &quot;, sprice=&quot; + sprice + &quot;, sdesc=&quot; + sdesc + &quot;]&quot;;
        }                
    }

    /*
     *  JDBC读取数据表sort,每行数据封装到Sort类的对象中
     *  很多个Sort类对象,存储到List集合中
     */
    public class JDBCDemo {
        public static void main(String[] args) throws Exception{
            //使用JDBC工具类,直接获取数据库连接对象
            Connection con = JDBCUtils.getConnection();
            //连接获取数据库SQL语句执行者对象
            PreparedStatement pst = con.prepareStatement(&quot;SELECT * FROM sort&quot;);
            //调用查询方法,获取结果集
            ResultSet rs = pst.executeQuery();
            //创建集合对象
            List&lt;Sort&gt; list = new ArrayList&lt;Sort&gt;();
            while(rs.next()){
                //获取到每个列数据,封装到Sort对象中
                Sort s = new Sort(rs.getInt(&quot;sid&quot;),rs.getString(&quot;sname&quot;),rs.getDouble(&quot;sprice&quot;),rs.getString(&quot;sdesc&quot;));
                //封装的Sort对象,存储到集合中
                list.add(s);
            }
            JDBCUtils.close(con, pst, rs);
            //遍历List集合
            for(Sort s : list){
                System.out.println(s);
            }
        }
    }</code></pre><p>​            </p>
<p>​<br>​<br>###18properties配置文件<br>    * A: properties配置文件<br>        * a: 相关介绍<br>            * 开发中获得连接的4个参数（驱动、URL、用户名、密码）通常都存在配置文件中，方便后期维护，程序如果需要更换数据库，<br>                只需要修改配置文件即可。<br>            * 通常情况下，我们习惯使用properties文件，此文件我们将做如下要求：<br>                1.    文件位置：任意，建议src下<br>                2.    文件名称：任意，扩展名为properties<br>                3.    文件内容：一行一组数据，格式是“key=value”.<br>                    a)    key命名自定义，如果是多个单词，习惯使用点分隔。例如：jdbc.driver<br>                    b)    value值不支持中文，如果需要使用非英文字符，将进行unicode转换。</p>
<p>###19properties文件的创建和编写<br>    * A: properties文件的创建和编写<br>        * a: properties文件的创建<br>            * src路径下建立database.properties(其实就是一个文本文件)<br>        * b: properties文件的编写(内容如下)<br>            driverClass=com.mysql.jdbc.Driver<br>            url=jdbc:mysql://localhost:3296/mybase<br>            username=root<br>            password=123        </p>
<p>###20加载配置文件<br>    * A: 加载配置文件<br>        * a: 案例代码<br>            /*<br>             *  加载properties配置文件<br>             *  IO读取文件,键值对存储到集合<br>             *  从集合中以键值对方式获取数据库的连接信息,完成数据库的连接<br>             */<br>            public class PropertiesDemo {<br>                public static void main(String[] args) throws Exception{<br>                    FileInputStream fis = new FileInputStream(“database.properties”);<br>                    System.out.println(fis);<br>                    //使用类的加载器<br>                    InputStream in = PropertiesDemo.class.getClassLoader().getResourceAsStream(“database.properties”);<br>                    System.out.println(in);<br>                    Properties pro = new Properties();<br>                    pro.load(in);<br>                    System.out.println(in);<br>                }<br>            }</p>
<p>###21通过配置文件连接数据库<br>    * A: 通过配置文件连接数据库<br>        * a: 案例代码<br>            /*<br>             *  加载properties配置文件<br>             *  IO读取文件,键值对存储到集合<br>             *  从集合中以键值对方式获取数据库的连接信息,完成数据库的连接<br>             */<br>            public class PropertiesDemo {<br>                public static void main(String[] args) throws Exception{<br>                    FileInputStream fis = new FileInputStream(“database.properties”);<br>                    System.out.println(fis);<br>                    //使用类的加载器<br>                    InputStream in = PropertiesDemo.class.getClassLoader().getResourceAsStream(“database.properties”);<br>                    System.out.println(in);<br>                    Properties pro = new Properties();<br>                    pro.load(in);<br>                    //获取集合中的键值对<br>                    String driverClass=pro.getProperty(“driverClass”);<br>                    String url = pro.getProperty(“url”);<br>                    String username = pro.getProperty(“username”);<br>                    String password = pro.getProperty(“password”);<br>                    Class.forName(driverClass);<br>                    Connection con = DriverManager.getConnection(url, username, password);<br>                    System.out.println(con);</p>
<pre><code>    }
}</code></pre><p>​<br>###22读取配置文件的工具类<br>    * A: 读取配置文件的工具类<br>        * a: 案例代码<br>            /*<br>             *  编写数据库连接的工具类,JDBC工具类<br>             *  获取连接对象采用读取配置文件方式<br>             *  读取文件获取连接,执行一次,static{}<br>             */<br>            public class JDBCUtilsConfig {<br>                private static Connection con ;<br>                private static String driverClass;<br>                private static String url;<br>                private static String username;<br>                private static String password;</p>
<pre><code>static{
    try{
        readConfig();
        Class.forName(driverClass);
        con = DriverManager.getConnection(url, username, password);
    }catch(Exception ex){
        throw new RuntimeException(&quot;数据库连接失败&quot;);
    }
}

private static void readConfig()throws Exception{
    InputStream in = JDBCUtilsConfig.class.getClassLoader().getResourceAsStream(&quot;database.properties&quot;);
     Properties pro = new Properties();
     pro.load(in);
     driverClass=pro.getProperty(&quot;driverClass&quot;);
     url = pro.getProperty(&quot;url&quot;);
     username = pro.getProperty(&quot;username&quot;);
     password = pro.getProperty(&quot;password&quot;);
}</code></pre><p>​<br>                public static Connection getConnection(){<br>                    return con;<br>                }</p>
<pre><code>}            </code></pre><p>###23测试工具类<br>    * A: 测试工具类<br>        * a: 案例代码<br>            public class TestJDBCUtils {<br>                public static void main(String[] args) {<br>                    Connection con = JDBCUtilsConfig.getConnection();<br>                    System.out.println(con);<br>                }<br>            }</p>
<p>###24总结<br>    * 把今天的知识点总结一遍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day28%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day28%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记28</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:13:46" itemprop="dateModified" datetime="2020-12-23T23:13:46+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、网络三要素及传输协议<br>2、实现UDP协议的发送端和接收端<br>3、实现TCP协议的客户端和服务器<br>4、TCP上传文件案例</p>
<p>=======================第一节课开始=============================================</p>
<p>###01网络模型<br>  *A:网络模型<br>     TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能，接下来针对这四层进行详细地讲解。<br>       链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>       网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>       传输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>       应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</p>
<p>###02IP地址<br> *A:IP地址<br>      在TCP/IP协议中，这个标识号就是IP地址，它可以唯一标识一台计算机，<br>      目前，IP地址广泛使用的版本是IPv4，它是由4个字节大小的二进制数来表示，如：00001010000000000000000000000001。<br>      由于二进制形式表示的IP地址非常不便记忆和处理，因此通常会将IP地址写成十进制的形式，<br>      每个字节用一个十进制数字(0-255)表示，数字间用符号“.”分开，如 “192.168.1.100”<br>      127.0.0.1 为本地主机地址(本地回环地址)<br>###03端口号<br> *A:端口号<br>    通过IP地址可以连接到指定计算机，但如果想访问目标计算机中的某个应用程序，还需要指定端口号。<br>    在计算机中，不同的应用程序是通过端口号区分的。<br>    端口号是用两个字节（16位的二进制数）表示的，它的取值范围是0<del>65535，<br>    其中，0</del>1023之间的端口号用于一些知名的网络服务和应用，用户的普通应用程序需要使用1024以上的端口号，从而避免端口号被另外一个应用或服务所占用</p>
<p>###04InetAddress类<br>  <em>A:InetAddress类<br>     /</em><br>      *  表示互联网中的IP地址<br>      *    java.net.InetAddress<br>      *  静态方法<br>      *    static InetAddress  getLocalHost()   LocalHost本地主机<br>      *    返回本地主机,返回值InetAddress对象<br>      *<br>      *    static InetAddress getByName(String hostName)传递主机名,获取IP地址对象<br>      *<br>      *  非静态方法<br>      *     String getHoustAddress()获取主机IP地址<br>      *     String getHoustName()获取主机名<br>      *<br>      <em>/<br>     public class InetAddressDemo {<br>      public static void main(String[] args)throws UnknownHostException {<br>        function_1();<br>      }<br>      /</em><br>       * static InetAddress getByName(String hostName)传递主机名,获取IP地址对象<br>       */<br>      public static void function_1()throws UnknownHostException {<br>        InetAddress inet = InetAddress.getByName(“<a href="http://www.baidu.com&quot;" target="_blank" rel="noopener">www.baidu.com&quot;</a>);<br>        System.out.println(inet);<br>      }</p>
<pre><code> /*
  *  static InetAddress  getLocalHost()   LocalHost本地主机
  */
 public static void function() throws UnknownHostException{
   InetAddress inet = InetAddress.getLocalHost();
   //输出结果就是主机名,和 IP地址
   System.out.println(inet.toString());

   String ip = inet.getHostAddress();
   String name = inet.getHostName();
   System.out.println(ip+&quot;   &quot;+name);

   /*String host = inet.toString();
   String[] str = host.split(&quot;/&quot;);
   for(String s : str){
     System.out.println(s);
   }*/
 }
}</code></pre><p>###05UDP协议<br>   A:UDP协议<br>     a:UDP协议概述:<br>      UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。<br>      简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。<br>     b:UDP协议特点:<br>      由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，<br>      因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p>
<p>###06TCP协议<br>  *A:TCP协议<br>    TCP协议是面向连接的通信协议，即在传输数据前先在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。<br>    在TCP连接中必须要明确客户端与服务器端，<br>      由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。<br>      第一次握手，客户端向服务器端发出连接请求，等待服务器确认<br>      第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求<br>      第三次握手，客户端再次向服务器端发送确认信息，确认连接</p>
<p>========================================第二节课=========================================<br>###07数据包和发送对象介绍<br>  *A:数据包和发送对象介绍:<br>    DatagramPacket数据包的作用就如同是“集装箱”，<br>       可以将发送端或者接收端的数据封装起来。然而运输货物只有“集装箱”是不够的，还需要有码头。<br>       在程序中需要实现通信只有DatagramPacket数据包也同样不行，为此JDK中提供的一个DatagramSocket类。<br>       DatagramSocket类的作用就类似于码头，使用这个类的实例对象就可以发送和接收DatagramPacket数据包<br>    DatagramPacket:封装数据<br>    DatagramSocket:发送DatagramPacket</p>
<p>###08UDP发送端<br>   <em>A:UDP发送端<br>         /</em><br>        *  实现UDP协议的发送端:<br>        *    实现封装数据的类 java.net.DatagramPacket  将你的数据包装<br>        *    实现数据传输的类 java.net.DatagramSocket  将数据包发出去<br>        *<br>        *  实现步骤:<br>        *    1. 创建DatagramPacket对象,封装数据, 接收的地址和端口<br>        *    2. 创建DatagramSocket<br>        *    3. 调用DatagramSocket类方法send,发送数据包<br>        *    4. 关闭资源<br>        *<br>        *    DatagramPacket构造方法:<br>        *      DatagramPacket(byte[] buf, int length, InetAddress address, int port)<br>        *<br>        *    DatagramSocket构造方法:<br>        *      DatagramSocket()空参数<br>        *      方法: send(DatagramPacket d)<br>        *<br>        */<br>       public class UDPSend {<br>        public static void main(String[] args) throws IOException{<br>          //创建数据包对象,封装要发送的数据,接收端IP,端口<br>          byte[] date = “你好UDP”.getBytes();<br>          //创建InetAddress对象,封装自己的IP地址<br>          InetAddress inet = InetAddress.getByName(“127.0.0.1”);<br>          DatagramPacket dp = new DatagramPacket(date, date.length, inet,6000);<br>          //创建DatagramSocket对象,数据包的发送和接收对象<br>          DatagramSocket ds = new DatagramSocket();<br>          //调用ds对象的方法send,发送数据包<br>          ds.send(dp);<br>          //关闭资源<br>          ds.close();<br>        }<br>       }</p>
<p>###09UDP接收端<br>   <em>A:UDP接收端<br>       /</em><br>        *  实现UDP接收端<br>        *    实现封装数据包 java.net.DatagramPacket 将数据接收<br>        *    实现输出传输     java.net.DatagramSocket 接收数据包<br>        *<br>        *  实现步骤:<br>        *     1. 创建DatagramSocket对象,绑定端口号<br>        *         要和发送端端口号一致<br>        *     2. 创建字节数组,接收发来的数据<br>        *     3. 创建数据包对象DatagramPacket<br>        *     4. 调用DatagramSocket对象方法<br>        *        receive(DatagramPacket dp)接收数据,数据放在数据包中<br>        *     5. 拆包<br>        *          发送的IP地址<br>        *            数据包对象DatagramPacket方法getAddress()获取的是发送端的IP地址对象<br>        *            返回值是InetAddress对象<br>        *          接收到的字节个数<br>        *            数据包对象DatagramPacket方法 getLength()<br>        *          发送方的端口号<br>        *            数据包对象DatagramPacket方法 getPort()发送端口<br>        *     6. 关闭资源<br>        */<br>       public class UDPReceive {<br>        public static void main(String[] args)throws IOException {<br>          //创建数据包传输对象DatagramSocket 绑定端口号<br>          DatagramSocket ds = new DatagramSocket(6000);<br>          //创建字节数组<br>          byte[] data = new byte[1024];<br>          //创建数据包对象,传递字节数组<br>          DatagramPacket dp = new DatagramPacket(data, data.length);<br>          //调用ds对象的方法receive传递数据包<br>          ds.receive(dp);</p>
<pre><code> }
}</code></pre><p>###10UDP接收端的拆包<br>   *A:UDP接收端的拆包 </p>
<pre><code>/*
 *  实现UDP接收端
 *    实现封装数据包 java.net.DatagramPacket 将数据接收
 *    实现输出传输     java.net.DatagramSocket 接收数据包
 *    
 *  实现步骤:
 *     1. 创建DatagramSocket对象,绑定端口号
 *         要和发送端端口号一致
 *     2. 创建字节数组,接收发来的数据
 *     3. 创建数据包对象DatagramPacket
 *     4. 调用DatagramSocket对象方法
 *        receive(DatagramPacket dp)接收数据,数据放在数据包中
 *     5. 拆包
 *          发送的IP地址
 *            数据包对象DatagramPacket方法getAddress()获取的是发送端的IP地址对象
 *            返回值是InetAddress对象
 *          接收到的字节个数
 *            数据包对象DatagramPacket方法 getLength()
 *          发送方的端口号
 *            数据包对象DatagramPacket方法 getPort()发送端口
 *     6. 关闭资源
 */
public class UDPReceive {
  public static void main(String[] args)throws IOException {
    //创建数据包传输对象DatagramSocket 绑定端口号
    DatagramSocket ds = new DatagramSocket(6000);
    //创建字节数组
    byte[] data = new byte[1024];
    //创建数据包对象,传递字节数组
    DatagramPacket dp = new DatagramPacket(data, data.length);
    //调用ds对象的方法receive传递数据包
    ds.receive(dp);

    //获取发送端的IP地址对象
    String ip=dp.getAddress().getHostAddress();

    //获取发送的端口号
    int port = dp.getPort();

    //获取接收到的字节个数
    int length = dp.getLength();
    System.out.println(new String(data,0,length)+&quot;...&quot;+ip+&quot;:&quot;+port);
    ds.close();
  }
}</code></pre><p>###11键盘输入的聊天<br>   <em>A:键盘输入的聊天<br>    *a:发送端:<br>      /</em><br>       * 实现UDP发送,键盘输入的形式<br>       * 输入完毕,发送给接收端<br>       <em>/<br>      public class UDPSend {<br>        public static void main(String[] args) throws IOException{<br>          Scanner sc = new Scanner(System.in);<br>          DatagramSocket ds = new DatagramSocket();<br>          InetAddress inet = InetAddress.getByName(“127.0.0.1”);<br>          while(true){<br>          String message = sc.nextLine();<br>          /*if(“886”.equals(message)){<br>            break;<br>          }</em>/<br>          byte[] date = message.getBytes();<br>          DatagramPacket dp = new DatagramPacket(date, date.length, inet,6000);<br>          ds.send(dp);<br>          }<br>        //  ds.close();<br>        }<br>      }</p>
<pre><code>/*
 *  实现UDP接收端
 *  永不停歇的接收端
 */
public class UDPReceive {
 public static void main(String[] args)throws IOException {
   //创建数据包传输对象DatagramSocket 绑定端口号
   DatagramSocket ds = new DatagramSocket(6000);
   //创建字节数组
   byte[] data = new byte[1024];
   //创建数据包对象,传递字节数组
   while(true){
   DatagramPacket dp = new DatagramPacket(data, data.length);
   //调用ds对象的方法receive传递数据包
   ds.receive(dp);

   //获取发送端的IP地址对象
   String ip=dp.getAddress().getHostAddress();

   //获取发送的端口号
   int port = dp.getPort();

   //获取接收到的字节个数
   int length = dp.getLength();
   System.out.println(new String(data,0,length)+&quot;...&quot;+ip+&quot;:&quot;+port);
   }
   //ds.close();
 }
}</code></pre><p>=======================第三节课======================================<br>###12TCP的客户端和服务器<br>   *A:TCP的客户端和服务器<br>      TCP通信同UDP通信一样，都能实现两台计算机之间的通信，通信的两端都需要创建socket对象。<br>      区别在于，UDP中只有发送端和接收端，不区分客户端与服务器端，计算机之间可以任意地发送数据。<br>      而TCP通信是严格区分客户端与服务器端的，在通信时，必须先由客户端去连接服务器端才能实现通信，<br>      服务器端不可以主动连接客户端，并且服务器端程序需要事先启动，等待客户端的连接。<br>      在JDK中提供了两个类用于实现TCP程序，一个是ServerSocket类，用于表示服务器端，一个是Socket类，用于表示客户端。<br>      通信时，首先创建代表服务器端的ServerSocket对象，该对象相当于开启一个服务，并等待客户端的连接，然后创建代表客户端的Socket对象向服务器端发出连接请求，服务器端响应请求，两者建立连接开始通信。</p>
<p>###13TCP的客户端程序<br>  <em>A:TCP的客户端程序<br>   /</em><br>    *  实现TCP客户端,连接到服务器<br>    *  和服务器实现数据交换<br>    *  实现TCP客户端程序的类 java.net.Socket<br>    *<br>    *  构造方法:<br>    *      Socket(String host, int port)  传递服务器IP和端口号<br>    *      注意:构造方法只要运行,就会和服务器进行连接,连接失败,抛出异常<br>    *<br>    *    OutputStream  getOutputStream() 返回套接字的输出流<br>    *      作用: 将数据输出,输出到服务器<br>    *<br>    *    InputStream getInputStream() 返回套接字的输入流<br>    *      作用: 从服务器端读取数据<br>    *<br>    *    客户端服务器数据交换,必须使用套接字对象Socket中的获取的IO流,自己new流,不行<br>    */<br>   public class TCPClient {<br>    public static void main(String[] args)throws IOException {<br>      //创建Socket对象,连接服务器<br>      Socket socket = new Socket(“127.0.0.1”, 8888);<br>      //通过客户端的套接字对象Socket方法,获取字节输出流,将数据写向服务器<br>      OutputStream out = socket.getOutputStream();<br>      out.write(“服务器OK”.getBytes());</p>
<pre><code>  socket.close();
}</code></pre><p>   }</p>
<p>###14TCP的服务器程序accept方法<br>   A:TCP的服务器程序accept方法<br>     /*<br>      *  实现TCP服务器程序<br>      *  表示服务器程序的类 java.net.ServerSocket<br>      *  构造方法:<br>      *    ServerSocket(int port) 传递端口号<br>      *<br>      *  很重要的事情: 必须要获得客户端的套接字对象Socket<br>      *    Socket  accept()<br>      */<br>     public class TCPServer {<br>      public static void main(String[] args) throws IOException{<br>        ServerSocket server = new ServerSocket(8888);<br>        //调用服务器套接字对象中的方法accept() 获取客户端套接字对象<br>        Socket socket = server.accept();<br>        //通过客户端套接字对象,socket获取字节输入流,读取的是客户端发送来的数据<br>        InputStream in = socket.getInputStream();<br>        byte[] data = new byte[1024];<br>        int len = in.read(data);<br>        System.out.println(new String(data,0,len));</p>
<pre><code>   socket.close();
   server.close();
 }
}</code></pre><p>###15TCP的服务器程序读取客户端数据<br>   A:TCP的服务器程序读取客户端数据</p>
<pre><code>/*
 *  实现TCP客户端,连接到服务器
 *  和服务器实现数据交换
 *  实现TCP客户端程序的类 java.net.Socket
 *  
 *  构造方法:
 *      Socket(String host, int port)  传递服务器IP和端口号
 *      注意:构造方法只要运行,就会和服务器进行连接,连接失败,抛出异常
 *      
 *    OutputStream  getOutputStream() 返回套接字的输出流
 *      作用: 将数据输出,输出到服务器
 *      
 *    InputStream getInputStream() 返回套接字的输入流
 *      作用: 从服务器端读取数据
 *      
 *    客户端服务器数据交换,必须使用套接字对象Socket中的获取的IO流,自己new流,不行
 */
public class TCPClient {
  public static void main(String[] args)throws IOException {
    //创建Socket对象,连接服务器
    Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888);
    //通过客户端的套接字对象Socket方法,获取字节输出流,将数据写向服务器
    OutputStream out = socket.getOutputStream();
    out.write(&quot;服务器OK&quot;.getBytes());
    socket.close();
  }
}
/*
 *  实现TCP服务器程序
 *  表示服务器程序的类 java.net.ServerSocket
 *  构造方法:
 *    ServerSocket(int port) 传递端口号
 *  
 *  很重要的事情: 必须要获得客户端的套接字对象Socket
 *    Socket  accept()
 */
public class TCPServer {
  public static void main(String[] args) throws IOException{
    ServerSocket server = new ServerSocket(8888);
    //调用服务器套接字对象中的方法accept() 获取客户端套接字对象
    Socket socket = server.accept();
    //通过客户端套接字对象,socket获取字节输入流,读取的是客户端发送来的数据
    InputStream in = socket.getInputStream();
    byte[] data = new byte[1024];
    int len = in.read(data);
    System.out.println(new String(data,0,len));

  }
}</code></pre><p>###16TCP的服务器和客户端的数据交换<br>   A:TCP的服务器和客户端的数据交换<br>      /*<br>       *  实现TCP客户端,连接到服务器<br>       *  和服务器实现数据交换<br>       *  实现TCP客户端程序的类 java.net.Socket<br>       *<br>       *  构造方法:<br>       *      Socket(String host, int port)  传递服务器IP和端口号<br>       *      注意:构造方法只要运行,就会和服务器进行连接,连接失败,抛出异常<br>       *<br>       *    OutputStream  getOutputStream() 返回套接字的输出流<br>       *      作用: 将数据输出,输出到服务器<br>       *<br>       *    InputStream getInputStream() 返回套接字的输入流<br>       *      作用: 从服务器端读取数据<br>       *<br>       *    客户端服务器数据交换,必须使用套接字对象Socket中的获取的IO流,自己new流,不行<br>       */<br>      public class TCPClient {<br>        public static void main(String[] args)throws IOException {<br>          //创建Socket对象,连接服务器<br>          Socket socket = new Socket(“127.0.0.1”, 8888);<br>          //通过客户端的套接字对象Socket方法,获取字节输出流,将数据写向服务器<br>          OutputStream out = socket.getOutputStream();<br>          out.write(“服务器OK”.getBytes());</p>
<pre><code>    //读取服务器发回的数据,使用socket套接字对象中的字节输入流
    InputStream in = socket.getInputStream();
    byte[] data = new byte[1024];
    int len = in.read(data);
    System.out.println(new String(data,0,len));

    socket.close();
  }
}
/*
 *  实现TCP服务器程序
 *  表示服务器程序的类 java.net.ServerSocket
 *  构造方法:
 *    ServerSocket(int port) 传递端口号
 *  
 *  很重要的事情: 必须要获得客户端的套接字对象Socket
 *    Socket  accept()
 */
public class TCPServer {
  public static void main(String[] args) throws IOException{
    ServerSocket server = new ServerSocket(8888);
    //调用服务器套接字对象中的方法accept() 获取客户端套接字对象
    Socket socket = server.accept();
    //通过客户端套接字对象,socket获取字节输入流,读取的是客户端发送来的数据
    InputStream in = socket.getInputStream();
    byte[] data = new byte[1024];
    int len = in.read(data);
    System.out.println(new String(data,0,len));

    //服务器向客户端回数据,字节输出流,通过客户端套接字对象获取字节输出流
    OutputStream out = socket.getOutputStream();
    out.write(&quot;收到,谢谢&quot;.getBytes());

    socket.close();
    server.close();
  }
}</code></pre><p>###17TCP的中的流对象<br>    *A:TCP的中的流对象<br>        参见图解TCP中的流对象.jpg  </p>
<p>======================================第四节课=================================================<br>###18TCP图片上传案例分析<br>    *A:图片上传案例分析<br>         参见图解TCP上传图片案例.jpg  </p>
<p>###19TCP上传客户端<br>   <em>A TCP上传客户端<br>   /</em><br>    *  实现TCP图片上传客户端<br>    *  实现步骤:<br>    *    1. Socket套接字连接服务器<br>    *    2. 通过Socket获取字节输出流,写图片<br>    *    3. 使用自己的流对象,读取图片数据源<br>    *         FileInputStream<br>    *    4. 读取图片,使用字节输出流,将图片写到服务器<br>    *       采用字节数组进行缓冲<br>    *    5. 通过Socket套接字获取字节输入流<br>    *       读取服务器发回来的上传成功<br>    *    6. 关闭资源<br>    */<br>   public class TCPClient {<br>    public static void main(String[] args) throws IOException{<br>      Socket socket = new Socket(“127.0.0.1”, 8000);<br>      //获取字节输出流,图片写到服务器<br>      OutputStream out = socket.getOutputStream();<br>      //创建字节输入流,读取本机上的数据源图片<br>      FileInputStream fis = new FileInputStream(“c:\t.jpg”);<br>      //开始读写字节数组<br>      int len = 0 ;<br>      byte[] bytes = new byte[1024];<br>      while((len = fis.read(bytes))!=-1){<br>        out.write(bytes, 0, len);<br>      }<br>      //给服务器写终止序列<br>      //socket.shutdownOutput();</p>
<pre><code>  //获取字节输入流,读取服务器的上传成功
  InputStream in = socket.getInputStream();

  len = in.read(bytes);
  System.out.println(new String(bytes,0,len));

  fis.close();
  socket.close();
}</code></pre><p>   }<br>###20TCP上传服务器<br>   A:TCP上传服务器<br>   /*<br>    *  TCP图片上传服务器<br>    *   1. ServerSocket套接字对象,监听端口8000<br>    *   2. 方法accept()获取客户端的连接对象<br>    *   3. 客户端连接对象获取字节输入流,读取客户端发送图片<br>    *   4. 创建File对象,绑定上传文件夹<br>    *       判断文件夹存在, 不存,在创建文件夹<br>    *   5. 创建字节输出流,数据目的File对象所在文件夹<br>    *   6. 字节流读取图片,字节流将图片写入到目的文件夹中<br>    *   7. 将上传成功会写客户端<br>    *   8. 关闭资源<br>    *<br>    */<br>   public class TCPServer {<br>    public static void main(String[] args) throws IOException{<br>      ServerSocket server = new ServerSocket(8000);<br>      Socket socket = server.accept();<br>      //通过客户端连接对象,获取字节输入流,读取客户端图片<br>      InputStream in = socket.getInputStream();<br>      //将目的文件夹封装到File对象<br>      File upload = new File(“d:\upload”);<br>      if(!upload.exists())<br>        upload.mkdirs();</p>
<pre><code>  //创建字节输出流,将图片写入到目的文件夹中                         
  FileOutputStream fos = new FileOutputStream(upload+&quot;t.jpg&quot;);
  //读写字节数组
  byte[] bytes = new byte[1024];
  int len = 0 ;
  while((len = in.read(bytes))!=-1){
    fos.write(bytes, 0, len);
  }
  //通过客户端连接对象获取字节输出流
  //上传成功写回客户端
  socket.getOutputStream().write(&quot;上传成功&quot;.getBytes());

  fos.close();
  socket.close();
  server.close();
}</code></pre><p>   }<br>###21TCP图片上传问题解决<br>/*</p>
<ul>
<li><p>实现TCP图片上传客户端</p>
</li>
<li><p>实现步骤:</p>
</li>
<li><ol>
<li>Socket套接字连接服务器</li>
</ol>
</li>
<li><ol start="2">
<li>通过Socket获取字节输出流,写图片</li>
</ol>
</li>
<li><ol start="3">
<li>使用自己的流对象,读取图片数据源</li>
</ol>
</li>
<li><p>FileInputStream</p>
</li>
<li><ol start="4">
<li>读取图片,使用字节输出流,将图片写到服务器</li>
</ol>
</li>
<li><p>采用字节数组进行缓冲</p>
</li>
<li><ol start="5">
<li>通过Socket套接字获取字节输入流</li>
</ol>
</li>
<li><p>读取服务器发回来的上传成功</p>
</li>
<li><ol start="6">
<li>关闭资源</li>
</ol>
</li>
<li><p>/<br>public class TCPClient {<br>  public static void main(String[] args) throws IOException{<br>  Socket socket = new Socket(“127.0.0.1”, 8000);<br>  //获取字节输出流,图片写到服务器<br>  OutputStream out = socket.getOutputStream();<br>  //创建字节输入流,读取本机上的数据源图片<br>  FileInputStream fis = new FileInputStream(“c:\t.jpg”);<br>  //开始读写字节数组<br>  int len = 0 ;<br>  byte[] bytes = new byte[1024];<br>  while((len = fis.read(bytes))!=-1){</p>
<pre><code>out.write(bytes, 0, len);</code></pre><p>  }<br>  //给服务器写终止序列<br>  socket.shutdownOutput();//想服务端写入一个结束标志</p>
<p>  //获取字节输入流,读取服务器的上传成功<br>  InputStream in = socket.getInputStream();</p>
<p>  len = in.read(bytes);<br>  System.out.println(new String(bytes,0,len));</p>
<p>  fis.close();<br>  socket.close();<br>  }<br>}</p>
</li>
</ul>
<p>###TCP上传文件名<br>  <em>A:TCP上传文件名<br>   /</em><br>    *  TCP图片上传服务器<br>    *   1. ServerSocket套接字对象,监听端口8000<br>    *   2. 方法accept()获取客户端的连接对象<br>    *   3. 客户端连接对象获取字节输入流,读取客户端发送图片<br>    *   4. 创建File对象,绑定上传文件夹<br>    *       判断文件夹存在, 不存,在创建文件夹<br>    *   5. 创建字节输出流,数据目的File对象所在文件夹<br>    *   6. 字节流读取图片,字节流将图片写入到目的文件夹中<br>    *   7. 将上传成功会写客户端<br>    *   8. 关闭资源<br>    *<br>    */<br>   public class TCPServer {<br>    public static void main(String[] args) throws IOException{<br>      ServerSocket server = new ServerSocket(8000);<br>      Socket socket = server.accept();<br>      //通过客户端连接对象,获取字节输入流,读取客户端图片<br>      InputStream in = socket.getInputStream();<br>      //将目的文件夹封装到File对象<br>      File upload = new File(“d:\upload”);<br>      if(!upload.exists())<br>        upload.mkdirs();</p>
<pre><code>  //防止文件同名被覆盖,从新定义文件名字
  //规则:  域名+毫秒值+6位随机数
  String filename=&quot;itcast&quot;+System.currentTimeMillis()+new Random().nextInt(999999)+&quot;.jpg&quot;;
  //创建字节输出流,将图片写入到目的文件夹中                         
  FileOutputStream fos = new FileOutputStream(upload+File.separator+filename);
  //读写字节数组
  byte[] bytes = new byte[1024];
  int len = 0 ;
  while((len = in.read(bytes))!=-1){
    fos.write(bytes, 0, len);
  }
  //通过客户端连接对象获取字节输出流
  //上传成功写回客户端
  socket.getOutputStream().write(&quot;上传成功&quot;.getBytes());

  fos.close();
  socket.close();
  server.close();
}</code></pre><p>   }</p>
<p>###多线程上传案例<br>*A:多线程上传案例<br>  public class TCPThreadServer {<br>    public static void main(String[] args) throws IOException {<br>      ServerSocket server = new ServerSocket(8000);<br>      while (true) {<br>        // 获取到一个客户端,必须开启新线程,为这个客户端服务<br>        Socket socket = server.accept();<br>        new Thread(new Upload(socket)).start();<br>      }<br>    }<br>  }</p>
<p>  public class Upload implements Runnable {</p>
<pre><code>private Socket socket;

public Upload(Socket socket) {
  this.socket = socket;
}

public void run() {
  try {
    // 通过客户端连接对象,获取字节输入流,读取客户端图片
    InputStream in = socket.getInputStream();
    // 将目的文件夹封装到File对象
    File upload = new File(&quot;d:\\upload&quot;);
    if (!upload.exists())
      upload.mkdirs();

    // 防止文件同名被覆盖,从新定义文件名字
    // 规则: 域名+毫秒值+6位随机数
    String filename = &quot;itcast&quot; + System.currentTimeMillis() + new Random().nextInt(999999) + &quot;.jpg&quot;;
    // 创建字节输出流,将图片写入到目的文件夹中
    FileOutputStream fos = new FileOutputStream(upload + File.separator + filename);
    // 读写字节数组
    byte[] bytes = new byte[1024];
    int len = 0;
    while ((len = in.read(bytes)) != -1) {
      fos.write(bytes, 0, len);
    }
    // 通过客户端连接对象获取字节输出流
    // 上传成功写回客户端
    socket.getOutputStream().write(&quot;上传成功&quot;.getBytes());

    fos.close();
    socket.close();
  } catch (Exception ex) {

  }
}</code></pre><p>  }</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day27%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day27%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记27</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:12:58" itemprop="dateModified" datetime="2020-12-23T23:12:58+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、多线程安全问题<br>2、等待唤醒机制</p>
<p>=======================第一节课开始=============================================</p>
<p>###01线程操作共享数据的安全问题<br>  *A:线程操作共享数据的安全问题<br>    如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。<br>    程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<p>###02售票的案例<br> <em>A:售票的案例<br>     /</em><br>      * 多线程并发访问同一个数据资源<br>      * 3个线程,对一个票资源,出售<br>      */<br>     public class ThreadDemo {<br>      public static void main(String[] args) {<br>        //创建Runnable接口实现类对象<br>        Tickets t = new Tickets();<br>        //创建3个Thread类对象,传递Runnable接口实现类<br>        Thread t0 = new Thread(t);<br>        Thread t1 = new Thread(t);<br>        Thread t2 = new Thread(t);</p>
<pre><code>   t0.start();
   t1.start();
   t2.start();

 }
}

public class Tickets implements Runnable{

 //定义出售的票源
 private int ticket = 100;
 private Object obj = new Object();

 public void run(){
   while(true){

       if( ticket &gt; 0){

         System.out.println(Thread.currentThread().getName()+&quot; 出售第 &quot;+ticket--);
       }

   }
 }
}</code></pre><p>###03线程安全问题引发<br> <em>A:线程安全问题引发<br>    /</em><br>     * 多线程并发访问同一个数据资源<br>     * 3个线程,对一个票资源,出售<br>     */<br>    public class ThreadDemo {<br>     public static void main(String[] args) {<br>       //创建Runnable接口实现类对象<br>       Tickets t = new Tickets();<br>       //创建3个Thread类对象,传递Runnable接口实现类<br>       Thread t0 = new Thread(t);<br>       Thread t1 = new Thread(t);<br>       Thread t2 = new Thread(t);</p>
<pre><code>   t0.start();
   t1.start();
   t2.start();

 }
}
/*
 *  通过线程休眠,出现安全问题
 */
public class Tickets implements Runnable{

 //定义出售的票源
 private int ticket = 100;
 private Object obj = new Object();

 public void run(){
   while(true){

     //对票数判断,大于0,可以出售,变量--操作
       if( ticket &gt; 0){
         try{
            Thread.sleep(10); //加了休眠让其他线程有执行机会
         }catch(Exception ex){}
         System.out.println(Thread.currentThread().getName()+&quot; 出售第 &quot;+ticket--);
       }
   }
 }
}</code></pre><p>###04同步代码块解决线程安全问题<br>  <em>A:同步代码块解决线程安全问题<br>      *A:售票的案例<br>          /</em><br>           * 多线程并发访问同一个数据资源<br>           * 3个线程,对一个票资源,出售<br>           */<br>          public class ThreadDemo {<br>           public static void main(String[] args) {<br>             //创建Runnable接口实现类对象<br>             Tickets t = new Tickets();<br>             //创建3个Thread类对象,传递Runnable接口实现类<br>             Thread t0 = new Thread(t);<br>             Thread t1 = new Thread(t);<br>             Thread t2 = new Thread(t);</p>
<pre><code>   t0.start();
   t1.start();
   t2.start();

 }
}
/*
 *  通过线程休眠,出现安全问题
 *  解决安全问题,Java程序,提供技术,同步技术
 *  公式:
 *    synchronized(任意对象){
 *      线程要操作的共享数据
 *    }
 *    同步代码块
 */
public class Tickets implements Runnable{

 //定义出售的票源
 private int ticket = 100;
 private Object obj = new Object();

 public void run(){
   while(true){
     //线程共享数据,保证安全,加入同步代码块
     synchronized(obj){
     //对票数判断,大于0,可以出售,变量--操作
       if( ticket &gt; 0){
         try{
            Thread.sleep(10);
         }catch(Exception ex){}
         System.out.println(Thread.currentThread().getName()+&quot; 出售第 &quot;+ticket--);
       }
     }
   }
 }
}</code></pre><p>###05同步代码块的执行原理<br>   A:同步代码块的执行原理<br>     同步代码块: 在代码块声明上 加上synchronized<br>     synchronized (锁对象) {<br>       可能会产生线程安全问题的代码<br>     }<br>     同步代码块中的锁对象可以是任意的对象；但多个线程时，要使用同一个锁对象才能够保证线程安全。</p>
<p>=======================第二节课开始=============================================<br>###06同步的上厕所原理<br>  *A:同步的上厕所原理<br>    a:不使用同步:线程在执行的过程中会被打扰<br>       线程比喻成人<br>       线程执行代码就是上一个厕所<br>      第一个人正在上厕所,上到一半,被另外一个人拉出来<br>    b:使用同步:<br>       线程比喻成人<br>       线程执行代码就是上一个厕所<br>       锁比喻成厕所门<br>      第一个人上厕所,会锁门<br>      第二个人上厕所,看到门锁上了,等待第一个人上完再去上厕所</p>
<p>###07同步方法<br>  <em>A:同步方法:<br>  /</em></p>
<ul>
<li><p>多线程并发访问同一个数据资源</p>
</li>
<li><p>3个线程,对一个票资源,出售<br> */<br>public class ThreadDemo {</p>
<p>public static void main(String[] args) {<br> //创建Runnable接口实现类对象<br> Tickets t = new Tickets();<br> //创建3个Thread类对象,传递Runnable接口实现类<br> Thread t0 = new Thread(t);<br> Thread t1 = new Thread(t);<br> Thread t2 = new Thread(t);</p>
<p> t0.start();<br> t1.start();<br> t2.start();</p>
<p>}<br>}</p>
<p><em>A:同步方法<br>/</em></p>
<ul>
<li><p>采用同步方法形式,解决线程的安全问题</p>
</li>
<li><p>好处: 代码简洁</p>
</li>
<li><p>将线程共享数据,和同步,抽取到一个方法中</p>
</li>
<li><p>在方法的声明上,加入同步关键字</p>
</li>
<li></li>
<li><p>问题:</p>
</li>
<li><p>同步方法有锁吗,肯定有,同步方法中的对象锁,是本类对象引用 this</p>
</li>
<li><p>如果方法是静态的呢,同步有锁吗,绝对不是this</p>
</li>
<li><p>锁是本类自己.class 属性</p>
</li>
<li><p>静态方法,同步锁,是本类类名.class属性</p>
</li>
<li><p>/<br>public class Tickets implements Runnable{</p>
<p>//定义出售的票源<br>private  int ticket = 100;</p>
<p>public void run(){<br> while(true){<br>   payTicket();<br> }<br>}</p>
<p>public  synchronized void payTicket(){<br>   if( ticket &gt; 0){</p>
<pre><code>try{
   Thread.sleep(10);
}catch(Exception ex){}
System.out.println(Thread.currentThread().getName()+&quot; 出售第 &quot;+ticket--);</code></pre><p>   }</p>
<p>}<br>}</p>
</li>
</ul>
</li>
</ul>
<p>###08JDK1.5新特性Lock接口<br>   *A:JDK1.5新特性Lock接口<br>        查阅API，查阅Lock接口描述，Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。<br>       Lock接口中的常用方法<br>            void lock()<br>            void unlock()<br>      Lock提供了一个更加面对对象的锁，在该锁中提供了更多的操作锁的功能。<br>      我们使用Lock接口,以及其中的lock()方法和unlock()方法替代同步，对电影院卖票案例中Ticket</p>
<p>###09Lock接口改进售票案例<br>   <em>A:Lock接口改进售票案例<br>      /</em><br>       * 多线程并发访问同一个数据资源<br>       * 3个线程,对一个票资源,出售<br>       */<br>      public class ThreadDemo {<br>        public static void main(String[] args) {<br>          //创建Runnable接口实现类对象<br>          Tickets t = new Tickets();<br>          //创建3个Thread类对象,传递Runnable接口实现类<br>          Thread t0 = new Thread(t);<br>          Thread t1 = new Thread(t);<br>          Thread t2 = new Thread(t);</p>
<pre><code>    t0.start();
    t1.start();
    t2.start();

  }
}
/*
 *  使用JDK1.5 的接口Lock,替换同步代码块,实现线程的安全性
 *  Lock接口方法:
 *     lock() 获取锁
 *     unlock()释放锁
 *  实现类ReentrantLock
 */
public class Tickets implements Runnable{

  //定义出售的票源
  private int ticket = 100;
  //在类的成员位置,创建Lock接口的实现类对象
  private Lock lock = new ReentrantLock();

  public void run(){
    while(true){
      //调用Lock接口方法lock获取锁
        lock.lock();
      //对票数判断,大于0,可以出售,变量--操作
        if( ticket &gt; 0){
          try{
             Thread.sleep(10);
             System.out.println(Thread.currentThread().getName()+&quot; 出售第 &quot;+ticket--);
          }catch(Exception ex){

          }finally{
            //释放锁,调用Lock接口方法unlock
            lock.unlock();
          }
        }
    }
  }
}</code></pre><p>=======================第三节课开始=============================================<br>###10线程的死锁原理<br>   *A:线程的死锁原理<br>     当线程任务中出现了多个同步(多个锁)  时，如果同步中嵌套了其他的同步。这时容易引发一种现象：程序出现无限等待，这种现象我们称为死锁。这种情况能避免就避免掉。<br>        synchronzied(A锁){<br>            synchronized(B锁){</p>
<pre><code>    }
}</code></pre><p>###11线程的死锁代码实现<br>   *A:线程的死锁代码实现<br>       public class DeadLock implements Runnable{<br>        private int i = 0;<br>        public void run(){<br>          while(true){<br>            if(i%2==0){<br>              //先进入A同步,再进入B同步<br>              synchronized(LockA.locka){<br>                System.out.println(“if…locka”);<br>                synchronized(LockB.lockb){<br>                  System.out.println(“if…lockb”);<br>                }<br>              }<br>            }else{<br>              //先进入B同步,再进入A同步<br>              synchronized(LockB.lockb){<br>                System.out.println(“else…lockb”);<br>                synchronized(LockA.locka){<br>                  System.out.println(“else…locka”);<br>                }<br>              }<br>            }<br>            i++;<br>          }<br>        }<br>       }</p>
<pre><code>public class DeadLockDemo {
  public static void main(String[] args) {
    DeadLock dead = new DeadLock();
    Thread t0 = new Thread(dead);
    Thread t1 = new Thread(dead);
    t0.start();
    t1.start();
  }
}


public class LockA {
  private LockA(){}

  public  static final LockA locka = new LockA();
}</code></pre><p>​<br>      public class LockB {<br>        private LockB(){}</p>
<pre><code>  public static final LockB lockb = new LockB();
}</code></pre><p> ###12线程等待与唤醒案例介绍<br>   *A:线程等待与唤醒案例介绍<br>     等待唤醒机制所涉及到的方法：<br>         wait（） :等待，将正在执行的线程释放其执行资格 和 执行权，并存储到线程池中。<br>         notify（）：唤醒，唤醒线程池中被wait（）的线程，一次唤醒一个，而且是任意的。<br>         notifyAll（）： 唤醒全部：可以将线程池中的所有wait() 线程都唤醒。<br>       其实，所谓唤醒的意思就是让 线程池中的线程具备执行资格。必须注意的是，这些方法都是在 同步中才有效。同时这些方法在使用时必须标明所属锁，这样才可以明确出这些方法操作的到底是哪个锁上的线程。</p>
<p>###13线程等待与唤醒案例资源类编写<br>  <em>A:线程等待与唤醒案例资源类编写<br>    /</em><br>     *  定义资源类,有2个成员变量<br>     *  name,sex<br>     *  同时有2个线程,对资源中的变量操作<br>     *  1个对name,age赋值<br>     *  2个对name,age做变量的输出打印<br>     */<br>    public class Resource {<br>      public String name;<br>      public String sex;<br>    }</p>
<p>###14线程等待与唤醒案例输入和输出线程<br>   A:线程等待与唤醒案例输入和输出线程<br>     /*<br>       *  输入的线程,对资源对象Resource中成员变量赋值<br>       *  一次赋值 张三,男<br>       *  下一次赋值 lisi,nv<br>     */<br>      public class Input implements Runnable {<br>        private Resource r=new Resource();</p>
<pre><code>  public void run() {
    int i=0;
    while(true){
      if(i%2==0){
         r.name=&quot;张三&quot;;
         r.sex=&quot;男&quot;;
       }else{
          r.name=&quot;lisi&quot;;
          r.sex=&quot;女&quot;;
        }
      i++;
    }
  }
}

/*
 *  输出线程,对资源对象Resource中成员变量,输出值
 */
public class Output implements Runnable {
  private Resource r=new Resource() ;

  public void run() {
    while(true){
       System.out.println(r.name+&quot;...&quot;+r.sex); 
      }
    }
}</code></pre><p>=================================第四节课=========================================<br>###15线程等待与唤醒案例测试类<br>   A:线程等待与唤醒案例测试类<br>      /*<br>       *  开启输入线程和输出线程,实现赋值和打印值<br>       */<br>      public class ThreadDemo{<br>        public static void main(String[] args) {</p>
<pre><code>    Resource r = new Resource();

    Input in = new Input();
    Output out = new Output();

    Thread tin = new Thread(in);
    Thread tout = new Thread(out);

    tin.start();
    tout.start();
  }
}</code></pre><p>###16线程等待与唤醒案例null值解决<br>   A:线程等待与唤醒案例null值解决<br>        /*<br>        *  输入的线程,对资源对象Resource中成员变量赋值<br>        *  一次赋值 张三,男<br>        *  下一次赋值 lisi,nv<br>      */<br>       public class Input implements Runnable {<br>         private Resource r;<br>         public Input(Resource r){<br>           this.r=r;<br>         }</p>
<pre><code>  public void run() {
    int i=0;
    while(true){
      if(i%2==0){
         r.name=&quot;张三&quot;;
         r.sex=&quot;男&quot;;
       }else{
          r.name=&quot;lisi&quot;
          r.sex=&quot;女&quot;
        }
      i++;
    }
  }
}

/*
 *  输出线程,对资源对象Resource中成员变量,输出值
 */ 
public class Output implements Runnable {
  private Resource r;
  public Output(Resource r){
     this.r=r;
  } 
  public void run() {
    while(true){
       System.out.println(r.name+&quot;...&quot;+r.sex); 
      }
    }
  }

}
/*
 *  开启输入线程和输出线程,实现赋值和打印值
 */
public class ThreadDemo{
  public static void main(String[] args) {

    Resource r = new Resource();

    Input in = new Input(r);
    Output out = new Output(r);

    Thread tin = new Thread(in);
    Thread tout = new Thread(out);

    tin.start();
    tout.start();
  }
}</code></pre><p>###17线程等待与唤醒案例数据安全解决<br>    A:线程等待与唤醒案例数据安全解决<br>            /*<br>              *  输入的线程,对资源对象Resource中成员变量赋值<br>              *  一次赋值 张三,男<br>              *  下一次赋值 lisi,nv<br>            */<br>             public class Input implements Runnable {<br>               private Resource r;<br>               public Input(Resource r){<br>                 this.r=r;<br>               }</p>
<pre><code>  public void run() {
    int i=0;
    while(true){
     synchronized(r){
      if(i%2==0){
         r.name=&quot;张三&quot;;
         r.sex=&quot;男&quot;;
       }else{
          r.name=&quot;lisi&quot;
          r.sex=&quot;女&quot;
        }
      i++;
    }

  }
}

/*
 *  输出线程,对资源对象Resource中成员变量,输出值
 */ 
public class Output implements Runnable {
  private Resource r;
  public Output(Resource r){
     this.r=r;
  } 
  public void run() {
    while(true){
       synchronized(r){
        System.out.println(r.name+&quot;...&quot;+r.sex); 
       }
      }
    }
  }

}
/*
 *  开启输入线程和输出线程,实现赋值和打印值
 */
public class ThreadDemo{
  public static void main(String[] args) {

    Resource r = new Resource();

    Input in = new Input(r);
    Output out = new Output(r);

    Thread tin = new Thread(in);
    Thread tout = new Thread(out);

    tin.start();
    tout.start();
  }
}</code></pre><p>###18线程等待与唤醒案例通信的分析<br>    *A:线程等待与唤醒案例通信的分析<br>        输入:赋值后,执行方法wait()永远等待<br>        输出:变量值打印输出,在输出等待之前,唤醒<br>        输入的notify(),自己在wait()永远等待<br>        输入:被唤醒后,重新对变量赋值,赋值后,必须唤醒输出的线程notify(),<br>             自己的wait()</p>
<p>###19线程等待与唤醒案例的实现<br>   *A 线程等待与唤醒案例的实现</p>
<pre><code>/*
 *  定义资源类,有2个成员变量
 *  name,sex
 *  同时有2个线程,对资源中的变量操作
 *  1个对name,age赋值
 *  2个对name,age做变量的输出打印
 */
public class Resource {
 public String name;
 public String sex;
 public boolean flag = false;
}

/*
 *  输入的线程,对资源对象Resource中成员变量赋值
 *  一次赋值 张三,男
 *  下一次赋值 lisi,nv
 */
public class Input implements Runnable {
 private Resource r ;

 public Input(Resource r){
   this.r = r;
 }

 public void run() {
   int i = 0 ;
   while(true){
     synchronized(r){
       //标记是true,等待
         if(r.flag){
           try{r.wait();}catch(Exception ex){}
         }

       if(i%2==0){
         r.name = &quot;张三&quot;;
         r.sex = &quot;男&quot;;
       }else{
         r.name = &quot;lisi&quot;;
         r.sex = &quot;nv&quot;;
       }
       //将对方线程唤醒,标记改为true
       r.flag = true;
       r.notify();
     }
     i++;
   }
 }

}

/*
 *  输出线程,对资源对象Resource中成员变量,输出值
 */
public class Output implements Runnable {
 private Resource r ;

 public Output(Resource r){
   this.r = r;
 }
 public void run() {
   while(true){
     synchronized(r){  
       //判断标记,是false,等待
     if(!r.flag){
       try{r.wait();}catch(Exception ex){}
       }
     System.out.println(r.name+&quot;..&quot;+r.sex);
     //标记改成false,唤醒对方线程
     r.flag = false;
     r.notify();
     }
   }
 }

}

/*
 *  开启输入线程和输出线程,实现赋值和打印值
 */
public class ThreadDemo{
 public static void main(String[] args) {

   Resource r = new Resource();

   Input in = new Input(r);
   Output out = new Output(r);

   Thread tin = new Thread(in);
   Thread tout = new Thread(out);

   tin.start();
   tout.start();
 }
}</code></pre><p>###20eclipse问题<br>   A:eclipse问题</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day26%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day26%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记26</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:12:47" itemprop="dateModified" datetime="2020-12-23T23:12:47+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、多线程<br>2、线程池</p>
<p>=======================第一节课开始=============================================</p>
<p>###01进程概念<br>*A:进程概念<br>   *a:进程：进程指正在运行的程序。确切的来说，当一个程序进入内存运行，<br>        即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能。</p>
<p>###02线程的概念<br> *A:线程的概念<br>   *a:线程：线程是进程中的一个执行单元(执行路径)，负责当前进程中程序的执行，<br>          一个进程中至少有一个线程。一个进程中是可以有多个线程的，<br>          这个应用程序也可以称之为多线程程序。<br>    简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程</p>
<p>###03深入线程的概念<br>  A:深入线程的概念<br>    什么是多线程呢？<br>     即就是一个程序中有多个线程在同时执行。<br>     一个核心的CPU在多个线程之间进行着随即切换动作,由于切换时间很短(毫秒甚至是纳秒级别),导致我们感觉不出来</p>
<pre><code>单线程程序：即，若有多个任务只能依次执行。当上一个任务执行结束后，下一个任务开始执行。如去            网吧上网，网吧只能让一个人上网，当这个人下机后，下一个人才能上网。
多线程程序：即，若有多个任务可以同时执行。如，去网吧上网，网吧能够让多个人同时上网。</code></pre><p>###04迅雷的多线程下载<br>   A:迅雷的多线程下载<br>     多线程,每个线程都读一个文件</p>
<p>###05线程的运行模式<br>   A:线程的运行模式<br>    a:分时调度<br>      所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p>
<pre><code>b:抢占式调度
 优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。

 大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。

 实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。
 其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。</code></pre><p>###06main的主线程<br>  <em>A:main的主线程<br>    /</em><br>     *  程序中的主线程<br>     */<br>    public class Demo {<br>      public static void main(String[] args) {<br>        System.out.println(0/0);<br>        function();<br>        System.out.println(Math.abs(-9));<br>      }</p>
<pre><code>  public static void function(){
    for(int i = 0 ; i &lt; 10000;i++){
      System.out.println(i);
    }
  }
}</code></pre><p>=======================第二节课开始=============================================<br>###07Thread类介绍<br>  A:Thread类介绍:Thread是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程。<br>     发现创建新执行线程有两种方法。<br>     a:一种方法是将类声明为 Thread 的子类。该子类应重写 Thread 类的 run 方法。创建对象，开启线程。run方法相当于其他线程的main方法。<br>     b:另一种方法是声明一个实现 Runnable 接口的类。该类然后实现 run 方法。然后创建Runnable的子类对象，传入到某个线程的构造方法中，开启线程。</p>
<p>###08实现线程程序继承Thread<br>   <em>A:实现线程程序继承Thread<br>        /</em><br>       * 创建和启动一个线程<br>       *   创建Thread子类对象<br>       *   子类对象调用方法start()<br>       *      让线程程序执行,JVM调用线程中的run<br>       <em>/<br>      public class ThreadDemo {<br>        public static void main(String[] args) {<br>          SubThread st = new SubThread();<br>          SubThread st1 = new SubThread();<br>          st.start();<br>          st1.start();<br>          for(int i = 0; i &lt; 50;i++){<br>            System.out.println(“main…”+i);<br>          }<br>        }<br>      }<br>      /</em><br>       *  定义子类,继承Thread<br>       *  重写方法run<br>       */<br>      public class SubThread  extends Thread{<br>        public void run(){<br>          for(int i = 0; i &lt; 50;i++){<br>            System.out.println(“run…”+i);<br>          }<br>        }<br>      }</p>
<p>​     </p>
<p>###09线程执行的随机性<br>   <em>A:线程执行的随机性<br>    /</em><br>      代码分析:<br>         整个程序就只有三个线程,<br>         一个是主线程<br>           启动另外两个线程<br>            st.start();<br>            st1.start();<br>            for(int i = 0; i &lt; 50;i++){<br>              System.out.println(“main…”+i);<br>            }<br>         一个是st(Thread-0)线程<br>         for(int i = 0; i &lt; 50;i++){<br>           System.out.println(“run…”+i);<br>         }<br>         一个是st1(Thread-1)线程下 </p>
<pre><code>*/
 public class ThreadDemo {
   public static void main(String[] args) {
     SubThread st = new SubThread();
     SubThread st1 = new SubThread();
     st.start();
     st1.start();
     for(int i = 0; i &lt; 50;i++){
       System.out.println(&quot;main...&quot;+i);
     }
   }
 }
 /*
  *  定义子类,继承Thread 
  *  重写方法run 
  */
 public class SubThread  extends Thread{
   public void run(){
     for(int i = 0; i &lt; 50;i++){
       System.out.println(&quot;run...&quot;+i);
     }
   }
 }</code></pre><p>###10为什么要继承Thread<br>   *A:什么要继承Thread<br>    a:我们为什么要继承Thread类，并调用其的start方法才能开启线程呢？<br>       继承Thread类：因为Thread类用来描述线程，具备线程应该有功能。那为什么不直接创建Thread类的对象呢？<br>       如下代码：<br>        Thread t1 = new Thread();<br>        t1.start();//这样做没有错，但是该start调用的是Thread类中的run方法<br>                  //而这个run方法没有做什么事情，更重要的是这个run方法中并没有定义我们需要让线程执行的代码。</p>
<pre><code>b:创建线程的目的是什么？
 是为了建立程序单独的执行路径，让多部分代码实现同时执行。也就是说线程创建并执行需要给定线程要执行的任务。
 对于之前所讲的主线程，它的任务定义在main函数中。自定义线程需要执行的任务都定义在run方法中。</code></pre><p>###11多线程内存图解<br>   *A:多线程内存图解<br>      多线程执行时，到底在内存中是如何运行的呢？<br>        多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。<br>        当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。</p>
<p>=======================第三节课开始=============================================<br>###12获取线程名字Thread类方法getName<br>   <em>A:获取线程名字Thread类方法getName<br>    /</em><br>     *  获取线程名字,父类Thread方法<br>     *    String getName()<br>     */<br>    public class NameThread extends Thread{</p>
<pre><code>  public NameThread(){
    super(&quot;小强&quot;);
  }

  public void run(){
    System.out.println(getName());
  }
}

/*
 *  每个线程,都有自己的名字
 *  运行方法main线程,名字就是&quot;main&quot;
 *  其他新键的线程也有名字,默认 &quot;Thread-0&quot;,&quot;Thread-1&quot;
 *  
 *  JVM开启主线程,运行方法main,主线程也是线程,是线程必然就是
 *  Thread类对象
 */
public class ThreadDemo {
  public static void main(String[] args) {
    NameThread nt = new NameThread();
    nt.start();</code></pre><p>​         </p>
<pre><code>  }
}</code></pre><p>###13获取线程名字Thread类方法currentThread<br>  <em>A:获取线程名字Thread类方法currentThread<br>   /</em><br>    *  获取线程名字,父类Thread方法<br>    *    String getName()<br>    */<br>   public class NameThread extends Thread{</p>
<pre><code>public void run(){
  System.out.println(getName());
}</code></pre><p>   }</p>
<p>   /*<br>    *  每个线程,都有自己的名字<br>    *  运行方法main线程,名字就是”main”<br>    *  其他新键的线程也有名字,默认 “Thread-0”,”Thread-1”<br>    *<br>    *  JVM开启主线程,运行方法main,主线程也是线程,是线程必然就是<br>    *  Thread类对象<br>    *  Thread类中,静态方法<br>    *   static Thread currentThread()返回正在执行的线程对象<br>    */<br>   public class ThreadDemo {<br>     public static void main(String[] args) {<br>       NameThread nt = new NameThread();<br>       nt.start();</p>
<pre><code>  /*Thread t =Thread.currentThread();
  System.out.println(t.getName());*/
  System.out.println(Thread.currentThread().getName());


}</code></pre><p>   }</p>
<p>###14线程名字设置<br>   A:线程名字设置<br>      /*<br>       *  获取线程名字,父类Thread方法<br>       *    String getName()<br>       */<br>      public class NameThread extends Thread{</p>
<pre><code>  public NameThread(){
    super(&quot;小强&quot;);
  }

  public void run(){
    System.out.println(getName());
  }
}

/*
 *  每个线程,都有自己的名字
 *  运行方法main线程,名字就是&quot;main&quot;
 *  其他新键的线程也有名字,默认 &quot;Thread-0&quot;,&quot;Thread-1&quot;
 *  
 *  JVM开启主线程,运行方法main,主线程也是线程,是线程必然就是
 *  Thread类对象
 *  Thread类中,静态方法
 *   static Thread currentThread()返回正在执行的线程对象
 */
public class ThreadDemo {
  public static void main(String[] args) {
    NameThread nt = new NameThread();
    nt.setName(&quot;旺财&quot;);
    nt.start();

  }
}</code></pre><p>###15Thread类方法sleep<br>   A:Thread类方法sleep<br>     public class ThreadDemo {<br>      public static void main(String[] args) throws Exception{<br>        /<em>for(int i = 0 ; i &lt; 5 ;i++){<br>          Thread.sleep(50);<br>          System.out.println(i);<br>        }</em>/</p>
<pre><code>   new SleepThread().start();
 }
}

public class SleepThread extends Thread{
 public void run(){
   for(int i = 0 ; i &lt; 5 ;i++){
     try{
       Thread.sleep(500);//睡眠500ms,500ms已到并且cpu切换到该线程继续向下执行
     }catch(Exception ex){

     }
     System.out.println(i);
   }
 }
}</code></pre><p>###16实现线程的另一种方式实现Runnable接口<br>   A:实现线程的另一种方式实现Runnable接口<br>       /*<br>      *  实现接口方式的线程<br>      *    创建Thread类对象,构造方法中,传递Runnable接口实现类<br>      *    调用Thread类方法start()<br>      */<br>     public class ThreadDemo {<br>      public static void main(String[] args) {<br>        SubRunnable sr = new SubRunnable();<br>        Thread t = new Thread(sr);<br>        t.start();<br>        for(int i = 0 ; i &lt; 50; i++){<br>          System.out.println(“main…”+i);<br>        }<br>      }<br>     }</p>
<pre><code>/*
 *  实现线程成功的另一个方式,接口实现
 *  实现接口Runnable,重写run方法
 */
public class SubRunnable implements Runnable{
 public void run(){
   for(int i = 0 ; i &lt; 50; i++){
     System.out.println(&quot;run...&quot;+i);
   }
 }
}</code></pre><p>###17实现接口方式的好处<br>    A:实现接口方式的好处<br>     第二种方式实现Runnable接口避免了单继承的局限性，所以较为常用。<br>     实现Runnable接口的方式，更加的符合面向对象，线程分为两部分，一部分线程对象，一部分线程任务。<br>     继承Thread类，线程对象和线程任务耦合在一起。<br>     一旦创建Thread类的子类对象，既是线程对象，有又有线程任务。<br>     实现runnable接口，将线程任务单独分离出来封装成对象，类型就是Runnable接口类型。Runnable接口对线程对象和线程任务进行解耦。<br>     (降低紧密性或者依赖性,创建线程和执行任务不绑定)</p>
<p>###18匿名内部类实现线程程序<br>    <em>A:匿名内部类实现线程程序<br>    /</em><br>     *  使用匿名内部类,实现多线程程序<br>     *  前提: 继承或者接口实现<br>     *  new 父类或者接口(){<br>     *     重写抽象方法<br>     *  }<br>     */<br>    public class ThreadDemo {<br>      public static void main(String[] args) {<br>        //继承方式  XXX extends Thread{ public void run(){}}<br>        new Thread(){<br>          public void run(){<br>            System.out.println(“!!!”);<br>          }<br>        }.start();</p>
<pre><code>//实现接口方式  XXX implements Runnable{ public void run(){}}

Runnable r = new Runnable(){
  public void run(){
    System.out.println(&quot;###&quot;);
  }
};
new Thread(r).start();</code></pre><p>​<br>        new Thread(new Runnable(){<br>          public void run(){<br>            System.out.println(“@@@”);<br>          }<br>        }).start();</p>
<pre><code>  }
}</code></pre><p>=======================第四节课开始=============================================</p>
<p>###19线程的状态图<br>   A:线程的状态图<br>        a:参见线程状态图.jpg</p>
<p>###20线程池的原理<br>   A:线程池的原理<br>      1.在java中，如果每个请求到达就创建一个新线程，开销是相当大的。<br>      2.在实际使用中，创建和销毁线程花费的时间和消耗的系统资源都相当大，甚至可能要比在处理实际的用户请求的时间和资源要多的多。<br>      3.除了创建和销毁线程的开销之外，活动的线程也需要消耗系统资源。<br>        如果在一个jvm里创建太多的线程，可能会使系统由于过度消耗内存或“切换过度”而导致系统资源不足。<br>        为了防止资源不足，需要采取一些办法来限制任何给定时刻处理的请求数目，尽可能减少创建和销毁线程的次数，特别是一些资源耗费比较大的线程的创建和销毁，尽量利用已有对象来进行服务。<br>      线程池主要用来解决线程生命周期开销问题和资源不足问题。通过对多个任务重复使用线程，线程创建的开销就被分摊到了多个任务上了，而且由于在请求到达时线程已经存在，所以消除了线程创建所带来的延迟。这样，就可以立即为请求服务，使用应用程序响应更快。另外，通过适当的调整线程中的线程数目可以防止出现资源不足的情况。</p>
<p>###21JDK5实现线程池<br>    A:JDK5实现线程池<br>        /*<br>       *  JDK1.5新特性,实现线程池程序<br>       *  使用工厂类 Executors中的静态方法创建线程对象,指定线程的个数<br>       *   static ExecutorService newFixedThreadPool(int 个数) 返回线程池对象<br>       *   返回的是ExecutorService接口的实现类 (线程池对象)<br>       *<br>       *   接口实现类对象,调用方法submit (Ruunable r) 提交线程执行任务<br>       *<br>       */<br>      public class ThreadPoolDemo {<br>        public static void main(String[] args) {<br>          //调用工厂类的静态方法,创建线程池对象<br>          //返回线程池对象,是返回的接口<br>          ExecutorService es = Executors.newFixedThreadPool(2);<br>            //调用接口实现类对象es中的方法submit提交线程任务<br>          //将Runnable接口实现类对象,传递<br>          es.submit(new ThreadPoolRunnable());<br>          es.submit(new ThreadPoolRunnable());<br>          es.submit(new ThreadPoolRunnable());</p>
<pre><code>  }
}

public class ThreadPoolRunnable implements Runnable {
  public void run(){
    System.out.println(Thread.currentThread().getName()+&quot; 线程提交任务&quot;);
  }
}</code></pre><p>###22实现线程的Callable接口方式<br>  A:实现线程的Callable接口方式<br>     /*<br>      *  实现线程程序的第三个方式,实现Callable接口方式<br>      *  实现步骤<br>      *    工厂类 Executors静态方法newFixedThreadPool方法,创建线程池对象<br>      *    线程池对象ExecutorService接口实现类,调用方法submit提交线程任务<br>      *    submit(Callable c)<br>      <em>/<br>     public class ThreadPoolDemo1 {<br>      public static void main(String[] args)throws Exception {<br>        ExecutorService es = Executors.newFixedThreadPool(2);<br>        //提交线程任务的方法submit方法返回 Future接口的实现类<br>        Future<String> f = es.submit(new ThreadPoolCallable());<br>        String s = f.get();<br>        System.out.println(s);<br>      }<br>     }<br>     /</String></em><br>      * Callable 接口的实现类,作为线程提交任务出现<br>      * 使用方法返回值<br>      */</p>
<pre><code>import java.util.concurrent.Callable;

public class ThreadPoolCallable implements Callable&lt;String&gt;{
 public String call(){
   return &quot;abc&quot;;
 }
}</code></pre><p>###23线程实现异步计算<br>  A:线程实现异步计算</p>
<pre><code>/*
 * 使用多线程技术,求和
 * 两个线程,1个线程计算1+100,另一个线程计算1+200的和
 * 多线程的异步计算
 */
public class ThreadPoolDemo {
  public static void main(String[] args)throws Exception {
    ExecutorService es = Executors.newFixedThreadPool(2);
    Future&lt;Integer&gt; f1 =es.submit(new GetSumCallable(100));
    Future&lt;Integer&gt; f2 =es.submit(new GetSumCallable(200));
    System.out.println(f1.get());
    System.out.println(f2.get());
    es.shutdown();
  }
}</code></pre><p>​     </p>
<pre><code>public class GetSumCallable implements Callable&lt;Integer&gt;{
  private int a;
  public GetSumCallable(int a){
    this.a=a;
  }

  public Integer call(){
    int sum = 0 ;
    for(int i = 1 ; i &lt;=a ; i++){
      sum = sum + i ;
    }
    return sum;
  }
}</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day25%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day25%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记25</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:12:34" itemprop="dateModified" datetime="2020-12-23T23:12:34+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、Properties集合<br>2、序列化流与反序列化流<br>3、打印流<br>4、commons-IO</p>
<p>###01Properties集合的特点<br>    * A: Properties集合的特点<br>        * a: Properties类介绍<br>            * Properties 类表示了一个持久的属性集。Properties 可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串<br>        * b: 特点<br>            * Hashtable的子类，map集合中的方法都可以用。<br>            * 该集合没有泛型。键值都是字符串。<br>            * 它是一个可以持久化的属性集。键值可以存储到集合中，也可以存储到持久化的设备(硬盘、U盘、光盘)上。键值的来源也可以是持久化的设备。<br>            * 有和流技术相结合的方法。<br>        * c: 方法介绍<br>            * load(InputStream inputStream)  把指定流所对应的文件中的数据，读取出来，保存到Propertie集合中<br>            * load(Reader reader) 按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）<br>            * store(OutputStream outputStream,String commonts) 把集合中的数据，保存到指定的流所对应的文件中，参数commonts代表对描述信息<br>            * stroe(Writer writer,String comments) 以适合使用 load(Reader) 方法的格式，将此 Properties 表中的属性列表（键和元素对）写入输出字符</p>
<p>​<br>​<br>###02Properties集合存储键值对<br>    * A: Properties集合存储键值对<br>        * a: 方法介绍<br>            *  集合对象Properties类,继承Hashtable,实现Map接口<br>            *  可以和IO对象结合使用,实现数据的持久存储<br>            * 使用Properties集合,存储键值对<br>            * setProperty等同与Map接口中的put<br>            * setProperty(String key, String value)<br>            * 通过键获取值, getProperty(String key)<br>        * b: 案例代码<br>            public class PropertiesDemo {<br>                public static void main(String[] args)throws IOException {<br>                    function_2();<br>                }<br>                /*<br>                 * 使用Properties集合,存储键值对<br>                 * setProperty等同与Map接口中的put<br>                 * setProperty(String key, String value)<br>                 * 通过键获取值, getProperty(String key)<br>                 */<br>                public static void function(){<br>                    Properties pro = new Properties();<br>                    pro.setProperty(“a”, “1”);<br>                    pro.setProperty(“b”, “2”);<br>                    pro.setProperty(“c”, “3”);<br>                    System.out.println(pro);</p>
<pre><code>        String value = pro.getProperty(&quot;c&quot;);
        System.out.println(value);

        //方法stringPropertyNames,将集合中的键存储到Set集合,类似于Map接口的方法keySet
        Set&lt;String&gt; set = pro.stringPropertyNames();
        for(String key : set){
            System.out.println(key+&quot;...&quot;+pro.getProperty(key));
        }
    }
}</code></pre><p>​<br>###03Properties集合的方法load<br>    * A: Properties集合的方法load<br>        * a: 方法介绍<br>            * Properties集合特有方法 load<br>            * load(InputStream in)<br>            * load(Reader r)<br>            * 传递任意的字节或者字符输入流<br>            * 流对象读取文件中的键值对,保存到集合</p>
<pre><code>* b: 案例代码        
        public class PropertiesDemo {
            public static void main(String[] args)throws IOException {
                function_1();
            }                                    
            /*
             * Properties集合特有方法 load
             * load(InputStream in)
             * load(Reader r)
             * 传递任意的字节或者字符输入流
             * 流对象读取文件中的键值对,保存到集合
             */
            public static void function_1()throws IOException{
                Properties pro = new Properties();
                FileReader fr = new FileReader(&quot;c:\\pro.properties&quot;);
                //调用集合的方法load,传递字符输入流
                pro.load(fr);
                fr.close();
                System.out.println(pro);
            }                    
        }</code></pre><p>###04Properties集合的方法store<br>    * A: Properties集合的方法store<br>        * a: 方法介绍<br>            * Properties集合的特有方法store<br>            * store(OutputStream out)<br>            * store(Writer w)<br>            * 接收所有的字节或者字符的输出流,将集合中的键值对,写回文件中保存<br>        * b: 案例代码<br>            public class PropertiesDemo {<br>                public static void main(String[] args)throws IOException {<br>                    function_2();<br>                }<br>                /*<br>                 * Properties集合的特有方法store<br>                 * store(OutputStream out)<br>                 * store(Writer w)<br>                 * 接收所有的字节或者字符的输出流,将集合中的键值对,写回文件中保存<br>                 */<br>                public static void function_2()throws IOException{<br>                    Properties pro = new Properties();<br>                    pro.setProperty(“name”, “zhangsan”);<br>                    pro.setProperty(“age”, “31”);<br>                    pro.setProperty(“email”, “<a href="mailto:123456789@163.com">123456789@163.com</a>“);<br>                    FileWriter fw = new FileWriter(“c:\pro.properties”);<br>                    //键值对,存回文件,使用集合的方法store传递字符输出流<br>                    pro.store(fw, “”);<br>                    fw.close();<br>                }<br>            }</p>
<p>###05对象的序列化与反序列化<br>    * A: 对象的序列化与反序列化<br>        * a: 基本概念<br>            * 对象的序列化<br>                * 对象中的数据，以流的形式，写入到文件中保存过程称为写出对象，对象的序列化<br>                * ObjectOutputStream将对象写道文件中，实现序列化<br>            * 对象的反序列化<br>                * 在文件中，以流的形式，将对象读出来，读取对象，对象的反序列化<br>                * ObjectInputStream 将文件对象读取出来</p>
<p>###06ObjectOutputStream流写对象<br>    * A: ObjectOutputStream流写对象<br>        * a: 简单介绍<br>             *  IO流对象,实现对象Person序列化,和反序列化<br>             *  ObjectOutputStream 写对象,实现序列化<br>             *  ObjectInputStream 读取对象,实现反序列化</p>
<pre><code>* b: 案例代码
    public class Person implements Serializable{
        public String name;
        public int age;
        public Person(String name, int age) {
            super();
            this.name = name;
            this.age = age;
        }
        public Person(){}

        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
        public int getAge() {
            return age;
        }
        public void setAge(int age) {
            this.age = age;
        }
        @Override
        public String toString() {
            return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;
        }                
    }

    public class ObjectStreamDemo {
        public static void main(String[] args)throws IOException, ClassNotFoundException {
    //        writeObject();
            readObject();
        }
        /*
         * ObjectOutputStream
         * 构造方法: ObjectOutputStream(OutputSteam out)
         * 传递任意的字节输出流
         * void writeObject(Object obj)写出对象的方法
         */
        public static void writeObject() throws IOException{
            //创建字节输出流,封装文件
            FileOutputStream fos = new FileOutputStream(&quot;c:\\person.txt&quot;);
            //创建写出对象的序列化流的对象,构造方法传递字节输出流
            ObjectOutputStream oos = new ObjectOutputStream(fos);
            Person p = new Person(&quot;lisi&quot;,25);
            //调用序列化流的方法writeObject,写出对象
            oos.writeObject(p);
            oos.close();
        }
    }</code></pre><p>###07ObjectInputStream流读取对象<br>    * A: ObjectInputStream流读取对象<br>        * a: 简单介绍<br>            * ObjectInputStream<br>            * 构造方法:ObjectInputStream(InputStream in)<br>            * 传递任意的字节输入流,输入流封装文件,必须是序列化的文件<br>            * Object readObject()  读取对象<br>        * b: 案例代码<br>            /*<br>             *  IO流对象,实现对象Person序列化,和反序列化<br>             *  ObjectOutputStream 写对象,实现序列化<br>             *  ObjectInputStream 读取对象,实现反序列化<br>             <em>/<br>            public class ObjectStreamDemo {<br>                public static void main(String[] args)throws IOException, ClassNotFoundException {<br>                    readObject();<br>                }<br>                /</em><br>                 * ObjectInputStream<br>                 * 构造方法:ObjectInputStream(InputStream in)<br>                 * 传递任意的字节输入流,输入流封装文件,必须是序列化的文件<br>                 * Object readObject()  读取对象<br>                 */<br>                public static void readObject() throws IOException, ClassNotFoundException{<br>                    FileInputStream fis = new FileInputStream(“c:\person.txt”);<br>                    //创建反序列化流,构造方法中,传递字节输入流<br>                    ObjectInputStream ois = new ObjectInputStream(fis);<br>                    //调用反序列化流的方法 readObject()读取对象<br>                    Object obj =ois.readObject();<br>                    System.out.println(obj);<br>                    ois.close();<br>                }<br>            }</p>
<p>###08静态不能序列化<br>    * A: 静态不能序列化<br>        * a: 原因<br>            * 序列化是把对象数据进行持久化存储<br>            * 静态的东西不属于对象，而属于类</p>
<p>###09transient关键字<br>    * A: transient关键字<br>        * a: 作用<br>            * 被transient修饰的属性不会被序列化<br>            * transient关键字只能修饰成员变量</p>
<p>​<br>###10Serializable接口的含义<br>    * A：Serializable接口的含义<br>        * a: 作用<br>            * 给需要序列化的类上加标记。该标记中没有任何抽象方法<br>            * 只有实现了 Serializable接口的类的对象才能被序列化</p>
<p>###11序列化中的序列号冲突问题<br>    * A: 序列化中的序列号冲突问题<br>        * a: 问题产生原因<br>            * 当一个类实现Serializable接口后，创建对象并将对象写入文件，之后更改了源代码(比如：将成员变量的修饰符有private改成public)，<br>                再次从文件中读取对象时会报异常<br>            * 见day25_source文件夹下的”序列号的冲突.JPG”文件</p>
<p>###12序列化中自定义的序列号<br>    * A: 序列化中自定义的序列号<br>        * a: 定义方式<br>            * private static final long serialVersionUID = 1478652478456L;<br>                * 这样每次编译类时生成的serialVersionUID值都是固定的     </p>
<pre><code>* b: 案例代码
    public class Person implements Serializable{
        public String name;
        public /*transient阻止成员变量序列化*/ int age;
        //类,自定义了序列号,编译器不会计算序列号
        private static final long serialVersionUID = 1478652478456L;

        public Person(String name, int age) {
            super();
            this.name = name;
            this.age = age;
        }
        public Person(){}

        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
        public int getAge() {
            return age;
        }
        public void setAge(int age) {
            this.age = age;
        }
        @Override
        public String toString() {
            return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;
        }                
    }</code></pre><p>###13打印流和特性<br>    * A: 打印流和特性<br>        * a: 概述<br>            * 打印流添加输出数据的功能，使它们能够方便地打印各种数据值表示形式.<br>            * 打印流根据流的分类：<br>                * 字节打印流    PrintStream<br>                * 字符打印流    PrintWriter<br>            * 方法：<br>                * void print(String str): 输出任意类型的数据，<br>                * void println(String str): 输出任意类型的数据，自动写入换行操作<br>        * b: 特点<br>            * 此流不负责数据源,只负责数据目的<br>            * 为其他输出流,添加功能<br>            * 永远不会抛出IOException，但是可能抛出别的异常<br>            * 两个打印流的方法,完全一致<br>            * 构造方法,就是打印流的输出目的端<br>            * PrintStream构造方法<br>                * 接收File类型,接收字符串文件名,接收字节输出流OutputStream<br>            * PrintWriter构造方法<br>                * 接收File类型,接收字符串文件名,接收字节输出流OutputStream, 接收字符输出流Writer</p>
<p>​<br>###14打印流输出目的是File对象<br>    * A: 打印流输出目的是File对象<br>        * a: 案例代码<br>            public class PrintWriterDemo {<br>                public static void main(String[] args) throws  IOException {<br>                    function_3();</p>
<pre><code>    }

    /*
     * 打印流,向File对象的数据目的写入数据
     * 方法print println  原样输出
     * write方法走码表
     */
    public static void function() throws FileNotFoundException{
        File file = new File(&quot;c:\\1.txt&quot;);
        PrintWriter pw = new PrintWriter(file);
        pw.println(true);
        pw.write(100);
        pw.close();
    }
}</code></pre><p>###15输出语句是char数组<br>    * A: 输出语句是char数组<br>        * a: 案例代码<br>            public class Demo {<br>                public static void main(String[] args) {<br>                    int[] arr = {1};<br>                    System.out.println(arr);</p>
<pre><code>            char[] ch = {&apos;a&apos;,&apos;b&apos;};
            System.out.println(ch);

            byte[] b = {};
            System.out.println(b);
        }
    }
* b: 结果分析
    * println数组，只有打印字符数组时只有容，其余均打印数组的地址
        * 因为api中定义了打印字符数组的方法，其底层是在遍历数组中的元素
        * 而其他打印数组的方法，都是将数组对象编程Object，其底层再将对象编程String，调用了String s = String.valueOf(x);方法</code></pre><p>###16打印流输出目的是String和流对象<br>    * A: 打印流输出目的是String和流对象<br>        * a: 案例代码<br>            public class PrintWriterDemo {<br>                public static void main(String[] args) throws  IOException {<br>                    function_2();</p>
<pre><code>    }

    /*
     * 打印流,输出目的,是流对象
     * 可以是字节输出流,可以是字符的输出流
     * OutputStream  Writer
     */
    public static void function_2() throws IOException{
    //    FileOutputStream fos = new FileOutputStream(&quot;c:\\3.txt&quot;);
        FileWriter fw = new FileWriter(&quot;c:\\4.txt&quot;);
        PrintWriter pw = new PrintWriter(fw);
        pw.println(&quot;打印流&quot;);
        pw.close();
    }
    /*
     * 打印流,输出目的,String文件名
     */
    public static void function_1() throws FileNotFoundException{
        PrintWriter pw = new PrintWriter(&quot;c:\\2.txt&quot;);
        pw.println(3.5);
        pw.close();
    }    

}</code></pre><p>###17打印流开启自动刷新<br>    * A: 打印流开启自动刷新<br>        * 案例代码<br>            public class PrintWriterDemo {<br>                public static void main(String[] args) throws  IOException {<br>                    function_3();</p>
<pre><code>    }
    /* 
     * 打印流,可以开启自动刷新功能
     * 满足2个条件:
     *   1. 输出的数据目的必须是流对象
     *       OutputStream  Writer
     *   2. 必须调用println,printf,format三个方法中的一个,启用自动刷新
     */
    public static void function_3()throws  IOException{
        //File f = new File(&quot;XXX.txt&quot;);
        FileOutputStream fos = new FileOutputStream(&quot;c:\\5.txt&quot;);
        PrintWriter pw = new PrintWriter(fos,true);
        pw.println(&quot;i&quot;);
        pw.println(&quot;love&quot;);
        pw.println(&quot;java&quot;);
        pw.close();
    }
}</code></pre><p>###18打印流复制文本文件<br>    * A: 打印流复制文本文件<br>        * a: 案例代码<br>            /*<br>             * 打印流实现文本复制<br>             *   读取数据源  BufferedReader+File 读取文本行<br>             *   写入数据目的 PrintWriter+println 自动刷新<br>             */<br>            public class PrintWriterDemo1 {<br>                public static void main(String[] args) throws IOException{<br>                    BufferedReader bfr = new BufferedReader(new FileReader(“c:\a.txt”));<br>                    PrintWriter pw = new PrintWriter(new FileWriter(“d:\a.txt”),true);<br>                    String line = null;<br>                    while((line = bfr.readLine())!=null){<br>                        pw.println(line);<br>                    }<br>                    pw.close();<br>                    bfr.close();<br>                }<br>            }</p>
<p>###19commons-io工具类介绍<br>    * A: commons-io工具类介绍<br>        * a: 工具类介绍<br>            * 解压缩commons-io-2.4.zip文件<br>            * commons-io-2.4.jar需要导入到项目中的jar包，里面存放的是class文件<br>            * commons-io-2.4-sources.jar工具类中原代码<br>            * docs是帮助文档</p>
<p>###20使用工具类commons_io<br>    * A: 使用工具类commons_io<br>        * a: 导入jar包<br>            * 加入classpath的第三方jar包内的class文件才能在项目中使用<br>            * 创建lib文件夹<br>            * 将commons-io.jar拷贝到lib文件夹<br>            * 右键点击commons-io.jar，Build Path→Add to Build Path<br>        * b: 学会如何看源代码</p>
<p>###21IO工具类FilenameUtils<br>    * A: IO工具类FilenameUtils<br>        * a: 方法介绍<br>            * getExtension(String path)：获取文件的扩展名；<br>            * getName()：获取文件名；<br>            * isExtension(String fileName,String ext)：判断fileName是否是ext后缀名；<br>        * b: 案例代码<br>            public class Commons_IODemo {<br>                public static void main(String[] args) {<br>                    function_2();<br>                }<br>                /*<br>                 * FilenameUtils类的方法<br>                 * static boolean isExtension(String filename,String extension)<br>                 * 判断文件名的后缀是不是extension<br>                 */<br>                public static void function_2(){<br>                    boolean b = FilenameUtils.isExtension(“Demo.java”, “java”);<br>                    System.out.println(b);<br>                }</p>
<pre><code>    /*
     * FilenameUtils类的方法
     * static String getName(String filename)
     * 获取文件名
     */
    public static void function_1(){
        String name = FilenameUtils.getName(&quot;c:\\windows\\&quot;);
        System.out.println(name);
    }

    /*
     * FilenameUtils类的方法
     * static String getExtension(String filename)
     * 获取文件名的扩展名
     */
     public static void function(){
         String name = FilenameUtils.getExtension(&quot;c:\\windows&quot;);
         System.out.println(name);
     }
}</code></pre><p>###22IO工具类FileUtils<br>    * A: IO工具类FileUtils<br>        * a: 方法介绍<br>            * readFileToString(File file)：读取文件内容，并返回一个String；<br>            * writeStringToFile(File file，String content)：将内容content写入到file中；<br>            * copyDirectoryToDirectory(File srcDir,File destDir);文件夹复制<br>            * copyFile(File srcFile,File destFile);文件复制</p>
<pre><code>* b: 案例代码
    public class Commons_IODemo1 {
        public static void main(String[] args)throws IOException {
            function_3();
        }
        /*
         * FileUtils工具类方法
         * static void copyDirectoryToDirectory(File src,File desc)
         * 复制文件夹
         */
        public static void function_3() throws IOException{
            FileUtils.copyDirectoryToDirectory(new File(&quot;d:\\demo&quot;), new File(&quot;c:\\&quot;));
        }

        /*
         * FileUtils工具类的方法
         * static void copyFile(File src,File desc)
         * 复制文件
         */
        public static void function_2() throws IOException{
            FileUtils.copyFile(new File(&quot;c:\\k.jpg&quot;),new File(&quot;d:\\k.jpg&quot;));
        }

        /*
         * FileUtils工具类的方法
         * static void writeStringToFile(File src,String date)
         * 将字符串直接写到文件中
         */
        public static void function_1() throws IOException{
            FileUtils.writeStringToFile(new File(&quot;c:\\b.txt&quot;),&quot;我爱Java编程&quot;);
        }

        /*
         * FileUtils工具类的方法
         * static String readFileToString(File src)读取文本,返回字符串
         */
         public static void function() throws IOException{
             String s = FileUtils.readFileToString(new File(&quot;c:\\a.txt&quot;));
             System.out.println(s);
         }
    }</code></pre><p>###23总结<br>    * 把今天的知识点总结一遍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day24%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day24%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记24</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:12:25" itemprop="dateModified" datetime="2020-12-23T23:12:25+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、转换流<br>2、缓冲流</p>
<p>=======================第一节课开始=============================================</p>
<p>###01转换流概述<br>    * A: 转换流概述<br>        * a: 转换流概述<br>            * OutputStreamWriter 是字符流通向字节流的桥梁：可使用指定的字符编码表，将要写入流中的字符编码成字节<br>            * 将字符串按照指定的编码表转成字节，在使用字节流将这些字节写出去</p>
<p>​<br>###02转换流_字符转字节的过程<br>    * A: 转换流_字符转字节的过程<br>        * a.图解<br>            * 详见day24_source/转换流.JPG图片</p>
<p>​<br>###03OutputStreamWriter写文本文件<br>    * A: OutputStreamWriter写文本文件<br>        * a: OutputStreamWriter<br>            * java.io.OutputStreamWriter 继承Writer类<br>            * 就是一个字符输出流，写文本文件<br>            * write()字符，字符数组，字符串<br>            * 字符通向字节的桥梁，将字符流转字节流<br>            * OutputStreamWriter 使用方式<br>                * 构造方法：<br>                    * OutputStreamWriter(OuputStream out)接收所有的字节输出流<br>                    * 字节输出流：  FileOutputStream<br>                    * OutputStreamWriter(OutputStream out, String charsetName)<br>                    * String charsetName 传递编码表名字 GBK  UTF-8<br>            * OutputStreamWriter 有个子类，  FileWriter<br>        * b: 案例代码</p>
<pre><code>public class OutputStreamWriterDemo {
    public static void main(String[] args)throws IOException {
//        writeGBK();
        writeUTF();
    }
    /*
     * 转换流对象OutputStreamWriter写文本
     * 采用UTF-8编码表写入
     */
    public static void writeUTF()throws IOException{
        //创建字节输出流，绑定文件
        FileOutputStream fos = new FileOutputStream(&quot;c:\\utf.txt&quot;);
        //创建转换流对象，构造方法保证字节输出流，并指定编码表是UTF-8
        OutputStreamWriter osw = new OutputStreamWriter(fos,&quot;UTF-8&quot;);
        osw.write(&quot;你好&quot;);
        osw.close();
    }

    /*
     * 转换流对象 OutputStreamWriter写文本
     * 文本采用GBK的形式写入
     */
    public static void writeGBK()throws IOException{
        //创建字节输出流，绑定数据文件
        FileOutputStream fos = new FileOutputStream(&quot;c:\\gbk.txt&quot;);
        //创建转换流对象，构造方法，绑定字节输出流，使用GBK编码表
        OutputStreamWriter osw = new OutputStreamWriter(fos);
        //转换流写数据
        osw.write(&quot;你好&quot;);

        osw.close();
    }
}</code></pre><p>###04转换流_字节转字符流过程<br>    * A: 转换流_字节转字符流过程<br>        * a: InputStreamReader<br>            * java.io.InputStreamReader 继承 Reader<br>            * 字符输入流，读取文本文件<br>            * 字节流向字符的敲了，将字节流转字符流<br>            * 读取的方法:<br>                * read() 读取1个字符，读取字符数组<br>            * 技巧<br>                * OuputStreamWriter写了文件<br>                * InputStreamReader读取文件<br>            * OutputStreamWriter(OutputStream out)所有字节输出流<br>            * InputStreamReader(InputStream in) 接收所有的字节输入流<br>            * 可以传递的字节输入流： FileInputStream<br>            * InputStreamReader(InputStream in,String charsetName) 传递编码表的名字<br>        * b: 图解<br>            * 详见day24_source/转换流.JPG图片</p>
<p>###05InputSteamReader读取文本文件<br>    * A: InputSteamReader读取文本文件<br>        * a: 案例代码<br>            public class InputStreamReaderDemo {<br>                public static void main(String[] args) throws IOException {<br>            //        readGBK();<br>                    readUTF();<br>                }<br>                /*<br>                 *  转换流,InputSteamReader读取文本<br>                 *  采用UTF-8编码表,读取文件utf<br>                 <em>/<br>                public static void readUTF()throws IOException{<br>                    //创建自己输入流,传递文本文件<br>                    FileInputStream fis = new FileInputStream(“c:\utf.txt”);<br>                    //创建转换流对象,构造方法中,包装字节输入流,同时写编码表名<br>                    InputStreamReader isr = new InputStreamReader(fis,”UTF-8”);<br>                    char[] ch = new char[1024];<br>                    int len = isr.read(ch);<br>                    System.out.println(new String(ch,0,len));<br>                    isr.close();<br>                }<br>                /</em><br>                 *  转换流,InputSteamReader读取文本<br>                 *  采用系统默认编码表,读取GBK文件<br>                 */<br>                public static void readGBK()throws IOException{<br>                    //创建自己输入流,传递文本文件<br>                    FileInputStream fis = new FileInputStream(“c:\gbk.txt”);<br>                    //创建转换流对象,构造方法,包装字节输入流<br>                    InputStreamReader isr = new InputStreamReader(fis);<br>                    char[] ch = new char[1024];<br>                    int len = isr.read(ch);<br>                    System.out.println(new String(ch,0,len));</p>
<pre><code>        isr.close();
    }
}</code></pre><p>​<br>###06转换流子类父类的区别<br>    * A: 转换流子类父类的区别<br>        * a: 继承关系<br>            OutputStreamWriter:<br>                |–FileWriter:<br>            InputStreamReader:<br>                |–FileReader;<br>        * b: 区别<br>            * OutputStreamWriter和InputStreamReader是字符和字节的桥梁：也可以称之为字符转换流。字符转换流原理：字节流+编码表。<br>            * FileWriter和FileReader：作为子类，仅作为操作字符文件的便捷类存在。<br>                当操作的字符文件，使用的是默认编码表时可以不用父类，而直接用子类就完成操作了，简化了代码。<br>            * 以下三句话功能相同<br>                * InputStreamReader isr = new InputStreamReader(new FileInputStream(“a.txt”));//默认字符集。<br>                * InputStreamReader isr = new InputStreamReader(new FileInputStream(“a.txt”),”GBK”);//指定GBK字符集。<br>                * FileReader fr = new FileReader(“a.txt”);</p>
<p>###07缓冲流概述<br>    * A: 缓冲流概述<br>        * a: 概述<br>            * 可提高IO流的读写速度<br>            * 分为字节缓冲流与字符缓冲流 </p>
<p>​<br>###08字节输出流缓冲流BufferedOutputStream<br>    * A: 字节输出流缓冲流BufferedOutputStream<br>        * a: BufferedOutputStream<br>            * 字节输出流的缓冲流<br>            * java.io.BufferedOuputStream 作用: 提高原有输出流的写入效率<br>            * BufferedOuputStream 继承 OutputStream<br>            * 方法,写入 write 字节,字节数组<br>            * 构造方法:<br>                * BufferedOuputStream(OuputStream out)<br>                * 可以传递任意的字节输出流, 传递的是哪个字节流,就对哪个字节流提高效率  </p>
<pre><code>* b: 案例代码
    public class BufferedOutputStreamDemo {
        public static void main(String[] args)throws IOException {
            //创建字节输出流,绑定文件
            //FileOutputStream fos = new FileOutputStream(&quot;c:\\buffer.txt&quot;);
            //创建字节输出流缓冲流的对象,构造方法中,传递字节输出流
            BufferedOutputStream bos = new
                    BufferedOutputStream(new FileOutputStream(&quot;c:\\buffer.txt&quot;));

            bos.write(55);

            byte[] bytes = &quot;HelloWorld&quot;.getBytes();

            bos.write(bytes);

            bos.write(bytes, 3, 2);

            bos.close();
        }
    }</code></pre><p>###09字节输入流缓冲流BufferedInputStream<br>    * A: 字节输入流缓冲流BufferedInputStream<br>        * a: BufferedInputStream<br>            * 字节输入流的缓冲流<br>            * 继承InputStream,标准的字节输入流<br>            * 读取方法  read() 单个字节,字节数组<br>            * 构造方法:<br>                * BufferedInputStream(InputStream in)<br>                * 可以传递任意的字节输入流,传递是谁,就提高谁的效率<br>                * 可以传递的字节输入流 FileInputStream<br>        * b: 案例代码<br>            public class BufferedInputStreamDemo {<br>                public static void main(String[] args) throws IOException{<br>                    //创建字节输入流的缓冲流对象,构造方法中包装字节输入流,包装文件<br>                    BufferedInputStream bis = new<br>                            BufferedInputStream(new FileInputStream(“c:\buffer.txt”));<br>                    byte[] bytes = new byte[10];<br>                    int len = 0 ;<br>                    while((len = bis.read(bytes))!=-1){<br>                        System.out.print(new String(bytes,0,len));<br>                    }<br>                    bis.close();<br>                }<br>            }</p>
<p>​<br>###10四种文件复制方式的效率比较<br>    * A：四种文件复制方式的效率比较<br>        * a: 四中复制方式<br>            * 字节流读写单个字节                    125250 毫秒<br>            * 字节流读写字节数组                    193    毫秒  OK<br>            * 字节流缓冲区流读写单个字节            1210   毫秒<br>            * 字节流缓冲区流读写字节数组            73     毫秒  OK        </p>
<pre><code>* b: 案例代码

    public class Copy {
        public static void main(String[] args)throws IOException {
            long s = System.currentTimeMillis();
            copy_4(new File(&quot;c:\\q.exe&quot;), new File(&quot;d:\\q.exe&quot;));
            long e = System.currentTimeMillis();
            System.out.println(e-s);
        }
        /*
         * 方法,实现文件复制
         *  4. 字节流缓冲区流读写字节数组
         */
        public static void copy_4(File src,File desc)throws IOException{
            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));
            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(desc));
            int len = 0 ;
            byte[] bytes = new byte[1024];
            while((len = bis.read(bytes))!=-1){
                bos.write(bytes,0,len);
            }
            bos.close();
            bis.close();
        }
        /*
         * 方法,实现文件复制
         *  3. 字节流缓冲区流读写单个字节
         */
        public static void copy_3(File src,File desc)throws IOException{
            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));
            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(desc));
            int len = 0 ;
            while((len = bis.read())!=-1){
                bos.write(len);
            }
            bos.close();
            bis.close();
        }

        /*
         * 方法,实现文件复制
         *  2. 字节流读写字节数组
         */
        public static void copy_2(File src,File desc)throws IOException{
            FileInputStream fis = new FileInputStream(src);
            FileOutputStream fos = new FileOutputStream(desc);
            int len = 0 ;
            byte[] bytes = new byte[1024];
            while((len = fis.read(bytes))!=-1){
                fos.write(bytes,0,len);
            }
            fos.close();
            fis.close();
        }

        /*
         * 方法,实现文件复制
         *  1. 字节流读写单个字节
         */
        public static void copy_1(File src,File desc)throws IOException{
            FileInputStream fis = new FileInputStream(src);
            FileOutputStream fos = new FileOutputStream(desc);
            int len = 0 ;
            while((len = fis.read())!=-1){
                fos.write(len);
            }
            fos.close();
            fis.close();
        }
    }</code></pre><p>​<br>###11字符输出流缓冲流BufferedWriter<br>    * A: 字符输出流缓冲流BufferedWriter<br>        * a: BufferedWriter<br>            * 字符输出流缓冲区流<br>            * java.io.BufferedWriter 继承 Writer<br>            * 写入方法 write () 单个字符,字符数组,字符串</p>
<pre><code>    * 构造方法:
        * BufferedWriter(Writer w)传递任意字符输出流
        * 传递谁,就高效谁
        * 能传递的字符输出流 FileWriter, OutputStreamWriter
* b: 案例代码
    public class BufferedWrierDemo {
        public static void main(String[] args) throws IOException{
            //创建字符输出流,封装文件
            FileWriter fw = new FileWriter(&quot;c:\\buffer.txt&quot;);
            BufferedWriter bfw = new BufferedWriter(fw);

            bfw.write(100);
            bfw.flush();
            bfw.write(&quot;你好&quot;.toCharArray());
            bfw.flush();</code></pre><p>​<br>                    bfw.write(“你好”);</p>
<pre><code>bfw.flush();</code></pre><p>​<br>                    bfw.write(“我好好”);</p>
<pre><code>        bfw.flush();

        bfw.write(&quot;大家都好&quot;);
        bfw.flush();

        bfw.close();

    }
}</code></pre><p>###12字符输出流缓冲流BufferedWriter特有方法newLine<br>    * A: 字符输出流缓冲流BufferedWriter特有方法newLine<br>        * a: 方法介绍<br>            * void  newLine() 写换行</p>
<pre><code>    * newLine()文本中换行, \r\n也是文本换行
    * 方法具有平台无关性
    * Windows  \r\n
    * Linux    \n

    * newLine()运行结果,和操作系统是相互关系
    * JVM: 安装的是Windows版本,newLine()写的就是\r\n
    * 安装的是Linux版本,newLine()写的就是\n
    /*
     *  将数据源 c:\\a.txt
     *  复制到 d:\\a.txt  数据目的
     *  字节输入流,绑定数据源
     *  字节输出流,绑定数据目的
     *  
     *  输入,读取1个字节
     *  输出,写1个字节
     */
* b: 案例代码
    public class BufferedWrierDemo {
        public static void main(String[] args) throws IOException{
            //创建字符输出流,封装文件
            FileWriter fw = new FileWriter(&quot;c:\\buffer.txt&quot;);
            BufferedWriter bfw = new BufferedWriter(fw);

            bfw.write(100);
            bfw.flush();
            bfw.write(&quot;你好&quot;.toCharArray());
            bfw.flush();

            bfw.write(&quot;你好&quot;);
            bfw.newLine();
            bfw.flush();</code></pre><p>​<br>                    bfw.write(“我好好”);<br>                    bfw.newLine();<br>                    bfw.flush();</p>
<pre><code>        bfw.write(&quot;大家都好&quot;);
        bfw.flush();

        bfw.close();

    }
}</code></pre><p>###13字符输入流缓冲流BufferedReader<br>    * A: 字符输入流缓冲流BufferedReader<br>        * a: 概述<br>            * 从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取<br>            * public String readLine() 读取一个文本行，包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null</p>
<p>###14字符输入流缓冲流BufferedReader读取文本行<br>    * A: 字符输入流缓冲流BufferedReader读取文本行<br>        * a: BufferedReader<br>            * 字符输入流缓冲流<br>            * java.io.BufferedReader 继承 Reader<br>            * 读取功能 read() 单个字符,字符数组<br>            * 构造方法:<br>                * BufferedReader(Reader r)<br>                * 可以任意的字符输入流<br>                   FileReader  InputStreamReader<br>            * BufferedReader自己的功能<br>                * String readLine() 读取文本行 \r\n<br>                    * 方法读取到流末尾,返回null<br>        * b: 小特点<br>             * 获取内容的方法一般都有返回值<br>             * int 没有返回的都是负数<br>             * 引用类型 找不到返回null<br>             * boolean 找不到返回false</p>
<pre><code>* c: 案例代码
    public class BufferedReaderDemo {
        public static void main(String[] args) throws IOException {
            int lineNumber = 0;
            //创建字符输入流缓冲流对象,构造方法传递字符输入流,包装数据源文件
            BufferedReader bfr = new BufferedReader(new FileReader(&quot;c:\\a.txt&quot;));
            //调用缓冲流的方法 readLine()读取文本行
            //循环读取文本行, 结束条件 readLine()返回null
            String line = null;
            while((line = bfr.readLine())!=null){
                lineNumber++;
                System.out.println(lineNumber+&quot;  &quot;+line);
            }
            bfr.close();
        }
    }

    /*
     * String line = bfr.readLine();
            System.out.println(line);

            line = bfr.readLine();
            System.out.println(line);

            line = bfr.readLine();
            System.out.println(line);

            line = bfr.readLine();
            System.out.println(line);

            line = bfr.readLine();
            System.out.println(line);
     */</code></pre><p>###15字符流缓冲区流复制文本文件<br>    * A: 字符流缓冲区流复制文本文件<br>        * a: 案例代码<br>            /*<br>             *  使用缓冲区流对象,复制文本文件<br>             *  数据源  BufferedReader+FileReader 读取<br>             *  数据目的 BufferedWriter+FileWriter 写入<br>             *  读取文本行, 读一行,写一行,写换行<br>             */<br>            public class Copy_1 {<br>                public static void main(String[] args) throws IOException{<br>                    BufferedReader bfr = new BufferedReader(new FileReader(“c:\w.log”));<br>                    BufferedWriter bfw = new BufferedWriter(new FileWriter(“d:\w.log”));<br>                    //读取文本行, 读一行,写一行,写换行<br>                    String line = null;<br>                    while((line = bfr.readLine())!=null){<br>                        bfw.write(line);<br>                        bfw.newLine();<br>                        bfw.flush();<br>                    }<br>                    bfw.close();<br>                    bfr.close();<br>                }<br>            }</p>
<p>​<br>###16IO流对象的操作规律<br>    * A: IO流对象的操作规律<br>        * a: 明确一：要操作的数据是数据源还是数据目的。<br>            * 源：InputStream    Reader<br>            * 目的：OutputStream Writer<br>            * 先根据需求明确要读，还是要写。</p>
<pre><code>* b: 明确二：要操作的数据是字节还是文本呢？
    * 源：
        * 字节：InputStream
        * 文本：Reader
    * 目的：
        * 字节：OutputStream
        * 文本：Writer
* c: 明确三：明确数据所在的具体设备。
    * 源设备：
        * 硬盘：文件  File开头。
        * 内存：数组，字符串。
        * 键盘：System.in;
        * 网络：Socket
    * 目的设备：
        * 硬盘：文件  File开头。
        * 内存：数组，字符串。
        * 屏幕：System.out
        * 网络：Socket
        * 完全可以明确具体要使用哪个流对象。
* d: 明确四：是否需要额外功能呢？
    * 额外功能：
        * 转换吗？转换流。InputStreamReader OutputStreamWriter
        * 高效吗？缓冲区对象。BufferedXXX
        * 已经明确到了具体的体系上。</code></pre><p>###17总结<br>    * 把今天的知识点总结一遍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/16/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/18/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">匡俊桦</p>
  <div class="site-description" itemprop="description">回忆的沙漏将曾经屈指可数的日子渐渐淡去</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">227</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">匡俊桦</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.7m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">25:36</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
