<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="KJH">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day18%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day18%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">day18笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-11 09:22:48" itemprop="dateModified" datetime="2019-01-11T09:22:48+08:00">2019-01-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、集合<br>2、Iterator迭代器<br>3、增强for循环<br>4、泛型</p>
<p>=======================第一节课开始=============================================</p>
<p>###01集合使用的回顾<br>     *A:集合使用的回顾<br>       *a.ArrayList集合存储5个int类型元素<br>          public static void main(String[] args) {<br>               ArrayList<Integer> list = new ArrayList<Integer>();<br>            list.add(111);<br>            list.add(222);<br>            list.add(333);<br>            list.add(444);<br>            list.add(555);<br>            for(int i=0; i&lt;list.size(); i++){<br>                   System.out.println(list.get(i));<br>           }<br>          }</Integer></Integer></p>
<pre><code>*b.ArrayList集合存储5个Person类型元素
   public static void main(String[] args) {
    ArrayList&lt;Person&gt; list = new ArrayList&lt;Person&gt;();
    list.add(new Person(“小强”));
    list.add(new Person(“老王”));
    list.add(new Person(“小虎”));
    list.add(new Person(“小泽”));
    list.add(new Person(“小红”));
    for(int i=0; i&lt;list.size(); i++){
      Person p = list.get(i);
            System.out.println(p);
     }
   }</code></pre><p>###02集合的学习目标<br>       集合，集合是java中提供的一种容器，可以用来存储多个数据。<br>     在前面的学习中，我们知道数据多了，可以使用数组存放或者使用ArrayList集合进行存放数据。那么，集合和数组既然都是容器，它们有啥区别呢？<br>       数组的长度是固定的。集合的长度是可变的。<br>       集合中存储的元素必须是引用类型数据</p>
<p>###03集合继承关系图<br>    A:集合继承关系图<br>     a:ArrayList的继承关系:<br>     查看ArrayList类发现它继承了抽象类AbstractList同时实现接口List，而List接口又继承了Collection接口。Collection接口为最顶层集合接口了。<br>     源代码：<br>      interface List extends Collection {<br>      }<br>      public class ArrayList extends AbstractList implements List{<br>      }</p>
<pre><code>b:集合继承体系
 这说明我们在使用ArrayList类时，该类已经把所有抽象方法进行了重写。那么，实现Collection接口的所有子类都会进行方法重写。
   Collecton接口常用的子接口有：List接口、Set接口
   List接口常用的子类有：ArrayList类、LinkedList类
   Set接口常用的子类有：HashSet类、LinkedHashSet类

                          Collection 接口     
                               |
 ----------------------------------------------------------------
 |                                                              |
List接口                                                       Set接口
 |                                                              |</code></pre><hr>
<p> |              |                                             |            |<br>ArrayList类    LinkedList类                                 HashSet类     LinkedHashSet类</p>
<p>###04集合Collection的方法<br>    A:集合Collection的方法<br>     /*<br>      *  Collection接口中的方法<br>      *  是集合中所有实现类必须拥有的方法<br>      *  使用Collection接口的实现类,程序的演示<br>      *  ArrayList implements List<br>      *  List extends Collection<br>      *  方法的执行,都是实现的重写<br>      */<br>     public class CollectionDemo {<br>      public static void main(String[] args) {<br>        function_2();<br>      }</p>
<pre><code> /*  Collection接口方法
  *  Object[] toArray() 集合中的元素,转成一个数组中的元素, 集合转成数组
  *  返回是一个存储对象的数组, 数组存储的数据类型是Object
  */
 private static void function_2() {
   Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();
   coll.add(&quot;abc&quot;);
   coll.add(&quot;itcast&quot;);
   coll.add(&quot;itheima&quot;);
   coll.add(&quot;money&quot;);
   coll.add(&quot;123&quot;);

   Object[] objs = coll.toArray();
   for(int i = 0 ; i &lt; objs.length ; i++){
     System.out.println(objs[i]);
   }
 }
 /*
  * 学习Java中三种长度表现形式
  *   数组.length 属性  返回值 int
  *   字符串.length() 方法,返回值int
  *   集合.size()方法, 返回值int
  */

 /*
  * Collection接口方法
  * boolean contains(Object o) 判断对象是否存在于集合中,对象存在返回true
  * 方法参数是Object类型
  */
 private static void function_1() {
   Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();
   coll.add(&quot;abc&quot;);
   coll.add(&quot;itcast&quot;);
   coll.add(&quot;itheima&quot;);
   coll.add(&quot;money&quot;);
   coll.add(&quot;123&quot;);

   boolean b = coll.contains(&quot;itcast&quot;);
   System.out.println(b);
 }


 /*
  * Collection接口的方法
  * void clear() 清空集合中的所有元素
  * 集合容器本身依然存在
  */
 public static void function(){
   //接口多态的方式调用
   Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();
   coll.add(&quot;abc&quot;);
   coll.add(&quot;bcd&quot;);
   System.out.println(coll);

   coll.clear();

   System.out.println(coll);

 }
}</code></pre><p>###05集合Collection的remove方法<br>   A:05集合Collection的remove方法<br>    /*<br>     * Collection接口方法<br>     * boolean remove(Object o)移除集合中指定的元素<br>     */<br>    private static void function_3(){<br>      Collection<String> coll = new ArrayList<String>();<br>      coll.add(“abc”);<br>      coll.add(“money”);<br>      coll.add(“itcast”);<br>      coll.add(“itheima”);<br>      coll.add(“money”);<br>      coll.add(“123”);<br>      System.out.println(coll);</String></String></p>
<pre><code>  boolean b = coll.remove(&quot;money&quot;);
  System.out.println(b);
  System.out.println(coll);
}</code></pre><p>=======================第二节课开始=============================================<br>###06迭代器的概述<br>  A:迭代器概述:<br>   a:java中提供了很多个集合，它们在存储元素时，采用的存储方式不同。<br>    我们要取出这些集合中的元素，可通过一种通用的获取方式来完成。</p>
<p>   b:Collection集合元素的通用获取方式：在取元素之前先要判断集合中有没有元素，<br>  如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</p>
<p>   c:每种集合的底层的数据结构不同,例如ArrayList是数组,LinkedList底层是链表,但是无论使用那种集合,我们都会有判断是否有元素<br>     以及取出里面的元素的动作,那么Java为我们提供一个迭代器定义了统一的判断元素和取元素的方法 </p>
<p>###07迭代器的实现原理<br>   <em>A:迭代器的实现原理<br>      /</em><br>     *  集合中的迭代器:<br>     *    获取集合中元素方式<br>     *  接口 Iterator : 两个抽象方法<br>     *     boolean hasNext() 判断集合中还有没有可以被取出的元素,如果有返回true<br>     *     next() 取出集合中的下一个元素<br>     *<br>     *  Iterator接口,找实现类.<br>     *    Collection接口定义方法<br>     *       Iterator  iterator()<br>     *    ArrayList 重写方法 iterator(),返回了Iterator接口的实现类的对象<br>     *    使用ArrayList集合的对象<br>     *     Iterator it =array.iterator(),运行结果就是Iterator接口的实现类的对象<br>     *     it是接口的实现类对象,调用方法 hasNext 和 next 集合元素迭代<br>     */</p>
<p>###08迭代器的代码实现<br>   *A:迭代器的代码实现<br>      public class IteratorDemo {<br>        public static void main(String[] args) {<br>          Collection<String> coll = new ArrayList<String>();<br>          coll.add(“abc1”);<br>          coll.add(“abc2”);<br>          coll.add(“abc3”);<br>          coll.add(“abc4”);<br>          //迭代器,对集合ArrayList中的元素进行取出</String></String></p>
<pre><code>    //调用集合的方法iterator()获取出,Iterator接口的实现类的对象
    Iterator&lt;String&gt; it = coll.iterator();
    //接口实现类对象,调用方法hasNext()判断集合中是否有元素
    //boolean b = it.hasNext();
    //System.out.println(b);
    //接口的实现类对象,调用方法next()取出集合中的元素
    //String s = it.next();
    //System.out.println(s);

    //迭代是反复内容,使用循环实现,循环的条件,集合中没元素, hasNext()返回了false
    while(it.hasNext()){
      String s = it.next();
      System.out.println(s);
    }



  }
}</code></pre><p>###09迭代器的执行过程<br>   A:迭代器的执行过程<br>     a:迭代器的原理:<br>       while(it.hasNext()) {<br>            System.out.println(it.next());<br>       }</p>
<pre><code>  //cursor记录的索引值不等于集合的长度返回true,否则返回false
    public boolean hasNext() {       
      return cursor != size; //cursor初值为0

    }

   //next()方法作用:
   //①返回cursor指向的当前元素 
   //②cursor++
   public Object next() {            
            int i = cursor; 
            cursor = i + 1;  
            return  elementData[lastRet = i]; 

        }
b:for循环迭代写法:
   for (Iterator&lt;String&gt; it2 = coll.iterator(); it2.hasNext();  ) {
    System.out.println(it2.next());
  } </code></pre><p>###10集合迭代中的转型<br>   A:集合迭代中的转型<br>     a:在使用集合时，我们需要注意以下几点：<br>       集合中存储其实都是对象的地址。<br>       集合中可以存储基本数值吗？jdk1.5版本以后可以存储了。<br>         因为出现了基本类型包装类，它提供了自动装箱操作（基本类型对象），这样，集合中的元素就是基本数值的包装类对象。</p>
<pre><code>b:存储时提升了Object。取出时要使用元素的特有内容，必须向下转型。
 Collection coll = new ArrayList();
 coll.add(&quot;abc&quot;);
 coll.add(&quot;aabbcc&quot;);
 coll.add(&quot;shitcast&quot;);
 Iterator it = coll.iterator();
 while (it.hasNext()) {
  //由于元素被存放进集合后全部被提升为Object类型
 //当需要使用子类对象特有方法时，需要向下转型
  String str = (String) it.next();
  System.out.println(str.length());
 }
 注意：如果集合中存放的是多个对象，这时进行向下转型会发生类型转换异常。


c:Iterator接口也可以使用&lt;&gt;来控制迭代元素的类型的。代码演示如下：
 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();
 coll.add(&quot;abc&quot;);
 coll.add(&quot;aabbcc&quot;);
 coll.add(&quot;shitcast&quot;);
 Iterator&lt;String&gt; it = coll.iterator();
 while (it.hasNext()) {
  String str =  it.next(); 
 //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型
  System.out.println(str.length());
 }</code></pre><p>=========================第三节课开始====================================<br>###11增强for循环遍历数组<br>   <em>A:增强for循环遍历数组<br>     a:格式:<br>     /</em><br>      *  JDK1.5新特性,增强for循环<br>      *  JDK1.5版本后,出现新的接口 java.lang.Iterable<br>      *    Collection开是继承Iterable<br>      *    Iterable作用,实现增强for循环<br>      *<br>      *    格式:<br>      *      for( 数据类型  变量名 : 数组或者集合 ){<br>      *         sop(变量);<br>      *      }<br>      */<br>     public static void function_1(){<br>        //for对于对象数组遍历的时候,能否调用对象的方法呢<br>        String[] str = {“abc”,”itcast”,”cn”};<br>        for(String s : str){<br>          System.out.println(s.length());<br>        }<br>      }</p>
<pre><code>/*
 *  实现for循环,遍历数组
 *  好处: 代码少了,方便对容器遍历
 *  弊端: 没有索引,不能操作容器里面的元素
 */
public static void function(){
  int[] arr = {3,1,9,0};
  for(int i : arr){
    System.out.println(i+1);
  }
  System.out.println(arr[0]);
}</code></pre><p>###12增强for循环遍历集合<br>      A:增强for循环遍历集合<br>        /*<br>         *  增强for循环遍历集合<br>         *  存储自定义Person类型<br>         */<br>        public static void function_2(){<br>          ArrayList<Person> array = new ArrayList<Person>();<br>          array.add(new Person(“a”,20));<br>          array.add(new Person(“b”,10));<br>          for(Person p : array){<br>            System.out.println(p);// System.out.println(p.toString());<br>          }<br>        }</Person></Person></p>
<p>###13泛型的引入<br>   A:泛型的引入<br>    在前面学习集合时，我们都知道集合中是可以存放任意对象的，<br>    只要把对象存储集合后，那么这时他们都会被提升成Object类型。<br>    当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。比如下面程序：<br>    public class GenericDemo {<br>      public static void main(String[] args) {<br>        List list = new ArrayList();<br>        list.add(“abc”);<br>        list.add(“itcast”);<br>        list.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放<br>                    //相当于:Object obj=new Integer(5);</p>
<pre><code>    Iterator it = list.iterator();
    while(it.hasNext()){
      //需要打印每个字符串的长度,就要把迭代出来的对象转成String类型
      String str = (String) it.next();//String str=(String)obj;
                                      //编译时期仅检查语法错误,String是Object的儿子可以向下转型
                                      //运行时期String str=(String)(new Integer(5))
                                      //String与Integer没有父子关系所以转换失败
                                      //程序在运行时发生了问题java.lang.ClassCastException
      System.out.println(str.length());
    }
  }
}</code></pre><p>###14泛型的定义和使用<br>  A:泛型的定义和使用<br>    /*<br>     * JDK1.5 出现新的安全机制,保证程序的安全性<br>     *   泛型: 指明了集合中存储数据的类型  &lt;数据类型&gt;<br>     */</p>
<pre><code>public class GenericDemo {
  public static void main(String[] args) {
    function();
  }

  public static void function(){
    Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();
    coll.add(&quot;abc&quot;);
    coll.add(&quot;rtyg&quot;);
    coll.add(&quot;43rt5yhju&quot;);
//    coll.add(1);

    Iterator&lt;String&gt; it = coll.iterator();
    while(it.hasNext()){
      String s = it.next();
      System.out.println(s.length());
    }
  }
}</code></pre><p>###15Java中的伪泛型<br>     A:Java中的伪泛型：<br>       泛型只在编译时存在,编译后就被擦除,在编译之前我们就可以限制集合的类型,起到作用<br>     例如:ArrayList<String> al=new ArrayList<String>();<br>     编译后:ArrayList al=new ArrayList();</String></String></p>
<p>================================第四节课开始======================================================<br>###16泛型类<br>  A:泛型类:<br>    a:定义格式：<br>      修饰符 class 类名&lt;代表泛型的变量&gt; {  }</p>
<pre><code>  例如，API中的ArrayList集合：
  class ArrayList&lt;E&gt;{ 
       public boolean add(E e){ }
    public E get(int index){  }
  }

b:使用格式：
  创建对象时，确定泛型的类型

  例如，ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
  此时，变量E的值就是String类型
  class ArrayList&lt;String&gt;{ 
    public boolean add(String e){ }
    public String get(int index){  }
  }

  例如，ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
  此时，变量E的值就是Integer类型
  class ArrayList&lt;Integer&gt;{ 
       public boolean add(Integer e){ }
       public Integer get(int index){  }
  }</code></pre><p>###17泛型的方法<br>  A:泛型的方法<br>    a:定义格式：修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数){  }<br>    b:泛型方法的使用:<br>     1:例如，API中的ArrayList集合中的方法：<br>      public <T> T[] toArray(T[] a){  }<br>      //该方法，用来把集合元素存储到指定数据类型的数组中，返回已存储集合元素的数组</T></p>
<pre><code>  使用格式：调用方法时，确定泛型的类型
例如:
      ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
      String[] arr = new String[100];
      String[] result = list.toArray(arr);
   此时，变量T的值就是String类型。变量T，可以与定义集合的泛型不同
   public &lt;String&gt; String[] toArray(String[] a){  } 


  例如:
      ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
      Integer[] arr = new Integer[100];
      Integer [] result = list.toArray(arr);

  此时，变量T的值就是Integer类型。变量T，可以与定义集合的泛型不同
  public &lt;Integer&gt; Integer[] toArray(Integer[] a){  } </code></pre><p>###18泛型的接口<br>   A:泛型的接口:<br>     /*<br>      *  带有泛型的接口<br>      *<br>      *  public interface List <E>{<br>      *    abstract boolean add(E e);<br>      *  }<br>      *<br>      *  实现类,先实现接口,不理会泛型<br>      *  public class ArrayList<E> implements List<E>{<br>      *  }<br>      *  调用者 : new ArrayList<String>() 后期创建集合对象的时候,指定数据类型<br>      *<br>      *<br>      *  实现类,实现接口的同时,也指定了数据类型<br>      *  public class XXX implements List<String>{<br>      *  }<br>      *  new XXX()<br>      */<br>     public class GenericDemo2 {</String></String></E></E></E></p>
<pre><code>}</code></pre><p>###19泛型的好处<br>  A:泛型的好处<br>    a:将运行时期的ClassCastException，转移到了编译时期变成了编译失败。<br>    b:避免了类型强转的麻烦。<br>    演示下列代码：<br>    public class GenericDemo {<br>      public static void main(String[] args) {<br>        List<String> list = new ArrayList<String>();<br>        list.add(“abc”);<br>        list.add(“itcast”);<br>        //list.add(5);//当集合明确类型后，存放类型不一致就会编译报错<br>                     //集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</String></String></p>
<pre><code>    Iterator&lt;String&gt; it = list.iterator();
    while(it.hasNext()){
       String str = it.next();
       System.out.println(str.length()); //当使用Iterator&lt;String&gt;      
                                        //控制元素类型后，就不需要强转了。获取到的元素直接就是String类型
    }
  }
}</code></pre><p>###20泛型的通配符<br>   A:泛型的通配符<br>   /*<br>    *  泛型的通配符<br>    */<br>   public class GenericDemo {<br>    public static void main(String[] args) {<br>      ArrayList<String> array = new ArrayList<String>();</String></String></p>
<pre><code>  HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();

  array.add(&quot;123&quot;);
  array.add(&quot;456&quot;);

  set.add(789);
  set.add(890);

  iterator(array);
  iterator(set);
}
/*
 *  定义方法,可以同时迭代2个集合
 *  参数: 怎么实现 , 不能写ArrayList,也不能写HashSet
 *  参数: 或者共同实现的接口
 *  泛型的通配,匹配所有的数据类型  ?
 */
public static void iterator(Collection&lt;?&gt; coll){
  Iterator&lt;?&gt; it = coll.iterator();
  while(it.hasNext()){
    //it.next()获取的对象,什么类型
    System.out.println(it.next());
  }
}</code></pre><p>   }</p>
<p>###21泛型的限定<br> A:泛型的限定<br>   /*<br>    *  将的酒店员工,厨师,服务员,经理,分别存储到3个集合中<br>    *  定义方法,可以同时遍历3集合,遍历三个集合的同时,可以调用工作方法<br>    */<br>   import java.util.ArrayList;<br>   import java.util.Iterator;<br>   public class GenericTest {<br>    public static void main(String[] args) {<br>      //创建3个集合对象<br>      ArrayList<ChuShi> cs = new ArrayList<ChuShi>();<br>      ArrayList<FuWuYuan> fwy = new ArrayList<FuWuYuan>();<br>      ArrayList<JingLi> jl = new ArrayList<JingLi>();</JingLi></JingLi></FuWuYuan></FuWuYuan></ChuShi></ChuShi></p>
<pre><code>//每个集合存储自己的元素
cs.add(new ChuShi(&quot;张三&quot;, &quot;后厨001&quot;));
cs.add(new ChuShi(&quot;李四&quot;, &quot;后厨002&quot;));

fwy.add(new FuWuYuan(&quot;翠花&quot;, &quot;服务部001&quot;));
fwy.add(new FuWuYuan(&quot;酸菜&quot;, &quot;服务部002&quot;));

jl.add(new JingLi(&quot;小名&quot;, &quot;董事会001&quot;, 123456789.32));
jl.add(new JingLi(&quot;小强&quot;, &quot;董事会002&quot;, 123456789.33));</code></pre><p>   //   ArrayList<String> arrayString = new ArrayList<String>();<br>      iterator(jl);<br>      iterator(fwy);<br>      iterator(cs);</String></String></p>
<pre><code>}
/*
 * 定义方法,可以同时遍历3集合,遍历三个集合的同时,可以调用工作方法 work
 * ? 通配符,迭代器it.next()方法取出来的是Object类型,怎么调用work方法
 * 强制转换:  it.next()=Object o ==&gt; Employee
 * 方法参数: 控制,可以传递Employee对象,也可以传递Employee的子类的对象
 * 泛型的限定  本案例,父类固定Employee,但是子类可以无限?
 *   ? extends Employee 限制的是父类, 上限限定, 可以传递Employee,传递他的子类对象
 *   ? super   Employee 限制的是子类, 下限限定, 可以传递Employee,传递他的父类对象
 */
public static void iterator(ArrayList&lt;? extends Employee&gt; array){

   Iterator&lt;? extends Employee&gt; it = array.iterator();
   while(it.hasNext()){
     //获取出的next() 数据类型,是什么Employee
     Employee e = it.next();
     e.work();
   }
}</code></pre><p>   }</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day17%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day17%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">day17笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-11 09:22:48" itemprop="dateModified" datetime="2019-01-11T09:22:48+08:00">2019-01-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、基本类型包装类<br>2、System类<br>3、Math类<br>4、Arrays类<br>5、大数据运算</p>
<p>=======================第一节课开始=============================================</p>
<p>###01基本数据类型对象包装类概述<br>     *A:基本数据类型对象包装类概述<br>       *a.基本类型包装类的产生<br>           在实际程序使用中，程序界面上用户输入的数据都是以字符串类型进行存储的。而程序开发中，我们需要把字符串数据，根据需求转换成指定的基本数据类型，如年龄需要转换成int类型，考试成绩需要转换成double类型等<br>       *b.八种基本类型对应的包装类<br>           char    Character<br>           int     Integer<br>           byte    Byte<br>           short   Short<br>           long    Long<br>           float   Float<br>           double  Double<br>           boolean Boolean</p>
<p>###02Integer类parseInt方法<br>       *A:Integer类parseInt方法:<br>        *a:parseInt()<br>            int i = Integer.parseInt(“12”);<br>            System.out.println(i/2);//6</p>
<pre><code>*b:parseInt(String s, int radix)
    /*
      * Integer类静态方法parseInt(String s, int radix)
      * radix基数,进制
      * &quot;110&quot;,2 含义 前面的数字是二进制的,但是方法parseInt运行结果都是十进制
      *  指定进制的字符串转换为十进制的整数
      */
     public static void function_1(){
         int i = Integer.parseInt(&quot;110&quot;, 2);
         System.out.println(i);
     }</code></pre><p>###03Integer类int转成字符串<br>    *A:Integer类int转成字符串:<br>       *a:使用+与字符串拼接<br>            int i = 3;<br>              String s = i+””;<br>              System.out.println(s+1);//“31”</p>
<pre><code>*b:toString(int ,int 进制),任意进制整数转成任意进制的字符串 (了解)
       String s1 = Integer.toString(5,2);
       System.out.println(s1);</code></pre><p>###04Integer类构造方法<br>     <em>A:Integer类构造方法<br>        /</em><br>         *  Integer类构造方法<br>         *   Integer (String s)<br>         *   将数字格式的字符串,传递到Integer类的构造方法中<br>         *   创建Integer对象,包装的是一个字符串<br>         *   将构造方法中的字符串,转成基本数据类型,调用方法,非静态的, intValue()<br>         */<br>        public static void function_3(){<br>            Integer in = new Integer(“100”);<br>            int i = in.intValue();<br>            System.out.println(–i);//99<br>        }</p>
<p>###05Integer类其他方法<br>   <em>A:Integer类其他方法<br>         /</em><br>         * Integer类的3个静态方法<br>         * 做进制的转换<br>         * 十进制转成二进制  toBinarString(int)<br>         * 十进制转成八进制  toOctalString(int)<br>         * 十进制转成十六进制 toHexString(int)<br>         * 三个方法,返回值都是以String形式出现<br>         <em>/<br>          a:十进制转二,八,十六进制<br>              public static void function_1(){<br>                    System.out.println(Integer.toBinaryString(99));<br>                    System.out.println(Integer.toOctalString(99));<br>                    System.out.println(Integer.toHexString(999));<br>              }<br>          b:获取int的最大值和最小值<br>          /</em><br>           *   Integer类的静态成员变量<br>           *   MAX_VALUE<br>           *   MIN_VALUE<br>           */<br>          public static void function(){<br>              System.out.println(Integer.MAX_VALUE);<br>              System.out.println(Integer.MIN_VALUE);<br>          }</p>
<p>###06自动装箱和自动拆箱<br>  *A:自动装箱与自动拆箱:<br>    //JDK1.5新特性<br>    //自动装箱,拆箱的 好处: 基本类型和引用类直接运算<br>    //自动装箱:使用Integer.valueOf(整数值)返回一个封装了该整数值的Integer对象<br>    //自动拆箱:使用Integer对象.intValue()返回Integer对象中封装的整数值<br>    public static void function(){<br>        //引用类型 , 引用变量一定指向对象<br>        //自动装箱, 基本数据类型1, 直接变成了对象</p>
<pre><code>    Integer in = 1; // Integer in = new Integer(1)
    //in 是引用类型,不能和基本类型运算, 自动拆箱,引用类型in,转换基本类型

    //in+1  ==&gt; in.inValue()+1 = 2    
    //in = 2    自动装箱
    in = in + 1;

    System.out.println(in);

}</code></pre><p>###07自动装箱和自动拆箱练习题<br>   *A:自动装箱与自动拆箱:<br>        Integer i = new Integer(1);<br>         Integer j = new Integer(1);<br>         System.out.println(i==j);// false 对象地址<br>         System.out.println(i.equals(j));// true  继承Object重写equals,比较的对象数据</p>
<pre><code>System.out.println(&quot;===================&quot;);

Integer a = 500;//Integer integer=Integer.valueOf(500)
                //integer=new Integer(500);
Integer b = 500;
System.out.println(a==b);//false
System.out.println(a.equals(b));//true

System.out.println(&quot;===================&quot;);


//数据在byte(-128~127)范围内,JVM不会从新new对象
Integer aa = 127; // Integer aa = new Integer(127)
Integer bb = 127; // Integer bb = aa;
System.out.println(aa==bb); //true
System.out.println(aa.equals(bb));//true</code></pre><p>=========================第二节课开始====================================<br>###08System类方法currentTimeMillis<br>   <em>A:System类方法currentTimeMillis():用于计算程序的执行时间<br>        /</em><br>           *  获取系统当前毫秒值<br>           *  static long currentTimeMillis()<br>           *  对程序执行时间测试<br>           */<br>          public static void function(){<br>              long start = System.currentTimeMillis();//当前时间x-1970年1月1日零时零分零秒<br>              for(int i = 0 ; i &lt; 10000; i++){<br>                  System.out.println(i);<br>              }<br>              long end = System.currentTimeMillis();//当前时间y-1970年1月1日零时零分零秒<br>              System.out.println(end - start);//当前时间y-当前时间x<br>          }</p>
<p>###09System类方法exit<br>     <em>A:System类方法exit()方法<br>             /</em><br>              *  退出虚拟机,所有程序全停止<br>              *  static void exit(0)<br>              */<br>             public static void function_1(){<br>                 while(true){<br>                     System.out.println(“hello”);<br>                     System.exit(0);//该方法会在以后的finally代码块中使用(讲到再说)<br>                 }<br>             }<br>###10System类方法gc<br>   A:System类方法gc<br>        public class Person {<br>            public void finalize(){<br>                System.out.println(“垃圾收取了”);<br>            }<br>        }</p>
<pre><code>/*
  *  JVM在内存中,收取对象的垃圾
  *  当没有更多引用指向该对象时,会自动调用垃圾回收机制回收堆中的对象
  *  同时调用回收对象所属类的finalize方法()
  *  static void gc()
  */
 public static void function_2(){
     new Person();
     new Person();
     new Person();
     new Person();
     new Person();
     new Person();
     new Person();
     new Person();
     System.gc();
 }</code></pre><p>###11System类方法getProperties<br>  A:System类方法getProperties(了解)<br>     /*<br>      *  获取当前操作系统的属性:例如操作系统名称,<br>      *  static Properties getProperties()<br>      */<br>     public static void function_3(){<br>         System.out.println( System.getProperties() );<br>     }</p>
<p>###12System类方法arraycopy<br>     A:System类方法arraycopy：<br>      /*<br>       * System类方法,复制数组<br>       * arraycopy(Object src, int srcPos, Object dest, int destPos, int length)<br>       * Object src, 要复制的源数组<br>       * int srcPos, 数组源的起始索引<br>       * Object dest,复制后的目标数组<br>       * int destPos,目标数组起始索引<br>       * int length, 复制几个<br>       */<br>      public static void function_4(){<br>          int[] src = {11,22,33,44,55,66};<br>          int[] desc = {77,88,99,0};</p>
<pre><code>    System.arraycopy(src, 1, desc, 1, 2);//将src数组的1位置开始(包含1位置)的两个元素,拷贝到desc的1,2位置上
    for(int i = 0 ;  i &lt; desc.length ; i++){
        System.out.println(desc[i]);
    }
}</code></pre><p>================================第三节课开始======================================================<br>###13Math类的方法_1<br>   A:Math类中的方法<br>   /*<br>        * static double sqrt(double d)<br>        * 返回参数的平方根<br>        */<br>       public static void function_4(){<br>           double d = Math.sqrt(-2);<br>           System.out.println(d);<br>       }</p>
<pre><code>/*0
 * static double pow(double a, double b)
 * a的b次方
 */
public static void function_3(){
    double d = Math.pow(2, 3);
    System.out.println(d);
}

/*
 * static double floor(double d)
 * 返回小于或者等于参数d的最大整数
 */
public static void function_2(){
    double d = Math.floor(1.5);
    System.out.println(d);
}

/*
 *  static double ceil(double d)
 *  返回大于或者等于参数d的最小整数
 */
public static void function_1(){
    double d = Math.ceil(5.1);
    System.out.println(d);
}

/*
 *  static int abs(int i)
 *  获取参数的绝对值
 */
 public static void function(){
    int i = Math.abs(0);
    System.out.println(i);
 }</code></pre><p>###14Math类的方法_2<br> A:Math类的方法_2<br>  /*</p>
<ul>
<li><p>static double round(doubl d)</p>
</li>
<li><p>获取参数的四舍五入,取整数</p>
</li>
<li><p>/<br>public static void function_6(){<br>  double d = Math.round(5.4195);<br>  System.out.println(d);<br>}</p>
<p>/*</p>
</li>
<li><p>static double random() 返回随机数 0.0-1.0之间</p>
</li>
<li><p>来源,也是Random类</p>
</li>
<li><p>/<br>public static void function_5(){<br>  for(int i = 0 ; i &lt; 10 ;i++){</p>
<pre><code>double d = Math.random();
System.out.println(d);</code></pre><p>  }<br>}</p>
</li>
</ul>
<p>###15Arrays工具类<br>  A:Arrays工具类:<br>    public class ArraysDemo {<br>        public static void main(String[] args) {<br>            function_2();<br>            int[] arr = {56,65,11,98,57,43,16,18,100,200};<br>            int[] newArray = test(arr);<br>            System.out.println(Arrays.toString(newArray));<br>        }<br>        /*<br>         *  定义方法,接收输入,存储的是10个人考试成绩<br>         *  将最后三个人的成绩,存储到新的数组中,返回新的数组<br>         */<br>        public static int[] test(int[] arr){<br>            //对数组排序<br>            Arrays.sort(arr);<br>            //将最后三个成绩存储到新的数组中<br>            int[] result = new int[3];<br>            //成绩数组的最后三个元素,复制到新数组中<br>        //    System.arraycopy(arr, 0, result, 0, 3);<br>            for(int i = 0 ;  i &lt; 3 ;i++){<br>                result[i] = arr[i];<br>            }<br>            return result;<br>        }</p>
<pre><code>    /*
     *  static String toString(数组)
     *  将数组变成字符串
     */
    public static void function_2(){
        int[] arr = {5,1,4,6,8,9,0};
        String s = Arrays.toString(arr);
        System.out.println(s);
    }

    /*
     *  static int binarySearch(数组, 被查找的元素)
     *  数组的二分搜索法
     *  返回元素在数组中出现的索引
     *  元素不存在, 返回的是  (-插入点-1)
     */
    public static void function_1(){
        int[] arr = {1,4,7,9,11,15,18};
        int index =  Arrays.binarySearch(arr, 10);
        System.out.println(index);
    }

    /*
     *  static void sort(数组)
     *  对数组升序排列
     */
    public static void function(){
        int[] arr = {5,1,4,6,8,9,0};
        Arrays.sort(arr);
        for (int i = 0; i &lt; arr.length; i++) {
            System.out.println(arr[i]);
        }
    }
}</code></pre><p>###16数组复制练习<br>   <em>A:数组复制练习:<br>        public static void main(String[] args) {<br>                int[] arr = {56,65,11,98,57,43,16,18,100,200};<br>                int[] newArray = test(arr);<br>                System.out.println(Arrays.toString(newArray));<br>            }<br>            /</em><br>             *  定义方法,接收输入,存储的是10个人考试成绩<br>             *  将最后三个人的成绩,存储到新的数组中,返回新的数组<br>             */<br>            public static int[] test(int[] arr){<br>                //对数组排序<br>                Arrays.sort(arr);<br>                //将最后三个成绩存储到新的数组中<br>                int[] result = new int[3];<br>                //成绩数组的最后三个元素,复制到新数组中<br>                //System.arraycopy(arr, 0, result, 0, 3);<br>                for(int i = 0 ;  i &lt; 3 ;i++){<br>                    result[i] = arr[i];<br>                }<br>                return result;<br>            }</p>
<p>====================第四节课开始============================<br>###17BigInteger类概述和构造方法<br> A:BigInteger类概述和构造方法<br>   public static void main(String[] args) {<br>           function();<br>       }<br>    /*<br>        * BigInteger类的构造方法<br>        * 传递字符串,要求数字格式,没有长度限制<br>        */<br>       public static void function(){<br>           BigInteger b = new BigInteger(“8465846668464684562385634168451684568645684564564”);<br>           System.out.println(b);<br>           BigInteger b1 = new BigInteger(“5861694569514568465846668464684562385634168451684568645684564564”);<br>           System.out.println(b1);<br>       }</p>
<p>###18BigInteger类四则运算<br> A:BigInteger类四则运算<br>    public static void main(String[] args) {<br>           function_1();<br>       }<br>    /*<br>     * BigInteger对象的四则运算<br>     * 调用方法计算,计算结果也只能是BigInteger对象<br>     */<br>     public static void function_1(){<br>         BigInteger b1 = new BigInteger(“5665464516451051581613661405146”);<br>         BigInteger b2 = new BigInteger(“965855861461465516451051581613661405146”);</p>
<pre><code>    //计算 b1+b2对象的和,调用方法 add
    BigInteger bigAdd = b1.add(b2);//965855867126930032902103163227322810292
    System.out.println(bigAdd);

    //计算b1-b2对象的差,调用方法subtract
    BigInteger bigSub = b1.subtract(b2);
    System.out.println(bigSub);

    //计算b1*b2对象的乘积,调用方法multiply
    BigInteger bigMul = b1.multiply(b2);
    System.out.println(bigMul);

    //计算b2/b1对象商,调用方法divied
    BigInteger bigDiv = b2.divide(b1);
    System.out.println(bigDiv);
}</code></pre><p>###19员工案例的子类的编写<br> A:BigDecimal类概述 </p>
<pre><code>/*
 * 计算结果,未知
 * 原因: 计算机二进制中,表示浮点数不精确造成
 * 超级大型的浮点数据,提供高精度的浮点运算, BigDecimal
System.out.println(0.09 + 0.01);//0.09999999999999999
System.out.println(1.0 - 0.32);//0.6799999999999999
System.out.println(1.015 * 100);//101.49999999999999
System.out.println(1.301 / 100);//0.013009999999999999 
*/</code></pre><p>###20BigDecimal类实现加法减法乘法<br> A:BigDecimal类实现加法减法乘法<br>  /*<br>       *  BigDecimal实现三则运算<br>       *  + - *<br>       */<br>      public static void function(){<br>          BigDecimal b1 =  new BigDecimal(“0.09”);<br>          BigDecimal b2 =  new BigDecimal(“0.01”);<br>          //计算b1+b2的和,调用方法add<br>          BigDecimal bigAdd = b1.add(b2);<br>          System.out.println(bigAdd);</p>
<pre><code>    BigDecimal b3 = new BigDecimal(&quot;1&quot;);
    BigDecimal b4 = new BigDecimal(&quot;0.32&quot;);
    //计算b3-b2的差,调用方法subtract
    BigDecimal bigSub = b3.subtract(b4);
    System.out.println(bigSub);

    BigDecimal b5 = new BigDecimal(&quot;1.015&quot;);
    BigDecimal b6 = new BigDecimal(&quot;100&quot;);
    //计算b5*b6的成绩,调用方法 multiply
    BigDecimal bigMul = b5.multiply(b6);
    System.out.println(bigMul);
}</code></pre><p>###21BigDecimal类实现除法<br>     A:BigDecimal类实现除法<br>     /*<br>      * BigDecimal实现除法运算<br>      * divide(BigDecimal divisor, int scale, int roundingMode)<br>      * int scale : 保留几位小数<br>      * int roundingMode : 保留模式<br>      * 保留模式 阅读API文档<br>      *   static int ROUND_UP  向上+1<br>      *   static int ROUND_DOWN 直接舍去<br>      *   static int ROUND_HALF_UP  &gt;= 0.5 向上+1<br>      *   static int ROUND_HALF_DOWN   &gt; 0.5 向上+1 ,否则直接舍去<br>      */<br>     public static void function_1(){<br>         BigDecimal b1 = new BigDecimal(“1.0301”);<br>         BigDecimal b2 = new BigDecimal(“100”);<br>         //计算b1/b2的商,调用方法divied<br>         BigDecimal bigDiv = b1.divide(b2,2,BigDecimal.ROUND_HALF_UP);//0.01301<br>         System.out.println(bigDiv);<br>     }</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day16%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day16%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">day16笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-11 09:22:47" itemprop="dateModified" datetime="2019-01-11T09:22:47+08:00">2019-01-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、正则表达式的定义及使用<br>2、Date类的用法<br>3、Calendar类的用法</p>
<p>==========================================第一阶段========================================</p>
<p>###01正则表达式的概念和作用<br>    * A: 正则表达式的概念和作用<br>        * a: 正则表达式的概述<br>            * 正则表达式也是一个字符串，用来定义匹配规则，在Pattern类中有简单的规则定义。<br>              可以结合字符串类的方法使用。<br>            * 简单记：正则表达式是具有特殊含义的字符串。<br>        * b: 正则表达式的作用<br>        * 比如注册邮箱,邮箱有用户名和密码,一般会对其限制长度,这个限制长度的事情就是正则表达式做的</p>
<p>###02正则表达式语法规则<br>    * A: 正则表达式语法规则<br>        * a: 字符<br>            * x  代表的是字符x<br>            * \ 代表的是反斜线字符’&#39;<br>            * \t 代表的是制表符<br>            * \n 代表的是换行符<br>            * \r 代表的是回车符<br>        * b: 字符类<br>            * [abc]    a、b 或 c（简单类）<br>            * [^abc]   任何字符，除了 a、b 或 c（否定）<br>            * [a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围）<br>            * [0-9]    0到9的字符都包括<br>            * [a-zA-Z_0-9] 代表的字母或者数字或者下划线(即单词字符)<br>        * c: 预定义字符类<br>            * . 任何字符。<br>            * \d 数字：[0-9]<br>            * \w 单词字符：[a-zA-Z_0-9]如”com.itheima.tests”/finish<br>        * d: 边界匹配器<br>            * ^  代表的是行的开头<br>            * $  代表的是行的结尾<br>            * \b 代表的是单词边界<br>        * e: 数量词<br>            * X?     X，一次或一次也没有<br>            * X*     X，零次或多次<br>            * X+     X，一次或多次<br>            * X{n}   X，恰好 n 次<br>            * X{n,}  X，至少 n 次<br>            * X{n,m} X，至少 n 次，但是不超过 m 次</p>
<p>###03正则表达式练习和相关的String类方法<br>    * A: 正则表达式练习和相关的String类方法<br>        * a: boolean matches(String 正则的规则)<br>            * “abc”.matches(“[a]”)<br>            * 匹配成功返回true<br>        * b: String[] split(String 正则的规则)<br>            * “abc”.split(“a”)<br>            * 使用规则将字符串进行切割<br>        * c: String replaceAll( String 正则规则,String 字符串)<br>            * “abc0123”.repalceAll(“[\d]”,”#”)<br>            * 按照正则的规则,替换字符串</p>
<p>###04正则表达式匹配练习<br>    * A: 正则表达式匹配练习<br>        * a: 案例代码<br>            public class RegexDemo {<br>                public static void main(String[] args) {<br>                    checkTel();<br>                }</p>
<pre><code>    /*
     *  检查手机号码是否合法
     *  1开头 可以是34578  0-9 位数固定11位
     */
    public static void checkTel(){
        String telNumber = &quot;1335128005&quot;;
        //String类的方法matches
        boolean b = telNumber.matches(&quot;1[34857][\\d]{9}&quot;);
        System.out.println(b);
    }

    /*
     *  检查QQ号码是否合法
     *  0不能开头,全数字, 位数5,10位
     *  123456 
     *  \\d  \\D匹配不是数字
     */
    public static void checkQQ(){
        String QQ = &quot;123456&quot;;
        //检查QQ号码和规则是否匹配,String类的方法matches
        boolean b = QQ.matches(&quot;[1-9][\\d]{4,9}&quot;);
        System.out.println(b);
    }
}</code></pre><p>###05正则表达式切割练习<br>    * A: 正则表达式切割练习<br>        * a: 案例代码<br>            public class RegexDemo1 {<br>                public static void main(String[] args) {<br>                    split_1();<br>                    split_2();<br>                    split_3();</p>
<pre><code>    }

    /*
     * String类方法split对字符串进行切割
     * 192.168.105.27 按照 点切割字符串
     */
    public static void split_3(){
        String ip = &quot;192.168.105.27&quot;;
        String[] strArr = ip.split(&quot;\\.&quot;);
        System.out.println(&quot;数组的长度&quot;+strArr.length);
        for(int i = 0 ; i &lt; strArr.length ; i++){
            System.out.println(strArr[i]);
        }
    }

    /*
     * String类方法split对字符串进行切割
     * 18 22 40 65 按照空格切割字符串
     */
    public static void split_2(){
        String str = &quot;18    22     40          65&quot;;
        String[] strArr = str.split(&quot; +&quot;);
        System.out.println(&quot;数组的长度&quot;+strArr.length);
        for(int i = 0 ; i &lt; strArr.length ; i++){
            System.out.println(strArr[i]);
        }
    }

    /*
     *  String类方法split对字符串进行切割
     *  12-25-36-98  按照-对字符串进行切割
     */
    public static void split_1(){
        String str = &quot;12-25-36-98&quot;;
        //按照-对字符串进行切割,String类方法split
        String[] strArr = str.split(&quot;-&quot;);
        System.out.println(&quot;数组的长度&quot;+strArr.length);
        for(int i = 0 ; i &lt; strArr.length ; i++){
            System.out.println(strArr[i]);
        }
    }
}        </code></pre><p>###06正则表达式替换练习<br>    * A: 正则表达式替换练习<br>        * a: 案例代码<br>            public class RegexDemo1 {<br>                public static void main(String[] args) {<br>                    replaceAll_1();<br>                }</p>
<pre><code>    /*
     * &quot;Hello12345World6789012&quot;将所有数字替换掉
     * String类方法replaceAll(正则规则,替换后的新字符串)
     */
    public static void replaceAll_1(){
        String str = &quot;Hello12345World6789012&quot;;
        str = str.replaceAll(&quot;[\\d]+&quot;, &quot;#&quot;);
        System.out.println(str);
    }
}</code></pre><p>###07正则表达式邮箱地址验证<br>    * A: 正则表达式邮箱地址验证<br>        * a: 案例代码<br>            public class RegexDemo2 {<br>                public static void main(String[] args) {<br>                    checkMail();<br>                }<br>                /*<br>                 *  检查邮件地址是否合法<br>                 *  规则:<br>                 *   <a href="mailto:1234567@qq.com">1234567@qq.com</a><br>                 *   <a href="mailto:mym_ail@sina.com">mym_ail@sina.com</a><br>                 *   <a href="mailto:nimail@163.com">nimail@163.com</a><br>                 *   <a href="mailto:wodemail@yahoo.com.cn">wodemail@yahoo.com.cn</a><br>                 *<br>                 *   @: 前  数字字母_ 个数不能少于1个<br>                 *   @: 后  数字字母     个数不能少于1个<br>                 *   .: 后面 字母<br>                 *<br>                 */<br>                public static void checkMail(){<br>                    String email =”<a href="mailto:abc123@sina.com">abc123@sina.com</a>“;<br>                    boolean b = email.matches(“[a-zA-Z0-9_]+@[0-9a-z]+(\.[a-z]+)+”);<br>                    System.out.println(b);<br>                }<br>            }</p>
<p>###08毫秒值概念<br>    * A: 毫秒值概念<br>        * a: 时间和日期类<br>            * java.util.Date<br>        * b: 毫秒概念<br>            * 1000毫秒=1秒<br>        * c: 毫秒的0点<br>             * System.currentTimeMillis() 返回值long类型参数<br>             * 获取当前日期的毫秒值   3742769374405<br>             * 时间原点; 公元1970年1月1日,午夜0:00:00 英国格林威治  毫秒值就是0<br>             * 时间2088年8月8日<br>             * 时间和日期的计算，必须依赖毫秒值</p>
<p>###09Date类的构造方法<br>    * A: Date类的构造方法<br>        * a: 空参构造<br>            * public Date()<br>        * b: 带参构造<br>            * public Date(long times)</p>
<p>==============================第二阶段====================================        </p>
<p>###10Date类的get和set方法<br>    * A：Date类的get和set方法<br>        * public long getTime()<br>            * 将当前的日期对象，转为对应的毫秒值<br>        * public void setTime(long times);<br>            * 根据给定的毫秒值，生成对应的日期对象</p>
<p>###11日期格式化SimpleDateFormat<br>    * A: 日期格式化SimpleDateFormat<br>        * a: 对日期进行格式化(自定义)<br>            * 对日期格式化的类 java.text.DateFormat 抽象类, 普通方法,也有抽象的方法<br>            * 实际使用是子类 java.text.SimpleDateFormat 可以使用父类普通方法,重写了抽象方法<br>        * b: 对日期进行格式化的步骤<br>            * 1: 创建SimpleDateFormat对象<br>                * 在类构造方法中,写入字符串的日期格式 (自己定义)<br>            * 2: SimpleDateFormat调用方法format对日期进行格式化<br>                * public String format(Date date) 传递日期对象,返回字符串<br>                * 日期模式:<br>                 * yyyy    年份<br>                 * MM      月份<br>                * dd      月中的天数<br>                * HH       0-23小时<br>                * mm      小时中的分钟<br>                 * ss      秒<br>                 * yyyy年MM月dd日 HH点mm分钟ss秒  汉字修改,: -  字母表示的每个字段不可以随便写</p>
<p>###12字符串转成日期对象<br>    * A: 字符串转成日期对象<br>        * a: 使用步骤<br>            * 1: 创建SimpleDateFormat的对象<br>                * 构造方法中,指定日期模式<br>            * 2: 子类对象,调用方法 parse 传递String,返回Date<br>                * 注意: 时间和日期的模式yyyy-MM-dd, 必须和字符串中的时间日期匹配</p>
<p>###13Calendar类_1<br>    * A: Calendar类_1<br>        * a: 日历类(抽象类)<br>            * java.util.Calendar<br>        * b: 创建对象<br>            * Calendar类写了静态方法 getInstance() 直接返回了子类的对象<br>            * 不需要直接new子类的对象,通过静态方法直接获取</p>
<p>###14Calendar类_2<br>    * A: Calendar类_2<br>        * a: 成员方法<br>            * getTime() 把日历对象,转成Date日期对象<br>            * get(日历字段) 获取指定日历字段的值<br>        * b: 代码演示<br>            Calendar c = Calendar.getInstance();<br>            // 获取年份<br>            int year = c.get(Calendar.YEAR);<br>            // 获取月份<br>            int month = c.get(Calendar.MONTH) + 1;<br>            // 获取天数<br>            int day = c.get(Calendar.DAY_OF_MONTH);<br>            System.out.println(year + “年” + month + “月” + day + “日”);</p>
<p>###15Calendar类_3<br>    * A: Calendar类_3<br>        * a: 成员方法<br>            * set(int field,int value)  设置指定的时间<br>        * b: 代码演示<br>            /*<br>             * Calendar类的set方法 设置日历 set(int field,int value) field 设置的是哪个日历字段 value<br>             * 设置后的具体数值<br>             *<br>             * set(int year,int month,int day) 传递3个整数的年,月,日<br>             */<br>            public static void function_1() {<br>                Calendar c = Calendar.getInstance();<br>                // 设置,月份,设置到10月分<br>                // c.set(Calendar.MONTH, 9);</p>
<pre><code>    // 设置年,月,日
    c.set(2099, 4, 1);

    // 获取年份
    int year = c.get(Calendar.YEAR);
    // 获取月份
    int month = c.get(Calendar.MONTH) + 1;
    // 获取天数
    int day = c.get(Calendar.DAY_OF_MONTH);
    System.out.println(year + &quot;年&quot; + month + &quot;月&quot; + day + &quot;日&quot;);
}</code></pre><p>###16Calendar类_4<br>    * A: Calendar类_4<br>        * a: 成员方法<br>            * add(int field, int value) 进行整数的偏移<br>            * int get(int field) 获取指定字段的值<br>        * b: 案例演示<br>            /*<br>             * Calendar类方法add 日历的偏移量,<br>             * 可以指定一个日历中的字段,<br>             * 进行整数的偏移 add(int field, int value)<br>             */<br>            public static void function_2() {<br>                Calendar c = Calendar.getInstance();<br>                // 让日历中的天数,向后偏移280天<br>                c.add(Calendar.DAY_OF_MONTH, -280);<br>                // 获取年份<br>                int year = c.get(Calendar.YEAR);<br>                // 获取月份<br>                int month = c.get(Calendar.MONTH) + 1;<br>                // 获取天数<br>                int day = c.get(Calendar.DAY_OF_MONTH);<br>                System.out.println(year + “年” + month + “月” + day + “日”);<br>            }</p>
<p>###17日期练习_活了多少天<br>    * A: 日期练习_活了多少天<br>        * a: 案例代码<br>            /*<br>             *  计算活了多少天<br>             *   生日  今天的日期<br>             *   两个日期变成毫秒值,减法<br>             */<br>            public static void function() throws Exception {<br>                System.out.println(“请输入出生日期 格式 YYYY-MM-dd”);<br>                //获取出生日期,键盘输入<br>                String birthdayString = new Scanner(System.in).next();<br>                //将字符串日期,转成Date对象<br>                //创建SimpleDateFormat对象,写日期模式<br>                SimpleDateFormat sdf = new SimpleDateFormat(“yyyy-MM-dd”);<br>                //调用方法parse,字符串转成日期对象<br>                Date birthdayDate = sdf.parse(birthdayString);</p>
<pre><code>    //获取今天的日期对象
    Date todayDate = new Date();

    //将两个日期转成毫秒值,Date类的方法getTime
    long birthdaySecond = birthdayDate.getTime();
    long todaySecond = todayDate.getTime();
    long secone = todaySecond-birthdaySecond;

    if(secone &lt; 0){
        System.out.println(&quot;还没出生呢&quot;);
    }
    else{
    System.out.println(secone/1000/60/60/24);
    }

}</code></pre><p>###18日期练习_闰年计算<br>    * A: 日期练习_闰年计算<br>        * a: 案例代码<br>            /*<br>             *  闰年计算<br>             *  2000 3000<br>             *  高级的算法: 日历设置到指定年份的3月1日,add向前偏移1天,获取天数,29闰年<br>             */<br>            public static void function_1(){<br>                Calendar c = Calendar.getInstance();<br>                //将日历,设置到指定年的3月1日<br>                c.set(2088, 2, 1);<br>                //日历add方法,向前偏移1天<br>                c.add(Calendar.DAY_OF_MONTH, -1);<br>                //get方法获取天数<br>                int day = c.get(Calendar.DAY_OF_MONTH);<br>                System.out.println(day);<br>            }</p>
<p>###19总结</p>
<ul>
<li>把今天的知识点总结一遍。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/C++%E5%A4%8D%E4%B9%A0(%E5%88%9D%E8%AF%86STL)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/C++%E5%A4%8D%E4%B9%A0(%E5%88%9D%E8%AF%86STL)/" class="post-title-link" itemprop="url">C++复习(初识STL)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 16:49:29" itemprop="dateCreated datePublished" datetime="2020-12-22T16:49:29+08:00">2020-12-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/C++%E5%A4%8D%E4%B9%A0(%E5%BC%82%E5%B8%B8%E5%92%8C%E6%96%AD%E8%A8%80)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/C++%E5%A4%8D%E4%B9%A0(%E5%BC%82%E5%B8%B8%E5%92%8C%E6%96%AD%E8%A8%80)/" class="post-title-link" itemprop="url">C++复习(异常和断言)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 16:48:56" itemprop="dateCreated datePublished" datetime="2020-12-22T16:48:56+08:00">2020-12-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/C++%E5%A4%8D%E4%B9%A0(IO%E6%B5%81)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/C++%E5%A4%8D%E4%B9%A0(IO%E6%B5%81)/" class="post-title-link" itemprop="url">C++复习(IO流)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 16:48:14" itemprop="dateCreated datePublished" datetime="2020-12-22T16:48:14+08:00">2020-12-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/C++%E5%A4%8D%E4%B9%A0(%E6%A8%A1%E6%9D%BF)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/C++%E5%A4%8D%E4%B9%A0(%E6%A8%A1%E6%9D%BF)/" class="post-title-link" itemprop="url">C++复习(模板)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 16:47:53" itemprop="dateCreated datePublished" datetime="2020-12-22T16:47:53+08:00">2020-12-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/C++%E5%A4%8D%E4%B9%A0(%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/C++%E5%A4%8D%E4%B9%A0(%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD)/" class="post-title-link" itemprop="url">C++复习(运算符重载)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-22 16:47:17 / 修改时间：20:51:31" itemprop="dateCreated datePublished" datetime="2020-12-22T16:47:17+08:00">2020-12-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1、运算符重载的意义"><a href="#1、运算符重载的意义" class="headerlink" title="1、运算符重载的意义"></a>1、运算符重载的意义</h2><p>在C++中，运算符的操作对象只能是基本数据类型，而不能对于类、结构体等复杂数据类型进行操作，因此引入了运算符重载机制。运算符重载对已有的运算符赋予多重含义，使得同一个运算符作用于不同类型的数据时做出不同的行为。</p>
<p>运算符重载实际上是函数重载，它提供了C++的可扩展性。</p>
<h2 id="2、运算符重载的规则"><a href="#2、运算符重载的规则" class="headerlink" title="2、运算符重载的规则"></a>2、运算符重载的规则</h2><p><strong>1、只能重载C++已有的运算符，不能创建新的运算符。</strong></p>
<p><strong>2、重载之后的运算符不能改变其优先级和结合性，也不能改变其操作数的个数以及语法结构。</strong></p>
<p>3、运算符重载是针对新类型数据的实际需要，对原有运算符进行适当的改造，重载功能应与原有功能相类似，避免没有目的地使用重载运算符。</p>
<p><strong>4、C++中有五个运算符不可以重载：类属关系运算符“.”、成员指针运算符“*”、作用域运算符“::”、sizeof运算符和三目运算符“?:”。</strong></p>
<h2 id="3、运算符重载方式"><a href="#3、运算符重载方式" class="headerlink" title="3、运算符重载方式"></a>3、运算符重载方式</h2><p>重载运算符是具有特殊名字的函数，它们的名字由关键字operator和其后要重载的运算符共同组成。即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回类型 <span class="keyword">operator</span> 运算符(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">	函数体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-1、重载为类的成员函数"><a href="#3-1、重载为类的成员函数" class="headerlink" title="3.1、重载为类的成员函数"></a>3.1、重载为类的成员函数</h3><p>重载为类的成员函数，可以自由地访问本类的数据成员，运算的操作数会以调用者或参数的形式表示。</p>
<p>如果是双目运算符重载为类的成员函数，则它有两个操作数，左操作数一定是对象本身的数据，由this指针指出，右操作数则通过运算符重载函数的参数表来传递，即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">左操作数.运算符重载函数(右操作数)；</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> 	<span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> x1=<span class="number">0</span>,<span class="keyword">int</span> y1=<span class="number">0</span>):x(x1),y(y1)&#123;&#125;;</span><br><span class="line">	类名A <span class="keyword">operator</span>+(<span class="keyword">const</span> A&amp; a) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> A(x+a.x,y+a.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果是单目运算符重载为类的成员函数，则要分为前置运算符和后置运算符，如果是前置运算符，则它的操作数是函数调用者，函数没有参数，即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">左操作数.运算符重载函数();</span><br><span class="line"></span><br><span class="line">++a1;<span class="comment">//相当于调用a1.oprator++();</span></span><br></pre></td></tr></table></figure>

<p><strong>如果是后置单目运算符，则函数需要待一个整型参数，该参数不起任何作用，只是用来区分前置和后置。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">左操作数.运算符重载函数(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">a1++;<span class="comment">//相当于调用a1.operator++(int);</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> x;</span><br><span class="line">    	<span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	A(<span class="keyword">int</span> x1=<span class="number">0</span>,<span class="keyword">int</span> y1=<span class="number">0</span>):x(x1),y(y1)&#123;&#125;;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//const成员函数 只读数据成员 不可调用非const成员函数</span></span><br><span class="line">    	A <span class="keyword">operator</span>++()<span class="comment">//前置单目运算符</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++x;</span><br><span class="line">            ++y;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	A <span class="keyword">operator</span>++(<span class="keyword">int</span>)<span class="comment">//后置单目运算符</span></span><br><span class="line">        &#123;</span><br><span class="line">            A a = *<span class="keyword">this</span>;</span><br><span class="line">            ++(*<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::show</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"(x,y) = "</span>&lt;&lt;<span class="string">"("</span>&lt;&lt;x&lt;&lt;<span class="string">","</span>&lt;&lt;y&lt;&lt;<span class="string">")"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1(1,2),a2(3,4);</span><br><span class="line">    (a1++).show();</span><br><span class="line">    (++a2).show();</span><br><span class="line">    </span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p><strong>前置单目运算符与后置单目运算符重载的最主要区别就算函数的形参，后置单目运算符带一个int型形参，但它只起区分作用。</strong></p>
<h3 id="3-2、重载为类的友元函数"><a href="#3-2、重载为类的友元函数" class="headerlink" title="3.2、重载为类的友元函数"></a>3.2、重载为类的友元函数</h3><p>运算符重载为类的友元函数，只需要在函数前加一个friend 关键字。即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> 返回类型 <span class="keyword">operator</span> 运算符(参数列表)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	函数体；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重载为类的友元函数(类外定义的函数)时，由于没有隐含的this指针,因此操作数的个数没有变化，<strong>所有的操作数都必须通过函数的形参进行传递，函数的参数与操作数自左到右需要保持<u>一一对应</u>。</strong></p>
<p>一般调用格式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> 运算符(参数<span class="number">1</span>，参数<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>&lt;iostream</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> x;</span><br><span class="line">    	<span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> x1=<span class="number">0</span>,<span class="keyword">int</span> y1=<span class="number">0</span>):x(x1),y(y1)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//const成员函数 只读数据成员 不可调用非const成员函数</span></span><br><span class="line">    <span class="keyword">friend</span> A <span class="keyword">operator</span>+(<span class="keyword">const</span> A &amp;a1,<span class="keyword">const</span> A &amp;a2);</span><br><span class="line">    <span class="keyword">friend</span> A <span class="keyword">operator</span>-(<span class="keyword">const</span> A &amp;a1,<span class="keyword">const</span> A &amp;a2);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::show</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"(x,y) = "</span>&lt;&lt;<span class="string">"("</span>&lt;&lt;x&lt;&lt;<span class="string">","</span>&lt;&lt;y&lt;&lt;<span class="string">")"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">A <span class="keyword">operator</span>+(<span class="keyword">const</span> A &amp;a1,<span class="keyword">const</span> A &amp;a2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> A(a1.x+a2.x,a1.y+a2.y);</span><br><span class="line">&#125;</span><br><span class="line">A <span class="keyword">operator</span>-(<span class="keyword">const</span> A &amp;a1,<span class="keyword">const</span> A &amp;a2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> A(a1.x-a2.x,a1.y-a2.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1(1,2),a2(3,4);</span><br><span class="line">    A a;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a1:"</span>;</span><br><span class="line">    a1.show();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a2:"</span></span><br><span class="line">    a2.show();</span><br><span class="line">    a =a1+a2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a:"</span>;</span><br><span class="line">    a.show();</span><br><span class="line">    a=a1-a2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a:"</span>;</span><br><span class="line">    a.show();</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p><strong>1、一般情况下，单目运算符最好重载为类的成员函数，双目运算符最好重载为类的友元函数。</strong></p>
<p>2、若一个运算符的操作需要修改对象的状态，选择重载为成员函数比较好。</p>
<p><strong>3、若运算符的操作数(尤其是第一个操作数)希望有隐式类型转换，则只能选用友元函数。</strong></p>
<p>4、具有对称性的运算符可能转换任意一端的运算对象，如算术、关系运算符等等，通常重载为非成员函数。</p>
<p><strong>5、由4个运算符必须重载为类的成员函数：赋值(=)、下标([])、调用(())、成员访问箭头(-&gt;)。</strong></p>
<p><strong>（new、delete、类型转换函数也算）</strong></p>
<p><strong>6、类型转换函数只能定义为一个类的成员函数而不能定义为类的友元函数。</strong></p>
<p><strong>7、C++规定，重载运算符必须和用户定义的自定义类型对象一起使用。</strong></p>
<p>MyClass operator *(double,MyClass);</p>
<p>MyClass operator *(MyClass,MyClass);</p>
<p>MyClass operator *(MyClass,double);</p>
<p>对于一个运算符函数来说，它或者是类的成员，或者至少包含一个类类型参数。操作符重载允许将标准C++操作符用于类对象；</p>
<p>8、当运算符函数是一个成员函数时，最左边的操作数（或者只有最左边的操作数）必须是运算符类的一个类对象（或者是对该类对象的引用）。如果左边的操作数必须是一个不同类的对象，或者是一个内部　类型的对象，该运算符函数必须作为一个友元函数来实现。</p>
<p>典型例子:<strong>输入输出运算符不能重载为类的成员函数</strong>，因为它们左侧的运算符对象必须式istream/ostream流对象，而如果重载为类的成员函数，则左侧的操作对象必须是我们定义的一个类对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;,<span class="keyword">const</span> 类对象引用);</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp;,类对象引用);</span><br></pre></td></tr></table></figure>

<p>对于输出运算符”&lt;&lt;”来说，第一个参数是ostream对象引用，因为向六种写入数据会改变流的状态，所以不能用const修饰ostream对象。</p>
<p>对于输入运算符“&gt;&gt;”来说，第一个参数是istream对象的引用，第二个参数要想其中存入数据的对象，不能为常量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> x;</span><br><span class="line">    	<span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">public</span></span><br><span class="line">        A(<span class="keyword">int</span> x1=<span class="number">0</span>,<span class="keyword">int</span> y1=<span class="number">0</span>):x(x1),y(y1)&#123;&#125;;</span><br><span class="line">    	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="keyword">const</span> A &amp;a);</span><br><span class="line">    	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is,A &amp;a);</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="keyword">const</span> A &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    os&lt;&lt;a.x&lt;&lt;a.y;</span><br><span class="line">    <span class="comment">//os&lt;&lt;"("&lt;&lt;a.x&lt;&lt;a.y&lt;&lt;")";</span></span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; os,A &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    is&gt;&gt;a.x&gt;&gt;a.y;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A A1(1,2),A2(3,4);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a1:"</span>&lt;&lt;a1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a2:"</span>&lt;&lt;a2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请重新为a2对象输入数据："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"重新输入后a2:"</span>&lt;&lt;a2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>通常情况下，输出运算符主要负责输出对象的内容，而非控制格式，即在重载时可以不需要重载格式控制符，如空格、换行、制表位等等，因为如果把格式控制符也重载进去的话，用户又是想在同一行输出一些描述性的文本，就无法完成了。</p>
<h2 id="4、常用运算符的重载"><a href="#4、常用运算符的重载" class="headerlink" title="4、常用运算符的重载"></a>4、常用运算符的重载</h2><h3 id="4-1、输入输出运算符重载"><a href="#4-1、输入输出运算符重载" class="headerlink" title="4.1、输入输出运算符重载"></a>4.1、输入输出运算符重载</h3><p>如上所示。</p>
<h3 id="4-2、关系运算符的重载"><a href="#4-2、关系运算符的重载" class="headerlink" title="4.2、关系运算符的重载"></a>4.2、关系运算符的重载</h3><p>注意：</p>
<p><strong>1、通过关系运算符都要成对的重载，即重载了“&gt;”运算符，那么就要重载“&lt;”运算符，反之亦然。</strong></p>
<p>2、通常情况下，“==”运算符应该具有传递性，即a=b,b=c,则a=c成立。(都为两个=号)</p>
<p>3、当成对的出现运算符重载时，可以把一个运算符的工作委托给另外一个运算符，比如重载”!=”可以在重载”==”运算符基础上重载。</p>
<h3 id="4-3、赋值运算符的重载"><a href="#4-3、赋值运算符的重载" class="headerlink" title="4.3、赋值运算符的重载"></a>4.3、赋值运算符的重载</h3><p>对于赋值运算符来说，如果不重载，那么类会自动为我们提供一个赋值运算符。这个默认的赋值运算符与默认拷贝构造函数意义，就是把一个对象的数据成员的值复制给另外一个对象相应的数据成员，即浅拷贝。如果数据成员种有指针，则无法满足要求，会造成内存泄露，这时我们应该重载赋值函数，实现深拷贝。</p>
<h3 id="4-4、下标运算符"><a href="#4-4、下标运算符" class="headerlink" title="4.4、下标运算符"></a>4.4、下标运算符</h3><h3 id="4-5、类型转换函数"><a href="#4-5、类型转换函数" class="headerlink" title="4.5、类型转换函数"></a>4.5、类型转换函数</h3><p>类型转换函数又称类型转换运算符重载函数,<strong>是指将类对象等复杂数据类型转换为基本数据类型</strong>。即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> 类型名();</span><br></pre></td></tr></table></figure>

<p>类型转换函数也是以operator关键字开头，这点和运算符重载时的规律是一致的，只是被重载的是类型名。<strong>在函数名前面不能指定函数类型，函数也没有参数。其返回值的类型是由函数名中指定的类型名来确定的</strong>(如果类型名是double，则将类型数据转换为double类型返回)。</p>
<p><strong>类型转换运算符重载函数只能作为类的成员函数，因为转换的主体是本类的对象。</strong></p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Swap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	Swap(<span class="keyword">int</span> m,<span class="keyword">int</span> n):a(m),b(n)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">char</span><span class="params">()</span><span class="comment">//类型转换运算符重载函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">" "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Swap <span class="title">s1</span><span class="params">(<span class="number">65</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"s1:"</span>;</span><br><span class="line">    s1.show();</span><br><span class="line">    <span class="keyword">char</span> ch =s1;<span class="comment">//调用类型转换函数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ch&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">65</span> <span class="number">2</span></span><br><span class="line">A</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p><strong>类型转换函数有一个特殊功能。当需要的时候，编译系统会自动调用重载函数，建立一个无名的临时对象(或临时变量)，如上图，将s1对象赋值给ch时，如果没有重载“=”运算符，编译器会首先检查是否由类型转换函数，如果由，则调用operator char()函数将s1对象转换为一个临时的char类型变量，再将这个临时变量赋值给ch。</strong></p>
<h3 id="4-6、转换构造函数"><a href="#4-6、转换构造函数" class="headerlink" title="4.6、转换构造函数"></a>4.6、转换构造函数</h3><p>转换构造函数是当一个构造函数只有一个参数，并且这个参数又不是本类的const引用时，这种构造函数称为转换构造函数。<strong>即它用来将基本数据变量转换为类对象等复杂数据变量。</strong></p>
<p>转换构造函数不仅可以将一个标准类型数据转换为类对象，还可以将另一个类的对象转换为转换构造函数所在类的类对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line"><span class="comment">////////////////////////</span></span><br><span class="line"><span class="comment">//P146例4.10 包含转换构造函数、运算符重载函数和类型转换函数的程序</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//#include &lt;iostream.h&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Complex()&#123;real=<span class="number">0</span>;imag=<span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">	Complex(<span class="keyword">double</span> r)&#123;real=r;imag=<span class="number">0</span>;&#125; <span class="comment">//转换构造函数 普通基础数据转换为类对象数据 </span></span><br><span class="line"></span><br><span class="line">	Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i)&#123;real=r;imag=i;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//operator double()&#123;return real;&#125;    //类型转换函数 类对象数据转换为普通基础数据 </span></span><br><span class="line">	<span class="comment">//后面的语句：c3=c1+2.5; //error C2666: '+' : 2 overloads have similar conversions</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> Complex <span class="keyword">operator</span> + (Complex c1,Complex c2);   <span class="comment">//运算符重载函数</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> real;</span><br><span class="line">	<span class="keyword">double</span> imag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///* </span></span><br><span class="line">Complex <span class="keyword">operator</span> + (Complex c1,Complex c2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> Complex(c1.real+c2.real, c1.imag+c2.imag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//*/   </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Complex::display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"("</span>&lt;&lt;real&lt;&lt;<span class="string">","</span>&lt;&lt;imag&lt;&lt;<span class="string">"i)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Complex c1(3,4),c2(5,-10),c3;</span><br><span class="line">	<span class="keyword">double</span> d=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	c3=c1+<span class="number">2.5</span>; <span class="comment">//需要注释前面的 //类型转换函数，否则：//error C2666: '+' : 2 overloads have similar conversions</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//d = c1+2.5; //需要注释前面的  //转换构造函数，否则：//error C2666: '+' : 2 overloads have similar conversions</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//c3 = c1+2.5; 和 d = c1+2.5在此程序中不能同时出现。</span></span><br><span class="line"></span><br><span class="line">	c3.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*编程题（类对象的转换）。编写一个学生类和教师类信息输入/输出程序。学生类数据包括学号、姓名、班级、成绩；教师类数据包括编号、姓名、职称和部门。要求设计一个person类，作为学生类student和教师类teacher的基类，再写一个转换构造函数，可以把学生类对象转换为教师类对象，最后定义一个学生类对象和教师类对象。*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line">person()&#123;&#125;;</span><br><span class="line">person(<span class="built_in">string</span> nam):name(nam)&#123;&#125;;</span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>;</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span><span class="keyword">public</span> person</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="built_in">string</span> num,<span class="built_in">string</span> nam,<span class="built_in">string</span> cla,<span class="keyword">int</span> score):number(num),name(nam),classes(cla),scores(score),person(nam)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"学生："</span>&lt;&lt;name&lt;&lt;<span class="string">"，学号："</span>&lt;&lt;number&lt;&lt;<span class="string">"，班级："</span>&lt;&lt;classes&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>;</span></span><br><span class="line">        <span class="built_in">string</span> number;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">        <span class="built_in">string</span> classes;</span><br><span class="line">        <span class="keyword">int</span> scores; </span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>:</span><span class="keyword">public</span> person </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Teacher(<span class="built_in">string</span> num,<span class="built_in">string</span> nam,<span class="built_in">string</span> st,<span class="built_in">string</span> de):number(num),name(nam),stuff(st),department(de),person(nam)&#123;&#125;;</span><br><span class="line">Teacher(Student &amp;s):person(s.name)</span><br><span class="line">&#123;</span><br><span class="line">number = s.number;</span><br><span class="line">name = s.name;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"教师："</span>&lt;&lt;name&lt;&lt;<span class="string">"，编号："</span>&lt;&lt;number&lt;&lt;<span class="string">"，职称："</span>&lt;&lt;stuff&lt;&lt;<span class="string">"，部门："</span>&lt;&lt;department&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">string</span> number;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">string</span> stuff;</span><br><span class="line">    <span class="built_in">string</span> department;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> number;</span><br><span class="line">	<span class="built_in">string</span> name,sex;</span><br><span class="line">	<span class="keyword">int</span> score; </span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; number &gt;&gt; name &gt;&gt; sex &gt;&gt;score;</span><br><span class="line">	<span class="built_in">string</span> st,department;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt;st&gt;&gt;department;</span><br><span class="line">	<span class="function">person <span class="title">p</span><span class="params">(name)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">stu</span><span class="params">(number,name,sex,score)</span></span>;</span><br><span class="line">    stu.Print();</span><br><span class="line">    Teacher t = (Teacher)stu;</span><br><span class="line">    t.stuff=st;</span><br><span class="line">    t.department=department;</span><br><span class="line">    t.Print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/21/17%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/21/17%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/" class="post-title-link" itemprop="url">17函数进阶</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-21 16:48:23 / 修改时间：18:07:43" itemprop="dateCreated datePublished" datetime="2020-12-21T16:48:23+08:00">2020-12-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>函数参数和返回值的作用</li>
<li>函数的返回值 进阶</li>
<li>函数的参数 进阶</li>
<li>递归函数</li>
</ul>
<h2 id="01-函数参数和返回值的作用"><a href="#01-函数参数和返回值的作用" class="headerlink" title="01. 函数参数和返回值的作用"></a>01. 函数参数和返回值的作用</h2><p>函数根据 <strong>有没有参数</strong> 以及 <strong>有没有返回值</strong>，可以 <strong>相互组合</strong>，一共有 <strong>4 种</strong> 组合形式</p>
<ol>
<li>无参数，无返回值</li>
<li>无参数，有返回值</li>
<li>有参数，无返回值</li>
<li>有参数，有返回值</li>
</ol>
<p><img src="/2020/12/21/17%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/001_%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC.png" alt></p>
<blockquote>
<p>定义函数时，<strong>是否接收参数，或者是否返回结果</strong>，是根据 <strong>实际的功能需求</strong> 来决定的！</p>
</blockquote>
<ol>
<li>如果函数 <strong>内部处理的数据不确定</strong>，就可以将外界的数据以参数传递到函数内部</li>
<li>如果希望一个函数 <strong>执行完成后，向外界汇报执行结果</strong>，就可以增加函数的返回值</li>
</ol>
<h3 id="1-1-无参数，无返回值"><a href="#1-1-无参数，无返回值" class="headerlink" title="1.1 无参数，无返回值"></a>1.1 无参数，无返回值</h3><p>此类函数，不接收参数，也没有返回值，应用场景如下：</p>
<ol>
<li><strong>只是单纯地做一件事情</strong>，例如 <strong>显示菜单</strong></li>
<li>在函数内部 <strong>针对全局变量进行操作</strong>，例如：<strong>新建名片</strong>，最终结果 <strong>记录在全局变量</strong> 中</li>
</ol>
<blockquote>
<p>注意：</p>
</blockquote>
<ul>
<li>如果全局变量的数据类型是一个 <strong>可变类型</strong>，在函数内部可以使用 <strong>方法</strong> 修改全局变量的内容 —— <strong>变量的引用不会改变</strong></li>
<li>在函数内部，<strong>使用赋值语句</strong> 才会 <strong>修改变量的引用</strong></li>
</ul>
<h3 id="1-2-无参数，有返回值"><a href="#1-2-无参数，有返回值" class="headerlink" title="1.2 无参数，有返回值"></a>1.2 无参数，有返回值</h3><p>此类函数，不接收参数，但是有返回值，应用场景如下：</p>
<ul>
<li>采集数据，例如 <strong>温度计</strong>，返回结果就是当前的温度，而不需要传递任何的参数</li>
</ul>
<h3 id="1-3-有参数，无返回值"><a href="#1-3-有参数，无返回值" class="headerlink" title="1.3 有参数，无返回值"></a>1.3 有参数，无返回值</h3><p>此类函数，接收参数，没有返回值，应用场景如下：</p>
<ul>
<li>函数内部的代码保持不变，针对 <strong>不同的参数 处理 不同的数据</strong></li>
<li>例如 <strong>名片管理系统</strong> 针对 <strong>找到的名片</strong> 做 <strong>修改</strong>、<strong>删除</strong> 操作</li>
</ul>
<h3 id="1-4-有参数，有返回值"><a href="#1-4-有参数，有返回值" class="headerlink" title="1.4 有参数，有返回值"></a>1.4 有参数，有返回值</h3><p>此类函数，接收参数，同时有返回值，应用场景如下：</p>
<ul>
<li>函数内部的代码保持不变，针对 <strong>不同的参数 处理 不同的数据</strong>，并且 <strong>返回期望的处理结果</strong></li>
<li>例如 <strong>名片管理系统</strong> 使用 <strong>字典默认值</strong> 和 <strong>提示信息</strong> 提示用户输入内容<ul>
<li>如果输入，返回输入内容</li>
<li>如果没有输入，返回字典默认值</li>
</ul>
</li>
</ul>
<h2 id="02-函数的返回值-进阶"><a href="#02-函数的返回值-进阶" class="headerlink" title="02. 函数的返回值 进阶"></a>02. 函数的返回值 进阶</h2><ul>
<li>在程序开发中，有时候，会希望 <strong>一个函数执行结束后，告诉调用者一个结果</strong>，以便调用者针对具体的结果做后续的处理</li>
<li><strong>返回值</strong> 是函数 <strong>完成工作</strong>后，<strong>最后</strong> 给调用者的 <strong>一个结果</strong></li>
<li>在函数中使用 <code>return</code> 关键字可以返回结果</li>
<li>调用函数一方，可以 <strong>使用变量</strong> 来 <strong>接收</strong> 函数的返回结果</li>
</ul>
<blockquote>
<p>问题：一个函数执行后能否返回多个结果？</p>
</blockquote>
<h3 id="示例-——-温度和湿度测量"><a href="#示例-——-温度和湿度测量" class="headerlink" title="示例 —— 温度和湿度测量"></a>示例 —— 温度和湿度测量</h3><ul>
<li>假设要开发一个函数能够同时返回当前的温度和湿度</li>
<li><strong>先完成返回温度</strong>的功能如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">measure</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""返回当前的温度"""</span></span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"开始测量..."</span>)</span><br><span class="line">    temp = <span class="number">39</span></span><br><span class="line">    print(<span class="string">"测量结束..."</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line">result = measure()</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<ul>
<li>在利用 <strong>元组</strong> 在返回温度的同时，也能够返回 <strong>湿度</strong></li>
<li>改造如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">measure</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""返回当前的温度"""</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"开始测量..."</span>)</span><br><span class="line">    temp = <span class="number">39</span></span><br><span class="line">    wetness = <span class="number">10</span></span><br><span class="line">    print(<span class="string">"测量结束..."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (temp, wetness)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：如果一个函数返回的是元组，括号可以省略</p>
</blockquote>
<p><strong>技巧</strong> </p>
<ul>
<li>在 <code>Python</code> 中，可以 <strong>将一个元组</strong> 使用 <strong>赋值语句</strong> 同时赋值给 <strong>多个变量</strong></li>
<li>注意：变量的数量需要和元组中的元素数量保持一致</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = temp, wetness = measure()</span><br></pre></td></tr></table></figure>

<h3 id="面试题-——-交换两个数字"><a href="#面试题-——-交换两个数字" class="headerlink" title="面试题 —— 交换两个数字"></a>面试题 —— 交换两个数字</h3><p><strong>题目要求</strong></p>
<ol>
<li>有两个整数变量 <code>a = 6</code>, <code>b = 100</code></li>
<li>不使用其他变量，<strong>交换两个变量的值</strong></li>
</ol>
<h4 id="解法-1-——-使用其他变量"><a href="#解法-1-——-使用其他变量" class="headerlink" title="解法 1 —— 使用其他变量"></a>解法 1 —— 使用其他变量</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解法 1 - 使用临时变量</span></span><br><span class="line">c = b</span><br><span class="line">b = a</span><br><span class="line">a = c</span><br></pre></td></tr></table></figure>

<h4 id="解法-2-——-不使用临时变量"><a href="#解法-2-——-不使用临时变量" class="headerlink" title="解法 2 —— 不使用临时变量"></a>解法 2 —— 不使用临时变量</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解法 2 - 不使用临时变量</span></span><br><span class="line">a = a + b</span><br><span class="line">b = a - b</span><br><span class="line">a = a - b</span><br></pre></td></tr></table></figure>

<h4 id="解法-3-——-Python-专有，利用元组"><a href="#解法-3-——-Python-专有，利用元组" class="headerlink" title="解法 3 —— Python 专有，利用元组"></a>解法 3 —— Python 专有，利用元组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure>

<h2 id="03-函数的参数-进阶"><a href="#03-函数的参数-进阶" class="headerlink" title="03. 函数的参数 进阶"></a>03. 函数的参数 进阶</h2><h3 id="3-1-不可变和可变的参数"><a href="#3-1-不可变和可变的参数" class="headerlink" title="3.1. 不可变和可变的参数"></a>3.1. 不可变和可变的参数</h3><blockquote>
<p>问题 1：在函数内部，针对参数使用 <strong>赋值语句</strong>，会不会影响调用函数时传递的 <strong>实参变量</strong>？ —— 不会！</p>
</blockquote>
<ul>
<li>无论传递的参数是 <strong>可变</strong> 还是 <strong>不可变</strong> <ul>
<li>只要 <strong>针对参数</strong> 使用 <strong>赋值语句</strong>，会在 <strong>函数内部</strong> 修改 <strong>局部变量的引用</strong>，<strong>不会影响到 外部变量的引用</strong></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(num, num_list)</span>:</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"函数内部"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 赋值语句</span></span><br><span class="line">    num = <span class="number">200</span></span><br><span class="line">    num_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    print(num)</span><br><span class="line">    print(num_list)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"函数代码完成"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gl_num = <span class="number">99</span></span><br><span class="line">gl_list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">demo(gl_num, gl_list)</span><br><span class="line">print(gl_num)</span><br><span class="line">print(gl_list)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>问题 2：如果传递的参数是 <strong>可变类型</strong>，在函数内部，使用 <strong>方法</strong> 修改了数据的内容，<strong>同样会影响到外部的数据</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mutable</span><span class="params">(num_list)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># num_list = [1, 2, 3]</span></span><br><span class="line">    num_list.extend([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">    </span><br><span class="line">    print(num_list)</span><br><span class="line"></span><br><span class="line">gl_list = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">mutable(gl_list)</span><br><span class="line">print(gl_list)</span><br></pre></td></tr></table></figure>

<h4 id="面试题-——"><a href="#面试题-——" class="headerlink" title="面试题 —— +="></a>面试题 —— <code>+=</code></h4><ul>
<li>在 <code>python</code> 中，列表变量调用 <code>+=</code> 本质上是在执行列表变量的 <code>extend</code> 方法，不会修改变量的引用</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(num, num_list)</span>:</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"函数内部代码"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># num = num + num</span></span><br><span class="line">    num += num</span><br><span class="line">    <span class="comment"># num_list.extend(num_list) 由于是调用方法，所以不会修改变量的引用</span></span><br><span class="line">    <span class="comment"># 函数执行结束后，外部数据同样会发生变化</span></span><br><span class="line">    num_list += num_list</span><br><span class="line"></span><br><span class="line">    print(num)</span><br><span class="line">    print(num_list)</span><br><span class="line">    print(<span class="string">"函数代码完成"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gl_num = <span class="number">9</span></span><br><span class="line">gl_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">demo(gl_num, gl_list)</span><br><span class="line">print(gl_num)</span><br><span class="line">print(gl_list)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-缺省参数"><a href="#3-2-缺省参数" class="headerlink" title="3.2 缺省参数"></a>3.2 缺省参数</h3><ul>
<li>定义函数时，可以给 <strong>某个参数</strong> 指定一个<strong>默认值</strong>，具有默认值的参数就叫做 <strong>缺省参数</strong></li>
<li>调用函数时，如果没有传入 <strong>缺省参数</strong> 的值，则在函数内部使用定义函数时指定的 <strong>参数默认值</strong></li>
<li>函数的缺省参数，<strong>将常见的值设置为参数的缺省值</strong>，从而 <strong>简化函数的调用</strong></li>
<li>例如：对列表排序的方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gl_num_list = [<span class="number">6</span>, <span class="number">3</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认就是升序排序，因为这种应用需求更多</span></span><br><span class="line">gl_num_list.sort()</span><br><span class="line">print(gl_num_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只有当需要降序排序时，才需要传递 `reverse` 参数</span></span><br><span class="line">gl_num_list.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">print(gl_num_list)</span><br></pre></td></tr></table></figure>

<h4 id="指定函数的缺省参数"><a href="#指定函数的缺省参数" class="headerlink" title="指定函数的缺省参数"></a>指定函数的缺省参数</h4><ul>
<li>在参数后使用赋值语句，可以指定参数的缺省值</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_info</span><span class="params">(name, gender=True)</span>:</span></span><br><span class="line"></span><br><span class="line">    gender_text = <span class="string">"男生"</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> gender:</span><br><span class="line">        gender_text = <span class="string">"女生"</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"%s 是 %s"</span> % (name, gender_text))</span><br></pre></td></tr></table></figure>

<p><strong>提示</strong></p>
<ol>
<li>缺省参数，需要使用 <strong>最常见的值</strong> 作为默认值！</li>
<li>如果一个参数的值 <strong>不能确定</strong>，则不应该设置默认值，具体的数值在调用函数时，由外界传递！</li>
</ol>
<h4 id="缺省参数的注意事项"><a href="#缺省参数的注意事项" class="headerlink" title="缺省参数的注意事项"></a>缺省参数的注意事项</h4><h5 id="1-缺省参数的定义位置"><a href="#1-缺省参数的定义位置" class="headerlink" title="1) 缺省参数的定义位置"></a>1) 缺省参数的定义位置</h5><ul>
<li><strong>必须保证</strong> <strong>带有默认值的缺省参数</strong> <strong>在参数列表末尾</strong></li>
<li>所以，以下定义是错误的！</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_info</span><span class="params">(name, gender=True, title)</span>:</span></span><br></pre></td></tr></table></figure>

<h5 id="2-调用带有多个缺省参数的函数"><a href="#2-调用带有多个缺省参数的函数" class="headerlink" title="2) 调用带有多个缺省参数的函数"></a>2) 调用带有多个缺省参数的函数</h5><ul>
<li>在 <strong>调用函数时</strong>，如果有 <strong>多个缺省参数</strong>，<strong>需要指定参数名</strong>，这样解释器才能够知道参数的对应关系！</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_info</span><span class="params">(name, title=<span class="string">""</span>, gender=True)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param title: 职位</span></span><br><span class="line"><span class="string">    :param name: 班上同学的姓名</span></span><br><span class="line"><span class="string">    :param gender: True 男生 False 女生</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    gender_text = <span class="string">"男生"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> gender:</span><br><span class="line">        gender_text = <span class="string">"女生"</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"%s%s 是 %s"</span> % (title, name, gender_text))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提示：在指定缺省参数的默认值时，应该使用最常见的值作为默认值！</span></span><br><span class="line">print_info(<span class="string">"小明"</span>)</span><br><span class="line">print_info(<span class="string">"老王"</span>, title=<span class="string">"班长"</span>)</span><br><span class="line">print_info(<span class="string">"小美"</span>, gender=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-3-多值参数（知道）"><a href="#3-3-多值参数（知道）" class="headerlink" title="3.3 多值参数（知道）"></a>3.3 多值参数（知道）</h3><h4 id="定义支持多值参数的函数"><a href="#定义支持多值参数的函数" class="headerlink" title="定义支持多值参数的函数"></a>定义支持多值参数的函数</h4><ul>
<li><p>有时可能需要 <strong>一个函数</strong> 能够处理的参数 <strong>个数</strong> 是不确定的，这个时候，就可以使用 <strong>多值参数</strong></p>
</li>
<li><p><code>python</code> 中有 <strong>两种</strong> 多值参数：</p>
<ul>
<li>参数名前增加 <strong>一个</strong> <code>*</code> 可以接收 <strong>元组</strong></li>
<li>参数名前增加 <strong>两个</strong> <code>*</code> 可以接收 <strong>字典</strong></li>
</ul>
</li>
<li><p>一般在给多值参数命名时，<strong>习惯</strong>使用以下两个名字</p>
<ul>
<li><code>*args</code> —— 存放 <strong>元组</strong> 参数，前面有一个 <code>*</code></li>
<li><code>**kwargs</code> —— 存放 <strong>字典</strong> 参数，前面有两个 <code>*</code></li>
</ul>
</li>
<li><p><code>args</code> 是 <code>arguments</code> 的缩写，有变量的含义</p>
</li>
<li><p><code>kw</code> 是 <code>keyword</code> 的缩写，<code>kwargs</code> 可以记忆 <strong>键值对参数</strong></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(num, *args, **kwargs)</span>:</span></span><br><span class="line"></span><br><span class="line">    print(num)</span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">demo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, name=<span class="string">"小明"</span>, age=<span class="number">18</span>, gender=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：<strong>多值参数</strong> 的应用会经常出现在网络上一些大牛开发的框架中，知道多值参数，<strong>有利于我们能够读懂大牛的代码</strong></p>
</blockquote>
<h4 id="多值参数案例-——-计算任意多个数字的和"><a href="#多值参数案例-——-计算任意多个数字的和" class="headerlink" title="多值参数案例 —— 计算任意多个数字的和"></a>多值参数案例 —— 计算任意多个数字的和</h4><p><strong>需求</strong></p>
<ol>
<li>定义一个函数 <code>sum_numbers</code>，可以接收的 <strong>任意多个整数</strong></li>
<li>功能要求：将传递的 <strong>所有数字累加</strong> 并且返回累加结果</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_numbers</span><span class="params">(*args)</span>:</span></span><br><span class="line"></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 遍历 args 元组顺序求和</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">        num += n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line">print(sum_numbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<h4 id="元组和字典的拆包（知道）"><a href="#元组和字典的拆包（知道）" class="headerlink" title="元组和字典的拆包（知道）"></a>元组和字典的拆包（知道）</h4><ul>
<li>在调用带有多值参数的函数时，如果希望：<ul>
<li>将一个 <strong>元组变量</strong>，直接传递给 <code>args</code></li>
<li>将一个 <strong>字典变量</strong>，直接传递给 <code>kwargs</code></li>
</ul>
</li>
<li>就可以使用 <strong>拆包</strong>，简化参数的传递，<strong>拆包</strong> 的方式是：<ul>
<li>在 <strong>元组变量前</strong>，增加 <strong>一个</strong> <code>*</code></li>
<li>在 <strong>字典变量前</strong>，增加 <strong>两个</strong> <code>*</code></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"></span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要将一个元组变量/字典变量传递给函数对应的参数</span></span><br><span class="line">gl_nums = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">gl_xiaoming = &#123;<span class="string">"name"</span>: <span class="string">"小明"</span>, <span class="string">"age"</span>: <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会把 num_tuple 和 xiaoming 作为元组传递个 args</span></span><br><span class="line"><span class="comment"># demo(gl_nums, gl_xiaoming)</span></span><br><span class="line">demo(*gl_nums, **gl_xiaoming)</span><br></pre></td></tr></table></figure>

<h2 id="04-函数的递归"><a href="#04-函数的递归" class="headerlink" title="04. 函数的递归"></a>04. 函数的递归</h2><blockquote>
<p>函数调用自身的 <strong>编程技巧</strong> 称为递归</p>
</blockquote>
<h3 id="4-1-递归函数的特点"><a href="#4-1-递归函数的特点" class="headerlink" title="4.1 递归函数的特点"></a>4.1 递归函数的特点</h3><p><strong>特点</strong></p>
<ul>
<li><strong>一个函数</strong> <strong>内部</strong> <strong>调用自己</strong><ul>
<li>函数内部可以调用其他函数，当然在函数内部也可以调用自己</li>
</ul>
</li>
</ul>
<p><strong>代码特点</strong></p>
<ol>
<li>函数内部的 <strong>代码</strong> 是相同的，只是针对 <strong>参数</strong> 不同，<strong>处理的结果不同</strong></li>
<li>当 <strong>参数满足一个条件</strong> 时，函数不再执行<ul>
<li><strong>这个非常重要</strong>，通常被称为递归的出口，否则 <strong>会出现死循环</strong>！</li>
</ul>
</li>
</ol>
<p>示例代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_numbers</span><span class="params">(num)</span>:</span></span><br><span class="line"></span><br><span class="line">    print(num)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归的出口很重要，否则会出现死循环</span></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    sum_numbers(num - <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">sum_numbers(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/21/17%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/002_%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt></p>
<h3 id="4-2-递归案例-——-计算数字累加"><a href="#4-2-递归案例-——-计算数字累加" class="headerlink" title="4.2 递归案例 —— 计算数字累加"></a>4.2 递归案例 —— 计算数字累加</h3><p><strong>需求</strong></p>
<ol>
<li>定义一个函数 <code>sum_numbers</code></li>
<li>能够接收一个 <code>num</code> 的整数参数</li>
<li>计算 1 + 2 + … num 的结果</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_numbers</span><span class="params">(num)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 假设 sum_numbers 能够完成 num - 1 的累加</span></span><br><span class="line">    temp = sum_numbers(num - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 函数内部的核心算法就是 两个数字的相加</span></span><br><span class="line">    <span class="keyword">return</span> num + temp</span><br><span class="line"></span><br><span class="line">print(sum_numbers(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/21/17%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/002_%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E7%A4%BA%E6%84%8F%E5%9B%BEI.png" alt></p>
<blockquote>
<p>提示：递归是一个 <strong>编程技巧</strong>，初次接触递归会感觉有些吃力！在处理 <strong>不确定的循环条件时</strong>，格外的有用，例如：<strong>遍历整个文件目录的结构</strong></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/21/16%E5%8F%98%E9%87%8F%E8%BF%9B%E9%98%B6%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/21/16%E5%8F%98%E9%87%8F%E8%BF%9B%E9%98%B6%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89/" class="post-title-link" itemprop="url">16变量进阶（理解）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-21 16:48:23" itemprop="dateCreated datePublished" datetime="2020-12-21T16:48:23+08:00">2020-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2017-07-06 14:34:40" itemprop="dateModified" datetime="2017-07-06T14:34:40+08:00">2017-07-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="变量进阶（理解）"><a href="#变量进阶（理解）" class="headerlink" title="变量进阶（理解）"></a>变量进阶（理解）</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>变量的引用</li>
<li>可变和不可变类型</li>
<li>局部变量和全局变量</li>
</ul>
<h2 id="01-变量的引用"><a href="#01-变量的引用" class="headerlink" title="01. 变量的引用"></a>01. 变量的引用</h2><blockquote>
<ul>
<li>变量 和 数据 都是保存在 <strong>内存</strong> 中的</li>
<li>在 <code>Python</code> 中 <strong>函数 的 参数传递</strong> 以及 <strong>返回值</strong> 都是靠 <strong>引用</strong> 传递的</li>
</ul>
</blockquote>
<h3 id="1-1-引用的概念"><a href="#1-1-引用的概念" class="headerlink" title="1.1 引用的概念"></a>1.1 引用的概念</h3><p>在 <code>Python</code> 中</p>
<ul>
<li><strong>变量</strong> 和 <strong>数据</strong> 是分开存储的</li>
<li><strong>数据</strong> 保存在内存中的一个位置</li>
<li><strong>变量</strong> 中保存着数据在内存中的地址</li>
<li><strong>变量</strong> 中 <strong>记录数据的地址</strong>，就叫做 <strong>引用</strong></li>
<li>使用 <code>id()</code> 函数可以查看变量中保存数据所在的 <strong>内存地址</strong></li>
</ul>
<blockquote>
<p>注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是 <strong>修改了数据的引用</strong></p>
<ul>
<li>变量 <strong>不再</strong> 对之前的数据引用</li>
<li>变量 <strong>改为</strong> 对新赋值的数据引用</li>
</ul>
</blockquote>
<h3 id="1-2-变量引用-的示例"><a href="#1-2-变量引用-的示例" class="headerlink" title="1.2 变量引用 的示例"></a>1.2 <code>变量引用</code> 的示例</h3><p>在 <code>Python</code> 中，变量的名字类似于 <strong>便签纸</strong> 贴在 <strong>数据</strong> 上</p>
<ul>
<li>定义一个整数变量 <code>a</code>，并且赋值为 <code>1</code></li>
</ul>
<table>
<thead>
<tr>
<th align="center">代码</th>
<th align="center">图示</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a = 1</td>
<td align="center"><img src="/2020/12/21/16%E5%8F%98%E9%87%8F%E8%BF%9B%E9%98%B6%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89/14982751015713/004_a1tag.png" alt="004_a1tag"></td>
</tr>
</tbody></table>
<ul>
<li>将变量 <code>a</code> 赋值为 <code>2</code></li>
</ul>
<table>
<thead>
<tr>
<th align="center">代码</th>
<th align="center">图示</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a = 2</td>
<td align="center"><img src="/2020/12/21/16%E5%8F%98%E9%87%8F%E8%BF%9B%E9%98%B6%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89/14982751015713/005_a2tag.png" alt="005_a2tag">)<img src="/2020/12/21/16%E5%8F%98%E9%87%8F%E8%BF%9B%E9%98%B6%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89/14982751015713/005_1.png" alt="005_1"></td>
</tr>
</tbody></table>
<ul>
<li>定义一个整数变量 <code>b</code>，并且将变量 <code>a</code> 的值赋值给 <code>b</code></li>
</ul>
<table>
<thead>
<tr>
<th align="center">代码</th>
<th align="center">图示</th>
</tr>
</thead>
<tbody><tr>
<td align="center">b = a</td>
<td align="center"><img src="/2020/12/21/16%E5%8F%98%E9%87%8F%E8%BF%9B%E9%98%B6%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89/14982751015713/006_ab2tag.png" alt="006_ab2tag"></td>
</tr>
</tbody></table>
<blockquote>
<p>变量 <code>b</code> 是第 2 个贴在数字 <code>2</code> 上的标签</p>
</blockquote>
<h3 id="1-3-函数的参数和返回值的传递"><a href="#1-3-函数的参数和返回值的传递" class="headerlink" title="1.3 函数的参数和返回值的传递"></a>1.3 函数的参数和返回值的传递</h3><p>在 <code>Python</code> 中，函数的 <strong>实参</strong>/<strong>返回值</strong> 都是是靠 <strong>引用</strong> 来传递来的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(num)</span>:</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"-"</span> * <span class="number">50</span>)</span><br><span class="line">    print(<span class="string">"%d 在函数内的内存地址是 %x"</span> % (num, id(num)))</span><br><span class="line"></span><br><span class="line">    result = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"返回值 %d 在内存中的地址是 %x"</span> % (result, id(result)))</span><br><span class="line">    print(<span class="string">"-"</span> * <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  result</span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">print(<span class="string">"调用函数前 内存地址是 %x"</span> % id(a))</span><br><span class="line"></span><br><span class="line">r = test(a)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"调用函数后 实参内存地址是 %x"</span> % id(a))</span><br><span class="line">print(<span class="string">"调用函数后 返回值内存地址是 %x"</span> % id(r))</span><br></pre></td></tr></table></figure>

<h2 id="02-可变和不可变类型"><a href="#02-可变和不可变类型" class="headerlink" title="02. 可变和不可变类型"></a>02. 可变和不可变类型</h2><ul>
<li><p><strong>不可变类型</strong>，内存中的数据不允许被修改：</p>
<ul>
<li>数字类型 <code>int</code>, <code>bool</code>, <code>float</code>, <code>complex</code>, <code>long(2.x)</code></li>
<li>字符串 <code>str</code></li>
<li>元组 <code>tuple</code></li>
</ul>
</li>
<li><p><strong>可变类型</strong>，内存中的数据可以被修改：</p>
<ul>
<li>列表 <code>list</code></li>
<li>字典 <code>dict</code></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">a = <span class="string">"hello"</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">a = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">demo_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">"定义列表后的内存地址 %d"</span> % id(demo_list))</span><br><span class="line"></span><br><span class="line">demo_list.append(<span class="number">999</span>)</span><br><span class="line">demo_list.pop(<span class="number">0</span>)</span><br><span class="line">demo_list.remove(<span class="number">2</span>)</span><br><span class="line">demo_list[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"修改数据后的内存地址 %d"</span> % id(demo_list))</span><br><span class="line"></span><br><span class="line">demo_dict = &#123;<span class="string">"name"</span>: <span class="string">"小明"</span>&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="string">"定义字典后的内存地址 %d"</span> % id(demo_dict))</span><br><span class="line"></span><br><span class="line">demo_dict[<span class="string">"age"</span>] = <span class="number">18</span></span><br><span class="line">demo_dict.pop(<span class="string">"name"</span>)</span><br><span class="line">demo_dict[<span class="string">"name"</span>] = <span class="string">"老王"</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"修改数据后的内存地址 %d"</span> % id(demo_dict))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：字典的 <code>key</code> <strong>只能使用不可变类型的数据</strong></p>
</blockquote>
<p><strong>注意</strong></p>
<ol>
<li><strong>可变类型</strong>的数据变化，是通过 <strong>方法</strong> 来实现的</li>
<li>如果给一个可变类型的变量，赋值了一个新的数据，<strong>引用会修改</strong><ul>
<li>变量 <strong>不再</strong> 对之前的数据引用</li>
<li>变量 <strong>改为</strong> 对新赋值的数据引用</li>
</ul>
</li>
</ol>
<h3 id="哈希-hash"><a href="#哈希-hash" class="headerlink" title="哈希 (hash)"></a>哈希 <code>(hash)</code></h3><ul>
<li><code>Python</code> 中内置有一个名字叫做 <code>hash(o)</code> 的函数<ul>
<li>接收一个 <strong>不可变类型</strong> 的数据作为 <strong>参数</strong></li>
<li><strong>返回</strong> 结果是一个 <strong>整数</strong></li>
</ul>
</li>
<li><code>哈希</code> 是一种 <strong>算法</strong>，其作用就是提取数据的 <strong>特征码（指纹）</strong><ul>
<li><strong>相同的内容</strong> 得到 <strong>相同的结果</strong></li>
<li><strong>不同的内容</strong> 得到 <strong>不同的结果</strong></li>
</ul>
</li>
<li>在 <code>Python</code> 中，设置字典的 <strong>键值对</strong> 时，会首先对 <code>key</code> 进行 <code>hash</code> 已决定如何在内存中保存字典的数据，以方便 <strong>后续</strong> 对字典的操作：<strong>增、删、改、查</strong><ul>
<li>键值对的 <code>key</code> 必须是不可变类型数据</li>
<li>键值对的 <code>value</code> 可以是任意类型的数据</li>
</ul>
</li>
</ul>
<h2 id="03-局部变量和全局变量"><a href="#03-局部变量和全局变量" class="headerlink" title="03. 局部变量和全局变量"></a>03. 局部变量和全局变量</h2><ul>
<li><strong>局部变量</strong> 是在 <strong>函数内部</strong> 定义的变量，<strong>只能在函数内部使用</strong></li>
<li><strong>全局变量</strong> 是在 <strong>函数外部定义</strong> 的变量（没有定义在某一个函数内），<strong>所有函数</strong> 内部 <strong>都可以使用这个变量</strong></li>
</ul>
<blockquote>
<p>提示：在其他的开发语言中，大多 <strong>不推荐使用全局变量</strong> —— 可变范围太大，导致程序不好维护！</p>
</blockquote>
<h3 id="3-1-局部变量"><a href="#3-1-局部变量" class="headerlink" title="3.1 局部变量"></a>3.1 局部变量</h3><ul>
<li><strong>局部变量</strong> 是在 <strong>函数内部</strong> 定义的变量，<strong>只能在函数内部使用</strong></li>
<li>函数执行结束后，<strong>函数内部的局部变量，会被系统回收</strong></li>
<li>不同的函数，可以定义相同的名字的局部变量，但是 <strong>彼此之间</strong> 不会产生影响</li>
</ul>
<h4 id="局部变量的作用"><a href="#局部变量的作用" class="headerlink" title="局部变量的作用"></a>局部变量的作用</h4><ul>
<li>在函数内部使用，<strong>临时</strong> 保存 <strong>函数内部需要使用的数据</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo1</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line">    num = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"修改后 %d"</span> % num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo2</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    num = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line">demo1()</span><br><span class="line">demo2()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"over"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="局部变量的生命周期"><a href="#局部变量的生命周期" class="headerlink" title="局部变量的生命周期"></a>局部变量的生命周期</h4><ul>
<li>所谓 <strong>生命周期</strong> 就是变量从 <strong>被创建</strong> 到 <strong>被系统回收</strong> 的过程</li>
<li><strong>局部变量</strong> 在 <strong>函数执行时</strong> 才会被创建</li>
<li><strong>函数执行结束后</strong> 局部变量 <strong>被系统回收</strong></li>
<li><strong>局部变量在生命周期</strong> 内，可以用来存储 <strong>函数内部临时使用到的数据</strong></li>
</ul>
<h3 id="3-2-全局变量"><a href="#3-2-全局变量" class="headerlink" title="3.2 全局变量"></a>3.2 全局变量</h3><ul>
<li><strong>全局变量</strong> 是在 <strong>函数外部定义</strong> 的变量，所有函数内部都可以使用这个变量</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个全局变量</span></span><br><span class="line">num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo1</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo2</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line">demo1()</span><br><span class="line">demo2()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"over"</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：函数执行时，<strong>需要处理变量时</strong> 会：</p>
<ol>
<li><strong>首先</strong> 查找 <strong>函数内部</strong> 是否存在 <strong>指定名称 的局部变量</strong>，<strong>如果有，直接使用</strong></li>
<li>如果没有，查找 <strong>函数外部</strong> 是否存在 <strong>指定名称 的全局变量</strong>，<strong>如果有，直接使用</strong></li>
<li>如果还没有，程序报错！</li>
</ol>
<h4 id="1-函数不能直接修改-全局变量的引用"><a href="#1-函数不能直接修改-全局变量的引用" class="headerlink" title="1) 函数不能直接修改 全局变量的引用"></a>1) 函数不能直接修改 <code>全局变量的引用</code></h4><ul>
<li><strong>全局变量</strong> 是在 <strong>函数外部定义</strong> 的变量（没有定义在某一个函数内），<strong>所有函数</strong> 内部 <strong>都可以使用这个变量</strong></li>
</ul>
<blockquote>
<p>提示：在其他的开发语言中，大多 <strong>不推荐使用全局变量</strong> —— 可变范围太大，导致程序不好维护！</p>
</blockquote>
<ul>
<li>在函数内部，可以 <strong>通过全局变量的引用获取对应的数据</strong></li>
<li>但是，<strong>不允许直接修改全局变量的引用</strong> —— 使用赋值语句修改全局变量的值</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo1</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"demo1"</span> + <span class="string">"-"</span> * <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已</span></span><br><span class="line">    num = <span class="number">100</span></span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo2</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"demo2"</span> + <span class="string">"-"</span> * <span class="number">50</span>)</span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line">demo1()</span><br><span class="line">demo2()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"over"</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：只是在函数内部定义了一个局部变量而已，只是变量名相同 —— 在函数内部不能直接修改全局变量的值</p>
</blockquote>
<h4 id="2-在函数内部修改全局变量的值"><a href="#2-在函数内部修改全局变量的值" class="headerlink" title="2) 在函数内部修改全局变量的值"></a>2) 在函数内部修改全局变量的值</h4><ul>
<li>如果在函数中需要修改全局变量，需要使用 <code>global</code> 进行声明</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo1</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"demo1"</span> + <span class="string">"-"</span> * <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># global 关键字，告诉 Python 解释器 num 是一个全局变量</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="comment"># 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已</span></span><br><span class="line">    num = <span class="number">100</span></span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo2</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"demo2"</span> + <span class="string">"-"</span> * <span class="number">50</span>)</span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line">demo1()</span><br><span class="line">demo2()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"over"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3-全局变量定义的位置"><a href="#3-全局变量定义的位置" class="headerlink" title="3) 全局变量定义的位置"></a>3) 全局变量定义的位置</h4><ul>
<li>为了保证所有的函数都能够正确使用到全局变量，应该 <strong>将全局变量定义在其他函数的上方</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"%d"</span> % a)</span><br><span class="line">    print(<span class="string">"%d"</span> % b)</span><br><span class="line">    print(<span class="string">"%d"</span> % c)</span><br><span class="line"></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line">demo()</span><br><span class="line">c = <span class="number">30</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>由于全局变量 c，是在调用函数之后，才定义的，在执行函数时，变量还没有定义，所以程序会报错！</li>
</ul>
<p><strong>代码结构示意图如下</strong></p>
<p><img src="/2020/12/21/16%E5%8F%98%E9%87%8F%E8%BF%9B%E9%98%B6%EF%BC%88%E7%90%86%E8%A7%A3%EF%BC%89/14982751015713/001_%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="001_代码结构示意图-w240"></p>
<h4 id="4-全局变量命名的建议"><a href="#4-全局变量命名的建议" class="headerlink" title="4) 全局变量命名的建议"></a>4) 全局变量命名的建议</h4><ul>
<li>为了避免局部变量和全局变量出现混淆，在定义全局变量时，有些公司会有一些开发要求，例如：</li>
<li>全局变量名前应该增加 <code>g_</code> 或者 <code>gl_</code> 的前缀</li>
</ul>
<blockquote>
<p>提示：具体的要求格式，各公司要求可能会有些差异</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">KJH</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KJH</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
