<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:type" content="website">
<meta property="og:title" content="KJHの博客">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="KJHの博客">
<meta property="og:description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="匡俊桦">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>KJHの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>


<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KJHの博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录&回忆</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E6%89%80%E6%9C%89%E6%8C%87%E4%BB%A43/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E6%89%80%E6%9C%89%E6%8C%87%E4%BB%A43/" class="post-title-link" itemprop="url">汇编语言的所有指令3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-02 12:36:45 / 修改时间：17:54:30" itemprop="dateCreated datePublished" datetime="2021-01-02T12:36:45+08:00">2021-01-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96/" itemprop="url" rel="index"><span itemprop="name">汇编</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一、数据传送指令<br>1、传送指令：MOV (move)</p>
<p>格式：mov dst,src<br>具体用法：</p>
<p>(1) CPU内部寄存器之间的数据传送，如：mov ah,al</p>
<p>(2) 立即数送至通用寄存器(非段寄存器)或存储单元，如:mov al,3     mov [bx],1234h</p>
<p>(3) 寄存器与存储器间的数据传送，如：mov ax,var     mov ax,[bx]</p>
<p>2、交换指令：XCHG</p>
<p>xchg OPRD1,OPRD2   ;OPRD可以是通用寄存器或存储单元，但不包括段寄存器，不能同时是存储单元，不能有立即数<br>3、地址传送指令：LEA、LDS、LES</p>
<p>(1) LEA(Load Effective Address)<br>  格式：  lea REG,OPRD<br>  功能：  把操作数OPRD的有效地址传送到操作数REG<br>   注：   REG必须是16位通用寄存器，OPRD必须是一个存储器操作数</p>
<p>   如：   lea ax,buf       ;buf是变量名<br>      lea ax,[si+2]<br>(2) LDS(Load pointer into DS)<br>  格式：  lds REG,OPRD<br>  功能：  传送32位地址指针，将OPRD存储的32位数的高16位（段地址）送至DS，低16位（偏移地址）送至REG。（注意OPRD存放的32位数据，不是OPRD本身的地址）<br>   注：   操作数OPRD必须是一个32位存储器操作数，操作数REG可以时16位通用寄存器，但通常是指令指针寄存器（IP）或变址寄存器（SI，DI，SP，BP）</p>
<p>   如：    lds di,[bx]<br>      lds si,FARPOINTER    ;FARPOINTER是一个32位（双字）变量<br>(3) LES(Load pointer into ES)<br>  格式：    les REG,OPRD<br>  功能：    把操作数OPRD存储的32位数据的高16位（段地址）送至ES，低16位（偏移地址）送至REG</p>
<p>  其他同LDS<br>二、堆栈操作指令<br>1、进栈指令：push</p>
<p>格式：push src<br>功能： 把16位数据src压入堆栈。<br>注：   源操作数src可以是通用寄存器和段寄存器，也可以是字存储单元</p>
<p>如：  push si<br>   push [si]<br>   push var     ;var是16位（字）变量<br>2、出栈指令：pop</p>
<p>格式：pop dst<br>功能：从堆栈弹出16位数据至dst<br>注： dst可以是通用寄存器和段寄存器，但不能是CS，可以是字存储单元</p>
<p>如： pop si<br>  pop [si]<br>  pop var       ;var是字变量<br>三、标志操作指令<br>1、标志传送指令：LAHF(Load AH with Flags)、SAHF(Store AH into Flags)、PUSHF、POPF</p>
<p>(1) LAHF(Load AH with Flags)<br>  格式：LAHF<br>  功能：把标志寄存器的低8位（包括SF(7)、ZF(6)、AF(4)、PF(2)、CF(0)）传送到AH指定位。</p>
<p>(2) SAHF(Store AH into Flags)<br>  格式：SAHF<br>  功能：把寄存器AH的指定位送至标志寄存器低8位（包括SF(7)、ZF(6)、AF(4)、PF(2)、CF(0)）。</p>
<p>(3) PUSHF<br>  格式：PUSHF<br>  功能：把标志寄存器的内容（16位）压入堆栈。SP-=2<br>  注： 这条指令不影响标志位</p>
<p>(4) POPF<br>  格式：POPF<br>  功能：把当前栈顶的一个字传送到标志寄存器。SP+=2<br>2、标志位操作指令：CLC、STC、CMC、CLD、STD、CLI、STI</p>
<p>(1) CLC(Clear Carry Flag):         CF置0<br>(2) STC(Set Carry Flag):         CF置1</p>
<p>(3) CMC(Complement Carry Flag):       CF取反</p>
<p>(4) CLD(Clear Direction Flag):       DF置0，执行串操作指令时，地址递增<br>(5) STD(Set Direction Flag):       DF置1，执行串操作指令时，地址递减</p>
<p>(6) CLI(Clear Interrupt enable Flag)   IF置0，使CPU不响应来自外部装置的可屏蔽中断，但对不可屏蔽中断和内部中断没有影响<br>(7) STI(Set Interrupt enable Flag)     IF置1，可以响应可屏蔽中断<br>四、加减运算指令<br>加减法运算对无符号数和有符号数的处理一视同仁。即作为无符号数而影响标志位CF和AF，也作为有符号数影响标识OF和SF，且总会影响ZF。加减法运算指令也要影响标志位PF。有些指令稍有例外。<br>存放运算结果的操作数（两个操作数时即左操作数）只能是通用寄存器或存储单元（变量）。如果参与运算的操作数有两个，则最多只能有一个是存储器操作数。<br>如果参与运算的操作数有两个，则它们的类型必须一致，如同时为字节或同时为字等。<br>1、加法指令：add、adc、inc</p>
<p>(1) add(Addtion)<br>  格式：add OPRD1,OPRD2<br>  功能：OPRD1 = OPRD1 + OPRD2<br>  注：  影响FLAG</p>
<p>  如：add al,5<br>      add bl,var     ;var是字节变量<br>      add var,si     ;var是字变量</p>
<p>(2) adc(add with Carry)     ;带进位的加法<br>  格式：adc OPRD1,OPRD2<br>  功能：带进位的加法，OPRD1 = OPRD1 + OPRD2 + CF<br>  注：   影响FLAG，主要用于多字节运算</p>
<p>  如：   adc al,[bx]<br>     adc dx,ax<br>     adc dx,var     ;var是字变量</p>
<p>(3) inc(Increment)<br>  格式：inc OPRD<br>  功能：OPRD = OPRD + 1<br>  注： 不影响CF</p>
<p>  如：inc al<br>    inc var       ;var是字节变量，也可以是字变量<br>    inc cx<br>2、减法指令：sub、sbb、dec、neg、cmp</p>
<p>(1) sub(Subtraction)<br>  格式：sub OPRD1，OPRD2<br>  功能：OPRD1 = OPRD1 - OPRD2</p>
<p>  如：  sub ah,12<br>     sub bx,bp<br>     sub al,[bx]<br>     sub [BP],AX<br>     sub AX,VAR     ;VAR是字变量</p>
<p>(2) sbb(Sub with Borrow)<br>  格式：sbb OPRD1,OPRD2<br>  功能：OPRD1 = OPRD1 - OPRD2 - CF<br>  注：   主要用于多字节数相减的情况</p>
<p>(3) dec(decrement)<br>  格式：dec OPRD<br>  功能：OPRD = OPRD - 1<br>  注：   操作数OPRD可以是通用寄存器，也可以是存储单元。相减时把操作数作为一个无符号数对待，这条指令影响ZF、SP、OF、PF、AF，但不影响CF，该指令主要用于调整地址指针和计数器。</p>
<p>(4) neg(Negate)<br>  格式：NEG OPRD<br>  功能：对操作数取补，即OPRD = 0 - OPRD<br>  注： 操作数可以是通用寄存器，也可以是存储单元。此指令结果影响CF、ZF、OF、AF、PF，一般会使CF为1，除非OPRD=0</p>
<p>(5)   cmp(Compare)<br>  格式：cmp OPRD1,OPRD2<br>  功能：执行OPRD1 - OPRD2，但运算结果不运送到OPRD1<br>  注：   该指令通过OPRD - OPRD2影响标志位CF、ZF、SF、OF、AF、PF来判断OPRD1和OPRD2的大小关系。通过ZF判断是否相等；如果是无符号数，通过CF可判断大小；如果是有符号数，通过SF和OF判断大小<br>五、乘除运算指令<br>1、乘法指令：mul、imul</p>
<p>(1) mul(Multiply)       ;无符号数乘法指令<br>  格式：MUL OPRD<br>  功能：将OPRD与AX或AL中的操作数相乘，结果保存在DX:AX中或AX中<br>  注： 无符号数相乘分为16位<em>16位和8位</em>8位，结果分别为32位和16位，保存在DX:AX中或AX中，其中结果为32位时，DX为高16位，AX为低16位；结果为16位时，AH为高8位，AL为低8位。</p>
<p>(2) imul(Signed Multiply)   ;有符号数乘法指令<br>  格式：IMUL OPRD<br>  功能：把乘数和被乘数均作为有符号数进行乘法运算。其余与mul类似<br>  注：   如果乘积结果的高位部分（DX或AH）不是低位的符号扩展，则CF=1，OF=1，否则CF=0，OF=0。即CF=1，OF=1表示AH或DX中含有结果的有效数。<br>     如果除数为0，或8位数除时商超过8位，16位数除时商超过16位，则认为是除溢出，引起0号中断。除法指令对标志位的影响无定义。<br>2、除法指令：div、idiv</p>
<p>(1) div(Division)       ;无符号数除法指令<br>  格式：DIV OPRD<br>  功能：OPRD为除数，被除数存放在DX:AX或AX中，做除法，结果存放在DX:AX（DX存放余数，AX存放商）或AX（AH余数，AL商）。<br>  注：   8086中除法有32位除以16位和16位除以8位。前者被除数为32位，高位在DX中，低位在AX中，除数OPRD为16位通用寄存器或16位存储器操作数，结果为16位，其中16位余数存放在DX中，16位商存放在AX中；若为16位除以8位，被除数存放在AX中，OPRD为8位通用寄存器或存储器操作数，结果8位余数存放在AH中，8位商存放在AL中。</p>
<p>(2) idiv(Signed Division)   ;有符号数除法指令<br>  格式：IDIV OPRD<br>  功能：把除数和被除数看做有符号数做除法，其余与div类似<br>3、符号扩展指令：cbw、cwd</p>
<p>(1) cbw(Convert Byte to Word)<br>  格式：CBW<br>  功能：把寄存器AL中的符号位扩展到寄存器AH</p>
<p>(2) cwd(Convert Word to Double Word)<br>  格式：CWD<br>  功能：把寄存器AX中的符号扩展到寄存器DX<br>六、逻辑运算和移位指令<br>1、逻辑运算指令：not、and、or、xor、test</p>
<p>(1) NOT<br>  格式：NOT OPRD<br>  功能：把操作数OPRD取反，然后送回OPRD。<br>  注：   OPRD可以是通用寄存器，也可以是存储器操作数，此指令对标志没有影响</p>
<p>(2) AND<br>  格式：AND OPRD1,OPRD2<br>  功能：对两个操作数进行按位逻辑“与”运算，结果送到OPRD1中<br>  注： 该指令执行后，CF=0，OF=0，标志PF、ZF、SF反映运算结果，AF未定义。<br>     某个操作数与自身相与，值不变，但可以使CF置0。</p>
<p>(3) OR<br>  格式：OR OPRD1,OPRD2<br>  功能：对两个操作数进行按位逻辑“或”运算，结果送到OPRD1中<br>  注： 该指令执行后，CF=0，OF=0，标志PF、ZF、SF反映运算结果，AF未定义。<br>     某个操作数与自身相或，值不变，但可以使CF置0。</p>
<p>(4) XOR<br>  格式：XOR OPRD1,OPRD2<br>  功能：对两个操作数进行按位逻辑“异或”运算，结果送到OPRD1中<br>  注： 该指令执行后，CF=0，OF=0，标志PF、ZF、SF反映运算结果，AF未定义。</p>
<p>(5) TEST<br>  格式：TEST OPRD1,OPRD2<br>  功能：把OPRD1与OPRD2按位“与”，但结果不送到OPRD1中，仅影响标志位。<br>  注： 该指令执行后，CF=0，OF=0，标志PF、ZF、SF反映运算结果。常用于检测某些位是否为1<br>2、一般移位指令：SAL/SHL,SAR/SHR</p>
<p>(1) SAL/SHL(Shift Arithmetic Left / Shift Logic Left)     ;算术左移/逻辑左移<br>  格式：SAL OPRD,m<br>     SHL OPRD,m<br>  功能：把操作数OPRD左移m位，每移动一位，右边用0补足1位，移出的最高位进入标志位CF<br>  注：   算术左移和逻辑左移进行相同的动作，为了方便提供了两个助记符。</p>
<p>(2) SAR(Shift Arithmetic Right)                 ;算数右移指令<br>  格式：SAR OPRD,m<br>  功能：操作数右移m位，同时每移1位，左边的符号位保持不变，移出的最低位进入标志位CF<br>  注：   对有符号数和无符号数，算数右移1位相当于除以2</p>
<p>(3) SHR(Shift Logic Right)                   ;逻辑右移指令<br>  格式：SHR OPRD,m<br>  功能：操作数右移m位，同时每移1位，左边用0补足，移出的最低位进入标志位CF<br>  注：   对无符号数，逻辑右移1位相当于除以2<br>3、循环移位指令：ROL、ROR、RCL、RCR</p>
<p>格式：</p>
<p>ROL OPRD,m</p>
<p>ROR OPRD,m</p>
<p>RCL OPRD,m</p>
<p>RCR OPRD,m</p>
<p>这些指令只影响CF和OF<br>七、转移指令<br>1、无条件转移指令：JMP(Jump)</p>
<p>段内转移：改变IP<br>段间转移：改变CS:IP</p>
<p>(1) 无条件段内直接转移指令<br>  格式：JMP 标号<br>  功能：使控制无条件转移至标号地址处<br>  原理：把编译时计算出的地址差加到IP上</p>
<p>(2) 无条件段内间接转移指令<br>  格式：JMP OPRD<br>  功能：使控制指令无条件转移到OPRD的内容给定的目标地址处。操作数OPRD可以是通用寄存器，也可以是字存储单元<br>  例如：jmp cx           ;CX寄存器的内容送IP<br>     jmp word ptr [1234h]   ;字存储单元[1234h]的内容送IP</p>
<p>(3) 无条件段间直接转移指令<br>  格式：jmp far ptr 标号<br>  功能：使控制指令无条件的转移到标号对应的地址处<br>  原理：把编译时产生的标号处的段地址和偏移地址分别置入CS和IP</p>
<p>(4) 无条件段间间接转移指令<br>  格式：JMP OPRD<br>  功能：使控制指令无条件转移到操作数OPRD的内容给定的目标地址处。操作数OPRD必须是双字存储单元<br>  例如：jmp dword ptr [1234h]   ;双字存储单元的低字内容送IP，高字内容送CS<br>2、条件转移指令</p>
<p>3、循环指令：LOOP、LOOPE/LOOPZ、LOOPNE/LOOPNZ、JCXZ</p>
<p>(1) Loop       ;计数循环指令<br>  格式：loop 标号<br>  功能：使转移标号与Loop指令间的指令循环执行CX次<br>  原理：指令执行至loop时，cx减1，如果cx不为0，则跳转至标号处，否则继续执行下一条指令<br>    即：DEC CX<br>      JNZ 标号</p>
<p>(2) LOOPE/LOOPZ     ;等于/全零循环指令<br>  格式：LOOPE 标号<br>     LOOPZ 标号<br>  功能：该指令使CX自减1，若结果不为0，并且ZF=1，则转移至标号，否则顺序执行。注意指令本身实施的CX自减1操作不影响标志</p>
<p>(3) LOOPNE/LOOPNZ   ;不等于/非零循环指令<br>  格式：LOOPNE 标号<br>     LOOPNZ 标号<br>  功能：该指令使CX自减1，若结果不为0，并且ZF=0，则转移至标号，否则顺序执行。注意指令本身实施的CX自减1操作不影响标志</p>
<p>(4) JCXZ       ;跳转指令<br>  格式：JCXZ 标号<br>  功能：当寄存器CX的值为0时跳转到标号，否则顺序执行<br>-——————– </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">汇编语言加减乘除命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-02 10:41:22 / 修改时间：17:50:58" itemprop="dateCreated datePublished" datetime="2021-01-02T10:41:22+08:00">2021-01-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96/" itemprop="url" rel="index"><span itemprop="name">汇编</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>281</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1、加法指令"><a href="#1、加法指令" class="headerlink" title="1、加法指令"></a>1、加法指令</h2><h3 id="1-1、add-dst（目标操作数），src"><a href="#1-1、add-dst（目标操作数），src" class="headerlink" title="1.1、add dst（目标操作数），src"></a>1.1、add dst（目标操作数），src</h3><p>将dst（只能是寄存器或者存储器）+src送给dst（无符号加法）</p>
<h3 id="1-2、adc-dst，src"><a href="#1-2、adc-dst，src" class="headerlink" title="1.2、adc dst，src"></a>1.2、adc dst，src</h3><p>将dst+src+CF送给dst（带进位、借位的加法）</p>
<h3 id="1-3、inc-oprd（寄存器或者存储器）"><a href="#1-3、inc-oprd（寄存器或者存储器）" class="headerlink" title="1.3、inc oprd（寄存器或者存储器）"></a>1.3、inc oprd（寄存器或者存储器）</h3><p>将oprd+1送给oprd（即自增1运算）</p>
<h2 id="2、减法指令"><a href="#2、减法指令" class="headerlink" title="2、减法指令"></a>2、减法指令</h2><h3 id="2-1、sub-dst，src"><a href="#2-1、sub-dst，src" class="headerlink" title="2.1、sub dst，src"></a>2.1、sub dst，src</h3><p>将dst（只能是寄存器或者存储器）-src送给dst（无符号减法）</p>
<h3 id="2-2、sbb-dst，src"><a href="#2-2、sbb-dst，src" class="headerlink" title="2.2、sbb dst，src"></a>2.2、sbb dst，src</h3><p>将dst+src-CF送给dst（带进位、借位的减法）</p>
<h3 id="2-3、dec-oprd"><a href="#2-3、dec-oprd" class="headerlink" title="2.3、dec oprd"></a>2.3、dec oprd</h3><p>将oprd-1送给oprd（即自减1运算）</p>
<h2 id="3、乘法指令"><a href="#3、乘法指令" class="headerlink" title="3、乘法指令"></a>3、乘法指令</h2><h2 id="4、除法指令"><a href="#4、除法指令" class="headerlink" title="4、除法指令"></a>4、除法指令</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86Flag%E6%A0%87%E5%BF%97%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86Flag%E6%A0%87%E5%BF%97%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">汇编语言处理Flag标志命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-02 10:37:35 / 修改时间：10:40:54" itemprop="dateCreated datePublished" datetime="2021-01-02T10:37:35+08:00">2021-01-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96/" itemprop="url" rel="index"><span itemprop="name">汇编</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>69</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1、处理机命令"><a href="#1、处理机命令" class="headerlink" title="1、处理机命令"></a>1、处理机命令</h2><p>clc： 使CF=0</p>
<p>stc：使CF=1</p>
<p>cmc:CF取反</p>
<p>cld：使DF=0</p>
<p>std：使DF=1</p>
<p>cli：使IF=0</p>
<p>sti：使IF=1</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E7%B1%BB/" class="post-title-link" itemprop="url">汇编语言寄存器分类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-02 10:15:08 / 修改时间：10:37:30" itemprop="dateCreated datePublished" datetime="2021-01-02T10:15:08+08:00">2021-01-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96/" itemprop="url" rel="index"><span itemprop="name">汇编</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>248</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>寄存器共分为14个16位的寄存器。</p>
<h2 id="1、8个通用寄存器"><a href="#1、8个通用寄存器" class="headerlink" title="1、8个通用寄存器"></a>1、8个通用寄存器</h2><h3 id="1-1、4个数据寄存器"><a href="#1-1、4个数据寄存器" class="headerlink" title="1.1、4个数据寄存器"></a>1.1、4个数据寄存器</h3><p>AX:累加器</p>
<p>BX:基址寄存器</p>
<p>CX:计数器</p>
<p>DX:数据寄存器</p>
<h3 id="1-2、2个变址寄存器"><a href="#1-2、2个变址寄存器" class="headerlink" title="1.2、2个变址寄存器"></a>1.2、2个变址寄存器</h3><p>SI:源变址寄存器</p>
<p>DI:目标变址寄存器</p>
<h3 id="1-3、2个指针寄存器"><a href="#1-3、2个指针寄存器" class="headerlink" title="1.3、2个指针寄存器"></a>1.3、2个指针寄存器</h3><p>BP:基址指针寄存器</p>
<p>SP:堆栈栈顶寄存器</p>
<h2 id="2、4个段寄存器"><a href="#2、4个段寄存器" class="headerlink" title="2、4个段寄存器"></a>2、4个段寄存器</h2><p>CS:代码段寄存器</p>
<p>DS:数据段寄存器 </p>
<p><strong>用于存放源数据</strong></p>
<p>ES:附加数据段寄存器</p>
<p><strong>用于存放目标数据</strong></p>
<p>SS:堆栈段寄存器</p>
<h2 id="3、2个控制寄存器"><a href="#3、2个控制寄存器" class="headerlink" title="3、2个控制寄存器"></a>3、2个控制寄存器</h2><p>IP:指令指针寄存器</p>
<p><strong>用于存放将要执行的下一条指令的偏移地址</strong></p>
<p>FLAG:标志寄存器 CPAZSO(状态寄存器)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A41/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A41/" class="post-title-link" itemprop="url">汇编语言数据传送指令1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-01 22:58:11 / 修改时间：22:59:13" itemprop="dateCreated datePublished" datetime="2021-01-01T22:58:11+08:00">2021-01-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96/" itemprop="url" rel="index"><span itemprop="name">汇编</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据传送类指令"><a href="#数据传送类指令" class="headerlink" title="数据传送类指令"></a>数据传送类指令</h1><p>作用：把数据、地址或立即数传送到寄存器或存储单元中</p>
<h3 id="通用传送指令"><a href="#通用传送指令" class="headerlink" title="通用传送指令"></a>通用传送指令</h3><h5 id="传送指令MOV"><a href="#传送指令MOV" class="headerlink" title="传送指令MOV"></a>传送指令MOV</h5><ul>
<li>格式：MOV 目的操作数，源操作数<br>功能：将源操作数的内容传送给目的操作数，源操作数不变</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A41/20200507141512860.png" alt="在这里插入图片描述"></p>
<ul>
<li>注：MOV指令不改变标志位。<br>操作数的位数需要匹配。即8位配8位，16位配16位<br>两个操作数不能同时为段寄存器，也不能为存储器<br>CS不能作为目的操作数<br>IP不能做目的操作数和源操作数<br>立即数不能直接传送给段寄存器<br>对于存储器单元与立即数同时作为操作数的情况，必须显式指明；byte ptr指示字节类型，word ptr指示字类型、</li>
<li>例子<br>MOV AX, 1010H<br>MOV BL, 58H<br>MOV BYTE PTR [BX], 10H<br>MOV WORD PTR [BX], 2255H<br>MOV BYTE PTR [SI+20H], 10H</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A41/20200721144944886.png" alt="在这里插入图片描述"></p>
<h5 id="数据交换指令XCHG"><a href="#数据交换指令XCHG" class="headerlink" title="数据交换指令XCHG"></a>数据交换指令XCHG</h5><ul>
<li>格式：XCHG 寄存器，存储器操作数/寄存器</li>
<li>功能：实现源操作数和目的操作数之间的的内容互换</li>
<li>注：不能存储器与存储器之间交换<br>XCHG指令不影响标志位</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">1234h</span>	；<span class="built_in">ax</span>=<span class="number">1234h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">5678h</span>	；<span class="built_in">bx</span>=<span class="number">5678h</span></span><br><span class="line"><span class="keyword">xchg</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br><span class="line">；<span class="built_in">ax</span>=<span class="number">5678h</span>，<span class="built_in">bx</span>=<span class="number">1234h</span></span><br><span class="line"><span class="keyword">xchg</span> <span class="number">ah</span>,<span class="built_in">al</span>	；<span class="built_in">ax</span>=<span class="number">7856h</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<h5 id="表转换指令XLAT-（了解）"><a href="#表转换指令XLAT-（了解）" class="headerlink" title="表转换指令XLAT （了解）"></a>表转换指令XLAT （了解）</h5><ul>
<li>格式 XLAT 或XLAT 首地址</li>
<li>功能：将AL与BX寄存器内容之和作为偏移地中，将其所对应的存储单元的内容送入AL寄存器。</li>
<li>执行前：在内存建立一个字节表格，内含要转换成的目的代码<br>BX——存放表格首地址<br>AL——存放相对表格首地址的偏移量</li>
<li>执行后：将AL寄存器的内容转换为目标代码<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A41/20200507142450852.png" alt="在这里插入图片描述"></li>
</ul>
<h3 id="堆栈存储指令（字操作-2个字节）"><a href="#堆栈存储指令（字操作-2个字节）" class="headerlink" title="堆栈存储指令（字操作 2个字节）"></a>堆栈存储指令（字操作 2个字节）</h3><ul>
<li>堆栈：后进先出FILO，位于堆栈段；SS段寄存器记录其段地址</li>
<li>堆栈只有一个出口，即当前栈顶；用堆栈指针寄存器SP指定</li>
</ul>
<h5 id="进栈指令PUSH"><a href="#进栈指令PUSH" class="headerlink" title="进栈指令PUSH"></a>进栈指令PUSH</h5><ul>
<li>PUSH：进栈指令先使堆栈指针SP-2，然后把一个字操作数存入堆栈顶部</li>
<li>格式： PUSH r16/m6/seg；sp&lt;-sp-2(高地址向低地址）<br>；SS：【SP】&lt;-r16/m16/seg<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A41/20200507144307680.png" alt="在这里插入图片描述"></li>
</ul>
<h5 id="出栈指令POP"><a href="#出栈指令POP" class="headerlink" title="出栈指令POP"></a>出栈指令POP</h5><ul>
<li>POP：出栈指令把栈顶的一个字传送至指定的目的操作数，然后堆栈指针SP+2</li>
<li>POP r16/m16/seg ;r16/m16/seg&lt;-SS:[SP]<br>;SP&lt;-SP+2</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A41/20200507144403629.png" alt="在这里插入图片描述"></p>
<ul>
<li>堆栈操作的单位是字，进栈和出栈只对字量<br>字量数据从栈顶压入和弹出时，都是低地址字节送低字节，高地址字节送高字节</li>
<li>堆栈操作遵循先进后出原则，但可用存储器寻址方式随机存取堆栈中的数据</li>
<li>作用：临时存放数据，传递参数，保存和恢复寄存器</li>
</ul>
<h3 id="地址传送指令"><a href="#地址传送指令" class="headerlink" title="地址传送指令"></a>地址传送指令</h3><p>功能：地址传送指令将存储器单元的逻辑地址送至指定的寄存器</p>
<h5 id="有效地址传送指令LEA"><a href="#有效地址传送指令LEA" class="headerlink" title="有效地址传送指令LEA"></a>有效地址传送指令LEA</h5><ul>
<li>特点：传送的是存储器操作数的地址（偏移地址，段地址），而不是内容源操作数必须是存储器操作数，目的操作数是16位通用寄存器。<br>OPD可为一个16位的通用寄存器，通常为：BX、BP、SI、DI。OPS可为变量名、标号或地址表达式。</li>
<li>LEA r16，mem<br>功能：将源操作数的有效地址传送至指定的16通用寄存器</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">BX</span>,<span class="number">0400H</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">SI</span>,<span class="number">3CH</span></span><br><span class="line"><span class="keyword">LEA</span> <span class="built_in">BX</span>,[<span class="built_in">BX</span>+<span class="built_in">SI</span>+<span class="number">0F62H</span>] ；<span class="built_in">BX</span>＝<span class="number">0400h</span>＋<span class="number">003ch</span>＋<span class="number">0f62h</span>＝<span class="number">139EH</span></span><br><span class="line"></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<ul>
<li>例子<br>设BX=0100H,DI=0030H,DS:[0030H]=2436H, 变量DATA的有效地址为0050H<br>LEA BP, [3000H] ;执行后 BP=3000H<br>LEA BX, [BX+DI] ;执行后 BX=0130H<br>LEA SI, DATA ;执行后 SI＝0050<br>LEA SI, [DI] ;执行后 SI=0030H<br>MOV SI, [DI] ;执行后 SI＝2436H</li>
</ul>
<h5 id="指针传送指令LDS-LES"><a href="#指针传送指令LDS-LES" class="headerlink" title="指针传送指令LDS,LES"></a>指针传送指令LDS,LES</h5><ul>
<li>LDS r16,mem；r16←mem， DS←mem+2<br>LDS指令将主存中mem指定的字送至r16，并将mem的下一字送DS寄存器</li>
<li>LES r16,mem；r16←mem， ES←mem+2<br>LES指令将主存中mem指定的字送至r16，并将mem的下一字送ES寄存器</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">WORD</span> <span class="built_in">PTR</span> [<span class="number">3060H</span>],<span class="number">0100H</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">WORD</span> <span class="built_in">PTR</span> [<span class="number">3062H</span>],<span class="number">1450H</span></span><br><span class="line"><span class="keyword">LES</span> <span class="built_in">DI</span>,[<span class="number">3060H</span>]	；<span class="built_in">DI</span>=<span class="number">0100H</span>，<span class="built_in">ES</span>=<span class="number">1450H</span></span><br><span class="line"><span class="keyword">LDS</span> <span class="built_in">SI</span>,[<span class="number">3060H</span>]	；<span class="built_in">SI</span>=<span class="number">0100H</span>，<span class="built_in">DS</span>=<span class="number">1450H</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E6%89%80%E6%9C%89%E6%8C%87%E4%BB%A42/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E6%89%80%E6%9C%89%E6%8C%87%E4%BB%A42/" class="post-title-link" itemprop="url">汇编语言的所有指令2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-01 22:22:47 / 修改时间：22:23:29" itemprop="dateCreated datePublished" datetime="2021-01-01T22:22:47+08:00">2021-01-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96/" itemprop="url" rel="index"><span itemprop="name">汇编</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="通用寄存器及使用"><a href="#通用寄存器及使用" class="headerlink" title="通用寄存器及使用"></a>通用寄存器及使用</h2><p>IA-32系列有8个32位通用寄存器，名称分别为：EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI，如图：</p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E6%89%80%E6%9C%89%E6%8C%87%E4%BB%A42/006tNbRwgy1fvx9rqlkatj31ae0tz7wh.jpg" alt="image-20181005131233985"></p>
<h4 id="简单传送指令"><a href="#简单传送指令" class="headerlink" title="简单传送指令"></a>简单传送指令</h4><table>
<thead>
<tr>
<th>指令</th>
<th>中文名</th>
<th>格式</th>
<th>解释</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>MOV</td>
<td>传送指令</td>
<td>MOV DEST,SRC</td>
<td>DEST&lt;=SRC</td>
<td></td>
</tr>
<tr>
<td>XCHG</td>
<td>交换指令</td>
<td>XCHG OPER1,OPER2</td>
<td>把操作数oper1的内容与操作数oper2的内容交换</td>
<td>oper1和oper2可以是通用寄存器或存储单元，但不能同时是操作单元，也不能是立即数。</td>
</tr>
</tbody></table>
<h4 id="简单加减指令"><a href="#简单加减指令" class="headerlink" title="简单加减指令"></a>简单加减指令</h4><table>
<thead>
<tr>
<th>指令</th>
<th>中文名</th>
<th>格式</th>
<th>解释</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>ADD</td>
<td>加法指令</td>
<td>ADD DEST,SRC</td>
<td>DEST&lt;=DEST SRC</td>
<td>两数相加</td>
</tr>
<tr>
<td>SUB</td>
<td>减法指令</td>
<td>SUB DEST,SRC</td>
<td>DEST&lt;=DEST-SRC</td>
<td>两数相减</td>
</tr>
<tr>
<td>INC</td>
<td>加1指令</td>
<td>INC DEST</td>
<td>DEST&lt;=DEST 1</td>
<td></td>
</tr>
<tr>
<td>DEC</td>
<td>减1指令</td>
<td>DEC DEST</td>
<td>DEST&lt;=DEST-1</td>
<td></td>
</tr>
<tr>
<td>NEG</td>
<td>取补指令</td>
<td>NEG OPRD</td>
<td>OPRD=0-OPRD</td>
<td>对操作数取补（相反数）</td>
</tr>
</tbody></table>
<h2 id="标志寄存器及其使用"><a href="#标志寄存器及其使用" class="headerlink" title="标志寄存器及其使用"></a>标志寄存器及其使用</h2><h3 id="状态标志"><a href="#状态标志" class="headerlink" title="状态标志"></a>状态标志</h3><table>
<thead>
<tr>
<th>标志</th>
<th>中文名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>CF（carry flag）</td>
<td>进位标志</td>
<td>主要反映算术运算是否产生进位或借位，若产生，则CF=1，否则CF=0</td>
</tr>
<tr>
<td>ZF</td>
<td>零标志</td>
<td>反映运算结果是否为0</td>
</tr>
<tr>
<td>SF（sign flag）</td>
<td>符号标志</td>
<td>根据运算结果的最高位，若最高位为1则SF为1，否则为0，反映了有符号数运算结果的正负（0正1负）</td>
</tr>
<tr>
<td>OF（overflow flag）</td>
<td>溢出标志</td>
<td>反映有符号数运算结果是否产生溢出，是置1，否置0</td>
</tr>
<tr>
<td>PF（parity flag）</td>
<td>奇偶标志</td>
<td>偶数置1奇数置0</td>
</tr>
<tr>
<td>AF</td>
<td>辅助进位标志</td>
<td></td>
</tr>
</tbody></table>
<h3 id="状态标志操作指令"><a href="#状态标志操作指令" class="headerlink" title="状态标志操作指令"></a>状态标志操作指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>中文名</th>
<th>格式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>CLC（clear carry flag）</td>
<td>清进位标志指令</td>
<td>CLC</td>
<td>使进位标志CF为0</td>
</tr>
<tr>
<td>STC(set carry flag)</td>
<td>置进位标志指令</td>
<td>STC</td>
<td>使进位标志CF为1</td>
</tr>
<tr>
<td>CMC（complement carry flag）</td>
<td>进位标志取反指令</td>
<td>CMC</td>
<td>使进位标志CF取反</td>
</tr>
<tr>
<td>LAHF（load status flags into AH register）</td>
<td>获取状态标志操作指令</td>
<td>LAHF</td>
<td>把位于标志寄存器低端的5个状态标志位（p26图2.3）信息同时送到寄存器AH的对应位</td>
</tr>
<tr>
<td>SAHF（store AH into Flags）</td>
<td>设置状态标志操作指令</td>
<td>SAHF</td>
<td>对标志寄存器中的低8位产生影响，使得状态标志位SF、ZF、AF、PF和CF分别成为来自寄存器AH中对应位的值，但保留位（位1、位3、位5）不受影响</td>
</tr>
</tbody></table>
<h3 id="带进位加减指令"><a href="#带进位加减指令" class="headerlink" title="带进位加减指令"></a>带进位加减指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>中文名</th>
<th>格式</th>
<th>解释</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>ADC（add with carry）</td>
<td>带进位加法指令</td>
<td>ADC DEST,SRC</td>
<td>DEST&lt;=DEST SRC CF</td>
<td>与add指令不同之处是要再加上进位标志cf的值</td>
</tr>
<tr>
<td>SBB(substraction with borrow)</td>
<td>带借位减法</td>
<td>SBB DEST,SRC</td>
<td>DEST&lt;=DEST-(SRC CF)</td>
<td>与sub指令不同之处是要再减上借位标志cf的值</td>
</tr>
</tbody></table>
<h3 id="取有效地址指令"><a href="#取有效地址指令" class="headerlink" title="取有效地址指令"></a>取有效地址指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>中文名</th>
<th>格式</th>
<th>解释</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>LEA（load effective address）</td>
<td>取有效地址指令</td>
<td>LEA REC,OPRD</td>
<td>把操作数oprd的有效地址传送到操作数rec，源操作数oprd必须是一个存储器操作数，目的操作数rec必须是一个16位或32位的通用寄存器</td>
<td>与mov指令的区别：mov：移动地址中的值lea：将地址进行移动</td>
</tr>
</tbody></table>
<h3 id="指令指针寄存器和简单控制转移指令"><a href="#指令指针寄存器和简单控制转移指令" class="headerlink" title="指令指针寄存器和简单控制转移指令"></a>指令指针寄存器和简单控制转移指令</h3><h4 id="常用条件转移指令"><a href="#常用条件转移指令" class="headerlink" title="常用条件转移指令"></a>常用条件转移指令</h4><p>location：p45</p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E6%89%80%E6%9C%89%E6%8C%87%E4%BB%A42/006tNbRwgy1fvxm0ya707j30vo0ychdt.jpg" alt="image-20181005201637040"></p>
<table>
<thead>
<tr>
<th>指令</th>
<th>中文名</th>
<th>格式</th>
<th>解释</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>CMP</td>
<td>比较指令</td>
<td>CMP DEST,SRC</td>
<td>根据dest-src的差影响各状态标志寄存器</td>
<td>不把dest-src的结果送入dest</td>
</tr>
<tr>
<td>JMP</td>
<td>无条件段内直接转移指令</td>
<td>JMP LABEL</td>
<td>使控制无条件地转移到标号为label的位置</td>
<td>无条件转移指令本身不影响标志</td>
</tr>
</tbody></table>
<h3 id="堆栈和堆栈操作"><a href="#堆栈和堆栈操作" class="headerlink" title="堆栈和堆栈操作"></a>堆栈和堆栈操作</h3><table>
<thead>
<tr>
<th>指令</th>
<th>中文名</th>
<th>格式</th>
<th>解释</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>PUSH</td>
<td>进栈指令</td>
<td>PUSH SRC</td>
<td>把源操作数src压入堆栈</td>
<td>源操作数src可以是32位通用寄存器、16位通用寄存器和段寄存器，也可以是双字存储单元或者字符存储单元，还可以是立即数</td>
</tr>
<tr>
<td>POP</td>
<td>出栈指令</td>
<td>POP DEST</td>
<td>从栈顶弹出一个双字或字数据到目的操作数</td>
<td>如果目的操作数是双字的，那么就从栈顶弹出一个双字数据，否则，从栈顶弹出一个字数据，出栈至少弹出一个字（16位）</td>
</tr>
<tr>
<td>PUSHA</td>
<td>16位通用寄存器全进栈指令</td>
<td>PUSHA</td>
<td>将所有8个16位通用寄存器的内容压入堆栈</td>
<td>压入顺序是AX CX DX BX SP BP SI DI，然后对战指针寄存器SP的值减16，所以SP进栈的内容是PUSHA指令执行之前的值</td>
</tr>
<tr>
<td>POPA</td>
<td>16位通用寄存器全出栈指令</td>
<td>POPA</td>
<td>以PUSHA相反的顺序从堆栈中弹出内容，从而恢复PUSHA之前的寄存器状态</td>
<td>SP的值不是由堆栈弹出的，而是通过增加16来恢复</td>
</tr>
<tr>
<td>PUSHAD</td>
<td>32位通用寄存器全进栈指令</td>
<td>PUSHAD</td>
<td>将所有8个32位通用寄存器的内容压入堆栈</td>
<td>压入顺序是EAX ECX EDX EBX ESP EBP ESI EDI，然后对战指针寄存器SP的值减32，所以SP进栈的内容是PUSHAD指令执行之前的值</td>
</tr>
<tr>
<td>POPAD</td>
<td>32位通用寄存器全出栈指令</td>
<td>POPAD</td>
<td>以PUSHAD相反的顺序从堆栈中弹出内容，从而恢复PUSHAD之前的寄存器状态</td>
<td>ESP的值不是由堆栈弹出的，而是通过增加32来恢复</td>
</tr>
</tbody></table>
<h2 id="过程调用和返回指令"><a href="#过程调用和返回指令" class="headerlink" title="过程调用和返回指令"></a>过程调用和返回指令</h2><table>
<thead>
<tr>
<th>指令</th>
<th>中文名</th>
<th>格式</th>
<th>解释</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>CALL</td>
<td>过程调用指令</td>
<td>CALL LABEL</td>
<td>段内直接调用LABEL</td>
<td>与jmp的区别在于call指令会在调用label之前保存返回地址（call 中return之后主程序还可以继续执行，jmp 当label执行完毕后不能返回主程序继续执行）</td>
</tr>
<tr>
<td>RET</td>
<td>段内过程返回指令</td>
<td>RET</td>
<td>使子程序结束，继续执行主程序</td>
<td></td>
</tr>
</tbody></table>
<h2 id="算术逻辑运算指令"><a href="#算术逻辑运算指令" class="headerlink" title="算术逻辑运算指令"></a>算术逻辑运算指令</h2><table>
<thead>
<tr>
<th>指令</th>
<th>中文名</th>
</tr>
</thead>
<tbody><tr>
<td>MUL</td>
<td>无符号数乘法指令</td>
</tr>
<tr>
<td>IMUL</td>
<td>有符号数乘法指令</td>
</tr>
<tr>
<td>IMUL DEST，SRC</td>
<td>有符号数乘法指令</td>
</tr>
<tr>
<td>IMUL DEST,SRC1,SRC2</td>
<td>有符号数乘法指令</td>
</tr>
<tr>
<td>DIV</td>
<td>无符号数除法指令</td>
</tr>
<tr>
<td>IDIV OPRD</td>
<td>有符号数除法指令</td>
</tr>
</tbody></table>
<h2 id="符号拓展指令"><a href="#符号拓展指令" class="headerlink" title="符号拓展指令"></a>符号拓展指令</h2><table>
<thead>
<tr>
<th>指令</th>
<th>中文名</th>
<th>格式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>CBW</td>
<td>字节转化为字指令</td>
<td>CBW</td>
<td>把寄存器AL中的值符号拓展到寄存器AH</td>
</tr>
<tr>
<td>CWD</td>
<td>字转化为双字指令</td>
<td>CWD</td>
<td>把寄存器AX中的值符号拓展到寄存器DX</td>
</tr>
<tr>
<td>CDQ</td>
<td>双字转化为四字指令</td>
<td>CDQ</td>
<td>把寄存器EAX中的值符号拓展到EDX</td>
</tr>
<tr>
<td>CWDE</td>
<td>字转化为双字指令</td>
<td>CWDE</td>
<td>把AX中的值符号拓展到EAX的高16位</td>
</tr>
</tbody></table>
<h2 id="拓展传送指令"><a href="#拓展传送指令" class="headerlink" title="拓展传送指令"></a>拓展传送指令</h2><table>
<thead>
<tr>
<th>指令</th>
<th>中文名</th>
<th>格式</th>
<th>解释</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>MOVSX</td>
<td>符号拓展传送指令</td>
<td>MOVSX DEST,SRC</td>
<td>把源操作数SRC符号拓展后送至目的操作数DEST</td>
<td>src可以是通用寄存器或者存储单元，但是dest只能是通用寄存器（零拓展传送指令不会改变源操作数，也不影响标志寄存器的状态）</td>
</tr>
<tr>
<td>MOVZX</td>
<td></td>
<td>MOVZX DEST,SRC</td>
<td>把源操作数SRC零拓展后送至目的操作数DEST</td>
<td>零拓展传送指令不会改变源操作数，也不影响标志寄存器的状态</td>
</tr>
</tbody></table>
<h2 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h2><table>
<thead>
<tr>
<th>指令</th>
<th>中文名</th>
<th>格式</th>
<th>解释</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>NOT</td>
<td>否运算指令</td>
<td>NOT OPRD</td>
<td>把操作数OPRD按位取反，然后送回OPRD</td>
<td></td>
</tr>
<tr>
<td>AND</td>
<td>与运算指令</td>
<td>AND DEST，SRC</td>
<td>把两个操作数进行与运算之后结果送回DEST</td>
<td>同1得1，否则得0</td>
</tr>
<tr>
<td>OR</td>
<td>或运算指令</td>
<td>OR DEST，SRC</td>
<td>把两个操作数进行或运算之后结果送回DEST</td>
<td>同0得0，否则得1</td>
</tr>
<tr>
<td>XOR</td>
<td>异或运算</td>
<td>XOR DEST，SRC</td>
<td>把两个操作数进行异或运算之后结果送回DEST</td>
<td>相同得0不同得1</td>
</tr>
<tr>
<td>TEST</td>
<td>测试指令</td>
<td>TEST DEST，SRC</td>
<td>与AND指令类似，将各位相与，但是结果不送回DEST，仅影响状态位标志，指令执行后，ZF、PF、SF反映运算结果，CF和OF被清零</td>
<td>通常用于检测某些位是否为1，但又不希望改变操作数的值</td>
</tr>
</tbody></table>
<h2 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h2><h4 id="一般移位指令"><a href="#一般移位指令" class="headerlink" title="一般移位指令"></a>一般移位指令</h4><table>
<thead>
<tr>
<th>指令</th>
<th>中文名</th>
<th>格式</th>
<th>解释</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>SAL</td>
<td>算术左移</td>
<td>SAL OPRD，count</td>
<td>把操作数oprd左移count位，右边补0</td>
<td>与shl指令一样 通过截取count的低5位，实际的移位数被限于0到31之间。</td>
</tr>
<tr>
<td>SHL</td>
<td>逻辑左移</td>
<td>SHL OPRD，count</td>
<td>把操作数oprd左移count位，右边补0</td>
<td>与sal指令一样 通过截取count的低5位，实际的移位数被限于0到31之间。</td>
</tr>
<tr>
<td>SAR</td>
<td>算术右移</td>
<td>SAR OPRD，count</td>
<td>把操作数oprd右移count位，同时每右移一位，左边补符号位，移出的最低位进入标志位CF</td>
<td>通过截取count的低5位，实际的移位数被限于0到31之间。</td>
</tr>
<tr>
<td>SHR</td>
<td>逻辑右移</td>
<td>SHR OPRD，count</td>
<td>把操作数oprd右移count位，左边补0，移出的最低位进入标志位CF</td>
<td>通过截取count的低5位，实际的移位数被限于0到31之间。</td>
</tr>
</tbody></table>
<h4 id="循环移位指令"><a href="#循环移位指令" class="headerlink" title="循环移位指令"></a>循环移位指令</h4><table>
<thead>
<tr>
<th>指令</th>
<th>中文名</th>
<th>格式</th>
<th>解释</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>ROL</td>
<td>左循环移位指令</td>
<td>ROL OPRD,count</td>
<td></td>
<td>通过截取count的低5位，实际的移位数被限于0到31之间。</td>
</tr>
<tr>
<td>ROR</td>
<td>右循环移位指令</td>
<td>ROR OPRD,count</td>
<td></td>
<td>通过截取count的低5位，实际的移位数被限于0到31之间。</td>
</tr>
<tr>
<td>RCL</td>
<td>带进位左循环移位</td>
<td>RCL OPRD,count</td>
<td>相当于CF在最高位参与循环移位</td>
<td>大循环左移 通过截取count的低5位，实际的移位数被限于0到31之间。</td>
</tr>
<tr>
<td>RCR</td>
<td>带进位右循环移位</td>
<td>RCR OPRD,count</td>
<td>相当于CF在最高位参与循环移位</td>
<td>大循环右移 通过截取count的低5位，实际的移位数被限于0到31之间。</td>
</tr>
</tbody></table>
<h3 id="循环指令"><a href="#循环指令" class="headerlink" title="循环指令"></a>循环指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>中文名</th>
<th>格式</th>
<th>解释</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>LOOP</td>
<td>计数循环指令</td>
<td>LOOP LABEL</td>
<td>使ECX的值减1，当ECX的值不为0的时候跳转至LABEL，否则执行LOOP之后的语句</td>
<td></td>
</tr>
<tr>
<td>LOOPE</td>
<td>等于循环指令</td>
<td>LOOPE LABEL</td>
<td>使ECX的值减1，如果结果不等于0并且零标志ZF等于1（表示相等），那么就转移到LABEL，否则执行LOOPE之后的语句</td>
<td></td>
</tr>
<tr>
<td>LOOPZ</td>
<td>零循环指令</td>
<td>LOOPZ LABEL</td>
<td>使ECX的值减1，如果结果不等于0并且零标志ZF等于1（表示相等），那么就转移到LABEL，否则执行LOOPZ之后的语句</td>
<td></td>
</tr>
<tr>
<td>LOOPNE</td>
<td>不等于循环指令</td>
<td>LOOPE LABEL</td>
<td>使ECX的值减1，如果结果不等于0并且零标志ZF等于0（表示不相等），那么就转移到LABEL，否则执行LOOPNE之后的语句</td>
<td></td>
</tr>
<tr>
<td>LOOPNZ</td>
<td>非零循环指令</td>
<td>LOOPNZ LABEL</td>
<td>使ECX的值减1，如果结果不等于0并且零标志ZF等于0（表示不相等），那么9就转移到LABEL，否则执行LOOPNZ之后的语句</td>
<td></td>
</tr>
<tr>
<td>JECXZ</td>
<td>计数转移指令</td>
<td>JECXZ LABEL</td>
<td>当寄存器ECX的值为0时转移到LABEL，否则顺序执行</td>
<td>通常在循环开始之前使用该指令，所以循环次数为0时，就可以跳过循环体</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E6%89%80%E6%9C%89%E6%8C%87%E4%BB%A41/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E6%89%80%E6%9C%89%E6%8C%87%E4%BB%A41/" class="post-title-link" itemprop="url">汇编语言的所有指令1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-01 22:18:30 / 修改时间：22:23:38" itemprop="dateCreated datePublished" datetime="2021-01-01T22:18:30+08:00">2021-01-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96/" itemprop="url" rel="index"><span itemprop="name">汇编</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1、数据传送指令集"><a href="#1、数据传送指令集" class="headerlink" title="1、数据传送指令集**"></a>1、数据传送指令集**</h2><p><strong>MOV</strong><br>功能: 把源操作数送给目的操作数<br>语法: MOV 目的操作数,源操作数<br>格式: MOV r1,r2<br>MOV r,m<br>MOV m,r<br>MOV r,data</p>
<p><strong>XCHG</strong><br>功能: 交换两个操作数的数据<br>语法: XCHG<br>格式: XCHG r1,r2 XCHG m,r XCHG r,m</p>
<p><strong>PUSH,POP</strong><br>功能: 把操作数压入或取出堆栈<br>语法: PUSH 操作数 POP 操作数<br>格式: PUSH r PUSH M PUSH data POP r POP m</p>
<p><strong>PUSHF,POPF,PUSHA,POPA</strong><br>功能: 堆栈指令群<br>格式: PUSHF POPF PUSHA POPA</p>
<p><strong>LEA,LDS,LES</strong><br>功能: 取地址至寄存器<br>语法: LEA r,m LDS r,m LES r,m</p>
<p><strong>XLAT(XLATB)</strong><br>功能: 查表指令<br>语法: XLAT XLAT m</p>
<h2 id="2、算数运算指令"><a href="#2、算数运算指令" class="headerlink" title="2、算数运算指令"></a><strong>2、算数运算指令</strong></h2><p><strong>ADD,ADC</strong><br>功能: 加法指令<br>语法: ADD OP1,OP2 ADC OP1,OP2<br>格式: ADD r1,r2 ADD r,m ADD m,r ADD r,data<br>影响标志: C,P,A,Z,S,O</p>
<p><strong>SUB,SBB</strong><br>功能:减法指令<br>语法: SUB OP1,OP2 SBB OP1,OP2<br>格式: SUB r1,r2 SUB r,m SUB m,r SUB r,data SUB m,data<br>影响标志: C,P,A,Z,S,O</p>
<p><strong>INC,DEC</strong><br>功能: 把OP的值加一或减一<br>语法: INC OP DEC OP<br>格式: INC r/m DEC r/m<br>影响标志: P,A,Z,S,O</p>
<p><strong>NEG</strong><br>功能: 将OP的符号反相(取二进制补码)<br>语法: NEG OP<br>格式: NEG r/m<br>影响标志: C,P,A,Z,S,O</p>
<p><strong>MUL,IMUL</strong><br>功能: 乘法指令<br>语法: MUL OP IMUL OP<br>格式: MUL r/m IMUL r/m<br>影响标志: C,P,A,Z,S,O(仅IMUL会影响S标志)</p>
<p><strong>DIV,IDIV</strong><br>功能:除法指令<br>语法: DIV OP IDIV OP<br>格式: DIV r/m IDIV r/m</p>
<p><strong>CBW,CWD</strong><br>功能: 有符号数扩展指令<br>语法: CBW CWD</p>
<p><strong>AAA,AAS,AAM,AAD</strong><br>功能: 非压BCD码运算调整指令<br>语法: AAA AAS AAM AAD<br>影响标志: A,C(AAA,AAS) S,Z,P(AAM,AAD)</p>
<p><strong>DAA,DAS</strong><br>功能: 压缩BCD码调整指令<br>语法: DAA DAS<br>影响标志: C,P,A,Z,S</p>
<h2 id="3、位运算指令集"><a href="#3、位运算指令集" class="headerlink" title="3、位运算指令集"></a><strong>3、位运算指令集</strong></h2><p><strong>AND,OR,XOR,NOT,TEST</strong><br>功能: 执行BIT与BIT之间的逻辑运算<br>语法: AND r/m,r/m/data OR r/m,r/m/data XOR r/m,r/m/data TEST r/m,r/m/data NOT r/m<br>影响标志: C,O,P,Z,S(其中C与O两个标志会被设为0) NOT指令不影响任何标志位</p>
<p><strong>SHR,SHL,SAR,SAL</strong><br>功能: 移位指令<br>语法: SHR r/m,data/CL SHL r/m,data/CL SAR r/m,data/CL SAL r/m,data/CL<br>影响标志: C,P,Z,S,O</p>
<p><strong>ROR,ROL,RCR,RCL</strong><br>功能: 循环移位指令<br>语法: ROR r/m,data/CL ROL r/m,data/CL RCR r/m,data/CL RCL r/m,data/CL<br>影响标志: C,P,Z,S,O<br>程序流程控制指令集</p>
<p><strong>CLC,STC,CMC</strong><br>功能: 设定进位标志<br>语法: CLC STC CMC<br>标志位: C</p>
<p><strong>CLD,STD</strong><br>功能: 设定方向标志<br>语法: CLD STD<br>标志位: D</p>
<p><strong>CLI,STI</strong><br>功能: 设定中断标志<br>语法: CLI STI<br>标志位: I</p>
<p><strong>CMP</strong><br>功能: 比较OP1与OP2的值<br>语法: CMP r/m,r/m/data<br>标志位: C,P,A,Z,O</p>
<p><strong>JMP</strong><br>功能: 跳往指定地址执行<br>语法: JMP 地址</p>
<p><strong>JXX</strong><br>功能: 当特定条件成立则跳往指定地址执行<br>语法: JXX 地址<br>注:<br>A: ABOVE,当C=0,Z=0时成立<br>B: BELOW,当C=1时成立<br>C: CARRY,当弁时成立 CXZ: CX寄存器的值为0(ZERO)时成立<br>E: EQUAL,当Z=1时成立<br>G: GREATER(大于),当Z=0且S=0时成立<br>L: LESS(小于),当S不为零时成立<br>N: NOT(相反条件),需和其它符号配合使用<br>O: OVERFLOW,O=1时成立<br>P: PARITY,P=1时成立<br>PE: PARITY EVEN,P=1时成立<br>PO: PARITY ODD,P=0时成立<br>S: SIGN,S=1时成立<br>Z: ZERO,Z=1时成立</p>
<p><strong>LOOP</strong><br>功能: 循环指令集<br>语法: LOOP 地址</p>
<p><strong>LOOPE(Z)</strong><br>地址 LOOPNE(Z) 地址<br>标志位: 无</p>
<p><strong>CALL,RET</strong><br>功能: 子程序调用,返回指令<br>语法: CALL 地址 RET RET n<br>标志位: 无</p>
<p><strong>INT,IRET</strong><br>功能: 中断调用及返回指令<br>语法: INT n IRET<br>标志位: 在执行INT时,CPU会自动将标志寄存器的值入栈,在执行IRET时则会将堆栈中的标志值弹回寄存器<br>字符串操作指令集</p>
<p><strong>MOVSB,MOVSW,MOVSD</strong><br>功能: 字符串传送指令<br>语法: MOVSB MOVSW MOVSD<br>标志位: 无</p>
<p><strong>CMPSB,CMPSW,CMPSD</strong><br>功能: 字符串比较指令<br>语法: CMPSB CMPSW CMPSD<br>标志位: C,P,Z,S,O</p>
<p><strong>SCASB,SCASW</strong><br>功能: 字符串搜索指令<br>语法: SCASB SCASW<br>标志位: C,P,Z,S,O</p>
<p><strong>LODSB,LODSW,STOSB,STOSW</strong><br>功能: 字符串载入或存贮指令<br>语法: LODSB LODSW STOSB STOSW<br>标志位: 无</p>
<p><strong>REP,REPE,REPNE</strong><br>功能: 重复前缀指令集<br>语法: REP 指令S REPE 指令S REPNE 指令S<br>标志位: 依指令S而定</p>
<p>对于IBM PC机它有它的指令系统，其中包括：数据传送指令、串处理指令、算术指令、控制移动指令、逻辑指令、处理机控制指令。</p>
<p><strong>1)数据传送指令：</strong><br>负责把数据、地址或立即数传送到寄存器或存储单元中。<br>数据传送指令类型 指 令 说 明<br>通用数据传送指令 MOV（传送）、PUSH（进栈）、POP（出栈）、XCHG（交换）<br>累加器专用传送指令 IN（输入指令） 、OUT（输入指令）<br>地址传送指令 LEA（有效地址送寄存器）、LDS（指针送寄存器和DS）、LES（指针送寄存器和ES）<br>标志寄存器传送指令 LAHF（标志送AH）、SAHF（AH送标志寄存器）、PUSHF（标志进栈）、POPF（标志出栈）</p>
<p><strong>2）算术指令：</strong><br>用来执行算术运算。<br>算术指令类型 指 令 说 明<br>加法指令 ADD（加法）、ADC（带进位加法）、INC（加1）<br>减法指令 SUB（减法）、SBB（带借位减法）、DEC（减1）、NEG（求补）、CMP（比较）<br>乘法指令 MUL（无符号数乘法）、IMUL（带符号数乘法）<br>除法指令 DIV（无符号数除法）、IDIV（带符号数除法）、CBW（字节转换为字）、CWD（字转换为双字）</p>
<p><strong>3）逻辑指令：</strong><br>对字或字节执行逻辑运算。<br>逻辑指令类型 指 令 说 明<br>逻辑运算指令 AND（逻辑与）、OR（逻辑或）、NOT（逻辑非）、XOR（异或）、TEST（测试）<br>移动指令 SHL（逻辑左移）、SAL（算术左移）、SHR（逻辑右移）、SAR（算术右移）、ROL（循环左移）、ROR（循环右移）、RCL（带进位循环左移）、RCR（带进位右移）</p>
<p><strong>4）串处理指令：</strong><br>处理存放存储器里的数据串。<br>串处理指令类型 指 令 说 明<br>指 令 MOVS（串传送）、CMPS（串比较）、SCAS（串扫描）、LODS（从串取）、STOS（存入串）</p>
<p><strong>5）控制转移指令：</strong><br>用来控制程序的执行流程。<br>控制转移指令类型 指 令 说 明<br>无条件转移指令 JMP（段间和段内转移）<br>条件转移指令 JZ（结果为0（或相等）则转移）、JS（结果为负则转移）、JNS（结果为正则转移）、JO（溢出则转移）、JNO（不溢出则转移）、JP（奇偶位为1则转移）、JNP（奇偶位为0则转移）<br>循环指令 LOOP（循环指令）、LOOPPZ/LOOPE（当为0或相等时循环指令）、LOOPNZ/LOOPNE（当不为0或不相等时循环指令）<br>子程序指令 CALL（调用指令）、RET（返回指令）<br>中断指令 INT（中断）、INTO（如溢出则中断）、RIET（从中断返回）</p>
<p><strong>6）处理机控制指令：</strong><br>处理机控制指令类型 指 令 说 明<br>标志处理指令 CLC（进位位置0指令）、CMC（进位位求反指令）、STC（进位位置为1指令）、CLD（方向标志置1指令）、STD（方向标志位置1指令）、CLI（中断标志置0指令）、STI（中断标志置1指令）<br>其他处理机控制指令 NOP（无操作）、HLT（停机）、WAIT（等待）、ESC（换码）、LOCK（封锁）</p>
<p><strong>汇编语言程序格式</strong><br>汇编语言源程序用语句书写，MASM中可使用的语句分成两类，他们是指令性语句和伪指令语句</p>
<p>1．指令性语句：指令性语句与机器指令相对应，汇编程序将他翻译成目标代码（机器指令代码）。语句格为：<br>标号： 指令助记符 操作数，操作数；注释<br>标号表示指令语句的符号地址，标号后面必须紧跟“：”。标号可以省略，他经常作为转移指令或CALL指令的一个操作数，用以表示地址的转移。<br>指令助记符是该语句的指令名称的代表号码，他指出操作的类型，汇编程序将其翻译成机器指令。不可省略。<br>操作数表示参加本指令的运算数据，根据指令的操作类型，操作数不同，中间必须用“，”隔开。<br>注释指明一条指令的功能，可以省略。</p>
<p>2．伪指令语句<br>伪指令语句没有对应的机器指令。汇编程序汇编源程序时对伪指令进行处理，他可以完成数据定义，存储区分配，段定义，段分配，指示程序结束功能。伪指令语句的格式为：<br>名字 伪指令指示符 操作数，操作数；注释<br>名字时给伪指令取得名称，他用符号地址表示。伪指令中的名字通常是变量名，段名，过程名、符号名等。<br>伪指令指示符是汇编程序MASM规定的符号。<br>操作数是根据伪指令的具体要求来得。</p>
<p>3．数据项<br>汇编语言中使用的操作数，可以是常数、寄存器、存储器、变量、标号活表达式，其中藏书、变量和标号是三种基本数据项。<br>⑴常数必须是固定的值，没有属性，是确定的数据。<br>⑵变量在程序运行中是可以修改的。所有的变量具有三种属性<br>①段值（SEGMENT）：指明变量所在段的基址。<br>②段内偏移地址（OFFSET）：指变量所在地址与段首地址之间的偏移字节数。<br>③类型（TYPE）：变量的类型属性指变量中每个单元所包含的字节数，类型有：字节变量（BYTE）、字变量（WORD）、双字变量（DOUBLE WORD）<br>⑶标号：标号是指可执行指令语句的地址的符号表示，他可作为转移指令和调用指令的目标操作数，以确定程序转换的目标地址，他具有三个属性。<br>①段值（SEGMENT）：指明标号所在段的基址。<br>②段内偏移地址（OFFSET）：指标号所在地址与所在段段首地址之间的偏移字节数。<br>③类型（TYPE）：标号的类型属性指在转移指令中标号可转移的距离类型.NEAR，表示近标号只能实现在本代码段内转移或调用；FAR，表示远标号，可；以作为其他代码段中的目标地址，实现段间调用或转移。</p>
<p><strong>伪指令汇总</strong></p>
<p>1．数据定义语句<br>格式一：变量名 助记符 操作数，操作数…；注释<br>格式二：变量名 助记符 n DUP(操作数，操作数…)；注释<br>功能：将操作数存入变量名指定的存储单元中，或者只分配存储空间不存入数据。<br>变量名，用符号表示，可以省略。汇编程序时将此变量的助记符后的第一个字节的偏移地址作为他的符号地址。<br>助记符主要有：<br>DB：用来定义字节，表示每个操作数占用一个字节；<br>DW：用来定义字，表示每个操作数占用一个字；<br>DD：用来定义双字，表示每个操作数占用两个字；<br>DQ：用来定义四个字，表示每个操作数占用四个字；<br>DT：用来定义十个字节，表示每个操作数占用十个字节；<br>在格式二中，用n DUP表示时，n必须是整数，表示括号中的操作数的重复次数。DUP后面必须带括号。</p>
<p>2．表达式赋值语句<br>⑴赋值语句EQU<br>格式：符号名 EQU 表达式<br>功能：用来给变量、标号、常数、指令、表达式等定义一个符号名，程序中用到EQU左边得变量、标号时可以用右边的常数值或表达式来代替，但是一经定义在同一个程序模块中不能再重新定义。<br>⑵符号语句＝<br>符号语句“＝”与EQU语句具有相同功能，区别仅在于EQU中左边的标号不允许重新定义，而用“＝”定义的语句可以重新定义。<br>3段定义语句<br>存储器的物理地址由段基址和偏移地址组合而成，任何一个逻辑段，无论是数码段，数据段，堆栈段，附加段都必须定义。以便连接程序把不同段和模块连成一个可执行的程序。<br>⑴段定义语句SEGMENT…ENDS<br>格式：段名 SEGMENT 定位类型 组合类型 ‘分类名’<br>逻辑段内容<br>段名 ENDS<br>功能：将一个逻辑段定义成一个整体<br>段名，是逻辑段的标识符，不能省略。他确定了逻辑段在存储器中的地址。必须以SEGMENT开始，以ENDS结束，前后段名必须一致。<br>定位类型，定位类型参数是对该段起始地址的定位。定位类型参数主要有下面4种：<br>①PARA：指定定位段的起始地址必须在节的整数边界，当定位类型缺省时，就当成PARA<br>②BYTE：指定定位段的起始地址定位在存储单元的任何字节地址。<br>③WORD：指定定位段的起始地址定位在字的边界，即段的首地址必须是偶数。<br>④PAGE：指定定位段的起始地址定位在页的边界，即段的首地址必须是256的整数倍。<br>组合类型：组合类型参数主要提供了各个逻辑段之间的组合方式<br>①NONE：该段与其他同名段不进行连接，各段独立于存储器中，NONE可作为缺省参数。<br>②PUBLIC：该段与其他模块中的同名段连接时，由低地址到高地址连接起来，组成一个逻辑段，连接次序由连接命令指定。<br>③COMMON：该段在连接时与其他模块中的同名段有相同的起始地址，采用覆盖的方式在存储器中存放，连接长度为各分段中最大长度。<br>④AT表达式：定位该段的起始地址在表达式所指定的节（16的整数倍）边界上。当用户要求某个逻辑段在指定节的边界上时，就要用AT参数来实现。<br>⑤STACK：指定该段为堆栈段，此参数在堆栈段中不可省略。<br>⑥MEMORY：定位该段与其他模块中的同名段有相同的首地址，采用覆盖的方法在存储器中组合连接。其功能与COMMON相似，区别是第一个带MEMORY参数的逻辑段覆盖在其他同名段的最上层，其他带此参数的同名段按照COMMON方式处理。<br>⑶“分类名”（CLASS NAME）<br>其主要作用是汇编程序连接时将所有的分类名相同的逻辑段组成一个段组。</p>
<p>2．段分配语句（ASSUME）<br>格式：ASSUME CS:段名，DS:段名，SS:段名，ES:段名<br>功能：定义4个逻辑段，指明段和寄存器的关系。</p>
<p>3．过程定义语句<br>格式：过程名 PROC 属性<br>过程内容<br>RET N<br>过程名 ENDP<br>功能：定义一个过程，主程序可以用CALL 指令调用他<br>过程名：给所定义的过程取得名字，不可省略。象标号一样具有三个属性：段属性、偏移地址属性和距离属性。<br>RET N为过程内部的返回指令。过程中至少一条RET，可以在任何位置，使过程返回到主程序调用他的CALL指令之下的一条指令。N为弹出值，可以缺省，表示从程返回以后，堆栈中应有N个字节的值作废。</p>
<p>4．程序开始和结束语句<br>⑴NAME:<br>格式：NAME 程序名<br>功能：为源程序目标模块赋名字。<br>⑵TITLE<br>格式：TITLE 文本名<br>功能：将文本名赋给源程序目标模块作名字，功能同NAM…<br>⑶ORG<br>格式：ORG 表达式<br>功能：给汇编程序设置位置指针，指定下面语句的起始偏移地址。<br>⑷END<br>格式：END 标号名<br>功能：标记汇编源程序结束</p>
<p>5．外部伪指令及对准伪指令<br>程序中包含多个模块时，有些程序或数据在各个模块间要相互共享，可用外部伪指令PUBLIC和EXTRN来实现此功能。<br>⑴外部伪指令<br>PUBLIC用来定义共享模块，EXTAN用来调用共享模块<br>格式：PUBLIC 名称，名称，…<br>EXTRN 名称：类型，名称：类型…<br>⑵对准伪指令<br>格式：EVEN<br>功能：EVEN伪指令使下一语句的地址调整为偶地址<br>⑶LABEL<br>LABEL伪指令给已定义的变量或标号取另一个名字，并可重新定义他的类属性<br>格式：名称 LABEL 类型属性</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/" class="post-title-link" itemprop="url">汇编语言基础学习汇总3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-01 22:14:52 / 修改时间：22:20:43" itemprop="dateCreated datePublished" datetime="2021-01-01T22:14:52+08:00">2021-01-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96/" itemprop="url" rel="index"><span itemprop="name">汇编</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>64k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>58 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul>
<li>基本了解硬件系统的结构；</li>
<li>利用硬件系统的编程结构和指令集，有效灵活地控制系统进行工作。</li>
</ul>
<h2 id="1-1-机器语言"><a href="#1-1-机器语言" class="headerlink" title="1.1 机器语言"></a>1.1 机器语言</h2><ul>
<li>机器语言是机器指令的集合。电子计算机的机器指令是一系列二进制数字。计算机将之转换为一系列高低电平脉冲信号来驱动硬件工作的。</li>
</ul>
<h2 id="1-2-汇编语言的产生"><a href="#1-2-汇编语言的产生" class="headerlink" title="1.2 汇编语言的产生"></a>1.2 汇编语言的产生</h2><ul>
<li>由于机器语言指令都是由01组成,难以编写,记忆和维护程序.所以汇编语言为了解决这一问题产生。汇编语言的主体是汇编指令，汇编指令是机器指令的助记符。</li>
<li><strong>寄存器：</strong> CPU中存储数据的器件，一个CPU中有多个寄存器。</li>
</ul>
<h2 id="1-3-汇编语言的组成"><a href="#1-3-汇编语言的组成" class="headerlink" title="1.3 汇编语言的组成"></a>1.3 汇编语言的组成</h2><ul>
<li><strong>1、汇编指令</strong>(机器码的助记符，有对应的机器码)；</li>
<li><strong>2、伪指令</strong>(由编译器执行)和<strong>其他符号</strong>(由编译器识别)。</li>
</ul>
<h2 id="1-4-存储器"><a href="#1-4-存储器" class="headerlink" title="1.4 存储器"></a>1.4 存储器</h2><ul>
<li>CPU工作需要指令和数据，指令和数据存储在存储器中。</li>
</ul>
<h2 id="1-5-指令和数据"><a href="#1-5-指令和数据" class="headerlink" title="1.5 指令和数据"></a>1.5 指令和数据</h2><ul>
<li>在内存或者磁盘中存储的都是为二进制信息，<strong>指令和数据由我们设定(走的总线)</strong>。</li>
</ul>
<h2 id="1-6-存储单元"><a href="#1-6-存储单元" class="headerlink" title="1.6 存储单元"></a>1.6 存储单元</h2><ul>
<li>存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号。</li>
<li>B、KB、MB、GB、TB等单位。</li>
</ul>
<h2 id="1-7-CPU对存储器的读写"><a href="#1-7-CPU对存储器的读写" class="headerlink" title="1.7 CPU对存储器的读写"></a>1.7 CPU对存储器的读写</h2><ul>
<li><p><strong>CPU要对数据进行读写，必须和外部器件进行以下三类信息的交互：</strong></p>
<ul>
<li><strong>1、存储单元的地址</strong>(地址信息)；</li>
<li><strong>2、器件的选择、读或写命令</strong>(控制信息)；</li>
<li><strong>3、读或写的数据</strong>(数据信息) 。</li>
</ul>
</li>
<li><p>总线是连接CPU和其他芯片的导线，逻辑上分为<strong>地址总线</strong>、<strong>数据总线</strong>、<strong>控制总线</strong>。</p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516130510663.png" alt="逻辑上总线的分类"></p>
</li>
<li><p>CPU从内存单元中读写数据的过程：</p>
<ul>
<li>1、CPU通过地址线将地址信息发出；</li>
<li>2、CPU通过控制线发出内存读命令，选中存储器芯片，并通知它将要从中读或写数据；</li>
<li>3、存储器将相应的地址单元中的数据通过数据线送入CPU或CPU通过数据线将数据送入相应的内存单元。</li>
</ul>
</li>
</ul>
<h2 id="1-8-地址总线"><a href="#1-8-地址总线" class="headerlink" title="1.8 地址总线"></a>1.8 地址总线</h2><ul>
<li>CPU是通过地址总线指定存储单元，地址总线传送的能力决定了CPU对存储单元的寻址能力。(一般32位CPU，寻址能力为2^32=4G)</li>
</ul>
<h2 id="1-9-数据总线"><a href="#1-9-数据总线" class="headerlink" title="1.9 数据总线"></a>1.9 数据总线</h2><ul>
<li>CPU通过数据总线来与内存等器件进行数据传送，数据总线的宽度决定了CPU和外界的数据传送速度。</li>
</ul>
<h2 id="1-10-控制总线"><a href="#1-10-控制总线" class="headerlink" title="1.10 控制总线"></a>1.10 控制总线</h2><ul>
<li>控制总线是一些不同控制的集合，CPU通过控制总线对外部器件的控制。控制总线的宽度决定了CPU对外部器件的控制能力。</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>1、汇编指令时机器指令的助记符，与机器指令一一对应。</li>
<li>2、每一种CPU都有自己的汇编指令集。</li>
<li>3、CPU可以直接使用的信息在存储器中存放。</li>
<li>4、在存储器中指令和数据都是二进制信息。</li>
<li>5、存储单元从0开始顺序编号。</li>
<li>6、一个存储单元可以存储8个bit。</li>
<li>7、B、KB、MB、GB等单位之间的转换。</li>
<li>8、CPU管脚和总线相连。总线的宽度表示CPU不同方面的性能：<ul>
<li>地址总线的宽度决定了CPU的寻址能力；</li>
<li>数据总线的宽度决定了CPU与其他器件进行一次数据传送的量；</li>
<li>控制总线宽度决定了CPU对系统中其他器件的控制。</li>
</ul>
</li>
</ul>
<h2 id="检测点-1-1"><a href="#检测点-1-1" class="headerlink" title="检测点 1.1"></a>检测点 1.1</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516130534835.png" alt="检测点1.1"></p>
<h2 id="1-11-内存地址空间-概述"><a href="#1-11-内存地址空间-概述" class="headerlink" title="1.11 内存地址空间(概述)"></a>1.11 内存地址空间(概述)</h2><ul>
<li>CPU可寻的内存单元构成这个CPU的内存地址空间。例如一个CPU的地址总线宽度为10，那么可以寻址的1024个内存单元构成了这个CPU的内存空间。</li>
</ul>
<h2 id="1-12-主板"><a href="#1-12-主板" class="headerlink" title="1.12 主板"></a>1.12 主板</h2><ul>
<li>主板主板，主要的电路板 :laughing:</li>
</ul>
<h2 id="1-13-接口卡"><a href="#1-13-接口卡" class="headerlink" title="1.13 接口卡"></a>1.13 接口卡</h2><ul>
<li>CPU通过接口卡间接控制外部设备。</li>
</ul>
<h2 id="1-14-各类存储器"><a href="#1-14-各类存储器" class="headerlink" title="1.14 各类存储器"></a>1.14 各类存储器</h2><ul>
<li>随机存储器RAM(主板上的RAM、拓展插槽上的RAM和接口卡上的RAM)和只读存储器器ROM(装有BIOS的ROM)。<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516130646132.png" alt="PC集中各类存储器的逻辑连接"></li>
</ul>
<h2 id="1-15-内存地址空间"><a href="#1-15-内存地址空间" class="headerlink" title="1.15 内存地址空间"></a>1.15 内存地址空间</h2><ul>
<li><p><strong>各类存储器在物理上是独立的，但是：</strong></p>
<ul>
<li><strong>1、都和CPU的总线相连；</strong></li>
<li><strong>2、 CPU对他们进行读或写的时候都通过控制线发出的内存读写命令。</strong></li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516130610742.png" alt="将各类存储器看作一个逻辑存储器"></p>
</li>
<li><p>不同的计算机系统的内存地址空间分配情况是不同的。</p>
</li>
</ul>
<hr>
<h1 id="二、寄存器-CPU的工作原理"><a href="#二、寄存器-CPU的工作原理" class="headerlink" title="二、寄存器(CPU的工作原理)"></a>二、寄存器(CPU的工作原理)</h1><h2 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h2><ul>
<li>CPU由运算器、控制器、寄存器 等器件组成，靠内部总线相连。</li>
<li>内部总线实现CPU内部各器件之间的联系；外部总线实现CPU和主板上其他器件的联系。</li>
<li>在CPU中：<ul>
<li>运算器进行信息处理；</li>
<li>寄存器进行信息存储；</li>
<li>控制器控制各种器件进行工作；</li>
<li>内部总线连接各种器件在它们之间进行数据的传送。</li>
</ul>
</li>
</ul>
<h2 id="2-1-通用寄存器"><a href="#2-1-通用寄存器" class="headerlink" title="2.1 通用寄存器"></a>2.1 通用寄存器</h2><ul>
<li>8086有14个寄存器：<ul>
<li><strong>AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、CS、ES、PSW</strong>。</li>
</ul>
</li>
<li>AX、BX、CX、DX通常用来存放一般性数据，被称为通用寄存器。</li>
<li>16位寄存器所能存储的数据最大值为2^16^-1 。</li>
<li>为保证兼容性，8086 CPU的通用寄存器可以分为两个独立的8位寄存器使用。<strong>例：</strong> AX可分为AH和AL。</li>
</ul>
<h2 id="2-2-字在寄存器中的存储"><a href="#2-2-字在寄存器中的存储" class="headerlink" title="2.2 字在寄存器中的存储"></a>2.2 字在寄存器中的存储</h2><ul>
<li><p>8086 CPU所有的寄存器是16位，可以存放2个字节(一个字)。</p>
</li>
<li><p>一字节由8 bit 组成，可以存在8位寄存器中。</p>
</li>
<li><p>字(word)是两字节，16位。</p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516130720273.png" alt="一个字由两个字节组成"></p>
</li>
</ul>
<h2 id="2-3-几条汇编指令"><a href="#2-3-几条汇编指令" class="headerlink" title="2.3 几条汇编指令"></a>2.3 几条汇编指令</h2><ul>
<li><p>汇编指令对大小写不敏感</p>
<p>汇编指令举例</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>汇编指令</th>
<th>控制CPU完成的操作</th>
<th>用高级语言的语法描述</th>
</tr>
</thead>
<tbody><tr>
<td>mov ax，18</td>
<td>将8送入AX</td>
<td>AX=18</td>
</tr>
<tr>
<td>mov ah，78</td>
<td>将78送入AH</td>
<td>AH=78</td>
</tr>
<tr>
<td>add ax，8</td>
<td>将寄存器AX中的数值加上8结果存入AX中</td>
<td>AX=AX+8</td>
</tr>
<tr>
<td>mov ax，bx</td>
<td>将寄存器BX中的数据送入寄存器AX</td>
<td>AX=BX</td>
</tr>
<tr>
<td>add ax，bx</td>
<td>将AX，BX中的内容相加结果存入AX中</td>
<td>AX=AX+BX</td>
</tr>
</tbody></table>
<h2 id="检测点-2-1"><a href="#检测点-2-1" class="headerlink" title="检测点 2.1"></a>检测点 2.1</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516130748089.png" alt="检测点2.1"></p>
<h2 id="2-4-物理地址"><a href="#2-4-物理地址" class="headerlink" title="2.4 物理地址"></a>2.4 物理地址</h2><ul>
<li>所有的内存单元构成一个一维的线性存储空间。</li>
<li>CPU访问内存单元时要给出内存单元的唯一地址就是物理地址。</li>
</ul>
<h2 id="2-5-16位结构的CPU"><a href="#2-5-16位结构的CPU" class="headerlink" title="2.5 16位结构的CPU"></a>2.5 16位结构的CPU</h2><ul>
<li>1、运算器一次最多可以处理16位数据。</li>
<li>2、 寄存器的最大宽度为16位。</li>
<li>3、寄存器和运算器之间的通路是16位。</li>
</ul>
<h2 id="2-6-8086-CPU给出物理地址的方法"><a href="#2-6-8086-CPU给出物理地址的方法" class="headerlink" title="2.6 8086 CPU给出物理地址的方法"></a>2.6 8086 CPU给出物理地址的方法</h2><ul>
<li>8086有20位的地址总线，可以传送20位地址，寻址能力为1M；但8086内部为16位结构，只能传送16位的地址。</li>
<li><strong>8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。</strong></li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516130857852.png" alt="8086CPU相关部件的逻辑结构"></p>
<ul>
<li>8086CPU读写内存的步骤：<ul>
<li>1、CPU中的相关部件提供段子和偏移地址这两个16位的地址；</li>
<li>2、段地址和偏移地址通过内部总线送入到一个称为地址加法器的部件；</li>
<li>3、地址加法器将两个16位地址合并成一个20位的地址；</li>
<li>4、地址加法器通过内部总线将20位物理地址送送入输入输出地址；</li>
<li>5、输入输出控制电路将20位物理地址送上地址总线；</li>
<li>6、20位物理地址被地址总线传送到存储器。</li>
</ul>
</li>
<li>地址加法器工作原理：<strong>物理地址=段地址*16+偏移地址。</strong></li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516130922414.png" alt="地址加法器的过程"><br>- 段地址*16就是数据左移4位(二进制)</p>
<table>
<thead>
<tr>
<th>移位位数</th>
<th>二进制</th>
<th>十六进制</th>
<th>十进制</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>10B</td>
<td>2H</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>100B</td>
<td>4H</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>1000B</td>
<td>8H</td>
<td>8</td>
</tr>
<tr>
<td>3</td>
<td>10000B</td>
<td>10H</td>
<td>16</td>
</tr>
<tr>
<td>4</td>
<td>100000B</td>
<td>20H</td>
<td>32</td>
</tr>
</tbody></table>
<ul>
<li><strong>一个数据的二进制形式左移N位，相当于该数据乘以2的N次方。一个数据X进制形式左移N位，相当乘以NX。</strong></li>
</ul>
<h2 id="2-7-段地址-16-偏移地址-物理地址"><a href="#2-7-段地址-16-偏移地址-物理地址" class="headerlink" title="2.7 段地址*16+偏移地址=物理地址"></a>2.7 段地址*16+偏移地址=物理地址</h2><ul>
<li><strong>CPU可以通过不同的段地址和偏移地址形成一个相同的物理地址。</strong></li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516131059431.png" alt="CPU可以通过不同的段地址和偏移地址形成相同的物理地址"></p>
<blockquote>
<p>段地址*16是移位</p>
</blockquote>
<h2 id="2-8-段的概念"><a href="#2-8-段的概念" class="headerlink" title="2.8 段的概念"></a>2.8 段的概念</h2><ul>
<li>人为定义的，将若干地址连续的内存单元看作一个段。用段地址*16定位段的起始地址(基址)，用偏移地址定位段中的内存单元。<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516131242884.png" alt="段的概念"></li>
<li><strong>一个段的起始地址是16的倍数。偏移地址为16位，寻址能力为64K，所以段的最大长度也是64K。</strong></li>
</ul>
<h2 id="检测点-2-2"><a href="#检测点-2-2" class="headerlink" title="检测点 2.2"></a>检测点 2.2</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516131316807.png" alt="检测点2.2"></p>
<h2 id="2-9-段寄存器"><a href="#2-9-段寄存器" class="headerlink" title="2.9 段寄存器"></a>2.9 段寄存器</h2><ul>
<li>8086 CPU有4个段寄存器:<strong>CS(代码段)、DS(数据段)、SS(堆栈段)、ES(附加段)</strong>，这4个段提供给8086CPU内存单元的段地址。</li>
</ul>
<h2 id="2-10-CS和IP"><a href="#2-10-CS和IP" class="headerlink" title="2.10 CS和IP"></a>2.10 CS和IP</h2><ul>
<li><p><strong>CS(代码段寄存器)</strong> 和<strong>IP(指令指针寄存器)</strong> 是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址。在任意时刻CPU将CS:IP指向的内容当作指令执行。</p>
</li>
<li><p>8086CPU工作过程的简要概述：</p>
<ul>
<li><p>1、从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器；</p>
<blockquote>
<p>8086PC机刚开始启动时，CPU从内存FFFF0h单元中读取指令执行，FFFF0h单元中的指令时8086PC机开机后执行的第一条指令。</p>
</blockquote>
</li>
<li><p>2、 IP=IP+所读取指令的长度，从而正确的指向下一条指令；</p>
</li>
<li><p>3、执行指令。转到步骤1，周而复始。</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-11-修改CS、IP的指令"><a href="#2-11-修改CS、IP的指令" class="headerlink" title="2.11 修改CS、IP的指令"></a>2.11 修改CS、IP的指令</h2><ul>
<li><strong>mov指令(传送指令)</strong> 可以改变8086CPU大部分寄存器的值，但不能用于设置CS、IP的值。</li>
<li><strong>jmp指令(转移指令)</strong> 可以用来同时修改CS和IP的值，格式为</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmp 段地址:偏移地址;同时修改CS和IP</span><br><span class="line">jmp 某一合法寄存器;则是仅修改IP12</span><br></pre></td></tr></table></figure>

<h2 id="2-12-代码段"><a href="#2-12-代码段" class="headerlink" title="2.12 代码段"></a>2.12 代码段</h2><ul>
<li>对于8086PC机，在编程时可以将长度为N(N小于等于64KB)的一组代码存在一组地址连续、起始地址为16的倍数的内存单元中，这段内存是用来存放代码的，从而定义了一个代码段。</li>
<li>利用CS:IP来指向内存单元从而让CPU执行其中的内容。</li>
</ul>
<h2 id="检测点-2-3"><a href="#检测点-2-3" class="headerlink" title="检测点 2.3"></a>检测点 2.3</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516131420213.png" alt="检测点2.3"></p>
<h2 id="使用Debug"><a href="#使用Debug" class="headerlink" title="使用Debug"></a>使用Debug</h2><blockquote>
<p>windows xp系统自带debug，请使用xp以上系统的读者执行自行下载debug.exe和dosbox，使用方法笔者不再赘述，在dosbox中可以使用debug。<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516131442463.png" alt="debug in dosbox"></p>
</blockquote>
<ul>
<li><strong>可以使用汇编金手指查阅指令。</strong></li>
<li><strong>R</strong>命令查看、改变CPU寄存器的内容；</li>
<li><strong>D</strong>命令查看内存中的内容；</li>
<li><strong>E</strong>命令改写内存中的内容；</li>
<li><strong>U</strong>命令将内存中的机器指令翻译成汇编指令；</li>
<li><strong>T</strong>命令执行一条机器指令；</li>
<li><strong>G</strong>命令跳转到偏移地址；</li>
<li><strong>P</strong>命令结束循环或者是int 21H时是退出程序；</li>
<li><strong>A</strong>命令是以汇编指令的格式在内存中写入一条机器指令。</li>
</ul>
<hr>
<h1 id="三、寄存器-内存访问"><a href="#三、寄存器-内存访问" class="headerlink" title="三、寄存器(内存访问)"></a>三、寄存器(内存访问)</h1><h2 id="3-1-内存中字的存储"><a href="#3-1-内存中字的存储" class="headerlink" title="3.1 内存中字的存储"></a>3.1 内存中字的存储</h2><ul>
<li>字是两个字节，要用两个地址连续的内存来存放，字的低位字节存在低地址中，高位字节存放在高地址单元中。</li>
</ul>
<h2 id="3-2-DS和-address"><a href="#3-2-DS和-address" class="headerlink" title="3.2 DS和[address]"></a>3.2 DS和[address]</h2><ul>
<li><p>DS通常存放要访问的数据的段地址。</p>
</li>
<li><p><strong>8086 CPU由于硬件的设计不支持将数据直接送入段寄存器的操作。</strong></p>
<blockquote>
<p>数据 -&gt; 通用寄存器 -&gt; 段寄存器</p>
</blockquote>
</li>
<li><p>[ ]里边的数据代表偏移地址值</p>
</li>
<li><p>mov指令：</p>
<ul>
<li>将数据直接送入寄存器；</li>
<li>将一个寄存器或内存单元中的内容送入另一个寄存器；</li>
</ul>
</li>
<li><p>mov指令格式:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov 寄存器名,内存单元1</span><br></pre></td></tr></table></figure>

<h2 id="3-3-字型的传送"><a href="#3-3-字型的传送" class="headerlink" title="3.3 字型的传送"></a>3.3 字型的传送</h2><ul>
<li>高地址单元和高8位寄存器，低地址单元和低8位寄存器相对应。</li>
</ul>
<h2 id="3-4-mov、add、sub指令"><a href="#3-4-mov、add、sub指令" class="headerlink" title="3.4 mov、add、sub指令"></a>3.4 mov、add、sub指令</h2><ul>
<li>有两个操作对象，jmp只有一个操作对象。</li>
<li><strong>使用汇编金手指查阅指令</strong></li>
<li><strong>mov指令的几种形式</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov 寄存器,数据;mov ax,8</span><br><span class="line">mov 寄存器,寄存器;mov ax,bx</span><br><span class="line">mov 寄存器,内存单元;mov ax,[0]</span><br><span class="line">mov 内存单元,寄存器;mov [0],ax</span><br><span class="line">mov 段寄存器,寄存器;mov ds,ax</span><br><span class="line">mov 寄存器,段寄存器;mov ax,ds</span><br><span class="line">     ……1234567</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>add指令的几种形式</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add 通用寄存器,数据</span><br><span class="line">add 通用寄存器,通用寄存器</span><br><span class="line">add 通用寄存器,内存单元</span><br><span class="line">add 内存单元,寄存器1234</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>sub指令的几种形式</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sub 通用寄存器,数据</span><br><span class="line">sub 通用寄存器,通用寄存器</span><br><span class="line">sub 通用寄存器,内存单元</span><br><span class="line">sub 内存单元,通用寄存器  1234</span><br></pre></td></tr></table></figure>

<h2 id="3-5-数据段"><a href="#3-5-数据段" class="headerlink" title="3.5 数据段"></a>3.5 数据段</h2><ul>
<li>对于8086PC机，在编程时可以将长度为N(N小于等于64KB)的一组代码存在一组地址连续、起始地址为16的倍数的内存单元中，这段内存是用来存放数据的，从而定义了一个数据段。</li>
<li>可以通过在DS中存放数据段的段地址，用相关的指令访问数据段中的具体单元来访问数据段中的数据。</li>
</ul>
<h2 id="检测点-3-1"><a href="#检测点-3-1" class="headerlink" title="检测点 3.1"></a>检测点 3.1</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516132148984.png" alt="检测点3.1"></p>
<h2 id="3-6-栈"><a href="#3-6-栈" class="headerlink" title="3.6 栈"></a>3.6 栈</h2><ul>
<li>具有特殊的访问方式的存储空间，也是内存空间的一部分，数据<strong>先进后出。</strong></li>
<li>有两个基本操作:<ul>
<li>入栈：将一个新的元素放到栈顶；</li>
<li>出栈：从栈顶取出一个元素。</li>
</ul>
</li>
<li>栈顶元素最后入栈最先出栈。</li>
</ul>
<h2 id="3-7-8086-CPU提供的栈机制"><a href="#3-7-8086-CPU提供的栈机制" class="headerlink" title="3.7 8086 CPU提供的栈机制"></a>3.7 8086 CPU提供的栈机制</h2><ul>
<li><p>现今的CPU都有栈的设计，基于8086CPU编程可以将一段内存当作栈来使用。</p>
</li>
<li><p>8086CPU的</p>
<p>入栈(PUSH)</p>
<p>和</p>
<p>POP(出栈)</p>
<p>，以字为单位。</p>
<ul>
<li>push ax 将寄存器ax中的数据送入栈</li>
<li>pop ax 从栈顶取出数据送入ax</li>
</ul>
</li>
<li><p><strong>段寄存器SS存放栈顶的段地址，寄存器SP存放栈顶的偏移地址。任意时刻SS:SP指向栈顶元素。push时SP先自减法后写内存，pop先读内存sp后自加。</strong></p>
</li>
<li><p>pop之后数据还是存在内存中，push时覆盖。</p>
<blockquote>
<p>CS和IP存放当前指令的段地址和偏移地址。</p>
</blockquote>
</li>
</ul>
<h2 id="3-8-栈顶越界的问题"><a href="#3-8-栈顶越界的问题" class="headerlink" title="3.8 栈顶越界的问题"></a>3.8 栈顶越界的问题</h2><ul>
<li><strong>栈是空的，则SP指向栈底+1的内存。</strong></li>
<li>8086 CPU只纪录栈顶，栈空间由自己控制。栈顶越界问题导致溢出漏洞。</li>
<li>8086CPU只考虑当前的情况：<ul>
<li>当前栈顶在何处；</li>
<li>当前要执行的指令时哪一条。</li>
</ul>
</li>
</ul>
<h2 id="3-9-push、pop指令"><a href="#3-9-push、pop指令" class="headerlink" title="3.9 push、pop指令"></a>3.9 push、pop指令</h2><ul>
<li>可以直接对段寄存器使用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;push和pop格式</span><br><span class="line">push 寄存器</span><br><span class="line">pop 寄存器</span><br><span class="line">push 段寄存器</span><br><span class="line">pop 段寄存器</span><br><span class="line">push 内存单元</span><br><span class="line">pop 内存单元1234567</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>通用寄存器命名是x结尾的，段寄存器是以s结尾。</strong></li>
<li>CPU在执行指令时，数据的段地址是从DS中获得，代码是在CS中获得，栈地址是从SS获得。</li>
</ul>
<h2 id="3-10-栈段"><a href="#3-10-栈段" class="headerlink" title="3.10 栈段"></a>3.10 栈段</h2><ul>
<li>对于8086PC机，在编程时可以将长度为N(N小于等于64KB)的一组代码存在一组地址连续、起始地址为16的倍数的内存单元中，这段内存是当作栈来用，从而定义了一个栈段。</li>
<li><strong>寄存器清零可用sub ax,ax或者直接赋值0，</strong>常见的也有使用xor。</li>
<li>当栈空间定义为最大时，栈为空时SP=0。</li>
</ul>
<h2 id="检测点-3-2"><a href="#检测点-3-2" class="headerlink" title="检测点 3.2"></a>检测点 3.2</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516132601845.png" alt="检测点3.2"></p>
<hr>
<h1 id="四、第一个程序"><a href="#四、第一个程序" class="headerlink" title="四、第一个程序"></a>四、第一个程序</h1><h2 id="引言-2"><a href="#引言-2" class="headerlink" title="引言"></a>引言</h2><p>编写完成的汇编语言程序，用编译器编译成可执行文件并在操作系统中运行。</p>
<h2 id="4-1-一个源程序从写出到执行的过程"><a href="#4-1-一个源程序从写出到执行的过程" class="headerlink" title="4.1 一个源程序从写出到执行的过程"></a>4.1 一个源程序从写出到执行的过程</h2><ul>
<li><p>编写</p>
<ul>
<li>用编辑器(Sublime Text、Nodepad++、UltraEdit)编写，文件后缀为.asm。</li>
</ul>
</li>
<li><p>编译链接</p>
<ul>
<li>使用MASM.EXE编译生产obj(目标文件)。masm也请读者自行搜索下载。</li>
<li>LINKE.EXE对目标文件进行连接生产可在操作系统中直接运行的可执行文件。</li>
</ul>
</li>
</ul>
<blockquote>
<p>可执行文件包含程序(机器码)、数据(源程序中定义的数据)和相关的描述信息。</p>
</blockquote>
<ul>
<li><p>执行</p>
<ul>
<li>操作系统中依照可执行文件中的描述信息将可执行文件中的机器码和数据加载入内存并进行相关的初始化，然后CPU执行。</li>
</ul>
</li>
<li><h2 id="4-2-源程序"><a href="#4-2-源程序" class="headerlink" title="4.2 源程序"></a>4.2 源程序</h2><ul>
<li>汇编指令：有对应的机器码的指令，编译为机器码被CPU执行</li>
<li>伪指令：没有对应的机器码，不被CPU所执行，由编译器执行来进行相关的编译工作。<ul>
<li>segment和ends是用来定义一个段的，是成对使用的伪指令，再写可被编译器编译的汇编程序是必须要用的。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg ;假设代码段的名称为codesg</span><br><span class="line">codesg segment ;定义一个codesg段</span><br><span class="line">mov ax,0123H</span><br><span class="line">mov bx,0456H</span><br><span class="line">add ax,bx</span><br><span class="line">add ax,ax</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends ;codesg段结束</span><br><span class="line">end ;是个伪指令，程序的结束标记12345678910</span><br></pre></td></tr></table></figure>

<blockquote>
<p>assume用来加上某一段寄存器和程序中的某一用segment……ends定义的段相关联。通过assume说明这种关联，在需要的情况下编译程序可以将段寄存器和某一个具体的段相联系。<br>- 一个汇编程序是由多个段组成。一个有意义的汇编程序中至少要用一个段来存放代码。<br>- 程序与源程序<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516134102680.png" alt="程序与源程序"></p>
</blockquote>
<ul>
<li>标号:指代地址</li>
<li>程序的结构</li>
<li>小练习：</li>
</ul>
<figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;编程运算<span class="number">2</span>^<span class="number">3</span></span><br><span class="line">assume cs:abc ;段与寄存器关联</span><br><span class="line"></span><br><span class="line">abc segment ;定义一个段，名称为abc</span><br><span class="line">mov ax,<span class="number">2</span>;写入汇编指令</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br><span class="line"></span><br><span class="line">abd ends      </span><br><span class="line">end ;程序结束处<span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>程序的返回:一个程序结束后将CPU的控制权交还给使它得以运行的程序的过程。应该在程序的末尾添加返回的程序段。</p>
<blockquote>
<p>codesg：放在segment前面，作为一个段的名称，这个段的名称最终将被编译、连接程序，称为一个段的段地址 。</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00H</span><br><span class="line">int 21H ;第21号中断</span><br><span class="line">;这两条指令说实现的功能就是程序返回。123</span><br></pre></td></tr></table></figure>

<ul>
<li>语法错误和逻辑错误</li>
</ul>
<h2 id="4-3-编辑源程序"><a href="#4-3-编辑源程序" class="headerlink" title="4.3 编辑源程序"></a>4.3 编辑源程序</h2><ul>
<li>使用编辑器编辑，扩展名为.asm</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assume cs:ABC</span><br><span class="line">ABC segment</span><br><span class="line">    mov ax,2</span><br><span class="line">    add ax,ax</span><br><span class="line">    add ax,ax</span><br><span class="line">    mov ax,4c00H</span><br><span class="line">    int 21h</span><br><span class="line">ABC ends</span><br><span class="line">end123456789</span><br></pre></td></tr></table></figure>

<h2 id="4-4-编译"><a href="#4-4-编译" class="headerlink" title="4.4 编译"></a>4.4 编译</h2><ul>
<li><p>masn和 1.asm在同一目录中，dos下使用masm 1.asm命令即可生产1.obj文件。<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516134717267.png" alt="源程序文件和masm文件在同一目录下"></p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516134733996.png" alt="编译源程序"></p>
</li>
</ul>
<h2 id="4-5-连接"><a href="#4-5-连接" class="headerlink" title="4.5 连接"></a>4.5 连接</h2><ul>
<li><p>link 1.obj，生成exe文件，摁enter忽略编译程序提示输入的信息。</p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516134809731.png" alt="连接程序"></p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516134828737.png" alt="连接生成exe"></p>
</li>
<li><p>当源程序很大时，可以将它分成多个源程序文件编译，每个源程序编译成目标文件后再用连接程序将他们连接到一起，生成一个可执行文件。或者程序中调用了某个库文件中的子程序，需要将这个库文件和该目标文件连接到一起，生成一个可执行文件。或者一个源程序编译后得到存有机器码的目标文件，目标文件中的有些内容还不能直接生成可执行文件，连接程序将此内容处理为最终的可执行文件信息。</p>
</li>
</ul>
<h2 id="4-6-简化编译和连接"><a href="#4-6-简化编译和连接" class="headerlink" title="4.6 简化编译和连接"></a>4.6 简化编译和连接</h2><ul>
<li>使用ml命令，ml 1.asm</li>
</ul>
<h2 id="4-7-exe的执行"><a href="#4-7-exe的执行" class="headerlink" title="4.7 exe的执行"></a>4.7 exe的执行</h2><ul>
<li>为兼容16位的程序，使用dosbox运行。</li>
</ul>
<h2 id="4-8-可执行文件中的程序转入内存并运行的原理"><a href="#4-8-可执行文件中的程序转入内存并运行的原理" class="headerlink" title="4.8 可执行文件中的程序转入内存并运行的原理"></a>4.8 可执行文件中的程序转入内存并运行的原理</h2><ul>
<li><p>在dos中可执行文件中的程序p1若要运行吗必须有一个正在运行的程序p2将p1从可执行文件中加载如内存，将CPU的控制权交给它，p1才能得以运行；当p1运行完毕后，应该将CPU的控制权交还给使它de’yi 运行的程序p2。</p>
</li>
<li><p>汇编程序从写出到执行的过程：编程 -&gt; 编译 -&gt; 连接 -&gt; 加载 -&gt; 内存中的程序 -&gt; 运行</p>
</li>
<li><p>在dos系统中.exe文件中的加载过程</p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516134954833.png" alt="exe文件中程序的加载过程"></p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516135020850.png" alt="psp的内容"></p>
</li>
</ul>
<h2 id="4-9-程序执行过程的跟踪"><a href="#4-9-程序执行过程的跟踪" class="headerlink" title="4.9 程序执行过程的跟踪"></a>4.9 程序执行过程的跟踪</h2><ul>
<li>使用debug(xp以上的系统在dosbox中使用)来跟踪一个程序的运行过程。</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516135110577.png" alt="使用debug来跟踪程序运行"></p>
<hr>
<h1 id="五、-BX-和loop指令"><a href="#五、-BX-和loop指令" class="headerlink" title="五、[BX]和loop指令"></a>五、[BX]和loop指令</h1><h2 id="引言-3"><a href="#引言-3" class="headerlink" title="引言"></a>引言</h2><ul>
<li>约定符号()来表示一个寄存器或者一个内存单元中的内容。<strong>例如</strong>(ax)=0010H表示ax中的内容为0010H；(21000H)=0010H，表示2000:1000处的内容为0010H。</li>
<li>约定符号idata表示常量。</li>
</ul>
<h2 id="5-1-BX"><a href="#5-1-BX" class="headerlink" title="5.1 [BX]"></a>5.1 [BX]</h2><ul>
<li><strong>inc指令是自增1的意思</strong></li>
<li>和[0]有些类似，[0]表示内存单元，它的偏移地址是0。[bx]也是表示一个内存单元，它的内存偏移地址在bx中。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bx,0</span><br><span class="line">mov ax,[bx]</span><br><span class="line">mov al,[bx]123</span><br></pre></td></tr></table></figure>

<ul>
<li><p>用以下两种信息描述一个内存单元：</p>
<ul>
<li><p>1、内存单元的地址；</p>
</li>
<li><p>2、内训单元的长度(类型)。</p>
<blockquote>
<p>我们用[0]表示一个内训单元时，0表示单元的偏移地址，段地址默认在DS中，单元的长度(类型)可以由具体指令中的其他的操作对象(比如说寄存器)指出。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[0];0对应的字单元，主要单位要看操作对象(寄存器)</span><br><span class="line">mov al,[0];字节12</span><br></pre></td></tr></table></figure>

<h2 id="5-2-loop指令"><a href="#5-2-loop指令" class="headerlink" title="5.2 loop指令"></a>5.2 loop指令</h2><ul>
<li>指令的格式是loop 标号。CUP执行loop指令时要进两步操作：<ul>
<li><strong>CX中存放循环的次数，执行时CX中的内容自减1。相当于C的do while</strong></li>
<li><strong>判断CX中的值，不为0则转至标号处执行程序，为0则向下执行。</strong></li>
</ul>
</li>
<li>通常loop指令来实现循坏功能CX中存放循环的次数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">       code segment</span><br><span class="line">       mov ax,2</span><br><span class="line">       add ax,ax</span><br><span class="line"></span><br><span class="line">       mov ax,4c00H</span><br><span class="line">       int 21H</span><br><span class="line">code ends</span><br><span class="line">end123456789</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">;计算2^3</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">     mov ax,2</span><br><span class="line">     add ax,ax</span><br><span class="line">     add,ax,ax</span><br><span class="line"></span><br><span class="line">     mov ax,4c00H</span><br><span class="line">     int 21h</span><br><span class="line">code ends</span><br><span class="line">end1234567891011</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">;计算2^12</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:  mov ax,2</span><br><span class="line">        mov cx,11</span><br><span class="line">      p:add,ax,ax       </span><br><span class="line">        loop p;p是标号</span><br><span class="line"></span><br><span class="line">       mov ax,4c00H;masm默认数字是十进制</span><br><span class="line">       int 21H</span><br><span class="line">code ends</span><br><span class="line">end start123456789101112</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">;编程计算123*236，结果放在ax中</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,0</span><br><span class="line">      mov cx,236</span><br><span class="line">   an:add ax,123</span><br><span class="line">     loop an</span><br><span class="line">      mov ax,4c00H</span><br><span class="line">      int 21H</span><br><span class="line">code ends</span><br><span class="line">end start1234567891011</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,0</span><br><span class="line">      mov cx,123</span><br><span class="line">  pa:add ax,236</span><br><span class="line">      loop pa</span><br><span class="line"></span><br><span class="line">      mov ax,4c00H</span><br><span class="line">      int 21H</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start123456789101112</span><br></pre></td></tr></table></figure>

<h2 id="5-3-在Debug中跟踪用loop指令实现的循环程序"><a href="#5-3-在Debug中跟踪用loop指令实现的循环程序" class="headerlink" title="5.3 在Debug中跟踪用loop指令实现的循环程序"></a>5.3 在Debug中跟踪用loop指令实现的循环程序</h2><ul>
<li><strong>注意：在汇编源程序中数据不能以字母开头，有字母的在前面加0处理。</strong></li>
<li>t命令单步执行、G命令和P命令。</li>
<li><strong>使用汇编金手指查阅指令。</strong></li>
</ul>
<h2 id="5-4-Debug和汇编编译器Masm对指令的不同处理"><a href="#5-4-Debug和汇编编译器Masm对指令的不同处理" class="headerlink" title="5.4 Debug和汇编编译器Masm对指令的不同处理"></a>5.4 Debug和汇编编译器Masm对指令的不同处理</h2><ul>
<li><p><strong>Degug中mov ax,[0]，表示将ds:0处的数据存入al中。ah=0，因为一个内存单元是8位的，ax是16位的，同位存储。而编译器[0]会被当作0处理</strong></p>
</li>
<li><p>将内存2000:0、2000:1、2000:2、2000:3单元中的数据(字节)送入阿al、bl、cl、dl中。</p>
<ul>
<li>debug中：</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516183617791.png" alt="debug 1"></p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516183634486.png" alt="debug 3"></p>
<ul>
<li>在MASM中：</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516183712370.png" alt="1masmtest"></p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516183806106.png" alt="masmtest2"></p>
<ul>
<li><strong>要在编译器中实现用偏移地址[]中的内容传送先bx来代替，mov 偏移地址,bx 再 mov al,[bx]。如要直接使用[ ]则要加上段地址ds:[偏移地址]</strong></li>
</ul>
</li>
<li><p>在MASM中：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,[0] ;将al赋值0</span><br><span class="line">mov al,ds[0] ;将al赋值段地址为ds，偏移地址为0的内存单元中的内容</span><br><span class="line">mov al,[bx] ;默认段地址为ds，将al赋值偏移地址为bx</span><br><span class="line">mov al,ds:[bx] ;将al赋值段地址为ds，偏移地址为bx1234</span><br></pre></td></tr></table></figure>

<h2 id="5-5-loop和-BX-的联合应用"><a href="#5-5-loop和-BX-的联合应用" class="headerlink" title="5.5 loop和[BX]的联合应用"></a>5.5 loop和[BX]的联合应用</h2><ul>
<li>可以用循环来解决处理地址连续的内存单元中的数据的问题，用变量来给出内存单元的地址。</li>
</ul>
<h2 id="5-6-段前缀"><a href="#5-6-段前缀" class="headerlink" title="5.6 段前缀"></a>5.6 段前缀</h2><ul>
<li>出现在访问内存单元的指令中用显式地指明内存单元的段地址的ds、cs、ss、es称为段前缀。<strong>没有显式地给出内存单元的段地址则默认在ds中。</strong></li>
</ul>
<h2 id="5-7-一段安全的空间"><a href="#5-7-一段安全的空间" class="headerlink" title="5.7 一段安全的空间"></a>5.7 一段安全的空间</h2><blockquote>
<p>在8086模式中，随意向一段内存空间写入数据是危险的，因为这段空间中可能存放着重要的系统数据或代码。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    mov ax,0</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ds:[26H],ax</span><br><span class="line">    mov ax,4c00H</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end123456789</span><br></pre></td></tr></table></figure>

<ul>
<li><p>但笔者在练习的时候出现dosbox下debug卡死</p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516184105129.png" alt="dangeroustest"></p>
</li>
<li><p>dos下0:200H<del>0:2FFH的256个字节的空间是安全的，dos和其他合法程序一般都不会使用这段空间。内存0000:0000</del>0000:03FF大小为1kb的空间是系统存放中断处理程序入口地址的中断向量表。一般情况下0:200H~0:2FFH的256个字节的空间所对应的中断向量表都是空的，操作系统和其他应用程序都不占用。<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516184158629.png" alt="dos安全空间"></p>
</li>
</ul>
<h2 id="5-8-段前缀的使用"><a href="#5-8-段前缀的使用" class="headerlink" title="5.8 段前缀的使用"></a>5.8 段前缀的使用</h2><ul>
<li>将内存ffff:0~ffff:b段单元中的数据拷贝到0:200 ~ 0:20b单元中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">          mov bx,0 ;(bx)&#x3D;0，偏移地址从0开始</span><br><span class="line">          mov cx,12 ;(cx)&#x3D;12，循环12次</span><br><span class="line">      s:  mov ax,offffh</span><br><span class="line">          mov ds,ax ;(ds)&#x3D;0ffffh</span><br><span class="line">          mov dl,[bx] ;(ds)&#x3D;((ds)*16+(bx))，将ffff:bx中的数据送入dl</span><br><span class="line">          mov ax,0020h</span><br><span class="line">          mov ds,ax ;(ds)&#x3D;0020h</span><br><span class="line">          mov [bx],dl ;((ds)*16+(bx))&#x3D;dl，将数据送入0020:bx</span><br><span class="line">          inc bx ;(bx)&#x3D;(bx)+1</span><br><span class="line">          loop s</span><br><span class="line"></span><br><span class="line">          mov ax,4c00h</span><br><span class="line">          int 21h</span><br><span class="line">code ends</span><br><span class="line">end1234567891011121314151617</span><br></pre></td></tr></table></figure>

<ul>
<li>两个内存单元相差64KB则不再同一个段里，需要设置ds的值两次，效率不高。</li>
<li>使用 es(附加段)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">;优化后的代码，优化了两次设置ds</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">           mov ax,offffh</span><br><span class="line">           mov ds,ax ;(ds)&#x3D;0ffffh</span><br><span class="line">           mov ax,0020h</span><br><span class="line">           mov es,ax ;(es)&#x3D;0020H</span><br><span class="line">           mov bx,0 ;(bx)&#x3D;0，此时ds:bx指向ffff:0，es:bx指向0020:0</span><br><span class="line">           mov cx,12 ;(cx)&#x3D;12，循环12次</span><br><span class="line">       s:  mov dl,[bx] ;(ds)&#x3D;((ds)*16+(bx))，将ffff:bx中的数据送入dl</span><br><span class="line">           mov es:[bx],dl ;((es)*16+(bx))&#x3D;dl，将数据送入0020:bx</span><br><span class="line">           inc bx ;(bx)&#x3D;(bx)+1</span><br><span class="line">           loop s</span><br><span class="line"></span><br><span class="line">           mov ax,4c00h</span><br><span class="line">           int 21h</span><br><span class="line">code ends</span><br><span class="line">end123456789101112131415161718</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="六、包含多个段的程序"><a href="#六、包含多个段的程序" class="headerlink" title="六、包含多个段的程序"></a>六、包含多个段的程序</h1><h2 id="6-1在代码段中使用数据"><a href="#6-1在代码段中使用数据" class="headerlink" title="6.1在代码段中使用数据"></a>6.1在代码段中使用数据</h2><ul>
<li>编程计算0123H、0456H，0abxH、0defH、0fesH、0cbaH、0987H这8个数据的和，结果存放在ax中：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">        dw 0123H,0564H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span><br><span class="line">        ;dw，define word，定义字型数据，db定义字节型数据</span><br><span class="line">        ;由于数据在代码段中，所以段地址是CS</span><br><span class="line">        ;dw定义的数据在最开始的地方，所以偏移地址是0开始</span><br><span class="line">    start:mov bx,0 ;第一条指令</span><br><span class="line">        mov ax,0</span><br><span class="line">        mov cx,8</span><br><span class="line">    s:      add ax,cs:[bx]</span><br><span class="line">        add bx,2</span><br><span class="line">        loop s</span><br><span class="line">        mov ax,4c00H</span><br><span class="line">        int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start ;入口找end12345678910111213141516</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516185351745.png" alt="定义字型数据"></p>
<ul>
<li><strong>end的作用除了通知编译器结束之外还有告诉编译器程序的入口在什么地方。</strong></li>
<li>可执行文件中的程序执行过程</li>
</ul>
<h2 id="6-2-在代码段中使用栈"><a href="#6-2-在代码段中使用栈" class="headerlink" title="6.2 在代码段中使用栈"></a>6.2 在代码段中使用栈</h2><ul>
<li>利用栈编程将定义的数据逆序(联想栈的特性)存放：dw 0123H,0564H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">        dw 0123H,0564H,0789H,0abcH,0defH,0fedH,0cbaH,0987H;地址0~15</span><br><span class="line">        dw 0,0,0,0,0,0,0,0;定义8个字型空数据，后面当作栈来使用，地址是16~31</span><br><span class="line"></span><br><span class="line">    start:  </span><br><span class="line">            mov ax,cs</span><br><span class="line">            mov ss,ax</span><br><span class="line">            mov sp,32;设置栈底ss:sp指向cs:32，十进制的32</span><br><span class="line">            mov bx,0</span><br><span class="line">            mov cx,8</span><br><span class="line">           s:push cs:[bx]</span><br><span class="line">            add bx,2</span><br><span class="line">            loop s; 以上代码段0~15个单元中的8个字型数据一次入栈</span><br><span class="line"></span><br><span class="line">            mov bx,0</span><br><span class="line">            mov cx,8</span><br><span class="line">          s0:pop cs:[bx]</span><br><span class="line">            add bx,2</span><br><span class="line">            loop s0;依次出栈8个执行数据到代码段0~15单元中</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start;指明程序入口在start处12345678910111213141516171819202122232425</span><br></pre></td></tr></table></figure>

<ul>
<li>如果对此程序的栈有疑惑，跳转到 3.6 栈和3.10 栈段</li>
</ul>
<h2 id="6-3-将数据、代码、栈放入不同的段"><a href="#6-3-将数据、代码、栈放入不同的段" class="headerlink" title="6.3 将数据、代码、栈放入不同的段"></a>6.3 将数据、代码、栈放入不同的段</h2><ul>
<li>在8086CPU中数据、栈和代码存储空间不能大于64KB。<strong>可以用像定义代码段一样的方法来定义多个段并在其中定义需要的数据，或者通过定义数据来取得栈空间。</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:data,ss:stack;在源程序中为三个段进行有意义的名称</span><br><span class="line">data segment</span><br><span class="line">        dw 0123H,0564H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">        dw 0,0,0,0,0,0,0,0;定义8个字型空数据，后面当作栈来使用</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    start:      </span><br><span class="line">            mov ax,stack</span><br><span class="line">            mov ss,ax</span><br><span class="line">            mov sp,16;设置栈底ss:sp指向stack:16，</span><br><span class="line">            mov ax,data</span><br><span class="line">            mov ds,ax;ds指向data段</span><br><span class="line">            mov bx,0;ds:bx指向data段中的第一个单元</span><br><span class="line">           s:push cs:[bx]</span><br><span class="line">            add bx,2</span><br><span class="line">            loop s; 以上代码段0~16个单元中的8个字型数据一次入栈</span><br><span class="line"></span><br><span class="line">            mov bx,0</span><br><span class="line">            mov cx,8</span><br><span class="line">          s0:pop cs:[bx]</span><br><span class="line">            add bx,2</span><br><span class="line">            loop s0;依次出栈8个执行数据到代码段0~16单元中</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start;指明程序入口在start处12345678910111213141516171819202122232425262728293031</span><br></pre></td></tr></table></figure>

<ul>
<li>程序中指令决定了断中的内容是作为数据处理还是作为指令执行还是作为栈空间使用。</li>
</ul>
<h2 id="检测点-6-1"><a href="#检测点-6-1" class="headerlink" title="检测点 6.1"></a>检测点 6.1</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516185650553.png" alt="检测点6.1"></p>
<h2 id="实验五"><a href="#实验五" class="headerlink" title="实验五"></a>实验五</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:data,ss:stack</span><br><span class="line">data segment</span><br><span class="line">        dw 0123H,0564H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">        dw 0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">    start:  mov ax,stack</span><br><span class="line">            mov ss,ax</span><br><span class="line">            mov sp,16</span><br><span class="line">            mov ax,data</span><br><span class="line">            mov ds,ax</span><br><span class="line">            push ds:[0]</span><br><span class="line">            push ds:[2]</span><br><span class="line">            pop ds:[2]</span><br><span class="line">            pop ds:[0]</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start123456789101112131415161718192021222324</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="七、更灵活的定位内存地址的方法"><a href="#七、更灵活的定位内存地址的方法" class="headerlink" title="七、更灵活的定位内存地址的方法"></a>七、更灵活的定位内存地址的方法</h1><h2 id="7-1-and和or指令"><a href="#7-1-and和or指令" class="headerlink" title="7.1 and和or指令"></a>7.1 and和or指令</h2><ul>
<li><p>and指令：逻辑与指令，按位进行与运算。</p>
<blockquote>
<p>and两个同时为真的结果才为真。</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,01100011B</span><br><span class="line">and al,00111011B</span><br><span class="line">;执行后 al&#x3D;00100011B123</span><br></pre></td></tr></table></figure>

<ul>
<li>可用and指令将操作对象的相应位设为0，其他位不变</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">and al,10111111B;将al第六位设为0</span><br><span class="line">and al,01111111B;将al第七位设为0</span><br><span class="line">and al,11111110B;将al第0位设为0123</span><br></pre></td></tr></table></figure>

<ul>
<li>or指令：逻辑或指令，按位进行或运算。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,01100011B</span><br><span class="line">and al,00111011B</span><br><span class="line">;执行后 al&#x3D;01111011B123</span><br></pre></td></tr></table></figure>

<ul>
<li>可用or指令将操作对象的相应位设为1，其他位不变</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">and al,01000000B;将al第六位设为1</span><br><span class="line">and al,10000000B;将al第七位设为1</span><br><span class="line">and al,00000001B;将al第0位设为1123</span><br></pre></td></tr></table></figure>

<h2 id="7-2-关于ASCII码"><a href="#7-2-关于ASCII码" class="headerlink" title="7.2 关于ASCII码"></a>7.2 关于ASCII码</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516190632064.png" alt="ASCII码表"></p>
<ul>
<li>将字符的ascii码写入显存屏幕就显示出相关的字符。</li>
</ul>
<h2 id="7-3-以字符形式给出数据"><a href="#7-3-以字符形式给出数据" class="headerlink" title="7.3 以字符形式给出数据"></a>7.3 以字符形式给出数据</h2><ul>
<li>用‘’的方式指明数据是以字符的形式给出的。<strong>例如’A’</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">        db &#39;unIx&#39;</span><br><span class="line">        db &#39;foRK&#39;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:  mov al,&#39;a&#39;</span><br><span class="line">            mov bx,&#39;b&#39;</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">code ends</span><br><span class="line">end start123456789101112131415</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516191127691.png" alt="73 ascii"></p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516191202229.png" alt="以字符形式给出数据"></p>
<h2 id="7-4-大小写转换的问题"><a href="#7-4-大小写转换的问题" class="headerlink" title="7.4 大小写转换的问题"></a>7.4 大小写转换的问题</h2><ul>
<li><strong>大写字母比小写字母ASCII大32(20H)。</strong></li>
</ul>
<table>
<thead>
<tr>
<th>大写</th>
<th>二进制</th>
<th>小写</th>
<th>二进制</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>01000001</td>
<td>a</td>
<td>01100001</td>
</tr>
<tr>
<td>B</td>
<td>01000010</td>
<td>b</td>
<td>01100010</td>
</tr>
<tr>
<td>C</td>
<td>01000011</td>
<td>c</td>
<td>01100011</td>
</tr>
<tr>
<td>D</td>
<td>01000100</td>
<td>d</td>
<td>01100100</td>
</tr>
</tbody></table>
<ul>
<li>从第0位开始计算，大写字母ASCII码第五位为0，小写字母ASCII码第五位为1。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">;大小写转换</span><br><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db&#39;BaSiC&#39;</span><br><span class="line">db&#39;iNfOfMaTiOn&#39;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">    start:  mov ax,datasg</span><br><span class="line">            mov ds,ax;设置ds执行datasg段</span><br><span class="line">            mov bx,0;设置(bx)&#x3D;0，ds:bx指向&#39;BaSiC&#39;的第一个字母</span><br><span class="line">            mov cx,5;设置循环次数，因为BaSiC有5个字母</span><br><span class="line">              s:mov al,[bx];将ASCII码从ds:bx所指向的单元中取出</span><br><span class="line">            and al,11011111B;口岸al中ASCII码的第5个位置变为0，变为大写字母</span><br><span class="line">            mov [bx],al;转变后将ASCII码写回单元</span><br><span class="line">            inc bx;(bx)加1，ds:bx指向下一个字母</span><br><span class="line">            loop x</span><br><span class="line">            mov bx,5;设置(bx)&#x3D;5，ds:bx指向&#39;iNfOfMaTiOn&#39;的第一个字母</span><br><span class="line">            mov cx,11</span><br><span class="line">             s0:mov al,[bx]</span><br><span class="line">            or al,00100000B</span><br><span class="line">            mov [bx],al</span><br><span class="line">            inc bx</span><br><span class="line">            loop s0</span><br><span class="line"></span><br><span class="line">            mov ax,4c00H</span><br><span class="line">            int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br><span class="line">123456789101112131415161718192021222324252627282930</span><br></pre></td></tr></table></figure>

<h2 id="7-5-bx-idata"><a href="#7-5-bx-idata" class="headerlink" title="7.5 [bx+idata]"></a>7.5 [bx+idata]</h2><ul>
<li>[bx+idata]表示的是一个内存单元，它的偏移地址为bx+idata</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;[bx+idata]可以写成以下格式</span><br><span class="line">mov ax,[200+bx]</span><br><span class="line">mov ax,200[bx]</span><br><span class="line">mov ax,[bx].2001234</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;使用debug查看内存</span><br><span class="line">mov ax,2000H</span><br><span class="line">mov ds:ax</span><br><span class="line">mov bx,1000H</span><br><span class="line">mov ax,[bx]</span><br><span class="line">mov cx,[bx+1]</span><br><span class="line">add cx,[bx+2]1234567</span><br></pre></td></tr></table></figure>

<h2 id="7-6-用-bx-idata-的方式进行数组的处理"><a href="#7-6-用-bx-idata-的方式进行数组的处理" class="headerlink" title="7.6 用[bx+idata]的方式进行数组的处理"></a>7.6 用[bx+idata]的方式进行数组的处理</h2><ul>
<li>用[bx+idata]的方式进行数组处理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">;改进大小写转换程序</span><br><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db&#39;BaSiC&#39;</span><br><span class="line">db&#39;iNfOfMaTiOn&#39;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">    start:  mov ax,datasg</span><br><span class="line">            mov ds,ax;设置ds执行datasg段</span><br><span class="line">            mov bx,0;设置(bx)&#x3D;0，ds:bx指向&#39;BaSiC&#39;的第一个字母</span><br><span class="line">            mov cx,5;设置循环次数，因为BaSiC有5个字母</span><br><span class="line">          s:mov al,[bx+0];将ASCII码从ds:bx所指向的单元中取出</span><br><span class="line">            and al,11011111B;口岸al中ASCII码的第5个位置变为0，变为大写字母</span><br><span class="line">            mov [bx],al;转变后将ASCII码写回单元</span><br><span class="line">            mov [bx+5];定位第二个字符串的字符</span><br><span class="line">            or al,00100000B</span><br><span class="line">            mov [bx+5],al</span><br><span class="line">            inc bx</span><br><span class="line">            loop s</span><br><span class="line"></span><br><span class="line">            mov ax,4c00H</span><br><span class="line">            int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start12345678910111213141516171819202122232425</span><br></pre></td></tr></table></figure>

<ul>
<li>C语言的形式</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">include&lt;stdio.h&gt;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">char</span> a[<span class="number">5</span>]=<span class="string">"BaSiC"</span>;</span><br><span class="line"><span class="keyword">char</span> b[<span class="number">11</span>]=<span class="string">"iNfOfMaTiOn"</span>;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=a[i]&amp;<span class="number">0xDF</span>;</span><br><span class="line">        b[i]=b[i]|<span class="number">0x20</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;<span class="keyword">while</span>(i&lt;<span class="number">5</span>);</span><br><span class="line">&#125;<span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<h2 id="7-7-SI和DI"><a href="#7-7-SI和DI" class="headerlink" title="7.7 SI和DI"></a>7.7 SI和DI</h2><ul>
<li><strong>SI和DI在8086CPU中和bx功能相近，充当BX的扩充，但是不能分成两个8位寄存器来使用。[SI]段地址默认也是在DS中。</strong></li>
<li>下面的指令实现了相同的功能</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mov bx,0</span><br><span class="line">mov ax,[bx]</span><br><span class="line"></span><br><span class="line">mov si,0</span><br><span class="line">mov ax,[si]</span><br><span class="line"></span><br><span class="line">mov di,0</span><br><span class="line">mov ax,[di]</span><br><span class="line">;-------------</span><br><span class="line">;下面的三组指令也实现了另一个组相同的功能</span><br><span class="line">;-------------</span><br><span class="line">mov bx,0</span><br><span class="line">mov ax,[bx+123]</span><br><span class="line"></span><br><span class="line">mov si,0</span><br><span class="line">mov ax,[si+123]</span><br><span class="line"></span><br><span class="line">mov di,0</span><br><span class="line">mov ax,[di+123]12345678910111213141516171819</span><br></pre></td></tr></table></figure>

<ul>
<li>一般ds:si指向要复制的原始空间，ds:di指向复制的目的空间。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">;用DI和SI实现复制到它后面的数据区中</span><br><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db&#39;welcome to asm!&#39;</span><br><span class="line">db&#39;................&#39;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">    start  :mov ax,datasg</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov si,0</span><br><span class="line">            mov di,16</span><br><span class="line">            mov cx,8</span><br><span class="line">          s:mov ax,[si]</span><br><span class="line">            mov [di],ax</span><br><span class="line">            add si,2</span><br><span class="line">            add di,2</span><br><span class="line">            loop s</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21H</span><br><span class="line">;------</span><br><span class="line">;用数组的思维[bx(si或di)+idata]的方式优化程序</span><br><span class="line">;------</span><br><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db&#39;welcome to asm!&#39;</span><br><span class="line">db&#39;................&#39;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">    start  :mov ax,datasg</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov si,0</span><br><span class="line">            mov cx,8</span><br><span class="line">          s:mov ax,[si];第一个字符串的的第一个元素</span><br><span class="line">            mov [si+16],ax;目标字符串的第二个元素</span><br><span class="line">            add si,2</span><br><span class="line">            loop s</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br><span class="line">123456789101112131415161718192021222324252627282930313233343536373839404142434445</span><br></pre></td></tr></table></figure>

<h2 id="7-8-bx-si-和-bx-di"><a href="#7-8-bx-si-和-bx-di" class="headerlink" title="7.8 [bx+si]和[bx+di]"></a>7.8 [bx+si]和[bx+di]</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2000h</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,1000h</span><br><span class="line">mov si,0</span><br><span class="line">mov ax,[bx+si]</span><br><span class="line">inc si</span><br><span class="line">mov cx,[bx+si]</span><br><span class="line">inc si</span><br><span class="line">mov di,si</span><br><span class="line">mov ax,[bx+di]12345678910</span><br></pre></td></tr></table></figure>

<h2 id="7-9-bx-si-idata-和-bx-di-idata"><a href="#7-9-bx-si-idata-和-bx-di-idata" class="headerlink" title="7.9 [bx+si+idata]和[bx+di+idata]"></a>7.9 [bx+si+idata]和[bx+di+idata]</h2><ul>
<li>常数后要加.<strong>例如</strong>[bx+si].idata或者[bx].idata[si]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2000h</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,1000h</span><br><span class="line">mov si,0</span><br><span class="line">mov ax,[bx+2+si]</span><br><span class="line">inc si</span><br><span class="line">mov cx,[bx+si+2]</span><br><span class="line">inc si</span><br><span class="line">mov di,si</span><br><span class="line">mov ax,[bx+di+2]12345678910</span><br></pre></td></tr></table></figure>

<h2 id="7-10-不同的寻址方式的灵活应用"><a href="#7-10-不同的寻址方式的灵活应用" class="headerlink" title="7.10 不同的寻址方式的灵活应用"></a>7.10 不同的寻址方式的灵活应用</h2><ul>
<li>编程将数据段中每一个单词的头一个字母改为大写字母。</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516192520279.png" alt="数据段中的数据存储结构_2"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">    db&#39;1. file          &#39;;长度刚好都是16个字节</span><br><span class="line">    db&#39;2. edit          &#39;</span><br><span class="line">    db&#39;3. search        &#39;</span><br><span class="line">    db&#39;4. view          &#39;</span><br><span class="line">    db&#39;5. options       &#39;</span><br><span class="line">    db&#39;6. help          &#39;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">      start:</span><br><span class="line">            mov ax,datasg</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov bx,0</span><br><span class="line">            mov cx,6</span><br><span class="line">          s:    </span><br><span class="line">            mov al,[bx+3]</span><br><span class="line">            and al,11011111B</span><br><span class="line">            mov [bx+3],al</span><br><span class="line">            add bx,16</span><br><span class="line">            loop s</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start123456789101112131415161718192021222324252627</span><br></pre></td></tr></table></figure>

<ul>
<li>编程将数据段中每个单词改为大写字母</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516192653168.png" alt="数据段中的数据存储结构2"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">;有bug，问题在于cx的使用，进行二重循环，只用一个循环计数器，造成在进行内层的时候覆盖了外层循环的循环计数值。</span><br><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">    db &#39;ibm             &#39;</span><br><span class="line">    db &#39;dec             &#39;</span><br><span class="line">    db &#39;dos             &#39;</span><br><span class="line">    db &#39;vax             &#39;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">      start:mov ax,datasg</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov bx,0;用bx来定位行</span><br><span class="line">            mov cx,4</span><br><span class="line">         s0:mov si,0;用si来定位列</span><br><span class="line">            mov cx,3</span><br><span class="line">          s:mov al,[bx+si]</span><br><span class="line">            and al,11011111B</span><br><span class="line">            mov [bx+si],al</span><br><span class="line">            inc si</span><br><span class="line">            loop s</span><br><span class="line">            add bx,16</span><br><span class="line">            loop s0</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start12345678910111213141516171819202122232425262728</span><br></pre></td></tr></table></figure>

<ul>
<li>程序没有返回到cmd</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516192911638.png" alt="712bug"></p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516192928623.png" alt="712bug1"></p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516192952451.png" alt="712bug2"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loop s;三次循环后cx等于0了</span><br><span class="line">add bx,16</span><br><span class="line">loop s0;先是cx&#x3D;cx-1再判断时候等于0，此时cx&#x3D;FFFF不为0再循环，变成死循环了123</span><br></pre></td></tr></table></figure>

<ul>
<li>因为loop是和cx一起使用的，不能多用个寄存器来解决loop循环次数的问题。解决的方法是在每次开始内层循环时用dx将外层循环cx的值保存起来，在执行外层循环的loop指令前再回复外层循环的cx的数值。</li>
<li>改进后程序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">    datasg segment</span><br><span class="line">    db &#39;ibm             &#39;</span><br><span class="line">    db &#39;dec             &#39;</span><br><span class="line">    db &#39;dos             &#39;</span><br><span class="line">    db &#39;vax             &#39;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">      start:</span><br><span class="line">            mov ax,datasg</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov bx,0;用bx来定会行</span><br><span class="line">            mov cx,4</span><br><span class="line">         s0:</span><br><span class="line">            mov dx,cx;用dx寄存器来临时存放外层cx的值</span><br><span class="line">            mov si,0;用si来定位列</span><br><span class="line">            mov cx,3</span><br><span class="line">          s:</span><br><span class="line">            mov al,[bx+si]</span><br><span class="line">            and al,11011111B</span><br><span class="line">            mov [bx+si],al</span><br><span class="line">            inc si</span><br><span class="line">            loop s</span><br><span class="line">            add bx,16</span><br><span class="line">            mov cx,dx;在进行外层循环的时候回复cx的值</span><br><span class="line">            loop s0</span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start12345678910111213141516171819202122232425262728293031</span><br></pre></td></tr></table></figure>

<ul>
<li>在上面的程序中，8086 CPU si、cx、ax、bx这些寄存器经常要使用到；cs、ip、ds也不能用，因为cs:ip时刻指向当前指令，ds指向datasg段；那么可用的寄存器就只用dx、di、es、ss、sp、bp等寄存器了。<strong>内存可以解决经常性的数据暂存问题。为了使程序结构清晰便于阅读，应该使用栈</strong></li>
<li>再次被改进的程序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">    datasg segment</span><br><span class="line">    db &#39;ibm             &#39;</span><br><span class="line">    db &#39;dec             &#39;</span><br><span class="line">    db &#39;dos             &#39;</span><br><span class="line">    db &#39;vax             &#39;</span><br><span class="line">    dw 0;定义一个字用来保存cx的值</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">      start:mov ax,datasg</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov bx,0;用bx来定位行</span><br><span class="line">            mov cx,4</span><br><span class="line">         s0:mov ds:[40h],cx;datasg:40h单元存放外层cx的值</span><br><span class="line">            mov si,0;用si来定位列</span><br><span class="line">            mov cx,3</span><br><span class="line">          s:mov al,[bx+si]</span><br><span class="line">            and al,11011111B</span><br><span class="line">            mov [bx+si],al</span><br><span class="line">            inc si</span><br><span class="line">            loop s</span><br><span class="line">            add bx,16</span><br><span class="line">            mov cx,ds:[40h];在进行外层循环的时候回复cx的值</span><br><span class="line">            loop s0</span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start1234567891011121314151617181920212223242526272829</span><br></pre></td></tr></table></figure>

<ul>
<li>再次使用栈改进程序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg,ss:stacksg</span><br><span class="line">datasg segment</span><br><span class="line">    db &#39;ibm             &#39;</span><br><span class="line">    db &#39;dec             &#39;</span><br><span class="line">    db &#39;dos             &#39;</span><br><span class="line">    db &#39;vax             &#39;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">stacksg segment</span><br><span class="line">    dw 0,0,0,0,0,0,0,0;定义一个段，用作栈段，容量为16个字节</span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">      start:mov ax,stacksg</span><br><span class="line">            mov ss,ax</span><br><span class="line">            mov sp,16</span><br><span class="line">            mov ax,datasg</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov bx,0;用bx来定位行</span><br><span class="line">            mov cx,4</span><br><span class="line">         s0:push cx;datasg:40h单元存放外层cx的值</span><br><span class="line">            mov si,0;用si来定位列</span><br><span class="line">            mov cx,3</span><br><span class="line">          s:mov al,[bx+si]</span><br><span class="line">            and al,11011111B</span><br><span class="line">            mov [bx+si],al</span><br><span class="line">            inc si</span><br><span class="line">            loop s</span><br><span class="line">            add bx,16</span><br><span class="line">            pop cx;在进行外层循环的时候回复cx的值</span><br><span class="line">            loop s0</span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start1234567891011121314151617181920212223242526272829303132333435</span><br></pre></td></tr></table></figure>

<ul>
<li>编程将数据段中的每个单词的前四个字母改为大写字母</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516193134171.png" alt="数据段中的数据存储结构3"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg,ss:stacksg</span><br><span class="line"></span><br><span class="line">stacksg segment</span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">    db &#39;1. display      &#39;</span><br><span class="line">    db &#39;2. brows        &#39;</span><br><span class="line">    db &#39;3. replace      &#39;</span><br><span class="line">    db &#39;4. modify       &#39;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">      start:mov ax,stacksg</span><br><span class="line">            mov ss,ax</span><br><span class="line">            mov sp,16</span><br><span class="line">            mov ax,datasg</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov bx,0</span><br><span class="line">            mov cx,4</span><br><span class="line">         s0:push cx</span><br><span class="line">            mov si,0</span><br><span class="line">            mov cx,4</span><br><span class="line">          s:mov al,[bx+si+3]</span><br><span class="line">            and al,11011111B</span><br><span class="line">            mov [bx+si+3],al</span><br><span class="line">            inc si</span><br><span class="line">            loop s</span><br><span class="line">            add bx,16</span><br><span class="line">            pop cx</span><br><span class="line">            loop s0</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start1234567891011121314151617181920212223242526272829303132333435</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="八、数据处理的两个基本问题"><a href="#八、数据处理的两个基本问题" class="headerlink" title="八、数据处理的两个基本问题"></a>八、数据处理的两个基本问题</h1><h2 id="引言-4"><a href="#引言-4" class="headerlink" title="引言"></a>引言</h2><ul>
<li>本章是总结性的内容，数据处理的两个基本问题是<ul>
<li>处理的数据在哪？</li>
<li>要处理的数据有多长？</li>
</ul>
</li>
<li>自定义得描述符：<ul>
<li>reg寄存器<ul>
<li>ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di；</li>
</ul>
</li>
<li>sreg段寄存器<ul>
<li>ds、ss、cs、es。</li>
<li>-</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="8-1-bx、si、di、bp"><a href="#8-1-bx、si、di、bp" class="headerlink" title="8.1 bx、si、di、bp"></a>8.1 bx、si、di、bp</h2><ul>
<li>在8086 CPU中只有bx、si、di、bp这四个寄存器用在[ ]中进行内存单元寻址。<strong>在[]中，组合只能以这四种形式：bx和si、bx和di、bp和si、bp和di</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;以下指令是错误的</span><br><span class="line">mov ax,[ax]</span><br><span class="line">mov ax,[cx]</span><br><span class="line">mov ax,[dx]</span><br><span class="line">mov ax,[ds]</span><br><span class="line">mov ax,[bx+bp]</span><br><span class="line">mov ax,[si+di]1234567</span><br></pre></td></tr></table></figure>

<ul>
<li>正确的指令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx]</span><br><span class="line">mov ax,[si]</span><br><span class="line">mov ax,[di]</span><br><span class="line">mov ax,[bp]</span><br><span class="line">mov ax,[bx+si]</span><br><span class="line">mov ax,[bx+di]</span><br><span class="line">mov ax,[bp+si]</span><br><span class="line">mov ax,[bp+di]</span><br><span class="line">mov ax,[bx+si+idata]</span><br><span class="line">mov ax,[bx+di+idata]</span><br><span class="line">mov ax,[bp+si+idata]</span><br><span class="line">mov ax,[bp+di+idata]123456789101112</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>[bp]的段地址默认在ss中。</strong></li>
</ul>
<h2 id="8-2-机器指令处理的数据所在的位置"><a href="#8-2-机器指令处理的数据所在的位置" class="headerlink" title="8.2 机器指令处理的数据所在的位置"></a>8.2 机器指令处理的数据所在的位置</h2><ul>
<li>绝大部分机器指令时进行数据处理的，大致可以分为3类：读、写、运算。指令在处理前可以在三个地方：CPU内部、内存、端口。</li>
</ul>
<table>
<thead>
<tr>
<th>机器码</th>
<th>汇编指令</th>
<th>指令执行前数据的位置</th>
</tr>
</thead>
<tbody><tr>
<td>89C3</td>
<td>mov bx,[0]</td>
<td>内存，ds:0单元</td>
</tr>
<tr>
<td>89C3</td>
<td>mov bx,ax</td>
<td>CPU内部，ax寄存器</td>
</tr>
<tr>
<td>BB0100</td>
<td>mov bx,1</td>
<td>CPU内部，指令缓冲器</td>
</tr>
</tbody></table>
<h2 id="8-3-汇编语言中数据位置的表达"><a href="#8-3-汇编语言中数据位置的表达" class="headerlink" title="8.3 汇编语言中数据位置的表达"></a>8.3 汇编语言中数据位置的表达</h2><ul>
<li>汇编语言中用三个概念来表达数据的位置。<ul>
<li>1、立即数(idata)</li>
<li>2、寄存器</li>
<li>3、段地址(SA)和偏移地址(EA)</li>
</ul>
</li>
</ul>
<h2 id="8-4-寻址方式总小结"><a href="#8-4-寻址方式总小结" class="headerlink" title="8.4 寻址方式总小结"></a>8.4 寻址方式总小结</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516193307578.png" alt="寻址方式总结_1"></p>
<h2 id="8-5-指令要处理的数据有多长"><a href="#8-5-指令要处理的数据有多长" class="headerlink" title="8.5 指令要处理的数据有多长"></a>8.5 指令要处理的数据有多长</h2><ul>
<li>8086 CPU可以处理byte和word两种数据尺寸。</li>
<li><strong>通过寄存器指明要处理的数据尺寸；push指令只进行字操作，若没有寄存器名存在的情况下，用操作符word ptr或者byte ptr指明内存单元的长度。</strong> 例如</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr ds:[0],1</span><br><span class="line">inc word ptr [bx]</span><br><span class="line">inc word ptr ds:[0]</span><br><span class="line">add byte ptr [bx],21234</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">;假设内存2000:1000 FF FF FF FF FF FF ……</span><br><span class="line">;如果用以下指令</span><br><span class="line">mov ax,2000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov byte ptr [1000H],1</span><br><span class="line">;那么内存中的内容变为</span><br><span class="line">;2000:1000 01 FF FF FF FF FF ……</span><br><span class="line">如果是用以下指令</span><br><span class="line">mov ax,2000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov word ptr [1000H],1</span><br><span class="line">;那么内存中的内容变为</span><br><span class="line">;2000:1000 01 00 FF FF FF ……12345678910111213</span><br></pre></td></tr></table></figure>

<h2 id="8-6-寻址方式的综合应用"><a href="#8-6-寻址方式的综合应用" class="headerlink" title="8.6 寻址方式的综合应用"></a>8.6 寻址方式的综合应用</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516193354516.png" alt="86题目_1"></p>
<ul>
<li>初步汇编代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mov ax,seg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,60h;确定记录物理地址：ds:bx</span><br><span class="line">mov word ptr [bx+0ch],38;寄存器相对寻址     排名字段改为38</span><br><span class="line">add word ptr [bx+0eh],70;收入字段增加70</span><br><span class="line">  </span><br><span class="line">mov si,0;用si来定位产品字符串中的字符</span><br><span class="line">mov byte ptr [bx+10h+si],&#39;V&#39;;相对基址变址寻址</span><br><span class="line">inc si</span><br><span class="line">mov byte ptr [bx+10h+si],&#39;A&#39;</span><br><span class="line">inc si</span><br><span class="line">mov byte ptr [bx+10h+si],&#39;X&#39;123456789101112</span><br></pre></td></tr></table></figure>

<ul>
<li>c语言描述</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">company</span>  /*定义一个公司记录的结构体*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> cn[<span class="number">3</span>]; <span class="comment">/*公司名称*/</span></span><br><span class="line">    <span class="keyword">char</span> hn[<span class="number">9</span>]; <span class="comment">/*总裁姓名*/</span></span><br><span class="line">    <span class="keyword">int</span> pm;     <span class="comment">/*排名*/</span></span><br><span class="line">    <span class="keyword">int</span> sr;     <span class="comment">/*收入*/</span></span><br><span class="line">    <span class="keyword">char</span> cp[<span class="number">3</span>]; <span class="comment">/*著名产品*/</span></span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">compant</span> <span class="title">dec</span>=&#123;</span><span class="string">"DEC"</span>,<span class="string">"Ken Olsen"</span>,<span class="number">137</span>,<span class="number">40</span>,<span class="string">"PDF"</span>&#125;;</span><br><span class="line"><span class="comment">/*定义一个公司记录的变量，内存中将存有一条公司的记录*/</span></span><br><span class="line">mian()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    dec.pm=<span class="number">38</span>;</span><br><span class="line">    dec.sr=dec.sr+<span class="number">70</span>;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    dec.cp[i]=<span class="string">'V'</span>;</span><br><span class="line">    i++;</span><br><span class="line">    dec.cp[i]=<span class="string">'A'</span>;</span><br><span class="line">    i++;</span><br><span class="line">    dec.cp[i]=<span class="string">'X'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="number">123456789101112131415161718192021222324</span></span><br></pre></td></tr></table></figure>

<ul>
<li>按照c语言的风格用汇编写</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mov ax,seg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,60h;记录首地址送入bx</span><br><span class="line">  </span><br><span class="line">mov word ptr [bx].och,38;排名字段改为38</span><br><span class="line">add word ptr [bx].0eh,70;收入字段增加70</span><br><span class="line">  </span><br><span class="line">;产品名字段改为字符串&#39;VAX&#39;</span><br><span class="line">mov si,0</span><br><span class="line">mov byte ptr [bx].10h[si],&#39;V&#39;</span><br><span class="line">inc si</span><br><span class="line">mov byte ptr [bx].10h[si],&#39;A&#39;</span><br><span class="line">inc si</span><br><span class="line">mov byte ptr [bx].10h[si],&#39;X&#39;1234567891011121314</span><br></pre></td></tr></table></figure>

<ul>
<li>多种寻址方式为结构化数据的处理提供了方便。</li>
<li><strong>一般用[bx+idata+si]的方式来访问结构体，用idata定位结构体中的某一数据项，用si定位数组项中的每个元素。</strong> 例如：[bx].idata、[bx].idata[si]。</li>
</ul>
<h2 id="8-7-div指令"><a href="#8-7-div指令" class="headerlink" title="8.7 div指令"></a>8.7 div指令</h2><ul>
<li>div(divide)是除法指令，可用乘法模拟，格式为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div reg(寄存器)</span><br><span class="line">div 内存单元。12</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>除数：8位或16位，在寄存器或内存单元中；被除数：默认放在AX或DX和AX中。</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div byte ptr ds:[0]</span><br><span class="line">div byte ptr [bx+si+idata]</span><br><span class="line">;al放商，ah放余数</span><br><span class="line">  </span><br><span class="line">div word ptr es:[0]</span><br><span class="line">div word ptr [bx+si+idata]</span><br><span class="line">;ax放商，dx放余数1234567</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>除数</th>
<th>被除数</th>
</tr>
</thead>
<tbody><tr>
<td>8位</td>
<td>16为(AX)</td>
</tr>
<tr>
<td>16位</td>
<td>32位(DX高16位+AX低16位)</td>
</tr>
</tbody></table>
<p>- 8位或16位看的是除数。</p>
<table>
<thead>
<tr>
<th>运算</th>
<th>8位</th>
<th>16位</th>
</tr>
</thead>
<tbody><tr>
<td>商</td>
<td>AL</td>
<td>AX</td>
</tr>
<tr>
<td>余数</td>
<td>AH</td>
<td>DX</td>
</tr>
</tbody></table>
<p>- 利用除法指令计算10001/100编程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;被除数1001可用ax寄存器存放，除数100可用8位寄存器存放，要进行8位除法。</span><br><span class="line">mov ax,1001</span><br><span class="line">mov bl,100</span><br><span class="line">div bl</span><br><span class="line">;执行后al的值等于0AH(10)，ah的值等于1(余数为1)。12345</span><br></pre></td></tr></table></figure>

<ul>
<li>利用除法指令计算100001/100编程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;被除数100001大于2^16&#x3D;65535(FFFF)，不能用ax来存放，要用dx和ax两个寄存器联合存放。除数小于255，可用一个8位寄存器存放，但是被除数是32位的，除数应为16位，所以要用一个16位寄存器来存放除数。</span><br><span class="line">;100001的十六进制为186A1H，100001的高16位(1)存放在dx，低16位(86AH)存放在ax中。</span><br><span class="line">mov dx,1</span><br><span class="line">mov ax,86A1H</span><br><span class="line">mov bx,100</span><br><span class="line">div bx</span><br><span class="line">;执行后ax内容等于03E8H(即1000)，dx的值等于1(余数)。1234567</span><br></pre></td></tr></table></figure>

<h2 id="8-8-伪指令dd"><a href="#8-8-伪指令dd" class="headerlink" title="8.8 伪指令dd"></a>8.8 伪指令dd</h2><ul>
<li>db定义字节型数据，dw定于字型数据，<strong>dd 定于 dword(double word双字型数据)</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">        db 1;第一个数据为01h，在data:0处，占1个字节</span><br><span class="line">        dw 1;第二个数据为0001h，在data:1处，占1个字</span><br><span class="line">        dd 1;第三个数据为00000001h，在data:3处，占2个字</span><br><span class="line">data ends12345</span><br></pre></td></tr></table></figure>

<ul>
<li>利用除法指令计算 dd 100001H 除以 dw 100，商放在 dw 0中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">    dd 100001H;低16位存储在ax中，高16位存储在dx中</span><br><span class="line">    dw 100</span><br><span class="line">    dw 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ax,ds:[0];低16位存储在ax中</span><br><span class="line">    mov dx,ds:[2];高16位存储在dx中</span><br><span class="line">    div word ptr ds:[4]</span><br><span class="line">    mov ds:[6],ax123456789101112</span><br></pre></td></tr></table></figure>

<h2 id="8-9-伪指令dup"><a href="#8-9-伪指令dup" class="headerlink" title="8.9 伪指令dup"></a>8.9 伪指令dup</h2><ul>
<li>和db、dw、dd等数据定义伪指令配合使用，用来进行数据的重复。格式 db或者dw或者dd 重复的次数 dup (重复的数据)</li>
<li>例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db 3 dup(0)</span><br><span class="line">;定义了3个字节，它们的值都是0，等同于db 0,0,0。</span><br><span class="line">db 3 dup(0,1,2)</span><br><span class="line">;定义了9个直接，它们是0、1、2、0、1、2、0、1、2，相当于db 0、1、2、0、1、2、0、1、2</span><br><span class="line">db 3 dup(&#39;abc&#39;,&#39;ABC&#39;)</span><br><span class="line">;定义了18个直接，它们是&#39;abcABCabcABCabcABC&#39;123456</span><br></pre></td></tr></table></figure>

<h2 id="实验七-寻址方式在结构化数据访问中的应用"><a href="#实验七-寻址方式在结构化数据访问中的应用" class="headerlink" title="实验七 寻址方式在结构化数据访问中的应用"></a>实验七 寻址方式在结构化数据访问中的应用</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516194436381.png" alt="实验7"><br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516194814140.png" alt="实验7数据"></p>
<ul>
<li>ds已经和data段联系了，数据段不够用时用扩展段ES</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">;初始化阶段</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,table;data已经被占用</span><br><span class="line">mov es,ax</span><br><span class="line">  </span><br><span class="line">mov bx,0</span><br><span class="line">mov si,0</span><br><span class="line">mov di,0</span><br><span class="line">mov cx,21</span><br><span class="line">  </span><br><span class="line">;存放年份,每一个bx就是一个字节</span><br><span class="line">mov al,[bx]</span><br><span class="line">mov es:[di],al</span><br><span class="line">mov al,[bx+1]</span><br><span class="line">mov es:[di+1],al</span><br><span class="line">mov al,[bx+2]</span><br><span class="line">mov es:[di+2],al</span><br><span class="line">mov al,[bx+3]</span><br><span class="line">mov es:[di+3],al</span><br><span class="line">  </span><br><span class="line">;存放公司的总收入</span><br><span class="line">mov ax,[bx+54H];第一个年收入是dd数据类型，段地址为54H</span><br><span class="line">mov dx,[bx+54H]</span><br><span class="line">mov es:[di+5H],ax</span><br><span class="line">mov es:[di+7H],dx</span><br><span class="line">  </span><br><span class="line">;存放公司的人数</span><br><span class="line">mov ax,[si+0A8H];第一个人数的数据段地址为0A8H</span><br><span class="line">mov es:[di+0A8H],ax</span><br><span class="line">  </span><br><span class="line">;计算人均收入并存放</span><br><span class="line">mov ax,[bx+54H]</span><br><span class="line">mov dx,[bx+56H];这两句诗初始化被除数</span><br><span class="line">div word ptr,ds:[si+0A8H];除以人数</span><br><span class="line">mov es:[di+0dH],ax;将商放入指定位置</span><br><span class="line">  </span><br><span class="line">;为下一次循环时存放数据做准备</span><br><span class="line">add bx,4;bx确定年份和收入</span><br><span class="line">add si,2;si确定人数</span><br><span class="line">add di,16;di确定的是每行的列数1234567891011121314151617181920212223242526272829303132333435363738394041</span><br></pre></td></tr></table></figure>

<ul>
<li>完整的程序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:data,es:table</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">        db &#39;1975&#39;,&#39;1976&#39; &#39;1977&#39; ……</span><br><span class="line">        dd 16，22，382 ……</span><br><span class="line">        dw 3,7,9 ……</span><br><span class="line">        ;数据在题目中</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">table segment</span><br><span class="line">        db 21 dup(&#39;year summ ne ?? &#39;)</span><br><span class="line">table ends</span><br><span class="line"></span><br><span class="line">      start:mov ax,data</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov ax,table</span><br><span class="line">            mov es,ax</span><br><span class="line"></span><br><span class="line">            mov bx,0</span><br><span class="line">            mov si,0</span><br><span class="line">            mov di,0</span><br><span class="line">            mov cx,21</span><br><span class="line"></span><br><span class="line">          s:mov al,[bx]</span><br><span class="line">            mov es:[di],al</span><br><span class="line">            mov al,[bx+1]</span><br><span class="line">            mov es:[di+1],al</span><br><span class="line">            mov al,[bx+2]</span><br><span class="line">            mov es:[di+2],al</span><br><span class="line">            mov al,[bx+3]</span><br><span class="line">            mov es:[di+3],al</span><br><span class="line"></span><br><span class="line">            mov ax,[bx+54H]</span><br><span class="line">            mov dx,[bx+56H]</span><br><span class="line">            mov es:[di+5H],ax</span><br><span class="line">            mov es:[di+7H],dx</span><br><span class="line"></span><br><span class="line">            mov ax,[si+0A8H]</span><br><span class="line">            mov es:[di+0AH],ax</span><br><span class="line"></span><br><span class="line">            mov ax,[bx+54H]</span><br><span class="line">            div word ptr ds:[si+0A8H]</span><br><span class="line">            mov es:[di+0dH],ax</span><br><span class="line"></span><br><span class="line">            add bx,4</span><br><span class="line">            add si,2</span><br><span class="line">        loop s</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="九、转移指令的原理"><a href="#九、转移指令的原理" class="headerlink" title="九、转移指令的原理"></a>九、转移指令的原理</h1><h2 id="引言-5"><a href="#引言-5" class="headerlink" title="引言"></a>引言</h2><ul>
<li><strong>可以修改IP，或者同时修改CS和IP的指令统称为转移指令。</strong> 简单的来说可以控制CPU执行内存中某处代码的指令就是转移指令。</li>
<li>8086</li>
<li>CPU的转移行为有<strong>只修改的段内转移</strong>(如jmp ax) 和<strong>同时修改该CS和IP的段间转移</strong>(如jmp 1000:0)。其中段内转移分为<strong>短转移</strong>(IP的修改范围为-128<del>127)和<strong>近转移</strong> (IP的修改范围为-32768</del>32767)。</li>
<li>8086 CPU的转移指令分为以下几类：<ul>
<li>无条件转移指令(如：jmp)</li>
<li>条件转移指令</li>
<li>循环指令(如：loop)</li>
<li>过程</li>
<li>中断</li>
</ul>
</li>
</ul>
<h2 id="9-1-操作符offset"><a href="#9-1-操作符offset" class="headerlink" title="9.1 操作符offset"></a>9.1 操作符offset</h2><ul>
<li>offset是伪指令，由编译器处理，它的功能是取得标号的偏移地址。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">  </span><br><span class="line">  start:mov ax,offset start;相当于 mov ax,偏移地址0，段地址是从0开始</span><br><span class="line">      s:mov ax,offset s;相当于 mov ax,3，标记的是代码段中的第二条指令，第一条指令长度为3个字节，则s的偏移地址为3</span><br><span class="line">  </span><br><span class="line">codesg ends</span><br><span class="line">end start12345678</span><br></pre></td></tr></table></figure>

<h2 id="9-2-jmp指令"><a href="#9-2-jmp指令" class="headerlink" title="9.2 jmp指令"></a>9.2 jmp指令</h2><ul>
<li><strong>jmp为无条件转移，可以只修改IP，也可以同时修改CS和IP。</strong></li>
<li>jmp需要两种信息<ul>
<li>1、转移的目的地址；</li>
<li>2、转移的距离(段间转移、段内转移、段内近转移)。</li>
</ul>
</li>
</ul>
<h2 id="9-3-依据位移进行转移的jmp指令"><a href="#9-3-依据位移进行转移的jmp指令" class="headerlink" title="9.3 依据位移进行转移的jmp指令"></a>9.3 依据位移进行转移的jmp指令</h2><ul>
<li>段内短转移，<strong>jmp short 标号</strong> ，对IP的修改范围是-128~127，一个字节的空间，即向前转移最多128字节，向后最多127字节。short 表明指令进行的是短转移，标号指明了指令要转移的目的地，转移指令结束后<strong>CS:IP指向标号处的指令</strong>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">  </span><br><span class="line">  start:mov ax,0</span><br><span class="line">      jmp short s</span><br><span class="line">      add ax,1</span><br><span class="line">      s:inc ax</span><br><span class="line">  </span><br><span class="line">codesg ends</span><br><span class="line">end start12345678910</span><br></pre></td></tr></table></figure>

<ul>
<li>一般汇编指令中的立即数(idata)会出现在对应的机器指令中。而jmp指令的机器指令并不包含目的地址，包含的是相对于当前IP的转移位移，CPU并不需要目的地址就可以实现对IP的修改。<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516195028618.png" alt="92debug_1"></li>
<li>CPU执行指令的过程 在 2.10 CS和IP</li>
<li>jmp short s 指令的读取和执行过程：<ul>
<li>1、CS:IP指向jmp short s 的机器码；</li>
<li>2、读取指令码进入指令缓冲器</li>
<li>3、 改变IP，(IP)=(IP)+所读取指令的长度，IP指向下一个指令；</li>
<li>4、CPU执行指令缓冲器中的指令；</li>
<li>5、执行后CS:IP继续指向下一个指令</li>
</ul>
</li>
<li>jmp short 标号的功能为(IP)=(IP)+8位位移。<ul>
<li>1、8位为=标号处的地址-jmp指令后的第一个字节的地址；</li>
<li>2、short 指明此处的位移为8位；</li>
<li>3、8位位移的范围为-128~127，用补码表示。</li>
<li>4、8位位移由编译程序在编译时算出的。</li>
</ul>
</li>
<li>jmp near ptr 标号 指令实现段内近转移，功能为(IP)=(IP)+16位位移。<ul>
<li>1、16位为=标号处的地址-jmp指令后的第一个字节的地址；</li>
<li>2、nearptr 指明此处的位移为16位；</li>
<li>3、16位位移的范围为-32769~32767，用补码表示。</li>
<li>4、16位位移由编译程序在编译时算出的。</li>
</ul>
</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516195158771.png" alt="转移位移的计算方法"></p>
<h2 id="9-4-转移的目的地址在指令中的jmp指令"><a href="#9-4-转移的目的地址在指令中的jmp指令" class="headerlink" title="9.4 转移的目的地址在指令中的jmp指令"></a>9.4 转移的目的地址在指令中的jmp指令</h2><ul>
<li><strong>jmp far ptr 段间转移，又称为远转移</strong></li>
<li>jmp far ptr 标号的功能：<ul>
<li>(CS)=标号所在段的段地址；</li>
<li>(IP)=标号所在段总的偏移地址；</li>
<li>far ptr 指明了指令用标号的段地址和偏移地址修改CS和IP。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">  start:mov ax,0</span><br><span class="line">      mov bx,0</span><br><span class="line">      jmp far ptr s</span><br><span class="line">      db 256 dup(0)</span><br><span class="line">    s:add ax,1</span><br><span class="line">        inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start12345678910</span><br></pre></td></tr></table></figure>

<ul>
<li>机器码中包含了转移的目的地址。</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516195225072.png" alt="94debug"></p>
<h2 id="附注3-汇编编译器-masm-exe-对jmp的相关处理"><a href="#附注3-汇编编译器-masm-exe-对jmp的相关处理" class="headerlink" title="附注3 汇编编译器(masm.exe)对jmp的相关处理"></a>附注3 汇编编译器(masm.exe)对jmp的相关处理</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516195935453.png" alt="这里写图片描述"></p>
<h2 id="9-5-转移地址在寄存器中的jmp指令"><a href="#9-5-转移地址在寄存器中的jmp指令" class="headerlink" title="9.5 转移地址在寄存器中的jmp指令"></a>9.5 转移地址在寄存器中的jmp指令</h2><ul>
<li>jmp 16位寄存器，功能是16位寄存器赋值给IP，实现段内的近(短)转移。</li>
<li>参考 2.11 修改CS、IP的指令</li>
</ul>
<h2 id="9-6-转移地址在内存中的jmp指令"><a href="#9-6-转移地址在内存中的jmp指令" class="headerlink" title="9.6 转移地址在内存中的jmp指令"></a>9.6 转移地址在内存中的jmp指令</h2><ul>
<li><p>转移地址在内存中的jmp指令有两种格式：</p>
<ul>
<li><p><strong>1、jmp word ptr内存单元地址(16位只能实现段内转移)。</strong> 功能是从内存单元地址处开始存放一个字(转移的目的偏移地址)，内存单元地址可用寻址方式的格式给出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">jmp word ptr ds:[0]</span><br><span class="line">;相当于 jmp ax，执行后(IP)&#x3D;0123h</span><br><span class="line">      </span><br><span class="line">mov ax,0123H</span><br><span class="line">mov [bx],ax</span><br><span class="line">jmp word ptr [bx]</span><br><span class="line">;执行后(IP)&#x3D;0123h123456789</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>2、jmp dword ptr 内存单元地址(段间转移)。</strong> 功能：从内存单元地址处开始存放两个字型数据，高地址是转移的目的段地址，低地址处是转移的目的偏移地址。(CS)=(内存单元地址+2),(IP)=(内存单元地址)，内存单元地址可用寻址方式的任一格式给出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0]</span><br><span class="line">      </span><br><span class="line">mov ax,0123H</span><br><span class="line">mov [dx],ax</span><br><span class="line">mov word ptr [bx+2],0</span><br><span class="line">jmp dword ptr [bx]</span><br><span class="line">      </span><br><span class="line">;执行后 (CS)&#x3D;0,(IP)&#x3D;0123H CS:IP指向0000:01231234567891011</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="检测点-9-1"><a href="#检测点-9-1" class="headerlink" title="检测点 9.1"></a>检测点 9.1</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516200035483.png" alt="检测点 9.1"></p>
<h2 id="9-7-jcxz指令"><a href="#9-7-jcxz指令" class="headerlink" title="9.7 jcxz指令"></a>9.7 jcxz指令</h2><ul>
<li>指令格式为jcxz 标号，如果cx的值为0，则转移到标号处执行，不为0则向下执行。<ul>
<li>当cx的值为0时，(IP)=(IP)+8位位移，8位位移=标号处的地址-jcxz指令后的第一个字节的地址。</li>
<li>8位位移的范围是-128~127，用补码表。</li>
<li>8位位移由编译器在编译时算出。</li>
</ul>
</li>
<li><strong>jcxz指令是有条件转移指令，所有的条件转移指令都是短指令，在对应的机器码中包含转移的位移而不包含目的地址，对IP的修改范围都为-128-127。</strong></li>
</ul>
<h2 id="检测点-9-2"><a href="#检测点-9-2" class="headerlink" title="检测点 9.2"></a>检测点 9.2</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516200530657.png" alt="检测点9.2_1"></p>
<h2 id="9-8-loop指令"><a href="#9-8-loop指令" class="headerlink" title="9.8 loop指令"></a>9.8 loop指令</h2><ul>
<li><p>loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移而不包含目的地址。</p>
<p>操作i：</p>
<ul>
<li><strong>cx先自减1；</strong></li>
<li><strong>当cx的值不为0时，(IP)=(IP)+8位位移，8位位移=标号处的地址-loop指令后的第一个字节的地址。</strong></li>
<li>8位位移的范围是-128~127，用补码表。</li>
<li>8位位移由编译器在编译时算出。</li>
</ul>
</li>
</ul>
<h2 id="检测点-9-3"><a href="#检测点-9-3" class="headerlink" title="检测点 9.3"></a>检测点 9.3</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170529230442772.png" alt="检测点 9.3"></p>
<h2 id="9-9-根据位移进行转移的意义"><a href="#9-9-根据位移进行转移的意义" class="headerlink" title="9.9 根据位移进行转移的意义"></a>9.9 根据位移进行转移的意义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jmp short 标号</span><br><span class="line">jmp near ptr 标号</span><br><span class="line">jcxz 标号</span><br><span class="line">loop 标号1234</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>它们对IP的修改时根据转移目的地址和转移起始地址自检的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是目的地址的位移距离。方便了程序段在内存中的浮动分配，没有固定目的地址的限制，更灵活。</strong></li>
</ul>
<h2 id="9-10-编译器对转移位移超界的检测"><a href="#9-10-编译器对转移位移超界的检测" class="headerlink" title="9.10 编译器对转移位移超界的检测"></a>9.10 编译器对转移位移超界的检测</h2><ul>
<li>根据位移进行转移的指令，它们的转移范围受到了转移位移的限制，如果在源程序中出现了转移范围超界的问题，在编译时编译器会报错。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:  jmp short s</span><br><span class="line">          db 128 dup(0)</span><br><span class="line">          s:mov ax,0FFFFH</span><br><span class="line">    code ends</span><br><span class="line">end start12345678</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516201316988.png" alt="910err"></p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516201335895.png" alt="910err2"></p>
<h1 id="实验8"><a href="#实验8" class="headerlink" title="实验8"></a>实验8</h1><ul>
<li>实验八可以正常退出<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516201508975.png" alt="test8"></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line"></span><br><span class="line">      start:mov ax,0</span><br><span class="line">          s:nop</span><br><span class="line">            nop;nop占用两个字节，不执行任何操作</span><br><span class="line"></span><br><span class="line">            mov di,offset s</span><br><span class="line">            mov si,offset s2</span><br><span class="line">            mov ax,cs:[si];jmp short s1的机器码给了ax</span><br><span class="line">            mov cs:[di],ax;覆盖到指令 s:nop nop那</span><br><span class="line"></span><br><span class="line">         s0:jmp short s;s那已经被jmp short s1机器码覆盖</span><br><span class="line">         s1:mov ax,0</span><br><span class="line">            int 21h</span><br><span class="line">            mov ax,0</span><br><span class="line">         s2:jmp short s1;jmp -8h，向上跳到s1，s1又向上跳-10字节</span><br><span class="line">            nop</span><br><span class="line">codesg ends</span><br><span class="line">end start   12345678910111213141516171819202122</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516201621398.png" alt="test8debug"></p>
<h1 id="实验9"><a href="#实验9" class="headerlink" title="实验9"></a>实验9</h1><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516201820025.png" alt="实验9"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">            db&#39;welcome to masm!&#39;;定义要显示的字符串(共16字节)</span><br><span class="line">            db 02H,24H,71H;定义字符的属性</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">            dw 8 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">    start:</span><br><span class="line">            mov ax,data</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov ax,stack</span><br><span class="line">            mov ss,ax</span><br><span class="line">            mov sp,10H</span><br><span class="line"></span><br><span class="line">            xor bx,bx;bx清零，用来索引颜色</span><br><span class="line">            mov ax,0b872H;算出屏幕第12行中间的显存的段起始位置放入ax中</span><br><span class="line"></span><br><span class="line">            mov cx,3;s3循环控制行数，要显示三个字符串外循环为3次</span><br><span class="line">        s3: push cx;三个进栈操作为外循环s3保存相关寄存器的值</span><br><span class="line">            push ax;以防止它们的值在内循环中被破坏</span><br><span class="line">            push bx</span><br><span class="line"></span><br><span class="line">            mov es,ax;此时es为屏幕第12行中间的显存的段起始位置</span><br><span class="line"></span><br><span class="line">            mov si,0;si用来索引代码列的字符</span><br><span class="line">            mov di,0;di用来定位目标列</span><br><span class="line"></span><br><span class="line">            mov cx,10H</span><br><span class="line">            ;s1循环控制存放的字符，一个字符串中含有10H个字节内循环为10H次</span><br><span class="line">        s1: mov al,ds:[si]</span><br><span class="line">            mov es:[di],al</span><br><span class="line">            inc si</span><br><span class="line">            add id,2</span><br><span class="line">            loop s1;吃循环实现偶地址中存放字符</span><br><span class="line"></span><br><span class="line">            mov di,1;设置di的值为1，为在显存奇数地址中存放字符的颜色属性做准备</span><br><span class="line">            pop bx</span><br><span class="line">            mov al.ds:[bx+10H];取消颜色属性</span><br><span class="line">            inc bx</span><br><span class="line"></span><br><span class="line">            mov cx,10H;第二个内循环也为10H</span><br><span class="line">        s2: mov es:[di],al</span><br><span class="line">            add di 2</span><br><span class="line">            loop s2;此循环实现奇数地址存放字符的颜色属性</span><br><span class="line"></span><br><span class="line">            ;以下4句为下一趟外循环做准备</span><br><span class="line">            pop ax</span><br><span class="line">            add ax,0AH;将显存的段地址起始地址设置为当前行的下一行</span><br><span class="line">                      ;[在段地址中甲0aH，相当于在偏移地址中加了0a0h(&#x3D;160d)]</span><br><span class="line">            pop cx</span><br><span class="line">            loop s3</span><br><span class="line"></span><br><span class="line">            mov ax，4C00H</span><br><span class="line">            int 21H</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263</span><br></pre></td></tr></table></figure>

<ul>
<li>welcome to masm</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516201938980.png" alt="welcome to masm"></p>
<h1 id="十、CALL和RET指令"><a href="#十、CALL和RET指令" class="headerlink" title="十、CALL和RET指令"></a>十、CALL和RET指令</h1><h2 id="引言-6"><a href="#引言-6" class="headerlink" title="引言"></a>引言</h2><ul>
<li>回想程序之间的加载返回过程。</li>
<li>call和ret指令都是转移指令，它们都修改IP或者同时修改CS和IP，经常被共用来实现程序的设计。</li>
<li>这一章讲解call和ret指令的原理。</li>
</ul>
<h2 id="10-1-ret和retf指令"><a href="#10-1-ret和retf指令" class="headerlink" title="10.1 ret和retf指令"></a>10.1 ret和retf指令</h2><ul>
<li><strong>ret指令用栈中的数据来修改IP的内容，从而实现近转移。</strong></li>
<li>CPU执行ret指令时：<ul>
<li>1、(IP)=((SS)*16+(SP))，指向栈顶</li>
<li>2、(SP)=(SP)+2</li>
</ul>
</li>
<li><strong>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。</strong></li>
<li>CPU执行retf指令时，进行下面两步操作：<ul>
<li>1、(IP)=((SS)*16+(SP))</li>
<li>2、(SP)=(SP)+2</li>
<li>3、(CS)=((SS)*16+(SP))</li>
<li>4、(SP)=(SP)+2</li>
</ul>
</li>
<li>用汇编的语法来解释ret和retf指令：<ul>
<li>CPU执行ret指令相当于进行 POP IP</li>
<li>CPU执行retf指令相当于进行 POP IP和POP CS</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line"> stack segment</span><br><span class="line">              db 16 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">          codesg segment</span><br><span class="line">              mov ax,4c00h</span><br><span class="line">              int 21h</span><br><span class="line"></span><br><span class="line">          start:</span><br><span class="line">              mov ax,stack</span><br><span class="line">              mov ss,ax</span><br><span class="line">              mov sp,16</span><br><span class="line">              mov ax,0</span><br><span class="line"></span><br><span class="line">              push ax</span><br><span class="line"></span><br><span class="line">              mov bx,0</span><br><span class="line">              ret</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start1234567891011121314151617181920212223</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516202038274.png" alt="1012debug_1"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">        db 16 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">    start:</span><br><span class="line">        mov ax,stack</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,16</span><br><span class="line">        mov ax,0</span><br><span class="line">        push cs</span><br><span class="line">        push ax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        mov bx,0</span><br><span class="line">        retf</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start123456789101112131415161718192021222324</span><br></pre></td></tr></table></figure>

<h2 id="检测点-10-1"><a href="#检测点-10-1" class="headerlink" title="检测点 10.1"></a>检测点 10.1</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516202241000.png" alt="检测点10.1"></p>
<h2 id="10-2-call指令"><a href="#10-2-call指令" class="headerlink" title="10.2 call指令"></a>10.2 call指令</h2><ul>
<li>call指令经常跟ret指令配合使用，CPU执行call指令时：<ul>
<li><strong>1、将当前的IP或者CS和IP压入栈；</strong></li>
<li><strong>2、转移(jmp)。</strong></li>
</ul>
</li>
<li>call指令除了不能实现短转移之外，call指令实现转移的方法和jmp指令的原理相同。call指令实现段间的转移(远转移)或近转移。</li>
</ul>
<h2 id="10-3-依据位移进行转移的call指令"><a href="#10-3-依据位移进行转移的call指令" class="headerlink" title="10.3 依据位移进行转移的call指令"></a>10.3 依据位移进行转移的call指令</h2><ul>
<li>call标号(将当前的IP压入栈后转到目标处执行指令)，执行时进行以下操作：<ul>
<li>1、(SP)=(SP)-2<br>((SS)*16+(SP))=(IP)</li>
<li>2、(IP)=(IP)+16位位移；</li>
<li>3、16位位移=标号处的地址减去call指令后的第一个字节的地址。16位位移的范围是-32768~32767，用补码表示。16位位移由编译器编译时算出。</li>
</ul>
</li>
<li>用汇编语法解释call指令：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp near 标号12</span><br></pre></td></tr></table></figure>

<h2 id="检测点-10-2"><a href="#检测点-10-2" class="headerlink" title="检测点 10.2"></a>检测点 10.2</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516202326635.png" alt="检测点10.2"></p>
<h2 id="10-4-转移的目的地址在指令中的call指令"><a href="#10-4-转移的目的地址在指令中的call指令" class="headerlink" title="10.4 转移的目的地址在指令中的call指令"></a>10.4 转移的目的地址在指令中的call指令</h2><ul>
<li>call far ptr 标号 实现的是段间转移，执行时：<ul>
<li>1、CS先自减2；</li>
<li>2、CS的值等于SS的值乘以16加上SP的值，SP自减2，IP的值等于SS的值*16加上SP的值；</li>
<li>3、CS的值等于标号所在的段地址，IP的值等于标号所在的偏移地址.</li>
</ul>
</li>
<li>用汇编语法解释call指令：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp far ptr 标号123</span><br></pre></td></tr></table></figure>

<h2 id="检测点-10-3"><a href="#检测点-10-3" class="headerlink" title="检测点 10.3"></a>检测点 10.3</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516202411776.png" alt="检测点 10.3"></p>
<h2 id="10-5-转移地址在寄存器中的call指令"><a href="#10-5-转移地址在寄存器中的call指令" class="headerlink" title="10.5 转移地址在寄存器中的call指令"></a>10.5 转移地址在寄存器中的call指令</h2><ul>
<li>指令格式是：call 16位寄存器，功能是：<ul>
<li>1、SP的值先自减2；</li>
<li>2、IP的值SS的值乘以16再加上SP的值；</li>
<li>3、 IP的值等于16位寄存器的内容。</li>
</ul>
</li>
<li>用汇编语法解释此种call指令，CPU执行call 16位reg时，相当于：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp 16位寄存器12</span><br></pre></td></tr></table></figure>

<h2 id="检测点-10-4"><a href="#检测点-10-4" class="headerlink" title="检测点 10.4"></a>检测点 10.4</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516202448666.png" alt="检测点 10.4"></p>
<h2 id="10-6-转移地址在内存中的call指令"><a href="#10-6-转移地址在内存中的call指令" class="headerlink" title="10.6 转移地址在内存中的call指令"></a>10.6 转移地址在内存中的call指令</h2><ul>
<li>转移地址在内存中的call指令有两种格式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call word ptr 内存单元地址;段内跳转</span><br><span class="line">call dword ptr 内存单元地址;段间跳转12</span><br></pre></td></tr></table></figure>

<ul>
<li>用汇编语法解释call word ptr 内存单元地址</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp word ptr 内存单元地址12</span><br></pre></td></tr></table></figure>

<ul>
<li>例子：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">call word ptr ds:[0]</span><br><span class="line">;执行后IP的值等于0123H，SP的值等于0EH12345</span><br></pre></td></tr></table></figure>

<ul>
<li>用汇编语法解释call dword ptr 内存单元地址</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp word ptr 内存单元地址123</span><br></pre></td></tr></table></figure>

<ul>
<li>例子：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[0],0</span><br><span class="line">call dword ptr ds:[0]</span><br><span class="line">;执行后IP的值等于0123H，SP的值等于0CH，CS的值等于0123456</span><br></pre></td></tr></table></figure>

<h2 id="检测点-10-5"><a href="#检测点-10-5" class="headerlink" title="检测点 10.5"></a>检测点 10.5</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516202513426.png" alt="检测点10.5"></p>
<h2 id="10-7-call和ret的配合使用"><a href="#10-7-call和ret的配合使用" class="headerlink" title="10.7 call和ret的配合使用"></a>10.7 call和ret的配合使用</h2><ul>
<li>下面的程序返回前，bx中的值是多少？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">      start:</span><br><span class="line">            mov ax,1</span><br><span class="line">            mov cx,3</span><br><span class="line">            call s</span><br><span class="line">            mov bx,ax</span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">          s:</span><br><span class="line">            add ax,ax</span><br><span class="line">            loop s</span><br><span class="line">            ret</span><br><span class="line">code ends</span><br><span class="line">end start123456789101112131415</span><br></pre></td></tr></table></figure>

<ul>
<li>具有一定功能的程序段称为子程序，<strong>用call转去执行，在子程序后面使用ret实现返回。</strong></li>
<li>具有子程序的源程序的框架如下</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170516202547067.png" alt="107call"></p>
<h2 id="10-8-mull指令"><a href="#10-8-mull指令" class="headerlink" title="10.8 mull指令"></a>10.8 mull指令</h2><ul>
<li><p>mull指令时乘法指令，</p>
<p>相乘的两个数要么都是8位的，要么都是16位的</p>
<ul>
<li>8位：在AL中和8位寄存器中或内存字节单元中；</li>
<li>16位：在AX中和16位寄存器或内存字单元中。</li>
<li>结果<ul>
<li>8位的存放在AX中；</li>
<li>16位：DX(高位)和AX(低位)中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mull reg</span><br><span class="line"></span><br><span class="line">mull 内存单元</span><br><span class="line">mull byte ptr ds:[0]</span><br><span class="line"></span><br><span class="line">mull word ptr [bx+si+idata]</span><br><span class="line">;(ax)&#x3D;(ax)*((ds)*16+(bx)+(si)+idata)</span><br><span class="line">;(dx)&#x3D;(ax)*((ds)*16+(bx)+(si)+idata)12345678</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">;计算100*10，两个数都小于255，可以做8位乘法</span><br><span class="line">mov ax,100</span><br><span class="line">mov bx,10</span><br><span class="line">mull bl</span><br><span class="line">;结果(ax)&#x3D;1000(03E8H)</span><br><span class="line"></span><br><span class="line">;计算100*1000，1000都大于255，要做16位乘法</span><br><span class="line">mov ax,100;高位自动补零</span><br><span class="line">mov bx,10000</span><br><span class="line">mull bx</span><br><span class="line">;结果(ax)&#x3D;4240H，(dx)&#x3D;000FH，F4240H&#x3D;10000001234567891011</span><br></pre></td></tr></table></figure>

<h2 id="10-9-模块化程序设计"><a href="#10-9-模块化程序设计" class="headerlink" title="10.9 模块化程序设计"></a>10.9 模块化程序设计</h2><ul>
<li>cal和ret指令共同支持汇编语言编程中的模块化设计。</li>
</ul>
<h2 id="10-10-参数和结果传递的问题"><a href="#10-10-参数和结果传递的问题" class="headerlink" title="10.10 参数和结果传递的问题"></a>10.10 参数和结果传递的问题</h2><ul>
<li>用寄存器来存储参数和结果是最常用的方法。对于存放参数的寄存器和存放结果的寄存器，调用者和子程序的读写操作恰恰相反：<ul>
<li>调用者将参数送入参数寄存器，从结果寄存器中取到返回值；</li>
<li>子程序 从参数寄存器中取到参数，将返回值送入结果寄存器。</li>
</ul>
</li>
<li>编程：根据提供的N来计算N^3</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cube:mov ax,bx</span><br><span class="line">               mul bx</span><br><span class="line">               mul bx</span><br><span class="line">               ret1234</span><br></pre></td></tr></table></figure>

<ul>
<li>编程：计算data段中第一组数据的3次方，结果保存在后面一组dword单元中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">          dw 1,2,3,4,5,6,7,8</span><br><span class="line">          dd 8 dup (0)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">          start:</span><br><span class="line">              mov ax,data</span><br><span class="line">              mov ds,ax</span><br><span class="line">              mov si,0;ds:si指向第一组word单元</span><br><span class="line">              mov di,16;ds:di指向第二组dword单元</span><br><span class="line"></span><br><span class="line">              mov cx,8</span><br><span class="line">          s:  mov bx,[si]</span><br><span class="line">              call cube</span><br><span class="line">              mov [di],ax</span><br><span class="line">              mov [di+2],dx</span><br><span class="line">              add si,2;ds:di指向下一个word单元</span><br><span class="line">              add di,4;ds:di指向下一个dword单元</span><br><span class="line">              loop s</span><br><span class="line"></span><br><span class="line">              mov ax,4c00h</span><br><span class="line">              int 21h</span><br><span class="line"></span><br><span class="line">             cube:mov ax,bx</span><br><span class="line">              mul bx</span><br><span class="line">              mul bx</span><br><span class="line">              ret</span><br><span class="line">code ends</span><br><span class="line">end start1234567891011121314151617181920212223242526272829303132</span><br></pre></td></tr></table></figure>

<h2 id="10-11-批量数据的传递"><a href="#10-11-批量数据的传递" class="headerlink" title="10.11 批量数据的传递"></a>10.11 批量数据的传递</h2><ul>
<li>将批量数据放在内存中，然后将他们呢所在内存空间的首地址放在寄存器中，传递给需要的子程序，批量数据的返回结果也是采用同样的方法。除此之外还可以用栈来传递参数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db&#39;conversation&#39;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">    start:</span><br><span class="line">        mov ax,data</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,0;ds:si指向字符串(批量数据)所在空间的首地址</span><br><span class="line"></span><br><span class="line">        mov cx,12;cx存放字符串的长度</span><br><span class="line">        call capital</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">    capital:</span><br><span class="line">        add byte ptr [si],11011111B</span><br><span class="line">        inc si</span><br><span class="line">        loop capital</span><br><span class="line">        ret</span><br><span class="line">code ends1234567891011121314151617181920212223</span><br></pre></td></tr></table></figure>

<h2 id="10-12-寄存器冲突的问题"><a href="#10-12-寄存器冲突的问题" class="headerlink" title="10.12 寄存器冲突的问题"></a>10.12 寄存器冲突的问题</h2><ul>
<li>编程：将一个全是字母，以0结尾的字符串转化为大写</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">capital:</span><br><span class="line">    mov cl,[si];低8位</span><br><span class="line">    mov ch,0;高8位设置为0</span><br><span class="line">    jcxz ok;如果(cx)&#x3D;0则结束，如果不是0则处理</span><br><span class="line">    and byte ptr [si],11011111B</span><br><span class="line">    inc si</span><br><span class="line">    jmp short capital</span><br><span class="line">ok:</span><br><span class="line">    ret123456789</span><br></pre></td></tr></table></figure>

<ul>
<li>编程将data段中的字符串全部转化为大写</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">db&#39;word&#39;,0</span><br><span class="line">db&#39;unix&#39;,0</span><br><span class="line">db&#39;wind&#39;,0</span><br><span class="line">db&#39;good&#39;,0</span><br><span class="line">data ends1234567</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">;此程序有bug，cx有问题</span><br><span class="line">assume cs:code</span><br><span class="line">  </span><br><span class="line">data segment</span><br><span class="line">db&#39;word&#39;,0</span><br><span class="line">db&#39;unix&#39;,0</span><br><span class="line">db&#39;wind&#39;,0</span><br><span class="line">db&#39;good&#39;,0</span><br><span class="line">data ends</span><br><span class="line">  </span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">        mov ax,data</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov bx,0</span><br><span class="line">  </span><br><span class="line">        mov cx,4</span><br><span class="line">    s:</span><br><span class="line">        mov si,bx</span><br><span class="line">        call capital</span><br><span class="line">        add bx,5</span><br><span class="line">        loop s</span><br><span class="line">  </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">  </span><br><span class="line">capital:</span><br><span class="line">        mov cl,[si]</span><br><span class="line">        mov ch,0</span><br><span class="line">        jcxz ok</span><br><span class="line">        and byte ptr [si],11011111b</span><br><span class="line">        inc si</span><br><span class="line">        jmp short capital</span><br><span class="line">    ok:</span><br><span class="line">        ret</span><br><span class="line">  </span><br><span class="line">code ends</span><br><span class="line">end start1234567891011121314151617181920212223242526272829303132333435363738</span><br></pre></td></tr></table></figure>

<h1 id="实验十"><a href="#实验十" class="headerlink" title="实验十"></a>实验十</h1><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522073406637.jfif" alt="test10_1_1"><br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522073441450.jfif" alt="test10_1_2"><br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522073505403.jfif" alt="test10_1_3"></p>
<ul>
<li>实验10.1 显示字符串</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db &#39;welcome to masm!&#39;,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    start:</span><br><span class="line">            mov dh,8;行号</span><br><span class="line">            mov dl,3;列号</span><br><span class="line">            mov cl,2;颜色属性</span><br><span class="line">            mov ax,data</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov si,0</span><br><span class="line">            call show_str</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">        show_str:;子程序</span><br><span class="line">            push cx</span><br><span class="line">            push si</span><br><span class="line"></span><br><span class="line">            mov al,0A0h;每行有80*2&#x3D;160个字节&#x3D;0a0h</span><br><span class="line">            dec dh;行号在显存中下标从0开始，所以减1</span><br><span class="line">            mul dh;相当于从第(n-1)*0a0h个byte单元开始</span><br><span class="line"></span><br><span class="line">            mov bx,ax;定位好的位置偏移地址存放在bx里(行)</span><br><span class="line"></span><br><span class="line">            mov al,2;每个字符占2个字节</span><br><span class="line">            mul dl;定位列，结果ax存放的是定位好的列的位置</span><br><span class="line">            sub ax,2;列号在显存中下标从0开始，又因为是偶字节存放字符，所以减2</span><br><span class="line"></span><br><span class="line">            add bx,ax;此时bx中存放的是行与列的偏移地址</span><br><span class="line"></span><br><span class="line">            mov ax,0B800h;显存开始的地方</span><br><span class="line">            mov es,ax;es中存放的是显存的第0页的起始地段地址</span><br><span class="line"></span><br><span class="line">            mov di,0;di指向显存的偏移地址，确定指向下一个要处理的字符的位置</span><br><span class="line">            mov al,cl;cl存放颜色参数，下边cl要用来临时存放要处理的字符</span><br><span class="line">            mov ch,0;下边cx存放的是每次准备处理的字符</span><br><span class="line">        s:</span><br><span class="line">            mov cl,ds:[si];指向&#39;welcome to masm &#39;,0</span><br><span class="line"></span><br><span class="line">            jcxz ok;cl为0时跳转</span><br><span class="line">            mov es:[bx+di],cl;偶地址存放字符</span><br><span class="line">            mov es:[bx+di+1],al;奇地址存放字符的颜色属性</span><br><span class="line">            inc si</span><br><span class="line">            add di,2;指向了下个字符</span><br><span class="line">            jmp short s ;无条件跳转，jcxz是离开的关键跳</span><br><span class="line"></span><br><span class="line">        ok:</span><br><span class="line">            pop si</span><br><span class="line">            pop cx</span><br><span class="line">            ret;定义结束</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522075507746.png" alt="test101"></p>
<ul>
<li>实验10.2</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ss:stack</span><br><span class="line">  </span><br><span class="line">stack segment</span><br><span class="line">dw 8 dup(0)</span><br><span class="line">stack ends</span><br><span class="line">  </span><br><span class="line">code segment</span><br><span class="line">  </span><br><span class="line">start:</span><br><span class="line">        mov ax,stack</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,10h</span><br><span class="line">        mov ax,4240h</span><br><span class="line">        mov dx,0fh</span><br><span class="line">        mov xx,0ah</span><br><span class="line">  </span><br><span class="line">        call divdw</span><br><span class="line">  </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">  </span><br><span class="line">    divdw:</span><br><span class="line">        push ax;低16位先保存</span><br><span class="line">        mov ax,dx;ax这时是高16位了</span><br><span class="line">        mov dx,0;为了不影响余数位和高位数</span><br><span class="line">        div cx</span><br><span class="line">        mov bx,ax</span><br><span class="line">        pop ax</span><br><span class="line">        div cx</span><br><span class="line">        mov cx,dx</span><br><span class="line">        mov dx,dx</span><br><span class="line">        ret</span><br><span class="line">code ends</span><br><span class="line">end start12345678910111213141516171819202122232425262728293031323334</span><br></pre></td></tr></table></figure>

<ul>
<li>实验10.3</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db 10 dup(0)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,12666</span><br><span class="line">            mov bx,data;指向字符串的首地址</span><br><span class="line">            mov ds,bx</span><br><span class="line">            mov si,0</span><br><span class="line"></span><br><span class="line">            call dtoc;实现将word型整数转化为字符串并存储</span><br><span class="line"></span><br><span class="line">            mov dh,8;打印初始化</span><br><span class="line">            mov dl,3</span><br><span class="line">            mov cl,0cah</span><br><span class="line"></span><br><span class="line">            call show_str;开始打印字符串</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">        dtoc:</span><br><span class="line">            push dx</span><br><span class="line">            push cx</span><br><span class="line">            push ax</span><br><span class="line">            push si</span><br><span class="line"></span><br><span class="line">            mov bx,0;bx在子程序中用来存放位数，用栈来临时存放修改后的字符</span><br><span class="line">        s1:</span><br><span class="line">            mov cx,10d;d表示十进制，cx准备被除，用取余法来取出数字</span><br><span class="line">            mov dx,0</span><br><span class="line"></span><br><span class="line">            div cx;除以十</span><br><span class="line">            mov cx,ax;得到的商复制给cx，要利用jcxz</span><br><span class="line">            jcxz s2;当商为0则跳到s2</span><br><span class="line">            add dx,30h;余数加上30h得到相应的ascii码</span><br><span class="line">            push dx</span><br><span class="line">            inc bx</span><br><span class="line"></span><br><span class="line">            jmp short s1</span><br><span class="line">        s2：</span><br><span class="line">            add ax,30h;当商为0的时候，余数为个位</span><br><span class="line">            push dx</span><br><span class="line"></span><br><span class="line">            inc bx;再进行一次栈操作(补充当商为零而余数不为零时的情况)</span><br><span class="line">            mov cx,bx;总共有bx位进栈，所以循环次数为bx</span><br><span class="line">            mov si,0</span><br><span class="line">        s3:</span><br><span class="line">            pop ax;s3实现将栈中的数据依次出栈放到指定的内存中</span><br><span class="line">            mov [si],al</span><br><span class="line">            inc si</span><br><span class="line">            loop s3</span><br><span class="line"></span><br><span class="line">        okay:</span><br><span class="line">            pop bx</span><br><span class="line">            pop si</span><br><span class="line">            pop ax</span><br><span class="line">            pop dx</span><br><span class="line"></span><br><span class="line">            ret</span><br><span class="line">        show_str:;子程序</span><br><span class="line">            push bx</span><br><span class="line">            push cx</span><br><span class="line">            push si</span><br><span class="line"></span><br><span class="line">            mov al,0A0h;每行有80*2&#x3D;160个字节&#x3D;0a0h</span><br><span class="line">            dec dh;行号在显存中下标从0开始，所以减1</span><br><span class="line">            mul dh;相当于从第(n-1)*0a0h个byte单元开始</span><br><span class="line"></span><br><span class="line">            mov bx,ax;定位好的位置偏移地址存放在bx里(行)</span><br><span class="line">            mov al,2;每个字符占2个字节</span><br><span class="line">            mul dl;定位列，结果ax存放的是定位好的列的位置</span><br><span class="line"></span><br><span class="line">            sub ax,2;列号在显存中下标从0开始，又因为是偶字节存放字符，所以减2</span><br><span class="line">            add bx,ax;此时bx中存放的是行与列的偏移地址</span><br><span class="line"></span><br><span class="line">            mov ax,0B800h;显存开始的地方</span><br><span class="line">            mov es,ax;es中存放的是显存的第0页的起始地段地址</span><br><span class="line"></span><br><span class="line">            mov di,0;di指向显存的偏移地址，确定指向下一个要处理的字符的位置</span><br><span class="line">            mov al,cl;cl存放颜色参数，下边cl要用来临时存放要处理的字符</span><br><span class="line">            mov ch,0;下边cx存放的是每次准备处理的字符</span><br><span class="line">        S:</span><br><span class="line">            mov cl,ds:[si]</span><br><span class="line"></span><br><span class="line">            jcxz ok</span><br><span class="line"></span><br><span class="line">            mov es:[bx+di],cl</span><br><span class="line">            mov es:[bx+di+i],al</span><br><span class="line"></span><br><span class="line">            inc si</span><br><span class="line">            add di,2</span><br><span class="line"></span><br><span class="line">            jmp short s</span><br><span class="line"></span><br><span class="line">        ok:</span><br><span class="line">            pop si</span><br><span class="line">            pop cx</span><br><span class="line">            pop bx</span><br><span class="line">            ret</span><br><span class="line">code ends</span><br><span class="line">end start123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104</span><br></pre></td></tr></table></figure>

<h1 id="十一、标志寄存器"><a href="#十一、标志寄存器" class="headerlink" title="十一、标志寄存器"></a>十一、标志寄存器</h1><h2 id="引言-7"><a href="#引言-7" class="headerlink" title="引言"></a>引言</h2><ul>
<li>CPU内部的寄存器中有一种特殊的寄存器：<ul>
<li>1、用来存储相关指令的某些执行结果；</li>
<li>2、用来为CPU执行相关指令提供行为依据；</li>
<li>3、用来控制CPU的相关工作方式。</li>
</ul>
</li>
<li>8086 CPU的标志寄存器只有16位，其中存储的信息通常被称为程序状态字(PSW)。</li>
<li>本章中的标志寄存器(以下简称为flag)。某些指令将影响标志寄存器中的多个标志位，这些被影响的标记位比较全面地记录ill指令的执行结果，为相关的处理提供了所需的依据。</li>
<li>flag寄存器是按位起作用的，每一位都有专门的含义，记录特定的信息，与其他寄存器不一样。</li>
<li>8086 CPU的flag寄存器的结构：</li>
</ul>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522075642999.png" alt="flag"></p>
<ul>
<li>flag的1、3、5、12、13、14、15位在8086 CPU中没有使用，而0、2、4、6、7、8、9、10、11位都具有特殊的含义。</li>
</ul>
<h2 id="11-1-ZF-zero-flag-标志"><a href="#11-1-ZF-zero-flag-标志" class="headerlink" title="11.1 ZF(zero flag)标志"></a>11.1 ZF(zero flag)标志</h2><ul>
<li>flag的第6位是ZF，零标志位，它记录相关指令执行后，结果为0，ZF=1(记录下是0这样的肯定信息)，结果不为0，ZF=0(表示结果非0)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1</span><br><span class="line">  </span><br><span class="line">mov ax,1</span><br><span class="line">and ax,0</span><br><span class="line">;指令执行后，结果为0，则ZF&#x3D;1</span><br><span class="line">  </span><br><span class="line">mov ax,2</span><br><span class="line">sub ax,1</span><br><span class="line">  </span><br><span class="line">mov ax,1</span><br><span class="line">or ax,0</span><br><span class="line">;指令执行后，结果为1，则ZF&#x3D;012345678910111213</span><br></pre></td></tr></table></figure>

<ul>
<li>在8086CPU中,add、sub、mul、div、inc、or、and等它们大多都是运算(逻辑运算或是算术运算)指令，是影响标志寄存器的，而mov、push、pop等传送指令对标志寄存器一般没有影响，因为不会产生结果。</li>
</ul>
<h2 id="11-2-PF标志"><a href="#11-2-PF标志" class="headerlink" title="11.2 PF标志"></a>11.2 PF标志</h2><ul>
<li>flag的第2位是PF，奇偶标志位，记录指令执行后结果所有的二进制位中1的个数。为偶数，PF=1，为奇数PF=0</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">add al,10</span><br><span class="line">;执行结果为00001011B，有3个1，则PF&#x3D;0</span><br><span class="line">  </span><br><span class="line">mov al,1</span><br><span class="line">or al,10</span><br><span class="line">;执行后结果为00000011B，有2个1，则PF&#x3D;11234567</span><br></pre></td></tr></table></figure>

<h2 id="11-3-SF-sign-flag-标志"><a href="#11-3-SF-sign-flag-标志" class="headerlink" title="11.3 SF(sign flag)标志"></a>11.3 SF(sign flag)标志</h2><ul>
<li>flag的第7位是SF符号标志位，记录指令执行后结果为负则SF=1，结果为正，SF=0。<strong>弱国我们将数据当作无符号数来运算，SF的值没有意义，虽然相关的指令影响了它的值。</strong></li>
<li>有符号数与补码<ul>
<li>计算机默认把负数用补码记录。</li>
<li>00000001B，可以看作无符号数1，也可以看作符号数+1；</li>
<li>10000001B，可以看作无符号数129，也可以看作有符号数-127。</li>
</ul>
</li>
<li>补码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,10000001B</span><br><span class="line">add al,1</span><br><span class="line">;执行指令后al的值是10000010B，无符号数130，有符号数-126123</span><br></pre></td></tr></table></figure>

<h2 id="检测点-11-1"><a href="#检测点-11-1" class="headerlink" title="检测点 11.1"></a>检测点 11.1</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522075757000.png" alt="检测点11.1"></p>
<h2 id="11-4-CF-carry-flag-标志"><a href="#11-4-CF-carry-flag-标志" class="headerlink" title="11.4 CF(carry flag)标志"></a>11.4 CF(carry flag)标志</h2><ul>
<li>flag的第0位是CF，进位标志位。一般情况下，在进行无符号运算的时候，它记录了运算结果的最高有效位向更高位的进位值或从更高位的借位值。对于位数为N的无符号数，其对应的二进制信息的最高位为N-1位的最高有效位，假想存在第N位。<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522075820704.png" alt="更高位"></li>
<li>两个8位的数据运算可能产生进位或者借位，由于这个进位值在8位数中无法保存，8086CPU就用flag的CF位来记录这个进位值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov al.98h</span><br><span class="line">add al,al;执行后(al)&#x3D;30h，cf&#x3D;1，cf记录了从最高有效位向更高位的进位值</span><br><span class="line">add al,al;执行后(al)&#x3D;60h，cf&#x3D;0，cf记录了从更高有效位向更高位的进位值</span><br><span class="line">  </span><br><span class="line">mov al,97h</span><br><span class="line">sub al,98h;执行后(al)&#x3D;ffh，cf&#x3D;1，cf记录了向更高位的借位值</span><br><span class="line">sub al,al;执行后(al)&#x3D;0，cf&#x3D;0，cf记录了向更高位的借位值1234567</span><br></pre></td></tr></table></figure>

<h2 id="11-5-OF-overflow-flag-标志"><a href="#11-5-OF-overflow-flag-标志" class="headerlink" title="11.5 OF(overflow flag)标志"></a>11.5 OF(overflow flag)标志</h2><ul>
<li>如果运算结果超出了机器所能表达的范围(对于8位有符号数，机器所能表达的范围是-128~127)将产生溢出，对有符号数而言。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line"></span><br><span class="line">    start:</span><br><span class="line">            mov al,01100010b</span><br><span class="line">            add al,01100011b</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">    code ends</span><br><span class="line">end start123456789101112</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522075847336.png" alt="1150f_1"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">  </span><br><span class="line">code segment</span><br><span class="line">  </span><br><span class="line">start:</span><br><span class="line">        mov al,10001000b</span><br><span class="line">        add al,11110000b</span><br><span class="line">  </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start123456789101112</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522080045212.png" alt="115of2"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov al,98h</span><br><span class="line">            add al,al</span><br><span class="line">            add al,al</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">    code ends</span><br><span class="line">end start</span><br><span class="line">12345678910111213</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522080117865.png" alt="CFdebug"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov al,97h</span><br><span class="line">            sub al,98h</span><br><span class="line">            add al,al</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">    code ends</span><br><span class="line">end start</span><br><span class="line">12345678910111213</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522080147556.png" alt="114cf2"></p>
<ul>
<li><strong>CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位；</strong> CPU用CF位来记录无符号数运算是否产生了进位，用OF位来记录有符号数是否产生了溢出。用SF位来记录结果的符号</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,98d</span><br><span class="line">add al,99d</span><br><span class="line">;对于无符号数运算，98+99没有进位，CF&#x3D;0</span><br><span class="line">;对于有符号数运算，98+99发生溢出，OF&#x3D;11234</span><br></pre></td></tr></table></figure>

<h2 id="检测点-11-2"><a href="#检测点-11-2" class="headerlink" title="检测点 11.2"></a>检测点 11.2</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522080219665.png" alt="检测点11.2"></p>
<h2 id="11-6-adc指令"><a href="#11-6-adc指令" class="headerlink" title="11.6 adc指令"></a>11.6 adc指令</h2><ul>
<li><strong>adc是带有进位加法指令，利用了CF位上记录的进位值。格式:adc操作对象1，操作对象2，功能：操作对象1=操作对象1+操作对象2+CF。</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">mov bx,1</span><br><span class="line">sub bx,ax</span><br><span class="line">adx ax,1</span><br><span class="line">;执行后 (ax)&#x3D;4，相当于计算(ax)+1+CF&#x3D;2+1+1+4</span><br><span class="line">  </span><br><span class="line">mov ax,1</span><br><span class="line">add ax,ax</span><br><span class="line">adc ax,3</span><br><span class="line">;执行后(ax)&#x3D;5，相当于执行(ax)+3+CF&#x3D;2+3+0&#x3D;5</span><br><span class="line">  </span><br><span class="line">mov al,98H</span><br><span class="line">add al,al</span><br><span class="line">adx al,3</span><br><span class="line">;执行后 (ax)&#x3D;34H，相当于执行(ax)+3+CF&#x3D;30H+3+1&#x3D;34H123456789101112131415</span><br></pre></td></tr></table></figure>

<ul>
<li>由adc指令前面的指令决定在执行adc指令的时候加上的CF的值的含义，关键在于所加上的CF的值是被什么指令设置的。如果CF的值是被sub指令设置的，那么它的含义就是借位值；如果是被add指令设置的，那么它的含义就是进位值。加法运算先是低位相加，再高位相加加上低位相加产生的进位值。</li>
<li>编程：计算1EF000H+201000H,结果存放在AX(高16位)和BX(低16位)中。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,001EH</span><br><span class="line">mov bx,0F000H</span><br><span class="line">add bx,1000H</span><br><span class="line">adc ax,0020H1234</span><br></pre></td></tr></table></figure>

<ul>
<li>编程：1EF0001000H+2010001EF0H,结果存放在AX(高16位)、BX(次16位)中和cx(低16位)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,001EH</span><br><span class="line">mov bx,0F000H</span><br><span class="line">mov cx,1000H</span><br><span class="line">add cx,1EF0H</span><br><span class="line">add bx,1000H</span><br><span class="line">adc ax,0020H123456</span><br></pre></td></tr></table></figure>

<ul>
<li>编程：对两个128位数据进行相加</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">    data segment</span><br><span class="line">            db 16 dup(88H)</span><br><span class="line">            db 16 dup(11H)</span><br><span class="line">    data ends</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,data</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov si,0</span><br><span class="line">            mov di,16</span><br><span class="line"></span><br><span class="line">            mov cx,8</span><br><span class="line">            call add128</span><br><span class="line"></span><br><span class="line">            mov ax,4C00H</span><br><span class="line">            int 21H</span><br><span class="line">    add128:</span><br><span class="line">            push ax</span><br><span class="line">            push cx</span><br><span class="line">            push si</span><br><span class="line">            push di</span><br><span class="line"></span><br><span class="line">            sub ax,ax;将CF设置为0</span><br><span class="line">        s:</span><br><span class="line">            mov ax,[si]</span><br><span class="line">            adc ax,[di]</span><br><span class="line">            mov [si],ax</span><br><span class="line">            inc si;不能用add si,2代替</span><br><span class="line">            inc si;因为会影响cf位</span><br><span class="line">            inc di;而loop和inc不会影响</span><br><span class="line">            inc di</span><br><span class="line"></span><br><span class="line">            loop s</span><br><span class="line"></span><br><span class="line">             pop di</span><br><span class="line">             pop si</span><br><span class="line">             pop cx</span><br><span class="line">             pop ax</span><br><span class="line">             ret</span><br><span class="line">    code ends</span><br><span class="line">end start12345678910111213141516171819202122232425262728293031323334353637383940414243</span><br></pre></td></tr></table></figure>

<h2 id="11-7-sbb指令"><a href="#11-7-sbb指令" class="headerlink" title="11.7 sbb指令"></a>11.7 sbb指令</h2><ul>
<li><strong>sbb是带借位减法指令，利用了CF位上记录的借位值。格式：sbb 操作对象1,操作对象2，功能是：操作对象1=操作对象1-操作对象2-CF。</strong></li>
<li>利用sbb指令我们可以对任意大的数据进行减法运算。sbb和adc是基于同样的思想设计的两条指令，在应用思路上sbb和adc类似。</li>
<li>编程：计算003E1000H-00202000H，结果放在ax、bx中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000H</span><br><span class="line">mov ax,003EH</span><br><span class="line">sbb bx,2000H</span><br><span class="line">sbb ax,0020H1234</span><br></pre></td></tr></table></figure>

<h2 id="11-8-cmp指令"><a href="#11-8-cmp指令" class="headerlink" title="11.8 cmp指令"></a>11.8 cmp指令</h2><ul>
<li>cmp是比较指令，功能上相当于减法指令，只是不保存结果。格式：cmp 操作对象1,操作对象2.功能：计算操作对象1-操作对象2但不保存结果，仅仅是根据计算结果对标志寄存器进行设置。</li>
<li>cmp指令运算执行后通过做减法将对标志寄存器产生影响，其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmp ax,ax</span><br><span class="line">;执行后结果为0，ZF&#x3D;1,PF&#x3D;1,SF&#x3D;0,CF&#x3D;0,OF&#x3D;0</span><br><span class="line">  </span><br><span class="line">mov ax,8</span><br><span class="line">mov bx,3</span><br><span class="line">cmp ax,bx</span><br><span class="line">;执行后ax、bx的值不变，ZF&#x3D;0,PF&#x3D;1,SF&#x3D;0,CF&#x3D;0,OF&#x3D;01234567</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp ax,bx1</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522080305742.png" alt="118cmp_1"></p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522080322023.png" alt="118cmp2"></p>
<ul>
<li><p>CPU在执行cmp指令时也包含了对无符号数运算和进行有符号数运算，所以利用cmp指令可以对无符号数进行比较也可以对有符号数进行比较。</p>
</li>
<li><p>单纯地考察SF的值不可能知道结果的正负。因为SF记录的只是可以在计算机中存放的相应位数的结果的正负</p>
<p>(例如：add ah， al执行后，SF记录的是ah中的8位二进制信息所表示的数据的正负)。</p>
<p>如果没有溢出发生的话，实际结果的正负和逻辑上真正结果的正负就一致了。</p>
<p>。例如：22H(34)-0A0H(-96)=130=82H(是-126的补码)，SF=1。</p>
<ul>
<li><strong>1、如果SF=1或SF=0，OF=0，逻辑上真正结果的正负=实际结果的正负。</strong></li>
<li><strong>2、如果SF=1或SF=0，OF=1，逻辑上真正结果的负正=实际结果的正负。</strong></li>
</ul>
</li>
</ul>
<h2 id="11-9-检测比较结果的条件转移指令"><a href="#11-9-检测比较结果的条件转移指令" class="headerlink" title="11.9 检测比较结果的条件转移指令"></a>11.9 检测比较结果的条件转移指令</h2><ul>
<li>与cmp相配使用，根据cmp指令的比较结果(cmp指令执行后相关标志位的值)进行工作的指令。</li>
<li>cmp指令可以同时进行两种比较，无符号数比较和有符号数比较，所以根据cmp指令的比较结果进行转移的指令也分为两种：<ul>
<li>根据无符号数的比较结果进行转移的条件转移指令，它们检测ZF、CF的值；</li>
<li>根据有符号数的比较结果进行转移的条件转移指令，它们检测SF、OF、ZF的值。</li>
</ul>
</li>
<li><strong>它们所检测的标志位都是cmp指令进行无符号数比较时候记录比较结果的标志位。</strong></li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
<th>检测的相关标志位</th>
</tr>
</thead>
<tbody><tr>
<td>je</td>
<td>等于则转移</td>
<td>ZF=1</td>
</tr>
<tr>
<td>jne</td>
<td>不等于则转移</td>
<td>ZF=0</td>
</tr>
<tr>
<td>jb</td>
<td>低于则转移</td>
<td>CF=1</td>
</tr>
<tr>
<td>jnb</td>
<td>不低于则转移</td>
<td>CF=0</td>
</tr>
<tr>
<td>ja</td>
<td>高于则转移</td>
<td>CF=0 and ZF=0</td>
</tr>
<tr>
<td>jna</td>
<td>不高于则转移</td>
<td>CF=1 or ZF=1</td>
</tr>
</tbody></table>
</li>
</ul>
<table>
<thead>
<tr>
<th>j</th>
<th>e</th>
<th>ne</th>
<th>b</th>
<th>nb</th>
<th>a</th>
<th>na</th>
</tr>
</thead>
<tbody><tr>
<td>jump</td>
<td>equal</td>
<td>not equal</td>
<td>below</td>
<td>not below</td>
<td>above</td>
<td>not above</td>
</tr>
</tbody></table>
<ul>
<li><p>编程：如果ah的值等于bh则ah的值等于ah的值加ah的值，否则ah的值等于ah的值加上bh的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    cmp ah,bh</span><br><span class="line">    je s;ZF&#x3D;1则跳转</span><br><span class="line">    add ah,bh</span><br><span class="line">    jmp short ok</span><br><span class="line">s:</span><br><span class="line">    add ah,bh</span><br><span class="line">ok:ret1234567</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>je检测的是ZF的位置，不管je前面是什么指令，只要CPU执行je指令时，ZF=1那么就发生转移。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    mov ax,0</span><br><span class="line">    mov ax,0</span><br><span class="line">    je s</span><br><span class="line">    inc ax</span><br><span class="line">s:</span><br><span class="line">    inc ax</span><br><span class="line">;执行后ax的值等于1，add ax,0使得ZF&#x3D;1，所以je指令将进行转移。1234567</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h3></li>
<li><p>编程:统计data段中数值为8的字节的个数，用ax保存统计结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    ;方案一</span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    data segment</span><br><span class="line">            db 8,11,8,1,8,5,63,38</span><br><span class="line">    data ends</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,data</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov bx,0;ds:bx指向第一个字节</span><br><span class="line">            mov ax,0;初始化累加器</span><br><span class="line">            mov cx,0</span><br><span class="line"></span><br><span class="line">        s:</span><br><span class="line">            cmp byte ptr [bx],8;和8进行比较</span><br><span class="line">            jne next;如果不相等转到next，继续循环</span><br><span class="line">            inc ax;如果相等就计数值加1</span><br><span class="line"></span><br><span class="line">        next:</span><br><span class="line">            inc bx</span><br><span class="line">            loop s;执行后：(ax)&#x3D;3</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">    code ends</span><br><span class="line">end segment 12345678910111213141516171819202122232425262728</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">;方案二</span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    data segment</span><br><span class="line">            db 8,11,8,1,8,5,63,38</span><br><span class="line">    data ends</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,data</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov bx,0;ds:bx指向第一个字节</span><br><span class="line">            mov ax,0;初始化累加器</span><br><span class="line">            mov cx,0</span><br><span class="line"></span><br><span class="line">        s:</span><br><span class="line">            cmp byte ptr [bx],8;和8进行比较</span><br><span class="line">            je ok;如果不相等转到ok，继续循环</span><br><span class="line">            jmp short next;如果不想等就转到next，继续循环</span><br><span class="line"></span><br><span class="line">        ok:</span><br><span class="line">            inc ax;如果相等就计数值加1</span><br><span class="line"></span><br><span class="line">        next:</span><br><span class="line">            inc bx</span><br><span class="line">            loop s;执行后：(ax)&#x3D;3</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">    code ends</span><br><span class="line">end segment12345678910111213141516171819202122232425262728293031</span><br></pre></td></tr></table></figure>
</li>
<li><p>编程:统计data段中数值大于8的字节的个数，用ax保存统计结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    data segment</span><br><span class="line">            db 8,11,8,1,8,5,63,38</span><br><span class="line">    data ends</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,data</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov bx,0;ds:bx指向第一个字节</span><br><span class="line">            mov ax,0;初始化累加器</span><br><span class="line">            mov cx,0</span><br><span class="line"></span><br><span class="line">        s:</span><br><span class="line">            cmp byte ptr [bx],8;和8进行比较</span><br><span class="line">            jna next;如果大于8转到next，继续循环</span><br><span class="line">            inc ax;如果大于就计数值加1</span><br><span class="line"></span><br><span class="line">        next:</span><br><span class="line">            inc bx</span><br><span class="line">            loop s;执行后：(ax)&#x3D;3</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">    code ends</span><br><span class="line">end segment 123456789101112131415161718192021222324252627</span><br></pre></td></tr></table></figure>

<h2 id="检测点-11-3"><a href="#检测点-11-3" class="headerlink" title="检测点 11.3"></a>检测点 11.3</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522080826858.png" alt="检测点11.3"></p>
<h2 id="11-10-DF-direction-flag-标志和串传送指令"><a href="#11-10-DF-direction-flag-标志和串传送指令" class="headerlink" title="11.10 DF(direction flag)标志和串传送指令"></a>11.10 DF(direction flag)标志和串传送指令</h2></li>
<li><p>flag的第10位是DF，方向标志位，在串处理指令中，控制每次操作后si(一般指向原始偏移地址)、di(一般指向目标偏移地址)的增减。</p>
<ul>
<li>DF=0：每次操作后si、di递增；</li>
<li>DF=1，每次操作后so、di递减。</li>
</ul>
</li>
<li><p><strong>movsb(mov string byte)串传送指令，以字节为单位传送。将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器DF位的值将si和di递增1或递减1。movsw，以字为单位传送。将ds:si指向的内存单元中的字送入es:di中，然后根据标志寄存器DF位的值将si和di递增2或递减2。</strong></p>
</li>
<li><p>movsb和movsw进行的是串传送操作中的一个步骤，一般和rep配合使用，格式：rep movsb，rep的作用是根据cx 的值，重复执行后面的串传送指令。</p>
<p>由于每次执行一次movsb指令si和di都会递增或递减指向后一个单元或前个单元，则rep movsb就可以循环实现(cx)个字符的传送。</p>
<ul>
<li>1、传送的原始位置；</li>
<li>2、传送的目的位置；</li>
<li>3、传送的长度；</li>
<li>4、传送的方向。</li>
<li>movsb功能：((es)<em>16+(di))=((ds)</em>16+(si))，如果DF=0，则(si)=(si)+1,(di)=(di)+1;如果DF=1，则(si)=(si)-1，(di)=(di)-1。</li>
</ul>
</li>
<li><p>由于flag的DF位决定着串传送指令执行后，si和di改变的方向，8086CPU提供两条指令对DF位进行设置：</p>
<ul>
<li>cld指令：将标志寄存器的DF位设置为0；</li>
<li>std指令：将标志寄存器的DF位设置为1。</li>
</ul>
<h2 id="11-11-pushf和popf"><a href="#11-11-pushf和popf" class="headerlink" title="11.11 pushf和popf"></a>11.11 pushf和popf</h2></li>
<li><p>pushf的功能 是件标志寄存器的值压栈，popf是从栈中弹出数据m，送入标志寄存器中。pushf和popf为直接访问标志寄存器提供了一种方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;下面的程序执行后ax的值是多少？</span><br><span class="line">mov ax,0</span><br><span class="line">push ax</span><br><span class="line">popf</span><br><span class="line">mov ax,0fff0h</span><br><span class="line">add ax,0010h</span><br><span class="line">pushf</span><br><span class="line">pop ax </span><br><span class="line">and al,11000101b</span><br><span class="line">and ah 00001000b12345678910</span><br></pre></td></tr></table></figure>
</li>
<li><p>编程：用串传送指令将data段总的第一个字符串复制到它后面的空间中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    data segment</span><br><span class="line">            db&#39;welcome to masm!&#39;</span><br><span class="line">            db 16 dup(0)</span><br><span class="line">    data ends</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,data</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov si,0;指向data:0</span><br><span class="line">            mov es,ax</span><br><span class="line">            mov di,16;指向data:16</span><br><span class="line">            mov cx,16;rep循环16次</span><br><span class="line"></span><br><span class="line">            cld;设置DF&#x3D;0，正向传送</span><br><span class="line">            rep movsb</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">    code ends</span><br><span class="line">end start1234567891011121314151617181920212223</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522080919891.png" alt="1110"></p>
</li>
<li><p>用串传送指令将F00H段中的最后16个字符复制到data段中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    data segment</span><br><span class="line">            db 16 dup(0)</span><br><span class="line">    data ends</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,0f00h</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov si,0ffffh;指向f0000:ffff</span><br><span class="line">            mov ax,data</span><br><span class="line">            mov es,ax</span><br><span class="line">            mov di,16;指向data:15</span><br><span class="line">            mov cx,16;rep循环16次</span><br><span class="line"></span><br><span class="line">            std;设置DF&#x3D;1，逆向传送</span><br><span class="line">            rep movsb</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">    code ends</span><br><span class="line">end start1234567891011121314151617181920212223</span><br></pre></td></tr></table></figure>

<h2 id="检测点-11-4"><a href="#检测点-11-4" class="headerlink" title="检测点 11.4"></a>检测点 11.4</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522081015575.png" alt="检测点11.4"></p>
<h2 id="11-12-标志寄存器在Debug中的表示"><a href="#11-12-标志寄存器在Debug中的表示" class="headerlink" title="11.12 标志寄存器在Debug中的表示"></a>11.12 标志寄存器在Debug中的表示</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522081037059.png" alt="debugflag"></p>
<table>
<thead>
<tr>
<th>标志</th>
<th>值为1的标记</th>
<th>值为0的标记</th>
</tr>
</thead>
<tbody><tr>
<td>OF</td>
<td>OV</td>
<td>NV</td>
</tr>
<tr>
<td>SF</td>
<td>NG</td>
<td>PL</td>
</tr>
<tr>
<td>ZF</td>
<td>ZR</td>
<td>NZ</td>
</tr>
<tr>
<td>PF</td>
<td>PE</td>
<td>PO</td>
</tr>
<tr>
<td>CF</td>
<td>CY</td>
<td>NC</td>
</tr>
<tr>
<td>DF</td>
<td>DN</td>
<td>UP</td>
</tr>
</tbody></table>
<h1 id="十二、内中断"><a href="#十二、内中断" class="headerlink" title="十二、内中断"></a>十二、内中断</h1><h2 id="引言-8"><a href="#引言-8" class="headerlink" title="引言"></a>引言</h2></li>
<li><p>中断时CPU处理外部突发事件的一个重要技术。它能使CPU在运行过程中对外部事件发出的中断请求几时进行处理，处理完成后又立即返回断电，基础进行CPU原来的工作。引起中断的原因或是说发出中断请求的来源叫做中断源。根据中断源的不同，可以把中断分为硬件中断和软件中断两大类，而硬件中断又可以分为外部中断和内部中断两类。</p>
</li>
<li><p>外部中断一般是指由计算器外部设备发出的中断请求。如：键盘中断、打印机中断、定时器中断等。外部中断时可以屏蔽的中断，业绩是说利用中断控制器可以屏蔽这些外部设备的中断请求。</p>
</li>
<li><p>内部中断是指因硬件出错(如突然掉电)或运算出错(如除数为0、单步中断)所引起的中断。内部中断是不可屏蔽的。</p>
</li>
<li><p>软件中断其实并不是真正的中断，它们只是可被调用执行的一般程序以及DOS的系统功能调用(int 21)等都是软件中断。</p>
</li>
<li><p>中断的优先权：</p>
<ul>
<li>1、除法出错、溢出中断、软件中断；</li>
<li>2、不可屏蔽中断；</li>
<li>3、可屏蔽中断；</li>
<li>4、单步中断。</li>
</ul>
</li>
<li><p>中断信息中包含有标识中断源的类型码。根据CPU的设计，中断源类型码的作用就是用来定位中断处理程序。</p>
<h2 id="12-1-内中断的产生"><a href="#12-1-内中断的产生" class="headerlink" title="12.1 内中断的产生"></a>12.1 内中断的产生</h2></li>
<li><p>8086CPU内部有以下情况发生时将产生相应的中断信息：</p>
<ul>
<li>1、除法错误；</li>
<li>2、单步执行；</li>
<li>3、执行into指令；</li>
<li>4、执行int指令。</li>
</ul>
</li>
<li><p>8086CPU中的中断类型码如下：</p>
<ul>
<li>1、除法错误：0</li>
<li>2、单步执行：1</li>
<li>3、执行into指令：4</li>
<li>4、执行int指令，该指令格式为int n，n为立即数是提供给CPU的中断类型码。</li>
</ul>
<h2 id="12-2-中断处理程序"><a href="#12-2-中断处理程序" class="headerlink" title="12.2 中断处理程序"></a>12.2 中断处理程序</h2></li>
<li><p>CPU在收到中断信息后立即去执行该中断信息的处理程序。</p>
<h2 id="12-3-中断向量表"><a href="#12-3-中断向量表" class="headerlink" title="12.3 中断向量表"></a>12.3 中断向量表</h2></li>
<li><p>中断向量列表就是中断向量(中断处理程序的入口地址)的列表，其在内存中保存，存放着256个中断源说对应的中断处理程序的入口。8086PC机中断向量表放在内存地址0处。从内存0000:0000到0000:03FF的1024(一个物理地址是由段地址和偏移地址构成，要用4个字节来存放)个单元中存放着中断向量表。</p>
</li>
<li><p>CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址。中断向量表中存放的就是各个类型的处理程序的地址，8位的类型码是个索引。</p>
<h2 id="12-4-中断过程"><a href="#12-4-中断过程" class="headerlink" title="12.4 中断过程"></a>12.4 中断过程</h2></li>
<li><p>用中断码在中断向量表中找到中断处理程序的入口地址，用它来设置CS和IP，使CPU执行中断程序。用中断类型码找到中断向量并用它设置CS和IP，这个工作室由CPU的硬件自动完成的，这个工作的过程被称为中断过程。</p>
</li>
<li><p>8086CPU的中断过程：</p>
<ul>
<li>1、从中断信息中取得中断类型码；</li>
<li>2、标志寄存器的值入栈，以保护标志位；</li>
<li>3、设置标志寄存器的第8位TF和第9位IF的值为0；</li>
<li>4、CS的内容入栈，IP的内容入栈；</li>
<li>5、从内存地址为中断类型码* 4和中断类型码 *4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS。</li>
<li>在最后一步完成后，CPU开始执行由程序员编写的中断处理程序。</li>
</ul>
<h2 id="12-5-中断处理程序和iret指令"><a href="#12-5-中断处理程序和iret指令" class="headerlink" title="12.5 中断处理程序和iret指令"></a>12.5 中断处理程序和iret指令</h2></li>
<li><p>常规的步骤</p>
<ul>
<li>1、保存用到的寄存器；</li>
<li>2、处理中断；</li>
<li>3、 恢复用到的寄存器；</li>
<li>4、 用iret指令返回。</li>
</ul>
</li>
<li><p>iret指令的功能为相应的按顺序恢复之前保存起来的IP、CS地址和标志位寄存器。用汇编语法描述为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br><span class="line">popf123</span><br></pre></td></tr></table></figure>

<h2 id="12-6-除法错误中断的处理"><a href="#12-6-除法错误中断的处理" class="headerlink" title="12.6 除法错误中断的处理"></a>12.6 除法错误中断的处理</h2></li>
<li><p>当CPU执行dvi等处罚指令的时候，如果发生了除法溢出错误，将产生中断类型码为0的中断信息，CPU将检测到这个信息然后引发中断过程，转去执行0号中断所对应的中断处理程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">    codesg segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,1000h</span><br><span class="line">            mov bh,1    </span><br><span class="line">            div bh</span><br><span class="line">    codesg ends</span><br><span class="line"></span><br><span class="line">end start12345678910</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522081718999.png" alt="126"><br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522081751015.png" alt="debug 126"></p>
<h2 id="12-7-编程处理0号中断"><a href="#12-7-编程处理0号中断" class="headerlink" title="12.7 编程处理0号中断"></a>12.7 编程处理0号中断</h2></li>
<li><p>改变0号中断处理程序的功能，在屏幕中间显示字然后再返回操作系统。</p>
<ul>
<li><p>当发生除法溢出时产生0号中断信息，引发中断过程。</p>
<ul>
<li>此时CPU将进行以下工作(中断过程)</li>
<li>当中断0发生时，CPU将转去执行中断处理程序。</li>
<li>先进行相关处理，然后向显示缓冲区送字符串，最后返回。</li>
</ul>
</li>
<li><p>改变后的中断处理程序应该放在内存中，因为除法溢出随时可能发生，CPU随时都可能将CS:IP指向改变后的中断处理程序的入口执行程序。</p>
</li>
<li><p>把程序存入内存，修改向量表(即将内存地址登记在中断向量表的对应表项中)，中断时调用这个内存。</p>
<blockquote>
<p>除法溢出对应的中断类型码为0，它的中断处理程序的入口地址应该从0* 4+2地址单元开始存放，段地址存放在0* 4+2字单元中，偏移地址存放在0*4字单元中。也就是改变后的中断处理程序的段地址0存放在0000:0002字单元中，偏移地址200H存放在0000:0000字单元中。如果要显示的字符串在程序的data段中，那么程序执行完成后返回，它所占用的内存空间被系统释放，在其中存放的信息也可能被别的信息覆盖。</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">          code segment</span><br><span class="line">          start:</span><br><span class="line">                  mov ax,cs</span><br><span class="line">                  mov ds,ax</span><br><span class="line">                  mov si,offset do0;设置ds:di指向源地址</span><br><span class="line">                  mov ax,0</span><br><span class="line">                  mov es,ax</span><br><span class="line">                  mov di,200h;设置es:si指向目的地址</span><br><span class="line">                  mov cx,offset do0end - offset do0;设置cx为传输长度，编译器可以识别加减乘除运算符</span><br><span class="line">                  cld;设置传输方向为正</span><br><span class="line">                  rep movsb</span><br><span class="line"></span><br><span class="line">                  mov ax,0;设置中断向量表</span><br><span class="line">                  mov es,ax</span><br><span class="line">                  mov word ptr es:[0*4],200h</span><br><span class="line">                  mov word ptr es:[0*4+2],0</span><br><span class="line"></span><br><span class="line">                  mov ax,4c00h</span><br><span class="line">                  int 21h</span><br><span class="line">              do0:</span><br><span class="line">                  jmp short do0start</span><br><span class="line">                  db&quot;welcome to masm!&quot;;在代码段中存储数据</span><br><span class="line">              do0start:</span><br><span class="line">                  mov ax,cs</span><br><span class="line">                  mov ds,ax</span><br><span class="line">                  mov si,202h;jmp short do0start这条指令栈两个字节</span><br><span class="line">                  ;显示字符串，设置es:di指向字符串</span><br><span class="line">                  mov ax,0b800h;显存空间，直接显示在显示器上</span><br><span class="line">                  mov es,ax</span><br><span class="line">                  mov di,12*160+36*2;这只es:di指向显存空间的中间位置</span><br><span class="line">                  mov cx,16;设置cx为字符串(welcome to masm！)长度</span><br><span class="line">              s:</span><br><span class="line">                  mov al,[si]</span><br><span class="line">                  mov es:[di],al</span><br><span class="line">                  inc si</span><br><span class="line">                  add di,1</span><br><span class="line">                  mov al,02h</span><br><span class="line">                  mov es:[di],al</span><br><span class="line">                  add di,1</span><br><span class="line">                  loop s</span><br><span class="line"></span><br><span class="line">                  mov ax,4c00h</span><br><span class="line">                  int 21h</span><br><span class="line">              do0end:</span><br><span class="line">                  nop</span><br><span class="line"></span><br><span class="line">          code ends</span><br><span class="line">end start1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522081857031.png" alt="do0"> <img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522081929203.png" alt="do02"></p>
<h2 id="12-8-单步中断"><a href="#12-8-单步中断" class="headerlink" title="12.8 单步中断"></a>12.8 单步中断</h2></li>
<li><p>CPU执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断引发中断过程。单步中断的中断类型码为1，它所引发的中断过程如下：</p>
<ul>
<li>1、取得中断类型码；</li>
<li>2、标志寄存器入栈，TF、IF设置为0；</li>
<li>3、CS、IP入栈；</li>
<li>4、指向指定类型码的中断向量表。</li>
</ul>
<h2 id="12-9-响应中断的特殊情况"><a href="#12-9-响应中断的特殊情况" class="headerlink" title="12.9 响应中断的特殊情况"></a>12.9 响应中断的特殊情况</h2></li>
<li><p>在有些情况下CPU在执行完当前指令后，即便是发生了中断也不会响应。</p>
<blockquote>
<p>在执行完向ss寄存器传送数据的指令后，即便检测到了中断信号CPU也不会响应。因为ss:sp指向栈顶，对他们的设置应该连续完成。如果在执行完设置ss指令后mCPU响应中断引发中断过程，要在栈中压入标志寄存器、CS和IP的值。而ss改变，sp并未改变则ss:sp指向不是正确的栈顶将引发错误。</p>
</blockquote>
</li>
<li><p>我们要将栈顶设置为1000:0，不应该隔开</p>
<table>
<thead>
<tr>
<th>应该</th>
<th>不应该</th>
</tr>
</thead>
<tbody><tr>
<td>mov ax,1000h</td>
<td>mov ax,1000h</td>
</tr>
<tr>
<td>mov ss,ax</td>
<td>mov ss,ax</td>
</tr>
<tr>
<td>mov sp,0</td>
<td>mov ax,0</td>
</tr>
<tr>
<td>mov ax,0</td>
<td>mov sp,0</td>
</tr>
</tbody></table>
<h1 id="十三、int-指令"><a href="#十三、int-指令" class="headerlink" title="十三、int 指令"></a>十三、int 指令</h1><h2 id="引言-9"><a href="#引言-9" class="headerlink" title="引言"></a>引言</h2></li>
<li><p>在第12章中了解中断过程和除法错误中断和单步中断的处理，这章了解int指令。</p>
<h2 id="13-1-int-指令"><a href="#13-1-int-指令" class="headerlink" title="13.1 int 指令"></a>13.1 int 指令</h2></li>
<li><p>int格式：int n，n为中断类型码，它的功能是引发中断过程。CPU执行int n之力量能够，相当引发一个n号的中断过程，可以在程序中使用int指令调用任何一个中断的中断处理程序。执行过程如下：</p>
<ul>
<li><p>中断过程从，此处去执行n号中断的中断处理程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line"></span><br><span class="line">    start:</span><br><span class="line">            mov ax,0b800h</span><br><span class="line">            mov es,ax</span><br><span class="line">            mov byte ptr es:[12*160+40*2],&#39;!&#39;</span><br><span class="line"></span><br><span class="line">            int 0;执行int 0指令，引发中断过程，执行0号中断处理程序</span><br><span class="line">    code ends</span><br><span class="line"> end start123456789101112</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522082205111.png" alt="131dosbox"><br>​</p>
</li>
</ul>
</li>
<li><p>int指令的最终功能和call类似，都是调用一段程序。一般情况下系统将一些具有一定功能的子程序以中断处理程序的方式提供给应用程序调用，也可以自己编写一些中断处理程序供别人使用。</p>
<h2 id="13-2-编写供应用程序调用的中断例程"><a href="#13-2-编写供应用程序调用的中断例程" class="headerlink" title="13.2 编写供应用程序调用的中断例程"></a>13.2 编写供应用程序调用的中断例程</h2></li>
<li><p>中断处理程序简称为中断例程。</p>
</li>
<li><p>实例1：编写、安装中断7ch的中断例程实现求一word型数据的平方。</p>
<ul>
<li>1、编程实现求平方功能的程序；</li>
<li>2、安装程序在0:200处；</li>
<li>3、设置中断向量表将程序的入口地址保存在7ch表项中，使其成为中断7ch的中断例程。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">             ;计算</span><br><span class="line">ssume cs:code</span><br><span class="line">             code segment</span><br><span class="line">             start:</span><br><span class="line">                     mov ax,3456</span><br><span class="line">                     int 7ch</span><br><span class="line">                     add ax,ax</span><br><span class="line">                     adc ax,dx</span><br><span class="line">                     mov ax,4c00h</span><br><span class="line">                     int 21h</span><br><span class="line">             code ends</span><br><span class="line">             end start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             ;安装程序</span><br><span class="line">             assume cs:code</span><br><span class="line">             code segment</span><br><span class="line">             start:</span><br><span class="line">                     mov ax,cs</span><br><span class="line">                     mov ds,ax</span><br><span class="line">                     mov si offset sqr;设置ds:si指向源地址</span><br><span class="line">                     mov ax,0</span><br><span class="line">                     mov es,ax</span><br><span class="line">                     mov di,200h;设置es:di指向目的地址</span><br><span class="line">                     mov cx,offset sqrend- offset sqr;设置cx为传输长度</span><br><span class="line">                     cld;设置传输方向为正</span><br><span class="line">                     rep movsb</span><br><span class="line"></span><br><span class="line">                     mov ax,0</span><br><span class="line">                     mov es,ax</span><br><span class="line">                     mov word ptr es:[7ch*4],200h</span><br><span class="line">                     mov word ptr ws:[7ch*4+2],0</span><br><span class="line">                     mov ax,4c00h</span><br><span class="line">                     int 21h</span><br><span class="line">                 sqr:</span><br><span class="line">                     mul ax</span><br><span class="line">                     iret</span><br><span class="line">                 sqrend:</span><br><span class="line">                     nop</span><br><span class="line">             code ends</span><br><span class="line">end start123456789101112131415161718192021222324252627282930313233343536373839404142</span><br></pre></td></tr></table></figure>
</li>
<li><p>CPU执行int 7ch指令进入中断例程之前，标志寄存器、当前的CS和IP都被压入栈中，在执行完中断例程后，用iret指令恢复int 7ch执行前的标志寄存器和CS和IP的值，从而接着执行应用程序。</p>
</li>
<li><p><strong>int指令和iret指令配合使用与call指令和ret指令配合使用具有相似的思路。</strong></p>
</li>
<li><p>实例2：编写、安装中断7ch的中断例程，实现将一个全是字母，以0为结尾的字符串转化为大写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">             data segment</span><br><span class="line">                     db&#39;conversation&#39;,0</span><br><span class="line">             data ends</span><br><span class="line"></span><br><span class="line">             code segment</span><br><span class="line">             start:</span><br><span class="line">                     mov ax,data</span><br><span class="line">                     mov ds,ax</span><br><span class="line">                     mov si,0</span><br><span class="line">                     int 7ch</span><br><span class="line">                     mov ax,4c00h</span><br><span class="line">                     int 21h</span><br><span class="line">             code ends </span><br><span class="line">             end start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             assume cs:code</span><br><span class="line">             code segment</span><br><span class="line"></span><br><span class="line">             start:</span><br><span class="line">                     mov ax,cs</span><br><span class="line">                     mov ds,ax</span><br><span class="line">                     mov si,offset capital</span><br><span class="line">                     mov ax,0</span><br><span class="line">                     mov es,ax</span><br><span class="line">                     mov di 200h</span><br><span class="line">                     mov cx,offset capitalend - offset capital</span><br><span class="line">                     cld</span><br><span class="line">                     rep movsb</span><br><span class="line"></span><br><span class="line">                     mov ax,0</span><br><span class="line">                     mov es,ax</span><br><span class="line">                     mov word ptr es:[7ch*4],200h</span><br><span class="line">                     mov word ptr es:[7ch*4+2],0</span><br><span class="line"></span><br><span class="line">                     mov ax,4c00h</span><br><span class="line">                     int 21h</span><br><span class="line"></span><br><span class="line">                 capital:</span><br><span class="line">                     push cx</span><br><span class="line">                     push si</span><br><span class="line">                 change:</span><br><span class="line">                     mov cl,[si]</span><br><span class="line">                     mov ch,0</span><br><span class="line">                     jcxz ok</span><br><span class="line">                     and byte ptr [si],11011111b</span><br><span class="line">                     inc si</span><br><span class="line">                     jmp short change</span><br><span class="line">                 ok:</span><br><span class="line">                     pop si</span><br><span class="line">                     pop cx</span><br><span class="line">                     iret</span><br><span class="line"></span><br><span class="line">                 capitalend:</span><br><span class="line">                     nop</span><br><span class="line">             code ends</span><br><span class="line">end start1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162</span><br></pre></td></tr></table></figure>
</li>
<li><p>要注意用到的寄存器冲突。</p>
<h2 id="13-3-对int、iret和栈的深入理解"><a href="#13-3-对int、iret和栈的深入理解" class="headerlink" title="13.3 对int、iret和栈的深入理解"></a>13.3 对int、iret和栈的深入理解</h2></li>
<li><p>中断处理程序和iret指令</p>
</li>
<li><p>编程：用7ch中断例程完成loop指令的功能，在屏幕中间显示80个”!”.</p>
<blockquote>
<p>loop指令需要循环次数和到标号的位移。为了模拟loop指令7ch中断例程应具备下面dec cx和如果cx的值不等于0则转移到标号s处。</p>
</blockquote>
<ul>
<li>int 7ch引发中断过程后，进入7ch中断例程在中断过程中当前的标志寄存器、CS和IP都要压栈。此时压入的CS和IP中的内容分别是调用程序的段地址(可以认为是标号s的段地址)和int 7ch后一条指令的偏移地址(即标号se的偏移地址)。使用iret指令用栈中的内容设置CS、IP，从而实现转移到标号s处。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,0b800h;显存地址</span><br><span class="line">            mov es,ax</span><br><span class="line">            mov di,160*12</span><br><span class="line">            mov bx,offset s- offset se;设置从标号s的转移位移</span><br><span class="line">            mov cx,80</span><br><span class="line">        s:</span><br><span class="line">            mov byte ptr es:[di],&#39;!&#39;</span><br><span class="line">            add di,2</span><br><span class="line">            int 7ch;如果cx的值不等于0则转移到标号s处</span><br><span class="line">        se:</span><br><span class="line">            nop</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ;7ch中断例程</span><br><span class="line">        lp:</span><br><span class="line">            push bp</span><br><span class="line">            mov bp,sp;</span><br><span class="line">            dec cx</span><br><span class="line">            jcxz lpret</span><br><span class="line">            add [bp+2],bx</span><br><span class="line">        lpret:</span><br><span class="line">            pop bp</span><br><span class="line">            iret12345678910111213141516171819202122232425262728293031323334</span><br></pre></td></tr></table></figure>

<h2 id="13-4-BIOD和DOS所提供的中断例程"><a href="#13-4-BIOD和DOS所提供的中断例程" class="headerlink" title="13.4 BIOD和DOS所提供的中断例程"></a>13.4 BIOD和DOS所提供的中断例程</h2></li>
<li><p>bios中主要包含以下几部分内容：</p>
<ul>
<li>1、硬件操作系统的检测和初始化程序；</li>
<li>2、外部中断和内部中断的中断例程；</li>
<li>3、用于对硬件设备进行I\O操作的中断例程；</li>
<li>4、其他和硬件系统相关的中断例程。</li>
</ul>
</li>
<li><p>bios和dos在所提供的中断例程中包含了许多子程序，可以用int指令直接调用。和硬件设备相关的dos中断例程中一般都调用了bios的中断例程</p>
<h2 id="13-5-bios和dos中断例程的安装过程"><a href="#13-5-bios和dos中断例程的安装过程" class="headerlink" title="13.5 bios和dos中断例程的安装过程"></a>13.5 bios和dos中断例程的安装过程</h2></li>
<li><p>1、开机后8086CPU一加电初始化CS和IP，自动执行FFFF:0处指令，转去执行bios中的硬件系统检测和初始化程序。</p>
</li>
<li><p>2、初始化程序将建立bios所支持的中断向量，即将biso提供的中断例程的入口地址登记在中断向量表中。</p>
</li>
<li><p>3、硬件系统检测和初始化完成后，调用int 19h进行操作系统的引导。从此将计算机交由操作系统控制。</p>
</li>
<li><p>4、dos启动后除完成其他工作外，还将它所提供的中断例程装入内存并建立相应的中断向量。</p>
<h2 id="13-6-bios中断例程应用"><a href="#13-6-bios中断例程应用" class="headerlink" title="13.6 bios中断例程应用"></a>13.6 bios中断例程应用</h2></li>
<li><p>bios和dos提供的中断例程douyongah来传递内部子程序的编号。</p>
</li>
<li><p>int 10h中断例程是bios提供的中断例程，其中包含了多个和屏幕输出相关的子程序。int 10h中断例程的设置光标位置功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ah,2;表示调用10h号中断例程的2号子程序，功能为设置光标位置</span><br><span class="line">mov bh,0;页号</span><br><span class="line">mov dh,5;行号</span><br><span class="line">mov dl 12;列号</span><br><span class="line">int 10h;12345</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;功能为在光标位置显示字符功能</span><br><span class="line">mov ah,9;置光标，调用9号子程序</span><br><span class="line">mov al,&#39;a&#39;;字符</span><br><span class="line">mov bl,7;颜色属性，和在显存中的属性字节的格式相同</span><br><span class="line">mov bh,0;第0页</span><br><span class="line">mov cx,3;字符重复个数</span><br><span class="line">int 10h1234567</span><br></pre></td></tr></table></figure>
</li>
<li><p>编程：在屏幕的第5行12列显示3个红底高亮闪烁绿色的’a’</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">  </span><br><span class="line">code segment</span><br><span class="line">        mov ah,2;设置光标</span><br><span class="line">        mov bh,0;第0页</span><br><span class="line">        mov dh,5;dh中放行号</span><br><span class="line">        mov dl,12;dl中放列号</span><br><span class="line">        int 10</span><br><span class="line">  </span><br><span class="line">        mov ah,9;设置光标</span><br><span class="line">        mov al,&#39;a&#39;;字符</span><br><span class="line">        mov bl,11001010b;颜色属性</span><br><span class="line">        mov bh,0;第0页</span><br><span class="line">        mov cx,3;字符重复个数</span><br><span class="line">        int 10h</span><br><span class="line">  </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end1234567891011121314151617181920</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522082758756.png" alt="136"></p>
<h2 id="13-7-dos中断例程应用"><a href="#13-7-dos中断例程应用" class="headerlink" title="13.7 dos中断例程应用"></a>13.7 dos中断例程应用</h2></li>
<li><p>int 21h 中断例程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ah,4ch;程序返回</span><br><span class="line">mov al,0;返回值0是正常返回</span><br><span class="line">;合起来写就是 mov ax,4c00h</span><br><span class="line">int 21h1234</span><br></pre></td></tr></table></figure>
</li>
<li><p>int 2h中断例程还具有在光标位置显示字符串的功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ds:dx;要显示的字符串需要用 $ 作为结束符</span><br><span class="line">mov ah,9;功能号9，表示在光标位置显示字符串</span><br><span class="line">int 21h123</span><br></pre></td></tr></table></figure>

<h1 id="十四、端口"><a href="#十四、端口" class="headerlink" title="十四、端口"></a>十四、端口</h1><h2 id="引言-10"><a href="#引言-10" class="headerlink" title="引言"></a>引言</h2></li>
<li><p>CPU可以直接读写3个地方的数据：</p>
<ul>
<li>1、CPU内部的寄存器；</li>
<li>2、内存单元；</li>
<li>3、 端口。</li>
</ul>
<h2 id="14-1-端口的读写"><a href="#14-1-端口的读写" class="headerlink" title="14.1 端口的读写"></a>14.1 端口的读写</h2></li>
<li><p><strong>mov、push、pop等死内存读写指令。in和out是端口读指令写指令时in是从端口读取数据，out是往端口写入数据。in和out指令只能用ax或al来存放从端口中读入的数据或要发送到端口中的数据，访问8位短空时用al，访问16位端口时用ax。</strong></p>
<ul>
<li><p>访问内存：</p>
<ul>
<li>mov ax,ds:[8+0];假设(ds)=0</li>
<li>执行时，与总线相关的操作：<ul>
<li>1、CPU通过地址线信息8发出；</li>
<li>2、CPU通过控制线发出内存读命令，选中存储器芯片并通知它将要从中读取数据；</li>
<li>3、 存储器将8号单元中的数据通过数据线送入CPU。</li>
</ul>
</li>
</ul>
</li>
<li><p>访问端口：</p>
<ul>
<li><p>in al,60h;从60h号端口读入一个字节。</p>
</li>
<li><p>执行时与总线相关的操作：</p>
<ul>
<li><p>1、CPU通过地址线将地址信息60h发出；</p>
</li>
<li><p>2、CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据；</p>
</li>
<li><p>3、端口所在的芯片将60h端口中的数据通过数据线送入CPU。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;对0~255以内的端口进行读写</span><br><span class="line">in al,20h;从20h端口读入一个字节</span><br><span class="line">out 20h,al;往20h端口写入一个字节</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">;对256~65535的端口进行读写时，端口放在dx中</span><br><span class="line">mov dx,3f8h;将端口号3f8h送入dx</span><br><span class="line">in al,dx;从3f8端口读入一个字节</span><br><span class="line">out 3f8h,al;往3f8h端口写入一个字节123456789</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="14-2-CMOS-RAM芯片"><a href="#14-2-CMOS-RAM芯片" class="headerlink" title="14.2 CMOS RAM芯片"></a>14.2 CMOS RAM芯片</h2></li>
<li><p>CMOA RAM特征：</p>
<ul>
<li><p>1、包含一个实时钟和一个有128个存储单元的RAM存储器。(早期的计算机位64个字节)。</p>
</li>
<li><p>2、该芯片靠电池供电。因此关机后其内部的实时钟仍可正常工作，RAM中的信息不会丢失。</p>
</li>
<li><p>3、128个字节的RAM，内部实时钟占用0~0dh单元来保存时间信息默契与大部分单元用于保存系统配置信息，供系统启动时bios程序读取。</p>
</li>
<li><blockquote>
<p>bios也提供了相关的程序使用户在开机时配置CMOS RAM中的系统信息。</p>
</blockquote>
</li>
<li><p>4、该芯片内部有两个端口，端口地址为70h和71<br>h。CPU通过这两个端口读写CMOS RAM。</p>
</li>
<li><p>5、70h为地址端口，存放要访问的CMOS RAM单元的地址;71h为数据端口，存放从选定的CMOS RAM单元中读取的数据，或要写入到其中的数据。</p>
</li>
</ul>
</li>
<li><p>CPU对CMOS RAM的读写分两步进行，以读2号单元为例：</p>
<ul>
<li>1、将2送入端口70h；</li>
<li>2、从71h读出2号单元的内容。</li>
</ul>
<h2 id="14-3-shl和shr指令"><a href="#14-3-shl和shr指令" class="headerlink" title="14.3 shl和shr指令"></a>14.3 shl和shr指令</h2></li>
<li><p>shl为逻辑左移指令功能为：</p>
<ul>
<li>1、将一个寄存器或内存单元中的数据向左移位；</li>
<li>2、将<strong>最后移出</strong>的一位写入CF中；</li>
<li>3、最低位用0补充。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,01001000b</span><br><span class="line">shl al,1;将al中的数据左移一位</span><br><span class="line">;执行后al的值是10010000b，CF&#x3D;0123</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果移动位数大于1时，必须将移动位数放在cl中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,01010001b</span><br><span class="line">mov cl,3</span><br><span class="line">shl al,cl</span><br><span class="line">;执行后al的值为10001000b，cf&#x3D;01234</span><br></pre></td></tr></table></figure>
</li>
<li><p>二进制逻辑左移一位，相当于执行x=x*2(2是进制位)</p>
<table>
<thead>
<tr>
<th>mov al,00000001b</th>
<th>执行后al的值等于00000001b=1</th>
</tr>
</thead>
<tbody><tr>
<td>shl al,1</td>
<td>执行后al的值等于00000010b=2</td>
</tr>
<tr>
<td>shl al,1</td>
<td>执行后al的值等于00000100b=4</td>
</tr>
<tr>
<td>shl al,1</td>
<td>执行后al的值等于00001000b=8</td>
</tr>
<tr>
<td>mov cl,3</td>
<td></td>
</tr>
<tr>
<td>shl al,cl</td>
<td>执行后al的值等于01000000b=64</td>
</tr>
</tbody></table>
</li>
<li><p>shr为逻辑左移指令功能为：</p>
<ul>
<li>1、将一个寄存器或内存单元中的数据向右移位；</li>
<li>2、将<strong>最后移出</strong>的一位写入CF中；</li>
<li>3、最高位用0补充。</li>
</ul>
</li>
<li><p>二进制逻辑右移一位，相当于执行x=x/2(2是进制位)</p>
<h2 id="14-4-CMOS-RAM中存储的时间信息"><a href="#14-4-CMOS-RAM中存储的时间信息" class="headerlink" title="14.4 CMOS　RAM中存储的时间信息"></a>14.4 CMOS　RAM中存储的时间信息</h2></li>
<li><p>在CMOS RAM中以每个信息一字节存放着当前的时间信息：年09h，月08h，日07h，时04h，分02h，秒00h。这些数据以BCD码的方式存放，BCD码以4位为一位。</p>
</li>
<li><p>数值26BCD码表示为0010 0110，用两个BCD码表示两位十进制，高4位表示十位，低4位表示各位。</p>
</li>
<li><p>编程：在屏幕中间显示当前的月份。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">  </span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">        ;向地址端口70h写入要访问的单元地址，读取CMOS RAM的信息</span><br><span class="line">        mov al,8</span><br><span class="line">        out 70h,al</span><br><span class="line">        in al,71h;从数据端口中取得指定单元中的数据</span><br><span class="line">        mov ah,al;al中为从CMOS RAM的8号端口读出数据</span><br><span class="line">        mov cl,4</span><br><span class="line">        shr ah,cl;ah中为月份的十位数码值</span><br><span class="line">        and al,00001111b;ah中为月份的个位数值码</span><br><span class="line">        add ah,30h;BCD码值+30h(字符&#39;0&#39;)&#x3D;十进制对应的ASCII码</span><br><span class="line">        add al,30h</span><br><span class="line">        ;用BCD码表示的月份以十进制的形式显示到屏幕上。</span><br><span class="line">        mov bx,0b800h;显存</span><br><span class="line">        mov es,bx</span><br><span class="line">        mov byte ptr es:[160*12+40*2],ah;显示月份的十位数码</span><br><span class="line">        mov byte ptr es:[160*12+40*2+2],al;显示月份的个位数码</span><br><span class="line">  </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">  </span><br><span class="line">code ends</span><br><span class="line">end start12345678910111213141516171819202122232425</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522082906398.png" alt="144_1"></p>
<h1 id="十五、外中断"><a href="#十五、外中断" class="headerlink" title="十五、外中断"></a>十五、外中断</h1><h2 id="15-1接口芯片和端口"><a href="#15-1接口芯片和端口" class="headerlink" title="15.1接口芯片和端口"></a>15.1接口芯片和端口</h2></li>
<li><p>CPU通过端口和外设进行联系。在PC系统的接口卡和主板上，装有各种接口芯片。这些外设接口芯片的内部有若干寄存器，CCPU将这些寄存器当作端口来访问。外设的输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中；CPU向外设的输出也不是直接送入到外设而是先送入端口再由相关的芯片送到外设。</p>
<h2 id="15-2外中断信息"><a href="#15-2外中断信息" class="headerlink" title="15.2外中断信息"></a>15.2外中断信息</h2></li>
<li><p>外中断源有两类：</p>
<ul>
<li>1、可屏蔽中断；<ul>
<li>可屏蔽中断时CPU可以不响应的外中断。CPU是否响应可屏蔽中断要看标志寄存器的IF位的设置。</li>
</ul>
</li>
<li>2、不可屏蔽中断</li>
</ul>
</li>
<li><p>当CPU检测到可屏蔽中断信息时：</p>
<ul>
<li>如果IF=1，则CPU在执行完当前指令后响应中断引发中断过程。</li>
<li>如果IF=0，着不响应可屏蔽中断。</li>
<li><a href="https://blog.csdn.net/Gibbs_p/article/details/72257840?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control#12420e4b8ade696ade8bf87e7a88b_139" target="_blank" rel="noopener">内中断过程</a></li>
</ul>
</li>
<li><p>&gt; 可屏蔽中断所引发的中断过程，除在第一步的实现上有所不同外，基本上和内中断的中断过程相同。因为可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU的；而内中断的中断类型码是在CPU内部产生的。在中断过程中将IF置0的原因是在进入中断处理程序后禁止其他的可屏蔽中断。</p>
</li>
<li><p>8086CPU提供的设置IF的指令如下：</p>
<ul>
<li>sti，设置IF=1；</li>
<li>cli，设置if=0.</li>
</ul>
</li>
<li><p>不可屏蔽中断是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后立即响应引发中断过程。对于8086CPU不可屏蔽的中断类型码固定为2。所以中断过程中不需要取中断类型码。几乎所有外设引发的外中断都是可屏蔽中断。</p>
</li>
<li><p>不可屏蔽中断过程：</p>
<ul>
<li>1、标志寄存器入栈，IF=0，TF=0’</li>
<li>2、CS和IP入栈；</li>
<li>3、(IP)=(8)，(CS)=(0AH)</li>
</ul>
<h2 id="15-3PC机及键盘的处理过程"><a href="#15-3PC机及键盘的处理过程" class="headerlink" title="15.3PC机及键盘的处理过程"></a>15.3PC机及键盘的处理过程</h2></li>
<li><p>键盘输入的处理过程：</p>
<ul>
<li>1、键盘输入产生扫描码；</li>
<li>2、扫描码送入60h端口；</li>
<li>3、引发9号中断；</li>
<li>4、执行int 9中断例程。</li>
<li>&gt; 前三步由硬件系统自动完成，第四步用户可以修改int 9中断程序。</li>
</ul>
</li>
<li><p>按下一个键产生的扫描码称为通码，松开一个键产生的扫描码称为断码。扫描码被送入主板上的相关接口芯片端口地址为60h的寄存器中。</p>
</li>
<li><p>扫描码长度为一个字节，通码的第7位为0，断码的第7位为1。即断码=通码+80h。</p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170522082937633.png" alt="键盘上部分键的扫描码"></p>
</li>
<li><p>bios提供了int 9中断例程，用来进行基本键盘输入处理，主要的工作如下：</p>
<ul>
<li>1、读出60h端口中的扫描码；</li>
<li>2、如果是字符键的扫描码就将它和它所对应的字符码(ASCII码)送入内存中的bios键盘缓冲区；<ul>
<li>键盘的输入到达60h端口时相关的芯片就会向CPU发出中断类型码为9的可屏蔽中断信息。</li>
<li>CPU检测到该中断信息后，如果IF=1，则相应中断，引发中断过程，转去执行int 9中断例程。</li>
<li>如果是控制键(如ctrl)和切换键(如capslock)的扫描码，则将其转变为状态字节(用为进制位记录控制键和切换键状态的字节)写入内存中存储状态字节的单元</li>
</ul>
</li>
<li>3、键盘系统进行相关的控制。如向相关芯片发出应答信息。</li>
</ul>
</li>
<li><p>bios键盘缓冲区是系统启动后mbios用于存放int 9中断例程所接收的键盘输入的内存区。该内存可以存储15个键盘输入，在bios键盘缓冲区中一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码。0040:17单元存储键盘状态字节该字节记录了控制键和切换键的状态</p>
<ul>
<li>0:置1表表示按下右shift键</li>
<li>1:置1表表示按下左shift键</li>
<li>2:置1表表示按下ctrl</li>
<li>3:置1表表示按下alt</li>
<li>4:置1表表示按下scroll指示灯亮</li>
<li>5:置1表表示按下numlock，小键盘输入的是数字</li>
<li>6:置1表表示按下capslock，输入大写字母</li>
<li>7:置1表表示按下insert。处于删除状态</li>
</ul>
<h2 id="15-4编写int-9中断"><a href="#15-4编写int-9中断" class="headerlink" title="15.4编写int 9中断"></a>15.4编写int 9中断</h2></li>
<li><p>键盘输入的处理过程</p>
</li>
<li><p>编程：在屏幕中间依次显示让人看清的a~z，按下esc键后改变显示的颜色。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    ;显示字符</span><br><span class="line">code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,0b800h</span><br><span class="line">            mov es,ax</span><br><span class="line">            mov ah,&#39;a&#39;</span><br><span class="line">        s:</span><br><span class="line">            mov es:[160*12+40*2],ah</span><br><span class="line">            inc ax</span><br><span class="line">            cmp ah,&#39;z&#39;</span><br><span class="line">            jna s</span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">    code ends</span><br><span class="line">end start123456789101112131415</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    ;延迟显示字符</span><br><span class="line"></span><br><span class="line">assume cs:code</span><br><span class="line">    stack segment</span><br><span class="line">            db 128 dup(0)</span><br><span class="line">    stack ends</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,stack</span><br><span class="line">            mov ss,ax</span><br><span class="line">            mov sp,128</span><br><span class="line">            mov ax,0b800h</span><br><span class="line">            mov es,ax</span><br><span class="line">            mov ah,&#39;a&#39;</span><br><span class="line">        s:</span><br><span class="line">            mov es:[160*12+40*2],ah</span><br><span class="line">            call delay</span><br><span class="line">            inc ah</span><br><span class="line">            cmp ah,&#39;z&#39;</span><br><span class="line">            jna s</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line"></span><br><span class="line">        delay:</span><br><span class="line">            push ax</span><br><span class="line">            push dx</span><br><span class="line">            mov dx,10h;循环100次，延迟的时间和CPU的计算能力成反比</span><br><span class="line">            mov ax,0</span><br><span class="line">        s1:</span><br><span class="line">            sub ax,1</span><br><span class="line">            sbb dx,0</span><br><span class="line">            cmp ax,0</span><br><span class="line">            jne s1</span><br><span class="line">            cmp dx,0</span><br><span class="line">            jne s1</span><br><span class="line">            pop dx</span><br><span class="line">            pop ax</span><br><span class="line">            ret</span><br><span class="line">    code ends</span><br><span class="line">end start123456789101112131415161718192021222324252627282930313233343536373839404142</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;实现IF&#x3D;0，TF&#x3D;0步骤</span><br><span class="line">pushf</span><br><span class="line">pop ax</span><br><span class="line">and ah,11111100b</span><br><span class="line">push ax</span><br><span class="line">popf123456</span><br></pre></td></tr></table></figure>
</li>
<li><p>int指令在执行时CPU进行的工作</p>
</li>
<li><p>完整程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    stack segment</span><br><span class="line">            db 128 dup(0)</span><br><span class="line">    stack ends</span><br><span class="line"></span><br><span class="line">    data segment</span><br><span class="line">            dw 0,0</span><br><span class="line">    data ends</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,stack</span><br><span class="line">            mov ss,ax</span><br><span class="line">            mov sp,128</span><br><span class="line">            mov ax,data</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov ax,0</span><br><span class="line">            mov es,ax</span><br><span class="line"></span><br><span class="line">            push es:[9*4]</span><br><span class="line">            pop ds:[0]</span><br><span class="line">            push es:[9*4+2]</span><br><span class="line">            pop ds:[2];将原来的int9中断例程的入口地址保存</span><br><span class="line"></span><br><span class="line">            mov word ptr es:[9*4+2],offset int9</span><br><span class="line">            mov es:[9*4+2],cs;在中断向量表中设置新的int 9中断例程的入口地址</span><br><span class="line"></span><br><span class="line">            mov ax,0b800h</span><br><span class="line">            mov es,ax</span><br><span class="line">            mov ah,&#39;a&#39;</span><br><span class="line"></span><br><span class="line">        s:</span><br><span class="line">            mov es:[160*12+40*2],ah</span><br><span class="line">            call delay</span><br><span class="line">            inc ah</span><br><span class="line">            cmp ah,&#39;z&#39;</span><br><span class="line">            jna s</span><br><span class="line">            mov ax,0</span><br><span class="line">            mov es,ax</span><br><span class="line"></span><br><span class="line">            push ds:[0]</span><br><span class="line">            pop es:[9*4]</span><br><span class="line">            push ds:[2]</span><br><span class="line">            pop es:[9*4+2];将中断向量表中int9中断例程的入口恢复为原来的地址</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line"></span><br><span class="line">        delay:</span><br><span class="line">            push ax</span><br><span class="line">            push dx</span><br><span class="line">            mov dx,10h;循环100次，延迟的时间和CPU的计算能力成反比</span><br><span class="line">            mov ax,0</span><br><span class="line">        s1:</span><br><span class="line">            sub ax,1</span><br><span class="line">            sbb dx,0</span><br><span class="line">            cmp ax,0</span><br><span class="line">            jne s1</span><br><span class="line">            cmp dx,0</span><br><span class="line">            jne s1</span><br><span class="line">            pop dx</span><br><span class="line">            pop ax</span><br><span class="line">            ret</span><br><span class="line"></span><br><span class="line">            ;新的int 9中断例程</span><br><span class="line"></span><br><span class="line">        int9:</span><br><span class="line">            push ax</span><br><span class="line">            push bx</span><br><span class="line">            push es</span><br><span class="line"></span><br><span class="line">            in al,60h</span><br><span class="line"></span><br><span class="line">            pushf</span><br><span class="line">            pushf</span><br><span class="line">            pop bx</span><br><span class="line">            and bh,11111100b</span><br><span class="line">            push bx</span><br><span class="line">            popf</span><br><span class="line">            call dword ptr ds:[0];对int指令进行模拟，调用原来的int9中断例程</span><br><span class="line"></span><br><span class="line">            cmp al,1;esc键盘扫描码</span><br><span class="line">            jne int9ret</span><br><span class="line"></span><br><span class="line">            mov ax,0b800h</span><br><span class="line">            mov es,ax</span><br><span class="line">            inc byte ptr es:[160*12+40*2+1];改变颜色</span><br><span class="line"></span><br><span class="line">        int9ret:</span><br><span class="line">            pop es</span><br><span class="line">            pop bx</span><br><span class="line">            pop ax</span><br><span class="line">            iret</span><br><span class="line"></span><br><span class="line">    code ends</span><br><span class="line">end start</span><br><span class="line">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798</span><br></pre></td></tr></table></figure>

<h2 id="15-5安装新的int-9中断例程"><a href="#15-5安装新的int-9中断例程" class="headerlink" title="15.5安装新的int 9中断例程"></a>15.5安装新的int 9中断例程</h2></li>
<li><p><strong>小甲鱼版(笔者未成功运行)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    stack segment</span><br><span class="line">            db 128 dup(0)</span><br><span class="line">    stack ends</span><br><span class="line"></span><br><span class="line">    data segment</span><br><span class="line">            dw 0,0</span><br><span class="line">    data ends</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,stack</span><br><span class="line">            mov ss,ax</span><br><span class="line">            mov sp,128</span><br><span class="line">            mov ax,data</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov ax,0</span><br><span class="line">            mov es,ax</span><br><span class="line"></span><br><span class="line">            push es:[9*4]</span><br><span class="line">            pop ds:[0]</span><br><span class="line">            push es:[9*4+2]</span><br><span class="line">            pop ds:[2];将原来的int9中断例程的入口地址保存</span><br><span class="line"></span><br><span class="line">            mov word ptr es:[9*4+2],offset int9</span><br><span class="line">            mov es:[9*4+2],cs;在中断向量表中设置新的int 9中断例程的入口地址</span><br><span class="line"></span><br><span class="line">            mov ax,0b800h</span><br><span class="line">            mov es,ax</span><br><span class="line">            mov ah,&#39;a&#39;</span><br><span class="line"></span><br><span class="line">        s:</span><br><span class="line">            mov es:[160*12+40*2],ah</span><br><span class="line">            call delay</span><br><span class="line">            inc ah</span><br><span class="line">            cmp ah,&#39;z&#39;</span><br><span class="line">            jna s</span><br><span class="line">            mov ax,0</span><br><span class="line">            mov es,ax</span><br><span class="line"></span><br><span class="line">            push ds:[0]</span><br><span class="line">            pop es:[9*4]</span><br><span class="line">            push ds:[2]</span><br><span class="line">            pop es:[9*4+2];将中断向量表中int9中断例程的入口恢复为原来的地址</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line"></span><br><span class="line">        delay:</span><br><span class="line">            push ax</span><br><span class="line">            push dx</span><br><span class="line">            mov dx,10000h;循环100次，延迟的时间和CPU的计算能力成反比</span><br><span class="line">            mov ax,0</span><br><span class="line">        s1:</span><br><span class="line">            sub ax,1</span><br><span class="line">            sbb dx,0</span><br><span class="line">            cmp ax,0</span><br><span class="line">            jne s1</span><br><span class="line">            cmp dx,0</span><br><span class="line">            jne s1</span><br><span class="line">            pop dx</span><br><span class="line">            pop ax</span><br><span class="line">            ret</span><br><span class="line"></span><br><span class="line">            ;新的int 9中断例程</span><br><span class="line"></span><br><span class="line">        int9:</span><br><span class="line">            push ax</span><br><span class="line">            push bx</span><br><span class="line">            push es</span><br><span class="line"></span><br><span class="line">            in al,60h</span><br><span class="line"></span><br><span class="line">            pushf</span><br><span class="line">            pushf</span><br><span class="line">            pop bx</span><br><span class="line">            and bh,11111100b</span><br><span class="line">            push bx</span><br><span class="line">            popf</span><br><span class="line">            call dword ptr ds:[0];对int指令进行模拟，调用原来的int9中断例程</span><br><span class="line"></span><br><span class="line">            cmp al,1;esc键盘扫描码</span><br><span class="line">            jne int9ret</span><br><span class="line"></span><br><span class="line">            mov ax,0b800h</span><br><span class="line">            mov es,ax</span><br><span class="line">            inc byte ptr es:[160*12+40*2+1];改变颜色</span><br><span class="line"></span><br><span class="line">        int9ret:</span><br><span class="line">            pop es</span><br><span class="line">            pop bx</span><br><span class="line">            pop ax</span><br><span class="line">            iret</span><br><span class="line"></span><br><span class="line">    code ends</span><br><span class="line">end start12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>王爽原版(笔者未成功运行)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">    stack segment</span><br><span class="line">            db 128 dup(0)</span><br><span class="line">    stack ends</span><br><span class="line"></span><br><span class="line">    code segment</span><br><span class="line">    start:</span><br><span class="line">            mov ax,stack</span><br><span class="line">            mov ss,ax</span><br><span class="line">            mov sp,128</span><br><span class="line"></span><br><span class="line">            push cs</span><br><span class="line">            pop ds</span><br><span class="line"></span><br><span class="line">            mov ax,0</span><br><span class="line">            mov es,ax</span><br><span class="line"></span><br><span class="line">            mov si,offset int9;设置ds:si指向源地址</span><br><span class="line">            mov di,204h;设置es:di指向目的地址</span><br><span class="line">            mov cx,offset int9end - offset int9;设置cx为传输长度</span><br><span class="line">            cld;设置传输方向</span><br><span class="line">            rep movsb</span><br><span class="line"></span><br><span class="line">            push es:[9*4]</span><br><span class="line">            pop es:[200h]</span><br><span class="line">            push es:[9*4+2]</span><br><span class="line">            pop es:[202h]</span><br><span class="line"></span><br><span class="line">            cli</span><br><span class="line">            mov word ptr es:[9*4],204h</span><br><span class="line">            mov word ptr es:[9*4+2],0</span><br><span class="line">            sti</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line"></span><br><span class="line">        int9:</span><br><span class="line">            push ax</span><br><span class="line">            push bx</span><br><span class="line">            push cx</span><br><span class="line">            push es</span><br><span class="line"></span><br><span class="line">            in al,60h</span><br><span class="line"></span><br><span class="line">            pushf</span><br><span class="line">            call dword ptr cs:[200h];当此中断例程执行时(CS)&#x3D;0</span><br><span class="line"></span><br><span class="line">            cmp al,3bh;f1的扫描码</span><br><span class="line">            jne int9ret</span><br><span class="line"></span><br><span class="line">            mov ax,0b800h</span><br><span class="line">            mov es,ax</span><br><span class="line">            mov bx,1</span><br><span class="line">            mov cx,2000</span><br><span class="line"></span><br><span class="line">        s:</span><br><span class="line">            inc byte ptr es:[bx]</span><br><span class="line">            add bx,2</span><br><span class="line">            loop s</span><br><span class="line"></span><br><span class="line">        int9ret:</span><br><span class="line">            pop es</span><br><span class="line">            pop cx</span><br><span class="line">            pop bx</span><br><span class="line">            pop ax</span><br><span class="line">            iret</span><br><span class="line"></span><br><span class="line">        int9end:</span><br><span class="line">            nop</span><br><span class="line"></span><br><span class="line">    code ends</span><br><span class="line">end start12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273</span><br></pre></td></tr></table></figure>

<h1 id="第16章-直接定址表"><a href="#第16章-直接定址表" class="headerlink" title="第16章 直接定址表"></a>第16章 直接定址表</h1><h2 id="16-1-描述单元长度的标号"><a href="#16-1-描述单元长度的标号" class="headerlink" title="16.1 描述单元长度的标号"></a>16.1 描述单元长度的标号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">cod segment</span><br><span class="line">    a:db 1,2,3,4,5,6,7,8</span><br><span class="line">    b:dw 0</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">        mov si,offset a</span><br><span class="line">        mov bx,offset b</span><br><span class="line">        mov cx,8</span><br><span class="line">    s:</span><br><span class="line">        mov al,cs:[si]</span><br><span class="line">        mov ah,0</span><br><span class="line">        add cs:[bx],ax</span><br><span class="line">        inc si</span><br><span class="line"></span><br><span class="line">    loop s</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;代码中的 s、start等都是标号，表示了内存的地址123456789101112131415161718192021</span><br></pre></td></tr></table></figure>

<p>在code段中使用的标号a，b后面没有：，因此他们可以同时描述内存地址和单元长度的标号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">cod segment</span><br><span class="line">    a db 1,2,3,4,5,6,7,8 ;描述了地址code：0，和从这个地址开始以后的内存单元都是直接单元</span><br><span class="line">    b dw 0 ;则b是code[8]</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">        mov si,0</span><br><span class="line">        mov cx,8</span><br><span class="line">    s:</span><br><span class="line">        mov al,a[si] ;相当于mov al,cs:0[si]</span><br><span class="line">        mov ah,0</span><br><span class="line">        add b,ax</span><br><span class="line">        inc si</span><br><span class="line"></span><br><span class="line">    loop s</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">1234567891011121314151617181920</span><br></pre></td></tr></table></figure>

<h2 id="检测点-16-1"><a href="#检测点-16-1" class="headerlink" title="检测点 16.1"></a>检测点 16.1</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB3/20170523225635283.jfif" alt="检测点16.1"></p>
<h2 id="16-2-在其他段中使用数据标号"><a href="#16-2-在其他段中使用数据标号" class="headerlink" title="16.2 在其他段中使用数据标号"></a>16.2 在其他段中使用数据标号</h2></li>
<li><p>注意：在后面加有：的地址标号只能在代码段中使用，不能在其他段中使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">cod segment</span><br><span class="line">a:db 1,2,3,4,5,6,7,8</span><br><span class="line">b:dw 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov si,0</span><br><span class="line">s:</span><br><span class="line">    mov al,a[si]</span><br><span class="line">    mov ah,0</span><br><span class="line">    add b,ax</span><br><span class="line">    inc si</span><br><span class="line"></span><br><span class="line">loop s</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start123456789101112131415161718192021</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果现在代码段中直接用数据标号访问数据，则需要用伪指令assume将标号所在的段和一个段寄存器联系起来。 我们可以将标号当作数据来定义，此时编译器将标号所表示的地址当作数据的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">    a db 1,2,3,4,5,6,7,8</span><br><span class="line">    b dw 0</span><br><span class="line">    c dw a,b</span><br><span class="line">    ;相当于 c dw offset a,offset b</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    a db 1,2,3,4,5,6,7,8</span><br><span class="line">    b dw 0</span><br><span class="line">    c dd a,b</span><br><span class="line">    ;相当于 c dw offset a,seg a,offset b,seg b</span><br><span class="line">    ;seg操作符，功能是取得某一标号的段地址</span><br><span class="line">data ends</span><br><span class="line">123456789101112131415</span><br></pre></td></tr></table></figure>

<h2 id="16-3-直接定址表"><a href="#16-3-直接定址表" class="headerlink" title="16.3 直接定址表"></a>16.3 直接定址表</h2></li>
<li><p>利用表，在两个数据集合之间建立一种映射关系，使我们可以利用查表的方法根据给出的数据得到其在另一集合中对应数据</p>
<ul>
<li>目的：<ol>
<li>为了算法的清晰和简洁</li>
<li>为了加快运算速度</li>
<li>为了使程序易于扩充</li>
</ol>
</li>
</ul>
</li>
<li><p>小练习，编写子程序，以十六进制的形式在屏幕中间显示给定的byte型数据。小技巧，利用映射关系，0-9数值+30h=对应字符的ascii值，10-15和A到F之间的银色关系是：数值+37h=对应字符的ascii的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code:segment</span><br><span class="line">    mov al,0eh</span><br><span class="line"></span><br><span class="line">    call showbyte</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21</span><br><span class="line">    ;子程序，用al传送要显示的数据</span><br><span class="line"></span><br><span class="line">showbyte:</span><br><span class="line">    jmp short show</span><br><span class="line"></span><br><span class="line">    table db &#39;1023456789ABCDEF&#39;;字符表</span><br><span class="line"></span><br><span class="line">show:</span><br><span class="line">    push bx</span><br><span class="line">    push es</span><br><span class="line"></span><br><span class="line">    mov ah,al</span><br><span class="line">    shr ah,1</span><br><span class="line">    shr ah,1</span><br><span class="line">    shr ah,1</span><br><span class="line">    shr ah,1;右移4位，ah中得到高4位的值</span><br><span class="line">    and al,00001111b;al中为低4位</span><br><span class="line"></span><br><span class="line">    mov bl,ah</span><br><span class="line">    mov bh,0</span><br><span class="line">    mov ah,table[bx];用高4位的值作为相对于table的便宜，取得对应的字符</span><br><span class="line"></span><br><span class="line">    mov bx,0b800h</span><br><span class="line">    mov es,bx</span><br><span class="line">    mov es:[160*12+40*2],ah</span><br><span class="line"></span><br><span class="line">    mov bl,al</span><br><span class="line">    mov bh,0</span><br><span class="line">    mov al,table[bx];用低4位的值作为相对于table的偏移，取得对应的字符</span><br><span class="line"></span><br><span class="line">    mov es:[160*12+40*2+2],al</span><br><span class="line"></span><br><span class="line">    pop es</span><br><span class="line">    pop bx</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start 12345678910111213141516171819202122232425262728293031323334353637383940414243444546</span><br></pre></td></tr></table></figure>

<h2 id="16-4-程序入口地址的直接定址表"><a href="#16-4-程序入口地址的直接定址表" class="headerlink" title="16.4 程序入口地址的直接定址表"></a>16.4 程序入口地址的直接定址表</h2></li>
<li><p>小练习</p>
<ol>
<li>清屏：将显存中当前屏幕中的支付设为空格；</li>
<li>设置前景色：设置显存中当前屏幕中处于奇地址的属性字节的第0、1、2位；</li>
<li>设置背景色：设置显存中当前屏幕中处于奇地址的属性字节的第4、5、6位；</li>
<li>向上滚动一行：依次将第n+行的内容复制到第n行处，最后一行为空。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;入口函数1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">;入口函数说明;</span><br><span class="line">;用ah传递功能号，0是清屏，1是设置前景色，2是设置背景色，3是向上滚动一行</span><br><span class="line"></span><br><span class="line">setscreen:</span><br><span class="line">        jmp short set</span><br><span class="line">        table dw sub1,sub2,sub3,sub4</span><br><span class="line"></span><br><span class="line">set:</span><br><span class="line">        push bx</span><br><span class="line">        cmp ah,3;判断传递的功能号是否大于3</span><br><span class="line">        ja sret</span><br><span class="line">        mov bl,ah</span><br><span class="line">        mov bh,0</span><br><span class="line">        add bx,bx;根据ah中的功能号计算对应子程序的地址在table表中的偏移</span><br><span class="line"></span><br><span class="line">        call word ptr table[bx];调用对应的子程序</span><br><span class="line"></span><br><span class="line">sret;</span><br><span class="line">        pop bx</span><br><span class="line">        iret</span><br><span class="line"></span><br><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;入口函数2&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">;入口函数说明;</span><br><span class="line">;用ah传递功能号，0是清屏，1是设置前景色，2是设置背景色，3是向上滚动一行</span><br><span class="line"></span><br><span class="line">setscreen:</span><br><span class="line">        cmp ah,0</span><br><span class="line">        je do1</span><br><span class="line">        cmp ah,1</span><br><span class="line">        je do2</span><br><span class="line">        cmp ah,2</span><br><span class="line">        je do3</span><br><span class="line">        cmp ah,3</span><br><span class="line">        je do4</span><br><span class="line"></span><br><span class="line">        jmp short sret</span><br><span class="line"></span><br><span class="line">do1:</span><br><span class="line">        call sub1</span><br><span class="line">        jmp short sret</span><br><span class="line"></span><br><span class="line">do2:</span><br><span class="line">        call sub2</span><br><span class="line">        jmp short sret</span><br><span class="line"></span><br><span class="line">do3:</span><br><span class="line">        call sub3</span><br><span class="line">        jmp short sret</span><br><span class="line"></span><br><span class="line">do4:</span><br><span class="line">        call sub4</span><br><span class="line">        jmp short sret</span><br><span class="line"></span><br><span class="line">;子功能&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">;清屏</span><br><span class="line">sub1:</span><br><span class="line">        push bx</span><br><span class="line">        push cx</span><br><span class="line">        push es</span><br><span class="line">        mov bx,0b800h</span><br><span class="line">        mov es,bx</span><br><span class="line">        mov bx,0</span><br><span class="line">        mov cx,2000</span><br><span class="line"></span><br><span class="line">sub1s:</span><br><span class="line">        mov byte ptr es:[bx],&#39;&#39;</span><br><span class="line">        add bx,2</span><br><span class="line">    loop sub1s</span><br><span class="line"></span><br><span class="line">        pop es</span><br><span class="line">        pop cx</span><br><span class="line">        pop bx</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">;设置前景色</span><br><span class="line">sub2:</span><br><span class="line">        push bx</span><br><span class="line">        push cx</span><br><span class="line">        push es</span><br><span class="line">        mov bx,0b800h</span><br><span class="line">        mov es,bx</span><br><span class="line">        mov bx,1</span><br><span class="line">        mov cx,2000</span><br><span class="line"></span><br><span class="line">sub2s:</span><br><span class="line">        mov byte ptr es:[bx],11111000b</span><br><span class="line">        or es:[bx],al</span><br><span class="line">        add bx,2</span><br><span class="line">    loop sub2s</span><br><span class="line"></span><br><span class="line">        pop es</span><br><span class="line">        pop cx</span><br><span class="line">        pop bx</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">;设置背景色</span><br><span class="line">sub3:</span><br><span class="line">        push bx</span><br><span class="line">        push cx</span><br><span class="line">        push es</span><br><span class="line">        mov cl,4</span><br><span class="line">        shl al,cl</span><br><span class="line">        mov bx,0b800h</span><br><span class="line">        mov es,bx</span><br><span class="line">        mov bx,1</span><br><span class="line">        mov cx,2000</span><br><span class="line"></span><br><span class="line">sub3s:</span><br><span class="line">        mov byte ptr es:[bx],10001111b</span><br><span class="line">        or es:[bx],al</span><br><span class="line">        add bx,2</span><br><span class="line">    loop sub3s</span><br><span class="line"></span><br><span class="line">        pop es</span><br><span class="line">        pop cx</span><br><span class="line">        pop bx</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">;向上滚动一行</span><br><span class="line">sub4:</span><br><span class="line">        push cx</span><br><span class="line">        push si</span><br><span class="line">        push di</span><br><span class="line">        push es</span><br><span class="line">        push ds</span><br><span class="line"></span><br><span class="line">        mov si,0b800h</span><br><span class="line">        mov es,si</span><br><span class="line">        mov ds,si</span><br><span class="line">        mov si,160;ds：si指向第n+行</span><br><span class="line">        mov di,0;es：di指向第n行</span><br><span class="line">        cld</span><br><span class="line">        mov cx,24;共复制24行</span><br><span class="line"></span><br><span class="line">sub4s:</span><br><span class="line">        push cx</span><br><span class="line">        mov cx,160</span><br><span class="line">        rep movsb;复制</span><br><span class="line">        pop cx</span><br><span class="line">    loop sub4s</span><br><span class="line"></span><br><span class="line">        mov cx,80</span><br><span class="line">        mov si,0</span><br><span class="line"></span><br><span class="line">sub4s1:</span><br><span class="line">        mov byte ptr es:[160*24+si],&#39;&#39;;最后一行清空</span><br><span class="line">        add si,2</span><br><span class="line">    loop sub4s1</span><br><span class="line"></span><br><span class="line">        pop ds</span><br><span class="line">        pop es</span><br><span class="line">        pop di</span><br><span class="line">        pop si</span><br><span class="line">        pop cx</span><br><span class="line">        ret;结束123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157</span><br></pre></td></tr></table></figure>

<h1 id="第十七章-使用BIOS进行键盘输入和磁盘读写"><a href="#第十七章-使用BIOS进行键盘输入和磁盘读写" class="headerlink" title="第十七章 使用BIOS进行键盘输入和磁盘读写"></a>第十七章 使用BIOS进行键盘输入和磁盘读写</h1></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/" class="post-title-link" itemprop="url">汇编语言基础学习汇总2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-01 22:12:43 / 修改时间：22:20:33" itemprop="dateCreated datePublished" datetime="2021-01-01T22:12:43+08:00">2021-01-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96/" itemprop="url" rel="index"><span itemprop="name">汇编</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>37k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>34 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><hr>
<h2 id="1、指令"><a href="#1、指令" class="headerlink" title="1、指令"></a>1、指令</h2><p>机器指令：CPU能直接识别并执行的二进制编码</p>
<p>汇编指令：汇编指令是机器指令的助记符，同机器指令一一对应。</p>
<p>指令：指令通常由操作码和地址码（操作数）两部分组成</p>
<p>指令集：每种CPU都有自己的汇编指令集。</p>
<p>汇编语言由3类指令组成。</p>
<ul>
<li>汇编指令</li>
<li>伪指令：没有对应的机器码，由编译器执行，计算机并不执行</li>
<li>其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码。</li>
</ul>
<p>编译器：够将汇编指令转换成机器指令的翻译程序每一种CPU都有自己的汇编指令集。<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20190320203829451.png" alt="在这里插入图片描述"><br>在内存或磁盘上，指令和数据没有任何区别，都是二进制信息</p>
<h2 id="2、存储器"><a href="#2、存储器" class="headerlink" title="2、存储器"></a>2、存储器</h2><p>随机存储器（RAM）在程序的执行过程中可读可写，必须带电存储</p>
<p>只读存储器（ROM）在程序的执行过程中只读，关机数据不丢失<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20200106154745358.png" alt="在这里插入图片描述"><br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20200106152920443.png" alt="在这里插入图片描述"><br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20200106153208896.png" alt="在这里插入图片描述"><br>（以上3张图片来自王道考研 - 计算机组成原理课件）</p>
<h2 id="3、总线"><a href="#3、总线" class="headerlink" title="3、总线"></a>3、总线</h2><hr>
<h3 id="1、总线"><a href="#1、总线" class="headerlink" title="1、总线"></a>1、总线</h3><p>总线是连接各个部件的信息传输线，是<code>各个部件共享的传输介质</code>。</p>
<p>主板上有核心器件和一些主要器件，这些器件通过总线（地址总线、数据总线、控制总线）相连。这些器件有<strong>CPU、存储器、外围芯片组、扩展插槽</strong>等。扩展插槽上一般插有RAM内存条和各类接口卡。<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20200106155015974.png" alt="来自唐朔飞·计算机组成原理经典课件"></p>
<p>总线根据位置分类：</p>
<ul>
<li><p>片内总线（芯片内部总线）</p>
</li>
<li><p>系统总线（计算机各部件之间的信息传输线）</p>
<p>根据传送信息的不同，系统总线从逻辑上又分为3类，地址总线、控制总线和数据总线。</p>
</li>
</ul>
<p>CPU要想进行数据的读写，必须和外部器件（标准的说法是芯片）进行以下3类信息的交互。</p>
<ol>
<li><strong>地址总线</strong>：CPU通过地址总线来指定存储单元<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20190320223809106.png" alt="在这里插入图片描述"><br>1根导线可以传送的稳定状态只有两种，高电平或是低电平。用二进制表示就是1或0</li>
</ol>
<p>图示有10根地址线即一次可以传输10位，访问存储单元地址为1011，寻址范围为0 ~ (210 - 1)</p>
<ol>
<li><strong>数据总线</strong>：CPU与内存或其他器件之间的数据传送是通过数据总线来进行的<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20190320223954446.png" alt="在这里插入图片描述"><br>8根数据线一次可传送一个8位二进制数据（即一个字节），传送2个字节需要两次；16根数据线一次可传送2个字节（内存对齐核心原理）</li>
<li><strong>控制总线</strong>：CPU对外部器件的控制是通过控制总线来进行的。</li>
</ol>
<p>有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。<br>所以，控制总线的宽度决定了CPU对外部器件的控制能力。</p>
<h3 id="2、CPU对存储器的读写"><a href="#2、CPU对存储器的读写" class="headerlink" title="2、CPU对存储器的读写"></a>2、CPU对存储器的读写</h3><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20190320224808472.png" alt="在这里插入图片描述"><br>1、 CPU通过地址线将地址信息3发出。<br>2、 CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。<br>3、 存储器将3号单元中的数据8通过数据线送入CPU。写操作与读操作的步骤相似。<br>联想：在组成原理中用微操作表示：(PC) → MAR; 1 → R; M(MAR) → MDR; …</p>
<h3 id="3、CPU对外设的控制"><a href="#3、CPU对外设的控制" class="headerlink" title="3、CPU对外设的控制"></a>3、CPU对外设的控制</h3><p>CPU对外设都不能直接控制，如显示器、音箱、打印机等。</p>
<p>直接控制这些设备进行工作的是插在扩展插槽上的接口卡。</p>
<p>扩展插槽通过总线和CPU相连，所以接口卡也通过总线同CPU相连。CPU可以直接控制这些接口卡，从而实现CPU对外设的间接控制。</p>
<p>如：CPU无法直接控制显示器，但CPU可以直接控制显卡，从而实现对显示器的间接控制</p>
<h2 id="4、内存地址空间"><a href="#4、内存地址空间" class="headerlink" title="4、内存地址空间"></a>4、内存地址空间</h2><p>CPU将系统中各类存储器看作一个逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间。<br>对于CPU，所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力限制。(或许就是计组中学的统一编址吧)<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20190320225301671.png" alt="在这里插入图片描述"><br>每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据（对ROM写无效）。<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20190320225820276.png" alt="在这里插入图片描述"></p>
<h1 id="二、寄存器"><a href="#二、寄存器" class="headerlink" title="二、寄存器"></a>二、寄存器</h1><hr>
<h2 id="1、寄存器"><a href="#1、寄存器" class="headerlink" title="1、寄存器"></a>1、寄存器</h2><p>CPU由运算器、控制器、寄存器等器件构成，这些器件靠片内总线相连。</p>
<p>运算器进行信息处理；控制器控制各种器件进行工作；寄存器进行信息存储；</p>
<p>8086CPU有14个寄存器：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW都是16位<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20190320231551626.png" alt="在这里插入图片描述"></p>
<p>16位结构CPU具有下面几方面的结构特性。</p>
<ul>
<li>运算器一次最多可以处理16位的数据；</li>
<li>寄存器的最大宽度为16位；</li>
<li>寄存器和运算器之间的通路为16位。</li>
</ul>
<p>8086CPU可以一次性处理以下两种尺寸的数据。</p>
<ul>
<li>字节：记为byte，一个字节由8个bit组成，可以存在8位寄存器中。</li>
<li>字：记为word，一个字由两个字节组成，可以存在一个16位寄存器中(16位CPU)<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20190320231904812.png" alt="在这里插入图片描述"><br>8086采用小端模式：高地址存放高位字节，低地址存放低位字节。</li>
</ul>
<h2 id="2、通用寄存器"><a href="#2、通用寄存器" class="headerlink" title="2、通用寄存器"></a>2、通用寄存器</h2><p><strong>通用寄存器</strong>：通常用来存放一般性的数据，有AX、BX、CX、DX，它们可分为两个可独立使用的8位寄存器，</p>
<table>
<thead>
<tr>
<th>16位</th>
<th>8高位</th>
<th>8低位</th>
</tr>
</thead>
<tbody><tr>
<td>AX</td>
<td>AH</td>
<td>AL</td>
</tr>
<tr>
<td>BX</td>
<td>BH</td>
<td>BL</td>
</tr>
<tr>
<td>CX</td>
<td>CH</td>
<td>CL</td>
</tr>
<tr>
<td>DX</td>
<td>DH</td>
<td>DL</td>
</tr>
</tbody></table>
<p>在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的</p>
<p>一个8位寄存器所能存储的数据范围是0 ~ 28-1。</p>
<h2 id="3、8086CPU给出物理地址的方法"><a href="#3、8086CPU给出物理地址的方法" class="headerlink" title="3、8086CPU给出物理地址的方法"></a>3、8086CPU给出物理地址的方法</h2><p>8086CPU有20位地址总线，可以传送20位地址，达到1MB寻址能力。<br>8086CPU又是16位结构，在内部一次性处理、传输、暂时存储的地址为16位。<br>从8086CPU的内部结构来看，如果将地址从内部简单地发出，那么它只能送出16位的地址，表现出的寻址能力只有64KB。<br>8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20190320232455205.png" alt="在这里插入图片描述"><br>当8086CPU要读写内存时：</p>
<ol>
<li>CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址；</li>
<li>地址加法器将两个16位地址合成为一个20位的物理地址；</li>
</ol>
<p>地址加法器采用物理地址 = 段地址×16 + 偏移地址的方法用段地址和偏移地址合成物理地址。</p>
<p>例如，8086CPU要访问地址为<code>123C8H</code>的内存单元，<code>1230H</code>左移一位(空出4位)加上<code>00C8H</code>合成<code>123C8H</code></p>
<h2 id="4、段寄存器"><a href="#4、段寄存器" class="headerlink" title="4、段寄存器"></a>4、段寄存器</h2><p>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元，可以用分段的方式来管理内存。</p>
<p>用一个段存放数据，将它定义为“数据段”；</p>
<p>用一个段存放代码，将它定义为“代码段”；</p>
<p>用一个段当作栈，将它定义为“栈段”。</p>
<p>注意：</p>
<ul>
<li>一个段的起始地址一定是16的倍数；</li>
<li>偏移地址为16位，变化范围为0-FFFFH，所以一个段的长度最大为64KB。</li>
<li>CPU可以用不同的段地址和偏移地址形成同一个物理地址。</li>
</ul>
<p>段寄存器：8086CPU有4个段寄存器：<code>CS、DS、SS、ES</code>，提供内存单元的段地址。</p>
<h3 id="1、CS和IP"><a href="#1、CS和IP" class="headerlink" title="1、CS和IP"></a>1、CS和IP</h3><p>CS为代码段寄存器，IP为指令指针寄存器，</p>
<p>CPU将CS、IP中的内容当作指令的段地址和偏移地址,用它们合成指令的物理地址,</p>
<p>CPU将CS:IP指向的内容当作指令执行。(即PC)<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20190321105503491.png" alt="在这里插入图片描述"><br>8086CPU的工作过程简要描述</p>
<ol>
<li>从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器；</li>
<li>IP=IP+所读取指令的长度，从而指向下一条指令；</li>
<li>执行指令。转到步骤1，重复这个过程。</li>
</ol>
<p>在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H，即在8086PC机刚启动时，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。</p>
<p>8086CPU提供转移指令修改CS、IP的内容。</p>
<ul>
<li>jmp 段地址:偏移地址：用指令中给出的段地址修改CS，偏移地址修改IP。如：<code>jmp 2AE3:3</code></li>
<li>jmp 某一合法寄存器：仅修改IP的内容。如：<code>jmp ax</code>。在含义上好似：<code>mov IP，ax</code></li>
</ul>
<p>8086CPU不支持将数据直接送入段寄存器的操作，这属于8086CPU硬件设计</p>
<h3 id="2、DS-和-address"><a href="#2、DS-和-address" class="headerlink" title="2、DS 和 [address]"></a>2、DS 和 [address]</h3><p>DS寄存器：通常用来存放要访问数据的段地址</p>
<p>[address]表示一个偏移地址为address的内存单元，段地址默认放在ds中</p>
<p>通过数据段段地址和偏移地址即可定位内存单元。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mov bx, <span class="number">1000</span>H ;<span class="number">8086</span>CPU不支持将数据直接送入段寄存器的操作</span><br><span class="line"></span><br><span class="line">mov ds, bx ;ds存放数据段地址</span><br><span class="line"></span><br><span class="line">mov [<span class="number">0</span>], al ;将al数据（<span class="number">1</span>字节）存到<span class="number">1000</span>H段的<span class="number">0</span>偏移地址处，即<span class="number">10000</span>H</span><br><span class="line"></span><br><span class="line">mov ax, [<span class="number">2</span>] ;将数据段偏移地址<span class="number">2</span>处的一个字（<span class="number">8086</span>为<span class="number">2</span>字节）存放到ax寄存器</span><br><span class="line"></span><br><span class="line">add cx, [<span class="number">4</span>] ;将偏移地址<span class="number">4</span>处的一个字数据加上cx寄存器数据放到cx寄存器</span><br><span class="line"></span><br><span class="line">sub dx, [<span class="number">6</span>] ;dx寄存器数据减去数据段偏移地址<span class="number">6</span>处的字数据存到dx</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<h3 id="3、SS-和-SP"><a href="#3、SS-和-SP" class="headerlink" title="3、SS 和 SP"></a>3、SS 和 SP</h3><p>在基于8086CPU编程的时候，可以将一段内存当作栈来使用。</p>
<p>栈段寄存器SS，存放段地址，SP寄存器存放偏移地址，任意时刻，<strong>SS:SP</strong>指向栈顶元素</p>
<p>8086CPU中，入栈时，栈顶从高地址向低地址方向增长。</p>
<p><code>push ax</code>表示将寄存器ax中的数据送入栈中，由两步完成。</p>
<ol>
<li>SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；</li>
<li>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20190321113400430.png" alt="在这里插入图片描述"></li>
</ol>
<p><code>pop ax</code>表示从栈顶取出数据送入ax，由以下两步完成。</p>
<ol>
<li>将SS:SP指向的内存单元处的数据送入ax中；</li>
<li>SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</li>
</ol>
<p><strong>实验</strong></p>
<ol>
<li>将10000H~1000FH这段空间当作栈，初始状态栈是空的；</li>
<li>设置AX=001AH，BX=001BH；</li>
<li>将AX、BX中的数据入栈；</li>
<li>然后将AX、BX清零；</li>
<li>从栈中恢复AX、BX原来的内容。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 1000H </span><br><span class="line">mov ss, ax </span><br><span class="line">mov sp, 0010H    ;初始化栈顶</span><br><span class="line">mov ax, 001AH</span><br><span class="line">mov bx, 001BH </span><br><span class="line"></span><br><span class="line">push ax </span><br><span class="line">push bx    ;ax、bx入栈</span><br><span class="line"></span><br><span class="line">sub ax, ax   ;将ax清零，也可以用mov ax，0，</span><br><span class="line">             ;sub ax，ax的机器码为2个字节，</span><br><span class="line">             ;mov ax，0的机器码为3个字节。</span><br><span class="line">        </span><br><span class="line">sub bx, bx </span><br><span class="line"></span><br><span class="line">pop bx  ;从栈中恢复ax、bx原来的数据</span><br><span class="line">pop ax  ;</span><br><span class="line">1234567891011121314151617</span><br></pre></td></tr></table></figure>

<h1 id="三、第一个程序"><a href="#三、第一个程序" class="headerlink" title="三、第一个程序"></a>三、第一个程序</h1><h2 id="1、汇编程序从写出到执行的过程"><a href="#1、汇编程序从写出到执行的过程" class="headerlink" title="1、汇编程序从写出到执行的过程"></a>1、汇编程序从写出到执行的过程</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20190321114839761.png" alt="在这里插入图片描述"><br>加载后，CPU的CS:IP指向程序的第一条指令（即程序的入口）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">;1.asm</span><br><span class="line">assume cs:codesg ;将用作代码段的段codesg和段寄存器cs联系起来。</span><br><span class="line"></span><br><span class="line">codesg segment ;定义一个段，段的名称为“codesg”，这个段从此开始</span><br><span class="line">			   ;codesg是一个标号，作为一个段的名称，最终被编译连接成一个段的段地址</span><br><span class="line"></span><br><span class="line">	mov ax, 0123H</span><br><span class="line">	mov bx, 0456H </span><br><span class="line">	add ax, bx</span><br><span class="line">	add ax, ax </span><br><span class="line">	</span><br><span class="line">	mov ax, 4c00H </span><br><span class="line">	int 21H ;这两条指令实现程序的返回</span><br><span class="line">	</span><br><span class="line">codesg ends ;名称为“codesg”的段到此结束</span><br><span class="line"></span><br><span class="line">end ;编译器在编译汇编程序的过程中，碰到了伪指令end，结束对源程序的编译</span><br><span class="line">1234567891011121314151617</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20190321115112266.png" alt="在这里插入图片描述"><br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20190321115301209.png" alt="在这里插入图片描述"></p>
<h2 id="2、程序执行过程跟踪"><a href="#2、程序执行过程跟踪" class="headerlink" title="2、程序执行过程跟踪"></a>2、程序执行过程跟踪</h2><p>DOS系统中.EXE文件中的程序的加载过程<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/2019032114041883.png" alt="在这里插入图片描述"></p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20190321141657458.png" alt="在这里插入图片描述"></p>
<hr>
<h1 id="四、-bx-和-loop指令"><a href="#四、-bx-和-loop指令" class="headerlink" title="四、[bx] 和 loop指令"></a>四、[bx] 和 loop指令</h1><hr>
<h2 id="1、-bx-和-loop指令"><a href="#1、-bx-和-loop指令" class="headerlink" title="1、[bx] 和 loop指令"></a>1、[bx] 和 loop指令</h2><p><code>[bx]</code> 的含义：[bx]同样表示一个内存单元，它的偏移地址在bx中，段地址默认在ds中</p>
<p><code>loop</code>指令的格式是：loop 标号，CPU执行loop指令的时候，要进行两步操作，</p>
<ol>
<li>(cx) = (cx) - 1；</li>
<li>判断 cx 中的值，不为零则转至标号处执行程序，如果为零则向下执行。</li>
</ol>
<p>例如：计算212</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code </span><br><span class="line"></span><br><span class="line">code segment </span><br><span class="line">	mov ax, 2</span><br><span class="line">	</span><br><span class="line">	mov cx, 11 ;循环次数</span><br><span class="line">s:  add ax, ax </span><br><span class="line">	loop s     ;在汇编语言中，标号代表一个地址，标号s实际上标识了一个地址，</span><br><span class="line">               ;这个地址处有一条指令：add ax，ax。</span><br><span class="line">               ;执行loop s时，首先要将（cx）减1，然后若（cx）不为0，则向前</span><br><span class="line">               ;转至s处执行add ax，ax。所以，可以利用cx来控制add ax，ax的执行次数。</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h </span><br><span class="line">	int 21h </span><br><span class="line">code ends </span><br><span class="line">end</span><br><span class="line">12345678910111213141516</span><br></pre></td></tr></table></figure>

<p><strong>loop 和 [bx] 的联合应用</strong></p>
<p>计算<code>ffff:0 ~ ffff:b</code>单元中的数据的和，结果存储在dx中</p>
<p>问题分析：</p>
<ol>
<li>这些内存单元都是字节型数据范围0 ~ 255 ，12个字节数据和不会超过65535，dx可以存下</li>
<li>对于8位数据不能直接加到 dx</li>
</ol>
<p>解决方案：</p>
<p>用一个16位寄存器来做中介。将内存单元中的8位数据赋值到一个16位寄存器a中，再将ax中的数据加到dx</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code </span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span> </span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0ffffh</span> <span class="comment">;在汇编源程序中，数据不能以字母开头，所以要在前面加0。</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span> </span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0</span>   <span class="comment">;初始化ds:bx指向ffff:0</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0</span>   <span class="comment">;初始化累加寄存器dx，（dx）= 0</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">12</span>  <span class="comment">;初始化循环计数寄存器cx，（cx）= 12</span></span><br><span class="line"><span class="symbol">s:</span>  <span class="keyword">mov</span> <span class="built_in">al</span>, [<span class="built_in">bx</span>]</span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">add</span> <span class="built_in">dx</span>, <span class="built_in">ax</span>  <span class="comment">;间接向dx中加上（（ds）* 16 +（bx））单元的数值</span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">bx</span>      <span class="comment">;ds:bx指向下一个单元</span></span><br><span class="line">	<span class="keyword">loop</span> s </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span> </span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span> </span><br><span class="line">code ends </span><br><span class="line">end</span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure>

<h2 id="2、段前缀"><a href="#2、段前缀" class="headerlink" title="2、段前缀"></a>2、段前缀</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">ds</span>:[<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">cs</span>:[<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">ss</span>:[<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">es</span>:[<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">ss</span>:[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">cs</span>:[<span class="number">0</span>]</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>这些出现在访问内存单元的指令中，用于显式地指明内存单元的段地址<br>的“ds:”，“cs:”，“ss:”，“es:”，在汇编语言中称为段前缀。</p>
<p><strong>段前缀的使用</strong></p>
<p>将内存<code>ffff:0 ~ ffff:b</code>单元中的数据复制到<code>0:200 ~ 0:20b</code>单元中。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code </span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span> </span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0ffffh</span> </span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span>   <span class="comment">;（ds）= 0ffffh </span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0020h</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span>   <span class="comment">;（es）= 0020h     0:200 等效于 0020:0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0</span>    <span class="comment">;（bx）= 0，此时ds:bx指向ffff:0，es:bx指向0020:0</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>，<span class="number">12</span>   <span class="comment">;（cx）=12，循环12次</span></span><br><span class="line"><span class="symbol">s:</span>  <span class="keyword">mov</span> <span class="built_in">dl</span>，[<span class="built_in">bx</span>] <span class="comment">;（d1）=（（ds）* 16+（bx）），将ffff:bx中的字节数据送入dl </span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>]，<span class="built_in">dl</span> <span class="comment">;（（es）*16+（bx））=（d1），将dl中的数据送入0020:bx </span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">bx</span>  <span class="comment">;（bx）=（bx）+1</span></span><br><span class="line">	<span class="keyword">loop</span> s </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>，<span class="number">4c00h</span> </span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span> </span><br><span class="line">code ends </span><br><span class="line">end</span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure>

<h1 id="五、包含多个段的程序"><a href="#五、包含多个段的程序" class="headerlink" title="五、包含多个段的程序"></a>五、包含多个段的程序</h1><p>程序中对段名的引用，将被编译器处理为一个表示段地址的数值。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, data </span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="built_in">ds</span>:[<span class="number">6</span>]</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>在代码段中使用数据</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;计算 8 个数据的和存到 ax 寄存器</span></span><br><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code </span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span> </span><br><span class="line"></span><br><span class="line">	<span class="built_in">dw</span> <span class="number">0123h</span>,<span class="number">0456h</span>,<span class="number">0789h</span>,<span class="number">0abch</span>,<span class="number">0defh</span>,<span class="number">0fedh</span>,<span class="number">0cbah</span>,<span class="number">0987h</span> <span class="comment">;define word 定义8个字形数据</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">	start:</span>	<span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0</span>  <span class="comment">;标号start</span></span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0</span>  </span><br><span class="line">			</span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">8</span></span><br><span class="line"><span class="symbol">	s:</span>		<span class="keyword">add</span> <span class="built_in">ax</span>, <span class="built_in">cs</span>:[<span class="built_in">bx</span>]</span><br><span class="line">			<span class="keyword">add</span> <span class="built_in">bx</span>, <span class="number">2</span></span><br><span class="line">			<span class="keyword">loop</span> s </span><br><span class="line">			</span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span> </span><br><span class="line">			<span class="keyword">int</span> <span class="number">21h</span> </span><br><span class="line">code ends</span><br><span class="line">end start    <span class="comment">;end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方</span></span><br><span class="line">	     	 <span class="comment">;用end指令指明了程序的入口在标号start处，也就是说，“mov bx，0”是程序的第一条指令。</span></span><br><span class="line"><span class="number">1234567891011121314151617181920</span></span><br></pre></td></tr></table></figure>

<p>在代码段中使用栈</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">;利用栈，将程序中定义的数据逆序存放。</span><br><span class="line">assume cs:codesg </span><br><span class="line"></span><br><span class="line">codesg segment </span><br><span class="line">	dw <span class="number">0123</span>h，<span class="number">0456</span>h，<span class="number">0789</span>h，<span class="number">0</span>abch，<span class="number">0</span>defh，<span class="number">0f</span>edh，<span class="number">0</span>cbah，<span class="number">0987</span>h ; <span class="number">0</span><span class="number">-15</span>单元</span><br><span class="line">	dw <span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span> ; <span class="number">16</span><span class="number">-47</span>单元作为栈使用</span><br><span class="line">			</span><br><span class="line">	start:	mov ax, cs </span><br><span class="line">			mov ss, ax </span><br><span class="line">			mov sp, <span class="number">30</span>h ;将设置栈顶ss:sp指向栈底cs:<span class="number">30</span>。   <span class="number">30</span>h = <span class="number">48</span>d</span><br><span class="line">			mov bx, <span class="number">0</span></span><br><span class="line">			</span><br><span class="line">			mov cx, <span class="number">8</span></span><br><span class="line">	s:		push cs:[bx]</span><br><span class="line">			add bx, <span class="number">2</span></span><br><span class="line">			loop s    ;以上将代码段<span class="number">0</span>~<span class="number">15</span>单元中的<span class="number">8</span>个字型数据依次入栈</span><br><span class="line">			</span><br><span class="line">			mov bx, <span class="number">0</span></span><br><span class="line">			</span><br><span class="line">			mov cx, <span class="number">8</span></span><br><span class="line">	s0:		pop cs:[bx]		</span><br><span class="line">			add bx，<span class="number">2</span></span><br><span class="line">			loop s0   ;以上依次出栈<span class="number">8</span>个字型数据到代码段<span class="number">0</span>~<span class="number">15</span>单元中</span><br><span class="line">			</span><br><span class="line">			mov ax，<span class="number">4</span>c00h </span><br><span class="line">			<span class="built_in">int</span> <span class="number">21</span>h </span><br><span class="line">codesg ends </span><br><span class="line">end start	;指明程序的入口在start处</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728</span></span><br></pre></td></tr></table></figure>

<p>将数据、代码、栈放入不同的段</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data,<span class="built_in">ss</span>:stack </span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span> </span><br><span class="line">	<span class="built_in">dw</span> <span class="number">0123h</span>,<span class="number">0456h</span>,<span class="number">0789h</span>,<span class="number">0abch</span>,<span class="number">0defh</span>,<span class="number">0fedh</span>,<span class="number">0cbah</span>,<span class="number">0987h</span> <span class="comment">;0-15单元</span></span><br><span class="line">data ends </span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span> </span><br><span class="line">	<span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> <span class="comment">;0-31单元</span></span><br><span class="line">stack ends </span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span> </span><br><span class="line"><span class="symbol">	start:</span>	<span class="keyword">mov</span> <span class="built_in">ax</span>, stack<span class="comment">;将名称为“stack”的段的段地址送入ax</span></span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">ss</span>, <span class="built_in">ax</span></span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">sp</span>, <span class="number">20h</span>  <span class="comment">;设置栈顶ss:sp指向stack:20。 20h = 32d</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">ax</span>, data <span class="comment">;将名称为“data”的段的段地址送入ax</span></span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span>   <span class="comment">;ds指向data段</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0</span>    <span class="comment">;ds:bx指向data段中的第一个单元</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">8</span></span><br><span class="line"><span class="symbol">	s:</span>	    <span class="keyword">push</span> [<span class="built_in">bx</span>]</span><br><span class="line">			<span class="keyword">add</span> <span class="built_in">bx</span>, <span class="number">2</span></span><br><span class="line">			<span class="keyword">loop</span> s       <span class="comment">;以上将data段中的0~15单元中的8个字型数据依次入栈</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">8</span></span><br><span class="line"><span class="symbol">	s0:</span>		<span class="keyword">pop</span> [<span class="built_in">bx</span>]</span><br><span class="line">			<span class="keyword">add</span> <span class="built_in">bx</span>, <span class="number">2</span></span><br><span class="line">			<span class="keyword">loop</span> s0      <span class="comment">;以上依次出栈8个字型数据到data段的0~15单元中</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span> </span><br><span class="line">			<span class="keyword">int</span> <span class="number">21h</span> </span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"><span class="comment">;“end start”说明了程序的入口，这个入口将被写入可执行文件的描述信息，</span></span><br><span class="line"><span class="comment">;可执行文件中的程序被加载入内存后，CPU的CS:IP被设置指向这个入口，从而开始执行程序中的第一条指令</span></span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738</span></span><br></pre></td></tr></table></figure>

<p>关于可执行文件结构与程序入口的详细描述参考：<a href="https://blog.csdn.net/qq_39654127/article/details/97905901" target="_blank" rel="noopener">PE文件结构</a></p>
<h1 id="六、更灵活的定位内存地址的方法"><a href="#六、更灵活的定位内存地址的方法" class="headerlink" title="六、更灵活的定位内存地址的方法"></a>六、更灵活的定位内存地址的方法</h1><hr>
<h2 id="1、and-和-or"><a href="#1、and-和-or" class="headerlink" title="1、and 和 or"></a>1、and 和 or</h2><p>and指令：逻辑与指令，按位进行与运算。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">01100011B</span><span class="string">`</span></span><br><span class="line"><span class="string">`and al, 00111011B</span></span><br></pre></td></tr></table></figure>

<p>执行后：<code>al=00100011B</code>即都为1才为1</p>
<p>or指令：逻辑或指令，按位进行或运算。</p>
<p><code>mov al, 01100011B</code><br><code>or al, 00111011B</code><br>执行后：<code>al=01111011B</code> 即只要有一个为1就为1</p>
<p><strong>关于ASCII码</strong><br>世界上有很多编码方案，有一种方案叫做ASCII编码，是在计算机系统中通常被采用的。简单地说，所谓编码方案，就是一套规则，它约定了用什么样的信息来表示现实对象。比如说，在ASCII编码方案中，用61H表示“a”，62H表示“b”。一种规则需要人们遵守才有意义。</p>
<p>在文本编辑过程中，我们按一下键盘的a键，就会在屏幕上看到“a”。我们按下键盘的a键，这个按键的信息被送入计算机，计算机用ASCII码的规则对其进行编码，将其转化为61H存储在内存的指定空间中；文本编辑软件从内存中取出61H，将其送到显卡上的显存中；工作在文本模式下的显卡，用ASCII码的规则解释显存中的内容，<br>61H被当作字符“a”，显卡驱动显示器，将字符“a”的图像画在屏幕上。我们可以看到，显卡在处理文本信息的时候，是按照ASCII码的规则进行的。这也就是说，如果我们要想在显示器上看到“a”，就要给显卡提供“a”的ASCIⅡ码，61H。如何提供？当然是写入显存中。</p>
<p><strong>以字符形式给出的数据</strong></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data </span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span> </span><br><span class="line">	<span class="built_in">db</span> <span class="string">'unIx'</span>   <span class="comment">;相当于“db 75H，6EH，49H，58H”</span></span><br><span class="line">	<span class="built_in">db</span> <span class="string">'foRK'</span></span><br><span class="line">data ends </span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>	<span class="keyword">mov</span> <span class="built_in">al</span>, <span class="string">'a'</span>  <span class="comment">;相当于“mov al, 61H”，“a”的ASCI码为61H；</span></span><br><span class="line">		<span class="keyword">mov</span> b1, <span class="string">'b'</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span> </span><br><span class="line">		<span class="keyword">int</span> <span class="number">21h</span> </span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<p><strong>大小写转换的问题</strong><br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20190321194022547.png" alt="在这里插入图片描述"><br>小写字母的ASCII码值比大写字母的ASCII码值大20H</p>
<p>大写字母ASCII码的第5位为0，小写字母的第5位为1(其他一致)</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg,<span class="built_in">ds</span>:datasg </span><br><span class="line"></span><br><span class="line">datasg <span class="meta">segment</span> </span><br><span class="line">	<span class="built_in">db</span> <span class="string">'BaSiC'</span></span><br><span class="line">	<span class="built_in">db</span> <span class="string">'iNfOrMaTion'</span></span><br><span class="line">datasg end</span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span> </span><br><span class="line"><span class="symbol">	start:</span>	<span class="keyword">mov</span> <span class="built_in">ax</span>, datasg </span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span>	<span class="comment">;设置ds 指向 datasg段</span></span><br><span class="line">		</span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0</span>	<span class="comment">;设置（bx）=0，ds:bx指向’BaSic’的第一个字母</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">5</span>     	 <span class="comment">;设置循环次数5，因为’Basic'有5个字母</span></span><br><span class="line"><span class="symbol">	s:</span>		<span class="keyword">mov</span> <span class="built_in">al</span>, [<span class="built_in">bx</span>]     <span class="comment">;将ASCII码从ds:bx所指向的单元中取出</span></span><br><span class="line">			<span class="keyword">and</span> <span class="built_in">al</span>, <span class="number">11011111B</span><span class="comment">;将al中的ASCII码的第5位置为0，变为大写字母</span></span><br><span class="line">			<span class="keyword">mov</span> [<span class="built_in">bx</span>], <span class="built_in">al</span>	 <span class="comment">;将转变后的ASCII码写回原单元</span></span><br><span class="line">			<span class="keyword">inc</span> <span class="built_in">bx</span>		     <span class="comment">;（bx）加1，ds:bx指向下一个字母</span></span><br><span class="line">			<span class="keyword">loop</span> s </span><br><span class="line">			</span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">5</span>	<span class="comment">;设置（bx）=5，ds:bx指向，iNfOrMaTion'的第一个字母</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">11</span>	<span class="comment">;设置循环次数11，因为‘iNfOrMaTion'有11个字母</span></span><br><span class="line"><span class="symbol">	s0:</span>		<span class="keyword">mov</span> <span class="built_in">al</span>, [<span class="built_in">bx</span>]</span><br><span class="line">			<span class="keyword">or</span> <span class="built_in">al</span>, <span class="number">00100000B</span><span class="comment">;将a1中的ASCII码的第5位置为1，变为小写字母</span></span><br><span class="line">			<span class="keyword">mov</span> [<span class="built_in">bx</span>], <span class="built_in">al</span> </span><br><span class="line">			<span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line">			<span class="keyword">loop</span> s0</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span> </span><br><span class="line">			<span class="keyword">int</span> <span class="number">21h</span> </span><br><span class="line">codesg ends</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132</span></span><br></pre></td></tr></table></figure>

<h2 id="2、-bx-idata"><a href="#2、-bx-idata" class="headerlink" title="2、[bx+idata]"></a>2、[bx+idata]</h2><p>[bx+idata]表示一个内存单元, 例如：<code>mov ax, [bx+200]</code><br>该指令也可以写成如下格式：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="number">200</span>+<span class="built_in">bx</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">200</span>[<span class="built_in">bx</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">bx</span>].<span class="number">200</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>用[bx+idata]的方式进行数组的处理</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg,<span class="built_in">ds</span>:datasg </span><br><span class="line"></span><br><span class="line">datasg <span class="meta">segment</span> </span><br><span class="line">	<span class="built_in">db</span> <span class="string">'BaSiC'</span><span class="comment">;转为大写</span></span><br><span class="line">	<span class="built_in">db</span> <span class="string">'MinIx'</span><span class="comment">;转为小写</span></span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"><span class="symbol">	start:</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ax</span>, datasg </span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span> </span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0</span>  <span class="comment">;初始ds:bx</span></span><br><span class="line">	</span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">5</span></span><br><span class="line"><span class="symbol">	s:</span>	<span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">0</span>[<span class="built_in">bx</span>]  </span><br><span class="line">		<span class="keyword">and</span> <span class="built_in">al</span>, <span class="number">11011111b</span> <span class="comment">;转为大写字母</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="number">0</span>[<span class="built_in">bx</span>], <span class="built_in">al</span> <span class="comment">;写回</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">5</span>[<span class="built_in">bx</span>]  <span class="comment">;[5 + bx]</span></span><br><span class="line">		<span class="keyword">or</span> <span class="built_in">al</span>, <span class="number">00100000b</span> <span class="comment">;转为小写字母</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="number">5</span>[<span class="built_in">bx</span>], <span class="built_in">al</span> </span><br><span class="line">		<span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line">		<span class="keyword">loop</span> s</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span> </span><br><span class="line">		<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627</span></span><br></pre></td></tr></table></figure>

<p>C语言描述</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> a[] = <span class="string">"BaSic"</span>;</span><br><span class="line">	<span class="keyword">char</span> b[] = <span class="string">"MinIX"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		a[i] = a[i] &amp; <span class="number">0xDF</span>;</span><br><span class="line">		b[i] = b[i] | <span class="number">0x20</span>;</span><br><span class="line">		i++;</span><br><span class="line">	&#125; <span class="keyword">while</span>(i &lt; <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>

<h2 id="3、SI-、DI-与-寻址方式的灵活应用"><a href="#3、SI-、DI-与-寻址方式的灵活应用" class="headerlink" title="3、SI 、DI 与 寻址方式的灵活应用"></a>3、SI 、DI 与 寻址方式的灵活应用</h2><p><strong>1、si 、di</strong></p>
<p>si和di是8086CPU中和bx功能相近的寄存器，si和di不能够分成两个8位寄存器来使用。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>: codesg, <span class="built_in">ds</span>: datasg </span><br><span class="line"></span><br><span class="line">datasg <span class="meta">segment</span> </span><br><span class="line">	<span class="built_in">db</span> <span class="string">'welcome to masm!'</span><span class="comment">;用si和di实现将字符串‘welcome to masm！"复制到它后面的数据区中。</span></span><br><span class="line">	<span class="built_in">db</span> <span class="string">'................'</span></span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span> </span><br><span class="line"><span class="symbol">	start:</span>	<span class="keyword">mov</span> <span class="built_in">ax</span>, datasg </span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span> </span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">si</span>, <span class="number">0</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">8</span></span><br><span class="line"><span class="symbol">	s:</span>		<span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0</span>[<span class="built_in">si</span>] <span class="comment">;[0 + si]</span></span><br><span class="line">			<span class="keyword">mov</span> <span class="number">16</span>[<span class="built_in">si</span>], <span class="built_in">ax</span> <span class="comment">;[16 + si] 使用[bx +idata]方式代替di，使程序更简洁</span></span><br><span class="line">			<span class="keyword">add</span> <span class="built_in">si</span>, <span class="number">2</span> </span><br><span class="line">			<span class="keyword">loop</span> s </span><br><span class="line">			</span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span> </span><br><span class="line">			<span class="keyword">int</span> <span class="number">21h</span> </span><br><span class="line">codesg ends </span><br><span class="line">end start</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure>

<p><strong>2、[bx + si] 和 [bx + di]</strong></p>
<p>[bx+si]和[bx+di]的含义相似</p>
<p>[bx+si]表示一个内存单元，它的偏移地址为（bx）+（si）</p>
<p>指令<code>mov ax, [bx + si]</code>的含义：将一个内存单元字数据的内容送入ax，段地址在ds中</p>
<p>该指令也可以写成如下格式：<code>mov ax, [bx][si]</code></p>
<p><strong>3、[bx+si+idata]和[bx+di+idata]</strong><br>[bx+si+idata]表示一个内存单元，它的偏移地址为（bx）+（si）+idata</p>
<p>指令<code>mov ax，[bx+si+idata]</code>的含义：将一个内存单元字数据的内容送入ax，段地址在ds中</p>
<p><strong>4、不同的寻址方式的灵活应用</strong><br><code>[idata]</code>用一个常量来表示地址，可用于直接定位一个内存单元；<br><code>[bx]</code>用一个变量来表示内存地址，可用于间接定位一个内存单元；<br><code>[bx+idata]</code>用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；<br><code>[bx+si]</code>用两个变量表示地址；<br><code>[bx+si+idata]</code>用两个变量和一个常量表示地址。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;将datasg段中每个单词改为大写字母</span></span><br><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg,<span class="built_in">ds</span>:datasg,<span class="built_in">ss</span>:stacksg </span><br><span class="line"></span><br><span class="line">datasg <span class="meta">segment</span></span><br><span class="line">	<span class="built_in">db</span> <span class="string">'ibm            '</span> <span class="comment">;16</span></span><br><span class="line">	<span class="built_in">db</span> <span class="string">'dec            '</span> </span><br><span class="line">	<span class="built_in">db</span> <span class="string">'dos            '</span></span><br><span class="line">	<span class="built_in">db</span> <span class="string">'vax            '</span>  <span class="comment">;看成二维数组</span></span><br><span class="line">datasg ends </span><br><span class="line"></span><br><span class="line">stacksg <span class="meta">segment</span> <span class="comment">;定义一个段，用来做栈段，容量为16个字节</span></span><br><span class="line">	<span class="built_in">dw</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">stacksg ends </span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span> </span><br><span class="line"><span class="symbol">	start:</span>	<span class="keyword">mov</span> <span class="built_in">ax</span>, stacksg </span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">ss</span>, <span class="built_in">ax</span></span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">sp</span>, <span class="number">16</span> </span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">ax</span>, datasg </span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span> </span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0</span> <span class="comment">;初始ds:bx</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">;cx为默认循环计数器，二重循环只有一个计数器，所以外层循环先保存cx值，再恢复，我们采用栈保存</span></span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">4</span></span><br><span class="line"><span class="symbol">	s0:</span>		<span class="keyword">push</span> <span class="built_in">cx</span>	<span class="comment">;将外层循环的cx值入栈</span></span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">si</span>, <span class="number">0</span></span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">3</span>	<span class="comment">;cx设置为内层循环的次数</span></span><br><span class="line"><span class="symbol">	s:</span>		<span class="keyword">mov</span> <span class="built_in">al</span>, [<span class="built_in">bx</span>+<span class="built_in">si</span>]</span><br><span class="line">			<span class="keyword">and</span> <span class="built_in">al</span>, <span class="number">11011111b</span> <span class="comment">;每个字符转为大写字母</span></span><br><span class="line">			<span class="keyword">mov</span> [<span class="built_in">bx</span>+<span class="built_in">si</span>], <span class="built_in">al</span> </span><br><span class="line">			<span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">			<span class="keyword">loop</span> s </span><br><span class="line">			</span><br><span class="line">			<span class="keyword">add</span> <span class="built_in">bx</span>, <span class="number">16</span> <span class="comment">;下一行</span></span><br><span class="line">			<span class="keyword">pop</span> <span class="built_in">cx</span>	<span class="comment">;恢复cx值</span></span><br><span class="line">			<span class="keyword">loop</span> s0 <span class="comment">;外层循环的loop指令将cx中的计数值减1</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">mov</span> <span class="built_in">ax</span>，<span class="number">4c00H</span> </span><br><span class="line">			<span class="keyword">int</span> <span class="number">21H</span> </span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142</span></span><br></pre></td></tr></table></figure>

<h1 id="七、数据处理的两个基本问题"><a href="#七、数据处理的两个基本问题" class="headerlink" title="七、数据处理的两个基本问题"></a>七、数据处理的两个基本问题</h1><h2 id="1、-bx、si、di和bp"><a href="#1、-bx、si、di和bp" class="headerlink" title="1、 bx、si、di和bp"></a>1、 bx、si、di和bp</h2><p>在8086CPU中，只有这4个寄存器可以用在“[…]”中来进行内存单元的寻址。</p>
<p>在[ ]中，这4个寄存器可以单个出现，或只能以4种组合出现：<code>bx和si、bx和di</code>、<code>bp和si、bp和di</code>。</p>
<p>只要在[……]中使用寄存器bp，而指令中没有显性地给出段地址, 段地址就默认在ss中</p>
<h2 id="2、机器指令处理的数据在什么地方"><a href="#2、机器指令处理的数据在什么地方" class="headerlink" title="2、机器指令处理的数据在什么地方"></a>2、机器指令处理的数据在什么地方</h2><p>数据处理大致可分为3类：读取、写入、运算。</p>
<p>在机器指令这一层来讲，并不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置。指令在执行前，所要处理的数据可以在3个地方：CPU内部、内存、端口<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/2019032120283492.png" alt="在这里插入图片描述"></p>
<h2 id="3、汇编语言中数据位置的表达"><a href="#3、汇编语言中数据位置的表达" class="headerlink" title="3、汇编语言中数据位置的表达"></a>3、汇编语言中数据位置的表达</h2><p>汇编语言中用3个概念来表达数据的位置</p>
<ul>
<li>立即数（idata）</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">1</span>                 <span class="comment">;对于直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中）</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>, <span class="number">2000h</span>             <span class="comment">;在汇编语言中称为：立即数（idata）</span></span><br><span class="line"><span class="keyword">or</span> <span class="built_in">bx</span>, <span class="number">00010000b</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="string">'a'</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<ul>
<li>寄存器</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">bx</span>     <span class="comment">;指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span> </span><br><span class="line"><span class="keyword">push</span> <span class="built_in">bx</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">0</span>], <span class="built_in">bx</span> </span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ds</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ss</span>, <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span>, <span class="built_in">ax</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<ul>
<li>段地址（SA）和偏移地址（EA）</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;指令要处理的数据在内存中，在汇编指令中可用[X]的格式给出EA，SA在某个段寄存器中。</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="number">0</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">di</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">bx</span>+<span class="number">8</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">bx</span>+<span class="built_in">si</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">bx</span>+<span class="built_in">si</span>+<span class="number">8</span>]   <span class="comment">;以上段地址默认在ds中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">bp</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">bp</span>+<span class="number">8</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">bp</span>+<span class="built_in">si</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">bp</span>+<span class="built_in">si</span>+<span class="number">8</span>]   <span class="comment">;以上段地址默认在ss中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">ds</span>:[<span class="built_in">bp</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">es</span>:[<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">ss</span>:[<span class="built_in">bx</span>+<span class="built_in">si</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">cs</span>:[<span class="built_in">bx</span>+<span class="built_in">si</span>+<span class="number">8</span>] <span class="comment">;显式给出存放段地址的寄存器</span></span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>

<p>寻址方式<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20190321213006102.png" alt="在这里插入图片描述"></p>
<h2 id="4、指令要处理的数据有多长"><a href="#4、指令要处理的数据有多长" class="headerlink" title="4、指令要处理的数据有多长"></a>4、指令要处理的数据有多长</h2><p>8086CPU的指令，可以处理两种尺寸的数据，byte和word</p>
<ol>
<li>通过寄存器名指明要处理的数据的尺寸。<br>例如： <code>mov al, ds:[0]</code> 寄存器al指明了数据为1字节</li>
<li>在没有寄存器名存在的情况下，用操作符<code>X ptr</code>指明内存单元的长度，X在汇编指令中可以为<code>word</code>或<code>byte</code>。<br>例如：<code>mov byte ptr ds:[0], 1</code> byte ptr 指明了指令访问的内存单元是一个字节单元</li>
<li>有些指令默认了访问的是字单元还是字节单元<br>例如，<code>push [1000H]</code>，push 指令只进行字操作。</li>
</ol>
<h2 id="5、寻址方式的综合应用"><a href="#5、寻址方式的综合应用" class="headerlink" title="5、寻址方式的综合应用"></a>5、寻址方式的综合应用</h2><p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20190321215930774.png" alt="在这里插入图片描述"></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">seg</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">60h</span>   <span class="comment">;确定记录地址，ds:bx </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>+<span class="number">0ch</span>], <span class="number">38</span>   <span class="comment">;排名字段改为38  [bx].0ch</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>+<span class="number">0eh</span>], <span class="number">70</span>   <span class="comment">;收入字段增加70  [bx].0eh</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">si</span>, <span class="number">0</span>   <span class="comment">;用si来定位产品字符串中的字符</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>+<span class="number">10h</span>+<span class="built_in">si</span>], <span class="string">'V'</span>   <span class="comment">;[bx].10h[si]</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">si</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>+<span class="number">10h</span>+<span class="built_in">si</span>], <span class="string">'A'</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">si</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>+<span class="number">10h</span>+<span class="built_in">si</span>], <span class="string">'X'</span></span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<p>C语言描述</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定义一个公司记录的结构体*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">company</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> cn[<span class="number">3</span>];<span class="comment">/*公司名称*/</span></span><br><span class="line">    <span class="keyword">char</span> hn[<span class="number">9</span>];<span class="comment">/*总裁姓名*/</span></span><br><span class="line">    <span class="keyword">int</span> pm;<span class="comment">/*排名*/</span></span><br><span class="line">    <span class="keyword">int</span> sr;<span class="comment">/*收入*/</span></span><br><span class="line">    <span class="keyword">char</span> cp[<span class="number">3</span>];<span class="comment">/*著名产品*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//sizeof (struct company) == 24</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*定义一个公司记录的变量，内存中将存有一条公司的记录*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">company</span> <span class="title">dec</span> = &#123;</span><span class="string">"DEC"</span>, <span class="string">"Ken Olsen"</span>, <span class="number">137</span>, <span class="number">40</span>, <span class="string">"PDP"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    dec.pm = <span class="number">38</span>;</span><br><span class="line">    dec.sr = dec.sr + <span class="number">70</span>;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    dec.cp[i] = <span class="string">'V'</span>; <span class="comment">//mov byte ptr [bx].10h[si], 'V'</span></span><br><span class="line">    i++;</span><br><span class="line">    dec.cp[i] = <span class="string">'A'</span>;</span><br><span class="line">    i++;</span><br><span class="line">    dec.cp[i] = <span class="string">'X'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031</span></span><br></pre></td></tr></table></figure>

<h2 id="6、div指令、dd、dup、mul指令"><a href="#6、div指令、dd、dup、mul指令" class="headerlink" title="6、div指令、dd、dup、mul指令"></a>6、div指令、dd、dup、mul指令</h2><p><strong>div是除法指令</strong></p>
<ol>
<li>除数：有8位和16位两种，在一个<code>寄存器</code>或<code>内存单元</code>中。</li>
<li>被除数：默认放在<code>AX</code>或<code>DX和AX</code>中，<br>如果除数为8位，被除数则为16位，默认在AX中存放；<br>如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。</li>
<li>结果：<br>如果除数为8位，则<code>AL存储除法操作的商</code>，<code>AH存储除法操作的余数</code>；<br>如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">;利用除法指令计算<span class="number">100001</span>/<span class="number">100</span>。</span><br><span class="line">;<span class="number">100001</span>D = <span class="number">186</span>A1H</span><br><span class="line">mov dx, <span class="number">1</span></span><br><span class="line">mov ax, <span class="number">86</span>A1H ;(dx)*<span class="number">10000</span>H+(ax)=<span class="number">100001</span></span><br><span class="line">mov bx, <span class="number">100</span></span><br><span class="line">div bx</span><br><span class="line"></span><br><span class="line">;利用除法指令计算<span class="number">1001</span>/<span class="number">100</span></span><br><span class="line">mov ax, <span class="number">1001</span></span><br><span class="line">mov bl, <span class="number">100</span></span><br><span class="line">div b1</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<p><strong>伪指令dd</strong></p>
<p>db和dw定义字节型数据和字型数据。</p>
<p>dd是用来定义dword（double word，双字）型数据的伪指令</p>
<p><strong>操作符dup</strong></p>
<p>dup在汇编语言中同db、dw、dd等一样，也是由编译器识别处理的符号。<br>它和db、dw、dd等数据定义伪指令配合使用，用来进行数据的重复</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db <span class="number">3</span> dup (<span class="number">0</span>)       ;定义了<span class="number">3</span>个字节，它们的值都是<span class="number">0</span>，相当于db <span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>。</span><br><span class="line">db <span class="number">3</span> dup (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>) ;定义了<span class="number">9</span>个字节，它们是<span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>、<span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>、<span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>，相当于db <span class="number">0</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">0</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">0</span>，<span class="number">1</span>，<span class="number">2</span>。</span><br><span class="line">db <span class="number">3</span> dup ('abc', 'ABC') ;定义了<span class="number">18</span>个字节，它们是abcABCabcABCabcABCC，相当于db 'abc', 'ABC' ,'abc' , 'ABC, 'abc', 'ABC'。</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p><strong>mul 指令</strong></p>
<p>mul是乘法指令，使用 mul 做乘法的时候：相乘的两个数：要么都是8位，要么都是16位。</p>
<ul>
<li>8 位： <code>AL</code>中和 <code>8位寄存器</code>或<code>内存字节单元</code>中；</li>
<li>16 位： <code>AX</code>中和 <code>16 位寄存器</code>或<code>内存字单元</code>中。</li>
</ul>
<p>结果</p>
<ul>
<li>8位：AX中；</li>
<li>16位：DX（高位）和 AX（低位）中。</li>
</ul>
<p>格式：<code>mul 寄存器</code> 或 <code>mul 内存单元</code></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">;计算<span class="number">100</span>*<span class="number">10</span></span><br><span class="line">;<span class="number">100</span>和<span class="number">10</span>小于<span class="number">255</span>，可以做<span class="number">8</span>位乘法</span><br><span class="line">mov al,<span class="number">100</span></span><br><span class="line">mov bl,<span class="number">10</span></span><br><span class="line">mul bl</span><br><span class="line"></span><br><span class="line">;结果： (ax)=<span class="number">1000</span>（<span class="number">03E8</span>H） </span><br><span class="line"></span><br><span class="line"><span class="number">12345678</span></span><br><span class="line">;计算<span class="number">100</span>*<span class="number">10000</span></span><br><span class="line">;<span class="number">100</span>小于<span class="number">255</span>，可<span class="number">10000</span>大于<span class="number">255</span>，所以必须做<span class="number">16</span>位乘法，程序如下：</span><br><span class="line">mov ax,<span class="number">100</span></span><br><span class="line">mov bx,<span class="number">10000</span></span><br><span class="line">mul bx</span><br><span class="line"></span><br><span class="line">;结果： (ax)=<span class="number">4240</span>H，(dx)=<span class="number">000</span>FH     （F4240H=<span class="number">1000000</span>）</span><br><span class="line"></span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<h1 id="八、转移指令的原理"><a href="#八、转移指令的原理" class="headerlink" title="八、转移指令的原理"></a>八、转移指令的原理</h1><hr>
<p>可以修改IP，或同时修改CS和IP的指令统称为转移指令。概括地讲，转移指令就是可以控制CPU执行内存中某处代码的指令。</p>
<p>8086CPU的转移行为有以下几类。</p>
<ul>
<li>只修改IP时，称为<code>段内转移</code>，比如：<code>jmp ax</code>。</li>
<li>同时修改CS和IP时，称为<code>段间转移</code>，比如：<code>jmp 1000:0</code>。</li>
</ul>
<p>由于转移指令对IP的修改范围不同，段内转移又分为：<code>短转移和近转移</code>。</p>
<ul>
<li>短转移IP的修改范围为<code>-128 ~ 127</code>。</li>
<li>近转移IP的修改范围为<code>-32768 ~ 32767</code>。</li>
</ul>
<p>8086CPU的转移指令分为以下几类。</p>
<ul>
<li>无条件转移指令（如：jmp）</li>
<li>条件转移指令</li>
<li>循环指令（如：loop）</li>
<li>过程</li>
<li>中断</li>
</ul>
<h2 id="1、操作符offset"><a href="#1、操作符offset" class="headerlink" title="1、操作符offset"></a>1、操作符offset</h2><p>操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;将s处的一条指令复制到s0处</span></span><br><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg</span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"><span class="symbol"> s:</span>   <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">bx</span>           <span class="comment">;（mov ax,bx 的机器码占两个字节）</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">si</span>, offset s     <span class="comment">;获得标号s的偏移地址</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">di</span>, offset s0    <span class="comment">;获得标号s0的偏移地址</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">cs</span>:[<span class="built_in">si</span>]</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cs</span>:[<span class="built_in">di</span>], <span class="built_in">ax</span></span><br><span class="line"><span class="symbol"> s0:</span>  <span class="keyword">nop</span>                     <span class="comment">;（nop的机器码占一个字节）</span></span><br><span class="line">      <span class="keyword">nop</span></span><br><span class="line"> codesg ends</span><br><span class="line"> ends</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<h2 id="2、jmp指令"><a href="#2、jmp指令" class="headerlink" title="2、jmp指令"></a>2、jmp指令</h2><p>jmp为无条件转移，转到标号处执行指令可以只修改IP，也可以同时修改CS和IP；</p>
<p>jmp指令要给出两种信息：</p>
<ul>
<li><p>转移的目的地址</p>
</li>
<li><p>转移的距离（段间转移、段内短转移，段内近转移）</p>
<p><code>jmp short 标号</code> <code>jmp near ptr 标号</code> <code>jcxz 标号</code> <code>loop 标号</code> 等几种汇编指令，它们对 IP的修改</p>
</li>
</ul>
<p>是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移距离。</p>
<h3 id="1、依据位移进行转移的jmp指令"><a href="#1、依据位移进行转移的jmp指令" class="headerlink" title="1、依据位移进行转移的jmp指令"></a>1、依据位移进行转移的jmp指令</h3><p><code>jmp short 标号</code>（段内短转移）</p>
<p>指令“<code>jmp short 标号</code>”的功能为<code>(IP)=(IP)+8位位移</code>，转到标号处执行指令</p>
<p>（1）8位位移 = “标号”处的地址 - jmp指令后的第一个字节的地址；</p>
<p>（2）short指明此处的位移为8位位移；</p>
<p>（3）8位位移的范围为-128~127，用补码表示</p>
<p>（4）8位位移由编译程序在编译时算出。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg</span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"><span class="symbol">  start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">jmp</span> short s <span class="comment">;s不是被翻译成目的地址</span></span><br><span class="line">        <span class="keyword">add</span> <span class="built_in">ax</span>, <span class="number">1</span></span><br><span class="line"><span class="symbol">      s:</span><span class="keyword">inc</span> <span class="built_in">ax</span> <span class="comment">;程序执行后， ax中的值为 1 </span></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p>CPU不需要这个目的地址就可以实现对IP的修改。这里是依据位移进行转移</p>
<p><strong>jmp short s指令的读取和执行过程：</strong></p>
<ol>
<li>(CS)=0BBDH，(IP)=0006，上一条指令执行结束后CS:IP指向EB 03（jmp short s的机器码）；</li>
<li>读取指令码EB 03进入指令缓冲器；</li>
<li>(IP) = (IP) + 所读取指令的长度 = (IP) + 2 = 0008，CS:IP指向add ax,1；</li>
<li>CPU指行指令缓冲器中的指令EB 03；</li>
<li>指令EB 03执行后，(IP)=000BH，CS:IP指向inc ax</li>
</ol>
<p><code>jmp near ptr 标号</code> （段内近转移）</p>
<p>指令“<code>jmp near ptr 标号</code>”的功能为：<code>(IP) = (IP) + 16位位移</code>。</p>
<h3 id="2、转移的目的地址在指令中的jmp指令"><a href="#2、转移的目的地址在指令中的jmp指令" class="headerlink" title="2、转移的目的地址在指令中的jmp指令"></a>2、转移的目的地址在指令中的jmp指令</h3><p><code>jmp far ptr 标号</code>（段间转移或远转移）</p>
<p>指令 “<code>jmp far ptr 标号</code>” 功能如下：</p>
<ul>
<li>(CS) = 标号所在段的段地址；</li>
<li>(IP) = 标号所在段中的偏移地址。</li>
<li>far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg</span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"><span class="symbol">   start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0</span></span><br><span class="line">		  <span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0</span></span><br><span class="line">          <span class="keyword">jmp</span> <span class="built_in">far</span> <span class="built_in">ptr</span>  s <span class="comment">;s被翻译成转移的目的地址0B01 BD0B</span></span><br><span class="line">          <span class="built_in">db</span> <span class="number">256</span> dup (<span class="number">0</span>) <span class="comment">;转移的段地址：0BBDH，偏移地址：010BH</span></span><br><span class="line"><span class="symbol">    s:</span>    <span class="keyword">add</span> <span class="built_in">ax</span>,<span class="number">1</span></span><br><span class="line">          <span class="keyword">inc</span> <span class="built_in">ax</span></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20190322151439754.png" alt="在这里插入图片描述"></p>
<h3 id="3、转移地址在寄存器或内存中的jmp指令"><a href="#3、转移地址在寄存器或内存中的jmp指令" class="headerlink" title="3、转移地址在寄存器或内存中的jmp指令"></a>3、转移地址在寄存器或内存中的jmp指令</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp <span class="number">16</span>位寄存器` 功能：`IP =（<span class="number">16</span>位寄存器）</span><br></pre></td></tr></table></figure>

<p>转移地址在内存中的jmp指令有两种格式：</p>
<ul>
<li><code>jmp word ptr 内存单元地址</code>（段内转移）</li>
</ul>
<p>功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0123H</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">0</span>], <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">jmp</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line"><span class="comment">;执行后，(IP)=0123H</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>jmp dword ptr 内存单元地址</code>（段间转移）</li>
</ul>
<p>功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。</p>
<ol>
<li>(CS)=(内存单元地址+2)</li>
<li>(IP)=(内存单元地址)</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0123H</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">0</span>], <span class="built_in">ax</span><span class="comment">;偏移地址</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">2</span>], <span class="number">0</span><span class="comment">;段地址</span></span><br><span class="line"><span class="keyword">jmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line"><span class="comment">;执行后，</span></span><br><span class="line"><span class="comment">;(CS)=0</span></span><br><span class="line"><span class="comment">;(IP)=0123H</span></span><br><span class="line"><span class="comment">;CS:IP 指向 0000:0123。</span></span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<h3 id="4、jcxz指令和loop指令"><a href="#4、jcxz指令和loop指令" class="headerlink" title="4、jcxz指令和loop指令"></a>4、jcxz指令和loop指令</h3><p><strong>jcxz指令</strong></p>
<p>jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，</p>
<p>在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127。</p>
<p>指令格式：<code>jcxz 标号</code>（如果(cx)=0，则转移到标号处执行。）</p>
<p>当(cx) = 0时，(IP) = (IP) + 8位位移</p>
<ul>
<li>8位位移 = “标号”处的地址 - jcxz指令后的第一个字节的地址；</li>
<li>8位位移的范围为-128~127，用补码表示；</li>
<li>8位位移由编译程序在编译时算出。</li>
</ul>
<p>当(cx)!=0时，什么也不做（程序向下执行）</p>
<p><strong>loop指令</strong></p>
<p>loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。</p>
<p>对IP的修改范围都为-128~127。</p>
<p>指令格式：<code>loop 标号</code> ((cx) = (cx) - 1，如果(cx) ≠ 0，转移到标号处执行)。</p>
<p>(cx) = (cx) - 1；如果 (cx) != 0，(IP) = (IP) + 8位位移。</p>
<ul>
<li>8位位移 = 标号处的地址 - loop指令后的第一个字节的地址；</li>
<li>8位位移的范围为-128~127，用补码表示；</li>
<li>8位位移由编译程序在编译时算出。</li>
</ul>
<p>如果（cx）= 0，什么也不做（程序向下执行）。</p>
<h1 id="九、call和ret指令"><a href="#九、call和ret指令" class="headerlink" title="九、call和ret指令"></a>九、call和ret指令</h1><hr>
<p>call和ret指令都是转移指令，它们都修改IP，或同时修改CS和IP。</p>
<h2 id="1、ret-和-retf"><a href="#1、ret-和-retf" class="headerlink" title="1、ret 和 retf"></a>1、ret 和 retf</h2><ul>
<li>ret指令用栈中的数据，修改IP的内容，从而实现近转移；</li>
<li>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。</li>
</ul>
<p>CPU执行ret指令时，相当于进行： <code>pop IP</code>：</p>
<p>（1）(IP) = ( (ss) * 16 + (sp) )</p>
<p>（2）(sp) = (sp) + 2</p>
<p>CPU执行retf指令时，相当于进行：<code>pop IP, pop CS</code>：</p>
<p>（1）(IP) = ( (ss) * 16 + (sp) )</p>
<p>（2）(sp) = (sp) + 2</p>
<p>（3）(CS) = ( (ss) * 16 + (sp) )</p>
<p>（4）(sp) = (sp) + 2</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code </span><br><span class="line">stack seqment</span><br><span class="line">	<span class="built_in">db</span> <span class="number">16</span> dup (<span class="number">0</span>)</span><br><span class="line">stack ends </span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span></span><br><span class="line">		<span class="keyword">int</span> <span class="number">21h</span> </span><br><span class="line"><span class="symbol"> start:</span>	<span class="keyword">mov</span> <span class="built_in">ax</span>, stack </span><br><span class="line"> 		<span class="keyword">mov</span> <span class="built_in">ss</span>, <span class="built_in">ax</span></span><br><span class="line"> 		<span class="keyword">mov</span> <span class="built_in">sp</span>, <span class="number">16</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0</span></span><br><span class="line">		<span class="keyword">push</span> <span class="built_in">ax</span> <span class="comment">;ax入栈</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0</span></span><br><span class="line">		<span class="keyword">ret</span> <span class="comment">;ret指令执行后，(IP)=0，CS:IP指向代码段的第一条指令。可以push cs  push ax  retf</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>

<h2 id="2、call-指令"><a href="#2、call-指令" class="headerlink" title="2、call 指令"></a>2、call 指令</h2><p>call指令经常跟ret指令配合使用，因此CPU执行call指令，进行两步操作：</p>
<p>（1）将当前的 IP 或 CS和IP 压入栈中；</p>
<p>（2）转移（jmp）。</p>
<p>call指令不能实现短转移，除此之外，call指令实现转移的方法和 jmp 指令的原理相同。</p>
<p><code>call 标号</code>（近转移）</p>
<p>CPU执行此种格式的call指令时，相当于进行 <code>push IP</code> <code>jmp near ptr 标号</code></p>
<p><code>call far ptr 标号</code>（段间转移）</p>
<p>CPU执行此种格式的call指令时，相当于进行：<code>push CS，push IP</code> <code>jmp far ptr 标号</code></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call <span class="number">16</span>位寄存器</span><br></pre></td></tr></table></figure>

<p>CPU执行此种格式的call指令时，相当于进行： <code>push IP</code> <code>jmp 16位寄存器</code></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> <span class="built_in">word</span> <span class="built_in">ptr</span> 内存单元地址</span><br></pre></td></tr></table></figure>

<p>CPU执行此种格式的call指令时，相当于进行：<code>push IP</code> <code>jmp word ptr 内存单元地址</code></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span>, <span class="number">10h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0123h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">0</span>], <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">call</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line"><span class="comment">;执行后，(IP)=0123H，(sp)=0EH</span></span><br><span class="line"><span class="number">12345</span></span><br><span class="line"><span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> 内存单元地址</span><br></pre></td></tr></table></figure>

<p>CPU执行此种格式的call指令时，相当于进行：<code>push CS</code> <code>push IP</code> <code>jmp dword ptr 内存单元地址</code></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span>, <span class="number">10h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0123h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">0</span>], <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">2</span>], <span class="number">0</span></span><br><span class="line"><span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line"><span class="comment">;执行后，(CS)=0，(IP)=0123H，(sp)=0CH</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<h2 id="3、call-和-ret-的配合使用"><a href="#3、call-和-ret-的配合使用" class="headerlink" title="3、call 和 ret 的配合使用"></a>3、call 和 ret 的配合使用</h2><p>分析下面程序</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">1</span></span><br><span class="line">	    <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span></span><br><span class="line">     	<span class="keyword">call</span> s <span class="comment">;（1）CPU指令缓冲器存放call指令，IP指向下一条指令（mov bx, ax），执行call指令，IP入栈，jmp</span></span><br><span class="line">     	</span><br><span class="line">	    <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="built_in">ax</span>	<span class="comment">;（4）IP重新指向这里  bx = 8</span></span><br><span class="line">     	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">     	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">     s:</span> <span class="keyword">add</span> <span class="built_in">ax</span>,<span class="built_in">ax</span></span><br><span class="line">     	<span class="keyword">loop</span> s<span class="comment">;（2）循环3次ax = 8</span></span><br><span class="line">	    <span class="keyword">ret</span><span class="comment">;（3）return : pop IP</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>

<p>call 与 ret 指令共同支持了汇编语言编程中的模块化设计</p>
<p>编写子程序</p>
<h1 id="十、标志寄存器"><a href="#十、标志寄存器" class="headerlink" title="十、标志寄存器"></a>十、标志寄存器</h1><hr>
<h2 id="1、标志寄存器"><a href="#1、标志寄存器" class="headerlink" title="1、标志寄存器"></a>1、标志寄存器</h2><p>CPU内部的寄存器中，有一种特殊的寄存器（对于不同的处理机，个数和结构都可能不同）具有以下3种作用。</p>
<p>（1）用来存储相关指令的某些执行结果；</p>
<p>（2）用来为CPU执行相关指令提供行为依据；</p>
<p>（3）用来控制CPU的相关工作方式。</p>
<p>这种特殊的寄存器在8086CPU中，被称为标志寄存器（flag）。</p>
<p>8086CPU的标志寄存器有16位，其中存储的信息通常被称为程序状态字（PSW-Program Status Word）</p>
<p>flag寄存器是按位起作用的，它的每一位都有专门的含义，记录特定的信息。</p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20190322182130199.png" alt="在这里插入图片描述"><br>在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如，add、sub、mul、div、inc、or、and等，它们大都是运算指令（进行逻辑或算术运算）；有的指令的执行对标志寄存器没有影响，比如，mov、push、pop等，它们大都是传送指令</p>
<h3 id="1、零标志位-ZF"><a href="#1、零标志位-ZF" class="headerlink" title="1、零标志位 (ZF)"></a>1、零标志位 (ZF)</h3><p>零标志位（Zero Flag）。它记录相关指令执行后，其结果是否为0。</p>
<p>如果结果为0，那么zf = 1(表示结果是0)；如果结果不为0，那么zf = 0。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax, <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">ax</span>, 1 </span>;执行后，结果为<span class="number">0</span>，则zf = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">mov ax, <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">ax</span>, 1 </span>;执行后，结果不为<span class="number">0</span>，则zf = <span class="number">0</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<h3 id="2、奇偶标志位-PF"><a href="#2、奇偶标志位-PF" class="headerlink" title="2、奇偶标志位 (PF)"></a>2、奇偶标志位 (PF)</h3><p>奇偶标志位（Parity Flag）。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。</p>
<p>如果1的个数为偶数，pf = 1，如果为奇数，那么pf = 0。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov al, <span class="number">1</span></span><br><span class="line">add al, <span class="number">10</span> ;执行后，结果为<span class="number">00001011</span>B，其中有<span class="number">3</span>（奇数）个<span class="number">1</span>，则pf = <span class="number">0</span>；</span><br><span class="line"></span><br><span class="line">mov al, <span class="number">1</span></span><br><span class="line"><span class="keyword">or</span> al, <span class="number">2</span>  ;执行后，结果为<span class="number">00000011</span>B，其中有<span class="number">2</span>（偶数）个<span class="number">1</span>，则pf = <span class="number">1</span>；</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<h3 id="3、符号标志位-SF"><a href="#3、符号标志位-SF" class="headerlink" title="3、符号标志位(SF)"></a>3、符号标志位(SF)</h3><p>符号标志位(Symbol Flag)。它记录相关指令执行后，其结果是否为负。</p>
<p>如果结果为负，sf = 1；如果非负，sf = 0。</p>
<p>计算机中通常用补码来表示有符号数据。计算机中的一个数据可以看作是有符号数，也可以看成是无符号数。</p>
<p><code>00000001B</code>，可以看作为无符号数1，或有符号数+1；<br><code>10000001B</code>，可以看作为无符号数129，也可以看作有符号数-127。</p>
<p>对于同一个二进制数据，计算机可以将它当作无符号数据来运算，也可以当作有符号数据来运算</p>
<p>CPU在执行add等指令的时候，就包含了两种含义:可以将add指令进行的运算当作无符号数的运算，也可以将add指令进行的运算当作有符号数的运算</p>
<p>SF标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负。在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">10000001B</span> </span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>, <span class="number">1</span>   <span class="comment">;执行后，结果为10000010B，sf = 1，表示：如果指令进行的是有符号数运算，那么结果为负；</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">10000001B</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>, <span class="number">01111111B</span>   <span class="comment">;执行后，结果为0，sf = 0，表示：如果指令进行的是有符号数运算，那么结果为非负</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<h3 id="3、进位标志位-CF"><a href="#3、进位标志位-CF" class="headerlink" title="3、进位标志位(CF)"></a>3、进位标志位(CF)</h3><p>进位标志位(Carry Flag)。一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20190322222505568.png" alt="在这里插入图片描述"><br>97H - 98H 产生借位CF = 1 ==》 (al) = 197H - 98H = FFH</p>
<h3 id="4、溢出标志位-OF"><a href="#4、溢出标志位-OF" class="headerlink" title="4、溢出标志位(OF)"></a>4、溢出标志位(OF)</h3><p>溢出标志位(Overflow Flag)。一般情况下，OF记录了有符号数运算的结果是否发生了溢出。</p>
<p>如果发生溢出，OF = 1；如果没有，OF = 0。</p>
<p>CF和OF的区别：CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位</p>
<p>CPU在执行add等指令的时候，就包含了两种含义：无符号数运算和有符号数运算。</p>
<ul>
<li>对于无符号数运算，CPU用CF位来记录是否产生了进位；</li>
<li>对于有符号数运算，CPU用OF位来记录是否产生了溢出，当然，还要用SF位来记录结果的符号。</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mov al, <span class="number">98</span></span><br><span class="line">add al, <span class="number">99</span>   ;执行后将产生溢出。因为进行的<span class="string">"有符号数"</span>运算是：（al）=（al）+ <span class="number">99</span> = <span class="number">98</span> + <span class="number">99</span>=<span class="number">197</span> = C5H 为<span class="number">-59</span>的补码</span><br><span class="line">             ;而结果<span class="number">197</span>超出了机器所能表示的<span class="number">8</span>位有符号数的范围：<span class="number">-128</span><span class="number">-127</span>。</span><br><span class="line">             ;add 指令执行后：无符号运算没有进位CF=<span class="number">0</span>，有符号运算溢出OF=<span class="number">1</span></span><br><span class="line">             ;当取出的数据C5H按无符号解析C5H = <span class="number">197</span>, 当按有符号解析通过SP得知数据为负,即C5H为<span class="number">-59</span>补码存储，</span><br><span class="line">             </span><br><span class="line">mov al，<span class="number">0</span>F0H  ;F0H，为有符号数<span class="number">-16</span>的补码   -Not(F0 - <span class="number">1</span>)</span><br><span class="line">add al，<span class="number">088</span>H  ;<span class="number">88</span>H，为有符号数<span class="number">-120</span>的补码   -Not(<span class="number">88</span>- <span class="number">1</span>)</span><br><span class="line">              ;执行后，将产生溢出。因为add al, <span class="number">088</span>H进行的有符号数运算结果是：（al）= <span class="number">-136</span> </span><br><span class="line">              ;而结果<span class="number">-136</span>超出了机器所能表示的<span class="number">8</span>位有符号数的范围：<span class="number">-128</span><span class="number">-127</span>。</span><br><span class="line">              ;add 指令执行后：无符号运算有进位CF=<span class="number">1</span>，有符号运算溢出OF=<span class="number">1</span></span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<h2 id="2、adc指令和sbb指令"><a href="#2、adc指令和sbb指令" class="headerlink" title="2、adc指令和sbb指令"></a>2、adc指令和sbb指令</h2><p>adc是带进位加法指令，它利用了CF位上记录的进位值。</p>
<p>指令格式：<code>adc 操作对象1, 操作对象2</code></p>
<p>功能：操作对象1 = 操作对象1 + 操作对象2 + CF</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax, <span class="number">2</span></span><br><span class="line">mov bx, <span class="number">1</span></span><br><span class="line">sub bx, ax  ;无符号运算借位CF=<span class="number">1</span>，有符号运算OF = <span class="number">0</span></span><br><span class="line">adc ax, <span class="number">1</span>   ;执行后，（ax）= <span class="number">4</span>。adc执行时，相当于计算：(ax)+<span class="number">1</span>+CF = <span class="number">2</span>+<span class="number">1</span>+<span class="number">1</span> = <span class="number">4</span>。</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20190323125737798.png" alt="在这里插入图片描述"></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）中。</span></span><br><span class="line"><span class="comment">;将计算分两步进行，先将低16位相加，然后将高16位和进位值相加。</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">001EH</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0F000H</span> </span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>, <span class="number">1000H</span></span><br><span class="line"><span class="keyword">adc</span> <span class="built_in">ax</span>, <span class="number">0020H</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p><strong>sbb指令</strong></p>
<p>sbb是带借位减法指令，它利用了CF位上记录的借位值。</p>
<p>指令格式：<code>sbb 操作对象1, 操作对象2</code></p>
<p>功能：操作对象1 = 操作对象1 - 操作对象2 - CF</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;计算 003E1000H - 00202000H，结果放在ax，bx中，程序如下：</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">1000H</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">003EH</span></span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">bx</span>, <span class="number">2000H</span></span><br><span class="line"><span class="keyword">sbb</span> <span class="built_in">ax</span>, <span class="number">0020H</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<h2 id="3、cmp指令"><a href="#3、cmp指令" class="headerlink" title="3、cmp指令"></a>3、cmp指令</h2><p>cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。</p>
<p>其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。</p>
<p>cmp指令格式：<code>cmp 操作对象1，操作对象2</code></p>
<p>例如：<br>指令<code>cmp ax, ax</code>，做（ax）-（ax）的运算，结果为0，但并不在ax中保存，仅影响flag的相关各位。<br>指令执行后：zf=1，pf=1，sf=0，cf=0，of=0。</p>
<p>CPU在执行cmp指令的时候，也包含两种含义：进行无符号数运算和进行有符号数运算。</p>
<table>
<thead>
<tr>
<th>cmp ax, bx</th>
<th>无符号比较时</th>
</tr>
</thead>
<tbody><tr>
<td>(ax) = (bx)</td>
<td>zf = 1</td>
</tr>
<tr>
<td>(ax) ≠ (bx)</td>
<td>zf = 0</td>
</tr>
<tr>
<td>(ax) &lt; (bx)</td>
<td>cf = 1</td>
</tr>
<tr>
<td>(ax) ≥ (bx)</td>
<td>cf = 0</td>
</tr>
<tr>
<td>(ax) &gt; (bx)</td>
<td>cf = 0 且 zf = 0</td>
</tr>
<tr>
<td>(ax) ≤ (bx)</td>
<td>cf = 1 且 zf = 1</td>
</tr>
</tbody></table>
<p>上面的表格可以正推也可以逆推</p>
<p>如果用cmp来进行有符号数比较时<br>SF只能记录实际结果的正负，发生溢出的时候，实际结果的正负不能说明逻辑上真正结果的正负。<br>但是逻辑上的结果的正负，才是cmp指令所求的真正结果，所以我们在考察SF的同时考察OF，就可以得知逻辑上真正结果的正负，同时就知道比较的结果。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ah, <span class="number">08</span>AH  ; -Not(<span class="number">8</span>A<span class="number">-1</span>) = <span class="number">-118</span>  即当成有符号数时为<span class="number">-118</span></span><br><span class="line">mov bh, <span class="number">070</span>H  ; 有符号数时最高位为<span class="number">0</span>为正数， <span class="number">70</span>H = <span class="number">112</span></span><br><span class="line">cmp ah, bh    ;（ah）-（bh）实际得到的结果是<span class="number">1</span>AH </span><br><span class="line">		      ; 在逻辑上，运算所应该得到的结果是：（<span class="number">-118</span>）- <span class="number">112</span> = <span class="number">-230</span></span><br><span class="line">		      ; sf记录实际结果的正负，所以sf=<span class="number">0</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>cmp ah, bh</code><br>（1）如果sf=1，而of=0 。 of=0说明没有溢出，逻辑上真正结果的正负=实际结果的正负； sf=1，实际结果为负，所以逻辑上真正的结果为负，所以（ah）&lt;（bh）</p>
<p>（2）如果sf=1，而of=1： of=1，说明有溢出，逻辑上真正结果的正负≠实际结果的正负； sf=1，实际结果为负。<br>实际结果为负，而又有溢出，这说明是由于溢出导致了实际结果为负，，如果因为溢出导致了实际结果为负，那么逻辑上真正的结果必然为正。 这样，sf=1，of=1，说明了（ah）&gt;（bh）。</p>
<p>（3）如果sf=0，而of=1。of=1，说明有溢出，逻辑上真正结果的正负≠实际结果的正负；sf=0，实际结果非负。而of=1说明有溢出，则结果非0，所以，实际结果为正。<br>实际结果为正，而又有溢出，这说明是由于溢出导致了实际结果非负，如果因为溢出导致了实际结果为正，那么逻辑上真正的结果必然为负。这样，sf=0，of=1，说明了（ah）&lt;（bh）。<br>（4）如果sf=0，而of=0<br>of=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负；sf=0，实际结果非负，所以逻辑上真正的结果非负，所以（ah）≥（bh）。</p>
</blockquote>
<h2 id="4、检测比较结果的条件转移指令"><a href="#4、检测比较结果的条件转移指令" class="headerlink" title="4、检测比较结果的条件转移指令"></a>4、检测比较结果的条件转移指令</h2><p>可以根据某种条件，决定是否修改IP的指令</p>
<p>jcxz它可以检测cx中的数值，如果（cx）=0，就修改IP，否则什么也不做。</p>
<p>所有条件转移指令的转移位移都是[-128，127]。</p>
<p>多数条件转移指令都检测标志寄存器的相关标志位，根据检测的结果来决定是否修改IP</p>
<p>这些条件转移指令通常都和cmp相配合使用,它们所检测的标志位，都是cmp指令进行无符号数比较的时记录比较结果的标志位</p>
<p>根据无符号数的比较结果进行转移的条件转移指令（它们检测zf、cf的值）</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
<th>检测的相关标志位</th>
</tr>
</thead>
<tbody><tr>
<td>je</td>
<td>等于则转移</td>
<td>zf = 1</td>
</tr>
<tr>
<td>jne</td>
<td>不等于则转移</td>
<td>zf = 0</td>
</tr>
<tr>
<td>jb</td>
<td>低于则转移</td>
<td>cf = 1</td>
</tr>
<tr>
<td>jnb</td>
<td>不低于则转移</td>
<td>cf = 0</td>
</tr>
<tr>
<td>ja</td>
<td>高于则转移</td>
<td>cf = 0 且 zf = 0</td>
</tr>
<tr>
<td>jna</td>
<td>不高于则转移</td>
<td>cf = 1 且 zf = 1</td>
</tr>
</tbody></table>
<p>j：jump，e：equal，b：below，a：above，n：not</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;编程，统计data段中数值为8的字节的个数，用ax保存统计结果。</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, data </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0</span>   <span class="comment">;ds:bx指向第一个字节</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0</span>   <span class="comment">;初始化累加器mov cx，8</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">s:</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>], <span class="number">8</span>   <span class="comment">;和8进行比较</span></span><br><span class="line">	<span class="keyword">jne</span> next  <span class="comment">;如果不相等转到next，继续循环</span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">ax</span>  <span class="comment">;如果相等就将计数值加1</span></span><br><span class="line"><span class="symbol">next:</span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">loop</span> s <span class="comment">;程序执行后：（ax）=3</span></span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<h2 id="5、DF标志和串传送指令"><a href="#5、DF标志和串传送指令" class="headerlink" title="5、DF标志和串传送指令"></a>5、DF标志和串传送指令</h2><p>方向标志位。在串处理指令中，控制每次操作后si、di的增减。</p>
<ul>
<li>df = 0每次操作后si、di递增；</li>
<li>df = 1每次操作后si、di递减。</li>
</ul>
<p>格式：<code>movsb</code><br>功能：将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器df位的值，将si和di递增或递减</p>
<p>格式：<code>movsw</code><br>功能：将ds:si指向的内存字单元中的字送入es:di中，然后根据标志寄存器df位的值，将si和di递增2或递减2。</p>
<p>格式：<code>rep movsb</code><br>movsb和movsw进行的是串传送操作中的一个步骤，一般来说，movsb和movsw都和rep配合使用，<br>功能：rep的作用是根据cx的值，重复执行后面的串传送指令</p>
<p>8086CPU提供下面两条指令对df位进行设置。</p>
<ul>
<li><code>cld</code>指令：将标志寄存器的df位置0</li>
<li><code>std</code>指令：将标志寄存器的df位置1</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;将data段中的第一个字符串复制到它后面的空间中。</span></span><br><span class="line">data <span class="meta">segment</span> </span><br><span class="line">	<span class="built_in">db</span> <span class="string">'Welcome to masm!'</span></span><br><span class="line">	<span class="built_in">db</span> <span class="number">16</span> dup (<span class="number">0</span>)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, data </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">si</span>, <span class="number">0</span>   <span class="comment">;ds:si 指向data:0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">di</span>, <span class="number">16</span>  <span class="comment">;es:di指向data:0010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">16</span>  <span class="comment">;（cx）=16，rep循环16次</span></span><br><span class="line"><span class="keyword">cld</span>  <span class="comment">;设置df=0，正向传送</span></span><br><span class="line"><span class="keyword">rep</span> <span class="keyword">movsb</span></span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<h2 id="6、pushf和popf"><a href="#6、pushf和popf" class="headerlink" title="6、pushf和popf"></a>6、pushf和popf</h2><p>pushf的功能是将标志寄存器的值压栈，而popf是从栈中弹出数据，送入标志寄存器中</p>
<p>pushf和popf，为直接访问标志寄存器提供了一种方法。</p>
<h1 id="十一、内中断"><a href="#十一、内中断" class="headerlink" title="十一、内中断"></a>十一、内中断</h1><h2 id="1、内中断的产生"><a href="#1、内中断的产生" class="headerlink" title="1、内中断的产生"></a>1、内中断的产生</h2><p>任何一个通用的CPU，都具备一种能力，可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理。这种特殊的信息，我们可以称其为：中断信息。中断的意思是指，CPU不再接着（刚执行完的指令）向下执行，而是转去处理这个特殊信息。</p>
<p>中断信息可以来自CPU的内部和外部（内中断，外中断）</p>
<p>内中断：当CPU的内部有需要处理的事情发生的时候，将产生中断信息，引发中断过程。这种中断信息来自CPU的内部</p>
<p>8086CPU的内中断（下面四种情况将产生中断信息）</p>
<ul>
<li>除法错误，比如，执行div指令产生的除法溢出；</li>
<li>单步执行；</li>
<li>执行 into指令；</li>
<li>执行 int指令。</li>
</ul>
<p>中断信息中包含中断类型码，中断类型码为一个字节型数据，可以表示256种中断信息的来源（中断源）</p>
<p>上述的4种中断源，在8086CPU中的中断类型码如下。</p>
<ul>
<li>除法错误：0</li>
<li>单步执行：1</li>
<li>执行into指令：4</li>
<li>执行int指令，该指令的格式为int n，指令中的n为字节型立即数，是提供给CPU的中断类型码。</li>
</ul>
<h2 id="2、中断处理程序、中断向量表、中断过程"><a href="#2、中断处理程序、中断向量表、中断过程" class="headerlink" title="2、中断处理程序、中断向量表、中断过程"></a>2、中断处理程序、中断向量表、中断过程</h2><p><strong>中断处理程序</strong></p>
<p>用来处理中断信息的程序被称为中断处理程序。</p>
<p>根据CPU的设计，中断类型码的作用就是用来定位中断处理程序。比如CPU根据中断类型码4，就可以找到4号中断的处理程序</p>
<p><strong>中断向量表</strong></p>
<p>中断向量就是中断处理程序的入口地址。中断向量表就是中断处理程序入口地址的列表</p>
<p>CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址<br><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/20190323182525601.png" alt="在这里插入图片描述"></p>
<p><strong>中断过程</strong></p>
<p>中断过程的主要任务就是用中断类型码在中断向量表中找到中断处理程序的入口地址，设置CS和IP</p>
<p>简要描述如下</p>
<ol>
<li>取得中断类型码N；</li>
<li>pushf</li>
<li>TF=0，IF=0 （为什么这样参考单步中断）</li>
<li>push CS , push IP</li>
<li>（IP）=（N * 4），（CS）=（N * 4 + 2）</li>
</ol>
<p>硬件在完成中断过程后，CS:IP将指向中断处理程序的入口，CPU开始执行中断处理程序。</p>
<h2 id="3、iret指令"><a href="#3、iret指令" class="headerlink" title="3、iret指令"></a>3、iret指令</h2><p>CPU随时都可能执行中断处理程序，中断处理程序必须一直存储在内存某段空间之中<br>而中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中。</p>
<p>中断处理程序的常规编写步骤：</p>
<ol>
<li>保存用到的寄存器；</li>
<li>处理中断；</li>
<li>恢复用到的寄存器；</li>
<li>用<code>iret</code>指令返回。</li>
</ol>
<p>iret 指令描述为：<code>pop IP</code> <code>pop CS</code> <code>popf</code></p>
<p>iret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序</p>
<h2 id="4、除法错误中断的处理"><a href="#4、除法错误中断的处理" class="headerlink" title="4、除法错误中断的处理"></a>4、除法错误中断的处理</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">1000h</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="number">bh</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">div</span> <span class="number">bh</span> <span class="comment">;除法溢出错误</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>1、当CPU执行div bh时，发生了除法溢出错误，产生0号中断信息，从而引发中断过程，</p>
<p>2、CPU执行0号中断处理程序</p>
<p>3、系统中的0号中断处理程序的功能：显示提示信息“Divide overflow”后，返回到操作系统中。</p>
<p><strong>编程实验</strong></p>
<p>编程：编写0号中断处理程序do0，当发生除法溢出时，在屏幕中间显示“overflow！”，返回DOS。</p>
<p>1、0000:0200至0000:02FF的256个字节的空间所对应的中断向量表项都是空的，可以将中断处理程序do0传送到内存0000:0200处。</p>
<p>2、中断处理程序do0放到<code>0000:0200</code>,再将其地址登记在中断向量表对应表项</p>
<ul>
<li>0号表项的地址<code>0:0</code>。<code>0:0</code>字单元存放偏移地址，<code>0:2</code>字单元存放段地址</li>
<li>将do0的段地址0存放在<code>0000:0002</code>字单元中，将偏移地址200H存放在<code>0000:0000</code>字单元</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>	</span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">cs</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">si</span>, offset do0		<span class="comment">;设置ds:si指向源地址</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">di</span>, <span class="number">200h</span>			<span class="comment">;设置es:di指向目的地址0000:0200</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">cx</span>, offset do0end - offset do0		<span class="comment">;设置cx为传输长度 编译时给出do0部分代码长度</span></span><br><span class="line">		<span class="keyword">cld</span>				        <span class="comment">;设置传输方向为正</span></span><br><span class="line">		<span class="keyword">rep</span> <span class="keyword">movsb</span> <span class="comment">;将do0的代码送入0:200处</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0</span>               <span class="comment">;设置中断向量表</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">0</span>*<span class="number">4</span>], <span class="number">200h</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">0</span>*<span class="number">4</span>+<span class="number">2</span>], <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;do0程序的主要任务是显示字符串</span></span><br><span class="line"><span class="symbol">do0:</span>	<span class="keyword">jmp</span> short do0 start </span><br><span class="line">      	<span class="built_in">db</span> <span class="string">"overflow!"</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">do0start:</span></span><br><span class="line">      	<span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">cs</span></span><br><span class="line">      	<span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span></span><br><span class="line">      	<span class="keyword">mov</span> <span class="built_in">si</span>, <span class="number">202h</span>			<span class="comment">;设置ds:si指向字符串</span></span><br><span class="line"></span><br><span class="line">      	<span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0b800h</span></span><br><span class="line">      	<span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">di</span>, <span class="number">12</span>*<span class="number">160</span>+<span class="number">36</span>*<span class="number">2</span>		<span class="comment">;设置es:di指向显存空间的中间位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">9</span>				<span class="comment">;设置cx为字符串长度</span></span><br><span class="line"><span class="symbol">	s:</span>	<span class="keyword">mov</span> <span class="built_in">al</span>, [<span class="built_in">si</span>]</span><br><span class="line">      	<span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">di</span>], <span class="built_in">al</span></span><br><span class="line">      	<span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">      	<span class="keyword">add</span> <span class="built_in">di</span>, <span class="number">1</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">02h</span>             <span class="comment">;设置颜色</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">di</span>], <span class="built_in">al</span>        </span><br><span class="line">		<span class="keyword">add</span> <span class="built_in">di</span>, <span class="number">1</span></span><br><span class="line">      	<span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line">      	<span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span></span><br><span class="line">      	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">do0end:</span>	<span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152</span></span><br></pre></td></tr></table></figure>

<h2 id="5、单步中断"><a href="#5、单步中断" class="headerlink" title="5、单步中断"></a>5、单步中断</h2><p>CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程。单步中断的中断类型码为1</p>
<p>Debug是如何利用CPU所提供的单步中断的功能进行调试？如使用t命令查看寄存器状态</p>
<p>Debug提供了单步中断的中断处理程序，功能为显示所有寄存器中的内容后等待输入命令</p>
<p>在使用t命令执行指令时，Debug将TF设置为1，在CPU执行完这条指令后就引发单步中断，执行单步中断的中断处理程序，所有寄存器中的内容被显示在屏幕上，并且等待输入命令。</p>
<p>在进入中断处理程序之前，设置TF=0。从而避免CPU在执行中断处理程序的时候发生单步中断</p>
<h2 id="6、int指令"><a href="#6、int指令" class="headerlink" title="6、int指令"></a>6、int指令</h2><p>int指令的格式为：<code>int n</code> ，n为中断类型码，它的功能是引发中断过程。</p>
<p>CPU执行int n指令，相当于引发一个n号中断的中断过程</p>
<p>在程序中使用int指令调用任何一个中断的中断处理程序(中断例程)</p>
<p><strong>编写供应用程序调用的中断例程</strong></p>
<p><strong>实验1</strong></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;求2 * 3456^2</span></span><br><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span> </span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">3456</span> <span class="comment">;(ax)=3456</span></span><br><span class="line">     <span class="keyword">int</span> <span class="number">7ch</span>  <span class="comment">; 调用中断7ch的中断例程，计算ax中的数据的平方</span></span><br><span class="line">     <span class="keyword">add</span> <span class="built_in">ax</span>, <span class="built_in">ax</span>  </span><br><span class="line">     <span class="keyword">adc</span> <span class="built_in">dx</span>, <span class="built_in">dx</span>  <span class="comment">;存放结果，将结果乘以2</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">     <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start </span><br><span class="line"><span class="number">123456789101112131415</span></span><br><span class="line"><span class="comment">;编程：安装中断7ch的中断例程</span></span><br><span class="line"><span class="comment">;功能：求一word型数据的平方。</span></span><br><span class="line"><span class="comment">;参数：(ax) = 要计算的数据。</span></span><br><span class="line"><span class="comment">;返回值：dx、ax中存放结果的高16位和低16位。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">si</span>,offset sqr					<span class="comment">;设置ds:si指向源地址</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">200h</span>							<span class="comment">;设置es:di指向目的地址</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">cx</span>,offset sqrend - offset sqr	<span class="comment">;设置cx为传输长度</span></span><br><span class="line">		<span class="keyword">cld</span>									<span class="comment">;设置传输方向为正</span></span><br><span class="line">		<span class="keyword">rep</span> <span class="keyword">movsb</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">7ch</span>*<span class="number">4</span>], <span class="number">200h</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">7ch</span>*<span class="number">4</span>+<span class="number">2</span>], <span class="number">0</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">		<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">  sqr:</span>  </span><br><span class="line">		<span class="keyword">mul</span> <span class="built_in">ax</span></span><br><span class="line">		<span class="keyword">iret</span>  <span class="comment">;CPU执行int 7ch指令进入中断例程之前，标志寄存器、当前的CS和IP被压入栈</span></span><br><span class="line">		      <span class="comment">;在执行完中断例程后，应该用iret 指令恢复int 7ch执行前的标志寄存器和CS、IP的</span></span><br><span class="line"><span class="symbol">sqrend:</span>	<span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435</span></span><br></pre></td></tr></table></figure>

<p><strong>实验2</strong></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;功能：将一个全是字母，以0结尾的字符串，转化为大写。</span></span><br><span class="line"><span class="comment">;参数：ds:si指向字符串的首地址。</span></span><br><span class="line"><span class="comment">;应用举例：将data段中的字符串转化为大写。</span></span><br><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">	<span class="built_in">db</span> <span class="string">'conversation'</span>,<span class="number">0</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>  <span class="keyword">mov</span> <span class="built_in">ax</span>, data</span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">si</span>, <span class="number">0</span></span><br><span class="line">		<span class="keyword">int</span> <span class="number">7ch</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">		<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start   </span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">si</span>,offset capital</span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">200h</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">cx</span>,offset capitalend - offset capital</span><br><span class="line">		<span class="keyword">cld</span></span><br><span class="line">		<span class="keyword">rep</span> <span class="keyword">movsb</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">7ch</span>*<span class="number">4</span>],<span class="number">200h</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">7ch</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">		<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">capital:</span></span><br><span class="line">		<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">		<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">		</span><br><span class="line"><span class="symbol">change:</span> </span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">cl</span>,[<span class="built_in">si</span>]</span><br><span class="line">		<span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line">		<span class="keyword">jcxz</span> ok</span><br><span class="line">		<span class="keyword">and</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>],<span class="number">11011111b</span></span><br><span class="line">		<span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">		<span class="keyword">jmp</span> short change</span><br><span class="line"><span class="symbol">ok:</span>	</span><br><span class="line">		<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">		<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">		<span class="keyword">iret</span></span><br><span class="line">		</span><br><span class="line"><span class="symbol">capitalend:</span><span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445</span></span><br></pre></td></tr></table></figure>

<h2 id="7、BIOS和DOS所提供的中断例程"><a href="#7、BIOS和DOS所提供的中断例程" class="headerlink" title="7、BIOS和DOS所提供的中断例程"></a>7、BIOS和DOS所提供的中断例程</h2><p>在系统板的ROM中存放着一套程序，称为BIOS（基本输入输出系统）</p>
<p>BIOS中主要包含以下几部分内容</p>
<ul>
<li>硬件系统的检测和初始化程序；</li>
<li>外部中断和内部中断的中断例程；</li>
<li>用于对硬件设备进行I/O操作的中断例程；</li>
<li>其他和硬件系统相关的中断例程。</li>
</ul>
<p>程序员在编程的时候，可以用int 指令直接调用BIOS和DOS系统提供的中断例程，来完成某些工作。<br>和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。</p>
<p><strong>BIOS和DOS中断例程的安装过程</strong></p>
<p>BIOS和DOS提供的中断例程是如何安装到内存中的呢？</p>
<p>1、开机后，CPU一加电，初始化（CS）= 0FFFFH，（IP）= 0，自动从FFFF:0单元开始执行程序。FFFF:0处有一条转跳指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。</p>
<p>2、初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。<br>注意，对于BIOS所提供的中断例程，只需将入口地址登记在中断向量表中即可，因为它们是固化到ROM中的程序，一直在内存中存在。</p>
<p>3、硬件系统检测和初始化完成后，调用int 19h进行操作系统的引导。从此将计算机交由操作系统控制。</p>
<p>4、DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。</p>
<p><strong>BIOS中断例程应用</strong></p>
<p>一般来说，一个供程序员调用的中断例程中往往包括多个子程序，中断例程内部用传递进来的参数来决定执行哪一个子程序。</p>
<p>BIOS和DOS提供的中断例程，都用 ah 来传递内部子程序的编号。</p>
<p>编程：在屏幕的5行12列显示3个红底高亮闪烁绿色的“al。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code </span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="comment">;int 10h中断例程的"设置光标位置"功能</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>, <span class="number">2</span><span class="comment">;设置光标调用第10h号中断例程的2号子程序，功能为设置光标位置(可以提供光标所在的行号、列号和页号作为参数)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;设置光标到第0页，第5行，第12列</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">bh</span>, <span class="number">0</span>；第<span class="number">0</span>页</span><br><span class="line"><span class="keyword">mov</span> <span class="number">dh</span>, <span class="number">5</span>；<span class="number">dh</span>中放行号</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dl</span>, <span class="number">12</span>；<span class="built_in">dl</span>中放列号</span><br><span class="line"><span class="keyword">int</span> <span class="number">10h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;int10h中断例程的"在光标位置显示字符"功能。</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>，<span class="number">9</span> <span class="comment">;调用第10h号中断例程的9号子程序，功能为在光标位置显示字符</span></span><br><span class="line"><span class="comment">;提供要显示的字符、颜色属性、页号、字符重复个数作为参数</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>，<span class="string">'a'</span>  <span class="comment">;字符</span></span><br><span class="line"><span class="keyword">mov</span> b1，<span class="number">11001010b</span>  <span class="comment">;颜色属性</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">bh</span>，<span class="number">0</span>  <span class="comment">;第0页</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>，<span class="number">3</span>  <span class="comment">;字符重复个数</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">10h</span></span><br><span class="line"></span><br><span class="line">code ends </span><br><span class="line">end</span><br><span class="line"><span class="number">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure>

<p>bh中页号的含义：内存地址空间中，<code>B8000H~BFFFFH</code>共32kB的空间，为80*25彩色字符模式的显示缓冲区。<br>一屏的内容在显示缓冲区中共占4000个字节。显示缓冲区分为8页，每页4KB（约4000B），显示器可以显示任意一页的内容。一般情况下，显示第0页的内容。也就是说，通常情况下，B8000H~B8F9FH中的4000个字节的内容将出现在显示器上。</p>
<p><strong>DOS中断例程应用</strong><br><code>int 21h</code>中断例程是DOS提供的中断例程，<code>4ch</code>号功能，即程序返回功能</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ah, <span class="number">4</span>ch ;调用第<span class="number">21</span>h号中断例程的<span class="number">4</span>ch号子程序，功能为程序返回,可以提供返回值作为参数</span><br><span class="line">mov al, <span class="number">0</span> ;返回值</span><br><span class="line"><span class="built_in">int</span> <span class="number">21</span>h</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>编程：在屏幕的5行12列显示字符串“Welcome to masm！”。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code </span><br><span class="line"> </span><br><span class="line">data <span class="meta">segment</span> </span><br><span class="line">	<span class="built_in">db</span>	<span class="string">'Welcome to masm'</span>,  <span class="string">'$'</span>     <span class="comment">;“$”本身并不显示，只起到边界的作用</span></span><br><span class="line">data ends </span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>	<span class="keyword">mov</span> <span class="number">ah</span>, <span class="number">2</span> <span class="comment">;10号中断设置光标位置功能</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="number">bh</span>, <span class="number">0</span> <span class="comment">;第0页</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="number">dh</span>, <span class="number">5</span>；<span class="number">dh</span>中放行号</span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">dl</span>, <span class="number">12</span> <span class="comment">;dl中放列号</span></span><br><span class="line">		<span class="keyword">int</span> <span class="number">10h</span> </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ax</span>, data </span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span> </span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0</span> <span class="comment">;ds:dx指向字符串的首地址data:0  （参数）</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="number">ah</span>, <span class="number">9</span> <span class="comment">;调用第21h号中断例程的9号子程序，功能为在光标位置显示字符串，可以提供要显示字符串的地址作为参数</span></span><br><span class="line">		<span class="keyword">int</span> <span class="number">21h</span> </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span> <span class="comment">;21号中断程序返回功能</span></span><br><span class="line">		<span class="keyword">int</span> <span class="number">21h</span> </span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"><span class="number">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure>

<h1 id="十二、端口"><a href="#十二、端口" class="headerlink" title="十二、端口"></a>十二、端口</h1><p>在PC机系统中，和CPU通过总线相连的芯片除各种存储器外，还有以下3种芯片。</p>
<ul>
<li>各种接口卡（比如，网卡、显卡）上的接口芯片，它们控制接口卡进行工作；</li>
<li>主板上的接口芯片，CPU通过它们对部分外设进行访问；</li>
<li>其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理。</li>
</ul>
<p>在这些芯片中，都有一组可以由CPU读写的寄存器。这些寄存器，它们在物理上可能处于不同的芯片中，<br>但是它们在以下两点上相同。</p>
<ul>
<li>都和CPU的总线相连，这种连接是通过它们所在的芯片进行的；</li>
<li>CPU对它们进行读或写的时候都通过控制线向它们所在的芯片发出端口读写命令。</li>
</ul>
<p>从CPU的角度，将这些寄存器都当作端口，对它们进行统一编址，从而建立了一个统一的端口地址空间。<br>每一个端口在地址空间中都有一个地址。在访问端口的时候，CPU通过端口地址来定位端口。因为端口所在的芯片和CPU通过总线相连，</p>
<p>CPU可以直接读写以下3个地方的数据。</p>
<ul>
<li>CPU内部的寄存器；</li>
<li>内存单元；</li>
<li>端口。</li>
</ul>
<h2 id="1、端口的读写"><a href="#1、端口的读写" class="headerlink" title="1、端口的读写"></a>1、端口的读写</h2><p>端口地址和内存地址一样，通过地址总线来传送。在PC系统中，CPU最多可以定位64KB个不同的端口。则端口地址的范围为<code>0-65535</code>。</p>
<p>端口的读写指令只有两条：<code>in</code>和<code>out</code>，分别用于从端口读取数据和往端口写入数据。</p>
<p>在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;对<span class="number">0</span>~<span class="number">255</span>以内的端口进行读写时：</span><br><span class="line"><span class="keyword">in</span> al, <span class="number">20</span>h  ;从<span class="number">20</span>h端口读入一个字节</span><br><span class="line"><span class="keyword">out</span> <span class="number">20</span>h, al  ;往<span class="number">20</span>h端口写入一个字节</span><br><span class="line"></span><br><span class="line">;对<span class="number">256</span>~<span class="number">65535</span>的端口进行读写时，端口号放在dx中：</span><br><span class="line">mov dx, <span class="number">3f</span>8h  ;将端口号<span class="number">3f</span>8h送入dx</span><br><span class="line"><span class="keyword">in</span> al, dx  ;从<span class="number">3f</span>8h端口读入一个字节</span><br><span class="line"><span class="keyword">out</span> dx, al ;向<span class="number">3f</span>8h端口写入一个字节</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<h2 id="2、CMOS-RAM芯片"><a href="#2、CMOS-RAM芯片" class="headerlink" title="2、CMOS RAM芯片"></a>2、CMOS RAM芯片</h2><p>PC机中，有一个CMOS RAM芯片，一般简称为CMOS。此芯片的特征如下</p>
<ul>
<li>包含一个实时钟和一个有128个存储单元的RAM存储器</li>
<li>该芯片靠电池供电。关机后内部的实时钟正常工作，RAM中的信息不丢失</li>
<li>128个字节的RAM中，内部实时钟占用<code>0~0dh</code>单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。BIOS也提供了相关的程序，使我们可以在开机的时候配置CMOS RAM中的系统信息。</li>
<li>该芯片内部有两个端口，端口地址为70h和71h。CPU通过这两个端口来读写CMOS RAM</li>
<li>70h为地址端口，存放要访问的CMOS RAM单元的地址；71h为数据端口，存放从选定的CMOS RAM单元中读取的数据，或要写入到其中的数据。<br>可见，CPU对CMOS RAM的读写分两步进行，比如，读CMOS RAM的2号单元：<br>①将2送入端口70h；<br>②从端口71h读出2号单元的内容。</li>
</ul>
<p><strong>CMOS RAM中存储的时间信息</strong></p>
<p>在CMOS RAM中，存放着当前的时间：年、月、日、时、分、秒。长度都为1个字节，<br>存放单元为：</p>
<table>
<thead>
<tr>
<th>9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>年</td>
<td>月</td>
<td>日</td>
<td></td>
<td></td>
<td>时</td>
<td></td>
<td>分</td>
<td></td>
<td>秒</td>
</tr>
</tbody></table>
<p>BCD码是以4位二进制数表示十进制数码的编码方法 4 == 0100B</p>
<p>一个字节可表示两个BCD码。则CMOS RAM存储时间信息的单元中，存储了用两个BCD码表示的两位十进制数，高4位的BCD码表示十位，低4位的BCD码表示个位。比如，00010100b表示14。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;编程，在屏幕中间显示当前的月份。</span></span><br><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span> </span><br><span class="line"><span class="symbol">start:</span>	<span class="keyword">mov</span> <span class="built_in">al</span>，<span class="number">8</span> <span class="comment">;从CMOS RAM的8号单元读出当前月份的BCD码。</span></span><br><span class="line">		<span class="keyword">out</span> <span class="number">70h</span>，<span class="built_in">al</span> </span><br><span class="line">		<span class="keyword">in</span> <span class="built_in">al</span>, <span class="number">71h</span> <span class="comment">;从数据端口71h中取得指定单元中的数据：</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">mov</span> <span class="number">ah</span>, <span class="built_in">al</span> <span class="comment">;al中为从CMOS RAM的8号单元中读出的数据</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">cl</span>, <span class="number">4</span></span><br><span class="line">		<span class="keyword">shr</span> <span class="number">ah</span>, <span class="built_in">cl</span> <span class="comment">;ah中为月份的十位数码值,左移四位空出四位</span></span><br><span class="line">		<span class="keyword">and</span> <span class="built_in">al</span>, <span class="number">00001111b</span> <span class="comment">;al中为月份的个位数码值</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">add</span> <span class="number">ah</span>, <span class="number">30h</span> <span class="comment">;BCD码值+30h=十进制数对应的ASCII</span></span><br><span class="line">		<span class="keyword">add</span> <span class="built_in">al</span>, <span class="number">30h</span> </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0b800h</span> </span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">bx</span> </span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">160</span>*<span class="number">12</span>+<span class="number">40</span>*<span class="number">2</span>], <span class="number">ah</span> <span class="comment">;显示月份的十位数码</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">160</span>*<span class="number">12</span>+<span class="number">40</span>*<span class="number">2</span>+<span class="number">2</span>], <span class="built_in">al</span> <span class="comment">;接着显示月份的个位数码</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ax</span>，<span class="number">4c00h</span></span><br><span class="line">		<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"><span class="number">123456789101112131415161718192021222324</span></span><br></pre></td></tr></table></figure>

<h2 id="3、shl和shr指令"><a href="#3、shl和shr指令" class="headerlink" title="3、shl和shr指令"></a>3、shl和shr指令</h2><p>shl和shr是逻辑移位指令</p>
<p>shl是逻辑左移指令，它的功能为：</p>
<ol>
<li>将一个寄存器或内存单元中的数据向左移位；</li>
<li>将最后移出的一位写入CF中；</li>
<li>最低位用0补充。</li>
</ol>
<p>shr是逻辑右移指令，同理</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">01001000b</span> </span><br><span class="line"><span class="keyword">shl</span> <span class="built_in">al</span>, <span class="number">1</span> <span class="comment">;将a1中的数据左移一位执行后（al）=10010000b，CF=0。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">01010001b</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cl</span>, <span class="number">3</span> <span class="comment">;如果移动位数大于1时，必须将移动位数放在cl中</span></span><br><span class="line"><span class="keyword">shl</span> <span class="built_in">al</span>, c1</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">10000001b</span> </span><br><span class="line"><span class="keyword">shr</span> <span class="built_in">al</span>, <span class="number">1</span>  <span class="comment">;将al中的数据右移一位执行后（al）=01000000b，CF=1。</span></span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p>将X逻辑左移一位，相当于执行X=X*2。<br>将X逻辑右移一位，相当于执行X=X/2</p>
<h1 id="十三、外中断"><a href="#十三、外中断" class="headerlink" title="十三、外中断"></a>十三、外中断</h1><h2 id="1、外中断"><a href="#1、外中断" class="headerlink" title="1、外中断"></a>1、外中断</h2><p>CPU在计算机系统中，除了能够执行指令，进行运算以外，还应该能够对外部设备进行控制，接收它们的输入，向它们进行输出（I/O能力）</p>
<p>PC系统的接口卡和主板上，装有各种接口芯片。这些外设接口芯片的内部有若干寄存器，CPU将这些寄存器当作端口来访问</p>
<p>外设的输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中；<br>CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设。<br>CPU还可以向外设输出控制命令，而这些控制命令也是先送到相关芯片的端口中，然后再由相关的芯片根据命令对外设实施控制。</p>
<p>即：CPU通过端口和外部设备进行联系</p>
<p>当CPU外部有需要处理的事情发生的时候，比如说，外设的输入到达，相关芯片将向CPU发出相应的中断信息。CPU在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入。</p>
<p><strong>PC系统中，外中断源有两类</strong></p>
<p>1、可屏蔽中断</p>
<p>可屏蔽中断是CPU可以不响应的外中断。CPU是否响应可屏蔽中断，要看标志寄存器的IF位的设置。<br>当CPU检测到可屏蔽中断信息时，如果IF=1，则CPU在执行完当前指令后响应中断，引发中断过程；如果IF=0，则不响应可屏蔽中断。</p>
<p>可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU的；而内中断的中断类型码是在CPU内部产生的。</p>
<p>中断过程中将IF置0的原因就是，在进入中断处理程序后，禁止其他的可屏蔽中断。<br>如果在中断处理程序中需要处理可屏蔽中断，可以用指令将IF置1。</p>
<p>8086CPU提供的设置IF的指令：<code>sti</code>，设置IF=1；<code>cli</code>，设置IF=0。</p>
<p>2、不可屏蔽中断</p>
<p>不可屏蔽中断是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。</p>
<p>对于8086CPU，不可屏蔽中断的中断类型码固定为2，所以中断过程中，不需要取中断类型码。则不可屏蔽中断的中断过程为：①标志寄存器入栈，IF=0，TF=0；②CS、IP入栈；③（IP）=（8），（CS）=（0AH）。</p>
<p>几乎所有由外设引发的外中断，都是可屏蔽中断。当外设有需要处理的事件（比如说键盘输入）发生时，相关芯片向CPU发出可屏蔽中断信息。不可屏蔽中断是在系统中有必须处理的紧急情况发生时用来通知CPU的中断信息。</p>
<h2 id="2、PC机键盘的处理过程"><a href="#2、PC机键盘的处理过程" class="headerlink" title="2、PC机键盘的处理过程"></a>2、PC机键盘的处理过程</h2><p>键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描。按下一个键时，开关接通，该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置。扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为<code>60h</code>。松开按下的键时，也产生一个扫描码，扫描码说明了松开的键在键盘上的位置。松开按键时产生的扫描码也被送入60h端口中。</p>
<p>一般将按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码。</p>
<p>扫描码长度为一个字节，通码的第7位为0，断码的第7位为1<br>即：断码 = 通码 + 80h。比如，g键的通码为22h，断码为a2h</p>
<p>键盘的输入到达60h端口时，相关的芯片就会向CPU发出中断类型码为9的可屏蔽中断信息。CPU检测到该中断信息后，如果IF=1，则响应中断，引发中断过程，转去执行int 9中断例程。</p>
<p><img src="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB2/2019032416380958.png" alt="在这里插入图片描述"></p>
<p>BIOS提供了int 9中断例程，用来进行基本的键盘输入处理，主要的工作如下：<br>（1）读出60h端口中的扫描码；<br>（2）如果是字符键的扫描码，将该扫描码和它所对应的字符码（即ASCII码）送入内存中的BIOS键盘缓冲区； 如果是控制键（比如Ctrl）和切换键（比如CapsLock）的扫描码，则将其转变为状态字节写入内存中存储状态字节的单元；<br>（3）对键盘系统进行相关的控制，比如说，向相关芯片发出应答信息。</p>
<p>BIOS键盘缓冲区可以存储15个键盘输入，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码。</p>
<p><code>0040:17</code>单元存储键盘状态字节，该字节记录了控制键和切换键的状态。键盘状态字节各位记录的信息如下。</p>
<table>
<thead>
<tr>
<th>0</th>
<th>右shift状态</th>
<th>置1表示按下右shift键</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>左shift状态</td>
<td>置1表示按下左shift键</td>
</tr>
<tr>
<td>2</td>
<td>Ctrl状态</td>
<td>置1表示按下Ctrl键</td>
</tr>
<tr>
<td>3</td>
<td>Alt状态</td>
<td>置1表示按下Alt键</td>
</tr>
<tr>
<td>4</td>
<td>ScrollLock状态</td>
<td>置1表示Scroll指示灯亮</td>
</tr>
<tr>
<td>5</td>
<td>NumLock状态</td>
<td>置1表示小键盘输入的是数字</td>
</tr>
<tr>
<td>6</td>
<td>CapsLock状态</td>
<td>置1表示输入大写字母</td>
</tr>
<tr>
<td>7</td>
<td>Insert状态</td>
<td>置1表示处于删除态</td>
</tr>
</tbody></table>
<p><strong>编写int 9中断例程</strong></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;编程：在屏幕中间依次显示“a”~“z”，并可以让人看清。在显示的过程中，按下'Esc'键后，改变显示的颜色。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;完整功能代码：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">	<span class="built_in">db</span> <span class="number">128</span> dup (<span class="number">0</span>)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">	<span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>	</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">128</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>]</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>+<span class="number">2</span>]</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ds</span>:[<span class="number">2</span>]		<span class="comment">;将原来的int 9中断例程的入口地址保存在ds:0、ds:2单元中</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>], offset int9</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>+<span class="number">2</span>], <span class="built_in">cs</span>	<span class="comment">;在中断向量表中设置新的int 9中断例程的入口地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;显示字符串</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0b800h</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ah</span>, <span class="string">'a'</span></span><br><span class="line"><span class="symbol">s:</span>	</span><br><span class="line">	<span class="keyword">mov</span>  <span class="built_in">es</span>:[<span class="number">160</span>*<span class="number">12</span>+<span class="number">40</span>*<span class="number">2</span>], <span class="number">ah</span></span><br><span class="line">	<span class="keyword">call</span> delay</span><br><span class="line">	<span class="keyword">inc</span> <span class="number">ah</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="number">ah</span>, <span class="string">'z'</span></span><br><span class="line">	<span class="keyword">jna</span> s</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>]</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ds</span><span class="comment">;[2]</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">es</span><span class="comment">;[9*4+2]   	;将中断向量表中int 9中断例程的入口恢复为原来的地址</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;将循环延时的程序段写为一个子程序</span></span><br><span class="line"><span class="symbol">delay:</span>	</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span> </span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">2000h</span>  <span class="comment">;用两个16位寄存器来存放32位的循环次数</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0</span></span><br><span class="line"><span class="symbol">s1:</span> 	</span><br><span class="line">	<span class="keyword">sub</span> <span class="built_in">ax</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">sbb</span> <span class="built_in">dx</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">ax</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">jne</span> s1</span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">dx</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">jne</span> s1</span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;------以下为新的int 9中断例程--------------------</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">int9:</span>	</span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">in</span> <span class="built_in">al</span>, <span class="number">60h</span><span class="comment">;从端口60h读出键盘的输入</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">pushf</span> <span class="comment">;标志寄存器入栈</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">pushf</span>   </span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">and</span> <span class="number">bh</span>,<span class="number">11111100b</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">popf</span>	<span class="comment">;TF=0,IF=0</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>] 	<span class="comment">;对int指令进行模拟，调用原来的int 9中断例程</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">1</span></span><br><span class="line">	<span class="keyword">jne</span> int9ret</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">160</span>*<span class="number">12</span>+<span class="number">40</span>*<span class="number">2</span>+<span class="number">1</span>]  <span class="comment">;属性增加1，改变颜色</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">int9ret:</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">iret</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106</span></span><br></pre></td></tr></table></figure>

<p>CPU对外设输入的通常处理方法<br>（1）外设的输入送入端口；<br>（2）向CPU发出外中断（可屏蔽中断）信息；<br>（3）CPU检测到可屏蔽中断信息，如果IF=1，CPU在执行完当前指令后响应中断，执行相应的中断例程；<br>（4）可在中断例程中实现对外设输入的处理。</p>
<p>端口和中断机制，是CPU进行I/O的基础。</p>
<h1 id="十四、直接定址表"><a href="#十四、直接定址表" class="headerlink" title="十四、直接定址表"></a>十四、直接定址表</h1><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">         a : <span class="built_in">db</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>  <span class="comment">;在后面加有“：”的地址标号，只能在代码段中使用，不能在其他段中使用。</span></span><br><span class="line">         b : <span class="built_in">dw</span> <span class="number">0</span></span><br><span class="line">start :<span class="keyword">mov</span> <span class="built_in">si</span>,offset a</span><br><span class="line">         <span class="keyword">mov</span> <span class="built_in">bx</span>,offset b</span><br><span class="line">         <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line">    s : <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">cs</span>:[<span class="built_in">si</span>]</span><br><span class="line">         <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0</span></span><br><span class="line">         <span class="keyword">add</span> <span class="built_in">cs</span>:[<span class="built_in">bx</span>],<span class="built_in">ax</span></span><br><span class="line">         <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">         <span class="keyword">loop</span> s</span><br><span class="line">         <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">         <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>

<p>程序中，code、a、b、start、s都是标号。这些标号仅仅表示了内存单元的地址</p>
<p><strong>描述了单位长度的标号</strong></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">          a <span class="built_in">db</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> <span class="comment">;标号a、b后面没有":"，因此它们是可以同时描述内存地址和单元长度的标号。</span></span><br><span class="line">                               <span class="comment">;标号a，描述了地址code:0，和从这个地址开始，以后的内存单元都是字节单元</span></span><br><span class="line">          b <span class="built_in">dw</span> <span class="number">0</span>               <span class="comment">;标号b描述了地址code:8，和从这个地址开始，以后的内存单元都是字单元。</span></span><br><span class="line">start :  <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">          <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line">    s :   <span class="keyword">mov</span> <span class="built_in">al</span>,a[<span class="built_in">si</span>]</span><br><span class="line">          <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0</span></span><br><span class="line">          <span class="keyword">add</span> b,<span class="built_in">ax</span></span><br><span class="line">          <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">          <span class="keyword">loop</span> s</span><br><span class="line">          <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">          <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>

<p>使用<strong>数据标号</strong>来描述存储数据的单元的地址和长度。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data ；用伪指令<span class="meta">assume</span>将标号所在的段和一个段寄存器联系起来(编译器需要)</span><br><span class="line">data <span class="meta">segment</span>          </span><br><span class="line">          a <span class="built_in">db</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">          b <span class="built_in">dw</span> <span class="number">0</span></span><br><span class="line">data ends</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>  <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">          <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span> <span class="comment">;真正确定ds寄存器</span></span><br><span class="line">          <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">          <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">s:</span>       <span class="keyword">mov</span> <span class="built_in">al</span>,a[<span class="built_in">si</span>] <span class="comment">;编译为：mov al,[si+0] 默认所访问单元的段地址在ds</span></span><br><span class="line">          <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0</span></span><br><span class="line">          <span class="keyword">add</span> b,<span class="built_in">ax</span> <span class="comment">;编译为：add [8],ax</span></span><br><span class="line">          <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">          <span class="keyword">loop</span> s</span><br><span class="line">          <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">          <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">	a <span class="built_in">db</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">	b <span class="built_in">dw</span> <span class="number">0</span></span><br><span class="line">	c <span class="built_in">dw</span> a, b <span class="comment">;等价于c dw offset a, offset b</span></span><br><span class="line">	<span class="comment">;数据标号c处存储的两个字型数据为标号a、b 的偏移地址</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">	a <span class="built_in">db</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">	b <span class="built_in">dw</span> <span class="number">0</span></span><br><span class="line">	c <span class="built_in">dd</span> a,b <span class="comment">;等价于c dw offset a, seg a, offset b, seg b</span></span><br><span class="line">	<span class="comment">;数据标号c处存储的两个双字型数据为标号a的偏移地址和段地址、标号b 的偏移地址和段地址</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>

<p>seg操作符，功能为取得某一标号的段地址</p>
<p>建立一张表，表中依次存储字符“0”~“F”，我们可以通过数值0 ~ 15直接查找到对应的字符</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>  </span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0eh</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">call</span> showbyte</span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">        <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;子程序：</span></span><br><span class="line"><span class="comment">;用al传送要显示的数据</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">showbyte:</span></span><br><span class="line">        <span class="keyword">jmp</span> short show</span><br><span class="line"></span><br><span class="line">        table <span class="built_in">db</span> <span class="string">'0123456789ABCDEF'</span>	<span class="comment">;字符表</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">show:</span>   <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">        <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span> <span class="number">ah</span>,<span class="built_in">al</span></span><br><span class="line">        <span class="keyword">shr</span> <span class="number">ah</span>,<span class="number">1</span>           </span><br><span class="line">        <span class="keyword">shr</span> <span class="number">ah</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">shr</span> <span class="number">ah</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">shr</span> <span class="number">ah</span>,<span class="number">1</span>			    <span class="comment">;右移4位，ah中得到高4位的值</span></span><br><span class="line">        <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">00001111b</span>		<span class="comment">;al中为低4位的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="number">ah</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="number">ah</span>,table[<span class="built_in">bx</span>]		<span class="comment">;用高4位的值作为相对于table的偏移，取得对应的字符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0b800h</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">bx</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="number">160</span>*<span class="number">12</span>+<span class="number">40</span>*<span class="number">2</span>],<span class="number">ah</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="built_in">al</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">al</span>,table[<span class="built_in">bx</span>]		<span class="comment">;用低4位的值作为相对于table的偏移，取得对应的字符</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="number">160</span>*<span class="number">12</span>+<span class="number">40</span>*<span class="number">2</span>+<span class="number">2</span>],<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">        <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">        <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950</span></span><br></pre></td></tr></table></figure>

<h1 id="十五、-指令系统总结"><a href="#十五、-指令系统总结" class="headerlink" title="十五、 指令系统总结"></a>十五、 指令系统总结</h1><p>我们对8086CPU的指令系统进行一下总结。读者若要详细了解8086指令系统中的各个指令的用，可以查看有关的指令手册。</p>
<p>8086CPU提供以下几大类指令。</p>
<ol>
<li>数据传送指令<br><code>mov、push、pop、pushf、popf、xchg</code> 等都是数据传送指令，这些指令实现寄存器和内存、寄器和寄存器之间的单个数据传送。</li>
<li>算术运算指令<br><code>add、sub、adc、sbb、inc、dec、cmp、imul、idiv、aaa</code>等都是算术运算指令，这些指令实现存器和内存中的数据的算数运算。它们的执行结果影响标志寄存器的<code>sf、zf、of、cf、pf、af</code>位。</li>
<li>逻辑指令<br><code>and、or、not、xor、test、shl、shr、sal、sar、rol、ror、rcl、rcr</code>等都是逻辑指令。除了not指外，它们的执行结果都影响标志寄存器的相关标志位。</li>
<li>转移指令<br>可以修改IP，或同时修改CS和IP的指令统称为转移指令。转移指令分为以下几类。<br>（1）无条件转移指令，比如，<code>jmp</code>；<br>（2）条件转移指令，比如，<code>jcxz、je、jb、ja、jnb、jna</code>等；<br>（3）循环指令，比如，<code>loop</code>；<br>（4）过程，比如，<code>call、ret、retf</code>；<br>（5）中断，比如，<code>int、iret</code>。</li>
<li>处理机控制指令<br>对标志寄存器或其他处理机状态进行设置，<code>cld、std、cli、sti、nop、clc、cmc、stc、hlt、wait、esc、lock</code>等都是处理机控制指令。</li>
<li>串处理指令<br>对内存中的批量数据进行处理，<code>movsb、movsw、cmps、scas、lods、stos</code>等。若要使用这些指令方便地进行批量数据的处理，则需要和<code>rep、repe、repne</code> 等前缀指令配合使用。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AF%84%E5%AD%98%E5%99%A8%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AF%84%E5%AD%98%E5%99%A8%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">汇编语言寄存器应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-01 20:19:10" itemprop="dateCreated datePublished" datetime="2021-01-01T20:19:10+08:00">2021-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-04 10:10:05" itemprop="dateModified" datetime="2021-01-04T10:10:05+08:00">2021-01-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96/" itemprop="url" rel="index"><span itemprop="name">汇编</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>760</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>综合分析题</p>
<p>已知汇编语言程序：dzy.asm 清单如下：</p>
<p>（一）填写程序中指令旁边寄存器的值</p>
<p>DATA SEGMENT AT 1234H；<strong>AT是组合类型bai AT 表达式 它表示当前段应du该按绝对地址定zhi位，其段地址即为表达式dao之值。</strong></p>
<p>A DB ‘A’，23H，’123’</p>
<p>B DW ‘ab’，1234H，22H</p>
<p>C DD  44556677H</p>
<p>D DW B+1  ；D存放B+1所在段的偏移地址</p>
<p>E DD  C+2  ；E的低字存放C+2所在段的偏移地址，E的高字存放C+2所在段的段地址</p>
<p>DATA ENDS</p>
<p>STACK SEGMENT  STACK ’STACK‘</p>
<p>DW 200 DUP（？）</p>
<p>STACK ENDS</p>
<p>CODE SEGMENT PAGE PRIVATE USE16 ‘CODE’</p>
<p>ASSUME CS：CODE，DS：DATA，SS：STACK</p>
<p>START：MOV AX， DATA        ；AX=（  ①  ）</p>
<p>​    MOV DS， AX；         </p>
<p>​    <strong>MOV AX， WORD PTR A+2   ；AX=（  ②  ）</strong></p>
<p>​    LEA  AX，B+2          ；AX=（  ③ ）</p>
<p>​    MOV DX，OFFSET B+2      ；DX=（ ④  ）</p>
<p>​    MOV AX， WORD PTR C+1   ；AX=（  ⑤ ）</p>
<p>​    MOV AX， D          ；AX=（  ⑥  ）</p>
<p>​    MOV AX， B+1         ；AX=（  ⑦ ）</p>
<p>​    MOV AL，BYTE PTR C     ；AL=（  ⑧  ）</p>
<p>​    LDS  DX，E           ；DX=（  ⑨ ），DS=（ ⑩  ）</p>
<p>​    MOV AH, 4CH</p>
<p>​    INT 21H</p>
<p>​    CODE ENDS</p>
<p>​    END START</p>
<p><a href="javascript:void(0)">正确答案：</a></p>
<p><em>第一空：</em> 1234H<br><strong><em>第二空：</em> 3231H</strong><br><em>第三空：</em> 0007H<br><em>第四空：</em> 0007H<br><em>第五空：</em> 5566H<br><em>第六空：</em> 0006H<br><em>第七空：</em> 3461H<br><em>第八空：</em> 77H<br><em>第九空：</em> 000DH<br><em>第十空：</em> 1234H</p>
<p>我的答案：得分： 4.0分</p>
<p><em>第一空：</em> 1234H</p>
<p><em>第二空：</em> 0004H</p>
<p><em>第三空：</em> 0034H</p>
<p><em>第四空：</em> 0007H</p>
<p><em>第五空：</em> 0013H</p>
<p><em>第六空：</em> 0006H</p>
<p><em>第七空：</em> 0006H</p>
<p><em>第八空：</em> 11H</p>
<p><em>第九空：</em> 0013H</p>
<p><em>第十空：</em> 1234H</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">匡俊桦</p>
  <div class="site-description" itemprop="description">回忆的沙漏将曾经屈指可数的日子渐渐淡去</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">202</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">匡俊桦</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">22:23</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
