<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:type" content="website">
<meta property="og:title" content="KJHの博客">
<meta property="og:url" content="http://yoursite.com/page/35/index.html">
<meta property="og:site_name" content="KJHの博客">
<meta property="og:description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="匡俊桦">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/35/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>KJHの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KJHの博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录&回忆</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day01%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day01%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:14" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:14+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 22:59:19" itemprop="dateModified" datetime="2020-12-23T22:59:19+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、Java开发环境搭建<br>2、HelloWorld案例<br>3、注释、关键字、标识符<br>4、数据（数据类型、常量）</p>
<p>###01java语言概述<br>    * A: java语言概述<br>        * a: Java是sun公司开发的一门编程语言,目前被Oracle公司收购，编程语言就是用来编写软件的。<br>        * b: Java的应用<br>            * 开发QQ、迅雷程序(桌面应用软件)<br>            * 淘宝、京东(互联网应用软件)<br>        * c: Java的擅长<br>            * 互联网：电商、P2P等等<br>            * 企业级应用：ERP、CRM、BOS、OA等等<br>        * d: Java语言平台<br>            * JavaSE（标准版）部分,基础班学习JavaSE,JavaSE并不能开发大型项目。<br>            * JavaEE（企业版）部分,就业班学习JavaEE,学习完JavaEE部分就可以开发各种大型项目了。</p>
<p>###02常用的DOS命令<br>    * A: 常用的DOS命令<br>        * a: 打开Dos控制台<br>            * win+r–cmd–回车<br>        * b: 常用dos命令<br>            * cd.. : 退回到上一级目录<br>            * cd\  : 退回到根目录<br>            * cd tools: 进入tools文件夹<br>            * d:   : 回车    盘符切换<br>            * cd d:\234 :进入d盘的234文件夹,再切换盘符(d:)才能进入d:\234<br>            * dir  : 列出当前目录下的文件以及文件夹<br>            * cls  : 清除屏幕<br>            * ipconfig: 查看本机的相关网络配置<br>        * c: dos控制台运行记事本程序<br>            * D:&gt;C:\windows\notepad.exe<br>            * 还可以省略“.exe”后缀，例如：D:&gt;C:\windows\notepad</p>
<p>​<br>###03java语言开发环境JDK<br>    * A: java语言开发环境JDK<br>        * a: JDK是Java开发环境<br>        * b: 课程中使用的JDK版本是JDK7，当前最新版本是JDK8</p>
<p>​    </p>
<p>###04JDK的下载和安装<br>    * A: JDK的下载<br>        * a: 官网 <a href="http://www.oracle.com/cn/index.html" target="_blank" rel="noopener">http://www.oracle.com/cn/index.html</a><br>        * b: 演示下载流程<br>    * B: JDK的安装<br>        * a: 傻瓜式安装<br>            * 双击安装程序，然后一路next即可(但是不建议)<br>        * b: 安装的推荐方式<br>            * 安装路径不要有中文或者特殊符号如空格等。<br>            * 所有和开发相关的软件最好安装目录统一。<br>                * 举例：我的JDK安装路径<br>                    * D:\develop\Java\jdk1.7.0_72<br>            * 当提示安装JRE时，可以选择不安装。建议还是安装上。<br>                    * D:\develop\Java\jre<br>            * 安装路径中没有的文件夹,会自动创建</p>
<pre><code>* C: 验证安装是否成功
    * a:通过DOS命令，切换到JDK安装的bin目录下。
        * D:\develop\Java\jdk1.7.0_72\bin
    * b:然后分别输入javac和java，如果正常显示一些内容，说明安装成功</code></pre><p>###05JDK和JRE跨平台<br>    * A: JDK与JRE的关系<br>        * a: JDK：它是Java开发运行环境，在程序员的电脑上当然要安装JDK；<br>        * b: JRE：Java Runtime Environment它是Java运行环境，如果你不需要开发只需要运行Java程序，那么你可以安装JRE。例如程序员开发出的程序最终卖给了用户，用户不用开发，只需要运行程序，所以用户在电脑上安装JRE即可。<br>        * c: JDK包含了JRE。<br>    * B: 跨平台特性<br>        * a: 平台指的是操作系统 （Windows，Linux，Mac）。<br>        * b: Java程序可以在任意操作系统上运行，一次编写到处运行<br>        * c: 实现跨平台需要依赖Java的虚拟机 JVM （Java Virtual Machine）</p>
<p>​    </p>
<p>​                </p>
<p>###06编写HelloWorld程序<br>    * A: 编写步骤(初学者)<br>        * a: 创建一个普通文本文件，将其修改为.java文件。<br>        * b: 完成模板代码：<br>            public class HelloWorld{<br>                public static void main(String[] args) {<br>                        System.out.println(“Hello World!”);<br>                }<br>            }<br>    * B: 实际开发步骤<br>        * a: 定义类<br>        * b: 写main方法<br>        * c: 写输出语句(注意：下面的代码是原代码，是不能运行的)<br>            public class HelloWorld {<br>                public static void main(String[] args) {<br>                    System.out.println(“HelloWorld”);<br>                }<br>            }<br>        * d：注意：<br>            * 不要隐藏文件的扩展名<br>            * 类名和文件名要保持一致<br>    * C: Java代码的编写执行过程<br>        * a: 源文件：编写Java源文件（我们也称之为源代码文件），它的扩展名为.java；<br>        * b: 编译：然后通过编译器把源文件编译成字节码文件，字节码文件扩展名为.class；<br>        * c: 运行：最后使用解释器来运行字节码文件。</p>
<p>###07编译Java程序<br>    * A：程序编译<br>        * 作用：将程序员写的java源代码生成可以运行的Java程序(.class文件)<br>        * 过程：<br>            * a:开启DOS窗口并切换到.java文件所在的目录 比如HelloWord.java存放于d:\234\day01\code 中<br>            * b:切换到HelloWorld.java所在目录,但是此目录中没有javac命令,所以在编译时要写出javac命令的全路径<br>            * c: d:\234\day01\code&gt;d:\develop\java\jdk1.7.0_72\bin\javac HelloWorld.java 回车<br>            * d:在d:\234\day01\code文件夹中多了个HelloWorld.class文件(又叫做字节码文件)</p>
<p>###08运行Java程序<br>    * A：运行程序<br>        * a: 开启DOS窗口并切换到.class文件所在的目录<br>        * b: 此目录中没有java命令,所以在运行时也要写出java命令的全路径<br>        * c: d:\234\day01\code&gt;d:\develop\java\jdk1.7.0_72\bin\java HelloWorld 回车(注意:运行时不用后缀名.class)<br>        * d: 控制台打印显示结果”HelloWorld”</p>
<p>###09环境变量的配置<br>    * A: Path环境变量配置方式一<br>        * a: 安装高级文本编辑器notepad++<br>        * b: 配置Windows的path环境变量<br>            * 环境变量的作用：让Java的bin目录下的javac命令可以在任意目录下执行<br>            * 配置方法：<br>                * 右键点击计算机  →  选择属性  →  更改设置  →  点击高级  →  点击环境变量  →  找到系统变量中的path  →  将java安装目录下javac所在的bin目录路径配置到path变量中，用；(英文)与其他变量分隔<br>            * 注意：<br>                * 配置path后文件的访问顺序：先访问当前路径，如果当前路径没有该文件，则再访问path配置的路径<br>    * B:配置过程(建议使用这种方式配置)<br>        * a：右键点击计算机  →  选择属性  →  更改设置  →  点击高级  →  点击环境变量  →  创建名为JAVA_HOME的环境变量  →  将jdk所在的目录路径(bin所在的路径)配置到JAVA_HOME变量中<br>        * b: 用;与其他变量分隔  →  在path环境变量中添加%JAVA_HOME%\bin</p>
<p>###10notepad软件安装<br>    * A: 安装<br>        * 双击.exe文件安装 即可</p>
<p>###11注释<br>    * A: 注释<br>        * a: 定义：用来解释和说明程序的文字，注释是不会被执行的<br>        * b: 分类：<br>            * 1：单行注释    //注释内容<br>            * 2：多行注释    /<em>注释内容</em>/<br>            * 3：文档注释    /<em>*注释内容</em>/<br>        * c: 注意：<br>            * 1：对于单行和多行注释，被注释的文字，不会被JVM解释执行<br>            * 2：对于文档注释，可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档<br>            * 3：单行注释可以嵌套使用，多行注释不能嵌套使用<br>        * d: 案例代码<br>            /*<br>                 实现了一个Java的HelloWorld程序<br>                 实现步骤：<br>                   1. 定义类<br>                   2. 定义主方法<br>                   3. 一条命令，控制台输出了HelloWorld<br>            */<br>            public class HelloWorld{<br>                //main主方法，固定格式，程序的入口点<br>                public static void main(String[] args){<br>                    //系统 输出 打印    打印的内容<br>                    System.out.println(“HelloWorld”);<br>                }<br>            }<br>###12关键字<br>    * A: 关键字<br>        * a: 定义<br>            * 是被Java语言赋予特殊含义，具有专门用途的单词，比如之前接触的class，int，double均为Java已经预设好的<br>        * b: 特点<br>            * 组成关键字的字母全部小写(代码中的蓝色部分) ,注意String不是关键字<br>        * c: 常见关键字<br>            * public static void class等<br>        * d: 注意事项<br>            * goto与const是Java中的保留字，即没有赋予特殊含义却仍被Java占用的单词,类似Editplus这样的高级记事本,针对关键字有特殊的颜色标记，非常直观 </p>
<p>###13标识符<br>    * A: 标识符<br>        * a: 定义<br>            * 就是给类,接口,方法,变量等起名字时使用的字符序列<br>        * b: 组成规则(只能包含下面的内容,不能有其它内容)<br>            * 1: 英文大小写字母<br>            * 2：数字字符<br>            * 3：$和_<br>        * c: 注意事项<br>            * 1：数字不能开头<br>            * 2：不可以使用关键字<br>            * 3：严格区分大小写，不限制长度<br>            * 4：起名时，尽量达到见名知意<br>    * B：标识符中常见的命名规则(这些规定是不受语法约束的)<br>        * a: 包名：多单词组成时所有字母均小写，使用.连接  aaa.bbb.ccc<br>        * b: 类名&amp;接口名：大驼峰式   AaaBbbCcc<br>        * c: 变量名&amp;方法名：小驼峰式   aaaBbbCcc<br>        * d: 常量名：多单词组成是所有字母均大写，使用_连接AAA_BBB_CCC<br>    * C: 案例代码<br>        /*<br>           标识符<br>           Java中，自己定义的内容<br>           自定义类的名字，上一个案例 HelloWorld<br>           标识符的规则：<br>             组成： 字母52个A-Z a-z 数字0-9 _ 下划线 $ 美元符</p>
<pre><code>     注意： 不能数字开头，不能是关键字

     定义名字：
        _abc  0a  a0  a#a  a$a   void
         YES  NO  YES NO   YES   NO

     类的名字： 首字母大写，第二个单词首字母大写
      BeiJingShiHaiDianQuYiYuan
      MeiGuoJiaLiFuNiYa

     方法的名字：首字母小写，每个单词首字母大写
       addStudent  
*/
public class Demo{

}</code></pre><p>###14Java中的数据类型<br>    * A:为什么有数据类型<br>        * Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型<br>    * B:Java中数据类型的分类<br>        * 基本数据类型: 基本数据类型是Java语言中内置的类型，分别是整数类型、小数类型、字符类型、布尔类型。<br>            这四类基本类型是最简单、最基础的类型。<br>            * 整数(byte、short、int、long)、小数(float、double)、字符类型(char)、布尔类型(boolean)<br>        * 引用数据类型: 是强大的数据类型，它是基于基本数据类型创建的。JavaSE中提供了一个超级类库，类库中包含了近万种引用数据类型。<br>            不过现在我们先要学习的是基本类型！<br>            * 数组、类、接口</p>
<p>###15Java中的常量<br>    * A: 常量的定义<br>        * 常量就是不变的数据量, 在程序执行的过程中其值不可以发生改变<br>    * B: 常量分类<br>        * a: 整数类型<br>            * 十进制表示方式：正常数字   如 13、25等<br>            * 二进制表示方式：以0b(0B)开头    如0b1011 、0B1001<br>            * 十六进制表示方式：以0x(0X)开头   数字以0-9及A-F组成  如0x23A2、0xa、0x10<br>            * 八进制表示方式：以0开头   如01、07、0721<br>        * b: 小数类型<br>            * 如1.0、-3.15、3.168等<br>        * c: 布尔类型<br>            * true、false<br>        * d: 字符类型<br>            * 如’a’，’A’, ‘0’, ‘家’<br>            * 字符必须使用’’ 包裹，并且其中只能且仅能包含一个字符。<br>        * e: 字符串类型<br>            * 字符串String类型是一种引用类型，我们先了解作为常量类型的使用方式<br>            * 如“我爱Java”，“0123”，“”，“null”<br>            * 字符串必须使用“”包裹，其中可以包含0~N个字符。</p>
<p>###16程序中输出Java中的常量<br>    * A: 案例代码<br>        /*<br>           Demo_1类，演示Java中的所有类型的常量<br>           程序当中输出：<br>             输出整数常量<br>             小数常量<br>             布尔常量<br>             字符常量<br>             字符串常量<br>        */<br>        public class Demo_1{<br>            public static void main(String[] args){<br>                //输出整数 十进制<br>                System.out.println(50);</p>
<pre><code>        //输出整数，二进制, 数字开头0B
        System.out.println(0B11);

        //输出整数，八进制，数字开头0
        System.out.println(051);

        //输出整数，十六进制，数组开头0X  0-9 A-F
        System.out.println(0XE);

        //输出浮点数据
        System.out.println(5.0);

        //输出布尔数据，只有2个值，true，false 关键字
        System.out.println(true);
        System.out.println(false);

        //输出字符常量，单引号包裹，只能写1个字符
        System.out.println(&apos;a&apos;);

        //输出字符串常量，双引号包裹，可以写0-n个字符
        System.out.println(&quot;HelloWorld&quot;);
    }
}</code></pre><p>###17总结</p>
<ul>
<li>把今天的知识点总结一遍。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day33%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day33%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记33</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:14" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:14+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:14:44" itemprop="dateModified" datetime="2020-12-23T23:14:44+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、类加载器<br>2、反射构造方法<br>3、反射成员变量<br>4、反射成员方法<br>5、反射配置文件运行类中的方法</p>
<p>第一节课 类加载器<br>###01类的加载.avi(11:08)<br>###02类的加载时机.avi(06:19)<br>###03三种类的加载器.avi(05:14)</p>
<p>第二节课 反射<br>###01反射的概念以及作用.avi(09:23)<br>###02class文件的产生过程.avi(05:27)</p>
<p>###03获取class文件对象三种方式.avi(11:57)<br>###04反射获取空参数构造方法并运行.avi(15:55)<br>###05反射获取有参数的构造方法并运行.avi(06:27)<br>###06反射获取构造方法并运行的快速的方式.avi(06:14)</p>
<p>###07反射获取私有构造方法并运行.avi(09:41)<br>###08反射获取成员变量并改值.avi(09:22)<br>###09反射获取空参数成员方法并运行.avi(11:23)<br>###10反射获取有参数的成员方法并运行.avi(03:43)</p>
<p>###11反射泛型擦除.avi(10:29)<br>###12反射通过配置文件运行的步骤.avi(07:05)<br>###13反射通过配置文件运行功能实现.avi(09:12)</p>
<p>============上面的内容,方便我们只做ppt,word教案以及书写下面的简要的笔记=================</p>
<p>###01类加载器<br>    * A.类的加载<br>        当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。<br>        * a 加载<br>            * 就是指将class文件读入内存，并为之创建一个Class对象。<br>            * 任何类被使用时系统都会建立一个Class对象<br>        * b 连接<br>            * 验证 是否有正确的内部结构，并和其他类协调一致<br>            * 准备 负责为类的静态成员分配内存，并设置默认初始化值<br>            * 解析 将类的二进制数据中的符号引用替换为直接引用<br>        * c 初始化<br>            * 就是我们以前讲过的初始化步骤（new 对象）<br>        * 注：简单的说就是：把.class文件加载到内存里，并把这个.class文件封装成一个Class类型的对象。<br>    * B.类的加载时机<br>        以下的情况，会加载这个类。<br>        * a. 创建类的实例<br>        * b. 类的静态变量，或者为静态变量赋值<br>        * c. 类的静态方法<br>        * d. 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象<br>        * e. 初始化某个类的子类<br>        * f. 直接使用java.exe命令来运行某个主类</p>
<pre><code>* C: 类加载器(了解)
    负责将.class文件加载到内在中，并为之生成对应的Class对象。
    * a. Bootstrap ClassLoader 根类加载器
        * 也被称为引导类加载器，负责Java核心类的加载
        * 比如System,String等。在JDK中JRE的lib目录下rt.jar文件中</code></pre><p>        * b. Extension ClassLoader 扩展类加载器<br>            * 负责JRE的扩展目录中jar包的加载。<br>            * 在JDK中JRE的lib目录下ext目录<br>        * c. System ClassLoader 系统类加载器<br>            * 负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径。<br>            * 我们用的是System ClassLoader 系统类加载器</p>
<p>###02反射<br>    * A. 反射定义<br>        * a. JAVA反射机制是在运行状态中，<br>                对于任意一个类，都能够知道这个类的所有属性和方法；<br>                对于任意一个对象，都能够调用它的任意一个方法和属性；<br>            这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<pre><code>    * b.反射技术
        条件：运行状态
        已知：一个类或一个对象(根本是已知.class文件)
        结果：得到这个类或对象的所有方法和属性

    * 注: 要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象。
* B. Class类
    * a. Class类及Class对象的了解
        要想解剖一个类，必须先了解Class对象。
        阅读API的Class类得知，Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的。
    * b. 得到Class对象
        * 1. 有三个方法
            方式一: 通过Object类中的getClass()方法
                Person person = new Person();
                Class clazz = person.getClass();
            方式二: 通过 类名.class 获取到字节码文件对象（任意数据类型都具备一个class静态属性,看上去要比第一种方式简单）。
                Class clazz = Person.class;
            方式三: 通过Class类中的方法（将类名作为字符串传递给Class类中的静态方法forName即可）。
                Class c3 = Class.forName(&quot;Person&quot;);
            注：第三种和前两种的区别是：
                    前两种你必须明确Person类型.
                    后面是指定这种类型的字符串就行.这种扩展更强.我不需要知道你的类.我只提供字符串,按照配置文件加载就可以了

        * 2. 得到Class对象的三个方法代码演示：
            代码演示
            /*
             * 获取.class字节码文件对象的方式
             *         1：通过Object类中的getObject()方法
             *         2: 通过 类名.class 获取到字节码文件对象
             *         3: 反射中的方法,
             *             public static Class&lt;?&gt; forName(String className) throws ClassNotFoundException
             *             返回与带有给定字符串名的类或接口相关联的 Class 对象 
             */
            public class ReflectDemo {
                public static void main(String[] args) throws ClassNotFoundException {
                    // 1： 通过Object类中的getObject()方法
                    // Person p1 = new Person();
                    // Class c1 = p1.getClass();
                    // System.out.println(&quot;c1 = &quot;+ c1);

                    // 2: 通过 类名.class 获取到字节码文件对象
                    // Class c2 = Person.class;
                    // System.out.println(&quot;c2 = &quot;+ c2);

                    // 3: 反射中的方法
                    Class c3 = Class.forName(&quot;cn.itcast_01_Reflect.Person&quot;);// 包名.类名
                    System.out.println(&quot;c3 = &quot; + c3);
                }
            }</code></pre><p>                Person类<br>                package cn.itcast_01_Reflect;<br>                public class Person {<br>                    //成员变量<br>                    public String name;<br>                    public int age;<br>                    private String address;</p>
<pre><code>                //构造方法
                public Person() {
                    System.out.println(&quot;空参数构造方法&quot;);
                }

                public Person(String name) {
                    this.name = name;
                    System.out.println(&quot;带有String的构造方法&quot;);
                }
                //私有的构造方法
                private Person(String name, int age){
                    this.name = name;
                    this.age = age;
                    System.out.println(&quot;带有String，int的构造方法&quot;);
                }

                public Person(String name, int age, String address){
                    this.name = name;
                    this.age = age;
                    this.address = address;
                    System.out.println(&quot;带有String, int, String的构造方法&quot;);
                }

                //成员方法
                //没有返回值没有参数的方法
                public void method1(){
                    System.out.println(&quot;没有返回值没有参数的方法&quot;);
                }
                //没有返回值，有参数的方法
                public void method2(String name){
                    System.out.println(&quot;没有返回值，有参数的方法 name= &quot;+ name);
                }
                //有返回值，没有参数
                public int method3(){
                    System.out.println(&quot;有返回值，没有参数的方法&quot;);
                    return 123;
                }
                //有返回值，有参数的方法
                public String method4(String name){
                    System.out.println(&quot;有返回值，有参数的方法&quot;);
                    return &quot;哈哈&quot; + name;
                }
                //私有方法
                private void method5(){
                    System.out.println(&quot;私有方法&quot;);
                }

                @Override
                public String toString() {
                    return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;, address=&quot; + address+ &quot;]&quot;;
                }
            }
        * 注: Class类型的唯一性
            因为一个.class文件在内存里只生成一个Class对象，所以无论那一种方法得到Class对象，得到的都是同一个对象。
* C.通过反射获取无参构造方法并使用
    * a. 得到无参构造方法
        public Constructor&lt;?&gt;[] getConstructors() 
            获取所有的public 修饰的构造方法。
            选择无参构造方法，不建议使用。
        public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) 
            获取public修饰, 指定参数类型所对应的构造方法。
            不传参数得到无参构造方法。
    * b. 运行无参构造方法
        public T newInstance(Object... initargs) 
            使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。 
            因为是无参构造，所以不传参数。
    * c. 通过反射获取无参构造方法并使用的代码演示：
            package cn.itcast.demo1;

            import java.lang.reflect.Constructor;

            /*
             *  通过反射获取class文件中的构造方法,运行构造方法
             *  运行构造方法,创建对象
             *    获取class文件对象
             *    从class文件对象中,获取需要的成员
             *    
             *  Constructor 描述构造方法对象类
             */
            public class ReflectDemo1 {
                public static void main(String[] args) throws Exception {

                    Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);
                    //使用class文件对象,获取类中的构造方法
                    //  Constructor[]  getConstructors() 获取class文件对象中的所有公共的构造方法
                    /*Constructor[] cons = c.getConstructors();
                    for(Constructor con : cons){
                        System.out.println(con);
                    }*/
                    //获取指定的构造方法,空参数的构造方法
                    Constructor con =  c.getConstructor();
                    //运行空参数构造方法,Constructor类方法 newInstance()运行获取到的构造方法
                    Object obj = con.newInstance();
                    System.out.println(obj.toString());
                }
            }
* D. 通过反射获取有参构造方法并使用
    * a. 得到有参的构造方法
        public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) 
            获取public修饰, 指定参数类型所对应的构造方法。
            传相应的参数类型得到有参构造方法。
    * b. 运行无参构造方法
        public T newInstance(Object... initargs) 
            使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。 
            因为是有参构造，所以传相应的参数值。
    * c. 通过反射获取有参构造方法并使用的代码演示：
        package cn.itcast.demo1;

        import java.lang.reflect.Constructor;

        /*
         *  通过反射,获取有参数的构造方法并运行
         *  方法getConstructor,传递可以构造方法相对应的参数列表即可
         */
        public class ReflectDemo2 {
            public static void main(String[] args)throws Exception {
                Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);
                //获取带有,String和int参数的构造方法
                //Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)  
                //Class&lt;?&gt;... parameterTypes 传递要获取的构造方法的参数列表
                Constructor con = c.getConstructor(String.class,int.class);
                //运行构造方法
                // T newInstance(Object... initargs)  
                //Object... initargs 运行构造方法后,传递的实际参数
                Object obj = con.newInstance(&quot;张三&quot;,20);
                System.out.println(obj);
            }
        }
* E. 通过反射获取有参构造方法并使用快捷方式
    * a. 使用的前提
        类有空参的公共构造方法。（如果是同包，默认权限也可以）
    * b. 使用的基础
        Class类的 public T newInstance() 方法
             创建此 Class 对象所表示的类的一个新实例。
    * c. 通过反射获取有参构造方法并使用快捷方式的代码演示：
        package cn.itcast.demo1;
        /*
         * 反射获取构造方法并运行,有快捷点的方式
         * 有前提:
         *   被反射的类,必须具有空参数构造方法
         *   构造方法权限必须public
         */
        public class ReflectDemo3 {
            public static void main(String[] args) throws Exception {
                Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);
                // Class类中定义方法, T newInstance() 直接创建被反射类的对象实例
                Object obj = c.newInstance();
                System.out.println(obj);
            }
        }
* F. 通过反射获取私有构造方法并使用
    * a. 得到私有的构造方法
        public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) 
            获取指定参数类型所对应的构造方法(包含私有的)。
        public Constructor&lt;?&gt;[] getDeclaredConstructors() 
            获取所有的构造方法(包含私有的)。
    * b. 运行私有构造方法
        public void setAccessible(boolean flag)
            将此对象的 accessible 标志设置为指示的布尔值。
            设置为true,这个方法保证我们得到的私有构造方法的运行。（取消运行时期的权限检查。）
        public T newInstance(Object... initargs) 
            使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。 
    * c. 通过反射获取私有构造方法并使用的代码演示：
        package cn.itcast.demo1;

        import java.lang.reflect.Constructor;

        /*
         *  反射获取私有的构造方法运行
         *  不推荐,破坏了程序的封装性,安全性
         *  暴力反射
         */
        public class ReflectDemo4 {
            public static void main(String[] args) throws Exception{
                Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);
                //Constructor[] getDeclaredConstructors()获取所有的构造方法,包括私有的
                /*Constructor[] cons = c.getDeclaredConstructors();
                for(Constructor con : cons){
                    System.out.println(con);
                }*/
                //Constructor getDeclaredConstructor(Class...c)获取到指定参数列表的构造方法
                Constructor con = c.getDeclaredConstructor(int.class,String.class);

                //Constructor类,父类AccessibleObject,定义方法setAccessible(boolean b)
                con.setAccessible(true);

                Object obj = con.newInstance(18,&quot;lisi&quot;);
                System.out.println(obj);
            }
        }
    * 注：不推荐，破坏了程序的封装性,安全性。
* G. 反射获取成员变量并改值
    * a. 获取成员变量
        * 得到公共的成员变量
            public Field getField(String name) 
                返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定公共成员字段。 
            public Field[] getFields() 
                返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问公共字段。 
        * 得到所有的成员变量(包括私有的，如果要进行修改私有成员变量，要先进行public void setAccessible(boolean flag) 设置。)
            public Field getDeclaredField(String name) 
                返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段。 
            public Field[] getDeclaredFields() 
                返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段。 
    * b. 修改成员变量(Field)的值
        * 修改公共的成员变量
            public void set(Object obj, Object value) 
                将指定对象变量上此 Field 对象表示的字段设置为指定的新值。 
                obj指的是修改的是那个对象的这个成员变量值。
    * c. 反射获取成员变量并改值的代码演示
        package cn.itcast.demo1;
        import java.lang.reflect.Field;
        /*
         *  反射获取成员变量,并修改值
         *  Person类中的成员String name
         */
        public class ReflectDemo5 {
            public static void main(String[] args) throws Exception{
                Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);
                Object obj = c.newInstance();
                //获取成员变量 Class类的方法 getFields() class文件中的所有公共的成员变量
                //返回值是Field[]    Field类描述成员变量对象的类
                /*Field[] fields = c.getFields();
                for(Field f : fields){
                    System.out.println(f);
                }*/

                //获取指定的成员变量 String name
                //Class类的方法  Field getField(传递字符串类型的变量名) 获取指定的成员变量
                Field field = c.getField(&quot;name&quot;);

                //Field类的方法 void set(Object obj, Object value) ,修改成员变量的值
                //Object obj 必须有对象的支持,  Object value 修改后的值
                field.set(obj,&quot;王五&quot;);
                System.out.println(obj);

            }
        }
* H. 反射获取空参数成员方法并运行
    * a. 获取空参数成员方法
        * 得到公共的成员方法
            public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 
                返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。 
            public Method[] getMethods()
                返回一个包含某些 Method 对象的数组，这些对象反映此 Class对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。
        * 得到全部的成员方法(包括私有的，如果要使用私有成员方法，要先进行public void setAccessible(boolean flag) 设置。)
            public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) 
                返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。 
            public Method[] getDeclaredMethods() 
                返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 
    * b. 使用Method方法对象
        public Object invoke(Object obj, Object... args) 
            对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。 
            obj 指的是调这个方法的对象。
            args 指的是调用这个方法所要用到的参数列表。
            返回值Object就是方法的返回对象。如果方法没有返回值 ，返回的是null.
    * c. 反射获取空参数成员方法并运行代码演示
        package cn.itcast.demo1;

        import java.lang.reflect.Method;

        /*
         *  反射获取成员方法并运行
         *  public void eat(){}
         */
        public class ReflectDemo6 {
            public static void main(String[] args) throws Exception{
                Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);
                Object obj = c.newInstance();
                //获取class对象中的成员方法
                // Method[] getMethods()获取的是class文件中的所有公共成员方法,包括继承的
                // Method类是描述成员方法的对象
                /*Method[] methods = c.getMethods();
                for(Method m : methods){
                    System.out.println(m);
                }*/

                //获取指定的方法eat运行
                // Method getMethod(String methodName,Class...c)
                // methodName获取的方法名  c 方法的参数列表
                Method method = c.getMethod(&quot;eat&quot;);
                //使用Method类中的方法,运行获取到的方法eat
                //Object invoke(Object obj, Object...o)
                method.invoke(obj);
            }
        }

* I. 反射获取有参数成员方法并运行
    * a. 获取有参数成员方法
        * 得到公共的成员方法
            public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 
                返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。 
            public Method[] getMethods()
                返回一个包含某些 Method 对象的数组，这些对象反映此 Class对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。
        * 得到全部的成员方法(包括私有的，如果要使用私有成员方法，要先进行public void setAccessible(boolean flag) 设置。)
            public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) 
                返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。 
            public Method[] getDeclaredMethods() 
                返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 
    * b. 使用Method方法对象
        public Object invoke(Object obj, Object... args) 
            对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。 
            obj 指的是调这个方法的对象。
            args 指的是调用这个方法所要用到的参数列表。
            返回值Object就是方法的返回对象。如果方法没有返回值 ，返回的是null.
    * c. 反射获取有参数成员方法并运行代码演示
        package cn.itcast.demo1;
        import java.lang.reflect.Method;

        /*
         *  反射获取有参数的成员方法并执行
         *  public void sleep(String,int,double){}
         */
        public class ReflectDemo7 {
            public static void main(String[] args) throws Exception{
                Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);
                Object obj = c.newInstance();
                //调用Class类的方法getMethod获取指定的方法sleep
                Method method = c.getMethod(&quot;sleep&quot;, String.class,int.class,double.class);
                //调用Method类的方法invoke运行sleep方法
                method.invoke(obj, &quot;休眠&quot;,100,888.99);
            }
        }
* J. 反射泛型擦除
    * a. 使用情况
        例如：在泛型为String的集合里，添加Integer的数据
        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(100);
    * b. 能用泛型擦除的理论
        伪泛型：在编译后的.class文件里面是没有泛型的。类型为Object。
        用反射的方法绕过编译，得到Class文件对象，直接调用add方法。
    * c. 反射泛型擦除的代码演示
        package cn.itcast.demo2;
        import java.lang.reflect.Method;
        import java.util.ArrayList;

        /*
         *   定义集合类,泛型String
         *   要求向集合中添加Integer类型
         *   
         *   反射方式,获取出集合ArrayList类的class文件对象
         *   通过class文件对象,调用add方法
         *   
         *   对反射调用方法是否理解
         */
        public class ReflectTest {
            public static void main(String[] args)throws Exception {
                ArrayList&lt;String&gt; array  = new ArrayList&lt;String&gt;();
                array.add(&quot;a&quot;);
                //反射方式,获取出集合ArrayList类的class文件对象
                Class c = array.getClass();
                //获取ArrayList.class文件中的方法add
                Method method = c.getMethod(&quot;add&quot;,Object.class);
                //使用invoke运行ArrayList方法add
                method.invoke(array, 150);
                method.invoke(array, 1500);
                method.invoke(array, 15000);
                System.out.println(array);</code></pre><p>​<br>                }<br>            }<br>    * K. 反射通过配置文件来决定运行的步骤<br>        * a. 操作依据<br>                通过配置文件得到类名和要运行的方法名,用反射的操作类名得到对象和调用方法<br>        * b. 实现步骤:<br>             *    1. 准备配置文件,键值对<br>             *    2. IO流读取配置文件  Reader<br>             *    3. 文件中的键值对存储到集合中 Properties<br>             *        集合保存的键值对,就是类名和方法名<br>             *    4. 反射获取指定类的class文件对象<br>             *    5. class文件对象,获取指定的方法<br>             *    6. 运行方法<br>        * c. 代码演示<br>            代码：<br>            package cn.itcast.demo3;</p>
<pre><code>import java.io.FileReader;
import java.lang.reflect.Method;
import java.util.Properties;

/*
 *  调用Person方法,调用Student方法,调用Worker方法
 *  类不清楚,方法也不清楚
 *  通过配置文件实现此功能
 *    运行的类名和方法名字,以键值对的形式,写在文本中
 *    运行哪个类,读取配置文件即可
 *  实现步骤:
 *    1. 准备配置文件,键值对
 *    2. IO流读取配置文件  Reader
 *    3. 文件中的键值对存储到集合中 Properties
 *        集合保存的键值对,就是类名和方法名
 *    4. 反射获取指定类的class文件对象
 *    5. class文件对象,获取指定的方法
 *    6. 运行方法
 */
public class Test {
    public static void main(String[] args) throws Exception{
        //IO流读取配置文件
        FileReader r = new FileReader(&quot;config.properties&quot;);
        //创建集合对象
        Properties pro = new Properties();
        //调用集合方法load,传递流对象
        pro.load(r);
        r.close();
        //通过键获取值
        String className = pro.getProperty(&quot;className&quot;);
        String methodName = pro.getProperty(&quot;methodName&quot;);
        //反射获取指定类的class文件对象
        Class c = Class.forName(className);
        Object obj = c.newInstance();
        //获取指定的方法名
        Method method = c.getMethod(methodName);
        method.invoke(obj);
    }
}
配置文件：
#className=cn.itcast.demo3.Student
#methodName=study
className=cn.itcast.demo3.Person
methodName=eat
#className=cn.itcast.demo3.Worker
#methodName=job</code></pre><p>###3总结</p>
<ul>
<li>把今天的知识点总结一遍。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day32%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day32%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记32</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:14:35" itemprop="dateModified" datetime="2020-12-23T23:14:35+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day31%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day31%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记31</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:14:20" itemprop="dateModified" datetime="2020-12-23T23:14:20+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、管家婆项目</p>
<p>###01项目训练目标<br>    * A: 项目训练目标<br>        * a: 项目目标<br>            * 综合运用前面所学习的知识点<br>            * 熟练View层、Service层、Dao层之间的方法相互调用操作、<br>            * 熟练dbutils操作数据库表完成增删改查<br>            * 了解公司项目开发的流程，充分的掌握项目需求分析、设计与功能的代码实现。提高同学们独立分析需求与功能实现的能力。            </p>
<p>###02项目中的功能模块<br>    * A: 项目中的功能模块<br>        * a: 五大模块<br>            * 查询账务<br>            * 多条件组合查询账务<br>            * 添加账务<br>            * 编辑账务<br>            * 删除账务</p>
<p>###03技术的选择和相关jar包<br>    * A: 技术的选择和相关jar包<br>        * a: apache的commons组件：<br>            * commons-dbutils-1.4.jar：封装并简化了JDBC；<br>            * commons-dbcp-1.4.jar：apache commons提供的数据库连接池组件，命名为DBCP；<br>        * b: commons.pool-1.3.jar：DBCP连接池依赖该jar包；<br>            * mysql-connector-java-5.1.28-bin.jar：MySQL的JDBC驱动包，用JDBC连接MySQL数据库必须使用该JAR包。</p>
<p>###04项目中的工具类<br>    * A: 项目中的工具类<br>        * a: 工具类的介绍<br>            * 每个项目中都会有很多个工具类，不要求每个工具类对能独立写出来，但是要会使用工具类<br>            * JDBCUtils：用来创建数据库连接池对象</p>
<p>###05数据表的设计<br>    * A: 数据表的设计<br>        * a: 数据表的设计(详见：day34_source/表关系.JPG)<br>            * 表与表之间是有关系的<br>            * 主表和从表的关系<br>            * 主表中的主键作为从表中的外键</p>
<p>​<br>###06创建数据库数据表写入测试数据<br>    * A: 创建数据库数据表写入测试数据<br>        * a: 创建数据库数据表<br>            /*<br>              创建管家婆的数据库<br>              名字 gjp<br>            */<br>            CREATE DATABASE gjp;</p>
<pre><code>    USE gjp;

    /*
      创建数据表,表名账务
      字段,列
      主键
      分类名称  可变字符
      金额  double
      账户  可变字符 (支付,收入方法)
      创建日期 date
      账务描述 可变字符
    */

    CREATE TABLE gjp_zhangwu(
       -- 主键
       zwid INT PRIMARY KEY AUTO_INCREMENT,
       -- 分类名称   
       flname VARCHAR(200),
       -- 金额
       money DOUBLE,
       -- 账户
       zhanghu VARCHAR(100),
       -- 创建日期
       createtime DATE,
       -- 账务描述
       description  VARCHAR(1000)
    );
    SELECT * FROM gjp_zhangwu;
* b: 写入数据
    -- 写入测试的数据
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (1,&apos;吃饭支出&apos;,247,&apos;交通银行&apos;,&apos;2016-03-02&apos;,&apos;家庭聚餐&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (2,&apos;工资收入&apos;,12345,&apos;现金&apos;,&apos;2016-03-15&apos;,&apos;开工资了&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (3,&apos;服装支出&apos;,1998,&apos;现金&apos;,&apos;2016-04-02&apos;,&apos;买衣服&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (4,&apos;吃饭支出&apos;,325,&apos;现金&apos;,&apos;2016-06-18&apos;,&apos;朋友聚餐&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (5,&apos;股票收入&apos;,8000,&apos;工商银行&apos;,&apos;2016-10-28&apos;,&apos;股票大涨&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (6,&apos;股票收入&apos;,5000,&apos;工商银行&apos;,&apos;2016-10-28&apos;,&apos;股票又大涨&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (7,&apos;工资收入&apos;,5000,&apos;交通银行&apos;,&apos;2016-10-28&apos;,&apos;又开工资了&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (8,&apos;礼金支出&apos;,5000,&apos;现金&apos;,&apos;2016-10-28&apos;,&apos;朋友结婚&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (9,&apos;其他支出&apos;,1560,&apos;现金&apos;,&apos;2016-10-29&apos;,&apos;丢钱了&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (10,&apos;交通支出&apos;,2300,&apos;交通银行&apos;,&apos;2016-10-29&apos;,&apos;油价还在涨啊&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (11,&apos;吃饭支出&apos;,1000,&apos;工商银行&apos;,&apos;2016-10-29&apos;,&apos;又吃饭&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (12,&apos;工资收入&apos;,1000,&apos;现金&apos;,&apos;2016-10-30&apos;,&apos;开资&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (13,&apos;交通支出&apos;,2000,&apos;现金&apos;,&apos;2016-10-30&apos;,&apos;机票好贵&apos;);
    INSERT  INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (14,&apos;工资收入&apos;,5000,&apos;现金&apos;,&apos;2016-10-30&apos;,&apos;又开资&apos;);</code></pre><p>###07项目中的分层设计<br>    * A: 项目中的分层设计<br>        * a: 各层功能介绍<br>            * view层作用: 视图层,即项目中的界面<br>            * controller层作用: 控制层, 获取界面上的数据,为界面设置数据; 将要实现的功能交给业务层处理<br>            * service层作用: 业务层, 功能的实现, 与controller控制层和数据访问层DAO交互, 将对数据库的操作交给DAO数据访问层来处理<br>            * dao层作用: 数据访问层, 用来操作数据库表的数据<br>            * db数据库: 这里指MySQL<br>            * domain 实体包: 存放JavaBean<br>            * tools工具包:存放项目中使用到的工具类<br>            * test 测试包: 存放项目功能测试的代码</p>
<p>​<br>###08创建项目_分层_导入jar包<br>    * A: 创建项目_分层_导入jar包<br>        * a: 创建工程包<br>            * cn.itcast.gjp.app: 存放main方法类；<br>            * cn.itcast.gjp.domain: 存放JavaBean；<br>            * cn.itcast.gjp.view: 存放界面，及表现层类；<br>            * cn.itcast.gjp.service: 存放业务层类；<br>            * cn.itcast.gjp.dao: 存放数据访问层类;<br>            * cn.itcast.gjp.tools:存放工具类<br>        * b: 导入jar包<br>            * 在项目根路径下建立文件夹lib<br>            * 导入以下jar包<br>                * mysql-connector-java-5.1.37-bin.jar：数据库驱动<br>                * commons-dbutils-1.6.jar：提供QueryRunner类方便进行增删改查操作<br>                * commons-dbcp-1.4.jar：<br>                * commons-pool-1.5.6.jar：提供高效的数据库连接池技术<br>            * 拷贝以上jar包，选定拷贝的jar包/右键/Build Path/Add to Build Path</p>
<p>###09创建domain包中的类<br>    * A: 创建domain包中的类<br>        * a: 案例代码<br>            public class ZhangWu {<br>                 private int  zwid;</p>
<pre><code>     private String flname; 

     private double  money; 

     private String zhanghu;

     private String createtime; 

     private String description;
     //注意生成空参构造、有参构造、set和get方法、toString方法等
}</code></pre><p>###10创建JDBCUtils工具类<br>    * A：创建JDBCUtils工具类<br>        * a: 案例代码<br>            public class JDBCUtils{<br>                //创建BasicDataSource对象<br>                private static BasicDataSource datasource = new BasicDataSource();<br>                //静态代码块,实现必要参数设置<br>                static{<br>                    datasource.setDriverClassName(“com.mysql.jdbc.Driver”);<br>                    datasource.setUrl(“jdbc:mysql://localhost:3306/gjp”);<br>                    datasource.setUsername(“root”);<br>                    datasource.setPassword(“123”);<br>                    datasource.setMaxActive(10);<br>                    datasource.setMaxIdle(5);<br>                    datasource.setMinIdle(2);<br>                    datasource.setInitialSize(10);<br>                }<br>                public static DataSource getDataSource(){<br>                    return datasource;<br>                }<br>            }</p>
<p>​<br>###11创建其他包中的类</p>
<pre><code>* A: 创建其他包中的类
    * a: cn.itcast.gjp.dao包中创建ZhangWuDao类
        /*
         *  实现对数据表 gjp_zhangwu 数据增删改查操作
         *  dbuils工具类完成,类成员创建QueryRunner对象,指定数据源
         */
        public class ZhangWuDao {
            private QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource());
        }
    * b: cn.itcast.gjp.service包中创建ZhangWuService类
        /*
         *  业务层类
         *  接收上一层,控制层controller的数据
         *  经过计算,传递给dao层,操作数据库
         *  调用dao层中的类,类成员位置,创建Dao类的对象
         */
        public class ZhangWuService {
            private ZhangWuDao dao = new ZhangWuDao();

        }
    * c: cn.itcast.gjp.controller包中建立ZhangWuController类
        /*
         *  控制器层
         *  接收视图层的数据,数据传递给service层
         *  成员位置,创建service对象
         */
        public class ZhangWuController {
            private ZhangWuService service = new ZhangWuService();                
        }
    * d: cn.itcast.gjp.view包中建立MainView类
        /*
         *  试图层,用户看到和操作的界面
         *  数据传递给controller层实现
         *  成员位置,创建controller对象
         */
        public class MainView {
            private ZhangWuController controller = new ZhangWuController();

        }
    * e: cn.itcast.gjp.app包中建立MainApp类
        /*
         *  主程序类,作用,开启软件程序
         */
        public class MainApp {
            public static void main(String[] args) {
                new MainView().run();
            }
        }</code></pre><p>###12实现用户的界面菜单<br>    * A: 实现用户的界面菜单<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.view包中建立MainView类中添加run方法<br>            /*<br>             *  实现界面效果<br>             *  接收用户的输入<br>             *  根据数据,调用不同的功能方法<br>             */<br>            public void run(){<br>                //创建Scanner类对象,反复键盘输入<br>                Scanner sc = new Scanner(System.in);<br>                while(true){<br>                    System.out.println(“—————管家婆家庭记账软件—————“);<br>                    System.out.println(“1.添加账务　2.编辑账务　3.删除账务　4.查询账务　5.退出系统”);<br>                    System.out.println(“请输入要操作的功能序号[1-5]:”);<br>                    //接收用户的菜单选择<br>                    int choose = sc.nextInt();<br>                    //对选择的菜单判断,调用不同的功能<br>                    switch(choose){<br>                    case 1:<br>                       // 选择添加账务,调用添加账务的方法<br>                        break;<br>                    case 2:<br>                        // 选择的编辑账务,调用编辑账务方法<br>                        break;<br>                    case 3:<br>                        // 选择的删除账务,调用删除账务方法<br>                        break;<br>                    case 4:<br>                        // 选择的是查询账务,调用查询方法<br>                        //selectZhangWu();<br>                        break;<br>                    case 5:<br>                        System.exit(0);<br>                        break;<br>                    }<br>                }<br>            }</p>
<p>​            </p>
<p>###13实现查询的界面菜单<br>    * A: 实现查询的界面菜单<br>        * a: 案例核心代码<br>            *  cn.itcast.gjp.view包中建立MainView类中添加selectZhangWu方法、selectAll方法、select方法<br>                /*<br>                 * 定义方法 selectZhangWu()<br>                 * 显示查询的方式 1 所有查询   2 条件查询<br>                 * 接收用户的选择<br>                 <em>/<br>                 public void selectZhangWu(){<br>                     System.out.println(“1. 查询所有    2. 条件查询”);<br>                     Scanner sc = new Scanner(System.in);<br>                     int selectChooser = sc.nextInt();<br>                     //判断根据用户的选择,调用不同的功能<br>                     switch(selectChooser){<br>                     case 1:<br>                         //选择的查询所有,调用查询所有的方法<br>                         selectAll();<br>                         break;<br>                     case 2:<br>                         //选的条件查询,调用带有查询条件的方法<br>                         select();<br>                         break;<br>                     }<br>                 }<br>                 /</em><br>                  * 定义方法,实现查询所有的账务数据<br>                  */<br>                 public void selectAll(){</p>
<pre><code>}

/*
 * 定义方法,实现条件查询账务数据
 * 提供用户的输入日期,开始日期结束日期
 * 就2个日期,传递到controller层
 * 调用controller的方法,传递2个日期参数
 * 获取到controller查询的结果集,打印出来
 */
public void select(){

}</code></pre><p>###14实现查询所有账务的控制,业务层的实现<br>    * A: 实现查询所有账务的控制,业务层的实现<br>        * a: 案例核心代码<br>            * a: cn.itcast.gjp.dao包中创建ZhangWuDao类<br>            /*<br>             *  实现对数据表 gjp_zhangwu 数据增删改查操作<br>             *  dbuils工具类完成,类成员创建QueryRunner对象,指定数据源<br>             <em>/<br>            public class ZhangWuDao {<br>                private QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource());<br>                /</em><br>                 * 定义方法,查询数据库,获取所有的账务数据<br>                 * 方法,由业务层调用<br>                 * 结果集,将所有的账务数据,存储到Bean对象中,存储到集合中<br>                 <em>/<br>                public List<ZhangWu> selectAll(){<br>                    return null;<br>                }<br>            }<br>            * b: cn.itcast.gjp.service包中创建ZhangWuService类<br>                /</ZhangWu></em><br>                 *  业务层类<br>                 *  接收上一层,控制层controller的数据<br>                 *  经过计算,传递给dao层,操作数据库<br>                 *  调用dao层中的类,类成员位置,创建Dao类的对象<br>                 <em>/<br>                public class ZhangWuService {<br>                    private ZhangWuDao dao = new ZhangWuDao();<br>                    /</em><br>                     *  定义方法,实现查询所有的账务数据<br>                     *  此方法,由控制层调用, 去调用dao层的方法<br>                     *  返回存储ZhangWu对象的List集合<br>                     <em>/<br>                    public List<ZhangWu> selectAll(){<br>                        return dao.selectAll();<br>                    }<br>                }<br>            * c: cn.itcast.gjp.controller包中建立ZhangWuController类<br>                /</ZhangWu></em><br>                 *  控制器层<br>                 *  接收视图层的数据,数据传递给service层<br>                 *  成员位置,创建service对象<br>                 <em>/<br>                public class ZhangWuController {<br>                    private ZhangWuService service = new ZhangWuService();<br>                    /</em><br>                     * 控制层类定义方法,实现查询所有的账务数据<br>                     * 方法由试图层调用,方法调用service层<br>                     */<br>                    public List<ZhangWu> selectAll(){<br>                        return service.selectAll();<br>                    }<br>                }</ZhangWu></p>
<p>###15实现查询所有账务的dao层的实现<br>    * A: 实现查询所有账务的dao层的实现<br>        * a: 案例核心代码<br>            * a: cn.itcast.gjp.dao包中创建ZhangWuDao类selectAll方法<br>            /*<br>             *  实现对数据表 gjp_zhangwu 数据增删改查操作<br>             *  dbuils工具类完成,类成员创建QueryRunner对象,指定数据源<br>             <em>/<br>            public class ZhangWuDao {<br>                private QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource());<br>                /</em><br>                 * 定义方法,查询数据库,获取所有的账务数据<br>                 * 方法,由业务层调用<br>                 * 结果集,将所有的账务数据,存储到Bean对象中,存储到集合中<br>                 */<br>                public List<ZhangWu> selectAll(){<br>                    try{<br>                        //查询账务数据的SQL语句<br>                            String sql = “SELECT * FROM gjp_zhangwu”;<br>                            //调用qr对象的方法,query方法,结果集BeanListHandler<br>                            List<ZhangWu> list = qr.query(sql, new BeanListHandler&lt;&gt;(ZhangWu.class));<br>                            return list;<br>                        }catch(SQLException ex){<br>                            System.out.println(ex);<br>                            throw new RuntimeException(“查询所有账务失败”);<br>                        }<br>                }<br>            }</ZhangWu></ZhangWu></p>
<p>​<br>###16实现查询所有账务的view层的实现<br>    * A: 实现查询所有账务的view层的实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.view包中建立MainView类selectAll方法<br>            /*<br>              * 定义方法,实现查询所有的账务数据<br>              */<br>             public void selectAll(){<br>                 //调用控制层中的方法,查询所有的账务数据<br>                 List<ZhangWu> list = controller.selectAll();<br>                //输出表头<br>                 System.out.println(“ID\t\t类别\t\t账户\t\t金额\t\t时间\t\t说明”);<br>                 //遍历集合,结果输出控制台<br>                 for(ZhangWu zw : list){<br>                     System.out.println(zw.getZwid()+”\t\t”+zw.getFlname()+”\t\t”+zw.getZhanghu()+”\t\t”+<br>                     zw.getMoney()+”\t\t”+zw.getCreatetime()+”\t”+zw.getDescription());<br>                 }<br>             }</ZhangWu></p>
<p>###17实现条件查询账务的菜单实现<br>    * A: 实现条件查询账务的菜单实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.view包中建立MainView类select方法<br>              /*<br>              * 定义方法,实现条件查询账务数据<br>              * 提供用户的输入日期,开始日期结束日期<br>              * 就2个日期,传递到controller层<br>              * 调用controller的方法,传递2个日期参数<br>              * 获取到controller查询的结果集,打印出来<br>              */<br>             public void select(){<br>                 System.out.println(“选择条件查询,输入日期格式XXXX-XX-XX”);<br>                 Scanner sc = new Scanner(System.in);<br>                 System.out.print(“请输入开始日期:”);<br>                 String startDate = sc.nextLine();<br>                 System.out.print(“请输入结果日期:”);<br>                 String endDate = sc.nextLine();<br>                 //调用controller层的方法,传递日期,获取查询结果集</p>
<pre><code>}</code></pre><p>###18实现条件查询账务的控制层,业务层实现<br>    * A: 实现条件查询账务的控制层,业务层实现<br>        * a: 案例核心代码<br>            * a: cn.itcast.gjp.dao包中创建ZhangWuDao类<br>                /*<br>                 *  实现对数据表 gjp_zhangwu 数据增删改查操作<br>                 *  dbuils工具类完成,类成员创建QueryRunner对象,指定数据源<br>                 <em>/<br>                public class ZhangWuDao {<br>                    private QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource());<br>                    /</em><br>                     * 定义方法,查询数据库,带有条件去查询账务表<br>                     * 由业务层调用,查询结果集存储到Bean对象,存储到List集合<br>                     * 调用者传递2个日期字符串<br>                     <em>/<br>                    public List<ZhangWu> select(String startDate,String endDate){<br>                        return null;<br>                    }<br>                }<br>            * b: cn.itcast.gjp.service包中创建ZhangWuService类<br>                /</ZhangWu></em><br>                 *  业务层类<br>                 *  接收上一层,控制层controller的数据<br>                 *  经过计算,传递给dao层,操作数据库<br>                 *  调用dao层中的类,类成员位置,创建Dao类的对象<br>                 <em>/<br>                public class ZhangWuService {<br>                    private ZhangWuDao dao = new ZhangWuDao();<br>                    /</em><br>                     * 定义方法,实现条件查询账务<br>                     * 方法由控制层调用,传递2个日期字符串<br>                     * 调用dao层的方法,传递2个日期字符串<br>                     * 获取到查询结果集<br>                     <em>/<br>                    public List<ZhangWu> select(String startDate,String endDate){<br>                        return dao.select(startDate, endDate);<br>                    }<br>                }<br>            * c: cn.itcast.gjp.controller包中建立ZhangWuController类<br>                /</ZhangWu></em><br>                 *  控制器层<br>                 *  接收视图层的数据,数据传递给service层<br>                 *  成员位置,创建service对象<br>                 <em>/<br>                public class ZhangWuController {<br>                    private ZhangWuService service = new ZhangWuService();<br>                    /</em><br>                     * 定义方法,实现条件查询账务<br>                     * 方法由试图层调用,传递两个日期的字符串<br>                     * 调用service层的方法,传递两个日期字符串,获取结果集<br>                     * 结果集返回给试图<br>                     <em>/<br>                    public List<ZhangWu> select(String startDate,String endDate){<br>                        return service.select(startDate, endDate);<br>                    }<br>                }<br>###19实现条件查询账务的dao层实现<br>    * A: 实现条件查询账务的dao层实现<br>        * a: 案例核心代码<br>            * a: cn.itcast.gjp.dao包中创建ZhangWuDao类select方法<br>                /</ZhangWu></em><br>                 *  实现对数据表 gjp_zhangwu 数据增删改查操作<br>                 *  dbuils工具类完成,类成员创建QueryRunner对象,指定数据源<br>                 <em>/<br>                public class ZhangWuDao {<br>                    private QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource());<br>                    /</em><br>                     * 定义方法,查询数据库,带有条件去查询账务表<br>                     * 由业务层调用,查询结果集存储到Bean对象,存储到List集合<br>                     * 调用者传递2个日期字符串<br>                     */<br>                    public List<ZhangWu> select(String startDate,String endDate){<br>                        try{<br>                            //拼写条件查询的SQL语句<br>                            String sql = “SELECT * FROM gjp_zhangwu WHERE createtime BETWEEN ? AND ?”;<br>                            //定义对象数组,存储?占位符<br>                            Object[] params = {startDate,endDate};<br>                            //调用qr对象的方法query查询数据表,获取结果集<br>                            return qr.query(sql, new BeanListHandler&lt;&gt;(ZhangWu.class),params);<br>                        }catch(SQLException ex){<br>                            System.out.println(ex);<br>                            throw new RuntimeException(“条件查询失败”);<br>                        }<br>                    }<br>                }</ZhangWu></p>
<p>###20实现条件查询账务的view层实现<br>    * A: 实现条件查询账务的view层实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.view包中建立MainView类selectAll方法优化、抽取print方法、select方法<br>            /*<br>              * 定义方法,实现查询所有的账务数据<br>              */<br>             public void selectAll(){<br>                 //调用控制层中的方法,查询所有的账务数据<br>                 List<ZhangWu> list = controller.selectAll();<br>                 if(list.size()!=0)<br>                     print(list);<br>                 else<br>                     System.out.println(“没有查询到数据”);<br>             }</ZhangWu></p>
<pre><code>/*
 * 定义方法,实现条件查询账务数据
 * 提供用户的输入日期,开始日期结束日期
 * 就2个日期,传递到controller层
 * 调用controller的方法,传递2个日期参数
 * 获取到controller查询的结果集,打印出来
 */
public void select(){
    System.out.println(&quot;选择条件查询,输入日期格式XXXX-XX-XX&quot;);
    Scanner sc = new Scanner(System.in);
    System.out.print(&quot;请输入开始日期:&quot;);
    String startDate = sc.nextLine();
    System.out.print(&quot;请输入结果日期:&quot;);
    String endDate = sc.nextLine();
    //调用controller层的方法,传递日期,获取查询结果集
    List&lt;ZhangWu&gt; list = controller.select(startDate, endDate);
    if(list.size()!=0)
        print(list);
    else
        System.out.println(&quot;没有查询到数据&quot;);
}

//输出账务数据方法,接收List集合,遍历集合,输出表格
private void print(List&lt;ZhangWu&gt; list) {
       //输出表头
        System.out.println(&quot;ID\t\t类别\t\t账户\t\t金额\t\t时间\t\t说明&quot;);
        //遍历集合,结果输出控制台
        for(ZhangWu zw : list){
            System.out.println(zw.getZwid()+&quot;\t\t&quot;+zw.getFlname()+&quot;\t\t&quot;+zw.getZhanghu()+&quot;\t\t&quot;+
            zw.getMoney()+&quot;\t\t&quot;+zw.getCreatetime()+&quot;\t&quot;+zw.getDescription());
        }
   }</code></pre><p>###21添加账务功能分析<br>    * A: 添加账务功能分析<br>        * a: 编写MainView类中addZhangWu方法<br>            * 键盘输入新添加的账务信息<br>            * 调用ZhangWuService类中addZhangWu方法，用来指定账务的添加<br>            * 添加完毕后，使用输出语句，提示“添加账务成功！”<br>        * b: 编写ZhangWuService类中addZhangWu方法<br>            * 调用ZhangWuDao类中addZhangWu方法，用来指定账务的添加<br>        * c: 编写ZhangWuDao类中addZhangWu方法<br>            * 通过QueryRunner对象，调用update方法更新数据库表gjp_zhangwu，完成指定账务添加到数据库表中</p>
<p>​<br>###22添加账务功能菜单和输入功能实现<br>    * A: 添加账务功能菜单和输入功能实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.view包中建立MainView类addZhangWu方法<br>            /*<br>             * 定义方法addZhangWu<br>             * 添加账务的方法，用户在界面中选择菜单1的时候调用、<br>             * 实现思想：<br>             *       接收键盘输入，5项输入，调用controller层方法<br>             */<br>            public void addZhangWu() {<br>                System.out.println(“选择的添加账务功能，请输入以下内容”);<br>                Scanner sc = new Scanner(System.in);<br>                System.out.println(“输入分类名称”);<br>                String flname = sc.next();<br>                System.out.println(“输入金额”);<br>                double money = sc.nextDouble();<br>                System.out.println(“输入账户”);<br>                String zhanghu = sc.next();<br>                System.out.println(“输入日期：格式XXXX-XX-xx”);<br>                String createtime = sc.next();<br>                System.out.println(“输入具体描述”);<br>                String description = sc.next();<br>                //将接收到的数据，调用controller层的方法，传递参数，实现数据添加</p>
<pre><code>}</code></pre><p>###23添加账务功能控制层,业务层实现<br>    * A: 添加账务功能控制层,业务层实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.controller包中的ZhangWuController类addZhangWu方法<br>                /*<br>                 * 定义方法，实现账务添加功能<br>                 * 由视图层调用，传递参数(传递过来的参数不能是5个数据，传递的是一个ZhangWu类型的对象)<br>                 * 本方法调用service层的方法，传递ZhangWu对象，获取到添加后的结果集(添加成功影响的行数，int)<br>                 *<br>                 <em>/<br>                public void addZhangWu(ZhangWu zw) {<br>                    service.addZhangWu(zw);<br>                }<br>            * cn.itcast.gjp.service包中的ZhangWuService类addZhangWu方法<br>                /</em><br>                 * 定义方法，实现添加账务<br>                 * 是由控制层调用，传递ZhangWu对象<br>                 <em>/<br>                public void addZhangWu(ZhangWu zw) {<br>                    dao.addZhangWu(zw);<br>                }<br>            * cn.itcast.gjp.dao包中的ZhangWuDao类addZhangWu方法<br>                /</em><br>                 * 定义方法，实现添加账务功能<br>                 * 由业务层调用，传递ZhangWu对象<br>                 * 将ZhangWu对象中的数据，添加到数据库<br>                 */<br>                public void addZhangWu(ZhangWu zw) {</p>
<pre><code>}</code></pre><p>###24添加账务功能dao层实现<br>    * A: 添加账务功能dao层实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.dao包中的ZhangWuDao类的addZhangWu方法<br>                public void addZhangWu(ZhangWu zw) {<br>                    try{<br>                         //拼接添加数据的sql<br>                        String sql = “INSERT INTO gjp_zhangwu (flname,money,zhanghu,createtime,description) VALUES(?,?,?,?,?)”;<br>                        //创建对象数组，处处5个占位符的实际参数<br>                        //实际参数来源是传递过来的对象ZhangWu<br>                        Object[] params = {zw.getFlname(),zw.getMoney(),zw.getZhanghu(),zw.getCreatetime(),zw.getDescription()};<br>                        //调用qr对象中的方法update执行添加<br>                        qr.update(sql, params);<br>                    }catch(SQLException ex) {<br>                        System.out.println(ex);<br>                        throw new RuntimeException(“账务添加失败”);<br>                    }<br>                }</p>
<p>###25添加账务功能view层实现<br>    * A: 添加账务功能view层实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.view包中建立MainView类addZhangWu方法<br>                public void addZhangWu() {<br>                    System.out.println(“选择的添加账务功能，请输入以下内容”);<br>                    Scanner sc = new Scanner(System.in);<br>                    System.out.println(“输入分类名称”);<br>                    String flname = sc.next();<br>                    System.out.println(“输入金额”);<br>                    double money = sc.nextDouble();<br>                    System.out.println(“输入账户”);<br>                    String zhanghu = sc.next();<br>                    System.out.println(“输入日期：格式XXXX-XX-xx”);<br>                    String createtime = sc.next();<br>                    System.out.println(“输入具体描述”);<br>                    String description = sc.next();<br>                    //将接收到的数据，调用controller层的方法，传递参数，实现数据添加<br>                    //将用户输入的所有参数，封装成ZhangWu对象<br>                    ZhangWu zw = new ZhangWu(0, flname, money, zhanghu, createtime, description);<br>                    controller.addZhangWu(zw);<br>                    System.out.println(“恭喜添加账务成功”);<br>                }</p>
<p>​<br>###26编辑账务功能分析<br>    * A: 编辑账务功能分析<br>        * a: 编写MainView类中editZhangWu方法<br>            * 键盘输入要编辑的账务信息ID号<br>            * 键盘输入要修改的账务信息内容<br>            * 调用ZhangWuService类中editZhangWu方法，用来将指定的账务信息进行更新<br>            * 更新完毕后，使用输出语句，提示 “编辑账务成功！”<br>        * b: 编写ZhangWuService类中editZhangWu方法<br>            * 调用ZhangWuDao类中editZhangWu方法，用来将指定的账务信息进行更新<br>        * c: 编写ZhangWuDao类中editZhangWu方法<br>            * 通过QueryRunner对象，调用update方法更新数据库表gjp_zhangwu，完成数据库表中指定账务更新操作</p>
<p>###27编辑账务功能功能之前实现查询所有<br>    * A: 编辑账务功能功能之前实现查询所有<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.view包中建立MainView类editZhangWu方法<br>                public void editZhangWu() {<br>                    //调用查询所有账务数据的功能，显示出来<br>                    //看到所有数据，从中选择一项，进行修改<br>                    selectAll();<br>                    System.out.println(“选择的是编辑功能，请输入数据”);</p>
<p>​<br>                }</p>
<p>###28编辑账务功能菜单实现<br>    * A: 编辑账务功能菜单实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.view包中建立MainView类editZhangWu方法<br>                public void editZhangWu() {<br>                    //调用查询所有账务数据的功能，显示出来<br>                    //看到所有数据，从中选择一项，进行修改<br>                    selectAll();<br>                    System.out.println(“选择的是编辑功能，请输入数据”);<br>                    Scanner sc = new Scanner(System.in);<br>                    System.out.print(“请输入ID”);<br>                    int zwid = sc.nextInt();<br>                    System.out.println(“输入分类名称”);<br>                    String flname = sc.next();<br>                    System.out.println(“输入金额”);<br>                    double money = sc.nextDouble();<br>                    System.out.println(“输入账户”);<br>                    String zhanghu = sc.next();<br>                    System.out.println(“输入日期：格式XXXX-XX-xx”);<br>                    String createtime = sc.next();<br>                    System.out.println(“输入具体描述”);<br>                    String description = sc.next();<br>                    //将用户输入的数据，封装到ZhangWu对象中<br>                    //用户输入的ID，必须封装到到对象中<br>                    ZhangWu zw = new ZhangWu(zwid, flname, money, zhanghu, createtime, description);<br>                    //调用controller层中的方法，实现编辑账务<br>                }            </p>
<p>###29编辑账务功能控制层,业务层实现<br>    * A: 编辑账务功能控制层,业务层实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.controller包中的ZhangWuController类editZhangWu方法<br>                /*<br>                 * 定义方法，实现编辑账务功能<br>                 * 由视图层调用，传递参数，也是ZhangWu对象<br>                 * 调用service层的方法，也是ZhangWu对象<br>                 <em>/<br>                public void editZhangWu(ZhangWu zw) {<br>                    service.editZhangWu(zw);<br>                }<br>            * cn.itcast.gjp.service包中的ZhangWuService类editZhangWu方法<br>                /</em><br>                 * 定义方法，实现编辑账务<br>                 * 由控制层调用，传递ZhangWu对象<br>                 * 调用dao层的方法，传递ZhangWu对象<br>                 */<br>                public void editZhangWu(ZhangWu zw) {<br>                    dao.editZhangWu(zw);<br>                }<br>            * cn.itcast.gjp.dao包中的ZhangWuDao类editZhangWu方法<br>                public void editZhangWu(ZhangWu zw) {<br>                    // TODO Auto-generated method stub</p>
<pre><code>}</code></pre><p>###30编辑账务功能dao层实现<br>    * A：编辑账务功能dao层实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.dao包中的ZhangWuDao类editZhangWu方法<br>                /*<br>                 * 定义方法，实现编辑功能<br>                 * 由业务层调用，传递ZhangWu对象<br>                 * 将对象中的数据，更新到数据表<br>                 */<br>                public void editZhangWu(ZhangWu zw) {<br>                    try {<br>                        //更新数据的SQL<br>                        String sql = “UPDATE zhangwu SET flname=?,money=?,zhanghu=?,createtime=?,description=? WHERE zwid=?”;<br>                        //定义对象数组，封装所有数据<br>                        Object[] params = {zw.getFlname(),zw.getMoney(),zw.getZhanghu(),zw.getCreatetime(),zw.getDescription(),zw.getZwid()};<br>                        //调用qr对象方法update执行更新<br>                        qr.update(sql, params);<br>                    } catch (SQLException ex) {<br>                        System.out.println(ex);<br>                        throw new RuntimeException(“编辑账务失败”);<br>                    }</p>
<pre><code>}</code></pre><p>​<br>###31编辑账务功能view层实现<br>    * A: 编辑账务功能view层实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.view包中建立MainView类editZhangWu方法<br>                /*<br>                 * 定义方法，实现对账务的编辑功能<br>                 * 实现思想：<br>                 *     接收用户的输入的信息<br>                 *  封装成ZhangWu对象<br>                 *  调用控制层的方法，传递ZhangWu对象，实现编辑<br>                 *<br>                 */<br>                public void editZhangWu() {<br>                    //调用查询所有账务数据的功能，显示出来<br>                    //看到所有数据，从中选择一项，进行修改<br>                    selectAll();<br>                    System.out.println(“选择的是编辑功能，请输入数据”);<br>                    Scanner sc = new Scanner(System.in);<br>                    System.out.print(“请输入ID”);<br>                    int zwid = sc.nextInt();<br>                    System.out.println(“输入分类名称”);<br>                    String flname = sc.next();<br>                    System.out.println(“输入金额”);<br>                    double money = sc.nextDouble();<br>                    System.out.println(“输入账户”);<br>                    String zhanghu = sc.next();<br>                    System.out.println(“输入日期：格式XXXX-XX-xx”);<br>                    String createtime = sc.next();<br>                    System.out.println(“输入具体描述”);<br>                    String description = sc.next();<br>                    //将用户输入的数据，封装到ZhangWu对象中<br>                    //用户输入的ID，必须封装到到对象中<br>                    ZhangWu zw = new ZhangWu(zwid, flname, money, zhanghu, createtime, description);<br>                    //调用controller层中的方法，实现编辑账务<br>                    controller.editZhangWu(zw);<br>                    System.out.println(“账务编辑成功”);<br>                }</p>
<p>###32删除账务功能分析<br>    * A: 删除账务功能分析<br>        * a: 编写MainView类中deleteZhangWu方法<br>            * 键盘输入要删除的账务信息ID号<br>            * 调用ZhangWuService类中deleteZhangWu方法，用来将指定的账务信息删除<br>            * 删除完毕后，使用输出语句，提示 “删除账务成功！”<br>        * b: 编写ZhangWuService类中deleteZhangWu方法<br>            * 调用ZhangWuDao类中deleteZhangWu方法，用来将指定的账务信息删除<br>        * c: 编写ZhangWuDao类中deleteZhangWu方法<br>            * 通过QueryRunner对象，调用update方法更新数据库表gjp_zhangwu，完成数据库表中指定账务删除操作</p>
<p>​            </p>
<p>###33删除账务功能菜单实现<br>    * A: 删除账务功能菜单实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.view包中建立MainView类deleteZhangWu方法<br>                /*<br>                 * 定义方法，实现账务删除<br>                 * 实现思想：<br>                 *     接收用户的输入，输入一个主键数据<br>                 *  调用控制层方法，传递一个主键<br>                 */<br>                public void deleteZhangWu() {<br>                    //调用查询所有账务数据的功能，显示出来<br>                    //看到所有数据，从中选择一项，进行修改<br>                    selectAll();<br>                    System.out.println(“选择的是删除功能，请输入序号即可”);<br>                    int zwid = new Scanner(System.in).nextInt();<br>                    //调用控制层方法，传递主键id即可<br>                }</p>
<p>###34删除账务功能控制层,业务层实现<br>    * A: 删除账务功能控制层,业务层实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.controller包中的ZhangWuController类deleteZhangWu方法<br>                /*<br>                 * 定义方法，实现删除功能<br>                 * 视图层调用，传递int类型主键<br>                 * 调用service层方法，传递int主键<br>                 <em>/<br>                public void deleteZhangWu(int zwid) {<br>                    service.deleteZhangWu(zwid);<br>                }<br>            * cn.itcast.gjp.service包中的ZhangWuService类deleteZhangWu方法<br>                /</em><br>                 * 定义方法，实现删除账务功能<br>                 * 由控制层调用，传递主键id<br>                 * 调用dao层方法，传递主键id<br>                 */<br>                public void deleteZhangWu(int zwid) {<br>                    dao.deleteZhangWu(zwid);<br>                }<br>            * cn.itcast.gjp.dao包中的ZhangWuDao类deleteZhangWu方法<br>                public void deleteZhangWu(int zwid) {</p>
<pre><code>}</code></pre><p>###35删除账务功能dao实现<br>    * A: 删除账务功能dao实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.dao包中的ZhangWuDao类deleteZhangWu方法<br>                /*<br>                 * 定义方法，实现删除业务<br>                 * 业务层调用，传递主键id<br>                 */<br>                public void deleteZhangWu(int zwid) {<br>                    try {<br>                        //拼写删除数据SQL<br>                        String sql = “DELETE FROM gjp_zhangwu WHERE zwid=?”;<br>                        qr.update(sql, zwid);<br>                    } catch (SQLException ex) {<br>                        System.out.println(ex);<br>                        throw new RuntimeException(“删除账务失败”);<br>                    }<br>                }</p>
<p>​<br>###36删除账务功能view层实现<br>    * A: 删除账务功能view层实现<br>        * a: 案例核心代码<br>            * cn.itcast.gjp.view包中建立MainView类editZhangWu方法<br>                /*<br>                 * 定义方法，实现账务删除<br>                 * 实现思想：<br>                 *     接收用户的输入，输入一个主键数据<br>                 *  调用控制层方法，传递一个主键<br>                 */<br>                public void deleteZhangWu() {<br>                    //调用查询所有账务数据的功能，显示出来<br>                    //看到所有数据，从中选择一项，进行修改<br>                    selectAll();<br>                    System.out.println(“选择的是删除功能，请输入序号即可”);<br>                    int zwid = new Scanner(System.in).nextInt();<br>                    //调用控制层方法，传递主键id即可<br>                    controller.deleteZhangWu(zwid);<br>                    System.out.println(“删除账务成功”);</p>
<p>###37总结<br>    * 把今天的知识点总结一遍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day30%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day30%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记30</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:14:03" itemprop="dateModified" datetime="2020-12-23T23:14:03+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、DBUtils<br>2、连接池                        </p>
<p>###01DButils工具类的介绍个三个核心类<br>    * A: DButils工具类的介绍个三个核心类<br>        * a: 概述<br>            * DBUtils是java编程中的数据库操作实用工具，小巧简单实用。<br>            * DBUtils封装了对JDBC的操作，简化了JDBC操作，可以少写代码。<br>            * DBUtils就是JDBC的简化开发工具包。需要项目导入commons-dbutils-1.6.jar才能够正常使用DBUtils工具。<br>        * b: Dbutils三个核心功能介绍<br>            * QueryRunner中提供对sql语句操作的API.<br>                * update(Connection conn, String sql, Object… params) ，用来完成表数据的增加、删除、更新操作<br>                * query(Connection conn, String sql, ResultSetHandler<T> rsh, Object… params) ，用来完成表数据的查询操作<br>            * ResultSetHandler接口，用于定义select操作后，怎样封装结果集.<br>            * DbUtils类，它就是一个工具类,定义了关闭资源与事务处理的方法</T></p>
<p>###02事务的简单介绍(此知识点简单了解，难度较大，就业班会详细 讲解)<br>    * A: 事务的简单介绍<br>        * a: 见day32/day32_source/事务.jgp</p>
<p>###03QueryRunner类的update方法介绍<br>    * A：QueryRunner类的update方法介绍<br>        * a: 方法介绍<br>            * update(Connection conn, String sql, Object… params) ，用来完成表数据的增加、删除、更新操作<br>            *  使用QueryRunner类,实现对数据表的insert delete update<br>            *  调用QueryRunner类的方法 update (Connection con,String sql,Object…param)<br>                *  Object…param 可变参数,Object类型,SQL语句会出现?占位符<br>                *  数据库连接对象,自定义的工具类传递</p>
<p>​<br>###04QueryRunner类实现insert添加数据<br>    * A: QueryRunner类实现insert添加数据<br>        * a: 案例代码<br>            public class QueryRunnerDemo {<br>                private static Connection con = JDBCUtilsConfig.getConnection();<br>                public static void main(String[] args)throws SQLException {<br>                    insert();<br>                }<br>                /*<br>                 * 定义方法,使用QueryRunner类的方法update向数据表中,添加数据<br>                 */<br>                public static void insert()throws SQLException{<br>                    //创建QueryRunner类对象<br>                    QueryRunner qr = new QueryRunner();<br>                    String sql = “INSERT INTO sort (sname,sprice,sdesc)VALUES(?,?,?)”;<br>                    //将三个?占位符的实际参数,写在数组中<br>                    Object[] params = {“体育用品”,289.32,”购买体育用品”};<br>                    //调用QueryRunner类的方法update执行SQL语句<br>                    int row = qr.update(con, sql, params);<br>                    System.out.println(row);<br>                    DbUtils.closeQuietly(con);<br>                }<br>            }</p>
<p>###05QueryRunner类实现update修改数据<br>    * A: QueryRunner类实现update修改数据<br>        * a: 案例代码<br>            public class QueryRunnerDemo {<br>                private static Connection con = JDBCUtilsConfig.getConnection();<br>                public static void main(String[] args)throws SQLException {<br>                    update();<br>                }<br>                /*<br>                 *  定义方法,使用QueryRunner类的方法update将数据表的数据修改<br>                 */<br>                public static void update()throws SQLException{<br>                    //创建QueryRunner类对象<br>                    QueryRunner qr = new QueryRunner();<br>                    //写修改数据的SQL语句<br>                    String sql = “UPDATE sort SET sname=?,sprice=?,sdesc=? WHERE sid=?”;<br>                    //定义Object数组,存储?中的参数<br>                    Object[] params = {“花卉”,100.88,”情人节玫瑰花”,4};<br>                    //调用QueryRunner方法update<br>                    int row = qr.update(con, sql, params);<br>                    System.out.println(row);<br>                    DbUtils.closeQuietly(con);<br>                }<br>            }</p>
<p>​            </p>
<p>###06QueryRunner类实现delete删除数据<br>    * A: QueryRunner类实现delete删除数据<br>        * a: 案例代码<br>            public class QueryRunnerDemo {<br>                private static Connection con = JDBCUtilsConfig.getConnection();<br>                public static void main(String[] args)throws SQLException {<br>                    delete();<br>                }<br>                /*<br>                 *  定义方法,使用QueryRunner类的方法delete将数据表的数据删除<br>                 <em>/<br>                public static void delete()throws SQLException{<br>                    //创建QueryRunner类对象<br>                    QueryRunner qr = new QueryRunner();<br>                    //写删除的SQL语句<br>                    String sql = “DELETE FROM sort WHERE sid=?”;<br>                    //调用QueryRunner方法update<br>                    int row = qr.update(con, sql, 8);<br>                    System.out.println(row);<br>                    /</em><br>                     *  判断insert,update,delete执行是否成功<br>                     *  对返回值row判断<br>                     *  if(row&gt;0) 执行成功<br>                     */<br>                    DbUtils.closeQuietly(con);<br>                }<br>            }</p>
<p>###07JavaBean类<br>    * A: JavaBean类<br>        * a: 概念<br>            * JavaBean就是一个类，在开发中常用封装数据。具有如下特性<br>                1.    需要实现接口：java.io.Serializable ，通常实现接口这步骤省略了，不会影响程序。<br>                2.    提供私有字段：private 类型 字段名;<br>                3.    提供getter/setter方法：<br>                4.    提供无参构造</p>
<p>###08DBUtils工具类结果集处理的方式<br>    * A: DBUtils工具类结果集处理的方式<br>        * a: QueryRunner实现查询操作<br>            *    query(Connection conn, String sql, ResultSetHandler<T> rsh, Object… params) ，用来完成表数据的查询操作<br>        * b: ResultSetHandler结果集处理类<br>            * ArrayHandler    将结果集中的第一条记录封装到一个Object[]数组中，数组中的每一个元素就是这条记录中的每一个字段的值<br>            * ArrayListHandler    将结果集中的每一条记录都封装到一个Object[]数组中，将这些数组在封装到List集合中。<br>            * BeanHandler    将结果集中第一条记录封装到一个指定的javaBean中。<br>            * BeanListHandler    将结果集中每一条记录封装到指定的javaBean中，将这些javaBean在封装到List集合中<br>            * ColumnListHandler    将结果集中指定的列的字段值，封装到一个List集合中<br>            * ScalarHandler    它是用于单数据。例如select count(*) from 表操作。<br>            * MapHandler    将结果集第一行封装到Map集合中,Key 列名, Value 该列数据<br>            * MapListHandler    将结果集第一行封装到Map集合中,Key 列名, Value 该列数据,Map集合存储到List集合</T></p>
<p>###09QueryRunner类的方法query<br>    * A: QueryRunner类的方法query<br>        * a: QueryRunner数据查询操作<br>            * 调用QueryRunner类方法query(Connection con,String sql,ResultSetHandler r, Object..params)<br>            *  ResultSetHandler r 结果集的处理方式,传递ResultSetHandler接口实现类<br>            *  Object..params SQL语句中的?占位符<br>            *  注意: query方法返回值,返回的是T 泛型, 具体返回值类型,跟随结果集处理方式变化<br>        * b: 案例代码<br>            public class QueryRunnerDemo1 {<br>                private static Connection con = JDBCUtilsConfig.getConnection();<br>            }</p>
<p>###10结果集处理ArrayHandler<br>    * A: 结果集处理ArrayHandler<br>        * 案例代码<br>            public class QueryRunnerDemo1 {<br>                private static Connection con = JDBCUtilsConfig.getConnection();<br>                public static void main(String[] args) throws SQLException{<br>                    arrayHandler();<br>                }<br>                /*<br>                 *  结果集第一种处理方法, ArrayHandler<br>                 *  将结果集的第一行存储到对象数组中  Object[]<br>                 */<br>                public static void arrayHandler()throws SQLException{<br>                    QueryRunner qr = new QueryRunner();<br>                    String sql = “SELECT * FROM sort”;<br>                    //调用方法query执行查询,传递连接对象,SQL语句,结果集处理方式的实现类<br>                    //返回对象数组<br>                    Object[] result = qr.query(con, sql, new ArrayHandler());<br>                    for(Object obj : result){<br>                        System.out.print(obj);<br>                    }<br>                }<br>            }</p>
<p>###11结果集处理ArrayListHandler<br>    * A: 结果集处理ArrayListHandler<br>        * a: 案例代码<br>            public class QueryRunnerDemo1 {<br>                private static Connection con = JDBCUtilsConfig.getConnection();<br>                public static void main(String[] args) throws SQLException{<br>                    arrayListHandler();<br>                }<br>                /*<br>                 *  结果集第二种处理方法,ArrayListHandler<br>                 *  将结果集的每一行,封装到对象数组中, 出现很多对象数组<br>                 *  对象数组存储到List集合<br>                 */<br>                public static void arrayListHandler()throws SQLException{<br>                    QueryRunner qr = new QueryRunner();<br>                    String sql = “SELECT * FROM sort”;<br>                    //调用query方法,结果集处理的参数上,传递实现类ArrayListHandler<br>                    //方法返回值 每行是一个对象数组,存储到List<br>                    List&lt;Object[]&gt; result=  qr.query(con, sql, new ArrayListHandler());</p>
<pre><code>        //集合的遍历
        for( Object[] objs  : result){
            //遍历对象数组
            for(Object obj : objs){
                System.out.print(obj+&quot;  &quot;);
            }
            System.out.println();
        }
    }
}</code></pre><p>​<br>###12结果集处理BeanHandler<br>    * A: 结果集处理BeanHandler<br>        * a: 案例代码<br>            public class QueryRunnerDemo1 {<br>                private static Connection con = JDBCUtilsConfig.getConnection();<br>                public static void main(String[] args) throws SQLException{<br>                    beanHandler();<br>                }<br>                /*<br>                 *  结果集第三种处理方法,BeanHandler<br>                 *  将结果集的第一行数据,封装成JavaBean对象<br>                 *  注意: 被封装成数据到JavaBean对象, Sort类必须有空参数构造<br>                 */<br>                public static void beanHandler()throws SQLException{<br>                    QueryRunner qr = new QueryRunner();<br>                    String sql = “SELECT * FROM sort “;<br>                    //调用方法,传递结果集实现类BeanHandler<br>                    //BeanHandler(Class<T> type)<br>                    Sort s = qr.query(con, sql, new BeanHandler<Sort>(Sort.class));<br>                    System.out.println(s);<br>                }<br>            }</Sort></T></p>
<p>###13结果集处理BeanListHandler<br>    * A: 结果集处理BeanListHandler<br>        * a: 案例代码<br>        public class QueryRunnerDemo1 {<br>            private static Connection con = JDBCUtilsConfig.getConnection();<br>            public static void main(String[] args) throws SQLException{<br>                beanListHander();<br>            }<br>            /*<br>             *  结果集第四种处理方法, BeanListHandler<br>             *  结果集每一行数据,封装JavaBean对象<br>             *  多个JavaBean对象,存储到List集合<br>             */<br>            public static void beanListHander()throws SQLException{<br>                QueryRunner qr = new QueryRunner();<br>                String sql = “SELECT * FROM sort “;<br>                //调用方法query,传递结果集处理实现类BeanListHandler<br>                List<Sort> list = qr.query(con, sql, new BeanListHandler<Sort>(Sort.class));<br>                for(Sort s : list){<br>                    System.out.println(s);<br>                }<br>            }<br>        }</Sort></Sort></p>
<p>​<br>###14结果集处理ColumnListHandler<br>    * A: 结果集处理ColumnListHandler<br>        * a: 案例代码<br>            public class QueryRunnerDemo1 {<br>                private static Connection con = JDBCUtilsConfig.getConnection();<br>                public static void main(String[] args) throws SQLException{<br>                    columnListHandler();<br>                }<br>                /*<br>                 *  结果集第五种处理方法,ColumnListHandler<br>                 *  结果集,指定列的数据,存储到List集合<br>                 *  List<Object> 每个列数据类型不同<br>                 */<br>                public static void columnListHandler()throws SQLException{<br>                    QueryRunner qr = new QueryRunner();<br>                    String sql = “SELECT * FROM sort “;<br>                    //调用方法 query,传递结果集实现类ColumnListHandler<br>                    //实现类构造方法中,使用字符串的列名<br>                    List<Object> list = qr.query(con, sql, new ColumnListHandler<Object>(“sname”));<br>                    for(Object obj : list){<br>                        System.out.println(obj);<br>                    }<br>                }<br>            }</Object></Object></Object></p>
<p>​<br>###15结果集处理ScalarHandler<br>    * A: 结果集处理ScalarHandler<br>        * a: 案例代码<br>            public class QueryRunnerDemo1 {<br>                private static Connection con = JDBCUtilsConfig.getConnection();<br>                public static void main(String[] args) throws SQLException{<br>                    scalarHandler();<br>                }<br>                /*<br>                 *  结果集第六种处理方法,ScalarHandler<br>                 *  对于查询后,只有1个结果<br>                 <em>/<br>                public static void scalarHandler()throws SQLException{<br>                    QueryRunner qr = new QueryRunner();<br>                    String sql = “SELECT COUNT(</em>) FROM sort”;<br>                    //调用方法query,传递结果集处理实现类ScalarHandler<br>                    long count = qr.query(con, sql, new ScalarHandler<Long>());<br>                    System.out.println(count);<br>                }<br>            }</Long></p>
<p>###16结果集处理MapHandler<br>    * A: 结果集处理MapHandler<br>        * a: 案例代码<br>            public class QueryRunnerDemo1 {<br>                private static Connection con = JDBCUtilsConfig.getConnection();<br>                public static void main(String[] args) throws SQLException{<br>                    mapHandler();<br>                }<br>                /*<br>                 *  结果集第七种处理方法,MapHandler<br>                 *  将结果集第一行数据,封装到Map集合中<br>                 *  Map&lt;键,值&gt; 键:列名  值:这列的数据<br>                 */<br>                public static void mapHandler()throws SQLException{<br>                    QueryRunner qr = new QueryRunner();<br>                    String sql = “SELECT  * FROM sort”;<br>                    //调用方法query,传递结果集实现类MapHandler<br>                    //返回值: Map集合,Map接口实现类, 泛型<br>                    Map&lt;String,Object&gt; map = qr.query(con, sql, new MapHandler());<br>                    //遍历Map集合<br>                    for(String key : map.keySet()){<br>                        System.out.println(key+”..”+map.get(key));<br>                    }<br>                }<br>            }</p>
<p>###17结果集处理MapListHandler<br>    * A: 结果集处理MapListHandlerr<br>        * a: 案例代码<br>            public class QueryRunnerDemo1 {<br>                private static Connection con = JDBCUtilsConfig.getConnection();<br>                public static void main(String[] args) throws SQLException{<br>                    mapListHandler();<br>                }<br>                /*<br>                 *  结果集第八种处理方法,MapListHandler<br>                 *  将结果集每一行存储到Map集合,键:列名,值:数据<br>                 *  Map集合过多,存储到List集合<br>                 */<br>                public static void mapListHandler()throws SQLException{<br>                    QueryRunner qr = new QueryRunner();<br>                    String sql = “SELECT  * FROM sort”;<br>                    //调用方法query,传递结果集实现类MapListHandler<br>                    //返回值List集合, 存储的是Map集合<br>                    List&lt;Map&lt;String,Object&gt;&gt; list = qr.query(con, sql, new MapListHandler());<br>                    //遍历集合list<br>                    for( Map&lt;String,Object&gt; map : list ){<br>                        for(String key : map.keySet()){<br>                            System.out.print(key+”…”+map.get(key));<br>                        }<br>                        System.out.println();<br>                    }</p>
<pre><code>    }
}</code></pre><p>###18连接池介绍<br>    * A: 连接池介绍<br>        * a: 连接池介绍<br>            * 实际上就是存放连接的池子(容器)<br>            * 在开发中“获得连接”或“释放资源”是非常消耗系统资源的两个过程<br>            * 为了解决此类性能问题，通常情况我们采用连接池技术，来共享连接Connection。<br>            * 这样我们就不需要每次都创建连接、释放连接了，这些操作都交给了连接池            </p>
<p>###19连接池概念规范和DataSource接口<br>    * A: 连接池概念规范和DataSource接口<br>        * a: 连接池概念规范<br>            * 用池来管理Connection，这样可以重复使用Connection。<br>            * 不用自己来创建Connection，而是通过池来获取Connection对象<br>            * 使用完Connection后，调用Connection的close()方法也不会真的关闭Connection，而是把Connection“归还”给池<br>            * 连接池技术可以完成Connection对象的再次利用<br>        * b: DataSource接口<br>            * Java为数据库连接池提供了公共的接口：javax.sql.DataSource<br>            * 各个厂商需要让自己的连接池实现这个接口。这样应用程序可以方便的切换不同厂商的连接池<br>            * 常见的连接池：DBCP、C3P0<br>###20DBCP连接池介绍<br>    * A: DBCP连接池介绍<br>        * a: DBCP连接池介绍<br>            * DBCP也是一个开源的连接池，是Apache Common成员之一，在企业开发中也比较常见，tomcat内置的连接池<br>        * tomcat服务器简单介绍    </p>
<p>###21导入jar包<br>    * A: 导入jar包<br>        * a: jar包介绍<br>            * mysql-connector-java-5.1.37-bin.jar：数据库驱动<br>            * commons-dbutils-1.6.jar：提供QueryRunner类方便进行增删改查操作<br>            * commons-dbcp-1.4.jar：<br>            * commons-pool-1.5.6.jar：提供高效的数据库连接池技术<br>        * b: 导入jar包<br>            * 在项目根路径下建立文件夹lib<br>            * 拷贝以上jar包，选定拷贝的jar包/右键/Build Path/Add to Build Path</p>
<p>###22BasicDataSource类的使用<br>    * A: BasicDataSource类的使用<br>        * a: 案例代码<br>            /*<br>             *  连接池jar包中,定义好一个类 BasicDataSource<br>             *  实现类数据源的规范接口 javax.sql.DataSource<br>             */<br>            public class DataSoruceDemo {<br>                public static void main(String[] args) {<br>                    //创建DataSource接口的实现类对象<br>                    //实现类, org.apache.commons.dbcp<br>                    BasicDataSource dataSource = new BasicDataSource();<br>                    //连接数据库的4个最基本信息,通过对象方法setXXX设置进来<br>                    dataSource.setDriverClassName(“com.mysql.jdbc.Driver”);<br>                    dataSource.setUrl(“jdbc:mysql://localhost:3306/mybase”);<br>                    dataSource.setUsername(“root”);<br>                    dataSource.setPassword(“123”);</p>
<pre><code>        try{
        //调用对象方法getConnection获取数据库的连接
            Connection con = dataSource.getConnection();
            System.out.println(con);
        }catch(SQLException ex){
//            System.out.println(ex);
            ex.printStackTrace();
            throw new RuntimeException(&quot;数据库连接失败&quot;);
        }
    }
}</code></pre><p>​<br>###23BasicDataSource类的常见配置<br>    * A: BasicDataSource类的常见配置<br>        * a: 常见配置<br>            分类    属性            描述<br>            必须项<br>                    driverClassName    数据库驱动名称<br>                    url                数据库的地址<br>                    username        用户名<br>                    password        密码<br>            基本项（扩展）<br>                    maxActive        最大连接数量<br>                    minIdle            最小空闲连接<br>                    maxIdle         最大空闲连接<br>                    initialSize        初始化连接</p>
<p>​<br>###24实现数据库连接池工具类<br>    * A: 实现数据库连接池工具类<br>        * a: 案例代码<br>            /*<br>             *  使用DBCP实现数据库的连接池<br>             *  连接池配置,自定义类,<br>             *  最基本四项完整<br>             *  对于数据库连接池其他配置,自定义<br>             */</p>
<pre><code>import javax.sql.DataSource;

import org.apache.commons.dbcp.BasicDataSource;
public class JDBCUtils{
    //创建出BasicDataSource类对象
    private static BasicDataSource datasource = new BasicDataSource();

    //静态代码块,对象BasicDataSource对象中的配置,自定义
    static{
        //数据库连接信息,必须的
        datasource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
        datasource.setUrl(&quot;jdbc:mysql://localhost:3306/day33_user&quot;);
        datasource.setUsername(&quot;root&quot;);
        datasource.setPassword(&quot;123&quot;);
        //对象连接池中的连接数量配置,可选的
        datasource.setInitialSize(10);//初始化的连接数
        datasource.setMaxActive(8);//最大连接数量
        datasource.setMaxIdle(5);//最大空闲数
        datasource.setMinIdle(1);//最小空闲
    }</code></pre><p>​<br>                //定义静态方法,返回BasicDataSource类的对象<br>                public static DataSource getDataSource(){<br>                    return datasource;<br>                }<br>            }</p>
<p>​<br>###25工具类的测试<br>    * A: 工具类的测试<br>        * a: 案例代码<br>            /*<br>             *  测试写好的工具类,<br>             *  提供的是一个DataSource接口的数据源<br>             *  QueryRunner类构造方法,接收DataSource接口的实现类<br>             *  后面,调用方法update,query,无需传递他们Connection连接对象<br>             */</p>
<pre><code>import java.sql.SQLException;
import java.util.List;

import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.ArrayListHandler;

import cn.itcast.jdbcutils.JDBCUtils;
public class QueryRunnerDemo{
    public static void main(String[] args) {
        select();
    }
    //定义2个方法,实现数据表的添加,数据表查询
    //QueryRunner类对象,写在类成员位置
    private static QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource()); 

    //数据表查询
    public static void select(){
        String sql = &quot;SELECT * FROM sort&quot;;
        try{
        List&lt;Object[]&gt; list = qr.query(sql, new ArrayListHandler());
        for(Object[] objs : list){
            for(Object obj : objs){
                System.out.print(obj+&quot;\t&quot;);
            }
            System.out.println();
        }
        }catch(SQLException ex){
            throw new RuntimeException(&quot;数据查询失败&quot;);
        }
    }

    //数据表添加数据
    public static void insert(){
        String sql = &quot;INSERT INTO sort (sname,sprice,sdesc)VALUES(?,?,?)&quot;;
        Object[] params = {&quot;水果&quot;,100.12,&quot;刚刚上市的核桃&quot;};
        try{
            int row = qr.update(sql, params);
            System.out.println(row);
        }catch(SQLException ex){
            throw new RuntimeException(&quot;数据添加失败&quot;);
        }
    }

}</code></pre><p>###26总结<br>    * 把今天的知识点总结一遍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/34/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><span class="page-number current">35</span><a class="page-number" href="/page/36/">36</a><span class="space">&hellip;</span><a class="page-number" href="/page/48/">48</a><a class="extend next" rel="next" href="/page/36/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">匡俊桦</p>
  <div class="site-description" itemprop="description">回忆的沙漏将曾经屈指可数的日子渐渐淡去</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">238</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">匡俊桦</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">29:11</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
