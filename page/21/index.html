<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:type" content="website">
<meta property="og:title" content="KJHの博客">
<meta property="og:url" content="http://yoursite.com/page/21/index.html">
<meta property="og:site_name" content="KJHの博客">
<meta property="og:description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="匡俊桦">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/21/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>KJHの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KJHの博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录&回忆</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%AA%E7%A7%91%E6%96%AF%E5%BD%BB%E7%AE%97%E6%B3%95(Dijkstra)%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%AA%E7%A7%91%E6%96%AF%E5%BD%BB%E7%AE%97%E6%B3%95(Dijkstra)%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">数据结构迪科斯彻算法(Dijkstra)算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-29 21:40:46" itemprop="dateCreated datePublished" datetime="2020-12-29T21:40:46+08:00">2020-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-04 22:45:41" itemprop="dateModified" datetime="2021-03-04T22:45:41+08:00">2021-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>迪科斯彻算法(Dijkstra)是有荷兰计算机科学家艾兹格·迪科斯彻（Edsger Wybe Dijkstra）发明的。算法解决的是有向图中单个源点到其他顶点的最短路径问题。</p>
<p>算法描述</p>
<p>这个算法是通过为每个顶点 v 保留目前为止所找到的从s到v的最短路径来工作的。初始时，原点 s 的路径长度值被赋为 0 （d[s] = 0），同时把所有其他顶点的路径长度设为无穷大，即表示我们不知道任何通向这些顶点的路径（对于 V 中所有顶点 v 除 s 外d[v] = ∞）。当算法结束时，d[v] 中储存的便是从 s 到 v 的最短路径，或者如果路径不存在的话是无穷大。 Dijkstra 算法的基础操作是边的拓展：如果存在一条从 u 到 v 的边，那么从 s 到 v 的最短路径可以通过将边（u, v）添加到尾部来拓展一条从 s 到 u 的路径。这条路径的长度是 d[u] + w(u, v)。如果这个值比目前已知的 d[v] 的值要小，我们可以用新值来替代当前 d[v] 中的值。拓展边的操作一直执行到所有的 d[v] 都代表从 s 到 v 最短路径的花费。这个算法经过组织因而当 d[u] 达到它最终的值的时候每条边（u, v）都只被拓展一次。</p>
<p>算法维护两个顶点集 S 和 Q。集合 S 保留了我们已知的所有 d[v] 的值已经是最短路径的值顶点，而集合 Q 则保留其他所有顶点。集合S初始状态为空，而后每一步都有一个顶点从 Q 移动到 S。这个被选择的顶点是 Q 中拥有最小的 d[u] 值的顶点。当一个顶点 u 从 Q 中转移到了 S 中，算法对每条外接边 (u, v) 进行拓展。</p>
<p>算法实现<br>算法实现起来比较简单，当然这得归功于算法作者。</p>
<p>一、邻接矩阵实现</p>
<p>​    </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图的邻接矩阵存储*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> VertexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVEX 100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFI 65535</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	VertexType vexs[MAXVEX];           <span class="comment">/*顶点表*/</span></span><br><span class="line">	EdgeType matrix[MAXVEX][MAXVEX];   <span class="comment">/*邻接矩阵*/</span></span><br><span class="line">	<span class="keyword">int</span> numVertexes;          <span class="comment">/*顶点数*/</span></span><br><span class="line">	<span class="keyword">int</span> numEdges;             <span class="comment">/*边数*/</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"><span class="comment">/*创建一个邻接矩阵有向图*/</span></span><br><span class="line"><span class="function">Graph* <span class="title">CreateDiGraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Graph *pGragh = <span class="keyword">new</span> Graph;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pGragh)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入顶点数和边数："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; pGragh-&gt;numVertexes &gt;&gt; pGragh-&gt;numEdges;</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pGragh-&gt;numVertexes; ++i)<span class="comment">/*建立顶点表*/</span></span><br><span class="line">		(pGragh-&gt;vexs)[i] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pGragh-&gt;numVertexes; ++i)<span class="comment">/*邻接矩阵初始化*/</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pGragh-&gt;numVertexes; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			(pGragh-&gt;matrix)[i][j] = INFI;</span><br><span class="line">			<span class="keyword">if</span> (i == j)</span><br><span class="line">				(pGragh-&gt;matrix)[i][j] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; pGragh-&gt;numEdges; ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> i, j, w;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入边&lt;vi,vj&gt;上的下标i，下标j和权重w："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; i &gt;&gt; j &gt;&gt; w;</span><br><span class="line">		(pGragh-&gt;matrix)[i][j] = w;<span class="comment">//清楚上面输入的顺序，有向边的开始点和终点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pGragh;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图的邻接矩阵存储方式Dijkstra算法实现</span></span><br><span class="line"><span class="comment">该算法的目的是：找到图中给定起始点到其余顶点的最短距离*/</span></span><br><span class="line"><span class="comment">/*传参：dist为图pGraph中的起始顶点start到图中各个顶点的最短距离</span></span><br><span class="line"><span class="comment">dist为与图顶点数等值大小的数组，作为返回值</span></span><br><span class="line"><span class="comment">参数有效性有调用者保证*/</span></span><br><span class="line">void Dijkstra(Graph *pGraph, <span class="keyword">int</span> dist[], <span class="keyword">int</span> start)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[pGraph-&gt;numVertexes]();<span class="comment">//建立踪迹表</span></span><br><span class="line">	visited[start] = <span class="keyword">true</span>;<span class="comment">//记录已经访问的顶点</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pGraph-&gt;numVertexes; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		dist[i] = (pGraph-&gt;matrix)[start][i];<span class="comment">//记录起始点start到各顶点的距离</span></span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">int</span> index;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pGraph-&gt;numVertexes; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mincost = INFI;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pGraph-&gt;numVertexes; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!visited[j] &amp;&amp; dist[j] &lt; mincost)<span class="comment">//选出起始点到其余顶点中的最小距离的那个顶点</span></span><br><span class="line">			&#123;</span><br><span class="line">				mincost = dist[j];</span><br><span class="line">				index = j;<span class="comment">//记录该最小距离顶点</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	 </span><br><span class="line">		visited[index] = <span class="keyword">true</span>;<span class="comment">//标记为已经访问过</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pGraph-&gt;numVertexes; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/*d[u] + w(u,v) &lt; d[v] 就更新为最小距离为d[u]+w(u,v)*/</span></span><br><span class="line">			<span class="keyword">if</span> (!visited[j] &amp;&amp; (dist[index] + (pGraph-&gt;matrix)[index][j]) &lt; dist[j])</span><br><span class="line">				dist[j] = dist[index] + (pGraph-&gt;matrix)[index][j];</span><br><span class="line">			<span class="comment">//dist 中保存的始终都是起始顶点start到图其余各顶点间的距离(访问过的就更新为最小)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，上面的Dijkstra算法得到的只是起始点到各个顶点的最小距离值，并没有记录其到达的最短路径。如果要计算某两个顶点之间的最短路径的话，可在更新最小距离的时候把中间顶点保存即可。实现比较简单就不贴出来了。<br>二、邻接表实现<br>相信经过了上面，举一反三的你也会很容易把邻接表的Dijkstra 算法实现出来。（懒啊，图片来源于《大话数据结构》，向作者致敬）</p>
<p>需要注意的是，上面的Dijkstra算法得到的只是起始点到各个顶点的最小距离值，并没有记录其到达的最短路径。如果要计算某两个顶点之间的最短路径的话，可在更新最小距离的时候把中间顶点保存即可。实现比较简单就不贴出来了。<br>二、邻接表实现<br>相信经过了上面，举一反三的你也会很容易把邻接表的Dijkstra 算法实现出来。（懒啊，图片来源于《大话数据结构》，向作者致敬）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> VertexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFI 65535</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面构成一个链式哈希表结构*/</span></span><br><span class="line"><span class="comment">/*边表结点*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AdjNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> adjvex;  <span class="comment">//边的终点</span></span><br><span class="line">	<span class="keyword">int</span> weight;  <span class="comment">//边的权重</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">AdjNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指向下一个邻接点</span></span><br><span class="line">&#125;AdjNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*顶点表结点*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	VertexType data;   <span class="comment">//顶点信息</span></span><br><span class="line">	AdjNode *pFfirstedge;  <span class="comment">//边表头指针</span></span><br><span class="line">&#125;VertexNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*图结点*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	VertexNode *AdjArray;   <span class="comment">//指向顶点表</span></span><br><span class="line">	<span class="keyword">int</span> numVertexes;</span><br><span class="line">	<span class="keyword">int</span> numEdges;</span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line"><span class="function">Graph* <span class="title">CreateDiGraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Graph *pGraph = <span class="keyword">new</span> Graph;</span><br><span class="line">	AdjNode *pNode = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pGraph)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入顶点数和边数："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; pGraph-&gt;numVertexes &gt;&gt; pGraph-&gt;numEdges;</span><br><span class="line">	 </span><br><span class="line">	pGraph-&gt;AdjArray = <span class="keyword">new</span> VertexNode[pGraph-&gt;numVertexes]();<span class="comment">//创建并初始化为0</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pGraph-&gt;AdjArray)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> pGraph;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">/*建立顶点信息表*/</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pGraph-&gt;numVertexes; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*这里默认顶点从0到pGraph-&gt;numVertexes，可根据需要修改</span></span><br><span class="line"><span class="comment">		如：</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; "输入顶点信息" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		cin &gt;&gt; (pGraph-&gt;AdjArray)[i].data;</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		(pGraph-&gt;AdjArray)[i].data = i;</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">/*建立边表*/</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; pGraph-&gt;numEdges; ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> i, j, w;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入边&lt;vi,vj&gt;上的下标i，下标j和权重w："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; i &gt;&gt; j &gt;&gt; w;</span><br><span class="line">	 </span><br><span class="line">		pNode = <span class="keyword">new</span> AdjNode;</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> == pNode)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] pGraph-&gt;AdjArray;</span><br><span class="line">			<span class="keyword">delete</span> pGraph;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pNode-&gt;adjvex = j;</span><br><span class="line">		pNode-&gt;weight = w;</span><br><span class="line">		pNode-&gt;next = (pGraph-&gt;AdjArray)[i].pFfirstedge;<span class="comment">//类链式哈希表插入操作，新节点插入到链表头结点</span></span><br><span class="line">		(pGraph-&gt;AdjArray)[i].pFfirstedge = pNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pGraph;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这里着重阐述算法实现，参数的有效性由调用者保证*/</span></span><br><span class="line"><span class="comment">/*dist中保存的则是起始点start到图中各顶点的最小距离*/</span></span><br><span class="line">void Dijkstra(Graph *pGraph,int dist[], int start)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="title">bool</span> *visited = new bool[pGraph-&gt;</span>numVertexes]();</span><br><span class="line">	visited[start] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*不同于邻接矩阵，注意这里的初始化距离*/</span></span><br><span class="line">	<span class="function"><span class="title">for</span> (int i = 0; i &lt; pGraph-&gt;</span>numVertexes; ++i)</span><br><span class="line">		dist[i] = INFI;</span><br><span class="line">	dist[start] = <span class="number">0</span>;</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">/*记录起始点到各邻接点的距离*/</span></span><br><span class="line">	<span class="function"><span class="title">for</span> (AdjNode *ptmp = (pGraph-&gt;</span>A<span class="function"><span class="title">djArray</span>)[start].pFfirstedge; ptmp; ptmp = ptmp-&gt;</span>next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="title">dist</span>[ptmp-&gt;</span><span class="function"><span class="title">adjvex</span>] = ptmp-&gt;</span>weight;</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	int index;</span><br><span class="line">	<span class="function"><span class="title">for</span> (int i = 1; i &lt; pGraph-&gt;</span>numVertexes; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		int mincost = INFI;</span><br><span class="line">		<span class="comment">/*选择其中最小的距离的顶点*/</span></span><br><span class="line">		<span class="function"><span class="title">for</span> (int j = 0; j &lt; pGraph-&gt;</span>numVertexes; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!visited[j] &amp;&amp; dist[j] &lt; mincost)</span><br><span class="line">			&#123;</span><br><span class="line">				mincost = dist[j];</span><br><span class="line">				index = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	 </span><br><span class="line">		<span class="comment">/*以该顶点x为中间点，找到下一个点y，如果起始点start到中间点x的距离加上x到y的距离小于start到y的距离，则更新*/</span></span><br><span class="line">		<span class="comment">/*换言之，如果直接从北京到深圳用的钱比从先从北京到上海，再从上海转机到深圳要多，那么就选择后面这个方案*/</span></span><br><span class="line">		visited[index] = <span class="literal">true</span>;</span><br><span class="line">		<span class="function"><span class="title">for</span> (AdjNode *ptmp = (pGraph-&gt;</span>A<span class="function"><span class="title">djArray</span>)[index].pFfirstedge; ptmp; ptmp = ptmp-&gt;</span>next)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="title">if</span> (!visited[ptmp-&gt;</span><span class="function"><span class="title">adjvex</span>] &amp;&amp; (dist[index] + ptmp-&gt;</span><span class="function"><span class="title">weight</span>) &lt; dist[ptmp-&gt;</span>adjvex])</span><br><span class="line">				<span class="function"><span class="title">dist</span>[ptmp-&gt;</span><span class="function"><span class="title">adjvex</span>] = dist[index] + ptmp-&gt;</span>weight;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出迪科斯彻算法的时间复杂度为O(n^2)，对于邻接矩阵空间复杂度为O(n^2)。 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" class="post-title-link" itemprop="url">数据结构的BFS和DFS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-29 21:40:26" itemprop="dateCreated datePublished" datetime="2020-12-29T21:40:26+08:00">2020-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-04 22:46:02" itemprop="dateModified" datetime="2021-03-04T22:46:02+08:00">2021-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>下面的两种搜索算法都是基于 图的邻接表存储 。</p>
<p>深度优先搜索（DFS）</p>
<p>深度优先搜索（depth-first search）是对先序遍历（preorder traversal）的推广。我们从某个顶点 v 开始处理 v，然后递归地遍历所有与 v 邻接的顶点。</p>
<p>实现思想：</p>
<p>在深度优先搜索中，对于最新发现的顶点，如果它还有以此为起点而未探测到的边，就沿此边继续探测下去，当节点 v 的所有边都已被探寻过，探索将回溯到发现节点 v 有那条边的始节点，这一过程一直进行到已发现从源节点可达的所有节点位置。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个过程反复进行直到所有节点都被发现为止。</p>
<p>​                                                          </p>
<p>结合上图说明：左图是邻接表形式，按照上面的实现思想，假定我们首先发现顶点0，然后发现它还有以此为顶点而未探测到的边(0,1),(0,4)，探测完毕后，就回溯到始节点，然后到下一个节点1，(1,0)已探测过(无向图) ，则直接探测(1,4)，然后以此类推。                                    </p>
<p>为避免图中的圈造成的无限循环，当我们访问一个顶点 v 的时候，由于我们已经到达了该点处，因此需要将该点标记为已访问，对于未被标记的所有邻接顶点递归调用深度优先搜索。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">graph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	graph(<span class="keyword">int</span> v) :vertex(v)&#123;</span><br><span class="line">		adj = <span class="keyword">new</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;[v];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> vertex;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; *adj;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DFSUtil</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">bool</span> visited[])</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//v:边的首顶点；w：边的尾顶点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">graph::addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	adj[v].push_back(w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">graph::DFSUtil</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">bool</span> visited[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	visited[v] = <span class="literal">true</span>;<span class="comment">//置位</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">	<span class="keyword">for</span> (iter = adj[v].begin(); iter != adj[v].end(); ++iter)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!visited[*iter])<span class="comment">//表明未被访问过</span></span><br><span class="line">			DFSUtil(*iter, visited);<span class="comment">//跳转到*iter</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vStart:搜索的起始顶点</span></span><br><span class="line"><span class="comment">//指定的起始顶点必须位于图内可达到的顶点</span></span><br><span class="line"><span class="comment">//如果图不连通，有可能访问不到某些节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">graph::DFS</span><span class="params">(<span class="keyword">int</span> vStart)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[vertex];</span><br><span class="line">	<span class="built_in">memset</span>(visited, <span class="literal">false</span>, vertex);</span><br><span class="line"></span><br><span class="line">	DFSUtil(vStart, visited);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不需要指定起始顶点</span></span><br><span class="line"><span class="comment">//不管图的结构如何，都可以搜索到所有节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">graph::DFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[vertex];</span><br><span class="line">	<span class="built_in">memset</span>(visited, <span class="literal">false</span>, vertex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从V0开始深度优先遍历，Vk-1是最后一次深度优先遍历开始的顶点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertex; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!visited[i])</span><br><span class="line">			DFSUtil(i, visited);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">graph <span class="title">g</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">	g.addEdge(<span class="number">0</span>, <span class="number">1</span>);<span class="comment">//生成无向图</span></span><br><span class="line">	g.addEdge(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">	g.addEdge(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	g.addEdge(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">	g.addEdge(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	g.addEdge(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">	g.addEdge(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">	g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	g.addEdge(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">	g.addEdge(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">	g.addEdge(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">	g.addEdge(<span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">	g.addEdge(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">	g.addEdge(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	g.DFS();</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>布尔型数组 visited[ ] 初始化为 false。通过只对那些尚未被访问的节点递归调用该函数，我们保证不会陷入无限的循环。如果图是无向的且不连通，或是有向的但非强连通的，这种方法可能会访问不到某些节点（DFS(int v)）。此时我们搜索一个未被标记的节点，然后应用深度优先遍历，并继续这个过程直到不存在未标记的节点为止（DFS()）。因为该方法保证每条边只访问一次，所以只要使用邻接表，则执行遍历的总时间就是O(|E|+|V|)。 </p>
<p>广度优先搜索（BFS）</p>
<p>该方法按层处理顶点：距开始点最近的那些顶点首先被访问，而最远的那些顶点最后被访问。这很像对树的层序遍历。</p>
<p>为方便后面的介绍，重新贴一下邻接表的存储方式图：</p>
<p>​                                                  </p>
<p>我们以上图的邻接表存储方式为例对广度优先搜索进行说明：按照前面BFS的定义，我们首先访问所有与开始顶点最近的顶点，然后访问所有距离递增的顶点，最远的顶点则是最后被访问。假定开始顶点为1，与顶点1最近的顶点有四个：0、4、2、3。邻接表存储有个好处就是，所有最近且距离相等的顶点都位于该顶点位置的链表中。首先我们访问完所有与开始顶点1最近的顶点（0、4、2、3），很容易得知，与开始顶点次近（距离增1）的顶点恰好是最近顶点的最近顶点，也就是与（0、4、2、3）顶点最近的顶点。前面可理解为不断的替换开始顶点，已经访问过的顶点坐标记，保证不会被重复访问，否则进入无限循环。这样依次推进，直至访问完所有顶点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">``<span class="comment">//vStart:搜索的起始顶点`</span></span><br><span class="line">`<span class="comment">//指定的起始顶点必须位于图内可达到的顶点`</span></span><br><span class="line">`void graph::BFS(int vStart)`</span><br><span class="line">`&#123;`</span><br><span class="line">	`<span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[vertex];`</span><br><span class="line">	`<span class="built_in">memset</span>(visited, <span class="literal">false</span>, vertex);`</span><br><span class="line"></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;<span class="comment">//利用链表构建一个队列</span></span><br><span class="line">	 </span><br><span class="line">	visited[vStart] = <span class="literal">true</span>;<span class="comment">//表示开始访问</span></span><br><span class="line">	<span class="built_in">queue</span>.push_back(vStart);<span class="comment">//开始顶点入队</span></span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">queue</span>.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		vStart = <span class="built_in">queue</span>.front();<span class="comment">//这里有个优先级，邻接表中链表的头节点优先级最高，依次降低</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; vStart &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">queue</span>.pop_front();<span class="comment">//已访问顶点出队</span></span><br><span class="line">	 </span><br><span class="line">		<span class="comment">//将与开始顶点最近的顶点，也就是链表中的顶点依次入队</span></span><br><span class="line">		<span class="keyword">for</span> (iter = adj[vStart].<span class="built_in">begin</span>(); iter != adj[vStart].<span class="built_in">end</span>(); ++iter)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!visited[*iter])</span><br><span class="line">			&#123;</span><br><span class="line">				visited[*iter] = <span class="literal">true</span>;<span class="comment">//标记即将访问，事实上，进入队列了就是要访问的</span></span><br><span class="line">				<span class="built_in">queue</span>.push_back(*iter);<span class="comment">//从链表头节点到尾节点依次入队</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">`&#125;`</span><br><span class="line">`同样，如果图不是强连通，比如存在孤立的顶点，BFS就不能够访问图中所有的点，这可参考前面的DFS版本，进行修改以便对于任何图结构都能够访问所有顶点。BFS同DFS，只要使用邻接表，运行时间就是`O(|E|+|V|)。`</span><br></pre></td></tr></table></figure>

<p>深度优先搜索与广度优先搜索的区别：</p>
<p>深度优先搜索是按照一定的顺序先查找完一个分支，再查找另一个分支，直到找到目标，或是访问完所有节点（连通）；广度优先搜索是从初始状态一层一层向下找，直到找到目标，或是访问完所有节点（连通）。</p>
<p>深度优先搜索通过栈来实现，而广度优先搜索通过队列来实现。</p>
<p>通常深度优先搜索不全部保留结点，扩展完的结点从数据库中弹出删去，这样，一般在数据库中存储的结点数就是深度值，因此它占用空间较少。所以，当搜索树的结点较多，用其它方法易产生内存溢出时，深度优先搜索不失为一种有效的求解方法。<br>广度优先搜索算法，一般需存储产生的所有结点，占用的存储空间要比深度优先搜索大得多，因此，程序设计中，必须考虑溢出和节省内存空间的问题。但广度优先搜索法一般无回溯操作，即入栈和出栈的操作，所以运行速度比深度优先搜索要快些。</p>
<p>上面说的通俗点就是：广度优先搜索是从中心点层层向外推进，走完最里层房间，然后走第二层的所有房间，直到第二层的所有房间全部走完，再走第三层的房间（这里不同的是同一层的所有房间之间是可以跳转的）。而深度优先搜索则是走死胡同，从中心点开始走，一路走，直到最后无路可走，然后退回来一层，再进入下一层的一间房间（只有同层的房间可以跳转，不同层的房间需要退回来），再走其余房间。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">数据结构BFS、DFS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-29 21:38:30" itemprop="dateCreated datePublished" datetime="2020-12-29T21:38:30+08:00">2020-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-04 22:49:31" itemprop="dateModified" datetime="2021-03-04T22:49:31+08:00">2021-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这里则介绍图的另外一种存储方式：邻接矩阵。参考资料《大话数据结构》《C算法：卷二》</p>
<p>一、图的数据结构</p>
<p>图的邻接矩阵存储方式是用两个数据来表示。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边的信息。</p>
<p>见下图：（图片来源于《大话数据结构》）</p>
<p>​         <img src="/2020/12/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0/20150731211453086" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图的邻接矩阵存储*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> VertexType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVEX 100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFI 65535</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	VertexType vexs[MAXVEX];           <span class="comment">/*顶点表*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	EdgeType matrix[MAXVEX][MAXVEX];   <span class="comment">/*邻接矩阵*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> numVertexes;          <span class="comment">/*顶点数*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> numEdges;             <span class="comment">/*边数*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;Graph;</span><br></pre></td></tr></table></figure>

<p>二、创建一个图</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建一个邻接矩阵无向图*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Graph* <span class="title">CreateGraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Graph *pGragh = <span class="keyword">new</span> Graph;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pGragh)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入顶点数和边数："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; pGragh-&gt;numVertexes &gt;&gt; pGragh-&gt;numEdges;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pGragh-&gt;numVertexes; ++i)<span class="comment">/*建立顶点表*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		(pGragh-&gt;vexs)[i] = i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pGragh-&gt;numVertexes; ++i)<span class="comment">/*邻接矩阵初始化*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pGragh-&gt;numVertexes; ++j)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			(pGragh-&gt;matrix)[i][j] = INFI;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (i == j)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				(pGragh-&gt;matrix)[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; pGragh-&gt;numEdges; ++k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> i, j, w;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入边(vi,vj)上的下标i，下标j和权重w："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; i &gt;&gt; j &gt;&gt; w;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		(pGragh-&gt;matrix)[i][j] = w;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		(pGragh-&gt;matrix)[j][i] = (pGragh-&gt;matrix)[i][j];<span class="comment">//无向图是对称矩阵</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pGragh;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*创建一个邻接矩阵有向图*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Graph* <span class="title">CreateDiGraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Graph *pGragh = <span class="keyword">new</span> Graph;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pGragh)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入顶点数和边数："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; pGragh-&gt;numVertexes &gt;&gt; pGragh-&gt;numEdges;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pGragh-&gt;numVertexes; ++i)<span class="comment">/*建立顶点表*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		(pGragh-&gt;vexs)[i] = i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pGragh-&gt;numVertexes; ++i)<span class="comment">/*邻接矩阵初始化*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pGragh-&gt;numVertexes; ++j)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			(pGragh-&gt;matrix)[i][j] = INFI;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (i == j)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				(pGragh-&gt;matrix)[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; pGragh-&gt;numEdges; ++k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> i, j, w;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入边&lt;vi,vj&gt;上的下标i，下标j和权重w："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; i &gt;&gt; j &gt;&gt; w;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		(pGragh-&gt;matrix)[i][j] = w;<span class="comment">//清楚上面输入的顺序，有向边的开始点和终点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pGragh;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三、检查图中两个顶点间是否有边</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*检查两个顶点之间是否有边</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对于邻接矩阵存储图，这比较简单。其中有向图对输入顶点顺序有要求*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GraphHasEdge</span><span class="params">(Graph *pGraph, <span class="keyword">unsigned</span> <span class="keyword">int</span> begin, <span class="keyword">unsigned</span> <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pGraph || begin &gt;= pGraph-&gt;numVertexes || end &gt;= pGraph-&gt;numVertexes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (begin == end)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ((pGraph-&gt;matrix)[begin][end] != INFI) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四、DFS</p>
<p>关于DFS与BFS的介绍见开篇链接</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*DFS*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*邻接矩阵的深度优先递归算法*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSUtil</span><span class="params">(Graph *pGraph, <span class="keyword">int</span> start, <span class="keyword">bool</span> visited[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	visited[start] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; start &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pGraph-&gt;numVertexes; ++j)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((pGraph-&gt;matrix)[start][j] != <span class="number">0</span> &amp;&amp; (pGraph-&gt;matrix)[start][j] != INFI &amp;&amp; !visited[j])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			DFSUtil(pGraph, j, visited);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*邻接矩阵的深度优先搜索*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph *pGraph)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pGraph)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[pGraph-&gt;numVertexes];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(visited, <span class="literal">false</span>, pGraph-&gt;numVertexes);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pGraph-&gt;numVertexes; ++i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!visited[i])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			DFSUtil(pGraph, i, visited);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span>[] visited;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>五、BFS </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*BFS*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph *pGraph)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pGraph)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[pGraph-&gt;numVertexes];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(visited, <span class="literal">false</span>, pGraph-&gt;numVertexes);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;<span class="comment">//利用链表构造一个队列</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pGraph-&gt;numVertexes; ++i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!visited[i])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			visited[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; pGraph-&gt;vexs[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="built_in">queue</span>.push_back(i);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (!<span class="built_in">queue</span>.empty())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				i = *<span class="built_in">queue</span>.begin();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				<span class="built_in">queue</span>.pop_front();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pGraph-&gt;numVertexes; ++j)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> ((pGraph-&gt;matrix)[i][j] != <span class="number">0</span> &amp;&amp; (pGraph-&gt;matrix)[i][j] != INFI &amp;&amp; !visited[j])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">					&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">						visited[j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">						<span class="built_in">cout</span> &lt;&lt; pGraph-&gt;vexs[j] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">						<span class="built_in">queue</span>.push_back(j);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只提供相关代码实现，代码已测试，理论部分请参考相关资料。 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/29/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/29/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB1/" class="post-title-link" itemprop="url">汇编语言基础学习汇总1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-29 21:04:30" itemprop="dateCreated datePublished" datetime="2020-12-29T21:04:30+08:00">2020-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-01 22:20:21" itemprop="dateModified" datetime="2021-01-01T22:20:21+08:00">2021-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96/" itemprop="url" rel="index"><span itemprop="name">汇编</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>32k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>29 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h5 id="汇编语言指令组成"><a href="#汇编语言指令组成" class="headerlink" title="汇编语言指令组成"></a><strong>汇编语言指令组成</strong></h5><ul>
<li>汇编指令：机器码的助记符，有对应的机器码。</li>
<li>伪指令：没有对应的机器码，编译器执行，机器不执行。</li>
<li>其他符号：如±*/有编译器识别，无对应机器码。</li>
</ul>
<h5 id="CPU与外部器件交互需要"><a href="#CPU与外部器件交互需要" class="headerlink" title="CPU与外部器件交互需要"></a><strong>CPU与外部器件交互需要</strong></h5><ul>
<li>存储单元地址（地址信息）</li>
<li>器件选择，读写命令（控制信息）</li>
<li>数据（数据信息）</li>
</ul>
<h5 id="总线"><a href="#总线" class="headerlink" title="总线"></a><strong>总线</strong></h5><p>总线就是一根根导线的集合，分为</p>
<ul>
<li>地址总线，越宽（数量越多）代表可以寻址的范围越大</li>
<li>数据总线，越宽代表一次性读写的数据越多（8根1字节）</li>
<li>控制总线，越宽代表对器件控制操作越多</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h5><p>汇编指令和机器指令一一对应</p>
<p>每一种cpu都有自己的汇编指令集</p>
<p>在存储器中指令和数据都是二进制，没有任何区别</p>
<p>CPU可以直接使用的信息存放在存储器中（内存）</p>
<h5 id="接口卡"><a href="#接口卡" class="headerlink" title="接口卡"></a><strong>接口卡</strong></h5><p>CPU无法直接控制显示器，键盘等的外围设备，但CPU通过直接控制这些外围设备在主板上的接口卡来控制这些设备。</p>
<h5 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a><strong>存储器</strong></h5><p>随机存储器（RAM）：带电存储，关机丢失，可读可写</p>
<ul>
<li>用于存放CPU使用的绝大部分程序和数据，主随机存储器由装在主板上的RAM和扩展插槽的RAM组成。</li>
<li>其他接口卡上也可能有自己的RAM</li>
</ul>
<p>只读存储器（ROM）：关机不丢，只能读取</p>
<ul>
<li>主板上的ROM装有系统的BIOS（基本输入输出系统）。</li>
<li>其他接口卡上也可能有自己的ROM，一般装着相应的BIOS。</li>
</ul>
<p>（P10图）</p>
<h5 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a><strong>内存地址空间</strong></h5><p>以上这些内存都和CPU总线相连，CPU都通过控制总线向他们发出内存读写命令。所以CPU都把他们当内存对待，看做一个一个由若干存储单元组成的逻辑存储器，即内存地址空间（一个假想的逻辑存储器P11图）。</p>
<p>内存地址空间中的各个不同的地址段代表不同的存储设备，内存地址空间大小收到CPU地址总线长度限制。</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><h5 id="内部总线"><a href="#内部总线" class="headerlink" title="内部总线"></a><strong>内部总线</strong></h5><p>之前讨论的总线是CPU控制外部设备使用的总线，是将CPU和外部部件连接的。而CPU内部由寄存器，运算器，控制器等组成，由内部总线相连，内部总线负责连接CPU内部的部件。</p>
<h5 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a><strong>通用寄存器</strong></h5><p>8086CPU寄存器都是16位的，一共14个，分别是AX,BX,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW。其中AX,BX,CX,DX四个寄存器通常存放一般性的数据，称为通用寄存器。</p>
<p>而且为了兼容上一代的8位寄存器，这四个寄存器可以拆开成两个8位的寄存器来使用。称为AH,AL,BH,BL,CH,CL,DH,DL。低八位（编号0-7）构成L寄存器，高八位构成H寄存器。</p>
<h5 id="字"><a href="#字" class="headerlink" title="字"></a><strong>字</strong></h5><p>8086CPU可以处理以下两种数据</p>
<ul>
<li>字节byte，8位</li>
<li>字word，连个字节，16位。分别称为高位字节和低位字节。</li>
</ul>
<h5 id="简单的汇编指令"><a href="#简单的汇编指令" class="headerlink" title="简单的汇编指令"></a><strong>简单的汇编指令</strong></h5><table>
<thead>
<tr>
<th>指令</th>
<th>操作</th>
<th>高级语言</th>
</tr>
</thead>
<tbody><tr>
<td>mov ax,18</td>
<td>将18存入AX寄存器</td>
<td>AX=18</td>
</tr>
<tr>
<td>add ax,8</td>
<td>将AX寄存器中的数加8</td>
<td>AX=AX+8</td>
</tr>
<tr>
<td>mov ax,bx</td>
<td>将BX中的数据存入AX</td>
<td>AX=BX</td>
</tr>
<tr>
<td>add ax,bx</td>
<td>将AX中的数据和BX中的数据相加存入AX</td>
<td>AX=AX+BX</td>
</tr>
</tbody></table>
<p>汇编指令或寄存器名称不区分大小写。</p>
<p>注：AX寄存器当做两个8位寄存器al和ah使用的时候，CPU就把他们当做两个8位寄存器使用，而不会看成是一个16未分开，即如果al进行加法运算C5+93=158，即add al,93，al会变成58，ax则是0058而不是0158。</p>
<h5 id="CPU位结构"><a href="#CPU位结构" class="headerlink" title="CPU位结构"></a><strong>CPU位结构</strong></h5><p>16位结构的CPU指的是运算器一次最多处理16位数据，寄存器宽度16，寄存器和运算器之间通路也是16位。</p>
<h5 id="CPU表示物理地址"><a href="#CPU表示物理地址" class="headerlink" title="CPU表示物理地址"></a><strong>CPU表示物理地址</strong></h5><p>如果物理总线宽度超过寄存器宽度，CPU寻址方法是两个寄存器输出一个地址，当地址总线宽度20的时候，P21图。一个寄存器输出短地址，另一个输出偏移地址。然后通过地址加法器合并为一个20位的地址，然后通过内部总线送给控制电路，控制电路通过地址总线送给内存。</p>
<p>公式：物理地址=段地址x16+偏移地址（这里的x16其实就是左移四位，P21图）</p>
<p>虽然这么表示，但内存并没有被分为一段一段的，是CPU划分的段。段地址x16称为基础地址，所以我们可以根据需求把任意的基础地址加上不超过一个寄存器表示的最长（64KB）的偏移地址来表示地址。而且一个实际地址往往可以有各种不同的方法表示，通常我们表示21F60H这个地址通过下面方法：</p>
<ul>
<li>2000:1F60</li>
<li>2000H段中的1F60单元中</li>
</ul>
<h5 id="段寄存器与指令指针寄存器"><a href="#段寄存器与指令指针寄存器" class="headerlink" title="段寄存器与指令指针寄存器"></a><strong>段寄存器与指令指针寄存器</strong></h5><p>8086CPU有四个段寄存器：CS,DS,SS,ES</p>
<p>除此之外，IP寄存器称为指令指针寄存器，所以任意时刻可以读取从CSx16+IP单元开始，读取一条指令执行。也就是说，CPU将IP指向的内容当做指令执行。</p>
<p>P26图，CPU执行一段指令。另外，8086CPU开机时CS被置为FFFFH，IP被置为0000H，也就是说刚开机的第一条指令从FFFF0H开始读取执行。</p>
<p>CPU将CS:IP指向的内存中的内容当做指令，一条指令被执行了，那一定被CS:IP指向过。</p>
<h5 id="修改CS，IP"><a href="#修改CS，IP" class="headerlink" title="修改CS，IP"></a><strong>修改CS，IP</strong></h5><p>CS和IP寄存器不可以使用传送指令mov来改变，而能改变CS，IP内容的指令是转移指令。</p>
<p>jmp指令用法：</p>
<ul>
<li>jmp 段地址:偏移地址 同时修改CS和IP的值 如jmp 2AE3:3 结果CS=2AE3H IP=0003H</li>
<li>jmp 某一合法寄存器 只修改IP的值 如jmp ax，将IP的值置为AX中的值（AX不变）</li>
</ul>
<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a><strong>小结</strong></h5><p>8086CPU有四个段寄存器，CS是用来存放指令的段地址的段寄存器</p>
<p>IP用来存放指令的偏移地址</p>
<p>CS:IP指向的内容在任意时刻会被当做指令执行</p>
<p>使用转移指令修改CS和IP的内容</p>
<h5 id="实验"><a href="#实验" class="headerlink" title="实验"></a><strong>实验</strong></h5><p>Debug命令：</p>
<ul>
<li>R：查看，改变CPU寄存器内容<ul>
<li>直接-r查看寄存器内容</li>
<li>-r 寄存器名，改变寄存器内容</li>
</ul>
</li>
<li>D：查看内存中内容<ul>
<li>-d直接查看</li>
<li>-d 段地址:偏移地址 查看固定地址开始的内容</li>
<li>-d 段地址:偏移地址 结尾偏移地址 查看指定范围内存</li>
</ul>
</li>
<li>E：改写内存中内容<ul>
<li>-e 起始地址 数据 数据 数据 …</li>
<li>提问方式修改 -e 段地址:偏移地址 从这个地址开始一个一个改，空格下一个，回车结束</li>
<li>也可以写入字符 ‘a’</li>
</ul>
</li>
<li>U：将内存中的机器指令翻译成汇编指令<ul>
<li>-u 段地址:偏移地址</li>
</ul>
</li>
<li>T：执行一条机器指令<ul>
<li>-t 执行cs:ip指向的命令</li>
</ul>
</li>
<li>A：以汇编指令格式在内存中写入一条机器指令<ul>
<li>-a 段地址:偏移地址 从这个地址开始一行一行的写入汇编语句</li>
</ul>
</li>
</ul>
<h3 id="寄存器（内存访问）"><a href="#寄存器（内存访问）" class="headerlink" title="寄存器（内存访问）"></a>寄存器（内存访问）</h3><h5 id="内存到寄存器的储存"><a href="#内存到寄存器的储存" class="headerlink" title="内存到寄存器的储存"></a><strong>内存到寄存器的储存</strong></h5><p>寄存器是16位的，可以存放一个字即两个字节，而内存中的一个存储单元是一字节。所以一个寄存器可以存两个存储单元的内容，高地址存储单元存在高位字节中，低地址存储单元存在低位字节中。</p>
<p>字单元：存放一个字型数据的两个地址连续的内存单元。</p>
<h5 id="DS寄存器"><a href="#DS寄存器" class="headerlink" title="DS寄存器"></a><strong>DS寄存器</strong></h5><p>与CS类似，DS寄存器存放的是要从内存中读取的数据的段地址。我们想要使用mov指令从内存10000H（1000:0）中的数据送给AL时，如下：</p>
<p>mov al,[0]</p>
<p>后面的[0]指的是内存的偏移地址是0，CPU会自动从DS寄存器中提取段地址，所以应该首先将段地址1000H写入DS寄存器中。但却不能直接使用mov ds,1000指令，只能从其他寄存器中转传入DS寄存器。所以完整命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000</span><br><span class="line">mov ds,bx</span><br><span class="line">mov al,[0]</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>当然，从AL寄存器中将数据送入内存只要反过来使用mov就可以了，mov [0],al</p>
<p>如果需要传输字型数，只要使用对应的16位寄存器就可以了，传输的是以相应地址开始的一个字型数据（连续两个字节）。如mov [0],cx。</p>
<h5 id="mov，add，sub"><a href="#mov，add，sub" class="headerlink" title="mov，add，sub"></a><strong>mov，add，sub</strong></h5><p>mov常见语法：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> 寄存器,数据       <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">8</span></span><br><span class="line"><span class="keyword">mov</span> 寄存器,寄存器		<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br><span class="line"><span class="keyword">mov</span> 寄存器,内存单元    <span class="keyword">mov</span> <span class="built_in">ax</span>,[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">mov</span> 内存单元,寄存器    <span class="keyword">mov</span> [<span class="number">0</span>],<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> 段寄存器,寄存器    <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> 寄存器,段寄存器    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">ds</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>add，sub常见语法：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">add</span> 寄存器,数据        <span class="builtin-name">add</span> ax,8</span><br><span class="line"><span class="builtin-name">add</span> 寄存器,寄存器      <span class="builtin-name">add</span> ax,bx</span><br><span class="line"><span class="builtin-name">add</span> 寄存器,内存单元    <span class="builtin-name">add</span> ax,[0]</span><br><span class="line"><span class="builtin-name">add</span> 内存单元,寄存器    <span class="builtin-name">add</span> [0],ax</span><br><span class="line">sub和add一样</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>注意，add，sub不可以操作段寄存器。</p>
<h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a><strong>栈</strong></h5><p>栈是一种后进先出的存储空间，从栈顶出栈入栈。LIFO（last in first out）</p>
<p>入栈指令：push ax ax中的数据送入栈顶</p>
<p>出栈指令：pop ax 栈顶送入ax</p>
<p>入栈和出栈指令都是以字为单位的。P58图</p>
<h5 id="栈寄存器SS，SP与push，pop"><a href="#栈寄存器SS，SP与push，pop" class="headerlink" title="栈寄存器SS，SP与push，pop"></a><strong>栈寄存器SS，SP与push，pop</strong></h5><p>CPU通过SS寄存器和SP寄存器来知道栈的范围，段寄存器SS存放的是栈顶的段地址，SP寄存器存放的是栈顶的偏移地址。所以，任意时刻SS:SP指向栈顶元素。</p>
<p>指令push ax执行过程：</p>
<ol>
<li>SP=SP-2，SP指针向前移动两格代表新栈顶</li>
<li>AX中的数据送入SS:SP目前指向的内存字单元，P59图</li>
</ol>
<p>所以栈顶在低地址，栈底在高地址。初始状态下，SP指向栈底的下一个单元。</p>
<p>反之pop ax执行过程相反。</p>
<p>8086CPU并不会自己检测push是否会超栈顶，pop是否会超栈底。</p>
<p>push和pop可以加寄存器，段寄存器，内存单元（直接偏移地址[address]）</p>
<p>指定栈空间通常通过指定SS来进行，如：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">指定<span class="number">10000H</span>~<span class="number">1000FH</span>为栈空间</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">1000</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span> <span class="number">0010</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>注：将一个寄存器清零 sub ax,ax 两个字节，mov ax,0 三个字节</p>
<p>注：若设定一个栈段为10000H~1FFFFH，栈空的时候SP=0（要知道入栈操作先SP-2，然后再送入栈）</p>
<h5 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a><strong>实验</strong></h5><p>Debug中的t命令一次执行一条指令，但如果执行的指令修改了ss段寄存器，下一条命令也会紧跟着执行（中断机制）。</p>
<h3 id="简单编程"><a href="#简单编程" class="headerlink" title="简单编程"></a>简单编程</h3><h5 id="一个汇编语言程序"><a href="#一个汇编语言程序" class="headerlink" title="一个汇编语言程序"></a><strong>一个汇编语言程序</strong></h5><ol>
<li>编写</li>
<li>编译（masm5.0）</li>
<li>连接</li>
</ol>
<h5 id="一些伪指令功能"><a href="#一些伪指令功能" class="headerlink" title="一些伪指令功能"></a><strong>一些伪指令功能</strong></h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg</span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0123</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0456</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">ax</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,4c00</span><br><span class="line"><span class="keyword">int</span> <span class="number">21</span></span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<p>涉及到的一些知识：</p>
<ul>
<li>XXX segment···XXXends<ul>
<li>segment和ends成对出现，代表一个段的开始和结束。</li>
<li>一个汇编程序可以有多个段，代码，数据和栈等，至少要有一个段。</li>
</ul>
</li>
<li>end<ul>
<li>end代表一个汇编程序结束，遇到end编译器停止编译。</li>
</ul>
</li>
<li>assume<ul>
<li>assume 假设，假设某一个段寄存器和程序中的一个段关联。</li>
<li>可以理解为将这个段寄存器指向程序段的段地址</li>
</ul>
</li>
<li>标号（codesg）<ul>
<li>一个标号代表一个地址</li>
</ul>
</li>
<li>程序返回mov ax,4c00 int 21<ul>
<li>暂时记住这两条指令代表程序返回</li>
</ul>
</li>
</ul>
<p>编译和连接方法，P83。</p>
<p>注：编译器只能发现语法错误而无法发现逻辑错误。</p>
<p>CPU执行一个程序，需要有另一个程序将它加载进内存（即将CS:IP指向它），一般情况下我们通过DOS执行这个.exe，所以是DOS程序将它加载进入内存。当这个程序运行结束，再返回DOS程序继续执行。如果是DOS调用Debug调用.exe，那么先返回Debug再返回DOS。</p>
<p>DOS加载一个.exe时，先在内存中找到一段内存，起始段地址SA，然后分配256字节的PSP区域，用来和被加载程序通信。在之后的段地址SA+10就是程序开始的段地址。CS:IP指向它，DS=SA。</p>
<p>注：在Debug中，最后的int 21指令要使用P命令执行。</p>
<h3 id="BX-和loop指令"><a href="#BX-和loop指令" class="headerlink" title="[BX]和loop指令"></a>[BX]和loop指令</h3><h5 id="内存单元的描述"><a href="#内存单元的描述" class="headerlink" title="内存单元的描述"></a><strong>内存单元的描述</strong></h5><p>内存单元可以使用[数字]表示，当然也可以使用[寄存器]表示，如[bx]，mov ax,[bx]，mov al,[bx]</p>
<p>为了表示方便，使用()来表示一个内存单元或寄存器中的内容，如(ax),(20000H)，或((dx)*16+(bx))表示ds:bx中的内容，但不可写为(1000:0),((dx):0H)。而(X)中的内容由具体寄存器名或运算来决定。</p>
<p>我们使用idata来表示常亮。所以以下语句可以这么写：mov ax,[idata] mov ax,idata。</p>
<h5 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a><strong>loop指令</strong></h5><p>loop指令格式：loop 标号。</p>
<p>loop指令通常用来实现循环功能，当执行loop指令时，CPU进行两步操作：</p>
<ol>
<li>(cx)=(cx)-1</li>
<li>(cx)不为零则跳至标号处执行程序。</li>
</ol>
<p>所以CX中存放的是循环次数，一个简单的例子如下（计算2^12）：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">11</span></span><br><span class="line"><span class="symbol">s:</span><span class="keyword">add</span> <span class="built_in">ax</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>

<p>所以使用loop注意三点：</p>
<ol>
<li>先设置cx的值 mov cx,循环次数</li>
<li>设置标号与执行循环的程序段 s:执行程序段</li>
<li>在程序段最后写loop loop</li>
</ol>
<p>注：在汇编语言中，数据不能以字母开头，所以大于9fffH的数据，要在开头加0，如0A000H</p>
<p>注：debug中G命令 g 0012表示CPU从当前CS:IP开始一直执行到0012处暂停。P命令可以将loop部分一次执行完毕，直到(CX)=0，或使用g loop的下一条命令。</p>
<h5 id="Debug和masm编译器对指令的不同处理"><a href="#Debug和masm编译器对指令的不同处理" class="headerlink" title="Debug和masm编译器对指令的不同处理"></a><strong>Debug和masm编译器对指令的不同处理</strong></h5><p>mov ax,[0]这条指令在Debug和masm中有着不同的解释，Debug是将DS:0内存中的数据送给AX，而masm中则是mov ax,0，即将0送入AX。</p>
<p>解决方法1：先将偏移地址送入BX，然后再使用mov ax,[bx]</p>
<p>解决方法2：直接显式给出地址，如mov al，ds:[0] （相应的段寄存器还有CS,SS,ES这些在汇编语言中可以称为“段前缀”）当然，这种写法通过编译器之后会变成Debug中的mov al,[0]</p>
<p>注：inc bx bx值加一</p>
<h5 id="安全的编程空间"><a href="#安全的编程空间" class="headerlink" title="安全的编程空间"></a><strong>安全的编程空间</strong></h5><p>在之前没有提到的一个问题，如果在写程序之前不看一眼要操作的内存，就直接开始使用的话，万一改写了内存中重要的系统数据，可能会引起系统崩溃。所以我们一般在一个安全的内存空间中操作。一般操作系统和合法程序都不会使用0:200~0:2ff这256字节的空间，所以我们可以在这里操作。</p>
<p>学习汇编语言的目的就是直接和硬件对话，而不理会操作系统，这在DOS（实模式）下是可以做到的，但在windows或Unix这种运行与CPU保护模式的操作系统上却是不可能的，因为这种操作系统已经将CPU全面严格的管理了。</p>
<h5 id="段前缀的使用"><a href="#段前缀的使用" class="headerlink" title="段前缀的使用"></a><strong>段前缀的使用</strong></h5><p>将ffff:0ffff:b中的数据转存入0:2000:20b中：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0ffffh</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0020h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">12</span></span><br><span class="line"><span class="symbol">s:</span><span class="keyword">mov</span> <span class="built_in">dl</span>,[<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>],<span class="built_in">dl</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line"><span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure>

<p>[bx]直接使用的时候默认段前缀是ds，但要使用其他的段前缀，如es就要在前面加上。</p>
<h3 id="程序的段"><a href="#程序的段" class="headerlink" title="程序的段"></a>程序的段</h3><h5 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a><strong>数据段</strong></h5><p>一般一个程序想要使用内存空间，有两种方法，在程序加载的时候系统分配或在需要使用的时候向系统申请，我们先考虑第一种情况。所以我们应事先将所需的数据存入内存中的某一段中，但我们又不可以随意的指定内存地址，以下面的求8个数据累加和的代码为例：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dw</span> <span class="number">0123h</span>,<span class="number">0456h</span>,<span class="number">0789h</span>,<span class="number">0abch</span>,<span class="number">0defh</span>,<span class="number">0fedh</span>,<span class="number">0cbah</span>,<span class="number">0987h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">s:</span><span class="keyword">add</span> <span class="built_in">ax</span>,<span class="built_in">cs</span>:[<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>

<p>代码第一行的dw是定义字类型数据，define word的意思。这里定义了8个字类型数据，占16字节。由于是在程序最开始定义的dw，所以数据段的偏移地址为0，也就是说第一个数据0123h的地址是CS:[0]第二个0456h的地址是CS:[2]以此类推。</p>
<p>所以这个程序加载之后CS:IP指向的是数据段的第一个数据，我们要是想成功执行，需要把IP置10，指向第一条指令mov bx,0，所以我们想要直接执行（不在Debug中调整IP）的话，需要指定程序开始的地方：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line"><span class="built_in">dw</span> <span class="number">0123h</span>,<span class="number">0456h</span>,<span class="number">0789h</span>,<span class="number">0abch</span>,<span class="number">0defh</span>,<span class="number">0fedh</span>,<span class="number">0cbah</span>,<span class="number">0987h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">···</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>在第一条指令前加start，后面的end变成end start，end除了通知编译器程序在哪里结束之外，也可以通知程序的入口在哪，也就是第一条语句，在这里编译器就知道了mov bx,0是程序的第一条指令。也就是说，我们想要CPU从何处开始执行程序，只要在源程序中使用end 标号指定就好了。</p>
<p>所以有如下框架：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">assume</span> <span class="string">cs:code</span></span><br><span class="line"><span class="attr">code</span> <span class="string">segment</span></span><br><span class="line"><span class="attr">···数据···</span></span><br><span class="line"><span class="attr">start</span>:<span class="string"></span></span><br><span class="line"><span class="attr">···代码···</span></span><br><span class="line"><span class="attr">code</span> <span class="string">ends</span></span><br><span class="line"><span class="attr">end</span> <span class="string">start</span></span><br><span class="line"><span class="attr">1234567</span></span><br></pre></td></tr></table></figure>

<h5 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a><strong>栈段</strong></h5><p>看下面一段使8个数逆序存放的代码：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg</span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dw</span> <span class="number">0123h</span>,<span class="number">0456h</span>,<span class="number">0789h</span>,<span class="number">0abch</span>,<span class="number">0defh</span>,<span class="number">0fedh</span>,<span class="number">0cbah</span>,<span class="number">0987h</span></span><br><span class="line"><span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">30h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">s:</span><span class="keyword">push</span> <span class="built_in">cs</span>:[<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">s0:</span><span class="keyword">pop</span> <span class="built_in">cs</span>:[<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">loop</span> s0</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627</span></span><br></pre></td></tr></table></figure>

<p>在定义了8个字型数据之后，又定义了16个取值为0的字型数据，用作栈空间。所以dw这个定义不仅仅用来定义数据，也可以用来开辟内存空间留给之后的程序使用。</p>
<h5 id="数据，代码，栈的程序段"><a href="#数据，代码，栈的程序段" class="headerlink" title="数据，代码，栈的程序段"></a><strong>数据，代码，栈的程序段</strong></h5><p>在8086CPU中，一个段的长度最大为64KB，所以如果我们将数据或栈空间定义的比较大，就不能像前面一样编程了。我们需要将代码，数据，栈放入不同的段中：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data,<span class="built_in">ss</span>:stack</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line"><span class="built_in">dw</span> <span class="number">0123h</span>,<span class="number">0456h</span>,<span class="number">0789h</span>,<span class="number">0abch</span>,<span class="number">0defh</span>,<span class="number">0fedh</span>,<span class="number">0cbah</span>,<span class="number">0987h</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line"><span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">srack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">20h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">s:</span><span class="keyword">push</span> [<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">s0:</span><span class="keyword">pop</span> [<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">loop</span> s0</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536</span></span><br></pre></td></tr></table></figure>

<p>我们可以这样在写代码时就将程序分为几个段，这段代码中，mov ax,data的意思是将data段的段地址送入ax寄存器。但我们不可以使用mov ds,data这样是错误的，因为在这里data被编译器视为一个数值。</p>
<p>在这里将数据命名为data，代码命名为code，栈命名为stack只是为了方便阅读，CPU并不能理解，和start，s，s0一样，只在源程序中使用。而assume cs:code,ds:data,ss:stack这段代码也并不能让CPU的cs，ds，ss指向对应的段，因为assume是伪指令，CPU并不认识，它是由编译器执行的。源程序中end start语句指明了程序的入口，在这个程序被加载后，CS:IP被指向start处，开始执行第一条语句，这样CPU才会将code段当做代码执行。而当CPU执行</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">20h</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>这三条语句后才会将stack段当做栈空间开使用。也就是说，CPU如何区分哪个段的功能，全靠我们使用汇编指令对ds，ss，cs寄存器的内容设置来指定。</p>
<h3 id="灵活定位内存地址"><a href="#灵活定位内存地址" class="headerlink" title="灵活定位内存地址"></a>灵活定位内存地址</h3><h5 id="and和or指令"><a href="#and和or指令" class="headerlink" title="and和or指令"></a><strong>and和or指令</strong></h5><p>and：逻辑与指令，按位与运算，如：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">01100011B</span></span><br><span class="line"><span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">00111011B</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>执行结果是al=00100011B，所以我们想要把某一位置零的时候可以使用and指令。</p>
<p>or：逻辑或指令，按位或运算，如：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">01100011B</span></span><br><span class="line"><span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">00111011B</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>执行结果是al=01111011B，or指令可以将相应位置1。</p>
<h5 id="ASCII码和字符形式的数据"><a href="#ASCII码和字符形式的数据" class="headerlink" title="ASCII码和字符形式的数据"></a><strong>ASCII码和字符形式的数据</strong></h5><p>在汇编语言中我们可以使用’···’的方式指明数据是以字符形式给出的，编译器会自动将它们转化为ASCII码。例如：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line"><span class="built_in">db</span> <span class="string">'unIX'</span></span><br><span class="line"><span class="built_in">db</span> <span class="string">'foRK'</span></span><br><span class="line">data ends</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="string">'a'</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="string">'b'</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<p>db和dw类似，只不过定义的是字节型数据，然后通过’unIX’相继在接下来四个字节中写下75H,6EH,49H,58H即unIX的ASCII值。同理,mov al,’a’也是将’a’的ASCII值61H送入al寄存器。</p>
<p>使用and和or指令改变一串字符串字母的大小写，将第一串全变为大写，第二串全变为小写：</p>
<p>首先分析ASCII码：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">大写	十六进制	二进制			小写	十六进制	二进制</span><br><span class="line"> A		<span class="number">41</span>		<span class="number">01000001</span>		a		<span class="number">61</span>	   <span class="number">01100001</span></span><br><span class="line"> B		<span class="number">42</span>		<span class="number">01000010</span>		b		<span class="number">62</span>	   <span class="number">01100010</span></span><br><span class="line"> C 		<span class="number">43</span>		<span class="number">01000011</span>		c		<span class="number">63</span>	   <span class="number">01100011</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>可见，只有第5位（从右往左数，从0开始计数）在大写和小写的二进制中是不一样的，所以我们只要把所有字母的二进制第五位置零，那就是大写，置1就是小写。代码如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg,<span class="built_in">ds</span>:datasg</span><br><span class="line"></span><br><span class="line">datasg <span class="meta">segment</span></span><br><span class="line"><span class="built_in">db</span> <span class="string">'BaSiC'</span></span><br><span class="line"><span class="built_in">db</span> <span class="string">'iNfOrMaTiOn'</span></span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,datasg</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">5</span></span><br><span class="line"><span class="symbol">s:</span><span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">11011111B</span></span><br><span class="line"><span class="keyword">mov</span> [<span class="built_in">bx</span>],<span class="built_in">al</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line"><span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">11</span></span><br><span class="line"><span class="symbol">s0:</span><span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">00100000B</span></span><br><span class="line"><span class="keyword">mov</span> [<span class="built_in">bx</span>],<span class="built_in">al</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line"><span class="keyword">loop</span> s0</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233</span></span><br></pre></td></tr></table></figure>

<h5 id="bx-idata-的内存表示方法与数组处理"><a href="#bx-idata-的内存表示方法与数组处理" class="headerlink" title="[bx+idata]的内存表示方法与数组处理"></a><strong>[bx+idata]的内存表示方法与数组处理</strong></h5><p>除了使用[bx]来表示一个内存单元外，我们还可以使用[bx+idata]来表示一个内存单元，他表示的意思是偏移地址为(bx)+idata（bx中的数值加idata）的内存单元。当然也可写为[idata+bx]，除此之外还可写为，200[bx]，[bx].200。</p>
<p>既然有了这种表示方法，我们就可以使用这种方法来操作数组，刚才将两个字符串改变大小写的代码的循环部分可以如下优化：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line"><span class="symbol">s:</span><span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">11011111B</span></span><br><span class="line"><span class="keyword">mov</span> [<span class="built_in">bx</span>],<span class="built_in">al</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="number">5</span>+<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">00100000B</span></span><br><span class="line"><span class="keyword">mov</span> [<span class="number">5</span>+<span class="built_in">bx</span>],<span class="built_in">al</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line"><span class="keyword">loop</span> s</span><br><span class="line">···</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p>当然也可写为0[bx]和5[bx]，注意这种写法和C语言中数组的相似之处：C语言中数组表示为a[i]，汇编语言中表示为5[bx]。</p>
<h5 id="SI和DI寄存器"><a href="#SI和DI寄存器" class="headerlink" title="SI和DI寄存器"></a><strong>SI和DI寄存器</strong></h5><p>SI和DI功能和BX相似，但不可以拆分为两个8位寄存器。也就是说下面代码等价：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>|<span class="built_in">si</span>|<span class="built_in">di</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,[<span class="built_in">bx</span>|<span class="built_in">si</span>|<span class="built_in">di</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,[<span class="built_in">bx</span>|<span class="built_in">si</span>|<span class="built_in">di</span>+<span class="number">123</span>]</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>所以在这里可以使用更方便的方式：[bx+si]和[bx+di]，这两个式子表示偏移地址为(bx)+(si)的内存单元，使用方法如：mov ax,[bx+si]等价于<code>mov ax,[bx][si]。</code></p>
<p>当然，有了这些表示方法，自然就有[bx+si+idata]和[bx+di+idata]，相似的，也可以写成</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx+200+si]</span><br><span class="line">mov ax,[200+bx+si]</span><br><span class="line">mov ax,200[<span class="string">bx</span>][<span class="symbol">si</span>]</span><br><span class="line">mov ax,[bx].200[si]</span><br><span class="line">mov ax,[<span class="string">bx</span>][<span class="symbol">si</span>].200</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>那我们总结一下这些内存寻址方法：</p>
<ul>
<li>[idata]用一个常量表示偏移地址，直接定位一个内存单元</li>
<li>[bx]用一个变量表示偏移地址，定位一个内存单元</li>
<li>[bx+idata]用一个常量和一个变量表示偏移地址，可在一个起始地址的基础上间接定位一个内存单元</li>
<li>[bx+si]用两个变量表示偏移地址</li>
<li>[bx+si+idata]用两个变量和一个常量表示偏移地址</li>
</ul>
<p>使用双循环，使用一个寄存器暂存cs的值，如：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">4</span></span><br><span class="line"><span class="symbol">s0:</span><span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="built_in">cx</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span></span><br><span class="line"><span class="symbol">s:</span><span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">bx</span>+<span class="built_in">si</span>]</span><br><span class="line"><span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">11011111b</span></span><br><span class="line"><span class="keyword">mov</span> [<span class="built_in">bx</span>+<span class="built_in">si</span>],<span class="built_in">al</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line"><span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">16</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">dx</span></span><br><span class="line"><span class="keyword">loop</span> s0</span><br><span class="line">···</span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>

<p>假如循环比较复杂，没有多余的寄存器可用，我们可以使用内存暂存cx或其他数据：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line"><span class="built_in">dw</span> <span class="number">0</span></span><br><span class="line">···</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">4</span></span><br><span class="line"><span class="symbol">s0:</span><span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">40H</span>],<span class="built_in">cx</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span></span><br><span class="line"><span class="symbol">s:</span><span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">bx</span>+<span class="built_in">si</span>]</span><br><span class="line"><span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">11011111b</span></span><br><span class="line"><span class="keyword">mov</span> [<span class="built_in">bx</span>+<span class="built_in">si</span>],<span class="built_in">al</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line"><span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">16</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">ds</span>:[<span class="number">40H</span>]</span><br><span class="line"><span class="keyword">loop</span> s0</span><br><span class="line">···</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>

<p>这么使用的话注意需要在数据段声明用来暂存的内存，好在程序加载时分配出来。当然，在需要暂存的地方，还是建议使用栈：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line"><span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">···</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,stacksg</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line">···</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">4</span></span><br><span class="line"><span class="symbol">s0:</span><span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span></span><br><span class="line"><span class="symbol">s:</span><span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">bx</span>+<span class="built_in">si</span>]</span><br><span class="line"><span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">11011111b</span></span><br><span class="line"><span class="keyword">mov</span> [<span class="built_in">bx</span>+<span class="built_in">si</span>],<span class="built_in">al</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line"><span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">16</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line"><span class="keyword">loop</span> s0</span><br><span class="line">···</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure>

<h3 id="数据处理的两个基本问题"><a href="#数据处理的两个基本问题" class="headerlink" title="数据处理的两个基本问题"></a>数据处理的两个基本问题</h3><h5 id="两个基本问题"><a href="#两个基本问题" class="headerlink" title="两个基本问题"></a><strong>两个基本问题</strong></h5><ol>
<li>处理的数据在什么地方</li>
<li>要处理的数据有多长</li>
</ol>
<p>接下来的讨论中，使用reg来表示一个寄存器，使用sreg来表示一个段寄存器。所以：</p>
<ul>
<li>reg：ax,bx,cx,dx,ah,al,bh,bl,ch,cl,dh,dl,sp,bp,si,di</li>
<li>sreg：ds,ss,cs,es</li>
</ul>
<h5 id="bx，si，di和bp"><a href="#bx，si，di和bp" class="headerlink" title="bx，si，di和bp"></a><strong>bx，si，di和bp</strong></h5><p>在8086CPU中，只有这四个寄存器可以使用[···]来进行内存寻址，可以单个出现，或以下面组合出现（常数可以随意出现在这些表示方法中）：</p>
<ul>
<li>bx+si/di</li>
<li>bp+si/di</li>
</ul>
<p>注：如果使用了bp来寻址，而没有显式的表明段地址，默认使用ss段寄存器，如：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bp]              ;<span class="comment">(ax)</span>=<span class="comment">((ss)</span>*<span class="number">16</span>+<span class="comment">(bp)</span>)</span><br><span class="line">mov ax,[bp+idata]        ;<span class="comment">(ax)</span>=<span class="comment">((ss)</span>*<span class="number">16</span>+<span class="comment">(bp)</span>+idata)</span><br><span class="line">mov ax,[bp+si]           ;<span class="comment">(ax)</span>=<span class="comment">((ss)</span>*<span class="number">16</span>+<span class="comment">(bp)</span>+<span class="comment">(si)</span>+idata)</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<h5 id="数据的位置"><a href="#数据的位置" class="headerlink" title="数据的位置"></a><strong>数据的位置</strong></h5><p>绝大部分机器指令都是用来处理数据的，基本可分为读取，写入，运算。在机器指令这个层面上，并不关心数据是什么，而关心指令执行前数据的位置。一般数据会在三个地方，CPU内部，内存，端口。</p>
<p>汇编语言中使用三个概念来表示数据的位置：</p>
<ul>
<li>立即数（idata）<ul>
<li>对于直接包含在机器指令中的数据，在汇编语言中称为立即数</li>
<li>例：mov ax,1 add bx,2000h</li>
</ul>
</li>
<li>寄存器<ul>
<li>指令要处理的数据在寄存器中，在汇编指令中给出相应寄存器名</li>
<li>例：mov ax,bx mov ds,ax</li>
</ul>
</li>
<li>段地址（SA）和偏移地址（EA）<ul>
<li>指令要处理的数据在内存中，在指令中使用[X]方式给出，SA在某个段寄存器中</li>
<li>例：mov ax,[0] mov ax,[di]</li>
</ul>
</li>
</ul>
<p>总结一下寻址方式：</p>
<table>
<thead>
<tr>
<th>寻址方式</th>
<th>含义</th>
<th>名称</th>
</tr>
</thead>
<tbody><tr>
<td>[idata]</td>
<td>EA=idata;SA=(DS)</td>
<td>直接寻址</td>
</tr>
<tr>
<td>[bx|si|di|bp]</td>
<td>EA=(bx|si|di|bp);SA=(DS)</td>
<td>寄存器间接寻址</td>
</tr>
<tr>
<td>[bx|si|di|bp+idata]</td>
<td>EA=(bx|si|di|bp+idata);SA=(DS)</td>
<td>寄存器相对寻址</td>
</tr>
<tr>
<td>[bx|bp+si|di]</td>
<td>EA=(bx|bp+si|di);SA=(DS|SS)</td>
<td>基址变址寻址</td>
</tr>
<tr>
<td>[bx|bp+si|di+idata]</td>
<td>EA=(bx|bp+si|di+idata);SA=(DS|SS)</td>
<td>相对基址变址寻址</td>
</tr>
</tbody></table>
<h5 id="数据的长度"><a href="#数据的长度" class="headerlink" title="数据的长度"></a><strong>数据的长度</strong></h5><p>8086CPU中可以指定两种尺寸的数据，byte和word，所以在使用数据的时候要指明数据尺寸。</p>
<ul>
<li>在有寄存器参与的时候使用寄存器的种类区分<ul>
<li>字：mov ax,1</li>
<li>字节：mov al,1</li>
</ul>
</li>
<li>在没有寄存器参与的时候，使用X ptr指明内存单元长度，X是word或byte<ul>
<li>字：mov word ptr ds:[0],1 add word ptr [bx],2</li>
<li>字节：mov byte ptr ds:[0],1 add byte ptr [bx],2</li>
</ul>
</li>
<li>其他默认指明处理类型的指令<ul>
<li>push [1000H]，push默认只进行字操作</li>
</ul>
</li>
</ul>
<p>灵活使用寻址方式的例子，修改下面内存空间中的数据：</p>
<p>段seg:60</p>
<table>
<thead>
<tr>
<th>起始地址</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>00</td>
<td>‘DEC’</td>
</tr>
<tr>
<td>03</td>
<td>‘Ken Oslen’</td>
</tr>
<tr>
<td>0C</td>
<td>137</td>
</tr>
<tr>
<td>0E</td>
<td>40</td>
</tr>
<tr>
<td>10</td>
<td>‘PDP’</td>
</tr>
</tbody></table>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">seg</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">60h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>].<span class="number">0ch</span>,<span class="number">38</span>    <span class="comment">;第三字段改为38</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>].<span class="number">0eh</span>,<span class="number">70</span>    <span class="comment">;第四字段改为70</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>].<span class="number">10h</span>[<span class="built_in">si</span>],<span class="string">'v'</span>   <span class="comment">;修改最后一个字段的三个字符</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>].<span class="number">10h</span>[<span class="built_in">si</span>],<span class="string">'A'</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>].<span class="number">10h</span>[<span class="built_in">si</span>],<span class="string">'X'</span></span><br><span class="line">···</span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>

<p>这段代码中地址的使用类似c++中结构体的使用。[bx].idata.[si]，就类似与c++中的dec.cp[i]。dec是结构体，cp是结构体中的字符串成员，[i]表示第几个字符。</p>
<h5 id="div指令"><a href="#div指令" class="headerlink" title="div指令"></a><strong>div指令</strong></h5><p>div是除法指令，需要注意以下三点：</p>
<ul>
<li>除数：8位或16位，在一个reg或内存单元中</li>
<li>被除数：默认在AX或DX中，如果除数8位，被除数则为16位，放在AX中；如果除数16位，则被除数32位，在DX和AX中，DX存放高16位，AX放低16位。</li>
<li>结果，除数8位，结果（商）存放在AL中，AH存放余数；如果除数16位，则AX存放商，DX存放余数</li>
</ul>
<p>格式：div reg或div 内存单元，所以div byte ptr ds:[0]表示：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(al)</span>=<span class="comment">(ax)</span>/<span class="comment">((ds)</span>*<span class="number">16</span><span class="number">+0</span>)的商;</span><br><span class="line"><span class="comment">(ah)</span>=<span class="comment">(ax)</span>/<span class="comment">((ds)</span>*<span class="number">16</span><span class="number">+0</span>)的余数；</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>div word ptr es:[0]表示：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">al</span>)=[(<span class="built_in">dx</span>)*<span class="number">10000H</span>+(<span class="built_in">ax</span>)]/((<span class="built_in">es</span>)*<span class="number">16</span>+<span class="number">0</span>)的商</span><br><span class="line">(<span class="number">ah</span>)=[(<span class="built_in">dx</span>)*<span class="number">10000H</span>+(<span class="built_in">ax</span>)]/((<span class="built_in">es</span>)*<span class="number">16</span>+<span class="number">0</span>)的余数</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>例：计算100001/100，因为100001(186A1H)大于65535，则需要存放在ax和dx两个寄存器，那么除数100只能存放在一个16位的寄存器中，实现代码：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">86A1H</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">100</span></span><br><span class="line"><span class="keyword">div</span> <span class="built_in">bx</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>执行之后(ax)=03E8H(1000),(dx)=1。</p>
<h5 id="伪指令dd"><a href="#伪指令dd" class="headerlink" title="伪指令dd"></a><strong>伪指令dd</strong></h5><p>dd是一个伪指令，类似dw，但dd是用来定义dword（double word，双字），如：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="number">1</span>  ;<span class="number">2</span>字，<span class="number">4</span>字节</span><br><span class="line">dw <span class="number">1</span>  ;<span class="number">1</span>字，<span class="number">2</span>字节</span><br><span class="line">db <span class="number">1</span>  ;<span class="number">1</span>字节</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>将data段中第一个数据除以第二个数据，商存入第三个数据：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line"><span class="built_in">dd</span> <span class="number">100001</span></span><br><span class="line"><span class="built_in">dw</span> <span class="number">100</span></span><br><span class="line"><span class="built_in">dw</span> <span class="number">0</span></span><br><span class="line">data ends</span><br><span class="line">···</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="built_in">ds</span>:[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">div</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">4</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">6</span>],<span class="built_in">ax</span></span><br><span class="line">···</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>

<p>总结一下div相关：</p>
<ul>
<li>div后面跟的是除数</li>
<li>被除数位数是除数两倍</li>
<li>被除数存在ax中或ax+dx（ax低，dx高）</li>
<li>商在ax或al中，余数在ah或dx中（高余数，低商）</li>
</ul>
<h5 id="dup"><a href="#dup" class="headerlink" title="dup"></a><strong>dup</strong></h5><p>dup是一个操作符，由编译器识别，和db,dw,dd配合使用，如：</p>
<p>db 3 dup (0)表示定义了三个值是0的字节，等价于db 0,0,0</p>
<p>db 3 dup (1,2,3)等价于db 1,2,3,1,2,3,1,2,3 共九个字节</p>
<p>db 3 dup (‘abc’,‘ABC’)等价于db ‘abcABCabcABCabcABC’</p>
<p>综上，db|dw|dd 重复次数 dup (重复内容)</p>
<h3 id="转移指令原理"><a href="#转移指令原理" class="headerlink" title="转移指令原理"></a>转移指令原理</h3><h5 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a><strong>转移指令</strong></h5><p>可以修改IP或同时修改CS，IP的系统指令称为转移指令，可分为以下几类：</p>
<ul>
<li>转移行为：<ul>
<li>只修改IP，称为段内转移，如jmp ax</li>
<li>同时修改CS和IP，称为段间转移，如jmp 1000:0</li>
</ul>
</li>
<li>修改范围（段内转移）：<ul>
<li>短转移：修改IP范围-128~127</li>
<li>近转移：修改IP范围-32768~32767</li>
</ul>
</li>
<li>转移指令分类：<ul>
<li>无条件转移：jmp</li>
<li>条件转移</li>
<li>循环指令</li>
<li>过程</li>
<li>中断</li>
</ul>
</li>
</ul>
<h5 id="offset操作符"><a href="#offset操作符" class="headerlink" title="offset操作符"></a><strong>offset操作符</strong></h5><p>offset是由编译器处理的符号，它能去的标号的偏移地址，如：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> ax,offset start</span><br><span class="line"><span class="symbol">s:</span><span class="keyword">mov</span> ax,offset s</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>这里就是将start和s的偏移地址分别送给ax，也就是0和3</p>
<h5 id="jmp指令"><a href="#jmp指令" class="headerlink" title="jmp指令"></a><strong>jmp指令</strong></h5><p>jmp是无条件转移指令，可以只修改IP也可以同时修改CS和IP，只要给出两种信息，要转移的目的地址和专一的距离。</p>
<p>依据位移的jmp指令：jmp short 标号（转到标号处执行指令）。这个指令实现的是段内短转移，对IP修改范围是-128~127，指令结束后CS:IP指向标号的地址，如：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>BBD:<span class="number">0000</span>   start:mov ax,<span class="number">0</span>  (B80000)</span><br><span class="line"><span class="number">0</span>BBD:<span class="number">0003</span>   jmp short s   (EB03)</span><br><span class="line"><span class="number">0</span>BBD:<span class="number">0005</span>   add ax,<span class="number">1</span>    (<span class="number">050100</span>)</span><br><span class="line"><span class="number">0</span>BBD:<span class="number">0008</span>   s:inc ax    (<span class="number">40</span>)</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>执行之后ax值为1，因为跳过了add指令。</p>
<p>还应注意的是，jmp short短转移指令并不会在机器码中直接写明需要转移的地址（0BBD:0008）,jmp的机器码是EB03并没有包含转移的地址，这里的转移距离是相对计算而出的地址，来看下面的执行过程：</p>
<ol>
<li>(CS)=0BBDH,(IP)=0006H，CS:IP指向EB03（jmp short s）</li>
<li>读取指令EB03进入指令缓冲器</li>
<li>(IP)=(IP)+指令长度，即(IP)=(IP)+2=0008H，之后CS:IP指向add ax,1</li>
<li>CPU指向指令缓冲器中的指令EB03</li>
<li>执行之后(IP)=000BH，指向inc ax</li>
</ol>
<p>在jmp short s的机器码中，包含的并不是转移的地址，而是转移的位移，这里的位移是相对计算出来的，用8位一字节来表示，所以表示范围是-128<del>127，用补码表示。计算方法如是，8位位移=标号处地址-jmp下一条指令的地址。当然还有一种类似的指令是jmp near ptr 标号，是近转移，原理一样，只是表示位移的是字类型16位，表示范围-32768</del>32767。</p>
<h5 id="jmp-地址远转移"><a href="#jmp-地址远转移" class="headerlink" title="jmp+地址远转移"></a><strong>jmp+地址远转移</strong></h5><p>jmp far ptr 标号实现的是段间转移，也就是远转移，它的机器码中指明了转移的目的地址的CS和IP的值，如下面例子：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>BBD:<span class="number">0000</span>   start:mov ax,<span class="number">0</span>    (B80000)</span><br><span class="line"><span class="number">0</span>BBD:<span class="number">0003</span>   mov bx,<span class="number">0</span>    (BB0000)</span><br><span class="line"><span class="number">0</span>BBD:<span class="number">0006</span>   jmp far ptr s    (EA0B01BD0B)</span><br><span class="line"><span class="number">0</span>BBD:<span class="number">000</span>B   db <span class="number">256</span> dup (<span class="number">0</span>)    </span><br><span class="line"><span class="number">0</span>BBD:<span class="number">010</span>B   s:add ax,<span class="number">1</span>    </span><br><span class="line"><span class="number">0</span>BBD:<span class="number">010</span>X   inc ax</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>可以看出，jmp的机器码中明确指明了跳转位置s的地址0BBD:010B，在低位的是IP的值，高位的是CS的值。</p>
<h5 id="jmp-寄存器-内存转移"><a href="#jmp-寄存器-内存转移" class="headerlink" title="jmp+寄存器|内存转移"></a><strong>jmp+寄存器|内存转移</strong></h5><p>jmp+寄存器：jmp 16位reg，实现的是(IP)=(16位reg)，之前讨论过，直接修改IP的值为寄存器中的值。</p>
<p>jmp+内存：jmp加内存使用的时候有两种用法：</p>
<ul>
<li>jmp word ptr 内存单元地址（段内转移）<ul>
<li>从内存单元地址处开始存放一个座位转移目的的偏移地址的字</li>
<li>内存单元支持任何寻址方式</li>
<li>如jmp word ptr ds:[0]，执行后(IP)=0123H(ds:[0]中的值是123H)</li>
</ul>
</li>
<li>jmp dword ptr 内存单元地址（段间转移）<ul>
<li>从内存单元地址处开始存放两个字，高位存放段地址，低位偏移地址作为转移的目的地址</li>
<li>(CS)=(内存单元地址+2),(IP)=(内存单元地址)，支持任一种寻址方式</li>
<li>如jmp dword ptr [bx]跳转到0:123H</li>
</ul>
</li>
</ul>
<h5 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a><strong>jcxz指令</strong></h5><p>jcxz指令为条件转移指令，所有的条件转移指令都是短转移，转移范围是-128~127。使用格式是jcxz 标号，功能是如果(cx)=0则跳转到标号处执行；如果(cx)!=0，那么什么也不做继续执行代码。</p>
<h5 id="loop指令-1"><a href="#loop指令-1" class="headerlink" title="loop指令"></a><strong>loop指令</strong></h5><p>loop为循环指令，所有的循环指令都是短转移，转移范围是-128~127。使用格式是loop 标号，功能是如果(cx)!=0那么跳转到标号处执行；如果(cx)=0那么什么也不做继续执行程序。</p>
<h5 id="根据位移进行转移的指令总结"><a href="#根据位移进行转移的指令总结" class="headerlink" title="根据位移进行转移的指令总结"></a><strong>根据位移进行转移的指令总结</strong></h5><p>下面几条指令是根据位移进行转移（相对计算转移位置，而不是直接提供转移目的的IP和CS的值）</p>
<ul>
<li>jmp short 标号</li>
<li>jmp near ptr 标号</li>
<li>jcxz 标号</li>
<li>loop 标号</li>
</ul>
<p>这些指令之所以是间接计算标号的位置，是为了方便在代码中浮动装配，使得循环体或这些指令的代码段在任何位置都可以执行（不要超跳转范围）。而编译器会对跳转的范围进行检测，如果跳转超过了范围，编译器会报错。</p>
<p>注：jmp 2100:0是debug使用的汇编指令，编译器并不认识。</p>
<h3 id="call和ret指令"><a href="#call和ret指令" class="headerlink" title="call和ret指令"></a>call和ret指令</h3><h5 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a><strong>ret和retf</strong></h5><p>ret和call都是转移指令，都是修改IP的值，或同时修改CS和IP。</p>
<p>ret指令用栈中的数据修改IP，实现的是近转移；retf指令用栈中的数据修改CS和IP的值，实现远转移。格式：直接用 ret。</p>
<p>ret执行步骤：</p>
<ol>
<li>(IP)=((SS)*16+(SP))</li>
<li>(SP)=(SP)+2</li>
</ol>
<p>retf执行步骤：</p>
<ol>
<li>(IP)=((SS)*16+(SP))</li>
<li>(SP)=(SP)+2</li>
<li>(CS)=((SS)*16+(SP))</li>
<li>(SP)=(SP)+2</li>
</ol>
<p>所以ret指令相当于 pop ip，执行retf指令相当于执行pop ip,pop cs。</p>
<h5 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a><strong>call指令</strong></h5><p>call指令也是一个转移指令，执行格式：call 目标（具体使用接下来说明），call的执行步骤：</p>
<ol>
<li>将当前的IP或CS和IP入栈</li>
<li>转移</li>
</ol>
<p>call不能实现短转移，但它实现转移的原理和jmp相同。</p>
<p>根据位移转移：call 标号，近转移，16位转移范围，也是使用相对的转移地址。</p>
<p>执行步骤：</p>
<ol>
<li>(SP)=(SP)-2</li>
<li>((SS)*16+(SP))=(IP)</li>
<li>(IP)=(IP)+16</li>
</ol>
<p>所以执行这条命令相当于执行push ip,jmp near ptr 标号。</p>
<p>直接使用地址进行（远）转移：call far ptr 标号，执行步骤：</p>
<ol>
<li>(SP)=(SP)-2</li>
<li>((SS)*16+(SP))=(CS)</li>
<li>(SP)=(SP)-2</li>
<li>((SS)*16+(SP))=(IP)</li>
<li>(CS)=标号所在的段的段地址</li>
<li>(IP)=标号的偏移地址</li>
</ol>
<p>所以执行call far ptr 标号相当于执行push cs,push ip,jmp far ptr 标号</p>
<p>使用寄存器的值作为call的跳转地址：call 16位reg</p>
<ol>
<li>(SP)=(SP)-2</li>
<li>((SS)*16+(SP))=(IP)</li>
<li>(IP)=(16为reg)</li>
</ol>
<p>相当于执行push ip,jmp 16位reg</p>
<p>使用内存中的值作为call的跳转地址：call word ptr 内存单元地址，当然还有call dword ptr 内存单元地址，这样进行的就是远转移。</p>
<h5 id="联合使用ret和call"><a href="#联合使用ret和call" class="headerlink" title="联合使用ret和call"></a><strong>联合使用ret和call</strong></h5><p>联合使用ret和call实现子程序的框架：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">···</span><br><span class="line"><span class="keyword">call</span> sub1</span><br><span class="line">···</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">sub1:</span></span><br><span class="line">···</span><br><span class="line"><span class="keyword">call</span> sub2</span><br><span class="line">···</span><br><span class="line"><span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">sub2:</span></span><br><span class="line">···</span><br><span class="line"><span class="keyword">ret</span></span><br><span class="line">code ends</span><br><span class="line">end main</span><br><span class="line"><span class="number">1234567891011121314151617181920</span></span><br></pre></td></tr></table></figure>

<h5 id="mul指令"><a href="#mul指令" class="headerlink" title="mul指令"></a><strong>mul指令</strong></h5><p>mul是乘法指令，使用时应注意，两个相乘的数，要么都是8位，要么都是16位，如果是8位，那么其中一个默认放在al中，另一个在一个8位reg或字节内存单元中；若是16位，则一个默认在ax中，另一个在16位reg或字内存单元中。如果是8位乘法， 则结果放在ax中，结果是16位；若是16位乘法，结果默认在ax和dx中，dx高位，ax低位，共32位。</p>
<p>格式：mul reg 或 mul 内存单元，支持内存单元的各种寻址方式。</p>
<p>如mul word ptr [bx+si+8]代表：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(ax)</span>=<span class="comment">(ax)</span>*<span class="comment">((ds)</span>*<span class="number">16</span>+<span class="comment">(bx)</span>+<span class="comment">(si)</span><span class="number">+8</span>)低<span class="number">16</span>位</span><br><span class="line"><span class="comment">(dx)</span>=<span class="comment">(ax)</span>*<span class="comment">((ds)</span>*<span class="number">16</span>+<span class="comment">(bx)</span>+<span class="comment">(si)</span><span class="number">+8</span>)高<span class="number">16</span>位</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>例：计算100*10</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">100</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="number">10</span></span><br><span class="line"><span class="keyword">mul</span> <span class="built_in">bl</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<h5 id="参数的传递和模块化编程"><a href="#参数的传递和模块化编程" class="headerlink" title="参数的传递和模块化编程"></a><strong>参数的传递和模块化编程</strong></h5><p>看下面一段程序：计算data中第一行的数的立方存在第二行</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line"><span class="built_in">dw</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line"><span class="built_in">dd</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cs</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">s:</span><span class="keyword">mov</span> <span class="built_in">bx</span>,[<span class="built_in">si</span>]</span><br><span class="line"><span class="keyword">call</span> cube</span><br><span class="line"><span class="keyword">mov</span> [<span class="built_in">di</span>],<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> [<span class="built_in">di</span>].<span class="number">2</span>,<span class="built_in">dx</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">si</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">4</span></span><br><span class="line"><span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">cube:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br><span class="line"><span class="keyword">mul</span> <span class="built_in">bx</span></span><br><span class="line"><span class="keyword">mul</span> <span class="built_in">bx</span></span><br><span class="line"><span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031</span></span><br></pre></td></tr></table></figure>

<h5 id="寄存器冲突"><a href="#寄存器冲突" class="headerlink" title="寄存器冲突"></a><strong>寄存器冲突</strong></h5><p>观察下面将data中的数据全转化为大写的代码：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line"><span class="built_in">db</span> <span class="string">'word'</span>,<span class="number">0</span></span><br><span class="line"><span class="built_in">db</span> <span class="string">'unix'</span>,<span class="number">0</span></span><br><span class="line"><span class="built_in">db</span> <span class="string">'wind'</span>,<span class="number">0</span></span><br><span class="line"><span class="built_in">db</span> <span class="string">'good'</span>,<span class="number">0</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">4</span></span><br><span class="line"><span class="symbol">s:</span><span class="keyword">mov</span> <span class="built_in">si</span>,<span class="built_in">bx</span></span><br><span class="line"><span class="keyword">call</span> capital</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">5</span></span><br><span class="line"><span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">capital:</span><span class="keyword">mov</span> <span class="built_in">cl</span>,[<span class="built_in">si</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">jcxz</span> ok</span><br><span class="line"><span class="keyword">and</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>],<span class="number">11011111b</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line"><span class="keyword">jmp</span> short capital</span><br><span class="line"><span class="symbol">ok:</span><span class="keyword">ret</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031</span></span><br></pre></td></tr></table></figure>

<p>这段代码有一个问题出在，主函数部分使用cx设置循环次数4次，在循环中调用了子函数，而子函数中有一个判断语句jcxz也是用了cx，并且在之前修改了cx的值，造成逻辑错误。虽然修改的方法有很多，但我们应遵循以下的标准：</p>
<ul>
<li>编写调用子程序的程序不必关心子程序使用了什么寄存器</li>
<li>编写子程序不用关心调用子程序的程序使用了什么寄存器</li>
<li>不会发生寄存器冲突</li>
</ul>
<p>针对这三点，我们可以如下修改代码：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line"><span class="symbol">capital:</span><span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">change:</span><span class="keyword">mov</span> <span class="built_in">cl</span>,[<span class="built_in">si</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">jcxz</span> ok</span><br><span class="line"><span class="keyword">and</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>],<span class="number">11011111b</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line"><span class="keyword">jmp</span> short change</span><br><span class="line"></span><br><span class="line"><span class="symbol">ok:</span><span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line"><span class="keyword">ret</span></span><br><span class="line">···</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<p>虽然和上面的程序中没有冲突的是si，但我们保险起见，在子程序开始时将子程序用到的所有的寄存器的内容存入栈中，在返回之前在出栈回到相应寄存器中。这样无论调用子程序的程序使用了什么寄存器，都不会产生寄存器冲突。</p>
<h3 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h3><h5 id="标志寄存器-1"><a href="#标志寄存器-1" class="headerlink" title="标志寄存器"></a><strong>标志寄存器</strong></h5><p>CPU中有一种特殊的寄存器——标志寄存器（不同CPU中的个数和结构都可能不同），主要有以下三种作用：</p>
<ol>
<li>存储相关指令的某些执行结果</li>
<li>为CPU执行相关质量提供行为依据</li>
<li>控制CPU相关工作方式</li>
</ol>
<p>8086CPU中的标志寄存器有16位，其中存储的信息通常被称为程序状态字（PSW），标志寄存器以下简称为flag。标志位如图：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span>	<span class="number">14</span>	<span class="number">13</span>	<span class="number">12</span>	<span class="number">11</span>	<span class="number">10</span>	<span class="number">9</span>	<span class="number">8</span>	<span class="number">7</span>	<span class="number">6</span>	<span class="number">5</span>	<span class="number">4</span>	<span class="number">3</span>	<span class="number">2</span>	<span class="number">1</span>	<span class="number">0</span></span><br><span class="line">				OF	DF	IF	TF	SF	ZF		AF		PF		CF</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>如上图所示，1,3,5,12,13,14,15位没有使用，没有任何意义，而其他几位都有不同的含义。</p>
<h5 id="ZF标志"><a href="#ZF标志" class="headerlink" title="ZF标志"></a><strong>ZF标志</strong></h5><p>ZF位于flag第6位，零标志位，功能是记录相关指令执行后结果是否为0，如果结果为0，则ZF=1，否则ZF=0。如：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">ax</span>,<span class="number">1</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>执行后结果为0，ZF=1。一般情况下，运算指令（如add,sub,mul,div,inc,or,and）影响标志寄存器，而传送指令（如mov,push,pop）不影响标志寄存器。</p>
<h5 id="PF标志"><a href="#PF标志" class="headerlink" title="PF标志"></a><strong>PF标志</strong></h5><p>flag的第2位是PF标志位，奇偶标志位，功能是记录相关指令执行后，其结果的所有bit中1的个数是否为偶数，若1的个数是偶数，pf=1，如果是奇数，fp=0。如：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">10</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>执行后结果为00001011b，有3个1，所以PF=0。</p>
<h5 id="SF标志"><a href="#SF标志" class="headerlink" title="SF标志"></a><strong>SF标志</strong></h5><p>flag的第7位是SF标志位，符号标志位，它记录相关指令执行后，结果是否为负，如果结果为负，则sf=1，结果为正，sf=0。计算机中通常用补码表示数据，一个数可以看成有符号数或无符号数，如：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000001</span>B，可以看成无符号<span class="number">1</span>或有符号+<span class="number">1</span></span><br><span class="line"><span class="number">10000001</span>B，可以看成无符号<span class="number">129</span>或有符号<span class="number">-127</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>也就是说对于同一个数字，可以当做有符号数运算也可以当做无符号数运算。如：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">10000001b</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">1</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>这段代码结果是(al)=10000010b，可以将add指令进行的运算当做无符号运算，那么相当于129+1=130，也可以当做有符号运算，相当于-127+1=-126。SF标志就是在进行有符号运算的时候记录结果的符号的，当进行无符号运算的时候SF无意义（但还会影响SF，只是对我们来说没有意义了）。</p>
<h5 id="CF标志"><a href="#CF标志" class="headerlink" title="CF标志"></a><strong>CF标志</strong></h5><p>flag的第0位是CF标志位，进位标志位，一般情况下载进行无符号运算时，他记录了运算结果的最高有效为向更高为的进位值，或从更高位的借位值。加入一个无符号数据是8位的，也就是0-7个位，那么在做加法的时候就可能造成进位到第8位，这时并不是丢弃这个进位，而是记录在falg的CF位上。如：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">98h</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="built_in">al</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>执行后al=30h，CF=1。当两个数据做减法的时候有可能向更高位借位，如97h-98h借位后相当于197h-198h，CF也可以用来记录借位，如：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">97h</span></span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">al</span>,<span class="number">98h</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>执行后(al)=FFH，CF=1记录了向更高位借位的信息。</p>
<h5 id="OF标志"><a href="#OF标志" class="headerlink" title="OF标志"></a><strong>OF标志</strong></h5><p>在进行有符号运算的时候，如果结果超过了机器能表示的范围称为“溢出”。机器能表示的范围是指如8位寄存器存放或一个内存单元存放，表示范围就是-128~127,16位同理。如果超出了这个范围就叫做溢出，如：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">98</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">99</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0F0H</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">088H</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>第一段代码(al)=(al)+99=98+99=197超过了8位能表示的有符号数的范围，第二段代码结果(al)=(al)+(-120)=(-16)+(-12-)=-136也超过了8位有符号的范围，所以计算的结果是不可信的。如第一段代码计算之后(al)=0C5H，换成补码表示的是-59,98+99=-59很明显是不正确的结果。</p>
<p>flag的第11位是OF标志位，溢出标志位，一般情况下，OF记录有符号数运算结果是否溢出，如果溢出则OF=1，如果没有溢出，OF=0。所以CF是对无符号数的标志，OF是对有符号的标志。但对于一个运算指令，他们是同时生效的，只不过这个指令究竟是有符号还是无符号，是看实际的操作的。有符号CF无意义，无符号OF无意义。</p>
<h5 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a><strong>adc指令</strong></h5><p>adc是带进位加法指令，利用了CF标志位上记录的进位值。格式：adc 操作对象1,操作对象2。功能：操作对象1=操作对象1+操作对象2+CF。如abc ax,bx实现的是(ax)=(ax)+(bx)+CF，如：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">bx</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">adc</span> <span class="built_in">ax</span>,<span class="number">1</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>注意这段代码，首先ax中的值是2，bx中的值是1，然后进行(bx)-(ax)的计算，结果是-1造成了无符号的借位，此时CF=1，在进行adc ax,1时，进行的是(ax)+1+CF=2+1+1=4。仔细分析一下就可以发现，如果把整个加法分开，低位先相加，然后高位相加再加上进位CF， 就是一个完整的加法运算，也就是说add ax,dx这个指令可以拆分为：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="built_in">bl</span></span><br><span class="line"><span class="keyword">adc</span> <span class="number">ah</span>,<span class="number">bh</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>所以有了adc这个指令我们就可以完成一些更庞大的数据量的加法运算。如计算1EF000H+000H的值：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">001eh</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0f000h</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">1000h</span></span><br><span class="line"><span class="keyword">adc</span> <span class="built_in">ax</span>,<span class="number">0020h</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>注：inc和loop指令不影响CF位。</p>
<h5 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a><strong>sbb指令</strong></h5><p>sbb和adc类似，是带借位的减法，格式：sbb 操作对象1,操作对象2，执行的功能是操作对象1=操作对象1-操作对象2-CF，如：sbb ax,bx即(ax)=(ax)-(bx)-CF。sbb指令影响CF。</p>
<h5 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a><strong>cmp指令</strong></h5><p>cmp是比较指令，cmp的功能相当于减法，只是不保存结果。cmp执行后影响标志寄存器，其他相关指令通过识别被影响的标志位来得知结果。格式：cmp 操作对象1,操作对象2，执行功能是计算对操作对象1-操作对象2但不保存结果，仅仅根据结果对标志位进行设置，如：cmp ax,ax结果为0，但并不保存在ax中，执行之后zf=1,pf=1,sf=0,cf=0,of=0。若执行cmp ax,bx通过标志位就可以判断结果：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">若<span class="comment">(ax)</span>=<span class="comment">(bx)</span>则<span class="comment">(ax)</span>-<span class="comment">(bx)</span>=<span class="number">0</span>,zf=<span class="number">1</span></span><br><span class="line">若<span class="comment">(ax)</span>!=<span class="comment">(bx)</span>则<span class="comment">(ax)</span>-<span class="comment">(bx)</span>!=<span class="number">0</span>,zf=<span class="number">0</span></span><br><span class="line">若<span class="comment">(ax)</span>&lt;<span class="comment">(bx)</span>则<span class="comment">(ax)</span>-<span class="comment">(bx)</span>产生借位,cf=<span class="number">1</span></span><br><span class="line">若<span class="comment">(ax)</span>&gt;=<span class="comment">(bx)</span>则<span class="comment">(ax)</span>-<span class="comment">(bx)</span>不产生借位,cf=<span class="number">0</span></span><br><span class="line">若<span class="comment">(ax)</span>&gt;<span class="comment">(bx)</span>则<span class="comment">(ax)</span>-<span class="comment">(bx)</span>既不产生借位,结果又不为<span class="number">0</span>,cf=<span class="number">0</span>且zf=<span class="number">0</span></span><br><span class="line">若<span class="comment">(ax)</span>&lt;=<span class="comment">(bx)</span>则<span class="comment">(ax)</span>-<span class="comment">(bx)</span>既可能借位,结果可能为<span class="number">0</span>,cf=<span class="number">1</span>或zf=<span class="number">1</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>但实际上往往会出现溢出，如34-(-96)=82H(82H是-126的补码)，但应该等于130超出了补码表示的范围，所以sf=1。我们可以同时检验sf和of两个来验证cmp的结果：cmp ah,bh</p>
<ul>
<li>若sf=1，of=0说明没有溢出，那么sf的计算结果正确(ah)&lt;(bh)</li>
<li>若sf=1，of=1说明出现了溢出，那么sf结果相反(ah)&gt;(bh)</li>
<li>若sf=0，of=1说明有溢出，那么sf结果相反(ah)&lt;(bh)</li>
<li>若sf=0，of=0说明没有溢出，那么结果正确(ah)&gt;=(bh)</li>
</ul>
<h5 id="检测比较结果的条件转移指令"><a href="#检测比较结果的条件转移指令" class="headerlink" title="检测比较结果的条件转移指令"></a><strong>检测比较结果的条件转移指令</strong></h5><p>下面几条指令和cmp一起使用，检测不同的标志位来达到不同的条件跳转效果：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
<th>检测的标志位</th>
</tr>
</thead>
<tbody><tr>
<td>je</td>
<td>等于则转移</td>
<td>zf=1</td>
</tr>
<tr>
<td>jne</td>
<td>不等于转移</td>
<td>zf=0</td>
</tr>
<tr>
<td>jb</td>
<td>小于转移</td>
<td>cf=1</td>
</tr>
<tr>
<td>jnb</td>
<td>不小于转移</td>
<td>cf=0</td>
</tr>
<tr>
<td>ja</td>
<td>大于转移</td>
<td>cf=0且zf=0</td>
</tr>
<tr>
<td>jna</td>
<td>不大于转移</td>
<td>cf=1或zf=1</td>
</tr>
</tbody></table>
<p>指令中的字母含义如下：</p>
<ul>
<li>e:equa;</li>
<li>ne:not equal</li>
<li>b:below</li>
<li>nb:not below</li>
<li>a:above</li>
<li>na:not above</li>
</ul>
<p>上面的检测都是在cmp进行无符号比较时的检测位，有符号数检测原理一样，只是检测的标志位不同而已。下面看一个例子，如果(ah)=(bh)则(ah)=(ah)+(ah)，否则(ah)=(ah)+(bh)</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmp</span> <span class="number">ah</span>,<span class="number">bh</span></span><br><span class="line"><span class="keyword">je</span> s</span><br><span class="line"><span class="keyword">add</span> ab,<span class="number">bh</span></span><br><span class="line"><span class="keyword">jmp</span> short ok</span><br><span class="line"><span class="symbol">s:</span><span class="keyword">add</span> <span class="number">ah</span>,<span class="number">ah</span></span><br><span class="line"><span class="symbol">ok:</span>···</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>这里注意的是，je检测的是zf位，而不管之前执行的是什么指令，只要zf=1就会发生转移，所以cmp的位置需要仔细的把控，当然是否和cmp配合使用也是取决于编程者，下面例子实现了统计data中数值为8的字节个数，然后用ax保存：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line"><span class="built_in">db</span> <span class="number">8</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">63</span>,<span class="number">38</span></span><br><span class="line">data ends</span><br><span class="line">···</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">s:</span><span class="keyword">cmp</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>],<span class="number">8</span></span><br><span class="line"><span class="keyword">jne</span> next</span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">ax</span></span><br><span class="line"><span class="symbol">next:</span><span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line"><span class="keyword">loop</span> s</span><br><span class="line">···</span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>

<h5 id="DF标志位和串传送指令"><a href="#DF标志位和串传送指令" class="headerlink" title="DF标志位和串传送指令"></a><strong>DF标志位和串传送指令</strong></h5><p>flag的第10位是DF标志位，方向标志位，在串处理中，每次操作si，di的增减。</p>
<ul>
<li>df=0每次操作后si，di递增</li>
<li>df=1每次操作后si，di递减</li>
</ul>
<p>串传送指令，movsb，这个指令相当于执行：</p>
<ol>
<li><p><code>((es)*16+(di))=((ds)*16+(si))</code></p>
</li>
<li><p>如果df=0：(si)=(si)+1,(di)=(di)+1</p>
<p>如果df=1：(si)=(si)-1,(di)=(di)-1</p>
</li>
</ol>
<p>可以看出，movsb是将DS:SI指向的内存单元中的字节送入ES:DI中，然后根据DF的值对SI和DI增减1</p>
<p>同理mobsw就是将DS:SI指向的内存单元中的字送入ES:DI中，然后根据DF的值对SI和DI增减2</p>
<p>但一般来说，movsb和movsw都是和rep联合使用的，格式：rep movsb，这相当于：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s</span>:<span class="string">movsb</span></span><br><span class="line"><span class="attr">loop</span> <span class="string">s</span></span><br><span class="line"><span class="attr">12</span></span><br></pre></td></tr></table></figure>

<p>所以rep的作用是根据cx的值重复执行后面的串传送指令，由于每次执行movsb之后si和di都会自行增减，所以使用rep可以完成(cx)个字节的传送。movsw也一样。</p>
<p>由于DF位决定着串传送的方向，所以这里有两条指令用来设置df的值：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cld：<span class="attribute">df</span>=0</span><br><span class="line">std：<span class="attribute">df</span>=1</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>例子：使用串传送指令将data段中第一个字符串复制到他后面的空间中：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line"><span class="built_in">db</span> <span class="string">'Welcome to masm!'</span></span><br><span class="line"><span class="built_in">db</span> <span class="number">16</span> dup (<span class="number">0</span>)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">16</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">16</span></span><br><span class="line"><span class="keyword">cld</span></span><br><span class="line"><span class="keyword">rep</span> <span class="keyword">movsb</span></span><br><span class="line">···</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<h5 id="pushf和popf"><a href="#pushf和popf" class="headerlink" title="pushf和popf"></a><strong>pushf和popf</strong></h5><p>pushf的功能是将标志寄存器的值入栈，popf是出栈标志寄存器。有了这两个命令，就可以直接访问标志寄存器了，如：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">popf</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<h5 id="标志寄存器在Debug中的表示"><a href="#标志寄存器在Debug中的表示" class="headerlink" title="标志寄存器在Debug中的表示"></a><strong>标志寄存器在Debug中的表示</strong></h5><p>Debug中-r查看寄存器信息，最后有一段表示，下面列出我们已知的寄存器在Debug里的表示：</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>值1的标记</th>
<th>值0的标记</th>
</tr>
</thead>
<tbody><tr>
<td>of</td>
<td>OV</td>
<td>NV</td>
</tr>
<tr>
<td>sf</td>
<td>NG</td>
<td>PL</td>
</tr>
<tr>
<td>zf</td>
<td>ZR</td>
<td>NZ</td>
</tr>
<tr>
<td>pf</td>
<td>PE</td>
<td>PO</td>
</tr>
<tr>
<td>cf</td>
<td>CY</td>
<td>NC</td>
</tr>
<tr>
<td>df</td>
<td>DN</td>
<td>UP</td>
</tr>
</tbody></table>
<h3 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h3><h5 id="内中断的产生"><a href="#内中断的产生" class="headerlink" title="内中断的产生"></a><strong>内中断的产生</strong></h5><p>任何一个通用CPU都拥有执行完当前正在执行的指令后，检测到从CPU发来的中断信息，然后立即去处理中断信息的能力。这里的中断信息是指几个具有先后顺序的硬件操作，当CPU出现下面请看时会产生中断信息，相应的中断信息类型码（供CPU区分来源，是字节型，共256种）如下：</p>
<ul>
<li>除法错误，如执行div指令出现除法溢出 0</li>
<li>单步执行 1</li>
<li>执行into指令 4</li>
<li>执行int指令 指令执行的int n后面的n就是一个字节型立即数，即为中断类型码</li>
</ul>
<h5 id="中断处理和中断向量表"><a href="#中断处理和中断向量表" class="headerlink" title="中断处理和中断向量表"></a><strong>中断处理</strong>和中断向量表</h5><p>CPU接收到中断信息之后，往往要对中断信息进行处理，而如何处理使我们编程决定的。而CPU通过中断向量表来根据中断类型找到处理程序的入口地址（CS:IP)也称为中断向量。</p>
<p>中断向量表中存放着不同的中断类型对应的中断向量（处理程序的入口地址），中断向量表存放在内存中，8086PC指定必须放在内存地址0处，从0000:0000到0000:03FF的1024个单元存放中断向量表，每个表项占两个字，四个字节。</p>
<p>CPU会自动根据中断类型找到对应的中断向量并设置CS和IP的值，这个过程称为中断过程，步骤如下：</p>
<ol>
<li>（从中断信息中）取得中断类型码</li>
<li>标志寄存器的值入栈（暂存）pushf</li>
<li>设置标志寄存器第8位TF和第9位IF的值为0 TF=0,IF=0</li>
<li>CS内容入栈 push cs</li>
<li>IP内容入栈 push ip</li>
<li>在中断向量表中找到对应的CS和IP值并设置 <code>(ip)=(N*4),(cs)=(N*4+2)</code></li>
</ol>
<p>这么做的目的是，在中断处理之后还要回复CPU的现场（各个寄存器的值），所以先把那些入栈。</p>
<h5 id="中断处理程序和iret指令"><a href="#中断处理程序和iret指令" class="headerlink" title="中断处理程序和iret指令"></a><strong>中断处理程序和iret指令</strong></h5><p>运行中的CPU随时都可能接收到中断信息，所以CPU随时都可能执行中断程序，执行的步骤：</p>
<ol>
<li>保存用到的寄存器</li>
<li>处理中断</li>
<li>回复用到的寄存器</li>
<li>用iret返回</li>
</ol>
<p>iret的指令功能是：pop ip pop cs popf(前面说到了，这三个寄存器的入栈是硬件自动完成的，所以iret是和硬件自动完成的步骤配合使用的)。</p>
<p>以处理0号除法溢出中断为例，我们想要编写除法溢出的中断处理程序需要解决如下几步问题：</p>
<ol>
<li>编写程序</li>
<li>找到一段没有使用的内存空间</li>
<li>将程序写入到内存</li>
<li>将内存中的程序的入口写入0号中断的向量表位置</li>
</ol>
<p>我们可以采取下面框架来完成这个过程：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">start do0安装程序</span><br><span class="line">设置中断向量表</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">do0 程序部分</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">···</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p>可以看出我们分成了两部分，第一部分称之为“安装”，第二部分是代码实现。安装部分的函数实现思路如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">设置<span class="built_in">es</span>:<span class="built_in">di</span>至项目的地址</span><br><span class="line">设置<span class="built_in">ds</span>:<span class="built_in">si</span>指向源地址</span><br><span class="line">设置<span class="built_in">cx</span>为传输长度</span><br><span class="line">设置传输方向为正</span><br><span class="line"><span class="keyword">rep</span> <span class="keyword">movsb</span></span><br><span class="line">设置中断向量表</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>实现如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">si</span>,offset do0</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">200h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,offset do0end-fooset do0</span><br><span class="line"><span class="keyword">cld</span></span><br><span class="line"><span class="keyword">rep</span> <span class="keyword">movsb</span></span><br><span class="line">···</span><br><span class="line"><span class="symbol">do0:</span>代码</span><br><span class="line"><span class="symbol">do0end:</span><span class="keyword">nop</span></span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<p>这里offset do0end-fooset do0的意思是do0到do0end的代码长度，-是编译器可以识别并运算的符号，也就是说编译器可以再编译时处理表达式，如8-4等。还要注意的是，假如代码部分要输出“owerflow！”的话，需要将输出的内容写在代码部分并写入选择的内存中，否则如果单单在这个安装程序开始开辟一段data段的话，是会在程序返回时被释放。如：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">do0:</span><span class="keyword">jmp</span> short do0start</span><br><span class="line">db <span class="string">"overflow!"</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">do0start:</span></span><br><span class="line">···</span><br><span class="line"><span class="symbol">do0end:</span><span class="keyword">nop</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<h5 id="单步中断"><a href="#单步中断" class="headerlink" title="单步中断"></a><strong>单步中断</strong></h5><p>当标志寄存器的TF标志位为1的时候，CPU会在执行一条语句之后将资源入栈，然后去执行单步中断处理程序，如Debug就是运行在单步中断的条件下的，它能让CPU每执行一条指令都暂停，然后我们可以查看CPU的状态。但CPU可以防止在运行单步中断处理程序的时候再发生中断然后又去调用单步中断处理程序…CPU可以将TF置零，这样就不会再中断了。CPU提供这个功能就是为了单步跟踪程序的执行。</p>
<p>但需要注意的是，CPU并不会每次接收中断信息之后立即执行，在某些特定情况下它不会立即响应中断，如设置ss寄存器的时候如果接收到了中断信息，就不会响应。因为我们需要连续设置ss和ip的值，在debug中单步执行的时候也是，mov ss,ax和mov sp,0是在一步之内执行的，所以我们需要灵活使用这个特性，sp紧跟着ss执行，而不要在设置ss和sp之间插入其他指令。</p>
<h3 id="int指令"><a href="#int指令" class="headerlink" title="int指令"></a>int指令</h3><h5 id="int指令-1"><a href="#int指令-1" class="headerlink" title="int指令"></a><strong>int指令</strong></h5><p>int指令也会引发中断，使用格式是int n，n就是int引发的中断类型码，int中断的执行过程：</p>
<ol>
<li>获取类型码n</li>
<li>标志寄存器入栈，if=0，tf=0</li>
<li>cs，ip入栈</li>
<li><code>(ip)=(n*4),(cs)=(n*4+2)</code></li>
<li>执行n号中断的程序</li>
</ol>
<p>所以我们可以使用int指令调用任何一个中断的中断程序，如int 0调用除法溢出中断。一般情况下，系统将一些具有一定功能的小程序以中断的方式提供给程序调用，当然也可以自己编写，可以简称为中断例程。</p>
<h5 id="编写中断例程"><a href="#编写中断例程" class="headerlink" title="编写中断例程"></a><strong>编写中断例程</strong></h5><p>如编写中断7ch的中断例程，实现word型数据的平方，返回dx和ax中。求2*3456^2，代码：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">start <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">3456</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">7ch</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">ax</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">adc</span> <span class="built_in">dx</span>,<span class="built_in">dx</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p>接下来写7ch的功能和安装程序，并修改7ch中断向量表：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">si</span>,offset sqr</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">200h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,offset sqrend-offset sqr</span><br><span class="line"><span class="keyword">cld</span></span><br><span class="line"><span class="keyword">rep</span> <span class="keyword">movsb</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">7ch</span>*<span class="number">4</span>],<span class="number">200h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">7ch</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">sqr:</span><span class="keyword">mul</span> <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">iret</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">sqrend:</span><span class="keyword">nop</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526</span></span><br></pre></td></tr></table></figure>

<p>编写7ch中断实现loop指令，主程序输出80个“！”：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">start <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">160</span>*<span class="number">12</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,offset s-offset se</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">80</span></span><br><span class="line"><span class="symbol">s:</span><span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">di</span>],<span class="string">'!'</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">7ch</span></span><br><span class="line"><span class="symbol">se:</span><span class="keyword">nop</span></span><br><span class="line">···</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<p>7ch实现部分：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">lp:</span><span class="keyword">push</span> <span class="built_in">bp</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bp</span>,<span class="built_in">sp</span></span><br><span class="line"><span class="keyword">dec</span> <span class="built_in">cx</span></span><br><span class="line"><span class="keyword">jcxz</span> lpret</span><br><span class="line"><span class="keyword">add</span> [<span class="built_in">bp</span>+<span class="number">2</span>],<span class="built_in">bx</span></span><br><span class="line"><span class="symbol">lpret:</span><span class="keyword">pop</span> <span class="built_in">bp</span></span><br><span class="line"><span class="keyword">iret</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>因为bx里面是需要专一的偏移地址，而使用bp的时候默认段寄存器是ss，所以add [bp+2],bx就可以实现将栈中的sp的值修改回s处，自行推导一下就ok。</p>
<h5 id="BIOS和DOS提供的中断例程"><a href="#BIOS和DOS提供的中断例程" class="headerlink" title="BIOS和DOS提供的中断例程"></a><strong>BIOS和DOS提供的中断例程</strong></h5><p>系统ROM中存放着一套程序，称为BIOS，除此之外还有DOS都提供了一套可以供我们调用的中断例程，不同历程有不同的中断类型码，并且还能根据传入的参数不同而实现不同的功能，也就是说同一个类型码的中断例程可以实现很多不同功能，如int 10h是BIOS提供的包含了多个和屏幕输出相关子程序的中断例程。传参数如下面例子：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">2</span> <span class="comment">;置光标</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span> <span class="comment">;第0页</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">5</span> <span class="comment">;dh中放行号</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">12</span> <span class="comment">;dl中放列号</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">10h</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>BIOS和DOS安装历程的过程是，开机后CPU一加电，自动初始化CS为0FFFFH，IP为0，而在这个地方有一个跳转指令，挑战到BIOS和系统检测初始化程序。在BIOS系统检测初始化程序中会设置中断向量表中的值。</p>
<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><h5 id="端口的概念"><a href="#端口的概念" class="headerlink" title="端口的概念"></a><strong>端口的概念</strong></h5><p>各种存储器都要和CPU的地址线，数据线，控制线相连，在CPU看来，总线就是一个由若干个存储单元构成的逻辑存储器，称之为内存地址空间。除了各种存储器，通过总线和CPU相连的还有下面三种芯片：</p>
<ul>
<li>各种接口卡（如网卡显卡）上的接口芯片，他们控制接口卡工作</li>
<li>主板上的接口芯片，CPU通过它们访问外部设备</li>
<li>其他芯片，用来存储相关系统信息，或进行相应的输入输出</li>
</ul>
<p>上面的芯片中都有一种由CPU读写的寄存器，它们都和CPU的总线相连（通过各自的芯片），CPU对他们进行读写时候都通过控制线向他们所在的芯片发出端口读写指令。</p>
<p>所以，对于CPU来说，将这些寄存器都当做端口，对他们进行统一编址，建立了一个端口地址空间，每一个端口拥有一个地址，所以CPU可以直接读取下面三个地方的数据：</p>
<ul>
<li>CPU内部的寄存器</li>
<li>内存单元</li>
<li>端口</li>
</ul>
<h5 id="端口的写"><a href="#端口的写" class="headerlink" title="端口的写"></a><strong>端口的写</strong></h5><p>因为端口所在的芯片和CPU通过总线相连，所以端口地址和内存地址一样通过地址总线传送，并且在PC系统中，CPU最多可以定位64KB个不同的端口，所以端口地址范围是0~65535。</p>
<p>对端口的读写不能使用mov,push,pop等内存读写指令，端口的读写指令只有两个：in和out分别用于从端口读取数据和往端口写入数据。</p>
<p>访问端口的步骤：</p>
<ol>
<li>CPU通过地址总线降低至信息60h发出</li>
<li>CPU通过控制线发出端口读命令，选中端口所在芯片，并通知它要从中读取数据</li>
<li>端口所在芯片将目标端口中的数据通过数据线送入CPU</li>
</ol>
<p>注：在in和out指令中，只能通过ax或al来存放从端口中读入的数据或要发送到端口中的数据，且访问8位端口时，用al，访问16位端口用ax。</p>
<p>对0~255以内的端口进行读写时：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">20h</span></span><br><span class="line"><span class="keyword">out</span> <span class="number">20h</span>,<span class="built_in">al</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>对256~65535的端口进行读写时，需要将端口号写在dx中：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">dx</span>，<span class="number">3f8h</span></span><br><span class="line"><span class="keyword">in</span> <span class="built_in">al</span>,<span class="built_in">dx</span></span><br><span class="line"><span class="keyword">out</span> <span class="built_in">dx</span>,<span class="built_in">al</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<h5 id="CMOS-RAM芯片"><a href="#CMOS-RAM芯片" class="headerlink" title="CMOS RAM芯片"></a><strong>CMOS RAM芯片</strong></h5><p>PC中有一个叫做CMOS RAM的芯片，称为CMOS，有如下特征：</p>
<ul>
<li>包含一个实时钟和一个有128个存储单元的RAM存储器（早期的计算机64个字节）</li>
<li>靠电池供电，关机后内部的实时钟仍可继续工作，RAM中的信息不丢失</li>
<li>128个字节的RAM中，内部实时钟占用0~0dh单元保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取，BIOS也提供了相关的程序可以让我们在开机时配置CMOS中的系统信息。</li>
<li>芯片内部有两个端口70h和71h，CPU通过这两个端口读写CMOS</li>
<li>70h为地址端口，存放要访问CMOS单元的地址，71h为数据端口，存放从选定的单元中读取的数据，或写入的数据。</li>
</ul>
<p>所以可以看出，想要从CMOS中读取数据，应分两步，先将单元号送入70h，然后再从71h读出对应号的数据。</p>
<h5 id="shl和shr指令"><a href="#shl和shr指令" class="headerlink" title="shl和shr指令"></a><strong>shl和shr指令</strong></h5><p>shl和shr是逻辑移位指令，shl是逻辑左移，功能为：</p>
<ol>
<li>将一个寄存器或内存单元中的数向左移位</li>
<li>将最后移出的一位写入CF</li>
<li>最低位补0</li>
</ol>
<p>如：mov al,01001000b shl al,1执行结束后(al)=10010000b，CF=0。</p>
<p>注：如果移动位数大于1，那么必须将移动位数写在cl中。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">01010001b</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">3</span></span><br><span class="line"><span class="keyword">shl</span> <span class="built_in">al</span>,<span class="built_in">cl</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>执行后(al)=10001000b,最后移出的一位是0，所以CF=0。可以看出左移操作相当于x=x*2。</p>
<p>右移shr同理，最高位用0补充，移出的写入CF，若移动位数大于1，也要写在cl中，相当于x=x/2</p>
<p>在CMOS中存放着当前时间的年月日时分秒，分别存在下面的单元内：</p>
<table>
<thead>
<tr>
<th>秒</th>
<th>分</th>
<th>时</th>
<th>日</th>
<th>月</th>
<th>年</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>2</td>
<td>4</td>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
</tbody></table>
<p>每个信息使用一个字节存放，以BCD码的形式，BCD码是对0-9这几个数字使用二进制表示，如：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>0000</td>
<td>0001</td>
<td>0010</td>
<td>0011</td>
<td>0100</td>
<td>0101</td>
<td>0110</td>
<td>0111</td>
<td>1000</td>
<td>1001</td>
</tr>
</tbody></table>
<p>如果要表示一个两位数如13，就是一个字节高四位是十位1的BCD码，低四位是个位3的BCD码，表示为00010011b。下面程序获取当前月份：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">8</span></span><br><span class="line"><span class="keyword">out</span> <span class="number">70h</span>,<span class="built_in">al</span>   <span class="comment">;要从8号单元读取数据，所以先将8号单元送入70h端口</span></span><br><span class="line"><span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">71h</span>    <span class="comment">;从71h端口拿数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>,<span class="built_in">al</span>    <span class="comment">;复制一下</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">4</span>     </span><br><span class="line"><span class="keyword">shr</span> <span class="number">ah</span>,<span class="built_in">cl</span>    <span class="comment">;ah右移四位，ah里面的就是月份的十位</span></span><br><span class="line"><span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">00001111b</span>  <span class="comment">;al里面剩下的就是月份的个位</span></span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<h3 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h3><h5 id="接口芯片和端口"><a href="#接口芯片和端口" class="headerlink" title="接口芯片和端口"></a><strong>接口芯片和端口</strong></h5><p>CPU除了需要拥有运算的能力，还要拥有I/O（输入输出）能力，我们键入一个字母，要能处理，所以我们需要面对的是：外部设备随时的输入和CPU何处得到外部设备的输入。</p>
<p>外部设备拥有自己的芯片连接到主板上，这些芯片内部由若干寄存器，而CPU将这些寄存器当做端口访问，外设的输入或CPU向外设输出都是送给对应的端口然后再由芯片处理送给目标（CPU或外设）。</p>
<h5 id="外中断-1"><a href="#外中断-1" class="headerlink" title="外中断"></a><strong>外中断</strong></h5><p>CPU提供外中断来处理这些如随时可能出现的来自外设的输入，在PC系统中，外中断源有以下两类：</p>
<p>可屏蔽中断：CPU可以不响应的外部中断，CPU是否响应看标志寄存器IF的设置，如果IF=1，CPU执行完当前指令后响应中断，如果IF=0，则不响应。可屏蔽中断的执行步骤和内部中断类似：</p>
<ol>
<li>获取中断类型码n（从外部通过总线输入）</li>
<li>标志寄存器入栈，IF=0，TF=0</li>
<li>CS，IP入栈</li>
<li><code>(IP)=(n*4)，(CS)=(n*4+2)</code></li>
</ol>
<p>可见，将IF置零的原因是以免在处理中断程序的时候再发生中断。当然我们也可以选择处理，下面两个指令可以改变IF的值：sti，设置IF=1，cli，设置IF=0。</p>
<p>不可屏蔽中断：CPU必须响应的外部中断，CPU检测到不可屏蔽中断后执行完当前指令立即响应中断。8086CPU中不可屏蔽中断的中断类型码固定位2，所以中断过程中不需要获取中断类型码，步骤：</p>
<ol>
<li>标志寄存器入栈，IF=0，TF=0</li>
<li>CS，IP入栈</li>
<li>(IP)=(8),(CS)=(0AH)</li>
</ol>
<p>几乎所有由外设引发的外中断都是可屏蔽中断，如键盘输入，不可屏蔽中断通常是在系统中又必须处理的紧急情况发生时通知CPU的中断信息。</p>
<h5 id="PC键盘处理过程"><a href="#PC键盘处理过程" class="headerlink" title="PC键盘处理过程"></a><strong>PC键盘处理过程</strong></h5><p>键盘上每个按键都相当于一个开关，按下就是开关接通，抬起就是开关断开。键盘上有一个芯片对键盘中每一个键盘的状态进行扫描，开关按下生成一个扫描码——通码，记录按下的按键位置，开关抬起也会产生一个扫描——断码，码记录松开的位置，都是送入60h端口。通码的第7位为0，断码第7位为1，也就是说断码=通码+80h。P247表。</p>
<p>当键盘输入送达60h时，相关新品就会向CPU发送中断类型码为9的可屏蔽中断信息。CPU检测到该中断信息之后，如果IF=1，响应中断，引发中断过程并执行int9的中断例程。BIOS中int9的中断程序用来进行基本的键盘输入处理，步骤如下：</p>
<ol>
<li>读出60h的扫描码</li>
<li>如果是字符的扫描码，将对应的字符的ASCII吗存入内存中的BIOS键盘缓冲区，如果是控制键（Ctrl）和切换键（CapsLock）扫描码，则将其转换为状态字（二进制位记录控制键和切换键状态的字节）写入内存中的存储状态字节的单元。</li>
<li>对键盘系统进行相关控制，如向新平发出应答</li>
</ol>
<p>BIOS中键盘缓冲区能存储15个键盘输入，每个键盘输入两字节，高位存放扫描码，低位存放字符。此外，0040:17单元存放键盘状态字节，记录了控制键和切换键的状态，记录信息如下：</p>
<table>
<thead>
<tr>
<th>位</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>右shift，1表示按下</td>
</tr>
<tr>
<td>1</td>
<td>左shift，1按下</td>
</tr>
<tr>
<td>2</td>
<td>Ctrl，1按下</td>
</tr>
<tr>
<td>3</td>
<td>Alt，1按下</td>
</tr>
<tr>
<td>4</td>
<td>ScrollLock状态，1表示指示灯亮</td>
</tr>
<tr>
<td>5</td>
<td>NumLock状态，1表示小键盘输入的是数字</td>
</tr>
<tr>
<td>6</td>
<td>CapsLock状态，1表示大写字母</td>
</tr>
<tr>
<td>7</td>
<td>Insert状态，1表示处于删除状态</td>
</tr>
</tbody></table>
<p>可以看书P276的一个改写int 9的中断例程。</p>
<h3 id="直接定址表"><a href="#直接定址表" class="headerlink" title="直接定址表"></a>直接定址表</h3><h5 id="描述单元长度的标号"><a href="#描述单元长度的标号" class="headerlink" title="描述单元长度的标号"></a><strong>描述单元长度的标号</strong></h5><p>我们可以使用下面的标号来表示数据的开始：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">code segment</span><br><span class="line">a:db <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">b:dw <span class="number">0</span></span><br><span class="line">···</span><br><span class="line">code ends</span><br><span class="line">···</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>a，b都是代表对应数据的起始地址，但并不能判断数据的长度或类型。下面一段程序将a中的8个数累加存入b中：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">a <span class="built_in">db</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">b <span class="built_in">dw</span> <span class="number">0</span></span><br><span class="line">start <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">s:</span><span class="keyword">mov</span> <span class="built_in">al</span>,a[<span class="built_in">si</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">add</span> b,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line"><span class="keyword">loop</span> s</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<p>code段中a和b后并没有”:”号，这种写法同时描述内存地址和单元长度的标号。a描述了地址code:0和从这个地址开始后的内存单元都是字节单元，而b描述了地址code:8和从这个地址开始以后的内存单元都是字单元。所以b相当于CS:[8]，a[si]相当于CS:0[si]，使用这种标号，我们可以间接地访问内存数据。</p>
<h5 id="其它段中使用数据标号"><a href="#其它段中使用数据标号" class="headerlink" title="其它段中使用数据标号"></a><strong>其它段中使用数据标号</strong></h5><p>刚说的第一种标号即加”:”号的标号，只能使用在代码段中，不能在其他段中使用。如果想要在其它段中（如data段）使用标号可以使用第二种：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">a <span class="built_in">db</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">b <span class="built_in">dw</span> <span class="number">0</span></span><br><span class="line">data ends</span><br><span class="line">···</span><br><span class="line">start <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,a[<span class="built_in">si</span>]</span><br><span class="line">···</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<p>如果想在代码段中直接使用数据标号访问数据，需要使用assume伪指令将标号所在段和一个寄存器联系起来，是让寄存器明白，我们要访问的数据在ds指向的段中，但编译器并不会真的将段地址存入ds中，我们做了如下假设之后，编译器在编译的时候就会默认ds中已经存放了data的地址，如下面的编译例子：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,a[<span class="built_in">si</span>]</span><br><span class="line">编译为：<span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>+<span class="number">0</span>]</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>可以看出编译器默认了a[si]在ds所在的段中。所以我们需要手工指定ds指向data：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>也可以这么使用：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">b dw <span class="number">0</span></span><br><span class="line">c a,b</span><br><span class="line">data ends</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>c处存放的是a和b的偏移地址，相当于c dw offset a,offset b。同理c dd a,b相当于c dw offset a,seg a,offset b,seg b即存的是a和b的段地址和偏移地址。</p>
<h5 id="直接定址表-1"><a href="#直接定址表-1" class="headerlink" title="直接定址表"></a><strong>直接定址表</strong></h5><p>使用查表的方法编写相关程序，如输出一个字节型数据的16进制形式（子程序）：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">showbyte <span class="keyword">jmp</span> short show</span><br><span class="line">table <span class="built_in">db</span> <span class="string">'0123456789ABCDEF'</span></span><br><span class="line"><span class="symbol">show:</span><span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>,<span class="built_in">al</span></span><br><span class="line">she <span class="number">ah</span>,<span class="number">1</span></span><br><span class="line">she <span class="number">ah</span>,<span class="number">1</span></span><br><span class="line">she <span class="number">ah</span>,<span class="number">1</span></span><br><span class="line">she <span class="number">ah</span>,<span class="number">1</span> <span class="comment">;右移四位，位移子程序限制使用的寄存器数，只能这么移</span></span><br><span class="line"><span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">00001111b</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="built_in">al</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>,table[<span class="built_in">bx</span>]  <span class="comment">;高四位作为相对于table的偏移，取得对应字符</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0b800h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">bx</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="number">160</span>*<span class="number">12</span>+<span class="number">40</span>*<span class="number">2</span>],<span class="number">ah</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="built_in">al</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,table[<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="number">160</span>*<span class="number">12</span>+<span class="number">40</span>*<span class="number">2</span>+<span class="number">2</span>],<span class="built_in">al</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line"><span class="keyword">ret</span></span><br><span class="line"><span class="number">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure>

<p>可见我们直接使用需要的数值和地址的映射关系来寻找需要的数据。</p>
<h5 id="程序入口地址的直接定址表"><a href="#程序入口地址的直接定址表" class="headerlink" title="程序入口地址的直接定址表"></a><strong>程序入口地址的直接定址表</strong></h5><p>可以看书P296的例程，主要思想是，编写多个子程序实现不同功能，每个子程序有自己的标号，如sub1，sub2···等。将它们存在一个表中：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">table dw <span class="keyword">sub</span><span class="number">1</span>,<span class="keyword">sub</span><span class="number">2</span>,<span class="keyword">sub</span><span class="number">3</span>,<span class="keyword">sub</span><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>然后按照之前的方法使用如：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">setscreen:</span><span class="keyword">jmp</span> short set</span><br><span class="line">table <span class="built_in">dw</span> sub1,sub2,sub3,sub4</span><br><span class="line"><span class="symbol">set:</span><span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line"><span class="keyword">cmp</span> <span class="number">ah</span>,<span class="number">3</span></span><br><span class="line"><span class="keyword">ja</span> sret</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="number">ah</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>,<span class="built_in">bx</span></span><br><span class="line"><span class="keyword">call</span> <span class="built_in">word</span> <span class="built_in">ptr</span> table[<span class="built_in">bx</span>]</span><br><span class="line"><span class="symbol">sret:</span><span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line"><span class="keyword">ret</span></span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<h3 id="使用BIOS进行键盘输入和磁盘读写"><a href="#使用BIOS进行键盘输入和磁盘读写" class="headerlink" title="使用BIOS进行键盘输入和磁盘读写"></a>使用BIOS进行键盘输入和磁盘读写</h3><h5 id="int-9中断例程对键盘输入的处理"><a href="#int-9中断例程对键盘输入的处理" class="headerlink" title="int 9中断例程对键盘输入的处理"></a><strong>int 9中断例程对键盘输入的处理</strong></h5><p>键盘处理依次按下A,B,C,D,E,shift_A,A的过程：</p>
<p>我们知道，键盘有16字的缓冲区，可以存放15个按键的扫描码和对应的ASCII码值，如下：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>我们按下A时，引发键盘中断，CPU执行int 9中断例程，从60h端口读出A键通码，然后检测状态字，看是否有控制键或切换键按下，发现没有，将A的扫描码1eh和对应的ASCII码’a’61h写在缓冲区：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string">1e61</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>然后BCDE同理：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string">1e61</span>|<span class="string">3062</span>|<span class="string">2e63</span>|<span class="string">2064</span>|<span class="string">1265</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>在按下shift之后引发键盘中断，int 9程序接受了shift的通码之后设置0040:17处状态字第一位为1，表示左shift按下，接下来按A间，引发中断，int 9中断例程从60h端口督导通码之后检测状态字，发现左shift被按下，于是将A的键盘扫描码1eh和’A’的ASCII41h写入缓冲区：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string">1e61</span>|<span class="string">3062</span>|<span class="string">2e63</span>|<span class="string">2064</span>|<span class="string">1265</span>|<span class="string">1e41</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>松开shift，0040:17第一位变回0,之后又按下A和之前一样。</p>
<h5 id="int-16h读取键盘缓冲区"><a href="#int-16h读取键盘缓冲区" class="headerlink" title="int 16h读取键盘缓冲区"></a><strong>int 16h读取键盘缓冲区</strong></h5><p>int 16h可以供程序员调用，编号为0的功能是从键盘缓冲区读一个键盘输入，(ah)=扫描码，(al)=ascii码。如：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ah,0</span><br><span class="line">int 16h</span><br><span class="line">|<span class="string">3062</span>|<span class="string">2e63</span>|<span class="string">2064</span>|<span class="string">1265</span>|<span class="string">1e41</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|<span class="string">	</span>|</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>执行后，缓冲区第一个没了，然后ah中是1eh，al中是61h。如果缓冲区为空的时候执行，那么会循环等待知道缓冲区有数据，所以int 16h的0号功能的步骤是：</p>
<ol>
<li>检测键盘缓冲区是否有数据</li>
<li>没有则继续1</li>
<li>读取第一个单元的键盘输入</li>
<li>扫描码送ah，ascii码送al</li>
</ol>
<h5 id="int-13h读写磁盘"><a href="#int-13h读写磁盘" class="headerlink" title="int 13h读写磁盘"></a><strong>int 13h读写磁盘</strong></h5><p>3.5寸软盘分为上下两面，每面80个磁道，每个磁道18个扇区，每个扇区512字节，共约1.44MB。磁盘的实际访问时磁盘控制器进行的，我们通过控制磁盘控制器来控制磁盘，只能以扇区为单位读写磁盘，每次需要给出面号，磁道号，和扇区号，面号和磁道号从0开始，扇区号从1开始。BIOS提供int 13h来实现访问磁盘，读取0面0道1扇区的内容到0:200的程序：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">200h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">1</span>   <span class="comment">;读取的扇区数</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span>   <span class="comment">;磁道号</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">1</span>   <span class="comment">;扇区号</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">0</span>   <span class="comment">;驱动器号，0开始，0软驱A，1软驱B，磁盘从80h开始，80h硬盘C，81h硬盘D</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">0</span>   <span class="comment">;磁头号（软盘面号）</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">2</span>   <span class="comment">;13h的功能号，2表示读扇区</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">13h</span></span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<p>es:bx指向接收数据的内存区。操作成功(ah)=0,(al)=读入的扇区数，操作失败(ah)=错误代码。将0:200的数据写入0面0道1扇区：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">miv <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">200h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">1</span>   <span class="comment">;读取的扇区数</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span>   <span class="comment">;磁道号</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">1</span>   <span class="comment">;扇区号</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">0</span>   <span class="comment">;驱动器号</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">0</span>   <span class="comment">;磁头号（软盘面号）</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">3</span>   <span class="comment">;13h的功能号，3表示写扇区</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">13h</span></span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<p>es:bx指向写入磁盘的数据，操作成功(ah)=0,(al)=写入的扇区数，操作失败(ah)=错误代码</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/29/C++%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/29/C++%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F/" class="post-title-link" itemprop="url">C++编译产生文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-29 20:57:56 / 修改时间：21:00:13" itemprop="dateCreated datePublished" datetime="2020-12-29T20:57:56+08:00">2020-12-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>C++编译 （.obj, .lib, .dll, .exe的关系）</p>
<h2 id="一、总体介绍："><a href="#一、总体介绍：" class="headerlink" title="一、总体介绍："></a>一、总体介绍：</h2><p>c++程序在编译后,在目标路径下会生成多个文件：</p>
<p>Debug文件夹(<em>.exe,</em>.ilk,<em>.obj,</em>.pch,<em>.pdb,</em>.idb,<em>,pdb),</em>.cpp,<em>.dsp,</em>.ncb,*.plg</p>
<p>*.exe:是生成的可执行文件</p>
<p>*.ilk:当选定渐增型编译连接时，连接器自动生成ILK文件，记录连接信息</p>
<p>*.obj:是目标文件,源程序编译后的产物</p>
<p>*.pch:全称是PreCompiled Header，就是预先编译好的头文件</p>
<p>*.idb:文件保存的信息,使编译器在重新编译的时候只重编译最新改动过的函数和只对最新类定义改动过的源文件进行重编译，以提高编译速度</p>
<p>*.pdb:全称是Program DataBase，即程序数据库文件，用来记录调试信息</p>
<p>*.dsp:(全称是Developer Studio Project)也是一个配置文件</p>
<p>*.ncb:(全称No Compile Browser)的缩写，其中存放了供ClassView、WizardBar和Component Gallery使用的信息，由VC开发环境自动生成</p>
<p>*.plg:实际上是一个超文本文件，可以用Internet Explorer打开，记录了Build的过程</p>
<p>*.cpp:就是C++源代码文件.</p>
<h2 id="二、具体介绍："><a href="#二、具体介绍：" class="headerlink" title="二、具体介绍："></a>二、具体介绍：</h2><p>lib是和dll对应的。</p>
<p>lib是静态的库文件，dll是动态的库文件。</p>
<p>所谓静态就是link的时候把里面需要的东西抽取出来安排到你的exe文件中，以后运行   你的exe的时候不再需要lib。</p>
<p>所谓动态就是exe运行的时候依赖于dll里面提供的功能，没有这个dll，你的exe无法运行。</p>
<p>lib,   dll,   exe都算是最终的目标文件，是最终产物。而c/c++属于源代码。源代码和最终目标文件中过渡的就是中间代码obj，实际上之所以需要中间代码，是你不可能一次得到目标文件。</p>
<p>比如说一个exe需要很多的cpp文件生成。而编译器一次只能编译一个cpp文件。</p>
<p>这样编译器编译好一个cpp以后会将其编译成obj，当所有必须要的cpp都编译成obj以后，再统一link成所需要exe，应该说缺少任意一个obj都会导致exe的链接失败。</p>
<p>obj里存的是编译后的代码跟数据，并且有名称，所以在连接时会出现未解决的外部符号一说。当连成exe后便不存在名称的概念了，只有地址。lib就是一堆obj的组合。</p>
<p>2.理论上可以，但实际中通常用lib。</p>
<p>3.编译器会默认链接一些常用的库，其它的需要你自己指定。</p>
<h2 id="三、附上lib和DLL的区别"><a href="#三、附上lib和DLL的区别" class="headerlink" title="三、附上lib和DLL的区别"></a>三、附上lib和DLL的区别</h2><p>(1)lib是编译时需要的，dll是运行时需要的。 </p>
<p>如果要完成源代码的编译，有lib就够了。 </p>
<p>如果也使动态连接的程序运行起来，有dll就够了。 </p>
<p>在开发和调试阶段，当然最好都有。 </p>
<p>(2)一般的动态库程序有lib文件和dll文件。</p>
<p>lib文件是必须在编译期就连接到应用程序中的，而dll文件是运行期才会被调用的。如果有dll文件，那么对应的lib文件一般是一些索引信息，具体的实现在dll文件中。</p>
<p>如果只有lib文件，那么这个lib文件是静态编译出来的，索引和实现都在其中。静态编译的lib文件有好处：给用户安装时就不需要再挂动态库了。</p>
<p>但也有缺点，就是导致应用程序比较大，而且失去了动态库的灵活性，在版本升级时，同时要发布新的应用程序才行。 </p>
<p>(3)在动态库的情况下，有两个文件，一个是引入库（.LIB）文件，一个是DLL文件。</p>
<p>引入库文件包含被DLL导出的函数的名称和位置，DLL包含实际的函数和数据，应用程序使用LIB文件链接到所需要使用的DLL文件，库中的函数和数据并不复制到可执行文件中，因此在应用程序的可执行文件中，存放的不是被调用的函数代码，而是DLL中所要调用的函数的内存地址。</p>
<p>这样当一个或多个应用程序运行是再把程序代码和被调用的函数代码链接起来，从而节省了内存资源。</p>
<p>从上面的说明可以看出，DLL和.LIB文件必须随应用程序一起发行，否则应用程序将会产生错误。</p>
<h2 id="四、c-obj文件bai与exe文件的区别："><a href="#四、c-obj文件bai与exe文件的区别：" class="headerlink" title="四、c++ obj文件bai与exe文件的区别："></a>四、c++ obj文件bai与exe文件的区别：</h2><h3 id="一、作用的区别"><a href="#一、作用的区别" class="headerlink" title="一、作用的区别"></a>一、作用的区别</h3><p>obj文件当前源代zhi码编译成二dao进制目标文zhuan件（.obj文件）</p>
<p>exe文件将生成的shu.obj文件与库文件.lib等文件链接，生成可执行文件（.exe文件）。</p>
<h3 id="二、给出文件地址的区别"><a href="#二、给出文件地址的区别" class="headerlink" title="二、给出文件地址的区别"></a>二、给出文件地址的区别</h3><p>obj文件给出了程序的相对地址。</p>
<p>exe文件给出了程序的绝对地址。</p>
<h3 id="三、编译生成文件的区别"><a href="#三、编译生成文件的区别" class="headerlink" title="三、编译生成文件的区别"></a>三、编译生成文件的区别</h3><p>obj文件由.cpp的源程序经过编译生成机器可理解执行的二进制文件。</p>
<p>exe文件经过链接器同cpp的标准库以及其他用户自己的库进行连接，多个obj文件生成一个exe。</p>
<h3 id="四、类型的区别"><a href="#四、类型的区别" class="headerlink" title="四、类型的区别"></a>四、类型的区别</h3><p>obj文件是3D模型文件格式，属于编译类，结构不完整，可以看成是exe的一部分。</p>
<p>exe文件是可执行文件，属于链接（link）类，程序并非只作简单的拷贝与组合。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/20/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/page/22/">22</a><span class="space">&hellip;</span><a class="page-number" href="/page/48/">48</a><a class="extend next" rel="next" href="/page/22/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">匡俊桦</p>
  <div class="site-description" itemprop="description">回忆的沙漏将曾经屈指可数的日子渐渐淡去</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">238</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">匡俊桦</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">29:11</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
