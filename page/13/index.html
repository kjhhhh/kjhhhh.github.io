<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/13/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="KJH">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day21%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day21%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记21</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:11:42" itemprop="dateModified" datetime="2020-12-23T23:11:42+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、异常概述和继承体系<br>2、异常原因以及处理方式<br>3、运行时期异常<br>4、方法重写的异常处理<br>5、Throwable类常见方法<br>6、自定义异常</p>
<p>第一节课 异常的继续体系和异常处理(46:21)<br>###01异常的概述.avi(01:43)<br>###02异常的继续体系和错误的区别.avi(07:56)<br>###03异常对象的产生原因和处理方式.avi(13:25)<br>###04方法内部抛出对象throw关键字.avi(13:38)<br>###05方法声明异常关键字throws.avi(09:37)</p>
<p>第二节课 异常处理方式讲解(42:37)<br>###06(异常)try…catch异常处理.avi(19:50)<br>###07(异常)多catch处理.avi(02:46)<br>###08(异常)多catch处理细节.avi(10:44)<br>###09(异常)finally代码块.avi(04:21)<br>###10(异常)调用抛出异常方法try和throws处理方式.avi(04:54)</p>
<p>第三节课 运行时期异常和方法重写的异常处理(39:45)<br>###11(异常)运行时期异常的特点.avi(11:00)<br>###12(异常)运行异常的案例.avi(08:53)<br>###13(异常)方法重写时候异常的处理.avi(11:6)<br>###14(异常)Throwable类方法.avi(08:45)</p>
<p>第四节课 自定义异常与总结(13:32)<br>###15(异常)自定义异常.avi(13:32)</p>
<p>============上面的内容,方便我们只做ppt,word教案以及书写下面的简要的笔记=================</p>
<p>=======================第一节课开始=============================================</p>
<p>###01异常的概述<br>    * A: 异常的概述<br>        * a:什么是异常<br>            * Java代码在运行时期发生的问题就是异常。<br>        * b:异常类<br>            * 在Java中，把异常信息封装成了一个类。<br>            * 当出现了问题时，就会创建异常类对象并抛出异常相关的信息（如异常出现的位置、原因等）。<br>        * c：我们见过的异常：数组角标越界异常ArrayIndexOutOfBoundsException,空指针异常NullPointerException</p>
<p>###02异常的继续体系和错误的区别<br>    * A: 异常的继承体系<br>        Throwable: 它是所有错误与异常的超类（祖宗类）<br>            |- Error 错误<br>            |- Exception 编译期异常,进行编译JAVA程序时出现的问题<br>                |- RuntimeException 运行期异常, JAVA程序运行过程中出现的问题<br>    * B：异常与错误的区别<br>        * a：异常<br>            * 指程序在编译、运行期间发生了某种异常(XxxException)，我们可以对异常进行具体的处理。<br>            * 若不处理异常，程序将会结束运行。<br>            * 案例演示：<br>                public static void main(String[] args) {<br>                    int[] arr = new int[3];<br>                    System.out.println(arr[0]);<br>                    System.out.println(arr[3]);<br>                    // 该句运行时发生了数组索引越界异常ArrayIndexOutOfBoundsException，<br>                    // 由于没有处理异常，导致程序无法继续执行，程序结束。<br>                    System.out.println(“over”); // 由于上面代码发生了异常，此句代码不会执行<br>                }</p>
<pre><code>* b：错误
    * 指程序在运行期间发生了某种错误(XxxError)，Error错误通常没有具体的处理方式，程序将会结束运行。
    * Error错误的发生往往都是系统级别的问题，都是jvm所在系统发生的，并反馈给jvm的。
    * 我们无法针对处理，只能修正代码。
    * 案例演示：
        public static void main(String[] args) {
            int[] arr = new int[1024*1024*100];
            //该句运行时发生了内存溢出错误OutOfMemoryError，开辟了过大的数组空间，
            //导致JVM在分配数组空间时超出了JVM内存空间，直接发生错误。
        }</code></pre><p>###03异常对象的产生原因和处理方式<br>    * A: 异常对象的产生原因<br>        * 案例代码：<br>            * 工具类<br>            class ArrayTools{<br>                //对给定的数组通过给定的角标获取元素。<br>                public static int getElement(int[] arr,int index)    {<br>                    int element = arr[index];<br>                    return element;<br>                }<br>            }<br>            * 测试类<br>            class ExceptionDemo2 {<br>                public static void main(String[] args)     {<br>                    int[] arr = {34,12,67};<br>                    int num = ArrayTools.getElement(arr,4)<br>                    System.out.println(“num=”+num);<br>                    System.out.println(“over”);<br>                }<br>            }<br>        * 原因分析：<br>            * a: 由于没找到4索引，导致运行时发生了异常。这个异常JVM认识：ArrayIndexOutOfBoundsException。<br>                这个异常Java本身有描述：异常的名称、异常的内容、异常的产生位置。<br>                java将这些信息直接封装到异常对象中。new ArrayIndexOutOfBoundsException(4);<br>            * b：throw new ArrayIndexOutOfBoundsException(4);产生异常对象。JVM将产生的异常抛给调用者main()方法。<br>            * c：main()方法接收到了数组索引越界异常对象。<br>                由于main()方法并没有进行处理异常，main()方法就会继续把异常抛给调用者JVM。<br>                当JVM收到异常后，将异常对象中的名称、异常内容、位置都显示在就控制台上。同时让程序立刻终止。<br>    * B：异常的处理方式<br>        * a：JVM的默认处理方式<br>            * 把异常的名称,原因,位置等信息输出在控制台，同时会结束程序。<br>            * 一旦有异常发生，其后来的代码不能继续执行。<br>        * b：解决程序中异常的手动方式<br>            * a)：编写处理代码 try…catch…finally<br>            * b)：抛出 throws</p>
<p>###04方法内部抛出对象throw关键字<br>    在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。<br>    * A: 什么时候使用throw关键字？<br>        * 当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，<br>          数据若不合法，就应该告诉调用者，传递合法的数据进来。<br>          这时需要使用抛出异常的方式来告诉调用者。<br>    * B: 使用throw关键字具体操作<br>        * a: 创建一个异常对象。封装一些提示信息(信息可以自己编写)。<br>        * b: 通过关键字throw将这个异常对象告知给调用者。throw 异常对象；<br>        throw 用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。<br>    * C: throw关键字使用格式<br>        * throw new 异常类名(参数);<br>        * 例如：<br>            throw new NullPointerException(“要访问的arr数组不存在”);<br>            throw new ArrayIndexOutOfBoundsException(“该索引在数组中不存在，已超出范围”);<br>    * D：案例演示<br>        * throw的使用</p>
<p>###05方法声明异常关键字throws<br>    * A: 声明<br>        * 将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。<br>    * B: 声明异常格式<br>        * 修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2… {   }<br>    * C：注意事项：<br>        * throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。<br>    * D：代码演示：<br>        * 多个异常的处理</p>
<p>​<br>​<br>==============================第二节课开始====================================        </p>
<p>​                </p>
<p>###06try…catch异常处理<br>    * A: 捕获<br>        * Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理<br>    * B: 捕获异常格式<br>        try {<br>            //需要被检测的语句。<br>        }<br>        catch(异常类 变量) { //参数。<br>            //异常的处理语句。<br>        }<br>        finally {<br>            //一定会被执行的语句。<br>        }<br>    * C: 格式说明<br>        * a: try<br>            * 该代码块中编写可能产生异常的代码。<br>        * b: catch<br>            * 用来进行某种异常的捕获，实现对捕获到的异常进行处理。<br>        * c: finally：<br>            * 有一些特定的代码无论异常是否发生，都需要执行。<br>            * 另外，因为异常会引发程序跳转，导致有些语句执行不到。<br>            * 而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。<br>        * d：try…catch…处理掉异常后，程序可以继续执行<br>    * D：案例演示<br>        * 捕获异常格式</p>
<p>###07多catch处理<br>    * A：一个try 多个catch组合<br>        * 对代码进行异常检测，并对检测的异常传递给catch处理。对每种异常信息进行不同的捕获处理。<br>    * B：多catch处理的格式<br>        void show(){ //不用throws<br>            try{<br>                throw new Exception();//产生异常，直接捕获处理<br>            }catch(XxxException e){<br>                //处理方式<br>            }catch(YyyException e){<br>                //处理方式<br>            }catch(ZzzException e){<br>                //处理方式<br>            }<br>        }<br>        注意事项：在捕获异常处理中，变量也是有作用域的，如可以定义多个catch中异常变量名为e。</p>
<p>###08多catch处理细节<br>    * A：细节：多个catch小括号中，写的是异常类的类名，有没有顺序的概念？<br>        * 有顺序关系。<br>    * B：平级异常：<br>        * 抛出的异常类之间,没有继承关系,没有顺序<br>            NullPointerException extends RuntimeException<br>            NoSuchElementException extends RuntimeException<br>            ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException extends RuntimeException<br>    * C：上下级关系的异常<br>        * 越高级的父类,越写在下面<br>            NullPointerException extends RuntimeException extends Exception</p>
<p>###09finally代码块<br>    * A: finally的特点<br>        * 被finally控制的语句体一定会执行<br>    * B：finally的作用<br>        * finally,无论程序是否有异常出现,程序必须执行释放资源在<br>          如：IO流操作和数据库操作中会见到</p>
<p>###10调用抛出异常方法try和throws处理方式<br>    * A: 在实际开发中使用哪种异常处理方式呢？<br>        * 能自己处理的尽量自己处理。(建议用try…catch)</p>
<p>​<br>==============================第三节课开始====================================<br>​<br>###11运行时期异常的特点<br>    * A: 运行时期异常的概述:<br>        * RuntimeException和他的所有子类异常,都属于运行时期异常。<br>            NullPointerException,ArrayIndexOutOfBoundsException等都属于运行时期异常.<br>    * B：运行时期异常的特点<br>        * a：方法中抛出运行时期异常,方法定义中无需throws声明,调用者也无需处理此异常。<br>        * b：运行时期异常一旦发生,需要程序人员修改源代码。<br>        设计原因:<br>            运行异常,不能发生,但是如果发生了,程序人员停止程序修改源代码<br>            运行异常: 一旦发生,不要处理,请你修改源代码,运行异常一旦发生,后面的代码没有执行的意义</p>
<p>###12运行异常的案例<br>    * A: 计算圆的面积案例<br>        定义方法,计算圆形的面积<br>        传递参数0,或者负数,计算的时候没有问题<br>        但是,违反了真实情况<br>        参数小于=0, 停止程序,不要在计算了<br>    * B：数组索引越界案例<br>        使用数组中不存在的索引<br>        public class RuntimeExceptionDemo {<br>            public static void main(String[] args) {<br>                    double d = getArea(1);<br>                    System.out.println(d);<br>            }</p>
<pre><code>    /*
     *  定义方法,计算圆形的面积
     *  传递参数0,或者负数,计算的时候没有问题
     *  但是,违反了真实情况
     *  参数小于=0, 停止程序,不要在计算了
     */
    public static double getArea(double r){
        if(r &lt;= 0)
            throw new RuntimeException(&quot;圆形不存在&quot;);
        return r*r*Math.PI;
    }

    public static void function(){
        int[] arr = {1,2,3};
        //对数组的5索引进行判断,如果5索引大于100,请将5索引上的数据/2,否则除以3
        //索引根本就没有
        if(arr[5] &gt; 100){
            arr[5] = arr[5]/2;
        }else{
            arr[5] = arr[5]/3;
        }
}</code></pre><p>###13方法重写时候异常的处理<br>    * A：方法重写时候异常的处理<br>        * a：子类覆盖父类方法时，如果父类的方法声明异常，子类只能声明父类异常或者该异常的子类，或者不声明。<br>            例如：<br>            class Fu {<br>                public void method () throws RuntimeException {<br>                }<br>            }<br>            class Zi extends Fu {<br>                public void method() throws RuntimeException { }  //抛出父类一样的异常<br>                //public void method() throws NullPointerException{ } //抛出父类子异常<br>            }<br>        * b：当父类方法声明多个异常时，子类覆盖时只能声明多个异常的子集。<br>            例如：<br>            class Fu {<br>                public void method () throws NullPointerException, ClassCastException{<br>                }<br>            }<br>            class Zi extends Fu {<br>                public void method()throws NullPointerException, ClassCastException { }<br>                public void method() throws NullPointerException{ } //抛出父类异常中的一部分<br>                public void method() throws ClassCastException { } //抛出父类异常中的一部分<br>            }<br>        * c：当被覆盖的方法没有异常声明时，子类覆盖时无法声明异常的。<br>            例如：<br>            class Fu {<br>                public void method (){<br>                }<br>            }<br>            class Zi extends Fu {<br>                public void method() throws Exception { }//错误的方式<br>            }<br>    * B：问题：父类中会存在下列这种情况，接口也有这种情况。<br>                接口中没有声明异常，而实现的子类覆盖方法时发生了异常，怎么办？<br>         回答：无法进行throws声明，只能catch的捕获。<br>                万一问题处理不了呢？catch中继续throw抛出，但是只能将异常转换成RuntimeException子类抛出。</p>
<p>###14Throwable类方法<br>    * A: 常见方法<br>        * a：getMessage()方法<br>            返回该异常的详细信息字符串，即异常提示信息<br>        * b：toString()方法<br>            返回该异常的名称与详细信息字符串<br>        * c：printStackTrace()方法<br>            在控制台输出该异常的名称与详细信息字符串、异常出现的代码位置<br>    * B：案例演示<br>        异常的常用方法代码演示<br>            try {<br>                Person p= null;<br>                if (p==null) {<br>                    throw new NullPointerException(“出现空指针异常了，请检查对象是否为null”);<br>                }<br>            } catch (NullPointerException e) {<br>                String message = e.getMesage();<br>                System.out.println(message ); </p>
<pre><code>    String result = e.toString();
    System.out.println(result);    

    e.printStackTrace(); 
}</code></pre><p>​<br>​<br>======================第四节课开始=========</p>
<p>###15自定义异常<br>    * A: 自定义异常的定义<br>        * a：通过阅读源码，发现规律：<br>            每个异常中都调用了父类的构造方法，把异常描述信息传递给了父类，让父类帮我们进行异常信息的封装。<br>        * b：格式：<br>            Class 异常名 extends Exception{ //或继承RuntimeException<br>                public 异常名(){<br>                }<br>                public 异常名(String s){<br>                    super(s);<br>                }<br>            }    </p>
<pre><code>    * c：自定义异常继承Exception演示
    * d：自定义异常继承RuntimeException演示
* B：自定义异常的练习
    在Person类的有参数构造方法中，进行年龄范围的判断，
    若年龄为负数或大于200岁，则抛出NoAgeException异常，异常提示信息“年龄数值非法”。
    要求：在测试类中，调用有参数构造方法，完成Person对象创建，并进行异常的处理。

* C：关于构造方法抛出异常总结
    构造函数到底抛出这个NoAgeException是继承Exception呢？还是继承RuntimeException呢？
    * a：继承Exception，必须要throws声明，一声明就告知调用者进行捕获，一旦问题处理了调用者的程序会继续执行。
    * b：继承RuntimeExcpetion,不需要throws声明的，这时调用是不需要编写捕获代码的，因为调用根本就不知道有问题。
        一旦发生NoAgeException，调用者程序会停掉，并有jvm将信息显示到屏幕，让调用者看到问题，修正代码。</code></pre><p>​<br>###16总结</p>
<ul>
<li>把今天的知识点总结一遍。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day20%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day20%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记20</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:11:25" itemprop="dateModified" datetime="2020-12-23T23:11:25+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、Map接口<br>2、模拟斗地主洗牌发牌</p>
<p>=======================第一节课开始=============================================</p>
<p>###01Map集合概述<br>  A:Map集合概述:<br>    我们通过查看Map接口描述,发现Map接口下的集合与Collection接口下的集合，它们存储数据的形式不同<br>        a:Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。<br>    <br>        b:Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。<br>    <br>        Collection中的集合称为单列集合，Map中的集合称为双列集合。<br>        需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。<br>    Map<br>     |–HashMap<br>     |–LinkedHashMap</p>
<p>###02Map接口中的常用方法<br>  A:Map接口中的常用方法<br>       /*<br>        *  Map接口中的常用方法<br>        *    使用Map接口的实现类 HashMap<br>        <em>/<br>       public class MapDemo {<br>           public static void main(String[] args) {<br>               function_2();<br>           }<br>           /</em><br>            *  移除集合中的键值对,返回被移除之前的值<br>            *  V remove(K)<br>            */<br>           public static void function_2(){<br>               Map&lt;Integer,String&gt; map = new HashMap&lt;Integer, String&gt;();<br>               map.put(1, “a”);<br>               map.put(2, “b”);<br>               map.put(3, “c”);<br>               System.out.println(map);</p>
<pre><code>        String value = map.remove(33);
        System.out.println(value);
        System.out.println(map);
    }

    /*
     * 通过键对象,获取值对象
     * V get(K)
     * 如果集合中没有这个键,返回null
     */
    public static void function_1(){
        //创建集合对象,作为键的对象整数,值的对象存储字符串
        Map&lt;Integer,String&gt; map = new HashMap&lt;Integer, String&gt;();
        map.put(1, &quot;a&quot;);
        map.put(2, &quot;b&quot;);
        map.put(3, &quot;c&quot;);
        System.out.println(map);

        String value = map.get(4);
        System.out.println(value);
    }

    /*
     *  将键值对存储到集合中
     *  V put(K,V) K 作为键的对象, V作为值的对象
     *  存储的是重复的键,将原有的值,覆盖
     *  返回值一般情况下返回null,
     *  存储重复键的时候,返回被覆盖之前的值
     */
    public static void function(){
        //创建集合对象,HashMap,存储对象,键是字符串,值是整数
        Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();
        map.put(&quot;a&quot;, 1);

        map.put(&quot;b&quot;, 2);

        map.put(&quot;c&quot;, 3);

        System.out.println(map);
    }
}</code></pre><p>###03Map集合遍历方式keySet方法<br>  A:Map集合遍历方式keySet方法<br>     1.获取Map集合中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键<br>     2.遍历键的Set集合，得到每一个键<br>     3.根据键利用get(key)去Map找所对应的值<br>     /*<br>      *  Map集合的遍历<br>      *    利用键获取值<br>      *    Map接口中定义方法keySet<br>      *    所有的键,存储到Set集合<br>      <em>/<br>     public class MapDemo1 {<br>         public static void main(String[] args) {<br>             /</em><br>              *  1. 调用map集合的方法keySet,所有的键存储到Set集合中<br>              *  2. 遍历Set集合,获取出Set集合中的所有元素 (Map中的键)<br>              *  3. 调用map集合方法get,通过键获取到值<br>              */<br>             Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();<br>             map.put(“a”, 11);<br>             map.put(“b”, 12);<br>             map.put(“c”, 13);<br>             map.put(“d”, 14);</p>
<pre><code>        //1. 调用map集合的方法keySet,所有的键存储到Set集合中
        Set&lt;String&gt; set = map.keySet();
        //2. 遍历Set集合,获取出Set集合中的所有元素 (Map中的键)
        Iterator&lt;String&gt; it = set.iterator();
        while(it.hasNext()){
            //it.next返回是Set集合元素,也就是Map中的键
            //3. 调用map集合方法get,通过键获取到值
            String key = it.next();
            Integer value = map.get(key);
            System.out.println(key+&quot;....&quot;+value);
        }

        System.out.println(&quot;=======================&quot;);


        for(String key : map.keySet()){
            Integer value = map.get(key);
            System.out.println(key+&quot;....&quot;+value);
        }
    }
}</code></pre><p>###04Map集合Entry对象<br>   A:Map集合Entry对象<br>     interface Map{<br>         interface Entry{//Entry是Map的一个内部接口<br>                        //由Map的子类的内部类实现</p>
<pre><code>    }
}
class HashMap{
    static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {//Entry对象指的就是该类的对象
       final K key;
             V value;
    }
}
在Map类设计时，提供了一个嵌套接口：Entry。
Entry将键值对的对应关系封装成了对象。
即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对（Entry）对象中获取对应的键与对应的值。
  a:Entry是Map接口中提供的一个静态内部嵌套接口。
  b:相关方法
     getKey()方法：获取Entry对象中的键
  getValue()方法：获取Entry对象中的值
  entrySet()方法：用于返回Map集合中所有的键值对(Entry)对象，以Set集合形式返回。</code></pre><p>###05Map集合遍历方式entrySet方法<br>   A:Map集合遍历方式entrySet方法<br>    *<br>     *  Map集合获取方式<br>     *  entrySet方法,键值对映射关系(结婚证)获取<br>     *  实现步骤:<br>     *    1. 调用map集合方法entrySet()将集合中的映射关系对象,存储到Set集合<br>     *        Set&lt;Entry &lt;K,V&gt; &gt;<br>     *    2. 迭代Set集合<br>     *    3. 获取出的Set集合的元素,是映射关系对象<br>     *    4. 通过映射关系对象方法 getKet, getValue获取键值对<br>     *<br>     *    创建内部类对象 外部类.内部类 = new<br>     */<br>    public class MapDemo2 {<br>        public static void main(String[] args) {<br>            Map&lt;Integer,String&gt; map = new HashMap&lt;Integer, String&gt;();<br>            map.put(1, “abc”);<br>            map.put(2, “bcd”);<br>            map.put(3, “cde”);<br>            //1. 调用map集合方法entrySet()将集合中的映射关系对象,存储到Set集合<br>            Set&lt;Map.Entry &lt;Integer,String&gt; &gt;  set = map.entrySet();<br>            //2. 迭代Set集合<br>            Iterator&lt;Map.Entry &lt;Integer,String&gt; &gt; it = set.iterator();<br>            while(it.hasNext()){<br>                //  3. 获取出的Set集合的元素,是映射关系对象<br>                // it.next 获取的是什么对象,也是Map.Entry对象<br>                Map.Entry&lt;Integer, String&gt; entry = it.next();<br>                //4. 通过映射关系对象方法 getKet, getValue获取键值对<br>                Integer key = entry.getKey();<br>                String value = entry.getValue();<br>                System.out.println(key+”….”+value);<br>            }</p>
<pre><code>    }
}</code></pre><p>=======================第二节课开始============================================<br>###06Map集合遍历方式增强for循环<br>   A:Map集合遍历方式增强for循环<br>     A:Map集合遍历方式entrySet方法<br>      *<br>       *  Map集合获取方式<br>       *  entrySet方法,键值对映射关系(结婚证)获取<br>       *  实现步骤:<br>       *    1. 调用map集合方法entrySet()将集合中的映射关系对象,存储到Set集合<br>       *        Set&lt;Entry &lt;K,V&gt; &gt;<br>       *    2. 迭代Set集合<br>       *    3. 获取出的Set集合的元素,是映射关系对象<br>       *    4. 通过映射关系对象方法 getKet, getValue获取键值对<br>       *<br>       *    创建内部类对象 外部类.内部类 = new<br>       */<br>      public class MapDemo2 {<br>          public static void main(String[] args) {<br>              Map&lt;Integer,String&gt; map = new HashMap&lt;Integer, String&gt;();<br>              map.put(1, “abc”);<br>              map.put(2, “bcd”);<br>              map.put(3, “cde”);<br>              //1. 调用map集合方法entrySet()将集合中的映射关系对象,存储到Set集合<br>              Set&lt;Map.Entry &lt;Integer,String&gt; &gt;  set = map.entrySet();<br>              //2. 迭代Set集合<br>              Iterator&lt;Map.Entry &lt;Integer,String&gt; &gt; it = set.iterator();<br>              while(it.hasNext()){<br>                  //  3. 获取出的Set集合的元素,是映射关系对象<br>                  // it.next 获取的是什么对象,也是Map.Entry对象<br>                  Map.Entry&lt;Integer, String&gt; entry = it.next();<br>                  //4. 通过映射关系对象方法 getKet, getValue获取键值对<br>                  Integer key = entry.getKey();<br>                  String value = entry.getValue();<br>                  System.out.println(key+”….”+value);<br>              }</p>
<pre><code>        System.out.println(&quot;=========================&quot;);
        for(Map.Entry&lt;Integer, String&gt; entry : map.entrySet()){
            System.out.println(entry.getKey()+&quot;...&quot;+entry.getValue());
        }
    }
}

注意：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。</code></pre><p>###07HashMap集合存储和遍历<br>  A:HashMap集合存储和遍历<br>     /*<br>      *  使用HashMap集合,存储自定义的对象<br>      *  自定义对象,作为键,出现,作为值出现<br>      <em>/<br>     public class HashMapDemo {<br>         public static void main(String[] args) {<br>             function_1();<br>         }<br>         /</em><br>          * HashMap 存储自定义对象Person,作为键出现<br>          * 键的对象,是Person类型,值是字符串<br>          * 保证键的唯一性,存储到键的对象,重写hashCode equals<br>          */<br>         public static void function_1(){<br>             HashMap&lt;Person, String&gt; map = new HashMap&lt;Person, String&gt;();<br>             map.put(new Person(“a”,20), “里约热内卢”);<br>             map.put(new Person(“b”,18), “索马里”);<br>             map.put(new Person(“b”,18), “索马里”);<br>             map.put(new Person(“c”,19), “百慕大”);<br>             for(Person key : map.keySet()){<br>                 String value = map.get(key);<br>                 System.out.println(key+”…”+value);<br>             }<br>             System.out.println(“===================”);<br>             for(Map.Entry&lt;Person, String&gt; entry : map.entrySet()){<br>                 System.out.println(entry.getKey()+”…”+entry.getValue());<br>             }<br>         }</p>
<pre><code>    /*
     * HashMap 存储自定义的对象Person,作为值出现
     * 键的对象,是字符串,可以保证唯一性
     */
    public static void function(){
        HashMap&lt;String, Person&gt; map = new HashMap&lt;String, Person&gt;();
        map.put(&quot;beijing&quot;, new Person(&quot;a&quot;,20));
        map.put(&quot;tianjin&quot;, new Person(&quot;b&quot;,18));
        map.put(&quot;shanghai&quot;, new Person(&quot;c&quot;,19));
        for(String key : map.keySet()){
            Person value = map.get(key);
            System.out.println(key+&quot;...&quot;+value);
        }
        System.out.println(&quot;=================&quot;);
        for(Map.Entry&lt;String, Person&gt; entry : map.entrySet()){
            String key = entry.getKey();
            Person value = entry.getValue();
            System.out.println(key+&quot;...&quot;+value);
        }
    }
}</code></pre><p>###08LinkedHashMap的特点<br>   *A:LinkedHashMap的特点</p>
<pre><code>/*
 *  LinkedHashMap继承HashMap
 *  保证迭代的顺序
 */
public class LinkedHashMapDemo {
    public static void main(String[] args) {
        LinkedHashMap&lt;String, String&gt; link = new LinkedHashMap&lt;String, String&gt;();
        link.put(&quot;1&quot;, &quot;a&quot;);
        link.put(&quot;13&quot;, &quot;a&quot;);
        link.put(&quot;15&quot;, &quot;a&quot;);
        link.put(&quot;17&quot;, &quot;a&quot;);
        System.out.println(link);
    }
}</code></pre><p>###09Hashtable的特点<br>   <em>A:Hashtable的特点<br>       /</em><br>        *  Map接口实现类 Hashtable<br>        *  底层数据结果哈希表,特点和HashMap是一样的<br>        *  Hashtable 线程安全集合,运行速度慢<br>        *  HashMap 线程不安全的集合,运行速度快<br>        *<br>        *  Hashtable命运和Vector是一样的,从JDK1.2开始,被更先进的HashMap取代<br>        *<br>        *  HashMap 允许存储null值,null键<br>        *  Hashtable 不允许存储null值,null键<br>        *<br>        *  Hashtable他的孩子,子类 Properties 依然活跃在开发舞台<br>        */<br>       public class HashtableDemo {<br>           public static void main(String[] args) {<br>               Map&lt;String,String&gt; map = new Hashtable&lt;String,String&gt;();<br>               map.put(null, null);<br>               System.out.println(map);<br>           }<br>       }</p>
<p>###10静态导入<br>   <em>A:静态导入:如果本类中有和静态导入的同名方法会优先使用本类的<br>               如果还想使用静态导入的,依然需要类名来调用<br>       /</em><br>        * JDK1.5新特性,静态导入<br>        * 减少开发的代码量<br>        * 标准的写法,导入包的时候才能使用<br>        *<br>        * import static java.lang.System.out;最末尾,必须是一个静态成员<br>        */<br>       import static java.lang.System.out;<br>       import static java.util.Arrays.sort;</p>
<pre><code>public class StaticImportDemo {
    public static void main(String[] args) {
        out.println(&quot;hello&quot;);

        int[] arr = {1,4,2};
        sort(arr);
    }
}</code></pre><p>###11方法的可变参数<br>   <em>A:方法的可变参数<br>     /</em><br>      *  JDK1.5新的特性,方法的可变参数<br>      *  前提: 方法参数数据类型确定,参数的个数任意<br>      *  可变参数语法: 数据类型…变量名<br>      *  可变参数,本质就是一个数组<br>      */<br>     public class VarArgumentsDemo {<br>         public static void main(String[] args) {<br>             //调用一个带有可变参数的方法,传递参数,可以任意<br>         //    getSum();<br>             int sum = getSum(5,34,3,56,7,8,0);<br>             System.out.println(sum);</p>
<pre><code>    }

    /*
     * 定义方法,计算10个整数和
     * 方法的可变参数实现
     */
    public static int getSum(int...a){
        int sum = 0 ;
        for(int i : a){
            sum = sum + i;
        }
        return sum;
    }

    /*
     * 定义方法,计算3个整数和
     */
    /*public static int getSum(int a,int b ,int c){
        return a+b+c;
    }*/

    /*
     * 定义方法,计算2个整数和
     */
    /*public static int getSum(int a,int b){
        return a+b;
    }*/
}</code></pre><p>###12可变参数的注意事项<br>   <em>A:可变参数的注意事项<br>       /</em><br>        * 可变参数的注意事项<br>        * 1. 一个方法中,可变参数只能有一个<br>        * 2. 可变参数,必须写在参数列表的最后一位<br>        */<br>        public static void function(Object…o){</p>
<pre><code>}</code></pre><p>=======================第三节课开始=============================================<br>###13Collections工具类<br>   A:Collections工具类<br>      /*<br>       *  集合操作的工具类<br>       *    Collections<br>       <em>/<br>      public class CollectionsDemo {<br>          public static void main(String[] args) {<br>              function_2();<br>          }<br>          /</em><br>           * Collections.shuffle方法<br>           * 对List集合中的元素,进行随机排列<br>           */<br>          public static void function_2(){<br>              List<Integer> list = new ArrayList<Integer>();<br>              list.add(1);<br>              list.add(5);<br>              list.add(9);<br>              list.add(11);<br>              list.add(8);<br>              list.add(10);<br>              list.add(15);<br>              list.add(20);<br>              System.out.println(list);</Integer></Integer></p>
<pre><code>        //调用工具类方法shuffle对集合随机排列
        Collections.shuffle(list);
        System.out.println(list);
    }

    /*
     * Collections.binarySearch静态方法
     * 对List集合进行二分搜索,方法参数,传递List集合,传递被查找的元素
     */
    public static void function_1(){
        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        list.add(1);
        list.add(5);
        list.add(8);
        list.add(10);
        list.add(15);
        list.add(20);
        //调用工具类静态方法binarySearch
        int index = Collections.binarySearch(list, 16);
        System.out.println(index);
    }

    /*
     *  Collections.sort静态方法
     *  对于List集合,进行升序排列
     */
    public static void function(){
        //创建List集合
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(&quot;ewrew&quot;);
        list.add(&quot;qwesd&quot;);
        list.add(&quot;Qwesd&quot;);
        list.add(&quot;bv&quot;);
        list.add(&quot;wer&quot;);
        System.out.println(list);
        //调用集合工具类的方法sort
        Collections.sort(list);
        System.out.println(list);
    }
}</code></pre><p>###14集合的嵌套<br>   A:集合的嵌套<br>    /*<br>     *  Map集合的嵌套,Map中存储的还是Map集合<br>     *  要求:<br>     *    传智播客<br>     *      Java基础班<br>     *        001  张三<br>     *        002  李四<br>     *<br>     *      Java就业班<br>     *        001  王五<br>     *        002  赵六<br>     *  对以上数据进行对象的存储<br>     *   001 张三  键值对<br>     *   Java基础班: 存储学号和姓名的键值对<br>     *   Java就业班:<br>     *   传智播客: 存储的是班级<br>     *<br>     *   基础班Map   &lt;学号,姓名&gt;<br>     *   传智播客Map  &lt;班级名字, 基础班Map&gt;<br>     */<br>    public class MapMapDemo {<br>        public static void main(String[] args) {<br>            //定义基础班集合<br>            HashMap&lt;String, String&gt; javase = new HashMap&lt;String, String&gt;();<br>            //定义就业班集合<br>            HashMap&lt;String, String&gt; javaee = new HashMap&lt;String, String&gt;();<br>            //向班级集合中,存储学生信息<br>            javase.put(“001”, “张三”);<br>            javase.put(“002”, “李四”);</p>
<pre><code>    javaee.put(&quot;001&quot;, &quot;王五&quot;);
    javaee.put(&quot;002&quot;, &quot;赵六&quot;);
    //定义传智播客集合容器,键是班级名字,值是两个班级容器
    HashMap&lt;String, HashMap&lt;String,String&gt;&gt; czbk =
            new HashMap&lt;String, HashMap&lt;String,String&gt;&gt;();
    czbk.put(&quot;基础班&quot;, javase);
    czbk.put(&quot;就业班&quot;, javaee);

     keySet(czbk);

}</code></pre><p>###15集合的嵌套keySet遍历<br>   A:集合的嵌套keySet遍历<br>       /*<br>        *  Map集合的嵌套,Map中存储的还是Map集合<br>        *  要求:<br>        *    传智播客<br>        *      Java基础班<br>        *        001  张三<br>        *        002  李四<br>        *<br>        *      Java就业班<br>        *        001  王五<br>        *        002  赵六<br>        *  对以上数据进行对象的存储<br>        *   001 张三  键值对<br>        *   Java基础班: 存储学号和姓名的键值对<br>        *   Java就业班:<br>        *   传智播客: 存储的是班级<br>        *<br>        *   基础班Map   &lt;学号,姓名&gt;<br>        *   传智播客Map  &lt;班级名字, 基础班Map&gt;<br>        */<br>       public class MapMapDemo {<br>           public static void main(String[] args) {<br>               //定义基础班集合<br>               HashMap&lt;String, String&gt; javase = new HashMap&lt;String, String&gt;();<br>               //定义就业班集合<br>               HashMap&lt;String, String&gt; javaee = new HashMap&lt;String, String&gt;();<br>               //向班级集合中,存储学生信息<br>               javase.put(“001”, “张三”);<br>               javase.put(“002”, “李四”);</p>
<pre><code>    javaee.put(&quot;001&quot;, &quot;王五&quot;);
    javaee.put(&quot;002&quot;, &quot;赵六&quot;);
    //定义传智播客集合容器,键是班级名字,值是两个班级容器
    HashMap&lt;String, HashMap&lt;String,String&gt;&gt; czbk =
            new HashMap&lt;String, HashMap&lt;String,String&gt;&gt;();
    czbk.put(&quot;基础班&quot;, javase);
    czbk.put(&quot;就业班&quot;, javaee);

     keySet(czbk);

}</code></pre><p>​<br>​<br>           public static void keySet(HashMap&lt;String,HashMap&lt;String,String&gt;&gt; czbk){<br>               //调用czbk集合方法keySet将键存储到Set集合<br>               Set<String> classNameSet = czbk.keySet();<br>               //迭代Set集合<br>               Iterator<String> classNameIt = classNameSet.iterator();<br>               while(classNameIt.hasNext()){<br>                   //classNameIt.next获取出来的是Set集合元素,czbk集合的键<br>                   String classNameKey = classNameIt.next();<br>                   //czbk集合的方法get获取值,值是一个HashMap集合<br>                   HashMap&lt;String,String&gt; classMap = czbk.get(classNameKey);<br>                   //调用classMap集合方法keySet,键存储到Set集合<br>                   Set<String> studentNum = classMap.keySet();<br>                   Iterator<String> studentIt = studentNum.iterator();</String></String></String></String></p>
<pre><code>            while(studentIt.hasNext()){
                //studentIt.next获取出来的是classMap的键,学号
                String numKey = studentIt.next();
                //调用classMap集合中的get方法获取值
                String nameValue = classMap.get(numKey);
                System.out.println(classNameKey+&quot;..&quot;+numKey+&quot;..&quot;+nameValue);
            }
        }

        System.out.println(&quot;==================================&quot;);
        for(String className: czbk.keySet()){
           HashMap&lt;String, String&gt; hashMap = czbk.get(className);    
           for(String numKey : hashMap.keySet()){
               String nameValue = hashMap.get(numKey);
               System.out.println(className+&quot;..&quot;+numKey+&quot;..&quot;+nameValue);
           }
        }
    }

} </code></pre><p>###16集合的嵌套entrySet遍历<br>    A:集合的嵌套entrySet遍历<br>    /*<br>     *  Map集合的嵌套,Map中存储的还是Map集合<br>     *  要求:<br>     *    传智播客<br>     *      Java基础班<br>     *        001  张三<br>     *        002  李四<br>     *<br>     *      Java就业班<br>     *        001  王五<br>     *        002  赵六<br>     *  对以上数据进行对象的存储<br>     *   001 张三  键值对<br>     *   Java基础班: 存储学号和姓名的键值对<br>     *   Java就业班:<br>     *   传智播客: 存储的是班级<br>     *<br>     *   基础班Map   &lt;学号,姓名&gt;<br>     *   传智播客Map  &lt;班级名字, 基础班Map&gt;<br>     */<br>    public class MapMapDemo {<br>        public static void main(String[] args) {<br>            //定义基础班集合<br>            HashMap&lt;String, String&gt; javase = new HashMap&lt;String, String&gt;();<br>            //定义就业班集合<br>            HashMap&lt;String, String&gt; javaee = new HashMap&lt;String, String&gt;();<br>            //向班级集合中,存储学生信息<br>            javase.put(“001”, “张三”);<br>            javase.put(“002”, “李四”);</p>
<pre><code>    javaee.put(&quot;001&quot;, &quot;王五&quot;);
    javaee.put(&quot;002&quot;, &quot;赵六&quot;);
    //定义传智播客集合容器,键是班级名字,值是两个班级容器
    HashMap&lt;String, HashMap&lt;String,String&gt;&gt; czbk =
            new HashMap&lt;String, HashMap&lt;String,String&gt;&gt;();
    czbk.put(&quot;基础班&quot;, javase);
    czbk.put(&quot;就业班&quot;, javaee);

    entrySet(czbk);
}

public static void entrySet(HashMap&lt;String,HashMap&lt;String,String&gt;&gt; czbk){
    //调用czbk集合方法entrySet方法,将czbk集合的键值对关系对象,存储到Set集合
    Set&lt;Map.Entry&lt;String, HashMap&lt;String,String&gt;&gt;&gt; 
                             classNameSet = czbk.entrySet();
    //迭代器迭代Set集合
    Iterator&lt;Map.Entry&lt;String, HashMap&lt;String,String&gt;&gt;&gt; classNameIt = classNameSet.iterator();
    while(classNameIt.hasNext()){
        //classNameIt.next方法,取出的是czbk集合的键值对关系对象
        Map.Entry&lt;String, HashMap&lt;String,String&gt;&gt; classNameEntry =  classNameIt.next();
        //classNameEntry方法 getKey,getValue
        String classNameKey = classNameEntry.getKey();
        //获取值,值是一个Map集合
        HashMap&lt;String,String&gt; classMap = classNameEntry.getValue();
        //调用班级集合classMap方法entrySet,键值对关系对象存储Set集合
        Set&lt;Map.Entry&lt;String, String&gt;&gt; studentSet = classMap.entrySet();
        //迭代Set集合
        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; studentIt = studentSet.iterator();
        while(studentIt.hasNext()){
            //studentIt方法next获取出的是班级集合的键值对关系对象
            Map.Entry&lt;String, String&gt; studentEntry = studentIt.next();
            //studentEntry方法 getKey getValue
            String numKey = studentEntry.getKey();
            String nameValue = studentEntry.getValue();
            System.out.println(classNameKey+&quot;..&quot;+numKey+&quot;..&quot;+nameValue);
        }
    }
     System.out.println(&quot;==================================&quot;);

    for (Map.Entry&lt;String, HashMap&lt;String, String&gt;&gt; me : czbk.entrySet()) {
        String classNameKey = me.getKey();
        HashMap&lt;String, String&gt; numNameMapValue = me.getValue();
        for (Map.Entry&lt;String, String&gt; nameMapEntry : numNameMapValue.entrySet()) {
            String numKey = nameMapEntry.getKey();
            String nameValue = nameMapEntry.getValue();
            System.out.println(classNameKey + &quot;..&quot; + numKey + &quot;..&quot; + nameValue);
        }
    }
}</code></pre><p>​<br>    }</p>
<p>=======================第四节课开始=============================================</p>
<p>###17斗地主的功能分析<br>   A:斗地主的功能分析<br>       a:具体规则：<br>               1. 组装54张扑克牌<br>            2. 将54张牌顺序打乱<br>               3. 三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。<br>               4. 查看三人各自手中的牌（按照牌的大小排序）、底牌<br>       b:分析:<br>          1.准备牌：<br>           完成数字与纸牌的映射关系：<br>           使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。<br>          2.洗牌：<br>           通过数字完成洗牌发牌<br>          3.发牌：<br>           将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。<br>           存放的过程中要求数字大小与斗地主规则的大小对应。<br>           将代表不同纸牌的数字分配给不同的玩家与底牌。<br>          4.看牌：<br>           通过Map集合找到对应字符展示。<br>           通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</String></p>
<p>###18斗地主的准备牌<br>   A:斗地主的准备牌<br>     /*<br>      *  实现模拟斗地主的功能<br>      *   1. 组合牌<br>      *   2. 洗牌<br>      *   3. 发牌<br>      *   4. 看牌<br>      */<br>     public class DouDiZhu {<br>         public static void main(String[] args) {<br>             //1. 组合牌<br>             //创建Map集合,键是编号,值是牌<br>             HashMap&lt;Integer,String&gt; pooker = new HashMap&lt;Integer, String&gt;();<br>             //创建List集合,存储编号<br>             ArrayList<Integer> pookerNumber = new ArrayList<Integer>();<br>             //定义出13个点数的数组<br>             String[] numbers = {“2”,”A”,”K”,”Q”,”J”,”10”,”9”,”8”,”7”,”6”,”5”,”4”,”3”};<br>             //定义4个花色数组<br>             String[] colors = {“♠”,”♥”,”♣”,”♦”};<br>             //定义整数变量,作为键出现<br>             int index = 2;<br>             //遍历数组,花色+点数的组合,存储到Map集合<br>             for(String number : numbers){<br>                 for(String color : colors){<br>                     pooker.put(index, color+number);<br>                     pookerNumber.add(index);<br>                     index++;<br>                 }<br>             }<br>             //存储大王,和小王,索引是从0~54,对应大王,小王,…3(牌的顺序从大到小)<br>             pooker.put(0, “大王”);<br>             pookerNumber.add(0);<br>             pooker.put(1, “小王”);<br>             pookerNumber.add(1);</Integer></Integer></p>
<pre><code>}</code></pre><p>###19斗地主的洗牌<br>    A:斗地主的洗牌<br>      /*<br>       *  实现模拟斗地主的功能<br>       *   1. 组合牌<br>       *   2. 洗牌<br>       *   3. 发牌<br>       *   4. 看牌<br>       */<br>      public class DouDiZhu {<br>          public static void main(String[] args) {<br>              //1. 组合牌<br>              //创建Map集合,键是编号,值是牌<br>              HashMap&lt;Integer,String&gt; pooker = new HashMap&lt;Integer, String&gt;();<br>              //创建List集合,存储编号<br>              ArrayList<Integer> pookerNumber = new ArrayList<Integer>();<br>              //定义出13个点数的数组<br>              String[] numbers = {“2”,”A”,”K”,”Q”,”J”,”10”,”9”,”8”,”7”,”6”,”5”,”4”,”3”};<br>              //定义4个花色数组<br>              String[] colors = {“♠”,”♥”,”♣”,”♦”};<br>              //定义整数变量,作为键出现<br>              int index = 2;<br>              //遍历数组,花色+点数的组合,存储到Map集合<br>              for(String number : numbers){<br>                  for(String color : colors){<br>                      pooker.put(index, color+number);<br>                      pookerNumber.add(index);<br>                      index++;<br>                  }<br>              }<br>              //存储大王,和小王<br>              pooker.put(0, “大王”);<br>              pookerNumber.add(0);<br>              pooker.put(1, “小王”);<br>              pookerNumber.add(1);</Integer></Integer></p>
<pre><code>//洗牌,将牌的编号打乱
Collections.shuffle(pookerNumber);</code></pre><p>​<br>          }</p>
<pre><code>}</code></pre><p>###20斗地主的发牌<br>  A:斗地主的发牌<br>    /*<br>     *  实现模拟斗地主的功能<br>     *   1. 组合牌<br>     *   2. 洗牌<br>     *   3. 发牌<br>     *   4. 看牌<br>     */<br>    public class DouDiZhu {<br>        public static void main(String[] args) {<br>            //1. 组合牌<br>            //创建Map集合,键是编号,值是牌<br>            HashMap&lt;Integer,String&gt; pooker = new HashMap&lt;Integer, String&gt;();<br>            //创建List集合,存储编号<br>            ArrayList<Integer> pookerNumber = new ArrayList<Integer>();<br>            //定义出13个点数的数组<br>            String[] numbers = {“2”,”A”,”K”,”Q”,”J”,”10”,”9”,”8”,”7”,”6”,”5”,”4”,”3”};<br>            //定义4个花色数组<br>            String[] colors = {“♠”,”♥”,”♣”,”♦”};<br>            //定义整数变量,作为键出现<br>            int index = 2;<br>            //遍历数组,花色+点数的组合,存储到Map集合<br>            for(String number : numbers){<br>                for(String color : colors){<br>                    pooker.put(index, color+number);<br>                    pookerNumber.add(index);<br>                    index++;<br>                }<br>            }<br>            //存储大王,和小王<br>            pooker.put(0, “大王”);<br>            pookerNumber.add(0);<br>            pooker.put(1, “小王”);<br>            pookerNumber.add(1);</Integer></Integer></p>
<pre><code>        //洗牌,将牌的编号打乱
        Collections.shuffle(pookerNumber);

        //发牌功能,将牌编号,发给玩家集合,底牌集合
        ArrayList&lt;Integer&gt; player1 = new ArrayList&lt;Integer&gt;();
        ArrayList&lt;Integer&gt; player2 = new ArrayList&lt;Integer&gt;();
        ArrayList&lt;Integer&gt; player3 = new ArrayList&lt;Integer&gt;();
        ArrayList&lt;Integer&gt; bottom = new ArrayList&lt;Integer&gt;();

        //发牌采用的是集合索引%3
        for(int i = 0 ; i &lt; pookerNumber.size() ; i++){
            //先将底牌做好
            if(i &lt; 3){
                //存到底牌去
                bottom.add( pookerNumber.get(i));
               //对索引%3判断
            }else if(i % 3 == 0){
                //索引上的编号,发给玩家1
                player1.add( pookerNumber.get(i) );
            }else if( i % 3 == 1){
                //索引上的编号,发给玩家2
                player2.add( pookerNumber.get(i) );
            }else if( i % 3 == 2){
                //索引上的编号,发给玩家3
                player3.add( pookerNumber.get(i) );
            }
        }

    }

}</code></pre><p>###21斗地主的看牌<br>  A:斗地主的看牌<br>     /*<br>      *  实现模拟斗地主的功能<br>      *   1. 组合牌<br>      *   2. 洗牌<br>      *   3. 发牌<br>      *   4. 看牌<br>      */<br>     public class DouDiZhu {<br>         public static void main(String[] args) {<br>             //1. 组合牌<br>             //创建Map集合,键是编号,值是牌<br>             HashMap&lt;Integer,String&gt; pooker = new HashMap&lt;Integer, String&gt;();<br>             //创建List集合,存储编号<br>             ArrayList<Integer> pookerNumber = new ArrayList<Integer>();<br>             //定义出13个点数的数组<br>             String[] numbers = {“2”,”A”,”K”,”Q”,”J”,”10”,”9”,”8”,”7”,”6”,”5”,”4”,”3”};<br>             //定义4个花色数组<br>             String[] colors = {“♠”,”♥”,”♣”,”♦”};<br>             //定义整数变量,作为键出现<br>             int index = 2;<br>             //遍历数组,花色+点数的组合,存储到Map集合<br>             for(String number : numbers){<br>                 for(String color : colors){<br>                     pooker.put(index, color+number);<br>                     pookerNumber.add(index);<br>                     index++;<br>                 }<br>             }<br>             //存储大王,和小王<br>             pooker.put(0, “大王”);<br>             pookerNumber.add(0);<br>             pooker.put(1, “小王”);<br>             pookerNumber.add(1);</Integer></Integer></p>
<pre><code>        //洗牌,将牌的编号打乱
        Collections.shuffle(pookerNumber);

        //发牌功能,将牌编号,发给玩家集合,底牌集合
        ArrayList&lt;Integer&gt; player1 = new ArrayList&lt;Integer&gt;();
        ArrayList&lt;Integer&gt; player2 = new ArrayList&lt;Integer&gt;();
        ArrayList&lt;Integer&gt; player3 = new ArrayList&lt;Integer&gt;();
        ArrayList&lt;Integer&gt; bottom = new ArrayList&lt;Integer&gt;();

        //发牌采用的是集合索引%3
        for(int i = 0 ; i &lt; pookerNumber.size() ; i++){
            //先将底牌做好
            if(i &lt; 3){
                //存到底牌去
                bottom.add( pookerNumber.get(i));
               //对索引%3判断
            }else if(i % 3 == 0){
                //索引上的编号,发给玩家1
                player1.add( pookerNumber.get(i) );
            }else if( i % 3 == 1){
                //索引上的编号,发给玩家2
                player2.add( pookerNumber.get(i) );
            }else if( i % 3 == 2){
                //索引上的编号,发给玩家3
                player3.add( pookerNumber.get(i) );
            }
        }
        //对玩家手中的编号排序
        Collections.sort(player1);
        Collections.sort(player2);
        Collections.sort(player3);
        //看牌,将玩家手中的编号,到Map集合中查找,根据键找值
        //定义方法实现
        look(&quot;刘德华&quot;,player1,pooker);
        look(&quot;张曼玉&quot;,player2,pooker);
        look(&quot;林青霞&quot;,player3,pooker);
        look(&quot;底牌&quot;,bottom,pooker);
    }
    public static void look(String name,ArrayList&lt;Integer&gt; player,HashMap&lt;Integer,String&gt; pooker){
        //遍历ArrayList集合,获取元素,作为键,到集合Map中找值
        System.out.print(name+&quot; &quot;);
        for(Integer key : player){
            String value = pooker.get(key);
            System.out.print(value+&quot; &quot;);
        }
        System.out.println();
    }
}</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day19%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%AC%AC%E4%BA%8C%E5%A4%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day19%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%AC%AC%E4%BA%8C%E5%A4%A9/" class="post-title-link" itemprop="url">java学习笔记19_2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:11:12" itemprop="dateModified" datetime="2020-12-23T23:11:12+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>###并发修改异常(重点)</p>
<pre><code>描述的是：集合和迭代器同时持有同一个对象，当集合在添加，和删除集合元素时（修改呢），迭代器并不知道，所以会发生并发修改异常   
注意：增强for也会产生并发修改异常
如何解决： 第一： 使用普通for循环
          第二(重点):使用listIterator --&gt;是List 特有的，其他集合不能使用  
代码：</code></pre><h3 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h3><pre><code>a、 E set(int index, E) 修改指定索引上的元素，返回被修改之前的元素
b、 E remove(int index) 移除指定索引上的元素，返回被删除之前的元素
c、 add(int index, E)将元素插入到列表的指定索引上，其他元素顺移
d、remove(int index) 删除并返回元素</code></pre><h3 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h3><pre><code>栈   ： 手枪的弹夹 : 手枪的压栈     ---&gt; 喝酒   ---&gt;先进后出，后进先出
队列 :  超市的购物，先排队，先处理   ---&gt; 喝酒   ---&gt;先进去，先出来，后进去，后出来
数组 :  查找快:因为底层有索引，并且是连续
       增删慢: 数组的长度的是固定的，当我们在进行增删时，会创建一个新的数组，并且将老数组中的值拷贝到新数组中
链表：  查找慢（底层是链表，两两相连，依次往下找，直到找到为止） ---&gt;linkedList 采用二分法查找 
       增删快 :原因在于他仅仅只需要改变相邻元素的地址值</code></pre><h3 id="arrayList的特点"><a href="#arrayList的特点" class="headerlink" title="arrayList的特点"></a>arrayList的特点</h3><pre><code>底层是可变数组查找快:因为底层有索引，并且是连续</code></pre><p>###　linkedList 的特点：<br>       查找慢（底层是链表，两两相连，依次往下找，直到找到为止）<br>     Vector ： 已经被淘汰，是线程安全的，效率低，其他和arrayList 一致</p>
<h3 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h3><pre><code>我想自己实现一个栈结构：--&gt;先进后出，后进先出</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day19%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day19%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记19</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:10:51" itemprop="dateModified" datetime="2020-12-23T23:10:51+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、List接口<br>2、Set接口<br>3、判断集合唯一性原理</p>
<p>=======================第一节课开始=============================================</p>
<p>###01List接口的特点<br>  A:List接口的特点:<br>   a:它是一个元素存取有序的集合。<br>        例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。<br>   b:它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。<br>   <br>     c:集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</p>
<pre><code>d:List接口的常用子类有：</code></pre><p>      ArrayList集合<br>      LinkedList集合</p>
<p>###02List接口的特有方法<br>    A:List接口的特有方法(带索引的方法)<br>   a:增加元素方法<br>   add(Object e)：向集合末尾处，添加指定的元素<br>   add(int index, Object e)   向集合指定索引处，添加指定的元素，原有元素依次后移</p>
<pre><code>/*
  *  add(int index, E)
  *  将元素插入到列表的指定索引上
  *  带有索引的操作,防止越界问题
  *  java.lang.IndexOutOfBoundsException
  *     ArrayIndexOutOfBoundsException
  *     StringIndexOutOfBoundsException
  */
 public static void function(){
   List&lt;String&gt; list = new ArrayList&lt;String&gt;();
   list.add(&quot;abc1&quot;);
   list.add(&quot;abc2&quot;);
   list.add(&quot;abc3&quot;);
   list.add(&quot;abc4&quot;);
   System.out.println(list);

   list.add(1, &quot;itcast&quot;);
   System.out.println(list);
 }</code></pre><p>   b:删除元素删除<br>   remove(Object e)：将指定元素对象，从集合中删除，返回值为被删除的元素<br>   remove(int index)：将指定索引处的元素，从集合中删除，返回值为被删除的元素<br>     /*<br>       *  E remove(int index)<br>       *  移除指定索引上的元素<br>       *  返回被删除之前的元素<br>       */<br>      public static void function_1(){<br>        List<Double> list = new ArrayList<Double>();<br>        list.add(1.1);<br>        list.add(1.2);<br>        list.add(1.3);<br>        list.add(1.4);</Double></Double></p>
<pre><code>  Double d = list.remove(0);
  System.out.println(d);
  System.out.println(list);
}</code></pre><p>   c:替换元素方法<br>   set(int index, Object e)：将指定索引处的元素，替换成指定的元素，返回值为替换前的元素<br>      /*<br>       *  E set(int index, E)<br>       *  修改指定索引上的元素<br>       *  返回被修改之前的元素<br>       */<br>      public static void function_2(){<br>        List<Integer> list = new ArrayList<Integer>();<br>        list.add(1);<br>        list.add(2);<br>        list.add(3);<br>        list.add(4);</Integer></Integer></p>
<pre><code>    Integer i = list.set(0, 5);
    System.out.println(i);
    System.out.println(list);
  }
d:查询元素方法</code></pre><p>   get(int index)：获取指定索引处的元素，并返回该元素</p>
<p>###03迭代器的并发修改异常<br>    A:迭代器的并发修改异常</p>
<pre><code>/*
 *  迭代器的并发修改异常 java.util.ConcurrentModificationException
 *  就是在遍历的过程中,使用了集合方法修改了集合的长度,不允许的
 */
public class ListDemo1 {
 public static void main(String[] args) {
   List&lt;String&gt; list = new ArrayList&lt;String&gt;();
   list.add(&quot;abc1&quot;);
   list.add(&quot;abc2&quot;);
   list.add(&quot;abc3&quot;);
   list.add(&quot;abc4&quot;);

   //对集合使用迭代器进行获取,获取时候判断集合中是否存在 &quot;abc3&quot;对象
   //如果有,添加一个元素 &quot;ABC3&quot;
   Iterator&lt;String&gt; it = list.iterator();
   while(it.hasNext()){
     String s = it.next();
     //对获取出的元素s,进行判断,是不是有&quot;abc3&quot;
     if(s.equals(&quot;abc3&quot;)){
       list.add(&quot;ABC3&quot;);
     }
     System.out.println(s);
   }
 }
}

运行上述代码发生了错误 java.util.ConcurrentModificationException这是什么原因呢？
  在迭代过程中，使用了集合的方法对元素进行操作。
  导致迭代器并不知道集合中的变化，容易引发数据的不确定性。

并发修改异常解决办法：
   在迭代时，不要使用集合的方法操作元素。
   或者通过ListIterator迭代器操作元素是可以的，ListIterator的出现，解决了使用Iterator迭代过程中可能会发生的错误情况。</code></pre><p>###04数据的存储结构<br>    A:数据的存储结构<br>     a:栈结构:后进先出/先进后出(手枪弹夹) FILO (first in last out)<br>     b:队列结构:先进先出/后进后出(银行排队) FIFO(first in first out)<br>     c:数组结构:<br>               查询快:通过索引快速找到元素<br>               增删慢:每次增删都需要开辟新的数组,将老数组中的元素拷贝到新数组中<br>                      开辟新数组耗费资源<br>     d:链表结构<br>               查询慢:每次都需要从链头或者链尾找起<br>               增删快:只需要修改元素记录的下个元素的地址值即可不需要移动大量元素</p>
<p>=======================第二节课开始=============================================<br>###05ArrayList集合的自身特点<br>   A:ArrayList集合的自身特点<br>     底层采用的是数组结构<br>     ArrayList al=new ArrayList();//创建了一个长度为0的Object类型数组<br>     al.add(“abc”);//底层会创建一个长度为10的Object数组 Object[] obj=new Object[10]<br>                   //obj[0]=”abc”<br>                  //如果添加的元素的超过10个,底层会开辟一个1.5*10的长度的新数组<br>                  //把原数组中的元素拷贝到新数组,再把最后一个元素添加到新数组中<br>   原数组:<br>     a b c d e f g h k l<br>   添加m:<br>     a b c d e f g h k l m null null null null</p>
<p>###06LinkedList集合的自身特点<br>  A:LinkedList集合的自身特点<br>     底层采用链表结构,每次查询都要从链头或链尾找起,查询相对数组较慢<br>     但是删除直接修改元素记录的地址值即可,不要大量移动元素</p>
<pre><code>LinkedList的索引决定是从链头开始找还是从链尾开始找
如果该元素小于元素长度一半,从链头开始找起,如果大于元素长度的一半,则从链尾找起</code></pre><p>###07LinkedList特有方法<br>   <em>A:LinkedList特有方法:获取,添加,删除<br>       /</em><br>     *  LinkedList 链表集合的特有功能<br>     *    自身特点: 链表底层实现,查询慢,增删快<br>     *<br>     *  子类的特有功能,不能多态调用<br>     */<br>    public class LinkedListDemo {<br>      public static void main(String[] args) {<br>        function_3();<br>      }</p>
<pre><code>/*
 *  E removeFirst() 移除并返回链表的开头
 *  E removeLast() 移除并返回链表的结尾
 */
public static void function_3(){
  LinkedList&lt;String&gt; link = new LinkedList&lt;String&gt;();
  link.add(&quot;1&quot;);
  link.add(&quot;2&quot;);
  link.add(&quot;3&quot;);
  link.add(&quot;4&quot;);

  String first = link.removeFirst();
  String last = link.removeLast();
  System.out.println(first);
  System.out.println(last);

  System.out.println(link);
}

/*
 * E getFirst() 获取链表的开头
 * E getLast() 获取链表的结尾
 */
public static void function_2(){
  LinkedList&lt;String&gt; link = new LinkedList&lt;String&gt;();
  link.add(&quot;1&quot;);
  link.add(&quot;2&quot;);
  link.add(&quot;3&quot;);
  link.add(&quot;4&quot;);

  if(!link.isEmpty()){
    String first = link.getFirst();
    String last = link.getLast();
    System.out.println(first);
    System.out.println(last);
  }
}

public static void function_1(){
  LinkedList&lt;String&gt; link = new LinkedList&lt;String&gt;();
  link.addLast(&quot;a&quot;);
  link.addLast(&quot;b&quot;);
  link.addLast(&quot;c&quot;);
  link.addLast(&quot;d&quot;);

  link.addFirst(&quot;1&quot;);
  link.addFirst(&quot;2&quot;);
  link.addFirst(&quot;3&quot;);
  System.out.println(link);
}

/*
 *  addFirst(E) 添加到链表的开头
 *  addLast(E) 添加到链表的结尾
 */
public static void function(){
  LinkedList&lt;String&gt; link = new LinkedList&lt;String&gt;();

  link.addLast(&quot;heima&quot;);

  link.add(&quot;abc&quot;);
  link.add(&quot;bcd&quot;);

  link.addFirst(&quot;itcast&quot;);
  System.out.println(link);</code></pre><p>​<br>      }<br>    }</p>
<p>###08Vector类的特点<br>   *A:Vector类的特点<br>       Vector集合数据存储的结构是数组结构，为JDK中最早提供的集合,它是线程同步的<br>       Vector中提供了一个独特的取出方式，就是枚举Enumeration，它其实就是早期的迭代器。<br>       此接口Enumeration的功能与 Iterator 接口的功能是类似的。<br>       Vector集合已被ArrayList替代。枚举Enumeration已被迭代器Iterator替代。</p>
<p>=======================第三节课开始=============================================<br>###09Set接口的特点<br>   A:Set接口的特点<br>     a:它是个不包含重复元素的集合。<br>     b:Set集合取出元素的方式可以采用：迭代器、增强for。<br>     c:Set集合有多个子类，这里我们介绍其中的HashSet、LinkedHashSet这两个集合。</p>
<p>###10Set集合存储和迭代<br>   A:Set集合存储和迭代<br>      /*<br>       *  Set接口,特点不重复元素,没索引<br>       *<br>       *  Set接口的实现类,HashSet (哈希表)<br>       *  特点: 无序集合,存储和取出的顺序不同,没有索引,不存储重复元素<br>       *  代码的编写上,和ArrayList完全一致<br>       */<br>      public class HashSetDemo {<br>        public static void main(String[] args) {<br>          Set<String> set = new HashSet<String>();<br>          set.add(“cn”);<br>          set.add(“heima”);<br>          set.add(“java”);<br>          set.add(“java”);<br>          set.add(“itcast”);</String></String></p>
<pre><code>    Iterator&lt;String&gt; it = set.iterator();
    while(it.hasNext()){
      System.out.println(it.next());
    }
    System.out.println(&quot;==============&quot;);

    for(String s : set){
      System.out.println(s);
    }
  }
}</code></pre><p>###11哈希表的数据结构<br>    A:哈希表的数据结构:(参见图解)</p>
<pre><code>加载因子:表中填入的记录数/哈希表的长度
例如:
加载因子是0.75 代表:
  数组中的16个位置,其中存入16*0.75=12个元素

如果在存入第十三个(&gt;12)元素,导致存储链子过长,会降低哈希表的性能,那么此时会扩充哈希表(在哈希),底层会开辟一个长度为原长度2倍的数组,把老元素拷贝到新数组中,再把新元素添加数组中

当存入元素数量&gt;哈希表长度*加载因子,就要扩容,因此加载因子决定扩容时机</code></pre><p>###12字符串对象的哈希值<br>      A:字符串对象的哈希值<br>      /*<br>       *  对象的哈希值,普通的十进制整数<br>       *  父类Object,方法 public int hashCode() 计算结果int整数<br>       */<br>      public class HashDemo {<br>        public static void main(String[] args) {<br>          Person p = new Person();<br>          int i = p.hashCode();<br>          System.out.println(i);</p>
<pre><code>    String s1 = new String(&quot;abc&quot;);
    String s2 = new String(&quot;abc&quot;);
    System.out.println(s1.hashCode());
    System.out.println(s2.hashCode());

    /*System.out.println(&quot;重地&quot;.hashCode());
    System.out.println(&quot;通话&quot;.hashCode());*/
  }
}

//String类重写hashCode()方法
//字符串都会存储在底层的value数组中{&apos;a&apos;,&apos;b&apos;,&apos;c&apos;}
public int hashCode() {
        int h = hash;//hash初值为0
        if (h == 0 &amp;&amp; value.length &gt; 0) {
            char val[] = value;

            for (int i = 0; i &lt; value.length; i++) {
                h = 31 * h + val[i];
            }
            hash = h;
        }
        return h;
    }</code></pre><p>​<br>###13哈希表的存储过程<br>   A:哈希表的存储过程<br>     public static void main(String[] args) {<br>        HashSet<String> set = new HashSet<String>();<br>        set.add(new String(“abc”));<br>        set.add(new String(“abc”));<br>        set.add(new String(“bbc”));<br>        set.add(new String(“bbc”));<br>        System.out.println(set);<br>    }</String></String></p>
<p>  存取原理:<br>    每存入一个新的元素都要走以下三步:</p>
<pre><code>1.首先调用本类的hashCode()方法算出哈希值

2.在容器中找是否与新元素哈希值相同的老元素,
  如果没有直接存入
  如果有转到第三步

3.新元素会与该索引位置下的老元素利用equals方法一一对比
  一旦新元素.equals(老元素)返回true,停止对比,说明重复,不再存入
  如果与该索引位置下的老元素都通过equals方法对比返回false,说明没有重复,存入</code></pre><p>=======================第四节课开始=============================================<br>###14哈希表的存储自定义对象<br>   A:哈希表的存储自定义对象<br>     /*<br>      *  HashSet集合的自身特点:<br>      *    底层数据结构,哈希表<br>      *    存储,取出都比较快<br>      *    线程不安全,运行速度快<br>      */<br>     public class HashSetDemo1 {<br>      public static void main(String[] args) {</p>
<pre><code>    //将Person对象中的姓名,年龄,相同数据,看作同一个对象
    //判断对象是否重复,依赖对象自己的方法 hashCode,equals
    HashSet&lt;Person&gt; setPerson = new HashSet&lt;Person&gt;();
    setPerson.add(new Person(&quot;a&quot;,11));
    setPerson.add(new Person(&quot;b&quot;,10));
    setPerson.add(new Person(&quot;b&quot;,10));
    setPerson.add(new Person(&quot;c&quot;,25));
    setPerson.add(new Person(&quot;d&quot;,19));
    setPerson.add(new Person(&quot;e&quot;,17));//每个对象的地址值都不同,调用Obejct类的hashCode方法返回不同哈希值,直接存入
    System.out.println(setPerson);
  }
 }

public class Person {
  private String name;
  private int age;

  public String getName() {
    return name;
  }
  public void setName(String name) {
    this.name = name;
  }
  public int getAge() {
    return age;
  }
  public void setAge(int age) {
    this.age = age;
  }
  public Person(String name, int age) {
    super();
    this.name = name;
    this.age = age;
  }
  public Person(){}

  public String toString(){
    return name+&quot;..&quot;+age;
  }



 }</code></pre><p>​      </p>
<p>###15自定义对象重写hashCode和equals<br>     A:自定义对象重写hashCode和equals<br>      /*<br>          *  HashSet集合的自身特点:<br>          *    底层数据结构,哈希表<br>          *    存储,取出都比较快<br>          *    线程不安全,运行速度快<br>          */<br>         public class HashSetDemo1 {<br>          public static void main(String[] args) {</p>
<pre><code>    //将Person对象中的姓名,年龄,相同数据,看作同一个对象
    //判断对象是否重复,依赖对象自己的方法 hashCode,equals
    HashSet&lt;Person&gt; setPerson = new HashSet&lt;Person&gt;();
    setPerson.add(new Person(&quot;a&quot;,11));
    setPerson.add(new Person(&quot;b&quot;,10));
    setPerson.add(new Person(&quot;b&quot;,10));
    setPerson.add(new Person(&quot;c&quot;,25));
    setPerson.add(new Person(&quot;d&quot;,19));
    setPerson.add(new Person(&quot;e&quot;,17));
    System.out.println(setPerson);
  }
 }

public class Person {
  private String name;
  private int age;

  /*
   *  没有做重写父类,每次运行结果都是不同整数
   *  如果子类重写父类的方法,哈希值,自定义的
   *  存储到HashSet集合的依据
   *   
   *  尽可能让不同的属性值产生不同的哈希值,这样就不用再调用equals方法去比较属性
   *
   */
  public int hashCode(){
    return name.hashCode()+age*55;
  }
  //方法equals重写父类,保证和父类相同
  //public boolean equals(Object obj){}
  public boolean equals(Object obj){
    if(this == obj)
      return true;
    if(obj == null)
      return false;
    if(obj instanceof Person){
      Person p = (Person)obj;
      return name.equals(p.name) &amp;&amp; age==p.age;
    }
    return false;
  }

  public String getName() {
    return name;
  }
  public void setName(String name) {
    this.name = name;
  }
  public int getAge() {
    return age;
  }
  public void setAge(int age) {
    this.age = age;
  }
  public Person(String name, int age) {
    super();
    this.name = name;
    this.age = age;
  }
  public Person(){}

  public String toString(){
    return name+&quot;..&quot;+age;
  }



 }</code></pre><p>###16LinkedHashSet集合<br>  A:LinkedHashSet集合<br>    /*<br>     *   LinkedHashSet 基于链表的哈希表实现<br>     *   继承自HashSet<br>     *<br>     *   LinkedHashSet 自身特性,具有顺序,存储和取出的顺序相同的<br>     *   线程不安全的集合,运行速度块<br>     */<br>    public class LinkedHashSetDemo {</p>
<pre><code>  public static void main(String[] args) {
    LinkedHashSet&lt;Integer&gt; link = new LinkedHashSet&lt;Integer&gt;();
    link.add(123);
    link.add(44);
    link.add(33);
    link.add(33);
    link.add(66);
    link.add(11);
    System.out.println(link);
  }
}</code></pre><p>###17ArrayList,HashSet判断对象是否重复的原因<br>  A:ArrayList,HashSet判断对象是否重复的原因<br>     a:ArrayList的contains方法原理:底层依赖于equals方法<br>       ArrayList的contains方法会使用调用方法时，<br>         传入的元素的equals方法依次与集合中的旧元素所比较，<br>         从而根据返回的布尔值判断是否有重复元素。<br>         此时，当ArrayList存放自定义类型时，由于自定义类型在未重写equals方法前，<br>         判断是否重复的依据是地址值，所以如果想根据内容判断是否为重复元素，需要重写元素的equals方法。</p>
<pre><code>b:HashSet的add()方法和contains方法()底层都依赖 hashCode()方法与equals方法()

 Set集合不能存放重复元素，其添加方法在添加时会判断是否有重复元素，有重复不添加，没重复则添加。
 HashSet集合由于是无序的，其判断唯一的依据是元素类型的hashCode与equals方法的返回结果。规则如下：
 先判断新元素与集合内已经有的旧元素的HashCode值
  如果不同，说明是不同元素，添加到集合。
  如果相同，再判断equals比较结果。返回true则相同元素；返回false则不同元素，添加到集合。
 所以，使用HashSet存储自定义类型，如果没有重写该类的hashCode与equals方法，则判断重复时，使用的是地址值，如果想通过内容比较元素是否相同，需要重写该元素类的hashcode与equals方法。</code></pre><p>###18hashCode和equals方法的面试题<br> A:hashCode和equals的面试题<br> /*</p>
<ul>
<li><p>两个对象  Person  p1 p2</p>
</li>
<li><p>问题: 如果两个对象的哈希值相同 p1.hashCode()==p2.hashCode()</p>
</li>
<li><p>两个对象的equals一定返回true吗  p1.equals(p2) 一定是true吗</p>
</li>
<li><p>正确答案:不一定</p>
</li>
<li></li>
<li><p>如果两个对象的equals方法返回true,p1.equals(p2)==true</p>
</li>
<li><p>两个对象的哈希值一定相同吗</p>
</li>
<li><p>正确答案: 一定<br>*/<br>在 Java 应用程序执行期间，<br>1.如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。<br>2.如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不 要求一定生成不同的整数结果。 </p>
<p>两个对象不同(对象属性值不同) equals返回false=====&gt;两个对象调用hashCode()方法哈希值相同</p>
<p>两个对象调用hashCode()方法哈希值不同=====&gt;equals返回true</p>
</li>
</ul>
<pre><code>两个对象不同(对象属性值不同) equals返回false=====&gt;两个对象调用hashCode()方法哈希值不同

两个对象调用hashCode()方法哈希值相同=====&gt;equals返回true</code></pre><p>   所以说两个对象哈希值无论相同还是不同,equals都可能返回true</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day18%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day18%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记18</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:10:24" itemprop="dateModified" datetime="2020-12-23T23:10:24+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、集合<br>2、Iterator迭代器<br>3、增强for循环<br>4、泛型</p>
<p>=======================第一节课开始=============================================</p>
<p>###01集合使用的回顾<br>     *A:集合使用的回顾<br>       *a.ArrayList集合存储5个int类型元素<br>          public static void main(String[] args) {<br>               ArrayList<Integer> list = new ArrayList<Integer>();<br>            list.add(111);<br>            list.add(222);<br>            list.add(333);<br>            list.add(444);<br>            list.add(555);<br>            for(int i=0; i&lt;list.size(); i++){<br>                   System.out.println(list.get(i));<br>           }<br>          }</Integer></Integer></p>
<pre><code>*b.ArrayList集合存储5个Person类型元素
   public static void main(String[] args) {
    ArrayList&lt;Person&gt; list = new ArrayList&lt;Person&gt;();
    list.add(new Person(“小强”));
    list.add(new Person(“老王”));
    list.add(new Person(“小虎”));
    list.add(new Person(“小泽”));
    list.add(new Person(“小红”));
    for(int i=0; i&lt;list.size(); i++){
      Person p = list.get(i);
            System.out.println(p);
     }
   }</code></pre><p>###02集合的学习目标<br>       集合，集合是java中提供的一种容器，可以用来存储多个数据。<br>     在前面的学习中，我们知道数据多了，可以使用数组存放或者使用ArrayList集合进行存放数据。那么，集合和数组既然都是容器，它们有啥区别呢？<br>       数组的长度是固定的。集合的长度是可变的。<br>       集合中存储的元素必须是引用类型数据</p>
<p>###03集合继承关系图<br>    A:集合继承关系图<br>     a:ArrayList的继承关系:<br>     查看ArrayList类发现它继承了抽象类AbstractList同时实现接口List，而List接口又继承了Collection接口。Collection接口为最顶层集合接口了。<br>     源代码：<br>      interface List extends Collection {<br>      }<br>      public class ArrayList extends AbstractList implements List{<br>      }</p>
<pre><code>b:集合继承体系
 这说明我们在使用ArrayList类时，该类已经把所有抽象方法进行了重写。那么，实现Collection接口的所有子类都会进行方法重写。
   Collecton接口常用的子接口有：List接口、Set接口
   List接口常用的子类有：ArrayList类、LinkedList类
   Set接口常用的子类有：HashSet类、LinkedHashSet类

                          Collection 接口     
                               |
 ----------------------------------------------------------------
 |                                                              |
List接口                                                       Set接口
 |                                                              |</code></pre><hr>
<p> |              |                                             |            |<br>ArrayList类    LinkedList类                                 HashSet类     LinkedHashSet类</p>
<p>###04集合Collection的方法<br>    A:集合Collection的方法<br>     /*<br>      *  Collection接口中的方法<br>      *  是集合中所有实现类必须拥有的方法<br>      *  使用Collection接口的实现类,程序的演示<br>      *  ArrayList implements List<br>      *  List extends Collection<br>      *  方法的执行,都是实现的重写<br>      */<br>     public class CollectionDemo {<br>      public static void main(String[] args) {<br>        function_2();<br>      }</p>
<p>​<br>      /*  Collection接口方法<br>       *  Object[] toArray() 集合中的元素,转成一个数组中的元素, 集合转成数组<br>       *  返回是一个存储对象的数组, 数组存储的数据类型是Object<br>       */<br>      private static void function_2() {<br>        Collection<String> coll = new ArrayList<String>();<br>        coll.add(“abc”);<br>        coll.add(“itcast”);<br>        coll.add(“itheima”);<br>        coll.add(“money”);<br>        coll.add(“123”);</String></String></p>
<pre><code>   Object[] objs = coll.toArray();
   for(int i = 0 ; i &lt; objs.length ; i++){
     System.out.println(objs[i]);
   }
 }
 /*
  * 学习Java中三种长度表现形式
  *   数组.length 属性  返回值 int
  *   字符串.length() 方法,返回值int
  *   集合.size()方法, 返回值int
  */

 /*
  * Collection接口方法
  * boolean contains(Object o) 判断对象是否存在于集合中,对象存在返回true
  * 方法参数是Object类型
  */
 private static void function_1() {
   Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();
   coll.add(&quot;abc&quot;);
   coll.add(&quot;itcast&quot;);
   coll.add(&quot;itheima&quot;);
   coll.add(&quot;money&quot;);
   coll.add(&quot;123&quot;);

   boolean b = coll.contains(&quot;itcast&quot;);
   System.out.println(b);
 }


 /*
  * Collection接口的方法
  * void clear() 清空集合中的所有元素
  * 集合容器本身依然存在
  */
 public static void function(){
   //接口多态的方式调用
   Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();
   coll.add(&quot;abc&quot;);
   coll.add(&quot;bcd&quot;);
   System.out.println(coll);

   coll.clear();

   System.out.println(coll);

 }
}</code></pre><p>###05集合Collection的remove方法<br>   A:05集合Collection的remove方法<br>    /*<br>     * Collection接口方法<br>     * boolean remove(Object o)移除集合中指定的元素<br>     */<br>    private static void function_3(){<br>      Collection<String> coll = new ArrayList<String>();<br>      coll.add(“abc”);<br>      coll.add(“money”);<br>      coll.add(“itcast”);<br>      coll.add(“itheima”);<br>      coll.add(“money”);<br>      coll.add(“123”);<br>      System.out.println(coll);</String></String></p>
<pre><code>  boolean b = coll.remove(&quot;money&quot;);
  System.out.println(b);
  System.out.println(coll);
}</code></pre><p>=======================第二节课开始=============================================<br>###06迭代器的概述<br>  A:迭代器概述:<br>   a:java中提供了很多个集合，它们在存储元素时，采用的存储方式不同。<br>    我们要取出这些集合中的元素，可通过一种通用的获取方式来完成。</p>
<p>   b:Collection集合元素的通用获取方式：在取元素之前先要判断集合中有没有元素，<br>  如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</p>
<p>   c:每种集合的底层的数据结构不同,例如ArrayList是数组,LinkedList底层是链表,但是无论使用那种集合,我们都会有判断是否有元素<br>     以及取出里面的元素的动作,那么Java为我们提供一个迭代器定义了统一的判断元素和取元素的方法 </p>
<p>###07迭代器的实现原理<br>   <em>A:迭代器的实现原理<br>      /</em><br>     *  集合中的迭代器:<br>     *    获取集合中元素方式<br>     *  接口 Iterator : 两个抽象方法<br>     *     boolean hasNext() 判断集合中还有没有可以被取出的元素,如果有返回true<br>     *     next() 取出集合中的下一个元素<br>     *<br>     *  Iterator接口,找实现类.<br>     *    Collection接口定义方法<br>     *       Iterator  iterator()<br>     *    ArrayList 重写方法 iterator(),返回了Iterator接口的实现类的对象<br>     *    使用ArrayList集合的对象<br>     *     Iterator it =array.iterator(),运行结果就是Iterator接口的实现类的对象<br>     *     it是接口的实现类对象,调用方法 hasNext 和 next 集合元素迭代<br>     */</p>
<p>###08迭代器的代码实现<br>   *A:迭代器的代码实现<br>      public class IteratorDemo {<br>        public static void main(String[] args) {<br>          Collection<String> coll = new ArrayList<String>();<br>          coll.add(“abc1”);<br>          coll.add(“abc2”);<br>          coll.add(“abc3”);<br>          coll.add(“abc4”);<br>          //迭代器,对集合ArrayList中的元素进行取出</String></String></p>
<pre><code>//调用集合的方法iterator()获取出,Iterator接口的实现类的对象
Iterator&lt;String&gt; it = coll.iterator();
//接口实现类对象,调用方法hasNext()判断集合中是否有元素
//boolean b = it.hasNext();
//System.out.println(b);
//接口的实现类对象,调用方法next()取出集合中的元素
//String s = it.next();
//System.out.println(s);

//迭代是反复内容,使用循环实现,循环的条件,集合中没元素, hasNext()返回了false
while(it.hasNext()){
  String s = it.next();
  System.out.println(s);
}</code></pre><p>​<br>​<br>        }<br>      }<br>###09迭代器的执行过程<br>   A:迭代器的执行过程<br>     a:迭代器的原理:<br>       while(it.hasNext()) {<br>            System.out.println(it.next());<br>       }</p>
<pre><code>  //cursor记录的索引值不等于集合的长度返回true,否则返回false
    public boolean hasNext() {       
      return cursor != size; //cursor初值为0

    }

   //next()方法作用:
   //①返回cursor指向的当前元素 
   //②cursor++
   public Object next() {            
            int i = cursor; 
            cursor = i + 1;  
            return  elementData[lastRet = i]; 

        }
b:for循环迭代写法:
   for (Iterator&lt;String&gt; it2 = coll.iterator(); it2.hasNext();  ) {
    System.out.println(it2.next());
  } </code></pre><p>###10集合迭代中的转型<br>   A:集合迭代中的转型<br>     a:在使用集合时，我们需要注意以下几点：<br>       集合中存储其实都是对象的地址。<br>       集合中可以存储基本数值吗？jdk1.5版本以后可以存储了。<br>         因为出现了基本类型包装类，它提供了自动装箱操作（基本类型对象），这样，集合中的元素就是基本数值的包装类对象。</p>
<pre><code>b:存储时提升了Object。取出时要使用元素的特有内容，必须向下转型。
 Collection coll = new ArrayList();
 coll.add(&quot;abc&quot;);
 coll.add(&quot;aabbcc&quot;);
 coll.add(&quot;shitcast&quot;);
 Iterator it = coll.iterator();
 while (it.hasNext()) {
  //由于元素被存放进集合后全部被提升为Object类型
 //当需要使用子类对象特有方法时，需要向下转型
  String str = (String) it.next();
  System.out.println(str.length());
 }
 注意：如果集合中存放的是多个对象，这时进行向下转型会发生类型转换异常。</code></pre><p>​<br>    c:Iterator接口也可以使用&lt;&gt;来控制迭代元素的类型的。代码演示如下：<br>     Collection<String> coll = new ArrayList<String>();<br>     coll.add(“abc”);<br>     coll.add(“aabbcc”);<br>     coll.add(“shitcast”);<br>     Iterator<String> it = coll.iterator();<br>     while (it.hasNext()) {<br>      String str =  it.next();<br>     //当使用Iterator<String>控制元素类型后，就不需要强转了。获取到的元素直接就是String类型<br>      System.out.println(str.length());<br>     }</String></String></String></String></p>
<p>=========================第三节课开始====================================<br>###11增强for循环遍历数组<br>   <em>A:增强for循环遍历数组<br>     a:格式:<br>     /</em><br>      *  JDK1.5新特性,增强for循环<br>      *  JDK1.5版本后,出现新的接口 java.lang.Iterable<br>      *    Collection开是继承Iterable<br>      *    Iterable作用,实现增强for循环<br>      *<br>      *    格式:<br>      *      for( 数据类型  变量名 : 数组或者集合 ){<br>      *         sop(变量);<br>      *      }<br>      */<br>     public static void function_1(){<br>        //for对于对象数组遍历的时候,能否调用对象的方法呢<br>        String[] str = {“abc”,”itcast”,”cn”};<br>        for(String s : str){<br>          System.out.println(s.length());<br>        }<br>      }</p>
<pre><code>/*
 *  实现for循环,遍历数组
 *  好处: 代码少了,方便对容器遍历
 *  弊端: 没有索引,不能操作容器里面的元素
 */
public static void function(){
  int[] arr = {3,1,9,0};
  for(int i : arr){
    System.out.println(i+1);
  }
  System.out.println(arr[0]);
}</code></pre><p>###12增强for循环遍历集合<br>      A:增强for循环遍历集合<br>        /*<br>         *  增强for循环遍历集合<br>         *  存储自定义Person类型<br>         */<br>        public static void function_2(){<br>          ArrayList<Person> array = new ArrayList<Person>();<br>          array.add(new Person(“a”,20));<br>          array.add(new Person(“b”,10));<br>          for(Person p : array){<br>            System.out.println(p);// System.out.println(p.toString());<br>          }<br>        }</Person></Person></p>
<p>###13泛型的引入<br>   A:泛型的引入<br>    在前面学习集合时，我们都知道集合中是可以存放任意对象的，<br>    只要把对象存储集合后，那么这时他们都会被提升成Object类型。<br>    当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。比如下面程序：<br>    public class GenericDemo {<br>      public static void main(String[] args) {<br>        List list = new ArrayList();<br>        list.add(“abc”);<br>        list.add(“itcast”);<br>        list.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放<br>                    //相当于:Object obj=new Integer(5);</p>
<pre><code>    Iterator it = list.iterator();
    while(it.hasNext()){
      //需要打印每个字符串的长度,就要把迭代出来的对象转成String类型
      String str = (String) it.next();//String str=(String)obj;
                                      //编译时期仅检查语法错误,String是Object的儿子可以向下转型
                                      //运行时期String str=(String)(new Integer(5))
                                      //String与Integer没有父子关系所以转换失败
                                      //程序在运行时发生了问题java.lang.ClassCastException
      System.out.println(str.length());
    }
  }
}</code></pre><p>​    </p>
<p>###14泛型的定义和使用<br>  A:泛型的定义和使用<br>    /*<br>     * JDK1.5 出现新的安全机制,保证程序的安全性<br>     *   泛型: 指明了集合中存储数据的类型  &lt;数据类型&gt;<br>     */</p>
<pre><code>public class GenericDemo {
  public static void main(String[] args) {
    function();
  }

  public static void function(){
    Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();
    coll.add(&quot;abc&quot;);
    coll.add(&quot;rtyg&quot;);
    coll.add(&quot;43rt5yhju&quot;);
//    coll.add(1);

    Iterator&lt;String&gt; it = coll.iterator();
    while(it.hasNext()){
      String s = it.next();
      System.out.println(s.length());
    }
  }
}</code></pre><p>###15Java中的伪泛型<br>     A:Java中的伪泛型：<br>       泛型只在编译时存在,编译后就被擦除,在编译之前我们就可以限制集合的类型,起到作用<br>     例如:ArrayList<String> al=new ArrayList<String>();<br>     编译后:ArrayList al=new ArrayList();</String></String></p>
<p>================================第四节课开始======================================================<br>###16泛型类<br>  A:泛型类:<br>    a:定义格式：<br>      修饰符 class 类名&lt;代表泛型的变量&gt; {  }</p>
<pre><code>  例如，API中的ArrayList集合：
  class ArrayList&lt;E&gt;{ 
       public boolean add(E e){ }
    public E get(int index){  }
  }

b:使用格式：
  创建对象时，确定泛型的类型

  例如，ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
  此时，变量E的值就是String类型
  class ArrayList&lt;String&gt;{ 
    public boolean add(String e){ }
    public String get(int index){  }
  }

  例如，ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
  此时，变量E的值就是Integer类型
  class ArrayList&lt;Integer&gt;{ 
       public boolean add(Integer e){ }
       public Integer get(int index){  }
  }</code></pre><p>###17泛型的方法<br>  A:泛型的方法<br>    a:定义格式：修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数){  }<br>    b:泛型方法的使用:<br>     1:例如，API中的ArrayList集合中的方法：<br>      public <T> T[] toArray(T[] a){  }<br>      //该方法，用来把集合元素存储到指定数据类型的数组中，返回已存储集合元素的数组</T></p>
<pre><code>  使用格式：调用方法时，确定泛型的类型
例如:
      ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
      String[] arr = new String[100];
      String[] result = list.toArray(arr);
   此时，变量T的值就是String类型。变量T，可以与定义集合的泛型不同
   public &lt;String&gt; String[] toArray(String[] a){  } 


  例如:
      ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
      Integer[] arr = new Integer[100];
      Integer [] result = list.toArray(arr);

  此时，变量T的值就是Integer类型。变量T，可以与定义集合的泛型不同
  public &lt;Integer&gt; Integer[] toArray(Integer[] a){  } </code></pre><p>###18泛型的接口<br>   A:泛型的接口:<br>     /*<br>      *  带有泛型的接口<br>      *<br>      *  public interface List <E>{<br>      *    abstract boolean add(E e);<br>      *  }<br>      *<br>      *  实现类,先实现接口,不理会泛型<br>      *  public class ArrayList<E> implements List<E>{<br>      *  }<br>      *  调用者 : new ArrayList<String>() 后期创建集合对象的时候,指定数据类型<br>      *<br>      *<br>      *  实现类,实现接口的同时,也指定了数据类型<br>      *  public class XXX implements List<String>{<br>      *  }<br>      *  new XXX()<br>      */<br>     public class GenericDemo2 {</String></String></E></E></E></p>
<pre><code>}</code></pre><p>###19泛型的好处<br>  A:泛型的好处<br>    a:将运行时期的ClassCastException，转移到了编译时期变成了编译失败。<br>    b:避免了类型强转的麻烦。<br>    演示下列代码：<br>    public class GenericDemo {<br>      public static void main(String[] args) {<br>        List<String> list = new ArrayList<String>();<br>        list.add(“abc”);<br>        list.add(“itcast”);<br>        //list.add(5);//当集合明确类型后，存放类型不一致就会编译报错<br>                     //集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</String></String></p>
<pre><code>    Iterator&lt;String&gt; it = list.iterator();
    while(it.hasNext()){
       String str = it.next();
       System.out.println(str.length()); //当使用Iterator&lt;String&gt;      
                                        //控制元素类型后，就不需要强转了。获取到的元素直接就是String类型
    }
  }
}</code></pre><p>###20泛型的通配符<br>   A:泛型的通配符<br>   /*<br>    *  泛型的通配符<br>    */<br>   public class GenericDemo {<br>    public static void main(String[] args) {<br>      ArrayList<String> array = new ArrayList<String>();</String></String></p>
<pre><code>  HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();

  array.add(&quot;123&quot;);
  array.add(&quot;456&quot;);

  set.add(789);
  set.add(890);

  iterator(array);
  iterator(set);
}
/*
 *  定义方法,可以同时迭代2个集合
 *  参数: 怎么实现 , 不能写ArrayList,也不能写HashSet
 *  参数: 或者共同实现的接口
 *  泛型的通配,匹配所有的数据类型  ?
 */
public static void iterator(Collection&lt;?&gt; coll){
  Iterator&lt;?&gt; it = coll.iterator();
  while(it.hasNext()){
    //it.next()获取的对象,什么类型
    System.out.println(it.next());
  }
}</code></pre><p>   }</p>
<p>###21泛型的限定<br> A:泛型的限定<br>   /*<br>    *  将的酒店员工,厨师,服务员,经理,分别存储到3个集合中<br>    *  定义方法,可以同时遍历3集合,遍历三个集合的同时,可以调用工作方法<br>    */<br>   import java.util.ArrayList;<br>   import java.util.Iterator;<br>   public class GenericTest {<br>    public static void main(String[] args) {<br>      //创建3个集合对象<br>      ArrayList<ChuShi> cs = new ArrayList<ChuShi>();<br>      ArrayList<FuWuYuan> fwy = new ArrayList<FuWuYuan>();<br>      ArrayList<JingLi> jl = new ArrayList<JingLi>();</JingLi></JingLi></FuWuYuan></FuWuYuan></ChuShi></ChuShi></p>
<pre><code>//每个集合存储自己的元素
cs.add(new ChuShi(&quot;张三&quot;, &quot;后厨001&quot;));
cs.add(new ChuShi(&quot;李四&quot;, &quot;后厨002&quot;));

fwy.add(new FuWuYuan(&quot;翠花&quot;, &quot;服务部001&quot;));
fwy.add(new FuWuYuan(&quot;酸菜&quot;, &quot;服务部002&quot;));

jl.add(new JingLi(&quot;小名&quot;, &quot;董事会001&quot;, 123456789.32));
jl.add(new JingLi(&quot;小强&quot;, &quot;董事会002&quot;, 123456789.33));</code></pre><p>   //   ArrayList<String> arrayString = new ArrayList<String>();<br>      iterator(jl);<br>      iterator(fwy);<br>      iterator(cs);</String></String></p>
<pre><code>}
/*
 * 定义方法,可以同时遍历3集合,遍历三个集合的同时,可以调用工作方法 work
 * ? 通配符,迭代器it.next()方法取出来的是Object类型,怎么调用work方法
 * 强制转换:  it.next()=Object o ==&gt; Employee
 * 方法参数: 控制,可以传递Employee对象,也可以传递Employee的子类的对象
 * 泛型的限定  本案例,父类固定Employee,但是子类可以无限?
 *   ? extends Employee 限制的是父类, 上限限定, 可以传递Employee,传递他的子类对象
 *   ? super   Employee 限制的是子类, 下限限定, 可以传递Employee,传递他的父类对象
 */
public static void iterator(ArrayList&lt;? extends Employee&gt; array){

   Iterator&lt;? extends Employee&gt; it = array.iterator();
   while(it.hasNext()){
     //获取出的next() 数据类型,是什么Employee
     Employee e = it.next();
     e.work();
   }
}</code></pre><p>   }</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day17%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day17%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记17</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:10:12" itemprop="dateModified" datetime="2020-12-23T23:10:12+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、基本类型包装类<br>2、System类<br>3、Math类<br>4、Arrays类<br>5、大数据运算</p>
<p>=======================第一节课开始=============================================</p>
<p>###01基本数据类型对象包装类概述<br>     *A:基本数据类型对象包装类概述<br>       *a.基本类型包装类的产生<br>           在实际程序使用中，程序界面上用户输入的数据都是以字符串类型进行存储的。而程序开发中，我们需要把字符串数据，根据需求转换成指定的基本数据类型，如年龄需要转换成int类型，考试成绩需要转换成double类型等<br>       *b.八种基本类型对应的包装类<br>           char    Character<br>           int     Integer<br>           byte    Byte<br>           short   Short<br>           long    Long<br>           float   Float<br>           double  Double<br>           boolean Boolean</p>
<p>###02Integer类parseInt方法<br>       *A:Integer类parseInt方法:<br>        *a:parseInt()<br>            int i = Integer.parseInt(“12”);<br>            System.out.println(i/2);//6</p>
<pre><code>*b:parseInt(String s, int radix)
    /*
      * Integer类静态方法parseInt(String s, int radix)
      * radix基数,进制
      * &quot;110&quot;,2 含义 前面的数字是二进制的,但是方法parseInt运行结果都是十进制
      *  指定进制的字符串转换为十进制的整数
      */
     public static void function_1(){
         int i = Integer.parseInt(&quot;110&quot;, 2);
         System.out.println(i);
     }</code></pre><p>###03Integer类int转成字符串<br>    *A:Integer类int转成字符串:<br>       *a:使用+与字符串拼接<br>            int i = 3;<br>              String s = i+””;<br>              System.out.println(s+1);//“31”</p>
<pre><code>*b:toString(int ,int 进制),任意进制整数转成任意进制的字符串 (了解)
       String s1 = Integer.toString(5,2);
       System.out.println(s1);</code></pre><p>###04Integer类构造方法<br>     <em>A:Integer类构造方法<br>        /</em><br>         *  Integer类构造方法<br>         *   Integer (String s)<br>         *   将数字格式的字符串,传递到Integer类的构造方法中<br>         *   创建Integer对象,包装的是一个字符串<br>         *   将构造方法中的字符串,转成基本数据类型,调用方法,非静态的, intValue()<br>         */<br>        public static void function_3(){<br>            Integer in = new Integer(“100”);<br>            int i = in.intValue();<br>            System.out.println(–i);//99<br>        }</p>
<p>###05Integer类其他方法<br>   <em>A:Integer类其他方法<br>         /</em><br>         * Integer类的3个静态方法<br>         * 做进制的转换<br>         * 十进制转成二进制  toBinarString(int)<br>         * 十进制转成八进制  toOctalString(int)<br>         * 十进制转成十六进制 toHexString(int)<br>         * 三个方法,返回值都是以String形式出现<br>         <em>/<br>          a:十进制转二,八,十六进制<br>              public static void function_1(){<br>                    System.out.println(Integer.toBinaryString(99));<br>                    System.out.println(Integer.toOctalString(99));<br>                    System.out.println(Integer.toHexString(999));<br>              }<br>          b:获取int的最大值和最小值<br>          /</em><br>           *   Integer类的静态成员变量<br>           *   MAX_VALUE<br>           *   MIN_VALUE<br>           */<br>          public static void function(){<br>              System.out.println(Integer.MAX_VALUE);<br>              System.out.println(Integer.MIN_VALUE);<br>          }</p>
<p>###06自动装箱和自动拆箱<br>  *A:自动装箱与自动拆箱:<br>    //JDK1.5新特性<br>    //自动装箱,拆箱的 好处: 基本类型和引用类直接运算<br>    //自动装箱:使用Integer.valueOf(整数值)返回一个封装了该整数值的Integer对象<br>    //自动拆箱:使用Integer对象.intValue()返回Integer对象中封装的整数值<br>    public static void function(){<br>        //引用类型 , 引用变量一定指向对象<br>        //自动装箱, 基本数据类型1, 直接变成了对象</p>
<pre><code>    Integer in = 1; // Integer in = new Integer(1)
    //in 是引用类型,不能和基本类型运算, 自动拆箱,引用类型in,转换基本类型

    //in+1  ==&gt; in.inValue()+1 = 2    
    //in = 2    自动装箱
    in = in + 1;

    System.out.println(in);

}</code></pre><p>###07自动装箱和自动拆箱练习题<br>   *A:自动装箱与自动拆箱:<br>        Integer i = new Integer(1);<br>         Integer j = new Integer(1);<br>         System.out.println(i==j);// false 对象地址<br>         System.out.println(i.equals(j));// true  继承Object重写equals,比较的对象数据</p>
<pre><code>System.out.println(&quot;===================&quot;);

Integer a = 500;//Integer integer=Integer.valueOf(500)
                //integer=new Integer(500);
Integer b = 500;
System.out.println(a==b);//false
System.out.println(a.equals(b));//true

System.out.println(&quot;===================&quot;);</code></pre><p>​<br>         //数据在byte(-128~127)范围内,JVM不会从新new对象<br>         Integer aa = 127; // Integer aa = new Integer(127)<br>         Integer bb = 127; // Integer bb = aa;<br>         System.out.println(aa==bb); //true<br>         System.out.println(aa.equals(bb));//true</p>
<p>=========================第二节课开始====================================<br>###08System类方法currentTimeMillis<br>   <em>A:System类方法currentTimeMillis():用于计算程序的执行时间<br>        /</em><br>           *  获取系统当前毫秒值<br>           *  static long currentTimeMillis()<br>           *  对程序执行时间测试<br>           */<br>          public static void function(){<br>              long start = System.currentTimeMillis();//当前时间x-1970年1月1日零时零分零秒<br>              for(int i = 0 ; i &lt; 10000; i++){<br>                  System.out.println(i);<br>              }<br>              long end = System.currentTimeMillis();//当前时间y-1970年1月1日零时零分零秒<br>              System.out.println(end - start);//当前时间y-当前时间x<br>          }</p>
<p>###09System类方法exit<br>     <em>A:System类方法exit()方法<br>             /</em><br>              *  退出虚拟机,所有程序全停止<br>              *  static void exit(0)<br>              */<br>             public static void function_1(){<br>                 while(true){<br>                     System.out.println(“hello”);<br>                     System.exit(0);//该方法会在以后的finally代码块中使用(讲到再说)<br>                 }<br>             }<br>###10System类方法gc<br>   A:System类方法gc<br>        public class Person {<br>            public void finalize(){<br>                System.out.println(“垃圾收取了”);<br>            }<br>        }</p>
<pre><code>/*
  *  JVM在内存中,收取对象的垃圾
  *  当没有更多引用指向该对象时,会自动调用垃圾回收机制回收堆中的对象
  *  同时调用回收对象所属类的finalize方法()
  *  static void gc()
  */
 public static void function_2(){
     new Person();
     new Person();
     new Person();
     new Person();
     new Person();
     new Person();
     new Person();
     new Person();
     System.gc();
 }</code></pre><p>###11System类方法getProperties<br>  A:System类方法getProperties(了解)<br>     /*<br>      *  获取当前操作系统的属性:例如操作系统名称,<br>      *  static Properties getProperties()<br>      */<br>     public static void function_3(){<br>         System.out.println( System.getProperties() );<br>     }</p>
<p>###12System类方法arraycopy<br>     A:System类方法arraycopy：<br>      /*<br>       * System类方法,复制数组<br>       * arraycopy(Object src, int srcPos, Object dest, int destPos, int length)<br>       * Object src, 要复制的源数组<br>       * int srcPos, 数组源的起始索引<br>       * Object dest,复制后的目标数组<br>       * int destPos,目标数组起始索引<br>       * int length, 复制几个<br>       */<br>      public static void function_4(){<br>          int[] src = {11,22,33,44,55,66};<br>          int[] desc = {77,88,99,0};</p>
<pre><code>    System.arraycopy(src, 1, desc, 1, 2);//将src数组的1位置开始(包含1位置)的两个元素,拷贝到desc的1,2位置上
    for(int i = 0 ;  i &lt; desc.length ; i++){
        System.out.println(desc[i]);
    }
}</code></pre><p>================================第三节课开始======================================================<br>###13Math类的方法_1<br>   A:Math类中的方法<br>   /*<br>        * static double sqrt(double d)<br>        * 返回参数的平方根<br>           */<br>          public static void function_4(){<br>              double d = Math.sqrt(-2);<br>              System.out.println(d);<br>          }</p>
<pre><code>/*0
 * static double pow(double a, double b)
 * a的b次方
    */
   public static void function_3(){
       double d = Math.pow(2, 3);
       System.out.println(d);
   }

/*
 * static double floor(double d)
 * 返回小于或者等于参数d的最大整数
    */
   public static void function_2(){
       double d = Math.floor(1.5);
       System.out.println(d);
   }

/*
 *  static double ceil(double d)
 *  返回大于或者等于参数d的最小整数
    */
   public static void function_1(){
       double d = Math.ceil(5.1);
       System.out.println(d);
   }

/*
 *  static int abs(int i)
 *  获取参数的绝对值
    */
    public static void function(){
       int i = Math.abs(0);
       System.out.println(i);
    }</code></pre><p>###14Math类的方法_2<br> A:Math类的方法_2<br>  /*</p>
<ul>
<li><p>static double round(doubl d)</p>
</li>
<li><p>获取参数的四舍五入,取整数<br>*/<br>public static void function_6(){<br>  double d = Math.round(5.4195);<br>  System.out.println(d);<br>}</p>
<p>/*</p>
</li>
<li><p>static double random() 返回随机数 0.0-1.0之间</p>
</li>
<li><p>来源,也是Random类<br>*/<br>public static void function_5(){<br>  for(int i = 0 ; i &lt; 10 ;i++){</p>
<pre><code>double d = Math.random();
System.out.println(d);</code></pre><p>  }<br>}</p>
</li>
</ul>
<p>###15Arrays工具类<br>  A:Arrays工具类:<br>    public class ArraysDemo {<br>        public static void main(String[] args) {<br>            function_2();<br>            int[] arr = {56,65,11,98,57,43,16,18,100,200};<br>            int[] newArray = test(arr);<br>            System.out.println(Arrays.toString(newArray));<br>        }<br>        /*<br>         *  定义方法,接收输入,存储的是10个人考试成绩<br>         *  将最后三个人的成绩,存储到新的数组中,返回新的数组<br>         */<br>        public static int[] test(int[] arr){<br>            //对数组排序<br>            Arrays.sort(arr);<br>            //将最后三个成绩存储到新的数组中<br>            int[] result = new int[3];<br>            //成绩数组的最后三个元素,复制到新数组中<br>        //    System.arraycopy(arr, 0, result, 0, 3);<br>            for(int i = 0 ;  i &lt; 3 ;i++){<br>                result[i] = arr[i];<br>            }<br>            return result;<br>        }</p>
<pre><code>    /*
     *  static String toString(数组)
     *  将数组变成字符串
     */
    public static void function_2(){
        int[] arr = {5,1,4,6,8,9,0};
        String s = Arrays.toString(arr);
        System.out.println(s);
    }

    /*
     *  static int binarySearch(数组, 被查找的元素)
     *  数组的二分搜索法
     *  返回元素在数组中出现的索引
     *  元素不存在, 返回的是  (-插入点-1)
     */
    public static void function_1(){
        int[] arr = {1,4,7,9,11,15,18};
        int index =  Arrays.binarySearch(arr, 10);
        System.out.println(index);
    }

    /*
     *  static void sort(数组)
     *  对数组升序排列
     */
    public static void function(){
        int[] arr = {5,1,4,6,8,9,0};
        Arrays.sort(arr);
        for (int i = 0; i &lt; arr.length; i++) {
            System.out.println(arr[i]);
        }
    }
}</code></pre><p>###16数组复制练习<br>   <em>A:数组复制练习:<br>        public static void main(String[] args) {<br>                int[] arr = {56,65,11,98,57,43,16,18,100,200};<br>                int[] newArray = test(arr);<br>                System.out.println(Arrays.toString(newArray));<br>            }<br>            /</em><br>             *  定义方法,接收输入,存储的是10个人考试成绩<br>             *  将最后三个人的成绩,存储到新的数组中,返回新的数组<br>             */<br>            public static int[] test(int[] arr){<br>                //对数组排序<br>                Arrays.sort(arr);<br>                //将最后三个成绩存储到新的数组中<br>                int[] result = new int[3];<br>                //成绩数组的最后三个元素,复制到新数组中<br>                //System.arraycopy(arr, 0, result, 0, 3);<br>                for(int i = 0 ;  i &lt; 3 ;i++){<br>                    result[i] = arr[i];<br>                }<br>                return result;<br>            }</p>
<p>====================第四节课开始============================<br>###17BigInteger类概述和构造方法<br> A:BigInteger类概述和构造方法<br>   public static void main(String[] args) {<br>           function();<br>       }<br>    /*<br>        * BigInteger类的构造方法<br>        * 传递字符串,要求数字格式,没有长度限制<br>           */<br>          public static void function(){<br>              BigInteger b = new BigInteger(“8465846668464684562385634168451684568645684564564”);<br>              System.out.println(b);<br>              BigInteger b1 = new BigInteger(“5861694569514568465846668464684562385634168451684568645684564564”);<br>              System.out.println(b1);<br>          }</p>
<p>###18BigInteger类四则运算<br> A:BigInteger类四则运算<br>    public static void main(String[] args) {<br>           function_1();<br>       }<br>    /*<br>     * BigInteger对象的四则运算<br>     * 调用方法计算,计算结果也只能是BigInteger对象<br>     */<br>     public static void function_1(){<br>         BigInteger b1 = new BigInteger(“5665464516451051581613661405146”);<br>         BigInteger b2 = new BigInteger(“965855861461465516451051581613661405146”);</p>
<pre><code>    //计算 b1+b2对象的和,调用方法 add
    BigInteger bigAdd = b1.add(b2);//965855867126930032902103163227322810292
    System.out.println(bigAdd);

    //计算b1-b2对象的差,调用方法subtract
    BigInteger bigSub = b1.subtract(b2);
    System.out.println(bigSub);

    //计算b1*b2对象的乘积,调用方法multiply
    BigInteger bigMul = b1.multiply(b2);
    System.out.println(bigMul);

    //计算b2/b1对象商,调用方法divied
    BigInteger bigDiv = b2.divide(b1);
    System.out.println(bigDiv);
}</code></pre><p>###19员工案例的子类的编写<br> A:BigDecimal类概述 </p>
<pre><code>/*
 * 计算结果,未知
 * 原因: 计算机二进制中,表示浮点数不精确造成
 * 超级大型的浮点数据,提供高精度的浮点运算, BigDecimal
System.out.println(0.09 + 0.01);//0.09999999999999999
System.out.println(1.0 - 0.32);//0.6799999999999999
System.out.println(1.015 * 100);//101.49999999999999
System.out.println(1.301 / 100);//0.013009999999999999 
*/</code></pre><p>###20BigDecimal类实现加法减法乘法<br> A:BigDecimal类实现加法减法乘法<br>  /*<br>       *  BigDecimal实现三则运算<br>       *  + - *<br>         */<br>        public static void function(){<br>            BigDecimal b1 =  new BigDecimal(“0.09”);<br>            BigDecimal b2 =  new BigDecimal(“0.01”);<br>            //计算b1+b2的和,调用方法add<br>            BigDecimal bigAdd = b1.add(b2);<br>            System.out.println(bigAdd);</p>
<pre><code>    BigDecimal b3 = new BigDecimal(&quot;1&quot;);
    BigDecimal b4 = new BigDecimal(&quot;0.32&quot;);
    //计算b3-b2的差,调用方法subtract
    BigDecimal bigSub = b3.subtract(b4);
    System.out.println(bigSub);

    BigDecimal b5 = new BigDecimal(&quot;1.015&quot;);
    BigDecimal b6 = new BigDecimal(&quot;100&quot;);
    //计算b5*b6的成绩,调用方法 multiply
    BigDecimal bigMul = b5.multiply(b6);
    System.out.println(bigMul);
}</code></pre><p>###21BigDecimal类实现除法<br>     A:BigDecimal类实现除法<br>     /*<br>      * BigDecimal实现除法运算<br>      * divide(BigDecimal divisor, int scale, int roundingMode)<br>      * int scale : 保留几位小数<br>      * int roundingMode : 保留模式<br>      * 保留模式 阅读API文档<br>      *   static int ROUND_UP  向上+1<br>      *   static int ROUND_DOWN 直接舍去<br>      *   static int ROUND_HALF_UP  &gt;= 0.5 向上+1<br>      *   static int ROUND_HALF_DOWN   &gt; 0.5 向上+1 ,否则直接舍去<br>      */<br>     public static void function_1(){<br>         BigDecimal b1 = new BigDecimal(“1.0301”);<br>         BigDecimal b2 = new BigDecimal(“100”);<br>         //计算b1/b2的商,调用方法divied<br>         BigDecimal bigDiv = b1.divide(b2,2,BigDecimal.ROUND_HALF_UP);//0.01301<br>         System.out.println(bigDiv);<br>     }</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day16%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day16%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记16</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:10:01" itemprop="dateModified" datetime="2020-12-23T23:10:01+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、正则表达式的定义及使用<br>2、Date类的用法<br>3、Calendar类的用法</p>
<p>==========================================第一阶段========================================</p>
<p>###01正则表达式的概念和作用<br>    * A: 正则表达式的概念和作用<br>        * a: 正则表达式的概述<br>            * 正则表达式也是一个字符串，用来定义匹配规则，在Pattern类中有简单的规则定义。<br>              可以结合字符串类的方法使用。<br>            * 简单记：正则表达式是具有特殊含义的字符串。<br>        * b: 正则表达式的作用<br>        * 比如注册邮箱,邮箱有用户名和密码,一般会对其限制长度,这个限制长度的事情就是正则表达式做的</p>
<p>​<br>###02正则表达式语法规则<br>    * A: 正则表达式语法规则<br>        * a: 字符<br>            * x  代表的是字符x<br>            * \ 代表的是反斜线字符’&#39;<br>            * \t 代表的是制表符<br>            * \n 代表的是换行符<br>            * \r 代表的是回车符<br>        * b: 字符类<br>            * [abc]    a、b 或 c（简单类）<br>            * [^abc]   任何字符，除了 a、b 或 c（否定）<br>            * [a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围）<br>            * [0-9]    0到9的字符都包括<br>            * [a-zA-Z_0-9] 代表的字母或者数字或者下划线(即单词字符)<br>        * c: 预定义字符类<br>            * . 任何字符。<br>            * \d 数字：[0-9]<br>            * \w 单词字符：[a-zA-Z_0-9]如”com.itheima.tests”/finish<br>        * d: 边界匹配器<br>            * ^  代表的是行的开头<br>            * $  代表的是行的结尾<br>            * \b 代表的是单词边界<br>        * e: 数量词<br>            * X?     X，一次或一次也没有<br>            * X*     X，零次或多次<br>            * X+     X，一次或多次<br>            * X{n}   X，恰好 n 次<br>            * X{n,}  X，至少 n 次<br>            * X{n,m} X，至少 n 次，但是不超过 m 次</p>
<p>###03正则表达式练习和相关的String类方法<br>    * A: 正则表达式练习和相关的String类方法<br>        * a: boolean matches(String 正则的规则)<br>            * “abc”.matches(“[a]”)<br>            * 匹配成功返回true<br>        * b: String[] split(String 正则的规则)<br>            * “abc”.split(“a”)<br>            * 使用规则将字符串进行切割<br>        * c: String replaceAll( String 正则规则,String 字符串)<br>            * “abc0123”.repalceAll(“[\d]”,”#”)<br>            * 按照正则的规则,替换字符串</p>
<p>​<br>###04正则表达式匹配练习<br>    * A: 正则表达式匹配练习<br>        * a: 案例代码<br>            public class RegexDemo {<br>                public static void main(String[] args) {<br>                    checkTel();<br>                }</p>
<p>​<br>                /*<br>                 *  检查手机号码是否合法<br>                 *  1开头 可以是34578  0-9 位数固定11位<br>                 */<br>                public static void checkTel(){<br>                    String telNumber = “1335128005”;<br>                    //String类的方法matches<br>                    boolean b = telNumber.matches(“1[34857][\d]{9}”);<br>                    System.out.println(b);<br>                }</p>
<pre><code>    /*
     *  检查QQ号码是否合法
     *  0不能开头,全数字, 位数5,10位
     *  123456 
     *  \\d  \\D匹配不是数字
     */
    public static void checkQQ(){
        String QQ = &quot;123456&quot;;
        //检查QQ号码和规则是否匹配,String类的方法matches
        boolean b = QQ.matches(&quot;[1-9][\\d]{4,9}&quot;);
        System.out.println(b);
    }
}</code></pre><p>###05正则表达式切割练习<br>    * A: 正则表达式切割练习<br>        * a: 案例代码<br>            public class RegexDemo1 {<br>                public static void main(String[] args) {<br>                    split_1();<br>                    split_2();<br>                    split_3();</p>
<pre><code>    }

    /*
     * String类方法split对字符串进行切割
     * 192.168.105.27 按照 点切割字符串
     */
    public static void split_3(){
        String ip = &quot;192.168.105.27&quot;;
        String[] strArr = ip.split(&quot;\\.&quot;);
        System.out.println(&quot;数组的长度&quot;+strArr.length);
        for(int i = 0 ; i &lt; strArr.length ; i++){
            System.out.println(strArr[i]);
        }
    }

    /*
     * String类方法split对字符串进行切割
     * 18 22 40 65 按照空格切割字符串
     */
    public static void split_2(){
        String str = &quot;18    22     40          65&quot;;
        String[] strArr = str.split(&quot; +&quot;);
        System.out.println(&quot;数组的长度&quot;+strArr.length);
        for(int i = 0 ; i &lt; strArr.length ; i++){
            System.out.println(strArr[i]);
        }
    }

    /*
     *  String类方法split对字符串进行切割
     *  12-25-36-98  按照-对字符串进行切割
     */
    public static void split_1(){
        String str = &quot;12-25-36-98&quot;;
        //按照-对字符串进行切割,String类方法split
        String[] strArr = str.split(&quot;-&quot;);
        System.out.println(&quot;数组的长度&quot;+strArr.length);
        for(int i = 0 ; i &lt; strArr.length ; i++){
            System.out.println(strArr[i]);
        }
    }
}        </code></pre><p>​<br>###06正则表达式替换练习<br>    * A: 正则表达式替换练习<br>        * a: 案例代码<br>            public class RegexDemo1 {<br>                public static void main(String[] args) {<br>                    replaceAll_1();<br>                }</p>
<pre><code>    /*
     * &quot;Hello12345World6789012&quot;将所有数字替换掉
     * String类方法replaceAll(正则规则,替换后的新字符串)
     */
    public static void replaceAll_1(){
        String str = &quot;Hello12345World6789012&quot;;
        str = str.replaceAll(&quot;[\\d]+&quot;, &quot;#&quot;);
        System.out.println(str);
    }
}</code></pre><p>###07正则表达式邮箱地址验证<br>    * A: 正则表达式邮箱地址验证<br>        * a: 案例代码<br>            public class RegexDemo2 {<br>                public static void main(String[] args) {<br>                    checkMail();<br>                }<br>                /*<br>                 *  检查邮件地址是否合法<br>                 *  规则:<br>                 *   <a href="mailto:1234567@qq.com">1234567@qq.com</a><br>                 *   <a href="mailto:mym_ail@sina.com">mym_ail@sina.com</a><br>                 *   <a href="mailto:nimail@163.com">nimail@163.com</a><br>                 *   <a href="mailto:wodemail@yahoo.com.cn">wodemail@yahoo.com.cn</a><br>                 *<br>                 *   @: 前  数字字母_ 个数不能少于1个<br>                 *   @: 后  数字字母     个数不能少于1个<br>                 *   .: 后面 字母<br>                 *<br>                 */<br>                public static void checkMail(){<br>                    String email =”<a href="mailto:abc123@sina.com">abc123@sina.com</a>“;<br>                    boolean b = email.matches(“[a-zA-Z0-9_]+@[0-9a-z]+(\.[a-z]+)+”);<br>                    System.out.println(b);<br>                }<br>            }</p>
<p>###08毫秒值概念<br>    * A: 毫秒值概念<br>        * a: 时间和日期类<br>            * java.util.Date<br>        * b: 毫秒概念<br>            * 1000毫秒=1秒<br>        * c: 毫秒的0点<br>             * System.currentTimeMillis() 返回值long类型参数<br>             * 获取当前日期的毫秒值   3742769374405<br>             * 时间原点; 公元1970年1月1日,午夜0:00:00 英国格林威治  毫秒值就是0<br>             * 时间2088年8月8日<br>             * 时间和日期的计算，必须依赖毫秒值</p>
<p>###09Date类的构造方法<br>    * A: Date类的构造方法<br>        * a: 空参构造<br>            * public Date()<br>        * b: 带参构造<br>            * public Date(long times)</p>
<p>​<br>==============================第二阶段====================================        </p>
<p>​<br>###10Date类的get和set方法<br>    * A：Date类的get和set方法<br>        * public long getTime()<br>            * 将当前的日期对象，转为对应的毫秒值<br>        * public void setTime(long times);<br>            * 根据给定的毫秒值，生成对应的日期对象</p>
<p>###11日期格式化SimpleDateFormat<br>    * A: 日期格式化SimpleDateFormat<br>        * a: 对日期进行格式化(自定义)<br>            * 对日期格式化的类 java.text.DateFormat 抽象类, 普通方法,也有抽象的方法<br>            * 实际使用是子类 java.text.SimpleDateFormat 可以使用父类普通方法,重写了抽象方法<br>        * b: 对日期进行格式化的步骤<br>            * 1: 创建SimpleDateFormat对象<br>                * 在类构造方法中,写入字符串的日期格式 (自己定义)<br>            * 2: SimpleDateFormat调用方法format对日期进行格式化<br>                * public String format(Date date) 传递日期对象,返回字符串<br>                * 日期模式:<br>                 * yyyy    年份<br>                 * MM      月份<br>                * dd      月中的天数<br>                * HH       0-23小时<br>                * mm      小时中的分钟<br>                 * ss      秒<br>                 * yyyy年MM月dd日 HH点mm分钟ss秒  汉字修改,: -  字母表示的每个字段不可以随便写</p>
<p>​<br>###12字符串转成日期对象<br>    * A: 字符串转成日期对象<br>        * a: 使用步骤<br>            * 1: 创建SimpleDateFormat的对象<br>                * 构造方法中,指定日期模式<br>            * 2: 子类对象,调用方法 parse 传递String,返回Date<br>                * 注意: 时间和日期的模式yyyy-MM-dd, 必须和字符串中的时间日期匹配</p>
<p>###13Calendar类_1<br>    * A: Calendar类_1<br>        * a: 日历类(抽象类)<br>            * java.util.Calendar<br>        * b: 创建对象<br>            * Calendar类写了静态方法 getInstance() 直接返回了子类的对象<br>            * 不需要直接new子类的对象,通过静态方法直接获取</p>
<p>###14Calendar类_2<br>    * A: Calendar类_2<br>        * a: 成员方法<br>            * getTime() 把日历对象,转成Date日期对象<br>            * get(日历字段) 获取指定日历字段的值<br>        * b: 代码演示<br>            Calendar c = Calendar.getInstance();<br>            // 获取年份<br>            int year = c.get(Calendar.YEAR);<br>            // 获取月份<br>            int month = c.get(Calendar.MONTH) + 1;<br>            // 获取天数<br>            int day = c.get(Calendar.DAY_OF_MONTH);<br>            System.out.println(year + “年” + month + “月” + day + “日”);</p>
<p>​<br>###15Calendar类_3<br>    * A: Calendar类_3<br>        * a: 成员方法<br>            * set(int field,int value)  设置指定的时间<br>        * b: 代码演示<br>            /*<br>             * Calendar类的set方法 设置日历 set(int field,int value) field 设置的是哪个日历字段 value<br>             * 设置后的具体数值<br>             *<br>             * set(int year,int month,int day) 传递3个整数的年,月,日<br>             */<br>            public static void function_1() {<br>                Calendar c = Calendar.getInstance();<br>                // 设置,月份,设置到10月分<br>                // c.set(Calendar.MONTH, 9);</p>
<pre><code>    // 设置年,月,日
    c.set(2099, 4, 1);

    // 获取年份
    int year = c.get(Calendar.YEAR);
    // 获取月份
    int month = c.get(Calendar.MONTH) + 1;
    // 获取天数
    int day = c.get(Calendar.DAY_OF_MONTH);
    System.out.println(year + &quot;年&quot; + month + &quot;月&quot; + day + &quot;日&quot;);
}</code></pre><p>###16Calendar类_4<br>    * A: Calendar类_4<br>        * a: 成员方法<br>            * add(int field, int value) 进行整数的偏移<br>            * int get(int field) 获取指定字段的值<br>        * b: 案例演示<br>            /*<br>             * Calendar类方法add 日历的偏移量,<br>             * 可以指定一个日历中的字段,<br>             * 进行整数的偏移 add(int field, int value)<br>             */<br>            public static void function_2() {<br>                Calendar c = Calendar.getInstance();<br>                // 让日历中的天数,向后偏移280天<br>                c.add(Calendar.DAY_OF_MONTH, -280);<br>                // 获取年份<br>                int year = c.get(Calendar.YEAR);<br>                // 获取月份<br>                int month = c.get(Calendar.MONTH) + 1;<br>                // 获取天数<br>                int day = c.get(Calendar.DAY_OF_MONTH);<br>                System.out.println(year + “年” + month + “月” + day + “日”);<br>            }</p>
<p>###17日期练习_活了多少天<br>    * A: 日期练习_活了多少天<br>        * a: 案例代码<br>            /*<br>             *  计算活了多少天<br>             *   生日  今天的日期<br>             *   两个日期变成毫秒值,减法<br>             */<br>            public static void function() throws Exception {<br>                System.out.println(“请输入出生日期 格式 YYYY-MM-dd”);<br>                //获取出生日期,键盘输入<br>                String birthdayString = new Scanner(System.in).next();<br>                //将字符串日期,转成Date对象<br>                //创建SimpleDateFormat对象,写日期模式<br>                SimpleDateFormat sdf = new SimpleDateFormat(“yyyy-MM-dd”);<br>                //调用方法parse,字符串转成日期对象<br>                Date birthdayDate = sdf.parse(birthdayString);</p>
<pre><code>    //获取今天的日期对象
    Date todayDate = new Date();

    //将两个日期转成毫秒值,Date类的方法getTime
    long birthdaySecond = birthdayDate.getTime();
    long todaySecond = todayDate.getTime();
    long secone = todaySecond-birthdaySecond;

    if(secone &lt; 0){
        System.out.println(&quot;还没出生呢&quot;);
    }
    else{
    System.out.println(secone/1000/60/60/24);
    }

}</code></pre><p>###18日期练习_闰年计算<br>    * A: 日期练习_闰年计算<br>        * a: 案例代码<br>            /*<br>             *  闰年计算<br>             *  2000 3000<br>             *  高级的算法: 日历设置到指定年份的3月1日,add向前偏移1天,获取天数,29闰年<br>             */<br>            public static void function_1(){<br>                Calendar c = Calendar.getInstance();<br>                //将日历,设置到指定年的3月1日<br>                c.set(2088, 2, 1);<br>                //日历add方法,向前偏移1天<br>                c.add(Calendar.DAY_OF_MONTH, -1);<br>                //get方法获取天数<br>                int day = c.get(Calendar.DAY_OF_MONTH);<br>                System.out.println(day);<br>            }</p>
<p>###19总结</p>
<ul>
<li>把今天的知识点总结一遍。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day15%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day15%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记15</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:08:39" itemprop="dateModified" datetime="2020-12-23T23:08:39+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、Object<br>2、String<br>3、StringBuilder</p>
<p>=======================第一节课开始=============================================</p>
<p>###01API概念</p>
<pre><code>* A:API(Application Programming Interface) 
    * 应用程序编程接口
* B:Java API
    * 就是Java提供给我们使用的类，这些类将底层的实现封装了起来，
    * 我们不需要关心这些类是如何实现的，只需要学习这些类如何使用。
* C: 演示查看Object类中的相关方法</code></pre><p>###02Object类概述<br>    * A:Object类概述<br>        * 类层次结构的根类<br>        * 所有类都直接或者间接的继承自该类<br>        * Object中描述的所有方法子类都可以使用<br>        * 所有类在创建对象的时候，最终找的父类就是Object。<br>    * B:构造方法<br>        * public Object()<br>        * 回想面向对象中为什么说：<br>            * 子类的构造方法默认访问的是父类的无参构造方法</p>
<p>​<br>###03equals方法比较内存地址<br>    * A:equals方法比较内存地址<br>        * a: Object类中的equals方法<br>            * 用于比较两个对象是否相同，Object类中就是使用两个对象的内存地址在比较。<br>            * Object类中的equals方法内部使用的就是==比较运算符。</p>
<pre><code>* b: 案例代码

    public class Person extends Object{
        private String name;
        private int age;

        public Person(){}

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
        /*
         * 将父类的equals方法写过来,重写父类的方法
         * 但是,不改变父类方法的源代码, 方法equals 比较两个对象的内存地址
         *                 
         */
        public boolean equals(Object obj){                    
            return this == obj;
        }        

        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
        public int getAge() {
            return age;
        }
        public void setAge(int age) {
            this.age = age;
        }                 
    }
    //测试代码
    public class TestEquals {
        public static void main(String[] args) {
            //Person类继承Object类,继承下来了父类的方法equals
            Person p1 = new Person(&quot;李四&quot;,20);
            Person p2 = new Person(&quot;张三&quot;,20);</code></pre><p>​<br>                    //Person对象p1,调用父类的方法equals,进行对象的比较<br>                    boolean b = p1.equals(p1);<br>                    System.out.println(b);</p>
<pre><code>    }
}</code></pre><p>###04重写equals方法<br>    * A: 重写equals方法<br>        * a: 开发中要比较两个对象是否相同，经常会根据对象中的属性值进行比较<br>        * b: 在开发经常需要子类重写equals方法根据对象的属性值进行比较。<br>        * c: ==号和equals方法的区别<br>            * ==是一个比较运算符号,既可以比较基本数据类型,也可以比较引用数据类型,基本数据类型比较的是值,引用数据类型比较的是地址值<br>            * equals方法是一个方法,只能比较引用数据类型,所有的对象都会继承Object类中的方法,如果没有重写Object类中的equals方法,<br>                equals方法和==号比较引用数据类型无区别,重写后的equals方法比较的是对象中的属性<br>        * d: 案例代码<br>            public class Person extends Object{<br>                private String name;<br>                private int age;</p>
<pre><code>public Person(){}

public Person(String name, int age) {
    this.name = name;
    this.age = age;
}
/*
 * 重写父类的方法toString()
 * 没有必要让调用者看到内存地址
 * 要求: 方法中,返回类中所有成员变量的值
 */
public String toString(){
    return name + age;
}</code></pre><p>​<br>                /*<br>                 * 将父类的equals方法写过来,重写父类的方法<br>                 * 但是,不改变父类方法的源代码, 方法equals 比较两个对象的内存地址<br>                 *<br>                 * 两个对象,比较地址,没有意义<br>                 * 比较两个对象的成员变量,age<br>                 * 两个对象变量age相同,返回true,不同返回false<br>                 *<br>                 * 重写父类的equals,自己定义自己对象的比较方式<br>                 */<br>                public boolean equals(Object obj){<br>                    if( this == obj){<br>                        return true;<br>                    }</p>
<pre><code>        //对参数obj,非null判断
        if( obj == null){
            return false;
        }

        if( obj instanceof Person){
            // 参数obj接受到是Person对象,才能转型
            // 对obj参数进行类型的向下转型,obj转成Person类型
            Person p = (Person)obj;
            return this.age ==  p.age;
        }
        return false;
    }                

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }                 
}
//测试代码
public class TestEquals {
    public static void main(String[] args) {
        //Person类继承Object类,继承下来了父类的方法equals
        Person p1 = new Person(&quot;李四&quot;,20);
        Person p2 = new Person(&quot;张三&quot;,20);</code></pre><p>​<br>                    //Person对象p1,调用父类的方法equals,进行对象的比较<br>                    boolean b = p1.equals(p1);<br>                    System.out.println(b);</p>
<pre><code>    }
}            </code></pre><p>###05重写toString方法<br>    * A: 重写toString方法<br>        * a: 为什么要重写toString方法<br>            * toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。<br>            * 由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。<br>            * Object类中的toString的核心代码<br>                getClass().getName() + “@” + Integer.toHexString(hashCode())<br>            * 由于默认情况下的数据对我们来说没有意义，一般建议重写该方法。<br>        * b: 案例核心代码(重写Person类中的toString方法)<br>            /*<br>             * 重写父类的方法toString()<br>             * 没有必要让调用者看到内存地址<br>             * 要求: 方法中,返回类中所有成员变量的值<br>             <em>/<br>            public String toString(){<br>                return name + age;<br>            }<br>            //Eclipse中自动生成的toString<br>            @Override<br>            public String toString() {<br>                return “Person [name=” + name + “, age=” + age + “]”;<br>            }<br>            //测试代码<br>            public class TestToString {<br>                public static void main(String[] args) {<br>                    //调用Person类的方法toString()<br>                    //输出语句中,写的是一个对象,默认调用对象的toString方法<br>                    Person p = new Person(“张三”,20);<br>                    String s = p.toString();<br>                    System.out.println(p);<br>                    System.out.println(s);<br>                    /</em><br>                     * System.out.println(p);<br>                     * System.out.println(p.toString());<br>                     */</p>
<pre><code>        /*Random r = new Random();
        System.out.println(r.toString());

        Scanner sc = new Scanner(System.in);
        System.out.println(sc.toString());*/
    }
}</code></pre><p>========================================================第二节课开始===================================================</p>
<p>###06String类的概念和不变性<br>    * A: String类的概念和不变性<br>        * a:String类<br>            * API中的String类的描述，发现String 类代表字符串<br>            * Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。<br>            * 字符串是常量,在创建之后不能更改<br>            * 其实就是说一旦这个字符串确定了，那么就会在内存区域中就生成了这个字符串。字符串本身不能改变，但str变量中记录的地址值是可以改变的。<br>            * 源码分析,String类底层采用的是字符数组:<br>                private final char value[]<br>                private 修饰说明value只能在String类内部使用,而且又没有提供get方法,所以外部无法获取value数组,就无法改变数组中元素的值<br>                final修饰说明value是常量,一旦创建,就不能被改变,value一旦被初始化成某个数组,将永远指向这个数组,不可能再指向其它的数组了</p>
<pre><code>* b: 案例代码
    /*
     *   String类特点:
     *     一切都是对象,字符串事物 &quot;&quot; 也是对象
     *     类是描述事物,String类,描述字符串对象的类
     *     所有的 &quot;&quot; 都是String类的对象
     *     
     *     字符串是一个常量,一旦创建,不能改变
     */
    public class StringDemo {
        public static void main(String[] args) {
            //引用变量str执行内存变化
            //定义好的字符串对象,不变
            String str = &quot;itcast&quot;;
            System.out.println(str);
            str = &quot;itheima&quot;;
            System.out.println(str);</code></pre><p>​<br>                }<br>            }</p>
<p>###07String类创建方式和比较<br>    * A: String类创建方式和比较<br>        * a: 创建对象的数量比较<br>            * String s3 = “abc”;<br>                * 在内存中只有一个对象。这个对象在字符串常量池中<br>            * String s4 = new String(“abc”);<br>                * 在内存中有两个对象。一个new的对象在堆中，一个字符串本身对象，在字符串常量池中<br>        * b: 案例代码<br>            public class StringDemo2 {<br>                public static void main(String[] args) {<br>                    //字符串定义方式2个, 直接=  使用String类的构造方法<br>                    String str1 = new String(“abc”);<br>                    String str2 = “abc”;<br>                    System.out.println(str1);<br>                    System.out.println(str2);</p>
<pre><code>        System.out.println(str1==str2);//引用数据类型,比较对象的地址 false
        System.out.println(str1.equals(str2));//true
    }
}</code></pre><p>###08String类构造方法<br>    * A: String类构造方法<br>        * a: 常见构造方法<br>            * public String():空构造<br>            * public String(byte[] bytes):把字节数组转成字符串<br>            * public String(byte[] bytes,int index,int length):把字节数组的一部分转成字符串<br>            * public String(String original):把字符串常量值转成字符串<br>        * b: 案例代码<br>            public class StringDemo3 {<br>                public static void main(String[] args) {<br>                    function_1();<br>                }<br>                /*<br>                 *  定义方法,String类的构造方法<br>                 *  String(byte[] bytes)  传递字节数组<br>                 *  字节数组转成字符串<br>                 *  通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。<br>                 *  平台 : 机器操作系统<br>                 *  默认字符集: 操作系统中的默认编码表, 默认编码表GBK<br>                 *  将字节数组中的每个字节,查询了编码表,得到的结果<br>                 *  字节是负数,汉字的字节编码就是负数, 默认编码表 ,一个汉字采用2个字节表示<br>                 *<br>                 *  String(byte[] bytes, int offset, int length) 传递字节数组<br>                 *  字节数组的一部分转成字符串<br>                 *  offset 数组的起始的索引<br>                 *  length 个数,转几个   , 不是结束的索引<br>                 */<br>                public static void function(){<br>                    byte[] bytes = {97,98,99,100};<br>                    //调用String类的构造方法,传递字节数组<br>                    String s = new String(bytes);<br>                    System.out.println(s);</p>
<pre><code>        byte[] bytes1 ={65,66,67,68,69};
        //调用String构造方法,传递数组,传递2个int值
        String s1 = new String(bytes1,1,3);
        System.out.println(s1);
    }
}</code></pre><p>###09String类构造方法_2<br>    * A: String类构造方法<br>        * a: 常见构造方法<br>            * public String(char[] value):把字符数组转成字符串<br>            * public String(char[] value,int index,int count):把字符数组的一部分转成字符串<br>    * B: 案例代码<br>         /*<br>          *  String类构造方法<br>          *  String类的构造方法,重载形式<br>          *<br>          <em>/<br>        public class StringDemo3 {<br>            public static void main(String[] args) {<br>                function_1();<br>            }<br>            /</em><br>             * String(char[] value) 传递字符数组<br>             * 将字符数组,转成字符串, 字符数组的参数,不查询编码表<br>             *<br>             * String(char[] value, int offset, int count) 传递字符数组<br>             * 将字符数组的一部分转成字符串<br>             * offset  数组开始索引<br>             * count   个数<br>             */<br>            public static void function_1(){<br>                char[] ch = {‘a’,’b’,’c’,’d’,’e’,’f’};<br>                //调用String构造方法,传递字符数组<br>                String s = new String(ch);<br>                System.out.println(s);</p>
<pre><code>        String s1 = new String(ch,1,4);
        System.out.println(s1);
    }
}</code></pre><p>​<br>###10String类的其他方法<br>    * A：String类的其他方法<br>        * a: 方法介绍<br>            * int length(): 返回字符串的长度<br>            * String substring(int beginIndex,int endIndex): 获取字符串的一部分<br>            * String substring(int beginIndex): 获取字符串的一部分<br>            * boolean startsWith(String prefix): 判断一个字符串是不是另一个字符串的前缀,开头<br>            * boolean endsWith(String prefix): 判断一个字符串是不是另一个字符串的后缀,结尾<br>            * boolean contains (String s): 判断一个字符串中,是否包含另一个字符串<br>            * int indexOf(char ch):  查找一个字符,在字符串中第一次出现的索引,被查找的字符不存在,返回-1<br>            * byte[] getBytes(): 将字符串转成字节数组,此功能和String构造方法相反,byte数组相关的功能,查询编码表<br>            * char[] toCharArray(): 将字符串转成字符数组,功能和构造方法相反<br>            * boolean equals(Object obj): 方法传递字符串,判断字符串中的字符是否完全相同,如果完全相同返回true<br>            * boolean equalsIgnoreCase(String s): 传递字符串,判断字符串中的字符是否相同,忽略大小写            </p>
<pre><code>* b: 案例代码

    public class StringDemo4 {
        public static void main(String[] args) {
            function_9();
        }
        /*
         *  boolean equals(Object obj)
         *  方法传递字符串,判断字符串中的字符是否完全相同,如果完全相同返回true
         *  
         *  boolean equalsIgnoreCase(String s)
         *  传递字符串,判断字符串中的字符是否相同,忽略大小写
         */
        public static void function_9(){
            String str1 = &quot;Abc&quot;;
            String str2 = &quot;abc&quot;;
            //分别调用equals和equalsIgnoreCase
            boolean b1 = str1.equals(str2);
            boolean b2 = str1.equalsIgnoreCase(str2);
            System.out.println(b1);
            System.out.println(b2);
        }

        /*
         * char[] toCharArray() 将字符串转成字符数组
         * 功能和构造方法相反
         */
        public static void function_8(){
            String str = &quot;itcast&quot;;
            //调用String类的方法toCharArray()
            char[] ch = str.toCharArray();
            for(int i = 0 ; i &lt; ch.length ; i++){
                System.out.println(ch[i]);
            }
        }

        /*
         *  byte[] getBytes() 将字符串转成字节数组
         *  此功能和String构造方法相反
         *  byte数组相关的功能,查询编码表
         */
        public static void function_7(){
            String str = &quot;abc&quot;;
            //调用String类方法getBytes字符串转成字节数组
            byte[] bytes = str.getBytes();
            for(int i = 0 ; i &lt; bytes.length ; i++){
                System.out.println(bytes[i]);
            }
        }

        /*
         *  int indexOf(char ch)
         *  查找一个字符,在字符串中第一次出现的索引
         *  被查找的字符不存在,返回-1
         */
        public static void function_6(){
            String str = &quot;itcast.cn&quot;;
            //调用String类的方法indexOf
            int index = str.indexOf(&apos;x&apos;);
            System.out.println(index);
        }

        /*
         *  boolean contains (String s)
         *  判断一个字符串中,是否包含另一个字符串
         */
        public static void function_5(){
            String str = &quot;itcast.cn&quot;;
            //调用String类的方法contains
            boolean b =str.contains(&quot;ac&quot;);
            System.out.println(b);
        }

        /*
         * boolean endsWith(String prefix)
         * 判断一个字符串是不是另一个字符串的后缀,结尾
         * Demo.java
         *     .java
         */
        public static void function_4(){
            String str = &quot;Demo.java&quot;;
            //调用String类方法endsWith
            boolean b = str.endsWith(&quot;.java&quot;);
            System.out.println(b);
        }

        /*
         * boolean startsWith(String prefix)  
         * 判断一个字符串是不是另一个字符串的前缀,开头
         * howareyou
         * hOw
         */
          public static void function_3(){
              String str = &quot;howareyou&quot;;
              //调用String类的方法startsWith
              boolean b = str.startsWith(&quot;hOw&quot;);
              System.out.println(b);
          }

        /*
         *  String substring(int beginIndex,int endIndex) 获取字符串的一部分
         *  返回新的字符串
         *  包含头,不包含尾巴
         *  
         *  String substring(int beginIndex)获取字符串的一部分
         *  包含头,后面的字符全要
         */
        public static void function_2(){
            String str = &quot;howareyou&quot;;
            //调用String类方法substring获取字符串一部分
            str= str.substring(1, 5);
            System.out.println(str);

            String str2 = &quot;HelloWorld&quot;;
            str2 = str2.substring(1);
            System.out.println(str2);
        }

        /*
         *  int length() 返回字符串的长度
         *  包含多少个字符
         */
        public static void function(){
            String str = &quot;cfxdf#$REFewfrt54GT&quot;;
            //调用String类方法length,获取字符串长度
            int length = str.length();
            System.out.println(length);
        }
    }</code></pre><p>###11String类练习<br>    * A: 获取指定字符串中，大写字母、小写字母、数字的个数<br>        * a: 题目分析<br>            * 为了统计大写字母、小写字母、数字的个数。创建3个计数的变量。<br>            * 为了获取到字符串中的每个字符，进行字符串的遍历，得到每个字符。<br>            * 对得到的字符进行判断，如果该字符为大写字母，则大写字母个数+1；如果该字符为小写字母，则小写字母个数+1；如果该字符为数字，则数字个数+1。<br>            * 显示大写字母、小写字母、数字的个数</p>
<pre><code>* b: 解题步骤
    * 略
* 案例代码
    public class StringTest {
        public static void main(String[] args) {
            getCount(&quot;A%A3eBr1FFy&quot;);                    
        }

        /*
         * 获取指定字符串中，大写字母、小写字母、数字的个数。
         * 思想:
         *   1. 计数器,就是int变量,满足一个条件 ++
         *   2. 遍历字符串, 长度方法length() + charAt() 遍历
         *   3. 字符判断是大写,是小写,还是数字
         */
        public static void getCount(String str){
            //定义三个变量,计数
            int upper = 0;
            int lower = 0;
            int digit = 0;
            //对字符串遍历
            for(int i = 0 ; i &lt; str.length() ; i++){
                //String方法charAt,索引,获取字符
                char c = str.charAt(i);
                //利用编码表 65-90  97-122  48-57
                if(c &gt;=&apos;A&apos; &amp;&amp; c &lt;=90){
                    upper++;
                }else if( c &gt;= 97 &amp;&amp; c &lt;= 122){
                    lower++;
                }else if( c &gt;= 48 &amp;&amp; c &lt;=&apos;9&apos;){
                    digit++;
                }
            }
            System.out.println(upper);
            System.out.println(lower);
            System.out.println(digit);
        }
    }</code></pre><p>###12String类练习_2<br>    * A: 将字符串中，第一个字母转换成大写，其他字母转换成小写，并打印改变后的字符串。<br>        * a: 题目分析<br>            * 把字符串分为两个部分，第一部分为字符串中第一个字母，第二部分为剩下的字符串。<br>            * 把第一部分字符串转换成大写字母，把第二部分字符串转换成小写字母<br>            * 把两部分字符串连接在一起，得到一个完整的字符串<br>        * b: 解题步骤<br>            * 略<br>        * C: 案例代码<br>            public class StringTest {<br>                public static void main(String[] args) {</p>
<pre><code>        System.out.println(toConvert(&quot;aBc5%4dEF&quot;));

    }

    /*
     *  将字符串的首字母转成大写,其他内容转成小写
     *  思想:
     *    获取首字母, charAt(0)  substring(0,1)
     *    转成大写 toUpperCase()
     *    
     *    获取剩余字符串, substring(1)  toLowerCase()
     */
    public static String toConvert(String str){
        //定义变量,保存首字母,和剩余字符
        String first = str.substring(0,1);
        String after = str.substring(1);
        //调用String类方法,大写,小写转换
        first = first.toUpperCase();
        after = after.toLowerCase();
        return first+after;
    }
}</code></pre><p>###13String类练习_3<br>    * A: 查询大字符串中，出现指定小字符串的次数<br>        * a: 题目分析<br>            * 在大串中，查找小串出现的位置，出现了就次数+1<br>            * 在上次小串出现位置的后面继续查找，需要更改大串的内容为上次未查询到的字符串。<br>            * 回到第一步，继续查找小串出现的位置，直到大串中查询不到小串为止<br>        * b: 解题步骤<br>            * 略<br>        * C: 案例代码<br>            package cn.itcast.demo02;</p>
<pre><code>public class StringTest {
    public static void main(String[] args) {        
        System.out.println(getStringCount(&quot;hellojava,nijavahaojava,javazhenbang&quot;, &quot;java&quot;));
    }
    /*
     *  获取一个字符串中,另一个字符串出现的次数
     *  思想:
     *    1. indexOf到字符串中到第一次出现的索引
     *    2. 找到的索引+被找字符串长度,截取字符串
     *    3. 计数器++
     */
    public static int getStringCount(String str, String key){
        //定义计数器
        int count = 0;
        //定义变量,保存indexOf查找后的索引的结果
        int index = 0;
        //开始循环找,条件,indexOf==-1 字符串没有了
        while(( index = str.indexOf(key) )!= -1){
            count++;
            //获取到的索引,和字符串长度求和,截取字符串
            str = str.substring(index+key.length());
        }
        return count;
    }
}</code></pre><p>======================================================================第三节课开始=========================================================</p>
<p>###14StringBuffer特点可变字符数组<br>    * A:StringBuffer类概述<br>        * 通过JDK提供的API，查看StringBuffer类的说明<br>        * 线程安全的可变字符序列<br>        * 底层采用字符数组实现,初始容量为16<br>    * B:StringBuffer和String的区别<br>        * String是一个不可变的字符序列<br>        * StringBuffer是一个可变的字符序列</p>
<p>###15StringBuffer类的方法<br>    * A: StringBuffer类的方法<br>        * a: 方法介绍<br>            * StringBuffer append(), 将任意类型的数据,添加缓冲区<br>                *  append 返回值,写return this<br>                *  调用者是谁,返回值就是谁<br>            * delete(int start,int end): 删除缓冲区中字符<br>                *  开始索引包含,结尾索引不包含<br>            * insert(int index, 任意类型): 将任意类型数据,插入到缓冲区的指定索引上<br>            * replace(int start,int end, String str): 将指定的索引范围内的所有字符,替换成新的字符串<br>            * reverse(): 将缓冲区中的字符反转<br>            * String toString(): 继承Object,重写toString()<br>                *   将缓冲区中的所有字符,变成字符串<br>        * b: 案例代码<br>            public class StringBufferDemo {<br>                public static void main(String[] args) {<br>                    function_5();<br>                }<br>                /*<br>                 *  StringBuffer类的方法<br>                 *   String toString() 继承Object,重写toString()<br>                 *   将缓冲区中的所有字符,变成字符串<br>                 */<br>                public static void function_5(){<br>                    StringBuffer buffer = new StringBuffer();<br>                    buffer.append(“abcdef”);<br>                    buffer.append(12345);</p>
<pre><code>        //将可变的字符串缓冲区对象,变成了不可变String对象
        String s = buffer.toString();
        System.out.println(s);
    }

    /*
     *  StringBuffer类的方法
     *    reverse() 将缓冲区中的字符反转
     */
    public static void function_4(){
        StringBuffer buffer = new StringBuffer();
        buffer.append(&quot;abcdef&quot;);

        buffer.reverse();

        System.out.println(buffer);
    }

    /*
     *  StringBuffer类方法
     *    replace(int start,int end, String str)
     *    将指定的索引范围内的所有字符,替换成新的字符串
     */
    public static void function_3(){
        StringBuffer buffer = new StringBuffer();
        buffer.append(&quot;abcdef&quot;);

        buffer.replace(1, 4, &quot;Q&quot;);

        System.out.println(buffer);
    }

    /*
     *  StringBuffer类方法 insert
     *    insert(int index, 任意类型)
     *  将任意类型数据,插入到缓冲区的指定索引上
     */
     public static void function_2(){
         StringBuffer buffer = new StringBuffer();
         buffer.append(&quot;abcdef&quot;);     

         buffer.insert(3, 9.5);
         System.out.println(buffer);
     }

    /*
     * StringBuffer类方法
     *   delete(int start,int end) 删除缓冲区中字符
     *   开始索引包含,结尾索引不包含
     */
    public static void function_1(){
        StringBuffer buffer = new StringBuffer();
        buffer.append(&quot;abcdef&quot;);

        buffer.delete(1,5);
        System.out.println(buffer);
    }

    /*
     *  StringBuffer类方法
     *   StringBuffer append, 将任意类型的数据,添加缓冲区
     *   append 返回值,写return this
     *   调用者是谁,返回值就是谁
     */
    public static void function(){
        StringBuffer buffer = new StringBuffer();
        //调用StringBuffer方法append向缓冲区追加内容
        buffer.append(6).append(false).append(&apos;a&apos;).append(1.5);
        System.out.println(buffer);
    }
}</code></pre><p>​<br>###16StringBuilder类<br>    * A:StringBuilder的概述<br>        * 通过查看API了解一下StringBuilder类<br>    * B:面试题<br>        * String,StringBuffer,StringBuilder的区别<br>            * StringBuffer和StringBuilder的区别<br>                * StringBuffer是jdk1.0版本的,是线程安全的,效率低<br>                * StringBuilder是jdk1.5版本的,是线程不安全的,效率高</p>
<pre><code>* String和StringBuffer,StringBuilder的区别
    * String是一个不可变的字符序列
    * StringBuffer,StringBuilder是可变的字符序列</code></pre><p>###17StringBuffer类案例拼接数组<br>    * A: StringBuffer类案例拼接数组<br>        * a: 题目分析<br>            * 定义StringBuffer对象<br>            * 遍历数组,按照格式要求拼接处新的字符串,追加到StringBuffer容器中<br>            * 将StringBuffer中的内容以String的形式返回<br>        * b: 解题步骤<br>            * 略<br>        * C: 案例代码<br>            public class StringBufferTest {<br>                public static void main(String[] args) {<br>                    int[] arr = {4,1,4,56,7,8,76};<br>                    System.out.println(toString(arr));<br>                }<br>               /*<br>                * int[] arr = {34,12,89,68};将一个int[]中元素转成字符串<br>                * 格式 [34,12,89,68]<br>                * String s = “[“<br>                * 数组遍历<br>                *   s+= arr[i];<br>                *  s+”]”<br>                *  StringBuffer实现,节约内存空间, String + 在缓冲区中,append方法<br>                */<br>                public static String toString(int[] arr){<br>                    //创建字符串缓冲区<br>                    StringBuffer buffer = new StringBuffer();<br>                    buffer.append(“[“);<br>                    //数组遍历<br>                    for(int i = 0 ; i &lt; arr.length;i++){<br>                        //判断是不是数组的最后一个元素<br>                        if(i == arr.length-1){<br>                            buffer.append(arr[i]).append(“]”);<br>                        }else{<br>                            buffer.append(arr[i]).append(“,”);<br>                        }<br>                    }<br>                    return buffer.toString();<br>                }<br>            }<br>###18总结</p>
<ul>
<li>把今天的知识点总结一遍。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day14%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day14%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记14</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:08:29" itemprop="dateModified" datetime="2020-12-23T23:08:29+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、Eclipse常用快捷键操作<br>2、Eclipse文档注释导出帮助文档<br>3、Eclipse项目的jar包导出与使用jar包<br>4、不同修饰符混合使用细节<br>5、辨析何时定义变量为成员变量<br>6、类、抽象类、接口作为方法参数<br>7、类、抽象类、接口作为方法返回值</p>
<p>第1章 Eclipse的应用<br>###01 day14_01(面向对象)eclipse快捷键.avi(14:33)<br>###02 day14_02(面向对象)java中的文档注释和制作.avi(15:08)<br>###03 day14_03(面向对象)eclipse生成jar包(08:37)<br>###04 day14_04(面向对象)JAVA_HOME配置.avi(03:27)<br>###05 day14_05(面向对象)导入jar包.avi(12:13)</p>
<p>第2章    面向对象<br>###06 day14_07(面向对象)类中的修饰符(09:33)<br>###07 day14_08(面向对象)局部变量和成员变量解析(11:01)</p>
<p>第3章    自定义数据类型的使用<br>###08 day14_09(面向对象)类作为方法的参数(08:12)<br>###09 day14_10(面向对象)类作为方法的返回值(07:50)<br>###10 day14_11(面向对象)抽象类作为方法的参数(10:37)<br>###11 day14_12(面向对象)抽象类作为方法的返回值(09:24)<br>###12 day14_13(面向对象)抽象类作为方法的返回值_1(01:53)<br>###13 day14_14(面向对象)接口作为方法的参数(05:55)<br>###14 day14_15(面向对象)接口作为方法的参数_常量调用(03:31)<br>###15 day14_16(面向对象)接口作为方法的返回值(03:33)<br>###16 day14_17(面向对象)抽象类作为方法返回值的案例(09:31)</p>
<p>第三节课 星级酒店案例<br>###17 day14_18(面向对象)酒店案例分析(09:12)<br>###18 day14_19(面向对象)酒店案例功能实现(14:57)</p>
<p>============上面的内容,方便我们只做ppt,word教案以及书写下面的简要的笔记=================</p>
<p>=======================第一节课开始=============================================</p>
<p>###01eclipse快捷键<br>    * A:     Ctrl+T：查看所选中类的继承树<br>        例如，在下面代码中，选中Teacher类名，然后按Ctrl+T，就会显示出Teacher类的继承关系</p>
<pre><code>* B:    查看所选中方法的源代码
    Ctrl+滑动鼠标点击方法名，或者选中方法名后，按F3键查看所选中方法的源代码。</code></pre><p>###02java中的文档注释和制作<br>    * A: 在eclipse使用时，可以配合文档注释，导出对类的说明文档，从而供其         他人阅读学习与使用。<br>        通过使用文档注释，将类或者方法进行注释用@简单标注基本信息。如@author 作者、@version代码版本、@param方法参数、@return方法返回值等。</p>
<p>​<br>###03eclipse生成jar包<br>###04JAVA_HOME配置<br>###05导入jar包<br>    * A:     导入jar包：即把指定的jar包，加入到指项目中，提供给项目使用。<br>        导入jar包的过程是将jar包加入到项目的.classpath文件中去，让项目识别，便可以使用jar包中所有的.class文件类。<br>        以下是加入步骤：<br>        1：项目根文件夹下创建lib文件夹，用于同一管理所有的jar文件<br>        2：把jar文件复制到lib文件夹中<br>        3：右键点击jar文件，点击Build Path，选择Add to Build Path，此时查看项目根文件夹下的.classpath文件，发现新加入的jar包路径被配置到了该文件中。说明可以使用jar包中所有类了。</p>
<pre><code>注意：
    Jar包加入后，必须Add to Build Path才能使用
    Jar包加入后，加入的类也必须导包，如果加入的类其包名与现有类包名相同，则视作在同一个包下。(不常见)</code></pre><p>==============================第二节课开始====================================        </p>
<p>​                </p>
<p>###07不同修饰符使用细节</p>
<pre><code>A: 常用来修饰类、方法、变量的修饰符如下：
    public 权限修饰符，公共访问, 类,方法,成员变量
    protected 权限修饰符，受保护访问, 方法,成员变量
    默认什么也不写 也是一种权限修饰符，默认访问, 类,方法,成员变量
    private 权限修饰符，私有访问, 方法,成员变量
    static 静态修饰符  方法,成员变量
    final 最终修饰符   类,方法,成员变量,局部变量
    abstract 抽象修饰符  类 ,方法

B: 不能同时使用的修饰符
    同时，abstract与private不能同时使用；
    同时，abstract与static不能同时使用；
    同时，abstract与final不能同时使用。</code></pre><p>    C: 修饰类能够使用的修饰符：<br>        修饰类只能使用public、默认的、final、abstract关键字<br>        使用最多的是 public关键字</p>
<pre><code>    a:代码案例
        public class Demo {} //最常用的方式
        class Demo2{}
        public final class Demo3{}
        public abstract class Demo4{}

D:修饰成员变量能够使用的修饰符：
    public : 公共的
    protected : 受保护的
        : 默认的
    private ：私有的
    final : 最终的
    static : 静态的
    使用最多的是 private

    a: 代码案例
        public int count = 100;
        protected int count2 = 100;
        int count3 = 100;
        private int count4 = 100; //最常用的方式
        public final int count5 = 100;
        public static int count6 = 100;</code></pre><p>    E:修饰构造方法能够使用的修饰符：<br>        public : 公共的<br>        protected : 受保护的<br>            : 默认的<br>        private ：私有的<br>        使用最多的是 public</p>
<pre><code>a:代码案例
    public Demo(){} //最常用的方式
    protected Demo(){}
    Demo(){}
    private Demo(){}

    修饰成员方法能够使用的修饰符：
        public : 公共的
        protected : 受保护的
            : 默认的
        private ：私有的
        final : 最终的
        static : 静态的
        abstract : 抽象的
        使用最多的是 public
    public void method1(){}//最常用的方式
    protected void method2(){}
    void method3(){}
    private void method4(){}
    public final void method5(){}
    public static void method6(){}//最常用的方式
    public abstract void method7();//最常用的方式</code></pre><p>###07局部变量和成员变量解析<br>    * A：程序编译<br>            数学工具类<br>    public class MathTool {<br>        //求两个数的和的二倍<br>        public double sum2times(int number,int number2) {<br>            return (number+number2)<em>2;<br>        }<br>        //求两个数的积<br>        public double area(int number,int number2) {<br>            return number</em>number2;<br>        }<br>    }</p>
<p>    长方形类<br>    public class CFX {<br>        //因为长与宽，在现实事物中属于事物的一部分，所以定义成员变量<br>        private int chang;<br>        private int kuan;</p>
<pre><code>    public CFX(int chang, int kuan) {
        this.chang = chang;
        this.kuan = kuan;
    }

    //求长与宽的周长
    public double zhouChang() {
        return (chang+kuan)*2;
    }
    //求长与宽的面积
    public double mianJi() {
        return chang*kuan;
    }
    public int getChang() {
        return chang;
    }
    public void setChang(int chang) {
        this.chang = chang;
    }
    public int getKuan() {
        return kuan;
    }
    public void setKuan(int kuan) {
        this.kuan = kuan;
    }
}</code></pre><p>###08类作为方法的参数<br>    * A：    类作为方法参数<br>        在编写程序中，会经常碰到调用的方法要接收的是一个类类型的情况，那么这时，要向方法中传入该类的对象。</p>
<pre><code>如下代码演示：
    class Person{
        public void show(){
            System.out.println(&quot;show方法执行了&quot;);
        }
    }
    //测试类
    public class Test {
        public static void main(String[] args) {
            //创建Person对象
            Person p = new Person();
            //调用method方法
            method(p);
        }

    //定义一个方法method，用来接收一个Person对象，在方法中调用Person对象的show方法
    public static void method(Person p){
        p.show();
    }</code></pre><p>###09抽象类作为方法参数与返回值<br>    * A:     抽象类作为方法参数<br>        今后开发中，抽象类作为方法参数的情况也很多见。当遇到方法参数为抽象类类型时，要传入一个实现抽象类所有抽象方法的子类对象。如下代码演示：<br>        //抽象类<br>        abstract class Person{<br>            public abstract void show();<br>        }<br>        class Student extends Person{<br>            @Override<br>            public void show() {<br>                System.out.println(“重写了show方法”);<br>            }<br>        }<br>        //测试类<br>        public class Test {<br>            public static void main(String[] args) {<br>                //通过多态的方式，创建一个Person类型的变量，而这个对象实际是Student<br>                Person p = new Student();<br>                //调用method方法<br>                method(p);<br>            }</p>
<pre><code>        //定义一个方法method，用来接收一个Person类型对象，在方法中调用Person对象的show方法
        public static void method(Person p){//抽象类作为参数
            //通过p变量调用show方法,这时实际调用的是Student对象中的show方法
            p.show();    
    }
    }


* B:    抽象类作为方法返回值
    抽象类作为方法返回值的情况，也是有的，这时需要返回一个实现抽象类所有抽象方法的子类对象。如下代码演示：
    //抽象类
    abstract class Person{
        public abstract void show();
    }
    class Student extends Person{
        @Override
        public void show() {
            System.out.println(&quot;重写了show方法&quot;);
        }
    }
    //测试类
    public class Test {
        public static void main(String[] args) {
            //调用method方法，获取返回的Person对象
            Person p = method();
            //通过p变量调用show方法,这时实际调用的是Student对象中的show方法
            p.show();
        }

        //定义一个方法method，用来获取一个Person对象，在方法中完成Person对象的创建
        public static Person method(){
            Person p = new Student();
            return p;
        }
    }</code></pre><p>​<br>###10接口作为方法参数与返回值<br>    * A:     接口作为方法参数<br>        接口作为方法参数的情况是很常见的，经常会碰到。当遇到方法参数为接口类型时，那么该方法要传入一个接口实现类对象。如下代码演示。<br>        //接口<br>        interface Smoke{<br>            public abstract void smoking();<br>        }<br>        class Student implements Smoke{<br>            @Override<br>            public void smoking() {<br>                System.out.println(“课下吸口烟，赛过活神仙”);<br>            }<br>        }<br>        //测试类<br>        public class Test {<br>            public static void main(String[] args) {<br>                //通过多态的方式，创建一个Smoke类型的变量，而这个对象实际是Student<br>                Smoke s = new Student();<br>                //调用method方法<br>                method(s);<br>            }</p>
<pre><code>        //定义一个方法method，用来接收一个Smoke类型对象，在方法中调用Smoke对象的show方法
        public static void method(Smoke sm){//接口作为参数
            //通过sm变量调用smoking方法，这时实际调用的是Student对象中的smoking方法
            sm.smoking();
        }
    }

* B:    接口作为方法返回值
    接口作为方法返回值的情况，在后面的学习中会碰到。当遇到方法返回值是接口类型时，那么该方法需要返回一个接口实现类对象。如下代码演示。

    //接口
    interface Smoke{
        public abstract void smoking();
    }
    class Student implements Smoke{
        @Override
        public void smoking() {
            System.out.println(&quot;课下吸口烟，赛过活神仙&quot;);
        }
    }
    //测试类
    public class Test {
        public static void main(String[] args) {
            //调用method方法，获取返回的会吸烟的对象
            Smoke s = method();
            //通过s变量调用smoking方法,这时实际调用的是Student对象中的smoking方法
            s.smoking();
        }

        //定义一个方法method，用来获取一个具备吸烟功能的对象，并在方法中完成吸烟者的创建
        public static Smoke method(){
            Smoke sm = new Student();
            return sm;
        }
    }</code></pre><p>​<br>==============================第三节课开始====================================<br>###11星级酒店案例<br>    * A:     根据“某五星级酒店，资金雄厚……都有自己的工作要做。”分析出，该题        目中包含酒店，可以把它封装成类，多名员工）。</p>
<pre><code>    class 员工 {
         属性：姓名
    属性：工号
    方法：工作
    }
    class 厨师 extends 员工{}
    class 服务员 extends 员工{}
    class 经理 extends 员工 {
         属性：奖金
    }

    员工的类型有经理、厨师、服务员，它们有共同的属性（姓名、工号、），经理额外属性（奖金）。

        根据“向酒店中，增加多名员工（其中包含1名经理，1名厨师、2名服务员）”。分析出，要创建一个酒店对象，并添加4名员工到酒店对象的员工集合中。
    酒店员工集合添加新员工： 经理对象
    酒店员工集合添加新员工： 厨师对象
    酒店员工集合添加新员工： 服务员对象
    酒店员工集合添加新员工： 服务员对象

        根据“获取酒店幸运员工”。分析出，从酒店员工集合随机得到一名员工对象。
    1. 从酒店员工集合长度范围内，随机产生一个随机数
    2. 使用该随机数作为集合的索引，返回该索引处对应的员工对象

        根据“酒店开设VIP服务，酒店的厨师与服务员可以提供VIP服务。（厨师做菜加量、服务员给顾客倒酒）”。分析出，这是要增加一个VIP的接口，接口中提供个VIP服务的方法。让厨师与服务员实现该接口。
    interface VIP服务{
         抽象方法：服务
    }
    class 厨师 extends 员工 implements VIP服务{ 重写服务方法 }
    class 服务员 extends 员工 implements VIP服务{ 重写服务方法 }

B:
    VIP服务</code></pre><p>public interface VIP {<br>     public abstract void server(); //服务<br>}</p>
<p>    员工<br>/*</p>
<ul>
<li>员工：<br>  姓名 String<br>  工号 String</li>
</ul>
<p> */<br>public abstract class YuanGong {<br>    // 成员变量<br>    private String xingMing;<br>    private String gongHao;<br>    // 构造方法<br>    public YuanGong() {<br>        super();<br>    }<br>    public YuanGong(String xingMing, String gongHao) {<br>        super();<br>        this.xingMing = xingMing;<br>        this.gongHao = gongHao;</p>
<pre><code>}
// 抽象方法
public abstract void work();

// getters与setters
public String getXingMing() {
    return xingMing;
}
public void setXingMing(String xingMing) {
    this.xingMing = xingMing;
}
public String getGongHao() {
    return gongHao;
}
public void setGongHao(String gongHao) {
    this.gongHao = gongHao;
}</code></pre><p>}</p>
<p>    服务员<br>/*</p>
<ul>
<li><p>定义员工的子类 服务员类</p>
</li>
<li><p>/<br>public class FuWuYuan extends YuanGong implements VIP {<br>  public FuWuYuan() {</p>
<pre><code>super();</code></pre><p>  }</p>
<p>  public FuWuYuan(String xingMing, String gongHao) {</p>
<pre><code>super(xingMing, gongHao);</code></pre><p>  }<br>  @Override<br>  public void work() {</p>
<pre><code>System.out.println(&quot;亲，全身心为您服务，记得给好评哦&quot;);</code></pre><p>  }<br>  @Override<br>  public void server() {</p>
<pre><code>System.out.println(&quot;给顾客倒酒&quot;);</code></pre><p>  }<br>}</p>
</li>
</ul>
<p>    经理<br>/*</p>
<ul>
<li><p>经理在员工的基础上，添加了奖金成员</p>
</li>
<li><p>/<br>public class JingLi extends YuanGong {<br>  private double jiangJin;</p>
<p>  public JingLi() {</p>
<pre><code>super();</code></pre><p>  }<br>  public JingLi(String xingMing, String gongHao, double jiangJin) {</p>
<pre><code>super(xingMing, gongHao);
this.jiangJin = jiangJin;</code></pre><p>  }</p>
<p>  public double getJiangJin() {</p>
<pre><code>return jiangJin;</code></pre><p>  }<br>  public void setJiangJin(double jiangJin) {</p>
<pre><code>this.jiangJin = jiangJin;</code></pre><p>  }</p>
<p>  @Override<br>  public void work() {</p>
<pre><code>System.out.println(&quot;哪个员工让顾客不满意，我扣谁钱&quot;);</code></pre><p>  };<br>}</p>
</li>
</ul>
<p>    厨师<br>/*</p>
<ul>
<li><p>定义员工的子类 厨师类</p>
</li>
<li><p>/<br>public class ChuShi extends YuanGong implements VIP{<br>  public ChuShi() {</p>
<pre><code>super();</code></pre><p>  }<br>  public ChuShi(String xingMing, String gongHao) {</p>
<pre><code>super(xingMing, gongHao);</code></pre><p>  }</p>
<p>  @Override<br>  public void work() {</p>
<pre><code>System.out.println(&quot;我做饭，放心吃吧，包您满意&quot;);</code></pre><p>  }<br>  @Override<br>  public void server() {</p>
<pre><code>System.out.println(&quot;做菜加量加料&quot;);</code></pre><p>  }<br>}</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day13%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day13%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记13</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:08:17" itemprop="dateModified" datetime="2020-12-23T23:08:17+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、final 关键字<br>2、static 关键字<br>3、匿名对象<br>4、内部类<br>5、包的声明与访问<br>6、访问修饰符<br>7、代码块</p>
<p>第一节课<br>###01(面向对象)final关键字概念.avi                               02:20<br>###02(面向对象)final修饰类.avi                                    04:25<br>###03(面向对象)final修饰方法.avi                                 04:01<br>###04(面向对象)final修饰局部变量.avi                             05:57<br>###05(面向对象)final修饰成员变量.avi                              10:04<br>###06(面向对象)static的概念.avi                                 09:28</p>
<p>第二节课<br>###07(面向对象)static修饰的对象特有数据.avi                      06:53<br>###08(面向对象)static的内存图.avi                               14:09<br>###09(面向对象)static注意事项_静态不能直接调用非静态.avi         08:02<br>###10(面向对象)static静态的使用场景.avi                            08:14<br>###11(面向对象)对象中的静态调用.avi                              06:45<br>###12(面向对象)定义静态常量.avi                                  03:44</p>
<p>第三节课<br>###13(面向对象)匿名对象.avi                                      12:46<br>###14(面向对象)内部类.avi                                       03:34<br>###15(面向对象)成员内部类的调用格式.avi                         09:19<br>###16(面向对象)成员内部类的同名变量调用.avi                     02:59<br>###17(面向对象)局部内部类.avi                                  07:18<br>###18(面向对象)匿名内部类.avi                                      12:22 </p>
<p>第四节课<br>###19(面向对象)匿名内部类_2.avi                                 04:19<br>###20(面向对象)包的概念.avi                                      02:29<br>###21(面向对象)导入包.avi                                     06:48<br>###22(面向对象)权限修饰符.avi                                    12:47<br>###23(面向对象)代码块.avi                                      05:17</p>
<p>============上面的内容,方便我们只做ppt,word教案以及书写下面的简要的笔记=================</p>
<p>=======================第一节课开始=============================================</p>
<p>###01final关键字概念<br>    * A: 概述<br>            继承的出现提高了代码的复用性，并方便开发。但随之也有问题，有些类在描述完之后，不想被继承，<br>            或者有些类中的部分方法功能是固定的，不想让子类重写。可是当子类继承了这些特殊类之后，<br>            就可以对其中的方法进行重写，那怎么解决呢？<br>            要解决上述的这些问题，需要使用到一个关键字final，final的意思为最终，不可变。<br>            final是个修饰符，它可以用来修饰类，类的成员，以及局部变量。</p>
<p>###02final修饰类义<br>    * A: final 修饰类<br>            final修饰类不可以被继承，但是可以继承其他类。<br>    * B: 案例<br>            class Yy {}<br>            final class Fu extends Yy{} //可以继承Yy类<br>            class Zi extends Fu{} //不能继承Fu类</p>
<p>​<br>​<br>###03final修饰方法<br>    * A: final修饰方法<br>                final修饰的方法不可以被覆盖,但父类中没有被final修饰方法，子类覆盖后可以加final。<br>    * B: 案例<br>             class Fu {<br>                // final修饰的方法，不可以被覆盖，但可以继承使用<br>                public final void method1(){}<br>                public void method2(){}<br>            }<br>            class Zi extends Fu {<br>                //重写method2方法<br>                public final void method2(){}<br>            }</p>
<p>###04final修饰局部变量<br>    * A:修饰基本数据类型变量<br>        final修饰的变量称为常量，这些变量只能赋值一次</p>
<pre><code>* B:案例1
        final int i = 20;
        i = 30; //赋值报错，final修饰的变量只能赋值一次

* C: 修饰引用数据类型
        引用类型的变量值为对象地址值，地址值不能更改，但是地址内的对象属性值可以修改

* D: 修饰引用数据类型
        final Person p = new Person();
        Person p2 = new Person();
        p = p2; //final修饰的变量p，所记录的地址值不能改变
        p.name = &quot;小明&quot;;//可以更改p对象中name属性值
        p不能为别的对象，而p对象中的name或age属性值可更改。</code></pre><p>​<br>###05final修饰成员变量<br>    * A: 修饰成员变量<br>         修饰成员变量，需要在创建对象前赋值，否则报错。(当没有显式赋值时，多个构造方法的均需要为其赋值。)</p>
<pre><code>* B: 案例
        class Demo {
            //直接赋值
            final int m = 100;

            //final修饰的成员变量，需要在创建对象前赋值，否则报错。
            final int n; 
            public Demo(){
                //可以在创建对象时所调用的构造方法中，为变量n赋值
                n = 2016;
            }
        }</code></pre><p>###06static的概念<br>    * A：概念<br>        当在定义类的时候，类中都会有相应的属性和方法。而属性和方法都是通过创建本类对象调用的。<br>        当在调用对象的某个方法时，这个方法没有访问到对象的特有数据时，方法创建这个对象有些多余。<br>        可是不创建对象，方法又调用不了，这时就会想，那么我们能不能不创建对象，就可以调用方法呢？<br>        可以的，我们可以通过static关键字来实现。static它是静态修饰符，一般用来修饰类中的成员。</p>
<p>==============================第二节课开始====================================    </p>
<p>###07static修饰的对象特有数据<br>    * A：特点1:<br>            被static修饰的成员变量属于类，不属于这个类的某个对象。<br>            （也就是说，多个对象在访问或修改static修饰的成员变量时，其中一个对象将static成员变量值进行了修改，<br>            其他对象中的static成员变量值跟着改变，即多个对象共享同一个static成员变量）<br>    * B: 代码演示<br>            class Demo {<br>                public static int num = 100;<br>            }</p>
<pre><code>class Test {
    public static void main(String[] args) {
        Demo d1 = new Demo();
        Demo d2 = new Demo();
        d1.num = 200;
        System.out.println(d1.num); //结果为200
        System.out.println(d2.num); //结果为200
    }
}</code></pre><p>​    </p>
<p>###08static的内存图<br>    * A: 略<br>            参考day13_source 静态的内存图.jpg</p>
<p>​<br>###09static注意事项_静态不能直接调用非静态<br>    * A: 注意事项<br>            被static修饰的成员可以并且建议通过类名直接访问。</p>
<pre><code>* B: 访问静态成员的格式：
        类名.静态成员变量名
        类名.静态成员方法名(参数)
        对象名.静态成员变量名             ------不建议使用该方式，会出现警告
        对象名.静态成员方法名(参数)     ------不建议使用该方式，会出现警告

* C: 代码演示
        class Demo {
            //静态成员变量
            public static int num = 100;
            //静态方法
            public static void method(){
                System.out.println(&quot;静态方法&quot;);
            }
        }
        class Test {
            public static void main(String[] args) {
                System.out.println(Demo.num);
                Demo.method();
            }
        }</code></pre><p>​        </p>
<p>###10static静态的使用场景<br>    * A: 使用场景<br>        static可以修饰成员变量和成员方法。<br>        什么时候使用static修饰成员变量？<br>            加static修饰成员的时候，这个成员会被类的所有对象所共享。一般我们把共性数据定义为静态的变量<br>        什么时候使用static修饰成员方法？<br>            静态的方法只能访问静态的成员，如果静态方法中引用到了静态的其他成员，那么这个方法需要声明为静态的方法。</p>
<p>###11对象中的静态调用<br>    * A: 对象的静态调用<br>      在多态中，非静态编译看父类，运行看子类，父类没有编译失败。<br>      但多态中的静态方法,编译看父类,运行仍然看父类。因为静态和对象没有关系，属于静态绑定。</p>
<pre><code>* B: 举例
    public class Test{
        public static void main(String[] args){
            Fu f = new Zi();
            f.show();   //父类的引用和父类的方法绑定,和对象无关,不会在运行时动态的执行子类特有的方法。
        }
    }</code></pre><p>###12定义静态常量<br>    * A: 静态常量<br>        开发中，我们想在类中定义一个静态常量，通常使用public static final修饰的变量来完成定义。<br>        此时变量名用全部大写，多个单词使用下划线连接。<br>    * B: 定义格式：<br>        public static final 数据类型 变量名 = 值;</p>
<pre><code>* C: 如下演示：
    class Company {
        public static final String COMPANY_NAME = &quot;传智播客&quot;;
        public static void method(){
            System.out.println(&quot;一个静态方法&quot;);
        }
    }

    当我们想使用类的静态成员时，不需要创建对象，直接使用类名来访问即可。
    System.out.println(Company.COMPANY_NAME); //打印传智播客
    Company.method(); // 调用一个静态方法

* D: 注意：
    接口中的每个成员变量都默认使用public static final修饰。
    所有接口中的成员变量已是静态常量，由于接口没有构造方法，所以必须显示赋值。可以直接用接口名访问。
    interface Inter {
        public static final int COUNT = 100;
    }
        访问接口中的静态变量
    Inter.COUNT</code></pre><p>​<br>==============================第三节课开始====================================</p>
<p>###13匿名对象<br>    * A:匿名对象的概述<br>        * 匿名对象是指创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。<br>    * B:案例<br>        public class Person{<br>            public void eat(){<br>                System.out.println();<br>        }<br>        }</p>
<pre><code>    创建一个普通对象
    Person p = new Person();
    创建一个匿名对象
    new Person();

* C: 匿名对象的特点
    a:创建匿名对象直接使用，没有变量名。
        new Person().eat()  //eat方法被一个没有名字的Person对象调用了。

    b:匿名对象在没有指定其引用变量时，只能使用一次。
        new Person().eat(); 创建一个匿名对象，调用eat方法
        new Person().eat(); 想再次调用eat方法，重新创建了一个匿名对象

    c:匿名对象可以作为方法接收的参数、方法返回值使用
        class Demo {
            public static Person getPerson(){
                //普通方式
                //Person p = new Person();    
                //return p;

                //匿名对象作为方法返回值
                return new Person(); 
            }

            public static void method(Person p){}
        }

        class Test {
            public static void main(String[] args) {
                //调用getPerson方法，得到一个Person对象
                Person person = Demo.getPerson();

                //调用method方法
                Demo.method(person);
                //匿名对象作为方法接收的参数
                Demo.method(new Person());
            }
        }</code></pre><p>​<br>###14内部类<br>    * A: 内部类的概述<br>        将类写在其他类的内部，可以写在其他类的成员位置和局部位置，这时写在其他类内部的类就称为内部类。<br>        其他类也称为外部类。<br>    * B: 什么时候使用内部类<br>        在描述事物时，若一个事物内部还包含其他可能包含的事物，比如在描述汽车时，汽车中还包含这发动机，<br>        这时发动机就可以使用内部类来描述。<br>        class 汽车 { //外部类<br>            class 发动机 { //内部类<br>            }<br>        }<br>    * C: 内部类的分类<br>        内部类分为成员内部类与局部内部类。<br>        我们定义内部类时，就是一个正常定义类的过程，同样包含各种修饰符、继承与实现关系等。<br>        在内部类中可以直接访问外部类的所有成员。</p>
<p>###15成员内部类的调用格式<br>    * A: 格式<br>        成员内部类，定义在外部类中的成员位置。与类中的成员变量相似，可通过外部类对象进行访问<br>    * B: 定义格式<br>        class 外部类 {<br>            修饰符 class 内部类 {<br>                //其他代码<br>            }<br>        }</p>
<pre><code>* C: 访问方式
    外部类名.内部类名 变量名 = new 外部类名().new 内部类名();

* D: 成员内部类代码演示
    class Body {//外部类，身体
         private boolean life= true; //生命状态
         public class Heart { //内部类，心脏
             public void jump() {
                 System.out.println(&quot;心脏噗通噗通的跳&quot;)
                    System.out.println(&quot;生命状态&quot; + life); //访问外部类成员变量
            }
        }
    }

    访问内部类
    public static void main(String[] args) {
        //创建内部类对象
        Body.Heart bh = new Body().new Heart();
        //调用内部类中的方法
        bh.jump();
    }</code></pre><p>​        </p>
<p>###16成员内部类的同名变量调用<br>    * A: 代码实现<br>        public class Outer {<br>            int i  = 1;<br>            class Inner {<br>                int i  = 2;<br>                public void inner(){<br>                    int i = 3;<br>                    System.out.println(Outer.this.i);<br>                }<br>            }<br>        }</p>
<p>​<br>###17局部内部类<br>    * A 局部内部类，定义在外部类方法中的局部位置。与访问方法中的局部变量相似，可通过调用方法进行访问.<br>    * B 定义格式<br>        class 外部类 {<br>            修饰符 返回值类型 方法名(参数) {<br>                class 内部类 {<br>                    //其他代码<br>                }<br>            }<br>        }<br>    * C 访问方式<br>        在外部类方法中，创建内部类对象，进行访问</p>
<pre><code>* D 局部内部类代码演示
    定义类
    class Party {//外部类，聚会
        public void puffBall(){// 吹气球方法
            class Ball {// 内部类，气球
                  public void puff(){
                    System.out.println(&quot;气球膨胀了&quot;);
                  }
            }
            //创建内部类对象，调用puff方法
            new Ball().puff();
        }
    }
    访问内部类
    public static void main(String[] args) {    
        //创建外部类对象
        Party p = new Party();
        //调用外部类中的puffBall方法
        p.puffBall();
    }</code></pre><p>==============================第四节课开始====================================</p>
<p>###18匿名内部类<br>     * A: 概述<br>     内部类是为了应对更为复杂的类间关系。查看源代码中会涉及到，而在日常业务中很难遇到，这里不做赘述。<br>     最常用到的内部类就是匿名内部类，它是局部内部类的一种。<br>     定义的匿名内部类有两个含义：<br>     临时定义某一指定类型的子类<br>     定义后即刻创建刚刚定义的这个子类的对象</p>
<pre><code>* B: 本质
 匿名内部类的本质是一个实现了接口或继承了某个类的子类匿名对象.

* C: 案例
public interface Smoking {
    public abstract void smoking();
    }
    /*
     *  实现类,实现接口 重写接口抽象方法,创建实现类对象
     *  class XXX implements Smoking{
     *      public void smoking(){
     *      
     *      }
     *  }
     *  XXX x = new XXX();
     *  x.smoking(); 
     *  Smoking s = new XXX();
     *  s.smoking();
     *  
     *  匿名内部类,简化问题:  定义实现类,重写方法,建立实现类对象,合为一步完成
     */

测试类:
public class Test {
    public static void main(String[] args) {
        //使用匿名内部类
        /*
         *  定义实现类,重写方法,创建实现类对象,一步搞定
         *  格式:
         *    new 接口或者父类(){
         *       重写抽象方法
         *    };
         *    从 new开始,到分号结束
         *    创建了接口的实现类的对象
         */
        new Smoking(){
            public void smoking(){
                System.out.println(&quot;人在吸烟&quot;);
            }
        }.smoking();
    }
}</code></pre><p>###19匿名内部类_2<br>     * A: 匿名内部类案例演示<br>        public abstract class Animal {<br>            public abstract void eat();<br>            public abstract void sleep();<br>        }</p>
<pre><code>测试代码
/*
 *    new Animal(){
            public void eat(){
                System.out.println(&quot;在吃饭&quot;);
            } 
            public void sleep(){
                System.out.println(&quot;在睡觉&quot;);
            }
         };
    以上代码,就是Animal的子类的对象
    多态性, 父类引用 = 子类的对象

 */
public class Test2 {
    public static void main(String[] args) {
        Animal a= new Animal(){
            public void eat(){
                System.out.println(&quot;在吃饭&quot;);
            } 
            public void sleep(){
                System.out.println(&quot;在睡觉&quot;);
            }
         };
         a.eat();
         a.sleep();
    }
}</code></pre><p>###20包的概念<br>     * A: 概念<br>        java的包，其实就是我们电脑系统中的文件夹，包里存放的是类文件。<br>        当类文件很多的时候，通常我们会采用多个包进行存放管理他们，这种方式称为分包管理。<br>        在项目中，我们将相同功能的类放到一个包中，方便管理。并且日常项目的分工也是以包作为边界。<br>        类中声明的包必须与实际class文件所在的文件夹情况相一致，即类声明在a包下，则生成的.class文件必须在a文件夹下，否则，程序运行时会找不到类。</p>
<pre><code>* B 声明格式
    通常使用公司网址反写，可以有多层包，包名采用全部小写字母，多层包之间用”.”连接
        类中包的声明格式： 
    package 包名.包名.包名…;
        如：黑马程序员网址itheima.com那么网址反写就为com.itheima
            传智播客 itcast.cn  那么网址反写就为 cn.itcast
        注意：声明包的语句，必须写在程序有效代码的第一行（注释不算）
    代码演示：
    package cn.itcast; //包的声明，必须在有效代码的第一行

    import java.util.Scanner;
    import java.util.Random;

    public class Demo {}

* C: 包的访问
    在访问类时，为了能够找到该类，必须使用含有包名的类全名（包名.类名）。
    包名.包名….类名
    如： java.util.Scanner
         java.util.Random
        cn.itcast.Demo
    带有包的类，创建对象格式：包名.类名 变量名 = new包名.类名();
         cn.itcast.Demo d = new cn.itcast.Demo();
        前提：包的访问与访问权限密切相关，这里以一般情况来说，即类用public修饰的情况。

        类的简化访问
    当我们要使用一个类时，这个类与当前程序在同一个包中（即同一个文件夹中），或者这个类是java.lang包中的类时通常可以省略掉包名，直接使用该类。
    如：cn.itcast包中有两个类，PersonTest类，与Person类。我们在PersonTest类中，访问Person类时，由于是同一个包下，访问时可以省略包名，即直接通过类名访问 Person。
    类名 变量名 = new类名();
    Person p = new Person();

        当我们要使用的类，与当前程序不在同一个包中（即不同文件夹中），要访问的类必须用public修饰才可访问。
    package cn.itcst02;
    public class Person {}</code></pre><p>​<br>###22导入包<br>      * A:导入包<br>        我们每次使用类时，都需要写很长的包名。很麻烦，我们可以通过import导包的方式来简化。<br>        可以通过导包的方式使用该类，可以避免使用全类名编写（即，包类.类名）。<br>        导包的格式：<br>        import 包名.类名;</p>
<pre><code>    当程序导入指定的包后，使用类时，就可以简化了。演示如下
//导入包前的方式
//创建对象
java.util.Random r1 = new java.util.Random();
java.util.Random r2 = new java.util.Random();
java.util.Scanner sc1 = new java.util.Scanner(System.in);
java.util.Scanner sc2 = new java.util.Scanner(System.in);

//导入包后的方式
import java.util.Random;
import java.util.Scanner;
//创建对象
Random r1 = new Random();
Random r2 = new Random();
Scanner sc1 = new Scanner(System.in);
Scanner sc2 = new Scanner(System.in);
import导包代码书写的位置：在声明包package后，定义所有类class前，使用导包import包名.包名.类名;</code></pre><p>​<br>###23权限修饰符<br>     * A 权限修饰符有哪些<br>             在Java中提供了四种访问权限，使用不同的访问权限时，被修饰的内容会有不同的访问权限，<br>             以下表来说明不同权限的访问能力：<br>                                    public            protected      default        private<br>             同一类中                  √                   √             √               √<br>             同一包中(子类与无关类)      √                   √              √<br>             不同包的子类              √                   √<br>             不同包中的无关类          √<br>    * B: 小结<br>        归纳一下：在日常开发过程中，编写的类、方法、成员变量的访问<br>        要想仅能在本类中访问使用private修饰；<br>        要想本包中的类都可以访问不加修饰符即可；<br>        要想本包中的类与其他包中的子类可以访问使用protected修饰<br>        要想所有包中的所有类都可以访问使用public修饰。<br>        注意：如果类用public修饰，则类名必须与文件名相同。一个文件中只能有一个public修饰的类。</p>
<p>###24代码块<br>     * A: 概述:<br>        程序中用大括号括起来的代码叫代码块<br>     * B: 分类<br>      局部代码块  构造代码块  静态代码块  同步代码块</p>
<pre><code> * C 局部代码块:
    局部代码块是定义在方法或语句中
    特点：
        以”{}”划定的代码区域，此时只需要关注作用域的不同即可
        方法和类都是以代码块的方式划定边界的

      class Demo{
            public static void main(String[] args)    {
                {
                         int x = 1;
                         System.out.println(&quot;普通代码块&quot; + x);
                }
                int x = 99;
                System.out.println(&quot;代码块之外&quot; + x);
            }
      }
      结果：
        普通代码块1
        代码块之外99
      局部代码块作用:可以限定变量的声明周期.

* D: 构造代码块
    构造代码块是定义在类中成员位置的代码块
    特点：
        优先于构造方法执行，构造代码块用于执行所有对象均需要的初始化动作
        每创建一个对象均会执行一次构造代码块。
    public class Person {
        private String name;
        private int age;

         //构造代码块
        {
            System.out.println(&quot;构造代码块执行了&quot;);
        }
        Person(){
            System.out.println(&quot;Person无参数的构造函数执行&quot;);
        }
        Person(int age){
            this.age = age;
            System.out.println(&quot;Person（age）参数的构造函数执行&quot;);
        }
    }
    class PersonDemo{
        public static void main(String[] args)    {
            Person p = new Person();
            Person p1 = new Person(23);
        }
    }

* E: 静态代码块
    静态代码块是定义在成员位置，使用static修饰的代码块。
    特点：
        它优先于主方法执行、优先于构造代码块执行，当以任意形式第一次使用到该类时执行。
        该类不管创建多少对象，静态代码块只执行一次。
        可用于给静态变量赋值，用来给类进行初始化。
        public class Person {
            private String name;
            private int age;
             //静态代码块
            static{
                System.out.println(&quot;静态代码块执行了&quot;);
            }
        }

* F: 同步代码块(多线程学习)</code></pre><p>###25总结<br>    * 把今天的知识点总结一遍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">KJH</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">175</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KJH</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

<span id="busuanzi_container_site_uv">
  本站总访问量<span id="busuanzi_value_site_uv"></span>次
</span>
        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
