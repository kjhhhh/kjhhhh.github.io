<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:type" content="website">
<meta property="og:title" content="KJHの博客">
<meta property="og:url" content="http://yoursite.com/page/13/index.html">
<meta property="og:site_name" content="KJHの博客">
<meta property="og:description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="匡俊桦">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>KJHの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KJHの博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录&回忆</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">单例设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-27 15:28:55 / 修改时间：15:29:44" itemprop="dateCreated datePublished" datetime="2020-12-27T15:28:55+08:00">2020-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>单例模式（singleton）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>如何保证一个类只有一个实例并且这个实例易于被访问呢？一个全局变量使得一个对象可以被访问，但它不能防止你实例化多个对象。一个更好的办法是，让类自身负责保存它的唯一实例，这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法，这就是 Singleton 模式。</p>
<p>Singleton 类UML图</p>
<p>​                        <img src="/2020/12/27/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20150720215641458" alt="img"></p>
<p>Singleton 类，定义一个 GetInstance 操作，允许客户访问它的唯一实例。GetInstance 是一个静态方法，主要负责创建自己的唯一实例。</p>
<p>Singleton 模式使得这个唯一实例是类的一般实例，但该类被写成只有一个实例能被创建。做到这一点的一个常用方法是将创建这个实例的操作隐藏在一个类操作（即一个静态成员函数或者一个类方法）后面，由它保证只有一个实例被创建。这个操作可以访问保存唯一实例的变量，而且它可以保证这个变量在返回值之前用这个唯一实例初始化。</p>
<p><strong>懒汉模式</strong>：单例模式处理方式要在第一次被引用时，才会将自己实例化，其返回值直到被第一次访问时才创建和保存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> Singleton *instance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Singleton()<span class="comment">//让其private，这样外部程序不能通过其实例化。Singleton obj;错误</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span><span class="comment">//类操作，即一个静态成员函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">NULL</span>)<span class="comment">//没有实例化的情况下在去实例</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			instance = <span class="keyword">new</span> Singleton;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DestroyInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (instance != <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">delete</span> instance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			instance = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">NULL</span>;<span class="comment">//静态成员变量类外初始化</span></span><br></pre></td></tr></table></figure>





<p>客户端代码：</p>
<p>客户端不再考虑是否需要去实例化的问题了，而把责任给了应该负责的类去处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Singleton *s1 = Singleton::GetInstance();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Singleton *s2 = Singleton::GetInstance();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Singleton *s2 = s1-&gt;GetInstance();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s1 == s2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"两个对象是相同的实例"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑到多线程安全。在多线程的程序中，多个线程同时访问 Singleton 类，调用 GetInstance() 方法，会有可能造成创建多个实例的情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> Singleton *instance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Singleton()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span><span class="comment">//类操作，即一个静态成员函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//双重锁定</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> == instance)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			lock();<span class="comment">//实例未创建的情况下加锁，借用其他类实现</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="literal">NULL</span> == instance)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				instance = <span class="keyword">new</span> Singleton;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			unlock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DestroyInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (instance != <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">delete</span> instance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			instance = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">NULL</span>;<span class="comment">//静态成员变量类外初始化</span></span><br></pre></td></tr></table></figure>


<p><strong>饿汉模式</strong>：静态初始化实例方式，在自己被加载时就将自己实例化，提前占用系统资源。</p>
<p>其可以保证线程安全性，因为静态实例初始化在程序开始进入主函数之前就由主线程以单线程方式完成了初始化，不必担心多线程问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> Singleton *instance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Singleton()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">const</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DestroyInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (instance != <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">delete</span> instance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			instance = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//进入主函数之前就完成了实例初始化，是线程安全的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Singleton* Singleton::instance = <span class="keyword">new</span> Singleton;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> Singleton *s1 = Singleton::GetInstance();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> Singleton *s2 = Singleton::GetInstance();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//const Singleton *s2 = s1-&gt;GetInstance();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s1 == s2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"两个对象是相同的实例"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Singleton::DestroyInstance();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B01/" class="post-title-link" itemprop="url">C语言笔记1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-27 15:27:33 / 修改时间：15:28:15" itemprop="dateCreated datePublished" datetime="2020-12-27T15:27:33+08:00">2020-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1、定义申明最重要的区别：定义创建了对象并为这个对象分配了内存，声明没有分配内存。</p>
<p>即一个需要建立存储空间，如 int i; 这是定义；而 extern int i; 是声明，并没有建立存储空间，只是告诉编译器该变量已经在别处定义过了。对于函数的定义和声明也同样如此，这就为什么内联 inline 函数只能在放在函数定义的前面，而不能放在声明之前。</p>
<p>2、在 union 中所有的数据成员共用一个空间，同一时间只能存储其中一个数据成员，所有的数据成员具有相同的起始地址。可以根据这一特性来测试电脑存储模式（大端OR小端），参见代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span> MyUnion</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span> MyUnion mu;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	mu.i = <span class="number">1</span>;   <span class="comment">//0x0001</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == mu.c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"little-endian"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == mu.c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"big-endian"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>术语”大端”和“小端”表示多字节值得哪一端(大端OR小端)存储在该值的起始地址。</p>
<p>3、typedef 的真正意思是给一个已经存在的数据类型(不是变量)取一个别名，而非定义一个新的数据类型。</p>
<p>4、“贪心法”：C语言有这样一个规则：每一个符号应该包含尽可能多的字符。也就是说，编译器将程序分解成符号的方法是，从左到右一个一个字符地读入，如果该字符可能组成一个符号，那么再读入下一个字符，判断已经读入的两个字符组成的字符串是否可能是一个符号的组成部分，如果是，继续读入下一个字符，重复上述判断，直到读入的字符组成的字符串已不再可能组成一个有意义的符号。注意，除了字符串和字符常量，符号的中间不能嵌有空白。</p>
<p>5、关键字 sizeof 求值是在编译的时候，根据类型确定其值。即 sizeof 只能计算在该系统该编译器环境下，数据类型的大小。</p>
<p>6、对指针进行加 1 操作，得到的是下一个元素的地址，而不是原有地址值直接加 1。所以，一个类型为 T 的指针的移动，以 sizeof(T)为移动单位。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> c[] = &#123; <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; &amp;c &lt;&lt; <span class="built_in">endl</span>;                 <span class="comment">//数组C的首地址 ox002afb04</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>*)&amp;c[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">//数组C中字符‘c’的地址 ox002afb06</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; &amp;c + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;             <span class="comment">//ox002afb07 = ox002afb04 + sizeof(c)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; c + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;              <span class="comment">//ox002afb05 = ox002afb04 + sizeof(char)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7、C语言中，当一维数组作为函数参数的时候，编译器总是把它解析成一个指向其首元素首地址的指针，一维数组作为形参传递时是不需要指定大小的，因为函数并不为数组参数分配内存空间，形参只是一个指针，指向其他地方已经分配好的内存空间，所以函数是无法知道数组的长度的，除非显式的把数组长度传递给函数。但是多维数组就需要指定了，因为多维数组的每个元素本身是另外一个数组，编译器需要知道它的维数，以便为函数形参的下标表达式进行求值。</p>
<p>在C语言中，所有非数组形式的数据实参均以传值形式调用，即对实参做一份拷贝并传递给被调用的函数，函数只能修改传递给它的那份拷贝。实际上指针也是传值形式调用，只不过函数内则通过解引用操作实际变量，就习惯把它认作是传址调用传递。编译器总是要为函数的每个参数制作临时副本(位于栈中)。</p>
<p>8、sizeof 与 strlen：sizeof 第5点讲了一部分，sizeof 操作符的结果类型是 size_t ，它在头文件中 typedef 为 unsigned int 类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*无输出结果*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-1</span>; i &lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>); ++i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"csdn"</span> &lt;&lt; <span class="built_in">endl</span>;      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*输出5个csdn*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-1</span>; i &lt; (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(<span class="keyword">int</span>); ++i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"csdn"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个 for 循环，i 与 sizeof(int) 比较时，先将 i 转换为 unsigned int，那就是一个很大的数(VC 4294967295)。</p>
<p>sizeof 是关键字，是算符， strlen 是函数。sizeof 可以用类型作参数，strlen 只能用 char * 做参数，且必须是以‘\0’结尾的。数组作 sizeof 的参数不退化，传递给strlen 就退化为指针。strlen 是在运行期确定，计算的是实际长度。</p>
<p>当适用于一个结构类型或变量，sizeof 返回实际的大小；当适用一静态的空间数组，sizeof 返回全部数组的尺寸，但是 sizeof 操作符不能返回动态的被分配了的数组或外部的数组的尺寸。</p>
<p>sizeof(express) ，其中的 express 在编译过程中是不会被编译的，而是被替代为类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(a = <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//output：4 = sizeof(int)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;                <span class="comment">//output：1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对函数使用 sizeof，在编译阶段会被替换为函数的返回值的类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="string">'c'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(fun()) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//output:1 = sizeof(char)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果函数为 void fun() {} 那么 sizeof(fun()) 编译过程中会出现错误，因为替换之后的sizeof(void) 编译无法通过。</p>
<p>清楚一点，sizeof 是在编译期计算大小的。</p>
<p>9、声明一个指针并不会自动分配任何内存。在对指针执行间接访问前，指针必须执行初始化，使它指向现有的内存，或者给它分配动态内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *p1 = &amp;c;  <span class="comment">//指向现有的内存  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *p2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));  <span class="comment">//分配动态内存</span></span><br></pre></td></tr></table></figure>

<p>10、一个表达式能作为左值，表明该表达式标识了一个特定的内存位置。马克思告诉我们，世界是物质的。计算机科学中，任何数据的存储都需要一个物质性的地址空间。不然数据搁哪？ </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/const%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/const%E7%9A%84%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">const的使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-27 15:26:30 / 修改时间：15:27:04" itemprop="dateCreated datePublished" datetime="2020-12-27T15:26:30+08:00">2020-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对于const，最为熟悉的就是，它允许你指定一个语义约束，也就是指定一个不该被改动的对象，而编译器会强制实施这项约束。const 修饰的值是只读的变量，而不是常量，其值在编译时不能被使用，因为编译器在编译时不知道其存储的内容。下面程序说明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .c file , c project</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Size = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> arr[Size];  <span class="comment">//编译出错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C语言中，编译出错，表明 const 修饰的值不是常量(C语言)。但在C++中同样的代码却不会出现编译错误，因为C++扩展了const 的含义，所以C++和C在某些细节上还是有区别的，不过const在C++中更多的是应用在类中，这里主要讨论C++中的const 。</p>
<p>含指针情况下，const 到底修饰谁？先忽略类型名，const 离谁近，就修饰谁。或者，如果关键字 const 出现在 * 左边，表示被指的对象不可改；如果出现在 * 右边，则表示指针自身不可改，如果两边都有，那就是指针和指针所指的对象不可改。</p>
<p>下面就重点探讨C++类中的 const。</p>
<p>一、const 数据成员</p>
<p>const 数据成员只在某个对象生存期内是只读变量，而对于整个类而言是可变的，因为类可以创建多个对象，不同的对象其 const 数据成员可以是不同值，const 数据成员必须被初始化，且必须使用初始化列表，不能在构造函数的函数体中初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*错误初始化方式*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Test()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		i = <span class="number">5</span>;   <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*正确初始化方式*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Test():i(<span class="number">5</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为定义是在类本身定义的时候进行的(class {}范围)，调用构造函数的时候，首先是给该实例(类的具体对象)分配空间，使用初始化列表就是在分配空间的时候，同时将其空间初始化，而在构造函数的函数体内，所有变量(常量)的空间都已经分配好了，对于const成员变量本身是不能改变其值的，构造函数的函数体{}内的操作只能是赋值，对const 成员变量赋值操作，自然是非法操作。所以const 数据成员的初始化只能在类构造函数的初始化表中进行。</p>
<p>二、const 函数</p>
<p>重头戏来了，const 最具威力的用法是面对函数声明时的应用，在一个函数声明式内，const 可以和函数返回值、各参数、函数本身(成员函数)产生关联。</p>
<p>1、const 函数返回值，即令函数返回一个const 类型，最突出的应用就是运算符重载时保证与内置类型运算符兼容，这样在某些运算符重载时，就不会自创出一些没意义的自定义类型运算符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span> ... &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs);</span><br></pre></td></tr></table></figure>

<p>这样当指向下列操作时就会编译出错。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rational a, b, c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(a * b) = c;    <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<p>如果函数返回值不为const 类型，那么上面的操作是不会出错的，但是这与内置类型不兼容，内置类型不允许对两个数值的乘积再做一次赋值。只要const 了函数返回至，那么这个函数调用就别想作左值。</p>
<p>2、const 参数，保证函数内部不会修改该值，const 作为形参自然伴随着引用或指针，不然就没有实际意义，常用的是 const 引用形参，这样既确保了被调函数不会改变主调函数的数据，又不会像非指针、非引用的参数那样要发生复制，提高效率，虽然传值形式的函数调用也不会修改主调函数的数据，但函数调用时需要额外开辟栈空间拷贝一份副本。需要注意的是形参为const 时，最好实参也为const。如果主函数里面定义了一个const 变量，那么操作该变量的函数的对应形参就必须是const。</p>
<p>3、const 成员函数，将const 实施于成员函数的目的，是为了确认该成员函数可作用于const 对象身上。成员函数声明为const 类型，就意味着该函数不允许修改类中的成员数据(除非成员数据标记为 mutable)，这样编译器看到函数定义为const ，就知道并认为该函数不会去修改类成员数据。</p>
<p>const 成员函数的定义(声明)方式怪怪的，const 放在函数名后面，函数体前面</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> random_arg)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//code</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实际上上面的函数可理解为以下形式 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> Test* <span class="keyword">this</span>, <span class="keyword">int</span> random_arg)</span> <span class="keyword">const</span> </span>&#123;	<span class="comment">/*code*/</span>  &#125;</span><br></pre></td></tr></table></figure>

<p>修饰符const 的作用是限制指针this 指向的对象(const 在 * 左边)只读，也就是调用该函数的对象是只读，该函数不可修改该对象，一旦发现函数体内有修改该对象数据的行为就报错。C++中，this指针是隐藏的，所以就有了前面的const 成员函数声明方式。</p>
<p>C++规定，const 对象只能与const 成员函数连用，目的是为了保护const 对象数据不被改写。另外const成员函数的声明与定义形式需保持一致性，否则编译器将不认为二者是同一个函数。</p>
<p>总结：</p>
<p>1）const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；</p>
<p>2）非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；</p>
<p>3）作为一种良好的编程风格，在声明一个成员函数时，若该成员函数并不对数据成员进行修改操作，应心可能将该成员函数声明为const 成员函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C%E5%90%84%E7%B1%BB%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C%E5%90%84%E7%B1%BB%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">C各类库函数的实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-27 15:25:19 / 修改时间：15:26:08" itemprop="dateCreated datePublished" datetime="2020-12-27T15:25:19+08:00">2020-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这里讨论C语言标准库中各类常用函数，以及它们的高危情况。</p>
<p><strong>1、atoi 函数</strong></p>
<p>这个函数是转换输入字符串转换为整型数。</p>
<p>对于该函数的实现需要考虑以下几个方面：</p>
<ol>
<li>输入字符串为NULL；</li>
<li>输入的字符包含前导的空格；</li>
<li>输入开始是否包含符号‘+’、‘-’；</li>
<li>输入的字符是否合法（对于十进制‘0’~‘9’为合法的输入）；</li>
<li>计算出的数值为 long int，足够判断溢出；</li>
<li>数据溢出的处理（上溢出时，返回最大正数；下溢出时，返回最大负数）；</li>
</ol>
<p>上面的实现比较棘手的就是数据溢出的处理：这里我们用计算出的数值与最大值（最小值的无符号型）/10 进行比较，小于自然不会溢出，由于负数的最大值是-2147483648，最大值是2147483647，个位数不是9，所以还需考虑等于的情况下，个位数的比较。</p>
<p>将计算出的数值与最大值（最小值的无符号型）/10 比较而不是计算出数值<em>10 与最大值比较，是因为计算出的数值</em>10 有可能本身就溢出了。比如输入字符串为”314748364“，计算出的数值为314748364，然后其*10，必然会溢出出错，所以只能进行最大值 /10 操作。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_UINT ((unsigned)~0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_INT  ((int)(MAX_UINT &gt;&gt; 1))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_INT  ((int)~MAX_INT)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atoi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	assert(str != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> minus = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (*str == <span class="string">' '</span>)<span class="comment">//跳过开头空格</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		++str;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*正负判断*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*str == <span class="string">'+'</span> || *str == <span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (*str == <span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			minus = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		++str;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*只针对数字*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (*str &gt;= <span class="string">'0'</span> &amp;&amp; *str &lt;= <span class="string">'9'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		c = *str - <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*正数溢出判断，溢出则返回相应上限值*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!minus &amp;&amp; (res &gt; MAX_INT / <span class="number">10</span> || (res == MAX_INT / <span class="number">10</span> &amp;&amp; c &gt; MAX_INT % <span class="number">10</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			res = MAX_INT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*负数溢出判断，这里的比较转换为无符号，大于则溢出*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (minus &amp;&amp; (res &gt; (<span class="keyword">unsigned</span>)MIN_INT / <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			|| (res == (<span class="keyword">unsigned</span>)MIN_INT / <span class="number">10</span> &amp;&amp; c &gt; (<span class="keyword">unsigned</span>)MIN_INT % <span class="number">10</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			res = MIN_INT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		res = res * <span class="number">10</span> + c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		++str;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> minus ? -res : res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><em>\</em>2、strcpy 函数和 memcpy 函数**</strong></p>
<p>strcpy 函数可以复制以null 为退出字符的存储器区块到另一个存储器区块内，只用于字符串的复制，字符串在存储器内以连续的字节区块组成，strcpy 可以有效复制两个配置在存储器以指针回传的字符串（也就是字符指针或字符串指针）。</p>
<p>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> * dst, <span class="keyword">const</span> <span class="keyword">char</span> * src)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把src的内容复制到dst，然后目的字符串dst指针*/</span></span><br></pre></td></tr></table></figure>

<p>先下面看看微软的写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * __cdecl <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> * dst, <span class="keyword">const</span> <span class="keyword">char</span> * src)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> * cp = dst;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (*cp++ = *src++)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		;               <span class="comment">/* Copy src over dst */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(dst);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个写法为了提高性能，减去了那些安全检查，其余漏洞后面讨论。</p>
<p>除去安全性检查，strcpy 还不允许 src 与 dst 两内存块有重叠。只要有重叠势必会写入修改src 只读区域，这是不允许的，另外有重叠区域，当dst 在高地址时，复制过来的可能就是dst 前面部分的字符了。鉴于上面分析，我们写出下面实现代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> * dst, <span class="keyword">const</span> <span class="keyword">char</span> * src)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *ret = dst;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    assert((dst != <span class="literal">NULL</span>) &amp;&amp; (src != <span class="literal">NULL</span>));<span class="comment">//检查指针的有效性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    count = <span class="built_in">strlen</span>(src);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    assert((src + count &lt; dst) || (dst + count &lt; src));<span class="comment">//检查内存是否存在重叠区域，此处非最优方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*ret++ = *src++)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面的程序最后返回 char* 类型，是为了使函数能够支持链式表达式，增加了函数的“附加值”。</p>
<p>实际上上面对于地址重叠还有一个更好的解决方法，那就是判断地址是哪部分重叠，如果dst 地址位于 src 前面，按照正常的赋值操作是没问题的，如果dst地址位于src后面，那么则从src尾部开始复制，这样可以解决地址重叠问题。代码就不贴出来了，可自行画一个示意图，一目了然。</p>
<p>另外值得注意的是：上面那个函数一样，这是strcpy 的硬伤，就是必须为目标字串分配足够的空间，如果目标字串的长度小于源字串的长度，那么在复制操作的时候会出现缓存溢出。在拷贝字符串的时候没有越界检查，这使得 strcpy 成为一个高危函数。</p>
<p>从strcpy 函数的参数就可以看出，strcpy 只能复制字符串，也不需要指定复制长度（strncpy 需要指定长度）</p>
<p>下面顺带看看memcpy 函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> * dst, <span class="keyword">const</span> <span class="keyword">void</span> * src, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *ret = dst;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    assert((dst != <span class="literal">NULL</span>) &amp;&amp; (src != <span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count--)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        *(<span class="keyword">char</span>*)dst = *(<span class="keyword">char</span>*)src; <span class="comment">//强制转换为char*，因为char占一个字节</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dst = (<span class="keyword">char</span> *)dst + <span class="number">1</span>;     <span class="comment">//这样，地址增加一个字节位移，可以全部复制</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        src = (<span class="keyword">char</span> *)src + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>memcpy 接受void* 类型的形参，这使得memcpy 函数可以复制任意内容。strcpy 拷贝是遇到‘\0’ 就停止，而memcpy 并不是遇到‘\0’ 就结束，而是一定拷贝 count 个字符。一般而言，在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy。</p>
<p><strong>3、strcat 函数</strong></p>
<p>函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strcat</span><span class="params">(<span class="keyword">char</span> * dst, <span class="keyword">const</span> <span class="keyword">char</span> * src)</span></span></span><br></pre></td></tr></table></figure>

<p>功能是把 src 所指字符串添加到 dst 结尾处（覆盖dst 结尾处的’\0’）并添加’\0’，最终返回指向 dst 的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strcat</span><span class="params">(<span class="keyword">char</span> * dst, <span class="keyword">const</span> <span class="keyword">char</span> * src)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	assert(dst != <span class="literal">NULL</span> &amp;&amp; src != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> count = <span class="built_in">strlen</span>(src);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	assert((src + count &lt; dst) || (dst + count &lt; src)); <span class="comment">/*检查是否重叠*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> * cp = dst;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (*cp)                 <span class="comment">/*先判断，再指针增加*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		cp++;                   <span class="comment">/* dst末位置 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (*cp++ = *src++);       <span class="comment">/* 拷贝 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(dst);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>src 和 dst 所指的内存区域不可以重叠且 dst 必须保证有足够的空间来容纳 src 的字符串，否则会出错。C 语言标准库中strcat 函数同 strcpy 函数一样，没有保证dst 有足够的空间容纳操作后的字符串，也使得strcat 成为一个高危函数。</p>
<p><strong>4、strcmp 函数</strong></p>
<p>该函数用于比较两个字符串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * src, <span class="keyword">const</span> <span class="keyword">char</span> * dst)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	assert((src != <span class="literal">NULL</span>) &amp;&amp; (dst != <span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*两个字符串自左向右逐个比较(ASCII值)，直到出现不同字符或dst遇'\0'为止*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*如果前面字符相同，dst的'\0'最后会参与比较*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!(ret = *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)src - *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)dst) &amp;&amp; *dst)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		++src, ++dst;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*不同返回值对应不同比较结果*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(ret);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C++%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C++%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">C++指针与引用的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-27 15:23:56" itemprop="dateCreated datePublished" datetime="2020-12-27T15:23:56+08:00">2020-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-02 21:49:34" itemprop="dateModified" datetime="2021-03-02T21:49:34+08:00">2021-03-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>先写出两者的3点区别，后面再具体分析：</p>
<ol>
<li>当引用被创建时，它必须被初始化，而指针则可以在任何时候被初始化</li>
<li>一旦一个引用被初始化为指向一个对象，它就不能被改变为对另一个对象的引用，而指针可以在任何时候指向另一个对象</li>
<li>不可能有NULL引用，必须确保引用是和一块合法的存储单元关联，而指针可以初始化为NULL</li>
</ol>
<p>从概念上讲，指针(pointers)从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变，这点后面再详细叙述。</p>
<p>而引用(references)是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的，自始至终只能依附于同一个变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"sunburn"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"saltwater"</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> &amp;rs = s1;        <span class="comment">//引用，rs代表s1</span></span><br><span class="line"><span class="built_in">string</span> *ps = &amp;s1;       <span class="comment">//指针，ps指向s1</span></span><br><span class="line">rs = s2;                <span class="comment">//rs仍然是代表s1，但是s1的值现在变成了"saltwater"</span></span><br><span class="line">                        <span class="comment">//rs一直依附于s1，rs的值就是s1的值</span></span><br><span class="line"></span><br><span class="line">*ps = <span class="string">"owl city"</span>;       <span class="comment">//修改ps指向的地址中所存放的数据，也就是s1变成了"owl city"</span></span><br><span class="line">						<span class="comment">//rs依附于s1，那么这里rs也会变成"owl city"</span></span><br><span class="line">ps = &amp;s2;               <span class="comment">//修改ps所指向的地址，ps现在指向s2，s1没有变化</span></span><br></pre></td></tr></table></figure>

<p>从上面可以得知，指针可以被重新赋值，指向另一个对象，引用却总是代表它最初获得的那个对象。</p>
<p>一般而言，当你需要不指向任何对象时，或是需要在不同时间指向不同对象时，你就应该采用指针，前一种情况你可以将指针设为NULL，后一种情况你可以改变指针所指对象（地址）。而当你确定总是会代表某个对象，而且一旦代表了该对象就不再改变，就应该选用引用。</p>
<p>有一点最基本的，那就是没有所谓的空引用（NULL references），一个引用必须总是代表一个对象，所以如果你有一个变量，其目的是用来指向(代表)另一个对象，但是也可能它不指向任何对象，那么你就应该使用指针，如果这个变量必须总是代表一个对象，并且不允许这个变量为NULL，那么就应该选用引用。说白了，就是C++允许空指针，但不允许空引用。</p>
<p>引用一定得代表某个对象，因此要求引用必须有初值，但是对指针则没有这样的要求</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"sunburn"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"saltwater"</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> &amp;rs = s1;        <span class="comment">//初始化</span></span><br><span class="line"><span class="built_in">string</span> &amp;rs;             <span class="comment">//未初始化，error</span></span><br><span class="line"><span class="built_in">string</span> *ps;             <span class="comment">//未初始化的指针，有效，但是风险高，</span></span><br><span class="line">                        <span class="comment">//实际上，在应用中是不允许的</span></span><br></pre></td></tr></table></figure>

<p>没有所谓的空引用，这就意味着当使用引用传递形参参数时，则不需要测试其参数的有效性，相反如果使用指针，通常就得测试它是否为NULL。</p>
<p>下面看看在C++中，指针和引用在函数参数传递中的区别：</p>
<p>说到指针传递，以前在C中经常同值传递进行区别，其实指针传递本质上也是值传递的方式，只不过传递的是一个地址值，值传递过程中，被调函数的形参作为被调函数的局部变量处理，即在栈中开辟内存空间存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形参的任何操作都是作为局部变量处理的，其值都存放在栈中，随着被调函数的结束而消亡，不会影响主调函数中实参变量的值，指针传递过程中的实参变量指的则是实参指针，指针传递的目的是通过被调函数去修改实参变量，那么被调函数内部的操作肯定是解指针操作，也就是透过传过来的指针的副本来操作其指向的变量（实参变量）。</p>
<p>而在引用传递过程中，被调函数的形式参数自然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址，然后被调函数对形参的任何操作都被处理成间接寻址，通过栈中存放的地址访问主调函数中的实参变量。这个和前面的说到的指针传递就相同了，都是通过栈中的地址访问主调函数的实参变量，只不过引用传递则不需要指针的解引用操作，直接对形参的操作都会被内部解析为通过地址访问实参变量，从而去影响主调函数中的实参变量。但从这点来看，引用传递其实也是指针传递，只不过这一切实现都隐藏在内部，由编译器完成。</p>
<p>我们对比看下指针传递和引用传递的反汇编代码：</p>
<p><img src="/2020/12/27/C++%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/20140826213733671" alt="img"></p>
<p>上面这两个简单的被调函数都是实现相同的功能，代码的实现上存在本质区别，一个是指针传递一个是引用传递，但是内部的操作，从其反汇编代码来看（红色框框内），两者的汇编代码是一模一样的。但是从代码的实现上来看，引用传递显得更为高效和简洁，无需检查传入参数的有效性，并且不会带入指针这个易错量。</p>
<p>注意的是上面说的一模一样是针对指针传递是以透过指针变量来操作实参变量的目的。当然，如果单一的操作指针变量，没有解引用操作，也就是只改变被调函数中的指针地址，那么它将影响不到主调函数中的相关变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1 = str2;    <span class="comment">//这里指针变量作为局部变量，不会影响到主调函数的实参变量</span></span><br></pre></td></tr></table></figure>

<p>当然，如果实际上应用指针传递形参的话，是不会这样去操作的。</p>
<p>其实二者都是地址的概念。指针指向一块内存，它的内容是所指内存的地址，而引用则是某块内存的别名，既然是别名，那么在参数传递时，引用并不会产生对象的副本，对象无需复制，效率更高，以及在函数的返回值上，返回一个对象的引用有时也是必须的，尤其在某些运算符的重载上。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/" class="post-title-link" itemprop="url">C++运算符重载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-27 15:22:33 / 修改时间：15:23:22" itemprop="dateCreated datePublished" datetime="2020-12-27T15:22:33+08:00">2020-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一、运算符的定义</p>
<p>运算符重载就是运算符的“一符多用”。重载运算符是具有特殊名称的函数：保留字 operator 后接需定义的操作符符号。像任意其他函数一样，重载操作符具有返回类型和形参表，每个操作符用于内置类型都有关联的定义，当内置操作符和类型上的操作存在逻辑对应关系时，操作符重载最有用，最直观，使用重载操作符并不是创造命名操作。</p>
<p>二、在哪种情况下使用哪种重载运算符的方式合适？</p>
<p>C++ 提供了两种重载运算符的方式，在大多数情况下：</p>
<ul>
<li>只有一个操作数的运算符（一目）使用类运算符重载方式为好；</li>
<li>一般地说，如果运算符要修改操作数（类对象）的状态（值），则应使用类运算符（成员形式）。（在计算中可能改变操作数的值得运算符被称为有副作用的运算符，诸如：=、+=、-=、*=、/=、%=、++、– 等）；</li>
<li>C++规定，运算符=、()、[ ]、-&gt; 只能采用类运算符形式重载；</li>
<li>有两个操作数的运算符（二目）使用友元运算符重载方式为好；</li>
<li>友元运算符重载方式在操作数的数据类型自动转换方面更为宽容，尤其是第一个操作数希望能够隐式类型转换时，则应采用友元形式；</li>
<li>不允许重载的运算符有：&amp;&amp;、||、. 、:: 、 * 、?: 。</li>
</ul>
<p>三、运算符重载具体讨论（返回值和参数，这里讨论几个常用的运算符）</p>
<p>默认地，重载运算符必须与内置操作符保持一致，也就是说重载后的运算符必须与本来内置操作符保持特性一致。函数最主要的两个就是返回值和形参。</p>
<p>3.1、前缀++类运算符重载函数（前缀–类似）</p>
<p>自增（自减）操作符的前置式定义：累加（递减）而后取出；后置式定义：取出而后累加（递减）。</p>
<p>我们知道，在C语言里整型变量是允许连续前缀++两次的，也叫链式操作。这样为了保证重载运算符与内置操作符++类型一致，就要求前缀++类运算符重载函数也支持连续操作（链式操作），所以前缀++类运算符重载函数的返回值必须是类名的引用。上面第二点也说了，++作为单目运算符，并且会修改操作数的值，则应定义为类运算符，这样重载函数无形参。我们就可申明该前缀++类运算符重载函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zoo</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Zoo(<span class="keyword">int</span> lion_n = <span class="number">0</span>, <span class="keyword">int</span> tiger_n = <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		lion = lion_n; tiger = tiger_n; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	~Zoo()&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Zoo&amp; <span class="keyword">operator</span>++();<span class="comment">//无参，返回值为类名的引用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> lion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> tiger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面就是前缀++类运算符重载函数的实现了</p>
<p>内置类型前缀++操作符是直接修改了操作数，然后返回修改后的操作数本身（唯一地址），不存在复制的情况，所以重载函数也应遵循这一点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Zoo&amp; Zoo::<span class="keyword">operator</span>++()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++lion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++tiger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>由于函数的返回值类型被定义为引用，所以不会发生复制，返回的是操作数本身，完全符合内置前缀++的语法定义。</p>
<p>我们再来考虑错误情况：如果前缀++类运算符重载函数的返回值是类型，也就是返回一个对象，其对应实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Zoo Zoo::<span class="keyword">operator</span>++()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++lion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++tiger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>咋一看上面的也实现了前缀++的功能，但是返回值是对象，在函数返回时会发生复制，虽然该函数成功将操作类对象的成员修改了，但是函数返回的是一个复制品，然后再执行++链式操作时，修改的会是这个复制品的值（相当于这个复制品调用前缀++类运算符重载函数），本尊并没有修改，也就是不能成功实现链式操作，不符合内置++的语法定义（ C++中，前缀++是可以连续前缀两次以上的，但后缀++则不可以）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Zoo zoo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">++(++zoo);</span><br></pre></td></tr></table></figure>

<p>上面执行后，zoo.lion = 1，zoo.tiger = 1 。并不是期望的2。</p>
<p>至于返回其余类型那就更加错误了。</p>
<p>3.2、后缀++类运算符重载函数（后缀–类似）</p>
<p>与前缀++操作符一样，后缀++也是单目操作符，也会修改操作书本身，所以二者的形参数目和类型相同，为了区别函数，后缀++操作符接受一个额外的（即，无用的）int 型形参。使用后缀++操作符时，编译器提供0作为这个形参的实参。</p>
<p>与前缀++类运算符截然相反的是，后缀++返回值的类型恰恰不能是类的引用，其目的是在返回值时引起复制，即让一个并未自增的替身对象去参加表达式的后续运算，另外C/C++在语法上不允许后缀++连续运算两次以上，也就不要求返回引用，并且必须返回 const 对象。我们看看内置后缀++操作符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j = i++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i++++;  <span class="comment">//违法</span></span><br></pre></td></tr></table></figure>

<p>内置后缀++操作符，操作数 i 本身已经完成了自增，但是后续的赋值操作并不是将自增后的 i 赋值给j，而是将并未自增的替身参与赋值运算。所以在重载后缀++类运算符的时候，我们应该考虑这点，另外必须返回一个 const 对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Zoo Zoo::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">Zoo <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;<span class="comment">//拷贝构造函数，构造复制品</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++lion;<span class="comment">//本尊自增</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++tiger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;<span class="comment">//返回复制品</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在已经定义了前缀++类运算符重载函数的情况下，后缀++类运算符重载函数一般这样实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Zoo Zoo::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">Zoo <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;<span class="comment">//拷贝构造函数，构造复制品</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++(*<span class="keyword">this</span>);<span class="comment">//本尊自增</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;<span class="comment">//返回复制品</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.3、二目运算符重载（+=，-=，+，-） </p>
<p>先说复合赋值操作符，上面“+=”，“-=”也可认为是赋值操作符。内置+=、-=、%= 是允许进行链式操作的（如果不确定是否允许，可以写一个测试程序判断），所以为了与内置类型的操作一致，重载函数毫无疑问是返回一个引用，也避免了创建和撤销结果的临时副本。</p>
<p>但是“+”“-” 等是返回一个新的结果，这就要求算术运算符的重载不能返回一个引用，另外+的表达式也不能作为左值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = i + j + j;<span class="comment">//可以连续+，但是右边的i,j还是原值，(i+j) = i + i;错误！</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       i += (i += j);<span class="comment">//复合了赋值操作符，这样是允许的</span></span><br></pre></td></tr></table></figure>

<p>有了前面分析，不难写出上面的重载函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Zoo&amp; Zoo::<span class="keyword">operator</span>+=(Zoo &amp;rhs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	lion += rhs.lion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	tiger += rhs.tiger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继而过来讨论“+”“-”：</p>
<p><strong>返回值是一个右值</strong></p>
<p>前面说到了，“+”“-”是返回一个新的结果，算术运算符通常产生一个新值，该值是两个操作数的计算结果，它不同于任一操作数且在一个局部变量中计算，返回对那个变量的引用是一个运行时错误。通俗一点，假如算术运算符重载函数返回一个对象的引用，这个引用是两个操作的计算结果，它的本体就会是一个局部变量（对象），返回一个局部变量的引用，是错误的。所以对于类算术运算符的重载，只能返回一个右值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Zoo <span class="keyword">operator</span>+(Zoo &amp;first, Zoo &amp;second)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">Zoo <span class="title">ret</span><span class="params">(first)</span></span>;<span class="comment">//拷贝构造函数，构造一个局部变量，用于返回值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ret += second;<span class="comment">//运算操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;<span class="comment">//返回一个值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二目算术运算符重载通常使用友元运算符重载方式。</p>
<p>从上面也可以看出，类运算符的重载最好与内置运算符保持一致，虽然没硬性规定，但这俨然成了一个默认规定。</p>
<p>另外 !（逻辑反）、~（按位与）、-（负号）等与二目算术运算符有类似之处，那就他们都不会修改原对象数据成员，而是将运算结果交给一个新值，所以在重载时，需要构造一个临时对象作为返回值，返回值也就同样不能是引用。</p>
<p>3.4、输入输出操作符重载</p>
<p>支持I/O操作的类所提供的I/O操作接口，一般应该与标准库iostream为内置类型定义的接口相同。</p>
<p>1、输出操作符 &lt;&lt; 的重载</p>
<p>为了与I/O标准库一致，操作符应接受 ostream&amp; 作为第一个形参，对类类型 const 对象的引用作为第二个形参，并返回对 ostream 形参的引用。</p>
<p>重载输出操作符可能相对于比较难理解，这里简单的说下，我们只能以自定义类的友元函数的形式重载这两个运算符，这是因为如果我们用成员函数的形式来重载的话，就要改动系统的流类 istream 和 ostream 定义，这是C++不允许的，如果不定义为友元函数的话，将无法调用类对象成员数据输出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; stream, <span class="keyword">const</span> Zoo &amp;object)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//对object所引用的对象的数据进行的输出操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	stream &lt;&lt; object.lion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	stream &lt;&lt; object.tiger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> stream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看上面这个输出操作符重载函数，第一个参数是 ostream 类的引用，而函数的返回值也是 ostream 类的引用。毫无疑问，我们调用这个运算符重载函数时。实参肯定是 cout，这样就造成了这样一种情况：实参 stream 引用 cout，而函数的返回值又引用 stream，等于函数返回值引用的实体还是 cout。这样做的目的是实现了连续的输出操作。当执行下面语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; zoo_a &lt;&lt; zoo_b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面 cout &lt;&lt; zoo_a 实质就是调用 operator&lt;&lt;(cout, zoo_a),然后返回 cout</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下一个 &lt;&lt; 就相当于执行 cout &lt;&lt; zoo_b, 同上</span></span><br></pre></td></tr></table></figure>

<p>我们不能将该操作符重载函数定义为类的成员函数，否则，左操作数将只能是该类类型的对象。IO操作符通常要对非公用数据成员进行读写，因此，类通常将IO操作符（输入输出）设为友元。</p>
<p>2、输入操作符 &gt;&gt; 的重载</p>
<p>为了与IO标准库一致，操作符应接受 istream&amp; 作为第一个形参，指向它要读的流，并且返回的也是对同一个流的引用（链式操作）。它的第二个形参是对要读入的对象的非 const 引用，该形参必须为非 const，因为输入操作符的目的是将数据读到这个对象中。</p>
<p>更重要但通常重视不够的是，输入和输出操作符有如下区别：输入操作符必须处理错误和文件结束的可能性。</p>
<p>输入期间的错误：任何读操作都可能因为提供的值不正确而失败；任何读入都可能碰到输入流中的文件结束或其他一些错误。也就需要对输入进行附加检查，发现有这些错误就需要我们进行处理。</p>
<p>3.5、不能重载的运算符 &amp;&amp;、|| 和 , 操作符</p>
<p>和 C 一样，C++ 对于真假值表达式采用所谓骤死式评估方式。意思是一旦该表达式的真假值去顶，纵使表达式中还有部分尚未检验，整个评估工作仍告结束。比如下面这种情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((p != <span class="literal">NULL</span>) &amp;&amp; (<span class="built_in">strlen</span>(p) &gt; <span class="number">10</span>) ……</span><br></pre></td></tr></table></figure>

<p>你无需担心调用 strlen 时 p 是否为 NULL 指针，因为如果 p 是否为NULL 的测试结果是否定的，strlen 就绝不会被调用。事实上，对一个 NULL 指针调用 strlen，结果未可预期。</p>
<p>回到重载，C++ 允许我们为用户定制型别量身定做各类操作符，包括 &amp;&amp; 和 ||，操作符重载语义上是允许的，但是我们要考虑重载会不会改变对应内置操作符的规则。拿 &amp;&amp; 和 || 来说，重载则是对 operator &amp;&amp; 和 operator || 两函数进行重载工作，值得注意的是，函数调用语义将会取代骤死式语义，也就是说，如果你将operator &amp;&amp; 重载，下面这个虱子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression1 &amp;&amp; expression2) ……</span><br></pre></td></tr></table></figure>

<p>会被编译器视为以下两者之一：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression1.<span class="keyword">operator</span>&amp;&amp;(expression2)) ……</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设 operator&amp;&amp; 是个 member function</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">operator</span>&amp;&amp;(expression1, expression2)) ……</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设 operator&amp;&amp; 是个全局函数</span></span><br></pre></td></tr></table></figure>

<p>上面函数调用语义和所谓骤死式语义有两个重大的不同。第一，当函数调用动作被执行起来，所有参数值都必须评估完成，所以当我们调用 operator&amp;&amp; 和 operator|| 时，两个参数都已评估完成，没有什么骤死式语义。第二，C++ 语言规格并未明定函数调用动作中各参数的评估次序，所以没办法知道 expression1 和 expression2 哪个会先被评估，而内置的真假值表达式，则总是由左向右评估其自变量。</p>
<p>C++ 中，运算符重载的一个重要参考就是：不能修改运算符的内置语义。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Amalloc%E3%80%81calloc%E3%80%81free%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Amalloc%E3%80%81calloc%E3%80%81free%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">C语言内存管理：malloc、calloc、free的实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-27 15:20:44 / 修改时间：15:22:09" itemprop="dateCreated datePublished" datetime="2020-12-27T15:20:44+08:00">2020-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>任何一个对C稍稍有了解的人都知道malloc、calloc、free。前面两个是用户态在堆上分配一段连续（虚拟地址）的内存空间，然后可以通过free释放，但是，同时也会有很多人对其背后的实现机制不了解。<br>这篇文章则是通过介绍这三个函数，并简单的予以实现，对比现有C的标准库实现（glibc等）相比，并不是特别高效，我们重在阐述背后的基本原理。</p>
<p><strong>一、C程序的存储空间布局</strong></p>
<p>图1<br><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Amalloc%E3%80%81calloc%E3%80%81free%E7%9A%84%E5%AE%9E%E7%8E%B0/20160103134018703" alt="这里写图片描述"></p>
<ul>
<li>text：整个用户空间的最低地址部分，存放的是指令（程序所编译成的可执行机器码）。可共享，即使是频繁操作执行的程序，在存储器中也只需有一个副本，通常是只读的。</li>
<li>initialized data(data)：存放初始化过的全局变量，包含了程序中需明确地赋初值的变量。</li>
<li>uninitialized data(bss)：存放的是未初始化过的全局变量，在程序开始执行之前，内核将此段中的数据初始化为0或者NULL。</li>
<li>heap：堆，自低地址向高地址增长，后面重点剖析</li>
<li>stack：栈，自高地址向低地址增长，自动变量以及每次函数调用时所需保存的信息都存放在此段中。</li>
</ul>
<p><strong>二、Heap 内存模型</strong></p>
<p>一般来说，malloc所申请的内存主要从heap区域分配的。<br><a href="http://blog.csdn.net/wenqian1991/article/details/25159545" target="_blank" rel="noopener">linux内存管理</a>，从这里可以了解到linux下虚拟地址与物理地址。</p>
<p>linux对堆的管理如下：<br>图2<br><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Amalloc%E3%80%81calloc%E3%80%81free%E7%9A%84%E5%AE%9E%E7%8E%B0/20160103142123394" alt="这里写图片描述"></p>
<p>linux 内核维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址（Heap’s Start）到break之间的地址空间为映射好的（虚拟地址与物理地址的映射，通过MMU实现），可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。</p>
<p>所以，如果Mapped Region 空间不够时，会调整break指针，扩大映射空间，重新分配内存。</p>
<p><strong>三、调整break：brk()和sbrk()</strong></p>
<p>最初break的位置正好位于bss端末尾之后，看图1，在break指针的位置升高时，程序可以访问新分配区域内的任何内存地址，而此时物理内存页尚未分配，内存会在京城首次试图访问这些虚拟内存地址时自动分配新的物理内存页。</p>
<p>linux通过brk和sbrk系统调用操作break指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> increment)</span></span>;<span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>brk() 将break指针设置为 addr 所指定的位置，由于虚拟内存以页为单位进行分配，addr实际会四舍五入到下一个内存也的边界处。<br>由于brk是直接指定一个地址，所以一旦这个值取得过低，有可能导致不可预知的行为，对照图1，brk只能在指定的区域内调整break。</p>
<p>sbrk() 将break指针在原有地址增加从参数 increment 传入的大小（linux中，sbrk是基于brk基础上实现的一个库函数），用于声明increment 的intptr_t 类型属于整数数据类型。<br>若调用成功，sbrk() 返回前一个break 的地址，换言之，如果break 增加，那么返回值是指向这块新分配内存起始位置的指针。<br>sbrk(0) 将得到当前break指针的位置。</p>
<p>系统对每一个进程所分配的资源不是无限的，包括可映射的内存空间，图2，未映射内存的尾端有个rlimit表示当前进程可用的资源上限。</p>
<p><strong>三、malloc</strong></p>
<p>根据标准C库函数的定义，malloc 具有如下模型：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这个函数要实现的功能是在系统中分配一段连续的可用的内存，具体有如下要求：<br>- malloc分配的内存大小至少为size参数所指定的字节数<br>- malloc的返回值是一个指针，指向一段可用内存的起始地址<br>- 多次调用malloc所分配的地址不能有重叠部分，除非该地址已经被释放掉<br>- malloc应该尽快完成内存分配并返回（不能使用<a href="https://en.wikipedia.org/wiki/NP-hardness" target="_blank" rel="noopener">NP-hard</a>的内存分配算法）<br>- 实现malloc时，应该同时实现内存大小调整和内存释放函数（calloc和free）<br>- malloc分配失败时必须返回NULL</p>
<p>malloc 返回内存块所采用的字节对齐方式，总是适宜于高效访问任何类型的C语言数据结构。</p>
<p><strong>四、初探实现malloc：</strong></p>
<p>我们假定整个内存处于初始状态，即break指针位于bss段的单位，整个heap都是 Unmapped Region。（图2）<br>基于此，我们可以实现一个简单但毫无实际价值的malloc：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*一个糟糕的仿制malloc*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#incldue <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line">    p = sbrk(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*如果sbrk失败，返回NULL*/</span></span><br><span class="line">    <span class="keyword">if</span>(sbrk(<span class="built_in">size</span>) == (<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;<span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<p>这个malloc就是从未映射区域直接划出一块，但是malloc对这块已分配的内存缺乏记录，不便于内存释放。</p>
<p><strong>五、正式实现malloc</strong></p>
<p>上面说到分配的内存没有记录，一旦调用free释放，free不知道它到底要释放多大的内存，所以我们需要额外一个数据结构来记录这些信息。</p>
<p><strong>5.1、数据结构</strong><br>一个简单可行方案是将堆内存以块的形式组织起来，每个块（block）由meta区和数据区组成，meta去记录数据块的元信息（数据块大小、空闲标志位、指针等），数据区则是真实分配的内存区域，并且数据区的第一个字节地址即为malloc返回的地址。</p>
<p>可用如下结构体定义一个block：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> *<span class="title">t_block</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_block</span>&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span>   <span class="built_in">size</span>;<span class="comment">//数据区大小</span></span><br><span class="line">    t_block  next;<span class="comment">//指向下个块的指针</span></span><br><span class="line">    <span class="keyword">int</span>      <span class="built_in">free</span>;<span class="comment">//是否是空闲块</span></span><br><span class="line">    <span class="keyword">char</span>     data[<span class="number">1</span>];<span class="comment">//虚拟字段，表示数据块的第一个字节，长度不计入meta</span></span><br><span class="line">&#125;;<span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p>图3<br><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Amalloc%E3%80%81calloc%E3%80%81free%E7%9A%84%E5%AE%9E%E7%8E%B0/20160103160120434" alt="这里写图片描述"></p>
<p>那么用这个结构体来分配内存，而不用malloc则是下面一番场景：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t_block  <span class="keyword">b;</span></span><br><span class="line"><span class="keyword">b </span>= <span class="keyword">sbrk(0);</span></span><br><span class="line"><span class="keyword">sbrk(sizeof(struct </span>s_block) + size);</span><br><span class="line"><span class="keyword">b-&gt;size </span>= size<span class="comment">;//size 为要分配的内存大小1234</span></span><br></pre></td></tr></table></figure>

<p><strong>5.2、寻找合适的block</strong><br>我们从堆的起始地址开始查找第一个符合要求的block，并返回block起始地址，如果找不到就返回NULL；</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">t_block</span> find_block(t_block *last, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    t_block <span class="keyword">b </span>= <span class="keyword">base;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="meta">while</span>(<span class="keyword">b </span>&amp;&amp; !(<span class="keyword">b-&gt;free </span>&amp;&amp; <span class="keyword">b-&gt;size </span>&gt;= size))</span><br><span class="line">    &#123;</span><br><span class="line">        *last = <span class="keyword">b;</span></span><br><span class="line"><span class="keyword"> </span>       <span class="keyword">b </span>= <span class="keyword">b-&gt;next;</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line"><span class="symbol">return</span> <span class="keyword">b;</span></span><br><span class="line"><span class="keyword">&#125;12345678910</span></span><br></pre></td></tr></table></figure>

<p>这里base是一个全局变量，维护整个堆的起始地址。另外，这里在遍历时会更新一个last指针，这个指针始终指向当前遍历的block，如果找不到合适的block，那么malloc将很容易的开辟新的block使用。</p>
<p><strong>5.3、开辟新的block</strong><br>如果现有block都不能满足需求，则需要在链表最后开辟一个新的block。最简单的方式就是利用sbrk升高break位置然后对其初始化，然后更新对应block指针，将其add到链表最后。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">t_block <span class="title">extend_heap</span><span class="params">(t_block last, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t_block b;</span><br><span class="line">    b = sbrk(<span class="number">0</span>);<span class="comment">//定位到当前break位置</span></span><br><span class="line">    <span class="keyword">if</span>(sbrk(<span class="keyword">sizeof</span>(struct s_block) + <span class="built_in">size</span>) == (<span class="keyword">void</span>*)<span class="number">-1</span>)<span class="comment">//调整break位置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    b-&gt;<span class="built_in">size</span> = <span class="built_in">size</span>;</span><br><span class="line">    b-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(last)<span class="comment">//这个last是指向extend之前最后一个block</span></span><br><span class="line">        last-&gt;next = b;<span class="comment">//新开辟的block挂载在链表中</span></span><br><span class="line">    b-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;<span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<p><strong>5.4、分裂block</strong><br>看前面 find_block() 的实现，如果我们申请的 size 远小于查找到的 block。（这种情况是可能，它是查到第一个满足条件（大小，可用）的block），这样会导致较大内部碎片的产生。<br>所以，应该在剩余数据区足够大的情况下，将其分裂成一个新的block：</p>
<p>图4<br><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Amalloc%E3%80%81calloc%E3%80%81free%E7%9A%84%E5%AE%9E%E7%8E%B0/20160103165244021" alt="这里写图片描述"></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//b是要分裂的block，size是申请的内存大小</span></span><br><span class="line"><span class="comment">//分裂后b成了分配后的block</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split_block</span><span class="params">(t_block b, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t_block <span class="keyword">new</span>;<span class="comment">//新的空闲block = 要分裂的block - 申请分配出去的内存</span></span><br><span class="line">    <span class="keyword">new</span> = b-&gt;data + <span class="built_in">size</span>;<span class="comment">//将new定位到剩下的数据块区域</span></span><br><span class="line">    <span class="comment">//分裂的原block-分配出去的内存大小-block结构体本身大小</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;<span class="built_in">size</span> = b-&gt;<span class="built_in">size</span> - <span class="built_in">size</span> - BLOCK_SIZE;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = b-&gt;next;<span class="comment">//链表插入</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;<span class="built_in">free</span> = <span class="number">1</span>;<span class="comment">//空闲标记可用</span></span><br><span class="line">    b-&gt;<span class="built_in">size</span> = <span class="built_in">size</span>;</span><br><span class="line">    b-&gt;next = <span class="keyword">new</span>;<span class="comment">//链表插入</span></span><br><span class="line">&#125;<span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<p>看了上面一大串，是不是跟伙伴算法很像。但是这里的分裂block函数，得视情况调用，如果申请的size &lt; block-&gt;size，但是又不是小太多，如果分裂block的话，会导致分裂后剩余未分配出去的数据块过小，无法满足其余需求，很容易形成内存碎片。</p>
<p>所以，伙伴算法有更高效的处理（实际上伙伴算法也会产生内部碎片）。</p>
<p><strong>5.5、malloc 的实现</strong><br>铺垫做了那么多，我们可以利用它们整合成一个简单可用的malloc。<br>首先定义一个block链表的头指针，初始化为NULL，另外，我们需要剩余空间至少有 BLOCK_SIZE + 4 才执行分离操作。</p>
<p>此外，一开始我们讲到，malloc对分配的内存大小也有要求，是按4字节对齐，所以申请的size不为4的倍数时，我们需要将其调整为大于size的最小的4的倍数。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> align4(x) (((((x)-1)&gt;&gt;2)&lt;&lt;2)+4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_SIZE 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    t_block b, last;</span><br><span class="line">    <span class="keyword">size_t</span> s;</span><br><span class="line"></span><br><span class="line">    s = align4(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">if</span>(base)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//first find a block</span></span><br><span class="line">        last = base;</span><br><span class="line">        b = find_block(&amp;last, s);</span><br><span class="line">        <span class="keyword">if</span>(b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//can we split</span></span><br><span class="line">            <span class="keyword">if</span>((b-&gt;<span class="built_in">size</span> - s) &gt;= (BLOCK_SIZE + <span class="number">8</span>))</span><br><span class="line">                split_block(b, s);</span><br><span class="line">            b-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//no fitting block, extend the heap</span></span><br><span class="line">            b = extend_heap(last, s);</span><br><span class="line">            <span class="keyword">if</span>(!b)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//first time</span></span><br><span class="line">        b = extend_heap(<span class="literal">NULL</span>, s);</span><br><span class="line">        <span class="keyword">if</span>(!b)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        base = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b-&gt;data;</span><br><span class="line">&#125;<span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041</span></span><br></pre></td></tr></table></figure>

<p>实现思路很简单：首先往链表中查找合适的block，如果找到了，看是否可以分裂，如果可以就分裂；如果没有找到合适的，就开辟一个新的block；如果是第一次分配，即整个内存链表不存在，则一开始就得新开辟一个block。</p>
<p><strong>六、calloc 的实现</strong></p>
<p>先看calloc的标准库语义：函数 calloc() 用于给一组相同对象分配内存。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> numitems, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span>1</span></span><br></pre></td></tr></table></figure>

<p>参数numitems指定分配对象的数量，size指定每个对象的大小。</p>
<p>calloc 与之malloc 不同之处在于，calloc 会将分配后的内存空间初始化，而malloc 申请的是一块未初始化的内存。<br>所以，实现calloc，只需两步：</p>
<ol>
<li>malloc 一块内存</li>
<li>将数据区内容初始化为0</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> numitems, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> *<span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">size_t</span> s, i;</span><br><span class="line">    <span class="keyword">new</span> = <span class="built_in">malloc</span>(numitems * <span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//因为申请的内存总是4的倍数，所以这里我们以4字节为单位初始化</span></span><br><span class="line">        s = align4(numitems * <span class="built_in">size</span>) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; s; ++i)</span><br><span class="line">            <span class="keyword">new</span>[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line">&#125;<span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>

<p><strong>七、free 的实现</strong></p>
<p>free 的实现并不像看上去那么简单，需要解决两个关键问题：</p>
<ol>
<li>如何验证所传入的地址是有效地址（malloc方式分配的）</li>
<li>如何解决碎片问题</li>
</ol>
<p><strong>7.1、先看如何解决碎片问题</strong>，就是把相邻的空闲内存合并为大的（伙伴算法类似）：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并相邻空闲的内存块，参数决定合并的是上一个还是下一个</span></span><br><span class="line">t_block fusion(t_block b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(b-&gt;</span><span class="function"><span class="title">next</span> &amp;&amp; b-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>free)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">b</span>-&gt;</span><span class="function"><span class="title">size</span> += BLOCK_SIZE + b-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>size;</span><br><span class="line">        <span class="function"><span class="title">b</span>-&gt;</span><span class="function"><span class="title">next</span> = b-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>next;</span><br><span class="line">        <span class="function"><span class="title">if</span>(b-&gt;</span>next)</span><br><span class="line">            <span class="function"><span class="title">b</span>-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>prev = b;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;<span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<p>再看如何验证所传入的地址是有效的，位于heap内。<br>一个解决方法是，在block结构体中添加一个 ptr 指针，用于指向数据块区域，如果 b-&gt;ptr == b-&gt;data，则表示 b 极有可能是一个有效block。<br>所以我们对block数据结构进行了扩展：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_block</span>&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span>   <span class="built_in">size</span>;<span class="comment">//数据区大小</span></span><br><span class="line">    t_block  next;<span class="comment">//指向下个块的指针</span></span><br><span class="line">    <span class="keyword">int</span>      <span class="built_in">free</span>;<span class="comment">//是否是空闲块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="keyword">void</span>     *ptr;</span><br><span class="line">    <span class="keyword">char</span>     data[<span class="number">1</span>];</span><br><span class="line">&#125;;<span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p><strong>7.2、根据给定地址得到对应的block</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意，这个函数最后通过偏移量得到的block可能是有效的，可能不是有效的</span></span><br><span class="line"><span class="function">t_block <span class="title">get_block</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *tmp;</span><br><span class="line">    tmp = p;</span><br><span class="line">    <span class="keyword">return</span> (p = tmp -= BLOCK_SIZE);</span><br><span class="line">&#125;<span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p><strong>7.3、下面则验证是不是有效的block：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> valid_addr(<span class="built_in">void</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(base)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p &gt; base &amp;&amp; p &lt; sbrk(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> (p == (get_block(p))-&gt;ptr);</span><br><span class="line">        <span class="comment">//如果两个字段地址一样，表示是一个有效block</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p><strong>7.4、下面就实现free</strong></p>
<p>这里我们采用的合并策略是这样的：先合并相邻的空闲内存块，合并之后，再检查是否还有空闲的相邻内存块，如果有则继续合并，直到最后，该内存块是最大的连续内存块。<br>另外，对于break指针的调整（降低），必须保证在该释放的block与 Unmapped Region之间是空闲的，没有被占。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void free(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    t_block b;</span><br><span class="line">    <span class="keyword">if</span>(valid_addr(p))<span class="comment">//地址的有效性验证</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = get_block(p);<span class="comment">//得到对应的block</span></span><br><span class="line">        <span class="function"><span class="title">b</span>-&gt;</span>free = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果相邻的上一块内存是空闲的就合并,</span></span><br><span class="line"><span class="comment">//合并之后的上一块还是空闲的就继续合并，直到不能合并为止</span></span><br><span class="line">        <span class="function"><span class="title">while</span>(b-&gt;</span><span class="function"><span class="title">prev</span> &amp;&amp; b-&gt;</span><span class="function"><span class="title">prev</span>-&gt;</span>free)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">b</span> = fusion(b-&gt;</span>prev);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同理去合并后面的空闲block</span></span><br><span class="line">        <span class="function"><span class="title">while</span>(b-&gt;</span>next)</span><br><span class="line">            fusion(b);<span class="comment">//内部会判断是否空闲</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果当前block是最后面的那个block，此时可以调整break指针了</span></span><br><span class="line">        <span class="function"><span class="title">if</span>(NULL == b-&gt;</span>next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span>(b-&gt;</span>prev)<span class="comment">//当前block前面还有占用的block</span></span><br><span class="line">                <span class="function"><span class="title">b</span>-&gt;</span><span class="function"><span class="title">prev</span>-&gt;</span>next = NULL;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//当前block就是整个heap仅存的</span></span><br><span class="line">                base = NULL;<span class="comment">//则重置base</span></span><br><span class="line">            brk(b);<span class="comment">//调整break指针到b地址位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则不能调整break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="number">12345678910111213141516171819202122232425262728293031</span></span><br></pre></td></tr></table></figure>

<p><strong>八、realloc的实现</strong></p>
<p>同样先看标准库中realloc的语义：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span>1</span></span><br></pre></td></tr></table></figure>

<p>ptr 是指向需要调整大小的内存块的指针，参数 size 指定所需调整大小的期望值。</p>
<p>realloc() 用来调整（通常是增加）一块内存的大小，而此块内存应是之前由malloc函数分配的。若 realloc 增加了已分配内存块的大小，则不会对额外分配的内存进行初始化。</p>
<p><strong>8.1、内存块复制</strong><br>看了realloc的语义，我们首先得实现一个内存复制方法。如同calloc一样，我们以4字节为单位进行复制：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void copy_block(t_block src, t_block dst)</span><br><span class="line">&#123;</span><br><span class="line">    int *sdata, *dtata;</span><br><span class="line">    size_t <span class="built_in">i</span>;</span><br><span class="line">    sdata = src-&gt;ptr;</span><br><span class="line">    ddata = dst-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span>*<span class="number">4</span> &lt; src-&gt;<span class="built_in">size</span> &amp;&amp; <span class="built_in">i</span>*<span class="number">4</span> &lt; dst-&gt;<span class="built_in">size</span>; ++<span class="built_in">i</span>)</span><br><span class="line">        ddata[<span class="built_in">i</span>] = sdata[<span class="built_in">i</span>];</span><br><span class="line">&#125;<span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p><strong>8.2、实现realloc</strong><br>为了更高效，我们考虑以下几个方面：</p>
<ol>
<li>如果当前block的数据区大于等于realloc要求的size，则考虑能不能split，然后直接返回</li>
<li>如果新的size变小了，考虑split</li>
<li>如果当前block的数据区不能满足size，但是其后继block是free，并且合并后可以满足size，则考虑合并，然后再考虑能不能split</li>
<li>如果以上都不行，则调用malloc重新分配size大小内存，然后内存复制</li>
</ol>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void *realloc(<span class="name">void</span> *p, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    size_t s;</span><br><span class="line">    t_block b, new;</span><br><span class="line">    void *newp<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    if(!p)</span><br><span class="line">        return malloc(<span class="name">size</span>)<span class="comment">;</span></span><br><span class="line">    if(<span class="name">valid_addr</span>(<span class="name">p</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        s = align4(<span class="name">size</span>)<span class="comment">;</span></span><br><span class="line">        b = get_block(<span class="name">p</span>)<span class="comment">;//得到对应的block</span></span><br><span class="line">        if(<span class="name">b-&gt;size</span> &gt;= s)//如果size变小了，考虑split</span><br><span class="line">        &#123;</span><br><span class="line">            if(<span class="name">b-&gt;size</span> - s &gt;= (<span class="name">BLOCK_SIZE</span> + <span class="number">4</span>))</span><br><span class="line">                split_block(<span class="name">b</span>, s)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        else//如果当前block的数据区不能满足size</span><br><span class="line">        &#123;</span><br><span class="line">//如果后继block是free的，并且合并后大小满足size，考虑合并</span><br><span class="line">            if(<span class="name">b-&gt;next</span> <span class="symbol">&amp;&amp;</span> b-&gt;next-&gt;free</span><br><span class="line">                <span class="symbol">&amp;&amp;</span> (<span class="name">b-&gt;size</span> + BLOCK_SIZE + b-&gt;next-&gt;size) &gt;= s)</span><br><span class="line">            &#123;</span><br><span class="line">                fusion(<span class="name">b</span>)<span class="comment">;</span></span><br><span class="line">            //合并后满足size，再看能不能split</span><br><span class="line">                if(<span class="name">b-&gt;size</span> - s &gt;= (<span class="name">BLOCK_SIZE</span> + <span class="number">4</span>))</span><br><span class="line">                    split_block(<span class="name">b</span>, s)<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">            else//以上都不满足，则malloc新区域</span><br><span class="line">            &#123;</span><br><span class="line">                newp = malloc(<span class="name">s</span>)<span class="comment">;</span></span><br><span class="line">                if(!newp)</span><br><span class="line">                    return NULL<span class="comment">;</span></span><br><span class="line">            //内存复制</span><br><span class="line">                new = get_block(<span class="name">newp</span>)<span class="comment">;</span></span><br><span class="line">                copy_block(<span class="name">b</span>, new)<span class="comment">;</span></span><br><span class="line">                free(<span class="name">p</span>)<span class="comment">;//释放old </span></span><br><span class="line">                return newp<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return p<span class="comment">;//当前block数据区大于size时</span></span><br><span class="line">    &#125;</span><br><span class="line">    return NULL<span class="comment">;</span></span><br><span class="line">&#125;<span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041424344</span></span><br></pre></td></tr></table></figure>

<p><strong>九、总结</strong></p>
<p>以上是一个比较简陋，存在很大的优化空间，但大致阐述了malloc的机制，这也是本篇博文的目的。<br>对于更好的优化读者可以参考<a href="http://blog.csdn.net/wenqian1991/article/details/27968779" target="_blank" rel="noopener">linux内核伙伴算法</a>、以及<a href="http://blog.csdn.net/wenqian1991/article/details/19605727" target="_blank" rel="noopener">STL空间配置器</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E8%B5%8B%E5%80%BC%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E8%B5%8B%E5%80%BC%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">C++拷贝构造函数与赋值函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-27 15:18:11" itemprop="dateCreated datePublished" datetime="2020-12-27T15:18:11+08:00">2020-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-02 20:31:26" itemprop="dateModified" datetime="2021-03-02T20:31:26+08:00">2021-03-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这里我们用类String 来介绍这两个函数：</p>
<p>拷贝构造函数是一种特殊构造函数，具有单个形参，该形参（常用const修饰）是对该类类型的引用。当定义一个新对象并用一个同类型的对象对它进行初始化时，将显式使用拷贝构造函数。为啥形参必须是对该类型的引用呢？试想一下，假如形参是该类的一个实例，由于是传值参数，我们把形参复制到实参会调用拷贝构造函数，如果允许拷贝构造函数传值，就会在拷贝构造函数内调用拷贝构造函数，从而形成无休止的递归调用导致栈溢出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s);</span><br><span class="line"><span class="comment">//类成员，无返回值</span></span><br></pre></td></tr></table></figure>

<p>赋值函数，也是赋值操作符重载，因为赋值必须作为类成员，那么它的第一个操作数隐式绑定到 this 指针，也就是 this 绑定到指向左操作数的指针。因此，赋值操作符接受单个形参，且该形参是同一类类型的对象。右操作数一般作为const 引用传递。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>&amp;	<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s);</span><br><span class="line"><span class="comment">//类成员，返回对同一类类型(左操作数)的引用</span></span><br></pre></td></tr></table></figure>


<p>拷贝构造函数和赋值函数并非每个对象都会使用，另外如果不主动编写的话，编译器将以“位拷贝”的方式自动生成缺省的函数。在类的设计当中，“位拷贝”是应当防止的。倘若类中含有指针变量，那么这两个缺省的函数就会发生错误。这就涉及到深复制和浅复制的问题了。</p>
<p>拷贝有两种：深拷贝，浅拷贝<br>当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。<br>但当数据成员中有指针时，如果采用简单的浅拷贝，则<strong>两类中的两个指针将指向同一个地址</strong>，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。所以，这时，必须采用深拷贝。<br>深拷贝与浅拷贝的区别就在于<strong><em>\</em>深拷贝会在堆内存中另外申请空间来储存数据**</strong>，从而也就解决了指针悬挂的问题。指向不同的内存空间，但内容是一样的<br>简而言之，<strong><em>\</em>当数据成员中有指针时，必须要用深拷贝**</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> * c;</span><br><span class="line">&#125;a, b;</span><br><span class="line"><span class="comment">//浅复制不会重新分配内存</span></span><br><span class="line"><span class="comment">//将a 赋给 b，缺省赋值函数的“位拷贝”意味着执行</span></span><br><span class="line">a.c = b.c;</span><br><span class="line"><span class="comment">//从这行代码可以看出</span></span><br><span class="line"><span class="comment">//b.c 原有的内存没有释放</span></span><br><span class="line"><span class="comment">//a.c 和 b.c 指向同一块内存，任何一方的变动都会影响到另一方</span></span><br><span class="line"><span class="comment">//对象析构的时候，c 被释放了两次（a.c == b.c 指针一样）</span></span><br><span class="line"><span class="comment">//深复制需要自己处理里面的指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> *c;</span><br><span class="line">	A&amp; <span class="keyword">operator</span> =(<span class="keyword">const</span> A &amp;b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//隐含 this 指针</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;b)</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">delete</span> c;<span class="comment">//释放原有内存资源</span></span><br><span class="line">		<span class="comment">//分配新的内存资源</span></span><br><span class="line">		<span class="keyword">int</span> length = <span class="built_in">strlen</span>(b.c);</span><br><span class="line">		c = <span class="keyword">new</span> <span class="keyword">char</span>[length + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(c, b.c);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;a, b;</span><br><span class="line"><span class="comment">//这个是深复制，它有自定义的复制函数，赋值时，对指针动态分配了内存</span></span><br></pre></td></tr></table></figure>

<p>这里再总结一下深复制和浅复制的具体区别：</p>
<ol>
<li>当拷贝对象状态中包含其他对象的引用时，如果需要复制的是引用对象指向的内容，而不是引用内存地址，则是深复制，否则是浅复制。</li>
<li>浅复制就是成员数据之间的赋值，当值拷贝时，两个对象就有共同的资源。而深拷贝是先将资源复制一份，是对象拥有不同的资源（内存区域），但资源内容（内存里面的数据）是相同的。</li>
<li>与浅复制不同，深复制在处理引用时，如果改变新对象内容将不会影响到原对象内容</li>
<li>与深复制不同，浅复制资源后释放资源时可能会产生资源归属不清楚的情况（含指针时，释放一方的资源，其实另一方的资源也随之释放了），从而导致程序运行出错</li>
</ol>
<p>深复制和浅复制还有个区别就是执行的时候，浅复制是直接复制内存地址的，而深复制需要重新开辟同样大小的内存区域，然后复制整个资源。</p>
<p>好，有了前面的铺垫，下面开始讲讲拷贝构造函数和赋值函数，其实前面第一部分也已经介绍了许多</p>
<p>这里以string 类为例来进行说明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	String(<span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="literal">NULL</span>);</span><br><span class="line">	String(<span class="keyword">const</span> String &amp;rhs);</span><br><span class="line">	String&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String &amp;rhs);</span><br><span class="line">	~String(<span class="keyword">void</span>)&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] m_data;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> *m_data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">String::String(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == str)</span><br><span class="line">	&#123;</span><br><span class="line">		m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">		*m_data = <span class="string">'\0'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(m_data, str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数，无需检验参数的有效性</span></span><br><span class="line">String::String(<span class="keyword">const</span> String &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.m_data) + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(m_data, rhs.m_data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值函数</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">delete</span>[] m_data; m_data = <span class="literal">NULL</span>;</span><br><span class="line">	m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.m_data) + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(m_data, rhs.m_data);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类String 拷贝构造函数与普通构造函数的区别是：在函数入口处无需与 NULL 进行比较，这是因为“引用”不可能是NULL，而“指针”可以为NULL。（这是引用与指针的一个重要区别）。然后需要注意的就是深复制了。</p>
<p>相比而言，对于类String 的赋值函数则要复杂的多：</p>
<p>1、首先需要执行检查自赋值</p>
<p>这是防止自复制以及间接复制，如 b = a; c = b; a = c;之类，如果不进行自检的话，那么后面的 delete 将会进行自杀操作，后面随之的拷贝操作也会出错，所以这是关键的一步。还需要注意的是，自检是检查地址，而不是内容，内存地址是唯一的。必须是 if(this == &amp;rhs)</p>
<p>2、释放原有的内存资源</p>
<p>必须要用 delete 释放掉原有的内存资源，如果此时不释放，该变量指向的内存地址将不再是原有内存地址，也就无法进行内存释放，造成内存泄露。</p>
<p>3、分配新的内存资源，并复制资源</p>
<p>这样变量指向的内存地址变了，但是里面的资源是一样的</p>
<p>4、返回本对象的引用</p>
<p>这样的目的是为了实现像 a = b = c; 这样的链式表达，注意返回的是 *this 。</p>
<p>但仔细一想，上面的程序没有考虑到异常安全性，我们在分配内存之前用delete 释放了原有实例的内存，如果后面new 出现内存不足抛出异常，那么之前delete 的 m_data 将是一个空指针，这样很容易引起程序崩溃，所以我们可以调换下顺序，即先 new 一个实例内存，成功后再用 delete 释放原有内存空间，最后用 m_data 赋值为new后的指针。</p>
<p>接下来说说拷贝构造函数和赋值函数之间的区别。</p>
<p>拷贝构造函数和赋值函数非常容易混淆，常导致错写、错用。拷贝构造函数是在对象被创建是调用的，而赋值函数只能在已经存在了的对象调用。看下面代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">a</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">b</span><span class="params">(<span class="string">"world"</span>)</span></span>;</span><br><span class="line">	String c = a;<span class="comment">//这里c对象被创建调用的是拷贝构造函数</span></span><br><span class="line">             <span class="comment">//一般是写成 c(a);这里是与后面比较</span></span><br><span class="line">	c = b;<span class="comment">//前面c对象已经创建，所以这里是赋值函数</span></span><br></pre></td></tr></table></figure>

<p>上面说明出现“=”的地方未必调用的都是赋值函数（算术符重载函数），也有可能拷贝构造函数，那么什么时候是调用拷贝构造函数，什么时候是调用赋值函数你？ 判断的标准其实很简单：如果临时变量是第一次出现，那么调用的只能是拷贝构造函数，反之如果变量已经存在，那么调用的就是赋值函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C++%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%92%8CC%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84static/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C++%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%92%8CC%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84static/" class="post-title-link" itemprop="url">C++类的静态成员和C语言中的static</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-27 15:16:30" itemprop="dateCreated datePublished" datetime="2020-12-27T15:16:30+08:00">2020-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-02 21:46:25" itemprop="dateModified" datetime="2021-03-02T21:46:25+08:00">2021-03-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一、C++类的静态成员</p>
<p>学过C++的都知道，静态成员是属于整个类而不是某个对象的，静态成员变量在内存中只存储一份共所有对象共用，在所有对象中都可以共享它。</p>
<p>静态成员的定义或声明需要加个关键字 static。因为属于整个类，所以可以通过 &lt;类名&gt;::&lt;静态成员名&gt;来使用。</p>
<p>比较容易混淆和出错的地方在于类的静态成员变量和静态成员函数的使用，这两者都属于静态成员。</p>
<p>需要注意的是：静态成员属于整个类，在类对象实例化前，静态成员就已经分配空间了，而非静态成员无需初始化，必须在类实例化对象后才有内存空间，所以就有了个先后顺序：静态成员先于非静态成员存在。</p>
<p>下面我们来看看如下几个情况： </p>
<p>1、通过类名调用静态成员函数和非静态成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base::fun1();</span><br><span class="line">	Base::fun2();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>编译错误：“Base::fun1”: 非静态成员函数的非法调用<br>结论1：不能通过类名来调用类的非静态成员函数。<br>原因：类没有实例化对象，非静态成员函数不存在</p>
<p>2、通过类的对象静态成员函数和非静态成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base obj;</span><br><span class="line">	obj.fun1();</span><br><span class="line">	obj.fun2();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译通过<br>结论2：可以通过类的对象调用静态成员函数和非静态成员函数<br>原因：类实例化对象，非静态成员函数已分配内存，静态成员函数为类各对象共享</p>
<p>3、在类的静态成员函数中使用类的非静态成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base obj;</span><br><span class="line">	obj.fun2();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译出错：对非静态成员“Base::x”的非法引用<br>结论3：类的静态成员函数不能使用类的非静态成员<br>原因：在编译阶段，静态成员函数已分配内存，但非静态成员并没有分配内存，就好比提前使用一个不存在的东西</p>
<p>4、在类的非静态成员函数中使用类的静态成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		fun2();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base obj;</span><br><span class="line">	obj.fun1();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译通过<br>结论4：类的非静态成员函数可以调用静态成员，反之则不能<br>理由同前</p>
<p>5、使用类的静态成员变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//int Base::x = 0;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Base::x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链接出错：无法解析的外部符号 “private: static int Base::x” (?x@Base@@0HA)<br>结论5：类的静态成员变量必须初始化，并且静态成员变量的初始化必须在类外初始化，且不能带static关键字<br>原因：静态成员变量属于类作用域，不属于类对象，程序一运行就分配内存并初始化，生命周期和程序一致，在类的构造函数内初始化显然是不合理的。另外在类外初始化时，还必须指定类型，否则编译器不知道该为变量分配多大内存。</p>
<p><strong>但是，静态成员也并非不能再类中初始化。对于静态常量成员是可以在类中初始化的。</strong></p>
<p>总结：<br>1.静态成员存在于内存，非静态成员需要实例化才会分配内存<br>2.非静态成员的生存期取决于该类的生存期，而静态成员则不存在生存期的概念<br>3.类的静态成员函数不能调用非静态成员，存在的先后顺序，反之可以<br>4.类的静态成员变量必须初始化，且必须在类外初始化（静态常量成员除外），不能带static关键字，必须带类型。</p>
<p>二、C语言中的static</p>
<p>下面介绍在C语言中，static的作用：</p>
<p>1、隐藏</p>
<p>当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。比如，同时编译两个源文件，一个是a.c，另一个是main.c</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.c</span></span><br><span class="line"><span class="keyword">char</span> a = <span class="string">'A'</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">char</span> a;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%c"</span>, a);</span><br><span class="line">	(<span class="keyword">void</span>)msg();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output:A Hello</span></span><br></pre></td></tr></table></figure>

<p>由于a.c 中的所有成员（变量和函数）都未加static，所有都具有全局可见性，其他的源文件也能访问。如果加了static，那么其余源文件就不能访问了，利用这一特性，可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。</p>
<p>2、static还能保持变量内容的持久</p>
<p>对于函数而言，static的作用仅限于隐藏，对于变量，static还有两个作用，其一就是保持变量内容的持久。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化，事实上，全局变量和静态变量都存储在静态存储区。与全局变量不同的是，static可以控制变量的可见范围。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>;<span class="comment">//事实上此赋值语句从来没执行过,调试一进入函数，count=10</span></span><br><span class="line">	<span class="keyword">return</span> count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>3、static第三个作用则是默认初始化为0，事实上存储在静态存储区的变量都具有这样的特性，所有全局变量也能初始化为0. </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C++%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E8%99%9A%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C++%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E8%99%9A%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">C++深入分析虚函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-27 15:14:15" itemprop="dateCreated datePublished" datetime="2020-12-27T15:14:15+08:00">2020-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-22 22:19:10" itemprop="dateModified" datetime="2021-01-22T22:19:10+08:00">2021-01-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面探索了<a href="http://blog.csdn.net/wenqian1991/article/details/41047957" target="_blank" rel="noopener">C++对象的内存模型</a>，其中简单的涉及到了虚函数，作为C++实现其多态的一个重要机制，这里进一步探索下虚函数机制，以前也看过网络上关于虚函数机制的一些精彩的文章，但现在决定自己再分析这个虚函数机制以加深理解，看与自己动手探索还是有区别的。</p>
<p><strong><em>\</em>一、异质链表**</strong></p>
<p>1、“is-a” 原理</p>
<p>在公有派生方式下，对派生类的对象里的基类子对象的水平访问与基类单独生成的对象的访问是一样的。也就是说，我们完全可以把public 继承方式的派生类的对象当做基类的一个对象来使用。反过来则不行。这就是“is-a”原理</p>
<p>在公有派生方式下，基于“is-a”原理，我们可以得出以下几点：</p>
<ol>
<li>一个派生类的对象可以赋给基类对象；</li>
<li>派生类对象可以初始化基类对象；</li>
<li>派生类的对象可以初始化基类的引用；</li>
<li>派生类的对象的地址可以赋给指向基类对象的指针。</li>
</ol>
<p>前面三条都是一个性质，派生类对象赋给基类对象的时候，都是调用基类的赋值构造函数，这样赋值的时候，只会将派生类对象中继承的基类成员赋值给基类对象成员，不会发生内存越界的情况。下面是一段截取的反汇编代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">60</span>: 	base_obj = derived_obj;</span><br><span class="line"><span class="number">00</span>DD442C  lea         eax,[derived_obj]  </span><br><span class="line"><span class="number">00</span>DD442F  push        eax  </span><br><span class="line"><span class="number">00</span>DD4430  lea         ecx,[base_obj]  </span><br><span class="line"><span class="number">00</span>DD4433  call        Base::<span class="keyword">operator</span>= (<span class="number">0</span>DD16AEh)</span><br></pre></td></tr></table></figure>

<p>最重要的是第四条，对于这个基类的不同派生类的对象，我们可以使用指向基类的指针把它们（派生类对象）穿成一个链表，这个链表对于我们实现C++的多态性有很大的价值，被称之为异质链表。</p>
<p>   <img src="/2020/12/27/C++%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E8%99%9A%E5%87%BD%E6%95%B0/20141122122521379" alt="img"></p>
<p>通过基类指针将这个基类的不同子对象串联起来。一个充分必要条件就是，这几个子类都有一个公共的基类，且都与这个基类有“is-a”关系。</p>
<p>对于这我们可以这么理解：派生类的对象所占的存储空间要比基类的对象大，因为派生类继承了基类非私有成员函数和数据，再加上本身的成员数据，实例化的对象自然会比基类对象大，自然，派生类指针的寻址空间要比基类指针的寻址空间大。但由于对象的头部分是一样的，所以即使有超出基类指针所寻址的部分也能根据偏移量正确寻址，相反，如果派生类指针指向基类对象，则会把一部分不属于该基类对象的内存也包括进来，那么当派生类指针指向基类对象来使用派生类的函数的时候可能会发生严重的错误。</p>
<p><strong><em>\</em>二、虚函数机制前奏**</strong></p>
<p>1、静态联编</p>
<p>计算机应用程序对它的变量、对象的访问，以及对函数的调用实际上都是通过地址，而不是像源程序那样通过名字。程序中的变量名、对象名和函数名都是在编译的时候被编译器变换成了地址，这个地址是逻辑地址，在程序运行的时候再转换为物理地址。总之，程序最终运行的时候对各类变量的访问都是通过地址。</p>
<p>函数名字也会被编译器转换为地址，这样对这个函数的调用，就编译成了去执行这个地址里的指令（汇编语言更清晰的表达出这点），函数的调用关系就变成了对某个地址的连接。而这是编译器在编译时做成的连接，在运行的时候是不可能改变的，这种连接我们称之为静态联编。</p>
<p>2、动态联编</p>
<p>先说下多态。多态性实质就是“一个接口，多种方法”。就是基于“is-a”原理，把不同子类的对象都当做父类来看待，可以屏蔽不同子类对象之间的差异，写出通用的代码，增加代码的适用性。赋值之后，父对象就可以根据赋值给它的子对象的特性以不同的方式运作。多态最常用的就是上面“is-a”原理引申出来的第四点。通过基类对象指针去操作子类对象的函数，来实现多态性。当然基类中也要定义这个函数接口。这样的话问题就来了，像第一点所说的，函数名在编译的时候就被换算成了一个固定地址，那么当基类指针去操作同一个函数接口时，最终都会跳转到同一个地址，那就无法实现多态了。针对这个问题就引入了虚函数机制，虚函数机制是基于动态联编的，动态联编是相对静态联编来的，它的函数名对应的地址是在运行的时候才决定的，在编译时并不能确定各个函数的对应地址（这里是说编译器不确定，函数本身地址肯定是定了的），只有在运行的时候根据是隶属于哪个对象才去调用这个对象的同名函数。</p>
<p>默认状态下都是静态联编，为了引入动态联编，我们引入了虚函数机制，在对应的函数名前加上 virtual 关键字即可。然后剩下的工作就交给编译器去完成了，编译器才是实现多态性的真正幕后英雄。</p>
<p><strong>三、虚函数机制</strong></p>
<p>有了前面的异质链表和动态联编，我们开始解开虚函数的神秘面纱。</p>
<p>1、单一继承</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	Base(<span class="keyword">int</span> i = <span class="number">1</span>) :a(i)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	Derived(<span class="keyword">int</span> j = <span class="number">2</span>) :Base(j), b(j)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span><span class="comment">//覆盖的情况</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base* ptr = <span class="keyword">new</span> Derived(<span class="number">10</span>);</span><br><span class="line">	ptr-&gt;fun_a();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出就不用多说了。 </p>
<p>我们看看 ptr 指向的对象的布局：</p>
<p><img src="/2020/12/27/C++%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E8%99%9A%E5%87%BD%E6%95%B0/20141122215133793" alt="img"></p>
<p>看到虚表指针指向的虚函数表中第一个位置存放的是子类对象的函数，显然子类的虚函数已经覆盖了父类的同名同类型虚函数。</p>
<p>父类和子类都定义有虚函数，且存在不同类型的，情况就会如下所示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	Base(<span class="keyword">int</span> i = <span class="number">1</span>) :a(i)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_b</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::b"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	Derived(<span class="keyword">int</span> j = <span class="number">2</span>) :Base(j), b(j)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_c</span><span class="params">()</span><span class="comment">//无覆盖</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::c"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun_b</span><span class="params">()</span><span class="comment">//覆盖</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::b"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base* ptr = <span class="keyword">new</span> Derived(<span class="number">10</span>);</span><br><span class="line">	fun pFun = <span class="literal">NULL</span>;</span><br><span class="line">	pFun = (fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(ptr)+<span class="number">2</span>);</span><br><span class="line">	pFun();</span><br><span class="line">	<span class="comment">//ptr-&gt;fun_a();</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有意思的是调试的时候，Visual Studio 窗口中居然没有显示虚函数表的第三个函数指针，所以上面额外测试了一下。子类实际的虚表如下：</p>
<p>虚函数表：虚函数指针都在位于同一个函数指针数组中，很容易寻址到。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  Derived::$vftable@:</span><br><span class="line">1&gt;  	| &amp;Derived_meta</span><br><span class="line">1&gt;  	|  0</span><br><span class="line">1&gt;   0	| &amp;Base::fun_a </span><br><span class="line">1&gt;   1	| &amp;Derived::fun_b </span><br><span class="line">1&gt;   2	| &amp;Derived::fun_c</span><br></pre></td></tr></table></figure>

<p>可以得出的是， 没有覆盖的情况下，基类的虚函数指针放在虚表的前面，然后再是派生类的虚函数指针，其中覆盖的放在自身的没有不覆盖基类的前面。多个覆盖自然就是按顺序来。<br>上面派生类只会有一张虚函数表，基类和派生类的虚函数指针都放置在其中。<br>那么虚函数的调用过程是怎么样的呢？这里修改了上面的程序，把基类的 fun_b() 函数退化为一般函数，然后分别调用一个虚函数和这个一般函数，看看它们的反汇编代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">66</span>: 	ptr-&gt;fun_a();</span><br><span class="line"><span class="number">00405998</span>  mov         eax,dword ptr [ptr]  </span><br><span class="line"><span class="number">0040599B</span>  mov         edx,dword ptr [eax]  </span><br><span class="line"><span class="number">0040599</span>D  mov         esi,esp  </span><br><span class="line"><span class="number">0040599F</span>  mov         ecx,dword ptr [ptr]  </span><br><span class="line"><span class="number">004059</span>A2  mov         eax,dword ptr [edx]  </span><br><span class="line"><span class="number">004059</span>A4  call        eax  </span><br><span class="line"><span class="number">004059</span>A6  cmp         esi,esp  </span><br><span class="line"><span class="number">004059</span>A8  call        __RTC_CheckEsp (<span class="number">0401343</span>h)  </span><br><span class="line">    <span class="number">67</span>: 	ptr-&gt;fun_b();</span><br><span class="line"><span class="number">004059</span>AD  mov         ecx,dword ptr [ptr]  </span><br><span class="line"><span class="number">004059B</span>0  <span class="function">call        <span class="title">Base::fun_b</span> <span class="params">(<span class="number">04016F</span>Eh)</span></span></span><br></pre></td></tr></table></figure>

<p>上面fun_a() 是虚函数，fun_b() 是一般函数，通过汇编代码看看这两个函数的调用过程，可以看出一般函数是通过类直接调用，没什么特殊之处。重点看看虚函数的调用：</p>
<p>第二行代码（第一行汇编 mov  eax,dword ptr [ptr] ），取基类指针指向的数据（虚表指针）；后面的 mov  edx,dword ptr [eax]，定位到了虚函数表首位置；第六行 mov  eax,dword ptr [edx]，即得到对应位置（首位置）的虚函数指针（如果调用的虚函数指针不是首位置，那么这里会是edx+x），后面 call  eax 则是通过虚函数指针调用该虚函数。</p>
<p>总的说来，虚函数的调用是先定位到对应类的虚函数表，然后再去找对应位置的虚函数指针，继而调用该虚函数。</p>
<p>单一继承下，即只继承一个基类，那么派生类都只会产生一个虚函数表，<a href="http://blog.csdn.net/wenqian1991/article/details/41047957" target="_blank" rel="noopener">前面</a>已经说过了。然后所有的虚函数指针都放在这一张虚表中，派生类同类型虚函数会覆盖基类虚函数。虚函数机制下，编译器并不是简单的把基类指针类型编译成对应基类，而是按照这个基类指针去找到它指向的对象，换句话说不是看它的指针类型而是看它指向什么对象，对象下面有虚表指针，然后就是按照上面说的层层解引用调用对应的函数。</p>
<p>上面就是动态联编的过程，很显然效率要比静态联编低。</p>
<p>这虚函数指针的放置简单的说就是：先基类，然后派生类，派生类有覆盖的则直接对应覆盖。</p>
<p>2、多重继承</p>
<p>前面博文说到，多重继承（非虚拟继承）的情况下，继承多少个含虚函数基类（自身带虚函数表），派生类中就会生成多少个虚函数表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	Base1(<span class="keyword">int</span> i = <span class="number">1</span>) :a(i)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::a"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	Base2(<span class="keyword">int</span> i = <span class="number">2</span>) :b(i)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_b</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::b"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	Child(<span class="keyword">int</span> i = <span class="number">3</span>) :Base1(i), Base2(i), c(i)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span><span class="comment">//覆盖基类Base1</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Child::a"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun_b</span><span class="params">()</span><span class="comment">//覆盖基类Base2</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Child::b"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_c</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"child"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Child <span class="title">c</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">	c.fun_a();<span class="comment">//静态联编</span></span><br><span class="line">	Base1 &amp;ptr = c;</span><br><span class="line">	ptr.fun_a();<span class="comment">//动态联编</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的派生类公共继承了两个含有虚表的基类，自然地派生类中会产生两张虚表。</p>
<p>在讨论虚函数表前，先看看main函数，这里分别用了两个不同的手法调用函数 fun_a，第一个是静态联编，直接通过对象的名字来调用该对象的虚函数，无需额外的去定位对象了，而后面的动态联编，则要通过引用或指针先找到对应的对象，再去调用该对象的虚函数。</p>
<p>派生类中的虚函数表：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  Child::$vftable@Base1@:</span><br><span class="line">1&gt; | &amp;Child_meta</span><br><span class="line">1&gt; | 0</span><br><span class="line">1&gt;   0 | &amp;Child::fun_a</span><br><span class="line">1&gt;   1 | &amp;Child::fun_c</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;  Child::$vftable@Base2@:</span><br><span class="line">1&gt; | -8</span><br><span class="line">1&gt;   0 | &amp;Child::fun_b</span><br></pre></td></tr></table></figure>

<p>这样 当不同基类类型的指针指向同一个派生类对象时，都能够调用到实际的函数。改一下main函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Child <span class="title">c</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">	Base1 &amp;ptr1 = c;</span><br><span class="line">	ptr1.fun_a();</span><br><span class="line">	Base2 &amp;ptr2 = c;</span><br><span class="line">	ptr2.fun_b();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面两次调用的局部汇编code：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">77</span>: 	Base1 &amp;ptr1 = c;</span><br><span class="line"><span class="number">00</span>AA5E02  lea         eax,[c]  </span><br><span class="line"><span class="number">00</span>AA5E05  mov         dword ptr [ptr1],eax  </span><br><span class="line">    <span class="number">78</span>: 	ptr1.fun_a();<span class="comment">//动态联编</span></span><br><span class="line"><span class="number">00</span>AA5E08  mov         eax,dword ptr [ptr1]  </span><br><span class="line"><span class="number">00</span>AA5E0B  mov         edx,dword ptr [eax]  </span><br><span class="line"><span class="number">00</span>AA5E0D  mov         esi,esp  </span><br><span class="line"><span class="number">00</span>AA5E0F  mov         ecx,dword ptr [ptr1]  </span><br><span class="line"><span class="number">00</span>AA5E12  mov         eax,dword ptr [edx]  </span><br><span class="line"><span class="number">00</span>AA5E14  call        eax  </span><br><span class="line">    <span class="number">80</span>: 	Base2 &amp;ptr2 = c;</span><br><span class="line"><span class="number">00</span>AA5E1D  lea         eax,[c]  </span><br><span class="line"><span class="number">00</span>AA5E20  test        eax,eax  </span><br><span class="line"><span class="number">00</span>AA5E22  je          main+<span class="number">62</span>h (<span class="number">0</span>AA5E32h)  </span><br><span class="line"><span class="number">00</span>AA5E24  lea         ecx,[c]  </span><br><span class="line"><span class="number">00</span>AA5E27  add         ecx,<span class="number">8</span>  <span class="comment">//指针位置调整</span></span><br><span class="line"><span class="number">00</span>AA5E2A  mov         dword ptr [ebp<span class="number">-0F</span>Ch],ecx  </span><br><span class="line"><span class="number">00</span>AA5E30  jmp         main+<span class="number">6</span>Ch (<span class="number">0</span>AA5E3Ch)  </span><br><span class="line"><span class="number">00</span>AA5E32  mov         dword ptr [ebp<span class="number">-0F</span>Ch],<span class="number">0</span>  </span><br><span class="line"><span class="number">00</span>AA5E3C  mov         edx,dword ptr [ebp<span class="number">-0F</span>Ch]  </span><br><span class="line"><span class="number">00</span>AA5E42  mov         dword ptr [ptr2],edx  </span><br><span class="line">    <span class="number">81</span>: 	ptr2.fun_b();</span><br><span class="line"><span class="number">00</span>AA5E45  mov         eax,dword ptr [ptr2]  </span><br><span class="line"><span class="number">00</span>AA5E48  mov         edx,dword ptr [eax]  </span><br><span class="line">    <span class="number">81</span>: 	ptr2.fun_b();</span><br><span class="line"><span class="number">00</span>AA5E4A  mov         esi,esp  </span><br><span class="line"><span class="number">00</span>AA5E4C  mov         ecx,dword ptr [ptr2]  </span><br><span class="line"><span class="number">00</span>AA5E4F  mov         eax,dword ptr [edx]  </span><br><span class="line"><span class="number">00</span>AA5E51  call        eax</span><br></pre></td></tr></table></figure>

<p>后面调用的指针位置调整，就是根据由哪个基类指针指向来调整的（继承的基类在派生类中的位置）。这样不管继承多少个带虚表的基类，最终都能准确的调用到对应的虚函数。</p>
<p>也可以看出派生类中的两张虚表指针并不是全部在内存的首位置，而是等继承的第一个基类“放置”后再处理第二个。。<br>上面这一切都是编译器的功劳，我们只是通过基类指针简单的调用虚函数，然后内部的各类转移都是编译器的功劳。</p>
<p><strong>号外：</strong>构造函数，静态函数，内联函数，普通函数(非成员函数)、友元函数不能作为虚函数，成员模板函数也不能：虚函数仅适用于有继承关系的类对象。</p>
<p>虚函数是基于虚函数表的（内存空间），构造函数如果是虚函数，调用时也需要根据虚表寻找，但是虚表的产生依赖于构造函数（看下面的虚表指针的初始化），不能本末倒置，另外构造函数不能被继承（重写），静态函数是属于 class 自己的，必须有实体，其也不能被继承，内联函数在编译时展开，跟虚函数完全不是一个调调，水火不容的关系，至于普通函数，友元函数等，这两者是类外函数，不能被继承。</p>
<p><strong><em>\</em>四、虚表指针的初始化**</strong></p>
<p>没有虚函数的类对象自然不会产生虚表指针，而有虚函数的类对象就会产生虚表指针，那么虚表指针是什么时候安插在对象中的呢？答案就是构造函数。</p>
<p>我们可以在构造child实例处设置断点，然后反汇编跟踪编译，进入child的构造函数下的Base1构造函数，我们会发现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">35</span>: 	Base1(<span class="keyword">int</span> i = <span class="number">1</span>) :a(i)&#123;&#125;</span><br><span class="line">…… <span class="comment">//debug初始化环境略</span></span><br><span class="line"><span class="number">0008383F</span>  pop         ecx  <span class="comment">//还原this指针</span></span><br><span class="line"><span class="number">00083840</span>  mov         dword ptr [<span class="keyword">this</span>],ecx  <span class="comment">//存储this指针  </span></span><br><span class="line"><span class="number">00083843</span>  mov         eax,dword ptr [<span class="keyword">this</span>]  <span class="comment">//取出this指针并保存在eax中</span></span><br><span class="line"></span><br><span class="line"><span class="number">00083846</span>  mov         dword ptr [eax],<span class="number">8</span>DCB0h  <span class="comment">//后面的8DCB0h实际是虚函数表的偏移地址，也就是虚表指针安插在对象的前面（this指针内容）</span></span><br><span class="line"><span class="number">0008384</span>C  mov         eax,dword ptr [<span class="keyword">this</span>]    <span class="comment">//返回对象</span></span><br></pre></td></tr></table></figure>

<p>可以看出， 虚表指针是通过编译器在构造函数内安插在对象的前面的。另外也可以看到虚表指针的初始化都是基于this指针的，只有成员函数才有this指针，这就是为什么虚函数必须作为成员函数是用的原因。 </p>
<p>在虚表指针的初始化过程中，对象执行了构造函数后，就得到了虚表指针，当其余代码访问这个对象虚函数时，会根据对象的首地址，取出对应的虚表函数，当函数被调用时，会间接访问虚表，得到对应的虚函数首地址，然后调用执行。说白了就是地址转移来转移去的。</p>
<p>这种通过虚表间接寻址的情况只有在使用对象的指针或引用来调用虚函数时候才会出现，当直接使用对象调用自身的虚函数时，无需查表访问。就是前面代码中的静态联编方式访问。</p>
<p><strong>五、多态性</strong></p>
<p>前面说了动态联编和虚函数机制，就不能不说说这个C++中很重要的一个特性：多态性</p>
<p>多态性，简单地说就是“一个接口，多种实现”，就是不同的对象对应同一消息产生不同行为。一般而言，用同一个接口函数，去执行不同的函数体。执行哪个函数体看关联的是哪个对象。</p>
<p>下面直接通过一个简单例子来演示这个多态性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Course</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Choose</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span> :</span><span class="keyword">public</span> Course</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Choose</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Choose a Computer course"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Literature</span> :</span><span class="keyword">public</span> Course</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Choose</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Choose a Literature course"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DigitalImage</span> :</span><span class="keyword">public</span> Course</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Choose</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Choose a DigitalImage course"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection</span><span class="params">(Course *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ptr-&gt;Choose();<span class="comment">//动态联编，对不同的对象发送同一消息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Computer ObjCom;</span><br><span class="line">	Literature ObjLit;</span><br><span class="line">	DigitalImage ObjDig;</span><br><span class="line">	selection(&amp;ObjCom);</span><br><span class="line">	selection(&amp;ObjLit);</span><br><span class="line">	selection(&amp;ObjDig);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序中不同的课程，通过同一个消息来选择，选择的结果却由课程对象自身决定。</p>
<p>虚函数机制是这个实现的内在基石。多态性是外在的现象。</p>
<p>最后再补充一下：C++明白指出，当 derived class 对象经由一个 base class 指针被删除，而该base class 带着一个 non-virtual 析构函数，其结果是未有定义——实际执行时通常发生的是对象的 derived 成分没被销毁，而其base 成分通常会被销毁，造成一个诡异的“局部销毁”的对象。</p>
<p>如下面一个例子，如果base class 是带着一个 non-virtual 析构函数，那么下面程序，派生类将不会进行析构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Base() &#123;&#125;;</span><br><span class="line">	<span class="keyword">virtual</span> <span class="comment">/*尝试注释掉这个关键字，看输出结果*/</span> ~Base() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Output from the destructor of class Base"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Do something in class Base"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Derived() &#123;&#125;;</span><br><span class="line">	~Derived() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Output from the destructor of class Derived"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Do something in class Derived"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base *pT = <span class="keyword">new</span> Derived;</span><br><span class="line">	pT-&gt;DoSomething();</span><br><span class="line">	<span class="keyword">delete</span> pT;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使 base class 中不含虚函数（注释掉Dosomgthing函数前的virtual），如果不定义虚析构函数，那么派生类的析构函数将不会被调用，所以如果base class 是作为基类使用，其析构函数也应该定义为虚函数。 </p>
<p>虚析构函数与虚函数是相伴而生的。Scott Meyers 在《Effective C++》中建议：如果class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数。理由很简单，我们希望所自动调用的析构函数，能够通过动态联编方式去调用所关联的实际对象的析构函数，而不是简单的指针的基类型对应的基类对象的析构函数。</p>
<p>盲目的添加虚函数会增大对象内存空间，我们的心得是：除了上述情况，如果该 class 作为基类使用，那么它就应该声明一个 virtual 析构函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">匡俊桦</p>
  <div class="site-description" itemprop="description">回忆的沙漏将曾经屈指可数的日子渐渐淡去</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">238</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">匡俊桦</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">29:11</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
