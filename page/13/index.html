<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:type" content="website">
<meta property="og:title" content="KJHの博客">
<meta property="og:url" content="http://yoursite.com/page/13/index.html">
<meta property="og:site_name" content="KJHの博客">
<meta property="og:description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="匡俊桦">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>KJHの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KJHの博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录&回忆</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/" class="post-title-link" itemprop="url">C++运算符重载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-27 15:22:33 / 修改时间：15:23:22" itemprop="dateCreated datePublished" datetime="2020-12-27T15:22:33+08:00">2020-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一、运算符的定义</p>
<p>运算符重载就是运算符的“一符多用”。重载运算符是具有特殊名称的函数：保留字 operator 后接需定义的操作符符号。像任意其他函数一样，重载操作符具有返回类型和形参表，每个操作符用于内置类型都有关联的定义，当内置操作符和类型上的操作存在逻辑对应关系时，操作符重载最有用，最直观，使用重载操作符并不是创造命名操作。</p>
<p>二、在哪种情况下使用哪种重载运算符的方式合适？</p>
<p>C++ 提供了两种重载运算符的方式，在大多数情况下：</p>
<ul>
<li>只有一个操作数的运算符（一目）使用类运算符重载方式为好；</li>
<li>一般地说，如果运算符要修改操作数（类对象）的状态（值），则应使用类运算符（成员形式）。（在计算中可能改变操作数的值得运算符被称为有副作用的运算符，诸如：=、+=、-=、*=、/=、%=、++、– 等）；</li>
<li>C++规定，运算符=、()、[ ]、-&gt; 只能采用类运算符形式重载；</li>
<li>有两个操作数的运算符（二目）使用友元运算符重载方式为好；</li>
<li>友元运算符重载方式在操作数的数据类型自动转换方面更为宽容，尤其是第一个操作数希望能够隐式类型转换时，则应采用友元形式；</li>
<li>不允许重载的运算符有：&amp;&amp;、||、. 、:: 、 * 、?: 。</li>
</ul>
<p>三、运算符重载具体讨论（返回值和参数，这里讨论几个常用的运算符）</p>
<p>默认地，重载运算符必须与内置操作符保持一致，也就是说重载后的运算符必须与本来内置操作符保持特性一致。函数最主要的两个就是返回值和形参。</p>
<p>3.1、前缀++类运算符重载函数（前缀–类似）</p>
<p>自增（自减）操作符的前置式定义：累加（递减）而后取出；后置式定义：取出而后累加（递减）。</p>
<p>我们知道，在C语言里整型变量是允许连续前缀++两次的，也叫链式操作。这样为了保证重载运算符与内置操作符++类型一致，就要求前缀++类运算符重载函数也支持连续操作（链式操作），所以前缀++类运算符重载函数的返回值必须是类名的引用。上面第二点也说了，++作为单目运算符，并且会修改操作数的值，则应定义为类运算符，这样重载函数无形参。我们就可申明该前缀++类运算符重载函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zoo</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Zoo(<span class="keyword">int</span> lion_n = <span class="number">0</span>, <span class="keyword">int</span> tiger_n = <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		lion = lion_n; tiger = tiger_n; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	~Zoo()&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Zoo&amp; <span class="keyword">operator</span>++();<span class="comment">//无参，返回值为类名的引用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> lion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> tiger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面就是前缀++类运算符重载函数的实现了</p>
<p>内置类型前缀++操作符是直接修改了操作数，然后返回修改后的操作数本身（唯一地址），不存在复制的情况，所以重载函数也应遵循这一点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Zoo&amp; Zoo::<span class="keyword">operator</span>++()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++lion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++tiger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>由于函数的返回值类型被定义为引用，所以不会发生复制，返回的是操作数本身，完全符合内置前缀++的语法定义。</p>
<p>我们再来考虑错误情况：如果前缀++类运算符重载函数的返回值是类型，也就是返回一个对象，其对应实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Zoo Zoo::<span class="keyword">operator</span>++()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++lion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++tiger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>咋一看上面的也实现了前缀++的功能，但是返回值是对象，在函数返回时会发生复制，虽然该函数成功将操作类对象的成员修改了，但是函数返回的是一个复制品，然后再执行++链式操作时，修改的会是这个复制品的值（相当于这个复制品调用前缀++类运算符重载函数），本尊并没有修改，也就是不能成功实现链式操作，不符合内置++的语法定义（ C++中，前缀++是可以连续前缀两次以上的，但后缀++则不可以）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Zoo zoo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">++(++zoo);</span><br></pre></td></tr></table></figure>

<p>上面执行后，zoo.lion = 1，zoo.tiger = 1 。并不是期望的2。</p>
<p>至于返回其余类型那就更加错误了。</p>
<p>3.2、后缀++类运算符重载函数（后缀–类似）</p>
<p>与前缀++操作符一样，后缀++也是单目操作符，也会修改操作书本身，所以二者的形参数目和类型相同，为了区别函数，后缀++操作符接受一个额外的（即，无用的）int 型形参。使用后缀++操作符时，编译器提供0作为这个形参的实参。</p>
<p>与前缀++类运算符截然相反的是，后缀++返回值的类型恰恰不能是类的引用，其目的是在返回值时引起复制，即让一个并未自增的替身对象去参加表达式的后续运算，另外C/C++在语法上不允许后缀++连续运算两次以上，也就不要求返回引用，并且必须返回 const 对象。我们看看内置后缀++操作符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j = i++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i++++;  <span class="comment">//违法</span></span><br></pre></td></tr></table></figure>

<p>内置后缀++操作符，操作数 i 本身已经完成了自增，但是后续的赋值操作并不是将自增后的 i 赋值给j，而是将并未自增的替身参与赋值运算。所以在重载后缀++类运算符的时候，我们应该考虑这点，另外必须返回一个 const 对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Zoo Zoo::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">Zoo <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;<span class="comment">//拷贝构造函数，构造复制品</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++lion;<span class="comment">//本尊自增</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++tiger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;<span class="comment">//返回复制品</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在已经定义了前缀++类运算符重载函数的情况下，后缀++类运算符重载函数一般这样实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Zoo Zoo::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">Zoo <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;<span class="comment">//拷贝构造函数，构造复制品</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++(*<span class="keyword">this</span>);<span class="comment">//本尊自增</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;<span class="comment">//返回复制品</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.3、二目运算符重载（+=，-=，+，-） </p>
<p>先说复合赋值操作符，上面“+=”，“-=”也可认为是赋值操作符。内置+=、-=、%= 是允许进行链式操作的（如果不确定是否允许，可以写一个测试程序判断），所以为了与内置类型的操作一致，重载函数毫无疑问是返回一个引用，也避免了创建和撤销结果的临时副本。</p>
<p>但是“+”“-” 等是返回一个新的结果，这就要求算术运算符的重载不能返回一个引用，另外+的表达式也不能作为左值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = i + j + j;<span class="comment">//可以连续+，但是右边的i,j还是原值，(i+j) = i + i;错误！</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       i += (i += j);<span class="comment">//复合了赋值操作符，这样是允许的</span></span><br></pre></td></tr></table></figure>

<p>有了前面分析，不难写出上面的重载函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Zoo&amp; Zoo::<span class="keyword">operator</span>+=(Zoo &amp;rhs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	lion += rhs.lion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	tiger += rhs.tiger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继而过来讨论“+”“-”：</p>
<p><strong>返回值是一个右值</strong></p>
<p>前面说到了，“+”“-”是返回一个新的结果，算术运算符通常产生一个新值，该值是两个操作数的计算结果，它不同于任一操作数且在一个局部变量中计算，返回对那个变量的引用是一个运行时错误。通俗一点，假如算术运算符重载函数返回一个对象的引用，这个引用是两个操作的计算结果，它的本体就会是一个局部变量（对象），返回一个局部变量的引用，是错误的。所以对于类算术运算符的重载，只能返回一个右值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Zoo <span class="keyword">operator</span>+(Zoo &amp;first, Zoo &amp;second)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">Zoo <span class="title">ret</span><span class="params">(first)</span></span>;<span class="comment">//拷贝构造函数，构造一个局部变量，用于返回值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ret += second;<span class="comment">//运算操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;<span class="comment">//返回一个值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二目算术运算符重载通常使用友元运算符重载方式。</p>
<p>从上面也可以看出，类运算符的重载最好与内置运算符保持一致，虽然没硬性规定，但这俨然成了一个默认规定。</p>
<p>另外 !（逻辑反）、~（按位与）、-（负号）等与二目算术运算符有类似之处，那就他们都不会修改原对象数据成员，而是将运算结果交给一个新值，所以在重载时，需要构造一个临时对象作为返回值，返回值也就同样不能是引用。</p>
<p>3.4、输入输出操作符重载</p>
<p>支持I/O操作的类所提供的I/O操作接口，一般应该与标准库iostream为内置类型定义的接口相同。</p>
<p>1、输出操作符 &lt;&lt; 的重载</p>
<p>为了与I/O标准库一致，操作符应接受 ostream&amp; 作为第一个形参，对类类型 const 对象的引用作为第二个形参，并返回对 ostream 形参的引用。</p>
<p>重载输出操作符可能相对于比较难理解，这里简单的说下，我们只能以自定义类的友元函数的形式重载这两个运算符，这是因为如果我们用成员函数的形式来重载的话，就要改动系统的流类 istream 和 ostream 定义，这是C++不允许的，如果不定义为友元函数的话，将无法调用类对象成员数据输出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; stream, <span class="keyword">const</span> Zoo &amp;object)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//对object所引用的对象的数据进行的输出操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	stream &lt;&lt; object.lion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	stream &lt;&lt; object.tiger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> stream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看上面这个输出操作符重载函数，第一个参数是 ostream 类的引用，而函数的返回值也是 ostream 类的引用。毫无疑问，我们调用这个运算符重载函数时。实参肯定是 cout，这样就造成了这样一种情况：实参 stream 引用 cout，而函数的返回值又引用 stream，等于函数返回值引用的实体还是 cout。这样做的目的是实现了连续的输出操作。当执行下面语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; zoo_a &lt;&lt; zoo_b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面 cout &lt;&lt; zoo_a 实质就是调用 operator&lt;&lt;(cout, zoo_a),然后返回 cout</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下一个 &lt;&lt; 就相当于执行 cout &lt;&lt; zoo_b, 同上</span></span><br></pre></td></tr></table></figure>

<p>我们不能将该操作符重载函数定义为类的成员函数，否则，左操作数将只能是该类类型的对象。IO操作符通常要对非公用数据成员进行读写，因此，类通常将IO操作符（输入输出）设为友元。</p>
<p>2、输入操作符 &gt;&gt; 的重载</p>
<p>为了与IO标准库一致，操作符应接受 istream&amp; 作为第一个形参，指向它要读的流，并且返回的也是对同一个流的引用（链式操作）。它的第二个形参是对要读入的对象的非 const 引用，该形参必须为非 const，因为输入操作符的目的是将数据读到这个对象中。</p>
<p>更重要但通常重视不够的是，输入和输出操作符有如下区别：输入操作符必须处理错误和文件结束的可能性。</p>
<p>输入期间的错误：任何读操作都可能因为提供的值不正确而失败；任何读入都可能碰到输入流中的文件结束或其他一些错误。也就需要对输入进行附加检查，发现有这些错误就需要我们进行处理。</p>
<p>3.5、不能重载的运算符 &amp;&amp;、|| 和 , 操作符</p>
<p>和 C 一样，C++ 对于真假值表达式采用所谓骤死式评估方式。意思是一旦该表达式的真假值去顶，纵使表达式中还有部分尚未检验，整个评估工作仍告结束。比如下面这种情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((p != <span class="literal">NULL</span>) &amp;&amp; (<span class="built_in">strlen</span>(p) &gt; <span class="number">10</span>) ……</span><br></pre></td></tr></table></figure>

<p>你无需担心调用 strlen 时 p 是否为 NULL 指针，因为如果 p 是否为NULL 的测试结果是否定的，strlen 就绝不会被调用。事实上，对一个 NULL 指针调用 strlen，结果未可预期。</p>
<p>回到重载，C++ 允许我们为用户定制型别量身定做各类操作符，包括 &amp;&amp; 和 ||，操作符重载语义上是允许的，但是我们要考虑重载会不会改变对应内置操作符的规则。拿 &amp;&amp; 和 || 来说，重载则是对 operator &amp;&amp; 和 operator || 两函数进行重载工作，值得注意的是，函数调用语义将会取代骤死式语义，也就是说，如果你将operator &amp;&amp; 重载，下面这个虱子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression1 &amp;&amp; expression2) ……</span><br></pre></td></tr></table></figure>

<p>会被编译器视为以下两者之一：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression1.<span class="keyword">operator</span>&amp;&amp;(expression2)) ……</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设 operator&amp;&amp; 是个 member function</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">operator</span>&amp;&amp;(expression1, expression2)) ……</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设 operator&amp;&amp; 是个全局函数</span></span><br></pre></td></tr></table></figure>

<p>上面函数调用语义和所谓骤死式语义有两个重大的不同。第一，当函数调用动作被执行起来，所有参数值都必须评估完成，所以当我们调用 operator&amp;&amp; 和 operator|| 时，两个参数都已评估完成，没有什么骤死式语义。第二，C++ 语言规格并未明定函数调用动作中各参数的评估次序，所以没办法知道 expression1 和 expression2 哪个会先被评估，而内置的真假值表达式，则总是由左向右评估其自变量。</p>
<p>C++ 中，运算符重载的一个重要参考就是：不能修改运算符的内置语义。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Amalloc%E3%80%81calloc%E3%80%81free%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Amalloc%E3%80%81calloc%E3%80%81free%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">C语言内存管理：malloc、calloc、free的实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-27 15:20:44 / 修改时间：15:22:09" itemprop="dateCreated datePublished" datetime="2020-12-27T15:20:44+08:00">2020-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>任何一个对C稍稍有了解的人都知道malloc、calloc、free。前面两个是用户态在堆上分配一段连续（虚拟地址）的内存空间，然后可以通过free释放，但是，同时也会有很多人对其背后的实现机制不了解。<br>这篇文章则是通过介绍这三个函数，并简单的予以实现，对比现有C的标准库实现（glibc等）相比，并不是特别高效，我们重在阐述背后的基本原理。</p>
<p><strong>一、C程序的存储空间布局</strong></p>
<p>图1<br><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Amalloc%E3%80%81calloc%E3%80%81free%E7%9A%84%E5%AE%9E%E7%8E%B0/20160103134018703" alt="这里写图片描述"></p>
<ul>
<li>text：整个用户空间的最低地址部分，存放的是指令（程序所编译成的可执行机器码）。可共享，即使是频繁操作执行的程序，在存储器中也只需有一个副本，通常是只读的。</li>
<li>initialized data(data)：存放初始化过的全局变量，包含了程序中需明确地赋初值的变量。</li>
<li>uninitialized data(bss)：存放的是未初始化过的全局变量，在程序开始执行之前，内核将此段中的数据初始化为0或者NULL。</li>
<li>heap：堆，自低地址向高地址增长，后面重点剖析</li>
<li>stack：栈，自高地址向低地址增长，自动变量以及每次函数调用时所需保存的信息都存放在此段中。</li>
</ul>
<p><strong>二、Heap 内存模型</strong></p>
<p>一般来说，malloc所申请的内存主要从heap区域分配的。<br><a href="http://blog.csdn.net/wenqian1991/article/details/25159545" target="_blank" rel="noopener">linux内存管理</a>，从这里可以了解到linux下虚拟地址与物理地址。</p>
<p>linux对堆的管理如下：<br>图2<br><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Amalloc%E3%80%81calloc%E3%80%81free%E7%9A%84%E5%AE%9E%E7%8E%B0/20160103142123394" alt="这里写图片描述"></p>
<p>linux 内核维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址（Heap’s Start）到break之间的地址空间为映射好的（虚拟地址与物理地址的映射，通过MMU实现），可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。</p>
<p>所以，如果Mapped Region 空间不够时，会调整break指针，扩大映射空间，重新分配内存。</p>
<p><strong>三、调整break：brk()和sbrk()</strong></p>
<p>最初break的位置正好位于bss端末尾之后，看图1，在break指针的位置升高时，程序可以访问新分配区域内的任何内存地址，而此时物理内存页尚未分配，内存会在京城首次试图访问这些虚拟内存地址时自动分配新的物理内存页。</p>
<p>linux通过brk和sbrk系统调用操作break指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> increment)</span></span>;<span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>brk() 将break指针设置为 addr 所指定的位置，由于虚拟内存以页为单位进行分配，addr实际会四舍五入到下一个内存也的边界处。<br>由于brk是直接指定一个地址，所以一旦这个值取得过低，有可能导致不可预知的行为，对照图1，brk只能在指定的区域内调整break。</p>
<p>sbrk() 将break指针在原有地址增加从参数 increment 传入的大小（linux中，sbrk是基于brk基础上实现的一个库函数），用于声明increment 的intptr_t 类型属于整数数据类型。<br>若调用成功，sbrk() 返回前一个break 的地址，换言之，如果break 增加，那么返回值是指向这块新分配内存起始位置的指针。<br>sbrk(0) 将得到当前break指针的位置。</p>
<p>系统对每一个进程所分配的资源不是无限的，包括可映射的内存空间，图2，未映射内存的尾端有个rlimit表示当前进程可用的资源上限。</p>
<p><strong>三、malloc</strong></p>
<p>根据标准C库函数的定义，malloc 具有如下模型：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这个函数要实现的功能是在系统中分配一段连续的可用的内存，具体有如下要求：<br>- malloc分配的内存大小至少为size参数所指定的字节数<br>- malloc的返回值是一个指针，指向一段可用内存的起始地址<br>- 多次调用malloc所分配的地址不能有重叠部分，除非该地址已经被释放掉<br>- malloc应该尽快完成内存分配并返回（不能使用<a href="https://en.wikipedia.org/wiki/NP-hardness" target="_blank" rel="noopener">NP-hard</a>的内存分配算法）<br>- 实现malloc时，应该同时实现内存大小调整和内存释放函数（calloc和free）<br>- malloc分配失败时必须返回NULL</p>
<p>malloc 返回内存块所采用的字节对齐方式，总是适宜于高效访问任何类型的C语言数据结构。</p>
<p><strong>四、初探实现malloc：</strong></p>
<p>我们假定整个内存处于初始状态，即break指针位于bss段的单位，整个heap都是 Unmapped Region。（图2）<br>基于此，我们可以实现一个简单但毫无实际价值的malloc：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*一个糟糕的仿制malloc*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#incldue <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line">    p = sbrk(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*如果sbrk失败，返回NULL*/</span></span><br><span class="line">    <span class="keyword">if</span>(sbrk(<span class="built_in">size</span>) == (<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;<span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<p>这个malloc就是从未映射区域直接划出一块，但是malloc对这块已分配的内存缺乏记录，不便于内存释放。</p>
<p><strong>五、正式实现malloc</strong></p>
<p>上面说到分配的内存没有记录，一旦调用free释放，free不知道它到底要释放多大的内存，所以我们需要额外一个数据结构来记录这些信息。</p>
<p><strong>5.1、数据结构</strong><br>一个简单可行方案是将堆内存以块的形式组织起来，每个块（block）由meta区和数据区组成，meta去记录数据块的元信息（数据块大小、空闲标志位、指针等），数据区则是真实分配的内存区域，并且数据区的第一个字节地址即为malloc返回的地址。</p>
<p>可用如下结构体定义一个block：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> *<span class="title">t_block</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_block</span>&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span>   <span class="built_in">size</span>;<span class="comment">//数据区大小</span></span><br><span class="line">    t_block  next;<span class="comment">//指向下个块的指针</span></span><br><span class="line">    <span class="keyword">int</span>      <span class="built_in">free</span>;<span class="comment">//是否是空闲块</span></span><br><span class="line">    <span class="keyword">char</span>     data[<span class="number">1</span>];<span class="comment">//虚拟字段，表示数据块的第一个字节，长度不计入meta</span></span><br><span class="line">&#125;;<span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p>图3<br><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Amalloc%E3%80%81calloc%E3%80%81free%E7%9A%84%E5%AE%9E%E7%8E%B0/20160103160120434" alt="这里写图片描述"></p>
<p>那么用这个结构体来分配内存，而不用malloc则是下面一番场景：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t_block  <span class="keyword">b;</span></span><br><span class="line"><span class="keyword">b </span>= <span class="keyword">sbrk(0);</span></span><br><span class="line"><span class="keyword">sbrk(sizeof(struct </span>s_block) + size);</span><br><span class="line"><span class="keyword">b-&gt;size </span>= size<span class="comment">;//size 为要分配的内存大小1234</span></span><br></pre></td></tr></table></figure>

<p><strong>5.2、寻找合适的block</strong><br>我们从堆的起始地址开始查找第一个符合要求的block，并返回block起始地址，如果找不到就返回NULL；</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">t_block</span> find_block(t_block *last, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    t_block <span class="keyword">b </span>= <span class="keyword">base;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="meta">while</span>(<span class="keyword">b </span>&amp;&amp; !(<span class="keyword">b-&gt;free </span>&amp;&amp; <span class="keyword">b-&gt;size </span>&gt;= size))</span><br><span class="line">    &#123;</span><br><span class="line">        *last = <span class="keyword">b;</span></span><br><span class="line"><span class="keyword"> </span>       <span class="keyword">b </span>= <span class="keyword">b-&gt;next;</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line"><span class="symbol">return</span> <span class="keyword">b;</span></span><br><span class="line"><span class="keyword">&#125;12345678910</span></span><br></pre></td></tr></table></figure>

<p>这里base是一个全局变量，维护整个堆的起始地址。另外，这里在遍历时会更新一个last指针，这个指针始终指向当前遍历的block，如果找不到合适的block，那么malloc将很容易的开辟新的block使用。</p>
<p><strong>5.3、开辟新的block</strong><br>如果现有block都不能满足需求，则需要在链表最后开辟一个新的block。最简单的方式就是利用sbrk升高break位置然后对其初始化，然后更新对应block指针，将其add到链表最后。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">t_block <span class="title">extend_heap</span><span class="params">(t_block last, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t_block b;</span><br><span class="line">    b = sbrk(<span class="number">0</span>);<span class="comment">//定位到当前break位置</span></span><br><span class="line">    <span class="keyword">if</span>(sbrk(<span class="keyword">sizeof</span>(struct s_block) + <span class="built_in">size</span>) == (<span class="keyword">void</span>*)<span class="number">-1</span>)<span class="comment">//调整break位置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    b-&gt;<span class="built_in">size</span> = <span class="built_in">size</span>;</span><br><span class="line">    b-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(last)<span class="comment">//这个last是指向extend之前最后一个block</span></span><br><span class="line">        last-&gt;next = b;<span class="comment">//新开辟的block挂载在链表中</span></span><br><span class="line">    b-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;<span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<p><strong>5.4、分裂block</strong><br>看前面 find_block() 的实现，如果我们申请的 size 远小于查找到的 block。（这种情况是可能，它是查到第一个满足条件（大小，可用）的block），这样会导致较大内部碎片的产生。<br>所以，应该在剩余数据区足够大的情况下，将其分裂成一个新的block：</p>
<p>图4<br><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Amalloc%E3%80%81calloc%E3%80%81free%E7%9A%84%E5%AE%9E%E7%8E%B0/20160103165244021" alt="这里写图片描述"></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//b是要分裂的block，size是申请的内存大小</span></span><br><span class="line"><span class="comment">//分裂后b成了分配后的block</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split_block</span><span class="params">(t_block b, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t_block <span class="keyword">new</span>;<span class="comment">//新的空闲block = 要分裂的block - 申请分配出去的内存</span></span><br><span class="line">    <span class="keyword">new</span> = b-&gt;data + <span class="built_in">size</span>;<span class="comment">//将new定位到剩下的数据块区域</span></span><br><span class="line">    <span class="comment">//分裂的原block-分配出去的内存大小-block结构体本身大小</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;<span class="built_in">size</span> = b-&gt;<span class="built_in">size</span> - <span class="built_in">size</span> - BLOCK_SIZE;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = b-&gt;next;<span class="comment">//链表插入</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;<span class="built_in">free</span> = <span class="number">1</span>;<span class="comment">//空闲标记可用</span></span><br><span class="line">    b-&gt;<span class="built_in">size</span> = <span class="built_in">size</span>;</span><br><span class="line">    b-&gt;next = <span class="keyword">new</span>;<span class="comment">//链表插入</span></span><br><span class="line">&#125;<span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<p>看了上面一大串，是不是跟伙伴算法很像。但是这里的分裂block函数，得视情况调用，如果申请的size &lt; block-&gt;size，但是又不是小太多，如果分裂block的话，会导致分裂后剩余未分配出去的数据块过小，无法满足其余需求，很容易形成内存碎片。</p>
<p>所以，伙伴算法有更高效的处理（实际上伙伴算法也会产生内部碎片）。</p>
<p><strong>5.5、malloc 的实现</strong><br>铺垫做了那么多，我们可以利用它们整合成一个简单可用的malloc。<br>首先定义一个block链表的头指针，初始化为NULL，另外，我们需要剩余空间至少有 BLOCK_SIZE + 4 才执行分离操作。</p>
<p>此外，一开始我们讲到，malloc对分配的内存大小也有要求，是按4字节对齐，所以申请的size不为4的倍数时，我们需要将其调整为大于size的最小的4的倍数。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> align4(x) (((((x)-1)&gt;&gt;2)&lt;&lt;2)+4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_SIZE 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    t_block b, last;</span><br><span class="line">    <span class="keyword">size_t</span> s;</span><br><span class="line"></span><br><span class="line">    s = align4(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">if</span>(base)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//first find a block</span></span><br><span class="line">        last = base;</span><br><span class="line">        b = find_block(&amp;last, s);</span><br><span class="line">        <span class="keyword">if</span>(b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//can we split</span></span><br><span class="line">            <span class="keyword">if</span>((b-&gt;<span class="built_in">size</span> - s) &gt;= (BLOCK_SIZE + <span class="number">8</span>))</span><br><span class="line">                split_block(b, s);</span><br><span class="line">            b-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//no fitting block, extend the heap</span></span><br><span class="line">            b = extend_heap(last, s);</span><br><span class="line">            <span class="keyword">if</span>(!b)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//first time</span></span><br><span class="line">        b = extend_heap(<span class="literal">NULL</span>, s);</span><br><span class="line">        <span class="keyword">if</span>(!b)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        base = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b-&gt;data;</span><br><span class="line">&#125;<span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041</span></span><br></pre></td></tr></table></figure>

<p>实现思路很简单：首先往链表中查找合适的block，如果找到了，看是否可以分裂，如果可以就分裂；如果没有找到合适的，就开辟一个新的block；如果是第一次分配，即整个内存链表不存在，则一开始就得新开辟一个block。</p>
<p><strong>六、calloc 的实现</strong></p>
<p>先看calloc的标准库语义：函数 calloc() 用于给一组相同对象分配内存。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> numitems, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span>1</span></span><br></pre></td></tr></table></figure>

<p>参数numitems指定分配对象的数量，size指定每个对象的大小。</p>
<p>calloc 与之malloc 不同之处在于，calloc 会将分配后的内存空间初始化，而malloc 申请的是一块未初始化的内存。<br>所以，实现calloc，只需两步：</p>
<ol>
<li>malloc 一块内存</li>
<li>将数据区内容初始化为0</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> numitems, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> *<span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">size_t</span> s, i;</span><br><span class="line">    <span class="keyword">new</span> = <span class="built_in">malloc</span>(numitems * <span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//因为申请的内存总是4的倍数，所以这里我们以4字节为单位初始化</span></span><br><span class="line">        s = align4(numitems * <span class="built_in">size</span>) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; s; ++i)</span><br><span class="line">            <span class="keyword">new</span>[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line">&#125;<span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>

<p><strong>七、free 的实现</strong></p>
<p>free 的实现并不像看上去那么简单，需要解决两个关键问题：</p>
<ol>
<li>如何验证所传入的地址是有效地址（malloc方式分配的）</li>
<li>如何解决碎片问题</li>
</ol>
<p><strong>7.1、先看如何解决碎片问题</strong>，就是把相邻的空闲内存合并为大的（伙伴算法类似）：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并相邻空闲的内存块，参数决定合并的是上一个还是下一个</span></span><br><span class="line">t_block fusion(t_block b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(b-&gt;</span><span class="function"><span class="title">next</span> &amp;&amp; b-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>free)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">b</span>-&gt;</span><span class="function"><span class="title">size</span> += BLOCK_SIZE + b-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>size;</span><br><span class="line">        <span class="function"><span class="title">b</span>-&gt;</span><span class="function"><span class="title">next</span> = b-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>next;</span><br><span class="line">        <span class="function"><span class="title">if</span>(b-&gt;</span>next)</span><br><span class="line">            <span class="function"><span class="title">b</span>-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>prev = b;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;<span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<p>再看如何验证所传入的地址是有效的，位于heap内。<br>一个解决方法是，在block结构体中添加一个 ptr 指针，用于指向数据块区域，如果 b-&gt;ptr == b-&gt;data，则表示 b 极有可能是一个有效block。<br>所以我们对block数据结构进行了扩展：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_block</span>&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span>   <span class="built_in">size</span>;<span class="comment">//数据区大小</span></span><br><span class="line">    t_block  next;<span class="comment">//指向下个块的指针</span></span><br><span class="line">    <span class="keyword">int</span>      <span class="built_in">free</span>;<span class="comment">//是否是空闲块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="keyword">void</span>     *ptr;</span><br><span class="line">    <span class="keyword">char</span>     data[<span class="number">1</span>];</span><br><span class="line">&#125;;<span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p><strong>7.2、根据给定地址得到对应的block</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意，这个函数最后通过偏移量得到的block可能是有效的，可能不是有效的</span></span><br><span class="line"><span class="function">t_block <span class="title">get_block</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *tmp;</span><br><span class="line">    tmp = p;</span><br><span class="line">    <span class="keyword">return</span> (p = tmp -= BLOCK_SIZE);</span><br><span class="line">&#125;<span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p><strong>7.3、下面则验证是不是有效的block：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> valid_addr(<span class="built_in">void</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(base)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p &gt; base &amp;&amp; p &lt; sbrk(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> (p == (get_block(p))-&gt;ptr);</span><br><span class="line">        <span class="comment">//如果两个字段地址一样，表示是一个有效block</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p><strong>7.4、下面就实现free</strong></p>
<p>这里我们采用的合并策略是这样的：先合并相邻的空闲内存块，合并之后，再检查是否还有空闲的相邻内存块，如果有则继续合并，直到最后，该内存块是最大的连续内存块。<br>另外，对于break指针的调整（降低），必须保证在该释放的block与 Unmapped Region之间是空闲的，没有被占。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void free(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    t_block b;</span><br><span class="line">    <span class="keyword">if</span>(valid_addr(p))<span class="comment">//地址的有效性验证</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = get_block(p);<span class="comment">//得到对应的block</span></span><br><span class="line">        <span class="function"><span class="title">b</span>-&gt;</span>free = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果相邻的上一块内存是空闲的就合并,</span></span><br><span class="line"><span class="comment">//合并之后的上一块还是空闲的就继续合并，直到不能合并为止</span></span><br><span class="line">        <span class="function"><span class="title">while</span>(b-&gt;</span><span class="function"><span class="title">prev</span> &amp;&amp; b-&gt;</span><span class="function"><span class="title">prev</span>-&gt;</span>free)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">b</span> = fusion(b-&gt;</span>prev);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同理去合并后面的空闲block</span></span><br><span class="line">        <span class="function"><span class="title">while</span>(b-&gt;</span>next)</span><br><span class="line">            fusion(b);<span class="comment">//内部会判断是否空闲</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果当前block是最后面的那个block，此时可以调整break指针了</span></span><br><span class="line">        <span class="function"><span class="title">if</span>(NULL == b-&gt;</span>next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span>(b-&gt;</span>prev)<span class="comment">//当前block前面还有占用的block</span></span><br><span class="line">                <span class="function"><span class="title">b</span>-&gt;</span><span class="function"><span class="title">prev</span>-&gt;</span>next = NULL;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//当前block就是整个heap仅存的</span></span><br><span class="line">                base = NULL;<span class="comment">//则重置base</span></span><br><span class="line">            brk(b);<span class="comment">//调整break指针到b地址位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则不能调整break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="number">12345678910111213141516171819202122232425262728293031</span></span><br></pre></td></tr></table></figure>

<p><strong>八、realloc的实现</strong></p>
<p>同样先看标准库中realloc的语义：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span>1</span></span><br></pre></td></tr></table></figure>

<p>ptr 是指向需要调整大小的内存块的指针，参数 size 指定所需调整大小的期望值。</p>
<p>realloc() 用来调整（通常是增加）一块内存的大小，而此块内存应是之前由malloc函数分配的。若 realloc 增加了已分配内存块的大小，则不会对额外分配的内存进行初始化。</p>
<p><strong>8.1、内存块复制</strong><br>看了realloc的语义，我们首先得实现一个内存复制方法。如同calloc一样，我们以4字节为单位进行复制：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void copy_block(t_block src, t_block dst)</span><br><span class="line">&#123;</span><br><span class="line">    int *sdata, *dtata;</span><br><span class="line">    size_t <span class="built_in">i</span>;</span><br><span class="line">    sdata = src-&gt;ptr;</span><br><span class="line">    ddata = dst-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span>*<span class="number">4</span> &lt; src-&gt;<span class="built_in">size</span> &amp;&amp; <span class="built_in">i</span>*<span class="number">4</span> &lt; dst-&gt;<span class="built_in">size</span>; ++<span class="built_in">i</span>)</span><br><span class="line">        ddata[<span class="built_in">i</span>] = sdata[<span class="built_in">i</span>];</span><br><span class="line">&#125;<span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p><strong>8.2、实现realloc</strong><br>为了更高效，我们考虑以下几个方面：</p>
<ol>
<li>如果当前block的数据区大于等于realloc要求的size，则考虑能不能split，然后直接返回</li>
<li>如果新的size变小了，考虑split</li>
<li>如果当前block的数据区不能满足size，但是其后继block是free，并且合并后可以满足size，则考虑合并，然后再考虑能不能split</li>
<li>如果以上都不行，则调用malloc重新分配size大小内存，然后内存复制</li>
</ol>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void *realloc(<span class="name">void</span> *p, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    size_t s;</span><br><span class="line">    t_block b, new;</span><br><span class="line">    void *newp<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    if(!p)</span><br><span class="line">        return malloc(<span class="name">size</span>)<span class="comment">;</span></span><br><span class="line">    if(<span class="name">valid_addr</span>(<span class="name">p</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        s = align4(<span class="name">size</span>)<span class="comment">;</span></span><br><span class="line">        b = get_block(<span class="name">p</span>)<span class="comment">;//得到对应的block</span></span><br><span class="line">        if(<span class="name">b-&gt;size</span> &gt;= s)//如果size变小了，考虑split</span><br><span class="line">        &#123;</span><br><span class="line">            if(<span class="name">b-&gt;size</span> - s &gt;= (<span class="name">BLOCK_SIZE</span> + <span class="number">4</span>))</span><br><span class="line">                split_block(<span class="name">b</span>, s)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        else//如果当前block的数据区不能满足size</span><br><span class="line">        &#123;</span><br><span class="line">//如果后继block是free的，并且合并后大小满足size，考虑合并</span><br><span class="line">            if(<span class="name">b-&gt;next</span> <span class="symbol">&amp;&amp;</span> b-&gt;next-&gt;free</span><br><span class="line">                <span class="symbol">&amp;&amp;</span> (<span class="name">b-&gt;size</span> + BLOCK_SIZE + b-&gt;next-&gt;size) &gt;= s)</span><br><span class="line">            &#123;</span><br><span class="line">                fusion(<span class="name">b</span>)<span class="comment">;</span></span><br><span class="line">            //合并后满足size，再看能不能split</span><br><span class="line">                if(<span class="name">b-&gt;size</span> - s &gt;= (<span class="name">BLOCK_SIZE</span> + <span class="number">4</span>))</span><br><span class="line">                    split_block(<span class="name">b</span>, s)<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">            else//以上都不满足，则malloc新区域</span><br><span class="line">            &#123;</span><br><span class="line">                newp = malloc(<span class="name">s</span>)<span class="comment">;</span></span><br><span class="line">                if(!newp)</span><br><span class="line">                    return NULL<span class="comment">;</span></span><br><span class="line">            //内存复制</span><br><span class="line">                new = get_block(<span class="name">newp</span>)<span class="comment">;</span></span><br><span class="line">                copy_block(<span class="name">b</span>, new)<span class="comment">;</span></span><br><span class="line">                free(<span class="name">p</span>)<span class="comment">;//释放old </span></span><br><span class="line">                return newp<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return p<span class="comment">;//当前block数据区大于size时</span></span><br><span class="line">    &#125;</span><br><span class="line">    return NULL<span class="comment">;</span></span><br><span class="line">&#125;<span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041424344</span></span><br></pre></td></tr></table></figure>

<p><strong>九、总结</strong></p>
<p>以上是一个比较简陋，存在很大的优化空间，但大致阐述了malloc的机制，这也是本篇博文的目的。<br>对于更好的优化读者可以参考<a href="http://blog.csdn.net/wenqian1991/article/details/27968779" target="_blank" rel="noopener">linux内核伙伴算法</a>、以及<a href="http://blog.csdn.net/wenqian1991/article/details/19605727" target="_blank" rel="noopener">STL空间配置器</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E8%B5%8B%E5%80%BC%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E8%B5%8B%E5%80%BC%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">C++拷贝构造函数与赋值函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-27 15:18:11" itemprop="dateCreated datePublished" datetime="2020-12-27T15:18:11+08:00">2020-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-02 20:31:26" itemprop="dateModified" datetime="2021-03-02T20:31:26+08:00">2021-03-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这里我们用类String 来介绍这两个函数：</p>
<p>拷贝构造函数是一种特殊构造函数，具有单个形参，该形参（常用const修饰）是对该类类型的引用。当定义一个新对象并用一个同类型的对象对它进行初始化时，将显式使用拷贝构造函数。为啥形参必须是对该类型的引用呢？试想一下，假如形参是该类的一个实例，由于是传值参数，我们把形参复制到实参会调用拷贝构造函数，如果允许拷贝构造函数传值，就会在拷贝构造函数内调用拷贝构造函数，从而形成无休止的递归调用导致栈溢出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s);</span><br><span class="line"><span class="comment">//类成员，无返回值</span></span><br></pre></td></tr></table></figure>

<p>赋值函数，也是赋值操作符重载，因为赋值必须作为类成员，那么它的第一个操作数隐式绑定到 this 指针，也就是 this 绑定到指向左操作数的指针。因此，赋值操作符接受单个形参，且该形参是同一类类型的对象。右操作数一般作为const 引用传递。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>&amp;	<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s);</span><br><span class="line"><span class="comment">//类成员，返回对同一类类型(左操作数)的引用</span></span><br></pre></td></tr></table></figure>


<p>拷贝构造函数和赋值函数并非每个对象都会使用，另外如果不主动编写的话，编译器将以“位拷贝”的方式自动生成缺省的函数。在类的设计当中，“位拷贝”是应当防止的。倘若类中含有指针变量，那么这两个缺省的函数就会发生错误。这就涉及到深复制和浅复制的问题了。</p>
<p>拷贝有两种：深拷贝，浅拷贝<br>当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。<br>但当数据成员中有指针时，如果采用简单的浅拷贝，则<strong>两类中的两个指针将指向同一个地址</strong>，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。所以，这时，必须采用深拷贝。<br>深拷贝与浅拷贝的区别就在于<strong><em>\</em>深拷贝会在堆内存中另外申请空间来储存数据**</strong>，从而也就解决了指针悬挂的问题。指向不同的内存空间，但内容是一样的<br>简而言之，<strong><em>\</em>当数据成员中有指针时，必须要用深拷贝**</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> * c;</span><br><span class="line">&#125;a, b;</span><br><span class="line"><span class="comment">//浅复制不会重新分配内存</span></span><br><span class="line"><span class="comment">//将a 赋给 b，缺省赋值函数的“位拷贝”意味着执行</span></span><br><span class="line">a.c = b.c;</span><br><span class="line"><span class="comment">//从这行代码可以看出</span></span><br><span class="line"><span class="comment">//b.c 原有的内存没有释放</span></span><br><span class="line"><span class="comment">//a.c 和 b.c 指向同一块内存，任何一方的变动都会影响到另一方</span></span><br><span class="line"><span class="comment">//对象析构的时候，c 被释放了两次（a.c == b.c 指针一样）</span></span><br><span class="line"><span class="comment">//深复制需要自己处理里面的指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> *c;</span><br><span class="line">	A&amp; <span class="keyword">operator</span> =(<span class="keyword">const</span> A &amp;b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//隐含 this 指针</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;b)</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">delete</span> c;<span class="comment">//释放原有内存资源</span></span><br><span class="line">		<span class="comment">//分配新的内存资源</span></span><br><span class="line">		<span class="keyword">int</span> length = <span class="built_in">strlen</span>(b.c);</span><br><span class="line">		c = <span class="keyword">new</span> <span class="keyword">char</span>[length + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(c, b.c);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;a, b;</span><br><span class="line"><span class="comment">//这个是深复制，它有自定义的复制函数，赋值时，对指针动态分配了内存</span></span><br></pre></td></tr></table></figure>

<p>这里再总结一下深复制和浅复制的具体区别：</p>
<ol>
<li>当拷贝对象状态中包含其他对象的引用时，如果需要复制的是引用对象指向的内容，而不是引用内存地址，则是深复制，否则是浅复制。</li>
<li>浅复制就是成员数据之间的赋值，当值拷贝时，两个对象就有共同的资源。而深拷贝是先将资源复制一份，是对象拥有不同的资源（内存区域），但资源内容（内存里面的数据）是相同的。</li>
<li>与浅复制不同，深复制在处理引用时，如果改变新对象内容将不会影响到原对象内容</li>
<li>与深复制不同，浅复制资源后释放资源时可能会产生资源归属不清楚的情况（含指针时，释放一方的资源，其实另一方的资源也随之释放了），从而导致程序运行出错</li>
</ol>
<p>深复制和浅复制还有个区别就是执行的时候，浅复制是直接复制内存地址的，而深复制需要重新开辟同样大小的内存区域，然后复制整个资源。</p>
<p>好，有了前面的铺垫，下面开始讲讲拷贝构造函数和赋值函数，其实前面第一部分也已经介绍了许多</p>
<p>这里以string 类为例来进行说明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	String(<span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="literal">NULL</span>);</span><br><span class="line">	String(<span class="keyword">const</span> String &amp;rhs);</span><br><span class="line">	String&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String &amp;rhs);</span><br><span class="line">	~String(<span class="keyword">void</span>)&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] m_data;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> *m_data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">String::String(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == str)</span><br><span class="line">	&#123;</span><br><span class="line">		m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">		*m_data = <span class="string">'\0'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(m_data, str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数，无需检验参数的有效性</span></span><br><span class="line">String::String(<span class="keyword">const</span> String &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.m_data) + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(m_data, rhs.m_data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值函数</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">delete</span>[] m_data; m_data = <span class="literal">NULL</span>;</span><br><span class="line">	m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.m_data) + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(m_data, rhs.m_data);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类String 拷贝构造函数与普通构造函数的区别是：在函数入口处无需与 NULL 进行比较，这是因为“引用”不可能是NULL，而“指针”可以为NULL。（这是引用与指针的一个重要区别）。然后需要注意的就是深复制了。</p>
<p>相比而言，对于类String 的赋值函数则要复杂的多：</p>
<p>1、首先需要执行检查自赋值</p>
<p>这是防止自复制以及间接复制，如 b = a; c = b; a = c;之类，如果不进行自检的话，那么后面的 delete 将会进行自杀操作，后面随之的拷贝操作也会出错，所以这是关键的一步。还需要注意的是，自检是检查地址，而不是内容，内存地址是唯一的。必须是 if(this == &amp;rhs)</p>
<p>2、释放原有的内存资源</p>
<p>必须要用 delete 释放掉原有的内存资源，如果此时不释放，该变量指向的内存地址将不再是原有内存地址，也就无法进行内存释放，造成内存泄露。</p>
<p>3、分配新的内存资源，并复制资源</p>
<p>这样变量指向的内存地址变了，但是里面的资源是一样的</p>
<p>4、返回本对象的引用</p>
<p>这样的目的是为了实现像 a = b = c; 这样的链式表达，注意返回的是 *this 。</p>
<p>但仔细一想，上面的程序没有考虑到异常安全性，我们在分配内存之前用delete 释放了原有实例的内存，如果后面new 出现内存不足抛出异常，那么之前delete 的 m_data 将是一个空指针，这样很容易引起程序崩溃，所以我们可以调换下顺序，即先 new 一个实例内存，成功后再用 delete 释放原有内存空间，最后用 m_data 赋值为new后的指针。</p>
<p>接下来说说拷贝构造函数和赋值函数之间的区别。</p>
<p>拷贝构造函数和赋值函数非常容易混淆，常导致错写、错用。拷贝构造函数是在对象被创建是调用的，而赋值函数只能在已经存在了的对象调用。看下面代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">a</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">b</span><span class="params">(<span class="string">"world"</span>)</span></span>;</span><br><span class="line">	String c = a;<span class="comment">//这里c对象被创建调用的是拷贝构造函数</span></span><br><span class="line">             <span class="comment">//一般是写成 c(a);这里是与后面比较</span></span><br><span class="line">	c = b;<span class="comment">//前面c对象已经创建，所以这里是赋值函数</span></span><br></pre></td></tr></table></figure>

<p>上面说明出现“=”的地方未必调用的都是赋值函数（算术符重载函数），也有可能拷贝构造函数，那么什么时候是调用拷贝构造函数，什么时候是调用赋值函数你？ 判断的标准其实很简单：如果临时变量是第一次出现，那么调用的只能是拷贝构造函数，反之如果变量已经存在，那么调用的就是赋值函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C++%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%92%8CC%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84static/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C++%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%92%8CC%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84static/" class="post-title-link" itemprop="url">C++类的静态成员和C语言中的static</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-27 15:16:30" itemprop="dateCreated datePublished" datetime="2020-12-27T15:16:30+08:00">2020-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-02 21:46:25" itemprop="dateModified" datetime="2021-03-02T21:46:25+08:00">2021-03-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一、C++类的静态成员</p>
<p>学过C++的都知道，静态成员是属于整个类而不是某个对象的，静态成员变量在内存中只存储一份共所有对象共用，在所有对象中都可以共享它。</p>
<p>静态成员的定义或声明需要加个关键字 static。因为属于整个类，所以可以通过 &lt;类名&gt;::&lt;静态成员名&gt;来使用。</p>
<p>比较容易混淆和出错的地方在于类的静态成员变量和静态成员函数的使用，这两者都属于静态成员。</p>
<p>需要注意的是：静态成员属于整个类，在类对象实例化前，静态成员就已经分配空间了，而非静态成员无需初始化，必须在类实例化对象后才有内存空间，所以就有了个先后顺序：静态成员先于非静态成员存在。</p>
<p>下面我们来看看如下几个情况： </p>
<p>1、通过类名调用静态成员函数和非静态成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base::fun1();</span><br><span class="line">	Base::fun2();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>编译错误：“Base::fun1”: 非静态成员函数的非法调用<br>结论1：不能通过类名来调用类的非静态成员函数。<br>原因：类没有实例化对象，非静态成员函数不存在</p>
<p>2、通过类的对象静态成员函数和非静态成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base obj;</span><br><span class="line">	obj.fun1();</span><br><span class="line">	obj.fun2();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译通过<br>结论2：可以通过类的对象调用静态成员函数和非静态成员函数<br>原因：类实例化对象，非静态成员函数已分配内存，静态成员函数为类各对象共享</p>
<p>3、在类的静态成员函数中使用类的非静态成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base obj;</span><br><span class="line">	obj.fun2();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译出错：对非静态成员“Base::x”的非法引用<br>结论3：类的静态成员函数不能使用类的非静态成员<br>原因：在编译阶段，静态成员函数已分配内存，但非静态成员并没有分配内存，就好比提前使用一个不存在的东西</p>
<p>4、在类的非静态成员函数中使用类的静态成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		fun2();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base obj;</span><br><span class="line">	obj.fun1();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译通过<br>结论4：类的非静态成员函数可以调用静态成员，反之则不能<br>理由同前</p>
<p>5、使用类的静态成员变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//int Base::x = 0;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Base::x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链接出错：无法解析的外部符号 “private: static int Base::x” (?x@Base@@0HA)<br>结论5：类的静态成员变量必须初始化，并且静态成员变量的初始化必须在类外初始化，且不能带static关键字<br>原因：静态成员变量属于类作用域，不属于类对象，程序一运行就分配内存并初始化，生命周期和程序一致，在类的构造函数内初始化显然是不合理的。另外在类外初始化时，还必须指定类型，否则编译器不知道该为变量分配多大内存。</p>
<p><strong>但是，静态成员也并非不能再类中初始化。对于静态常量成员是可以在类中初始化的。</strong></p>
<p>总结：<br>1.静态成员存在于内存，非静态成员需要实例化才会分配内存<br>2.非静态成员的生存期取决于该类的生存期，而静态成员则不存在生存期的概念<br>3.类的静态成员函数不能调用非静态成员，存在的先后顺序，反之可以<br>4.类的静态成员变量必须初始化，且必须在类外初始化（静态常量成员除外），不能带static关键字，必须带类型。</p>
<p>二、C语言中的static</p>
<p>下面介绍在C语言中，static的作用：</p>
<p>1、隐藏</p>
<p>当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。比如，同时编译两个源文件，一个是a.c，另一个是main.c</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.c</span></span><br><span class="line"><span class="keyword">char</span> a = <span class="string">'A'</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">char</span> a;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%c"</span>, a);</span><br><span class="line">	(<span class="keyword">void</span>)msg();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output:A Hello</span></span><br></pre></td></tr></table></figure>

<p>由于a.c 中的所有成员（变量和函数）都未加static，所有都具有全局可见性，其他的源文件也能访问。如果加了static，那么其余源文件就不能访问了，利用这一特性，可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。</p>
<p>2、static还能保持变量内容的持久</p>
<p>对于函数而言，static的作用仅限于隐藏，对于变量，static还有两个作用，其一就是保持变量内容的持久。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化，事实上，全局变量和静态变量都存储在静态存储区。与全局变量不同的是，static可以控制变量的可见范围。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>;<span class="comment">//事实上此赋值语句从来没执行过,调试一进入函数，count=10</span></span><br><span class="line">	<span class="keyword">return</span> count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>3、static第三个作用则是默认初始化为0，事实上存储在静态存储区的变量都具有这样的特性，所有全局变量也能初始化为0. </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C++%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E8%99%9A%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C++%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E8%99%9A%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">C++深入分析虚函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-27 15:14:15" itemprop="dateCreated datePublished" datetime="2020-12-27T15:14:15+08:00">2020-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-22 22:19:10" itemprop="dateModified" datetime="2021-01-22T22:19:10+08:00">2021-01-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面探索了<a href="http://blog.csdn.net/wenqian1991/article/details/41047957" target="_blank" rel="noopener">C++对象的内存模型</a>，其中简单的涉及到了虚函数，作为C++实现其多态的一个重要机制，这里进一步探索下虚函数机制，以前也看过网络上关于虚函数机制的一些精彩的文章，但现在决定自己再分析这个虚函数机制以加深理解，看与自己动手探索还是有区别的。</p>
<p><strong><em>\</em>一、异质链表**</strong></p>
<p>1、“is-a” 原理</p>
<p>在公有派生方式下，对派生类的对象里的基类子对象的水平访问与基类单独生成的对象的访问是一样的。也就是说，我们完全可以把public 继承方式的派生类的对象当做基类的一个对象来使用。反过来则不行。这就是“is-a”原理</p>
<p>在公有派生方式下，基于“is-a”原理，我们可以得出以下几点：</p>
<ol>
<li>一个派生类的对象可以赋给基类对象；</li>
<li>派生类对象可以初始化基类对象；</li>
<li>派生类的对象可以初始化基类的引用；</li>
<li>派生类的对象的地址可以赋给指向基类对象的指针。</li>
</ol>
<p>前面三条都是一个性质，派生类对象赋给基类对象的时候，都是调用基类的赋值构造函数，这样赋值的时候，只会将派生类对象中继承的基类成员赋值给基类对象成员，不会发生内存越界的情况。下面是一段截取的反汇编代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">60</span>: 	base_obj = derived_obj;</span><br><span class="line"><span class="number">00</span>DD442C  lea         eax,[derived_obj]  </span><br><span class="line"><span class="number">00</span>DD442F  push        eax  </span><br><span class="line"><span class="number">00</span>DD4430  lea         ecx,[base_obj]  </span><br><span class="line"><span class="number">00</span>DD4433  call        Base::<span class="keyword">operator</span>= (<span class="number">0</span>DD16AEh)</span><br></pre></td></tr></table></figure>

<p>最重要的是第四条，对于这个基类的不同派生类的对象，我们可以使用指向基类的指针把它们（派生类对象）穿成一个链表，这个链表对于我们实现C++的多态性有很大的价值，被称之为异质链表。</p>
<p>   <img src="/2020/12/27/C++%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E8%99%9A%E5%87%BD%E6%95%B0/20141122122521379" alt="img"></p>
<p>通过基类指针将这个基类的不同子对象串联起来。一个充分必要条件就是，这几个子类都有一个公共的基类，且都与这个基类有“is-a”关系。</p>
<p>对于这我们可以这么理解：派生类的对象所占的存储空间要比基类的对象大，因为派生类继承了基类非私有成员函数和数据，再加上本身的成员数据，实例化的对象自然会比基类对象大，自然，派生类指针的寻址空间要比基类指针的寻址空间大。但由于对象的头部分是一样的，所以即使有超出基类指针所寻址的部分也能根据偏移量正确寻址，相反，如果派生类指针指向基类对象，则会把一部分不属于该基类对象的内存也包括进来，那么当派生类指针指向基类对象来使用派生类的函数的时候可能会发生严重的错误。</p>
<p><strong><em>\</em>二、虚函数机制前奏**</strong></p>
<p>1、静态联编</p>
<p>计算机应用程序对它的变量、对象的访问，以及对函数的调用实际上都是通过地址，而不是像源程序那样通过名字。程序中的变量名、对象名和函数名都是在编译的时候被编译器变换成了地址，这个地址是逻辑地址，在程序运行的时候再转换为物理地址。总之，程序最终运行的时候对各类变量的访问都是通过地址。</p>
<p>函数名字也会被编译器转换为地址，这样对这个函数的调用，就编译成了去执行这个地址里的指令（汇编语言更清晰的表达出这点），函数的调用关系就变成了对某个地址的连接。而这是编译器在编译时做成的连接，在运行的时候是不可能改变的，这种连接我们称之为静态联编。</p>
<p>2、动态联编</p>
<p>先说下多态。多态性实质就是“一个接口，多种方法”。就是基于“is-a”原理，把不同子类的对象都当做父类来看待，可以屏蔽不同子类对象之间的差异，写出通用的代码，增加代码的适用性。赋值之后，父对象就可以根据赋值给它的子对象的特性以不同的方式运作。多态最常用的就是上面“is-a”原理引申出来的第四点。通过基类对象指针去操作子类对象的函数，来实现多态性。当然基类中也要定义这个函数接口。这样的话问题就来了，像第一点所说的，函数名在编译的时候就被换算成了一个固定地址，那么当基类指针去操作同一个函数接口时，最终都会跳转到同一个地址，那就无法实现多态了。针对这个问题就引入了虚函数机制，虚函数机制是基于动态联编的，动态联编是相对静态联编来的，它的函数名对应的地址是在运行的时候才决定的，在编译时并不能确定各个函数的对应地址（这里是说编译器不确定，函数本身地址肯定是定了的），只有在运行的时候根据是隶属于哪个对象才去调用这个对象的同名函数。</p>
<p>默认状态下都是静态联编，为了引入动态联编，我们引入了虚函数机制，在对应的函数名前加上 virtual 关键字即可。然后剩下的工作就交给编译器去完成了，编译器才是实现多态性的真正幕后英雄。</p>
<p><strong>三、虚函数机制</strong></p>
<p>有了前面的异质链表和动态联编，我们开始解开虚函数的神秘面纱。</p>
<p>1、单一继承</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	Base(<span class="keyword">int</span> i = <span class="number">1</span>) :a(i)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	Derived(<span class="keyword">int</span> j = <span class="number">2</span>) :Base(j), b(j)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span><span class="comment">//覆盖的情况</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base* ptr = <span class="keyword">new</span> Derived(<span class="number">10</span>);</span><br><span class="line">	ptr-&gt;fun_a();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出就不用多说了。 </p>
<p>我们看看 ptr 指向的对象的布局：</p>
<p><img src="/2020/12/27/C++%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E8%99%9A%E5%87%BD%E6%95%B0/20141122215133793" alt="img"></p>
<p>看到虚表指针指向的虚函数表中第一个位置存放的是子类对象的函数，显然子类的虚函数已经覆盖了父类的同名同类型虚函数。</p>
<p>父类和子类都定义有虚函数，且存在不同类型的，情况就会如下所示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	Base(<span class="keyword">int</span> i = <span class="number">1</span>) :a(i)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_b</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::b"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	Derived(<span class="keyword">int</span> j = <span class="number">2</span>) :Base(j), b(j)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_c</span><span class="params">()</span><span class="comment">//无覆盖</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::c"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun_b</span><span class="params">()</span><span class="comment">//覆盖</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::b"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base* ptr = <span class="keyword">new</span> Derived(<span class="number">10</span>);</span><br><span class="line">	fun pFun = <span class="literal">NULL</span>;</span><br><span class="line">	pFun = (fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(ptr)+<span class="number">2</span>);</span><br><span class="line">	pFun();</span><br><span class="line">	<span class="comment">//ptr-&gt;fun_a();</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有意思的是调试的时候，Visual Studio 窗口中居然没有显示虚函数表的第三个函数指针，所以上面额外测试了一下。子类实际的虚表如下：</p>
<p>虚函数表：虚函数指针都在位于同一个函数指针数组中，很容易寻址到。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  Derived::$vftable@:</span><br><span class="line">1&gt;  	| &amp;Derived_meta</span><br><span class="line">1&gt;  	|  0</span><br><span class="line">1&gt;   0	| &amp;Base::fun_a </span><br><span class="line">1&gt;   1	| &amp;Derived::fun_b </span><br><span class="line">1&gt;   2	| &amp;Derived::fun_c</span><br></pre></td></tr></table></figure>

<p>可以得出的是， 没有覆盖的情况下，基类的虚函数指针放在虚表的前面，然后再是派生类的虚函数指针，其中覆盖的放在自身的没有不覆盖基类的前面。多个覆盖自然就是按顺序来。<br>上面派生类只会有一张虚函数表，基类和派生类的虚函数指针都放置在其中。<br>那么虚函数的调用过程是怎么样的呢？这里修改了上面的程序，把基类的 fun_b() 函数退化为一般函数，然后分别调用一个虚函数和这个一般函数，看看它们的反汇编代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">66</span>: 	ptr-&gt;fun_a();</span><br><span class="line"><span class="number">00405998</span>  mov         eax,dword ptr [ptr]  </span><br><span class="line"><span class="number">0040599B</span>  mov         edx,dword ptr [eax]  </span><br><span class="line"><span class="number">0040599</span>D  mov         esi,esp  </span><br><span class="line"><span class="number">0040599F</span>  mov         ecx,dword ptr [ptr]  </span><br><span class="line"><span class="number">004059</span>A2  mov         eax,dword ptr [edx]  </span><br><span class="line"><span class="number">004059</span>A4  call        eax  </span><br><span class="line"><span class="number">004059</span>A6  cmp         esi,esp  </span><br><span class="line"><span class="number">004059</span>A8  call        __RTC_CheckEsp (<span class="number">0401343</span>h)  </span><br><span class="line">    <span class="number">67</span>: 	ptr-&gt;fun_b();</span><br><span class="line"><span class="number">004059</span>AD  mov         ecx,dword ptr [ptr]  </span><br><span class="line"><span class="number">004059B</span>0  <span class="function">call        <span class="title">Base::fun_b</span> <span class="params">(<span class="number">04016F</span>Eh)</span></span></span><br></pre></td></tr></table></figure>

<p>上面fun_a() 是虚函数，fun_b() 是一般函数，通过汇编代码看看这两个函数的调用过程，可以看出一般函数是通过类直接调用，没什么特殊之处。重点看看虚函数的调用：</p>
<p>第二行代码（第一行汇编 mov  eax,dword ptr [ptr] ），取基类指针指向的数据（虚表指针）；后面的 mov  edx,dword ptr [eax]，定位到了虚函数表首位置；第六行 mov  eax,dword ptr [edx]，即得到对应位置（首位置）的虚函数指针（如果调用的虚函数指针不是首位置，那么这里会是edx+x），后面 call  eax 则是通过虚函数指针调用该虚函数。</p>
<p>总的说来，虚函数的调用是先定位到对应类的虚函数表，然后再去找对应位置的虚函数指针，继而调用该虚函数。</p>
<p>单一继承下，即只继承一个基类，那么派生类都只会产生一个虚函数表，<a href="http://blog.csdn.net/wenqian1991/article/details/41047957" target="_blank" rel="noopener">前面</a>已经说过了。然后所有的虚函数指针都放在这一张虚表中，派生类同类型虚函数会覆盖基类虚函数。虚函数机制下，编译器并不是简单的把基类指针类型编译成对应基类，而是按照这个基类指针去找到它指向的对象，换句话说不是看它的指针类型而是看它指向什么对象，对象下面有虚表指针，然后就是按照上面说的层层解引用调用对应的函数。</p>
<p>上面就是动态联编的过程，很显然效率要比静态联编低。</p>
<p>这虚函数指针的放置简单的说就是：先基类，然后派生类，派生类有覆盖的则直接对应覆盖。</p>
<p>2、多重继承</p>
<p>前面博文说到，多重继承（非虚拟继承）的情况下，继承多少个含虚函数基类（自身带虚函数表），派生类中就会生成多少个虚函数表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	Base1(<span class="keyword">int</span> i = <span class="number">1</span>) :a(i)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::a"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	Base2(<span class="keyword">int</span> i = <span class="number">2</span>) :b(i)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_b</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::b"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	Child(<span class="keyword">int</span> i = <span class="number">3</span>) :Base1(i), Base2(i), c(i)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span><span class="comment">//覆盖基类Base1</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Child::a"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun_b</span><span class="params">()</span><span class="comment">//覆盖基类Base2</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Child::b"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_c</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"child"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Child <span class="title">c</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">	c.fun_a();<span class="comment">//静态联编</span></span><br><span class="line">	Base1 &amp;ptr = c;</span><br><span class="line">	ptr.fun_a();<span class="comment">//动态联编</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的派生类公共继承了两个含有虚表的基类，自然地派生类中会产生两张虚表。</p>
<p>在讨论虚函数表前，先看看main函数，这里分别用了两个不同的手法调用函数 fun_a，第一个是静态联编，直接通过对象的名字来调用该对象的虚函数，无需额外的去定位对象了，而后面的动态联编，则要通过引用或指针先找到对应的对象，再去调用该对象的虚函数。</p>
<p>派生类中的虚函数表：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  Child::$vftable@Base1@:</span><br><span class="line">1&gt; | &amp;Child_meta</span><br><span class="line">1&gt; | 0</span><br><span class="line">1&gt;   0 | &amp;Child::fun_a</span><br><span class="line">1&gt;   1 | &amp;Child::fun_c</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;  Child::$vftable@Base2@:</span><br><span class="line">1&gt; | -8</span><br><span class="line">1&gt;   0 | &amp;Child::fun_b</span><br></pre></td></tr></table></figure>

<p>这样 当不同基类类型的指针指向同一个派生类对象时，都能够调用到实际的函数。改一下main函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Child <span class="title">c</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">	Base1 &amp;ptr1 = c;</span><br><span class="line">	ptr1.fun_a();</span><br><span class="line">	Base2 &amp;ptr2 = c;</span><br><span class="line">	ptr2.fun_b();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面两次调用的局部汇编code：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">77</span>: 	Base1 &amp;ptr1 = c;</span><br><span class="line"><span class="number">00</span>AA5E02  lea         eax,[c]  </span><br><span class="line"><span class="number">00</span>AA5E05  mov         dword ptr [ptr1],eax  </span><br><span class="line">    <span class="number">78</span>: 	ptr1.fun_a();<span class="comment">//动态联编</span></span><br><span class="line"><span class="number">00</span>AA5E08  mov         eax,dword ptr [ptr1]  </span><br><span class="line"><span class="number">00</span>AA5E0B  mov         edx,dword ptr [eax]  </span><br><span class="line"><span class="number">00</span>AA5E0D  mov         esi,esp  </span><br><span class="line"><span class="number">00</span>AA5E0F  mov         ecx,dword ptr [ptr1]  </span><br><span class="line"><span class="number">00</span>AA5E12  mov         eax,dword ptr [edx]  </span><br><span class="line"><span class="number">00</span>AA5E14  call        eax  </span><br><span class="line">    <span class="number">80</span>: 	Base2 &amp;ptr2 = c;</span><br><span class="line"><span class="number">00</span>AA5E1D  lea         eax,[c]  </span><br><span class="line"><span class="number">00</span>AA5E20  test        eax,eax  </span><br><span class="line"><span class="number">00</span>AA5E22  je          main+<span class="number">62</span>h (<span class="number">0</span>AA5E32h)  </span><br><span class="line"><span class="number">00</span>AA5E24  lea         ecx,[c]  </span><br><span class="line"><span class="number">00</span>AA5E27  add         ecx,<span class="number">8</span>  <span class="comment">//指针位置调整</span></span><br><span class="line"><span class="number">00</span>AA5E2A  mov         dword ptr [ebp<span class="number">-0F</span>Ch],ecx  </span><br><span class="line"><span class="number">00</span>AA5E30  jmp         main+<span class="number">6</span>Ch (<span class="number">0</span>AA5E3Ch)  </span><br><span class="line"><span class="number">00</span>AA5E32  mov         dword ptr [ebp<span class="number">-0F</span>Ch],<span class="number">0</span>  </span><br><span class="line"><span class="number">00</span>AA5E3C  mov         edx,dword ptr [ebp<span class="number">-0F</span>Ch]  </span><br><span class="line"><span class="number">00</span>AA5E42  mov         dword ptr [ptr2],edx  </span><br><span class="line">    <span class="number">81</span>: 	ptr2.fun_b();</span><br><span class="line"><span class="number">00</span>AA5E45  mov         eax,dword ptr [ptr2]  </span><br><span class="line"><span class="number">00</span>AA5E48  mov         edx,dword ptr [eax]  </span><br><span class="line">    <span class="number">81</span>: 	ptr2.fun_b();</span><br><span class="line"><span class="number">00</span>AA5E4A  mov         esi,esp  </span><br><span class="line"><span class="number">00</span>AA5E4C  mov         ecx,dword ptr [ptr2]  </span><br><span class="line"><span class="number">00</span>AA5E4F  mov         eax,dword ptr [edx]  </span><br><span class="line"><span class="number">00</span>AA5E51  call        eax</span><br></pre></td></tr></table></figure>

<p>后面调用的指针位置调整，就是根据由哪个基类指针指向来调整的（继承的基类在派生类中的位置）。这样不管继承多少个带虚表的基类，最终都能准确的调用到对应的虚函数。</p>
<p>也可以看出派生类中的两张虚表指针并不是全部在内存的首位置，而是等继承的第一个基类“放置”后再处理第二个。。<br>上面这一切都是编译器的功劳，我们只是通过基类指针简单的调用虚函数，然后内部的各类转移都是编译器的功劳。</p>
<p><strong>号外：</strong>构造函数，静态函数，内联函数，普通函数(非成员函数)、友元函数不能作为虚函数，成员模板函数也不能：虚函数仅适用于有继承关系的类对象。</p>
<p>虚函数是基于虚函数表的（内存空间），构造函数如果是虚函数，调用时也需要根据虚表寻找，但是虚表的产生依赖于构造函数（看下面的虚表指针的初始化），不能本末倒置，另外构造函数不能被继承（重写），静态函数是属于 class 自己的，必须有实体，其也不能被继承，内联函数在编译时展开，跟虚函数完全不是一个调调，水火不容的关系，至于普通函数，友元函数等，这两者是类外函数，不能被继承。</p>
<p><strong><em>\</em>四、虚表指针的初始化**</strong></p>
<p>没有虚函数的类对象自然不会产生虚表指针，而有虚函数的类对象就会产生虚表指针，那么虚表指针是什么时候安插在对象中的呢？答案就是构造函数。</p>
<p>我们可以在构造child实例处设置断点，然后反汇编跟踪编译，进入child的构造函数下的Base1构造函数，我们会发现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">35</span>: 	Base1(<span class="keyword">int</span> i = <span class="number">1</span>) :a(i)&#123;&#125;</span><br><span class="line">…… <span class="comment">//debug初始化环境略</span></span><br><span class="line"><span class="number">0008383F</span>  pop         ecx  <span class="comment">//还原this指针</span></span><br><span class="line"><span class="number">00083840</span>  mov         dword ptr [<span class="keyword">this</span>],ecx  <span class="comment">//存储this指针  </span></span><br><span class="line"><span class="number">00083843</span>  mov         eax,dword ptr [<span class="keyword">this</span>]  <span class="comment">//取出this指针并保存在eax中</span></span><br><span class="line"></span><br><span class="line"><span class="number">00083846</span>  mov         dword ptr [eax],<span class="number">8</span>DCB0h  <span class="comment">//后面的8DCB0h实际是虚函数表的偏移地址，也就是虚表指针安插在对象的前面（this指针内容）</span></span><br><span class="line"><span class="number">0008384</span>C  mov         eax,dword ptr [<span class="keyword">this</span>]    <span class="comment">//返回对象</span></span><br></pre></td></tr></table></figure>

<p>可以看出， 虚表指针是通过编译器在构造函数内安插在对象的前面的。另外也可以看到虚表指针的初始化都是基于this指针的，只有成员函数才有this指针，这就是为什么虚函数必须作为成员函数是用的原因。 </p>
<p>在虚表指针的初始化过程中，对象执行了构造函数后，就得到了虚表指针，当其余代码访问这个对象虚函数时，会根据对象的首地址，取出对应的虚表函数，当函数被调用时，会间接访问虚表，得到对应的虚函数首地址，然后调用执行。说白了就是地址转移来转移去的。</p>
<p>这种通过虚表间接寻址的情况只有在使用对象的指针或引用来调用虚函数时候才会出现，当直接使用对象调用自身的虚函数时，无需查表访问。就是前面代码中的静态联编方式访问。</p>
<p><strong>五、多态性</strong></p>
<p>前面说了动态联编和虚函数机制，就不能不说说这个C++中很重要的一个特性：多态性</p>
<p>多态性，简单地说就是“一个接口，多种实现”，就是不同的对象对应同一消息产生不同行为。一般而言，用同一个接口函数，去执行不同的函数体。执行哪个函数体看关联的是哪个对象。</p>
<p>下面直接通过一个简单例子来演示这个多态性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Course</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Choose</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span> :</span><span class="keyword">public</span> Course</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Choose</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Choose a Computer course"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Literature</span> :</span><span class="keyword">public</span> Course</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Choose</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Choose a Literature course"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DigitalImage</span> :</span><span class="keyword">public</span> Course</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Choose</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Choose a DigitalImage course"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection</span><span class="params">(Course *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ptr-&gt;Choose();<span class="comment">//动态联编，对不同的对象发送同一消息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Computer ObjCom;</span><br><span class="line">	Literature ObjLit;</span><br><span class="line">	DigitalImage ObjDig;</span><br><span class="line">	selection(&amp;ObjCom);</span><br><span class="line">	selection(&amp;ObjLit);</span><br><span class="line">	selection(&amp;ObjDig);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序中不同的课程，通过同一个消息来选择，选择的结果却由课程对象自身决定。</p>
<p>虚函数机制是这个实现的内在基石。多态性是外在的现象。</p>
<p>最后再补充一下：C++明白指出，当 derived class 对象经由一个 base class 指针被删除，而该base class 带着一个 non-virtual 析构函数，其结果是未有定义——实际执行时通常发生的是对象的 derived 成分没被销毁，而其base 成分通常会被销毁，造成一个诡异的“局部销毁”的对象。</p>
<p>如下面一个例子，如果base class 是带着一个 non-virtual 析构函数，那么下面程序，派生类将不会进行析构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Base() &#123;&#125;;</span><br><span class="line">	<span class="keyword">virtual</span> <span class="comment">/*尝试注释掉这个关键字，看输出结果*/</span> ~Base() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Output from the destructor of class Base"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Do something in class Base"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Derived() &#123;&#125;;</span><br><span class="line">	~Derived() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Output from the destructor of class Derived"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Do something in class Derived"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base *pT = <span class="keyword">new</span> Derived;</span><br><span class="line">	pT-&gt;DoSomething();</span><br><span class="line">	<span class="keyword">delete</span> pT;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使 base class 中不含虚函数（注释掉Dosomgthing函数前的virtual），如果不定义虚析构函数，那么派生类的析构函数将不会被调用，所以如果base class 是作为基类使用，其析构函数也应该定义为虚函数。 </p>
<p>虚析构函数与虚函数是相伴而生的。Scott Meyers 在《Effective C++》中建议：如果class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数。理由很简单，我们希望所自动调用的析构函数，能够通过动态联编方式去调用所关联的实际对象的析构函数，而不是简单的指针的基类型对应的基类对象的析构函数。</p>
<p>盲目的添加虚函数会增大对象内存空间，我们的心得是：除了上述情况，如果该 class 作为基类使用，那么它就应该声明一个 virtual 析构函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/" class="post-title-link" itemprop="url">C++对象模型深入探索</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-27 15:11:15" itemprop="dateCreated datePublished" datetime="2020-12-27T15:11:15+08:00">2020-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-02 00:30:52" itemprop="dateModified" datetime="2021-02-02T00:30:52+08:00">2021-02-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面简单的论述过<a href="http://blog.csdn.net/wenqian1991/article/details/19205505" target="_blank" rel="noopener">C++对象模型</a>，总觉得不够深入，现近闲来进一步挖掘C++对象内存布局情况。主要讨论：单一继承，多重继承，钻石继承的有无虚函数以及虚拟继承的情况。贴出测试程序，并给出测试结论以及对应的类对象的大小计算。（PS：类对象的内存布局取决于编译器，这里的测试都是基于Visual Studio）</p>
<p><strong><em>\</em>单一的类对象**</strong></p>
<p>单一的类对象主要考虑有虚函数的情况，前面提及的博文已有介绍，类中定义了虚函数，就会产生一个虚函数表（实质就是一个函数指针数组，虚函数表不在类中，VS编译环境下，虚函数表位于常量段，虚表指针在类对象中），类每定义一个对象，便会在对象的最前面安插一个虚表指针，指向虚函数表，这样该类定义的对象会多出4 Byte（32位）。</p>
<p>可以在Visual Studio C++ 编译输出中直接看C++内存布局：工程项目——右键“属性”——配置属性——C/C++——命令行——其他选项里添加“/d1reportAllClassLayout ”，即可在编译输出中查看定义的类的内存布局，上面是输出所有定义的类对象，你可以搜索你自己定义的对象。（最好不要把名字定为base，不然一大堆）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//public:</span></span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"parent: fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*virtual void fun2()</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; "parent: fun2" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	parent obj_b;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面便是定义的类对象内存布局情况：vfptr 即表示虚表指针，static 成员不在类对象中</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class parent	size(8):</span><br><span class="line">1&gt;  	+---</span><br><span class="line">1&gt;   0	| &#123;vfptr&#125;</span><br><span class="line">1&gt;   4	| b</span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>



<p>如果类中不定义为虚函数，类对象的大小是4，如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class parent	size(4):</span><br><span class="line">1&gt;  	+---</span><br><span class="line">1&gt;   0	| b</span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>

<p>下面我们来考虑类继承的情况：</p>
<p><strong><em>\</em>单一继承**</strong></p>
<p><strong>*\</strong>*1）一般继承，无虚函数**<em>**</em></p>
<p><strong><em>\</em>1.1 继承一个基类**</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//public:</span></span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="comment">/*virtual void fun1()</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; "parent: fun1" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span>:</span> <span class="keyword">public</span> parent</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	child obj_b;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存布局：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class child	size(8):</span><br><span class="line">1&gt;  	+---</span><br><span class="line">1&gt;  	| +--- (base class parent)</span><br><span class="line">1&gt;   0	| | b</span><br><span class="line">1&gt;  	| +---</span><br><span class="line">1&gt;   4	| a</span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>

<p><strong><em>\</em>1.2 再考虑继承两个基类的情况**</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//public:</span></span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="comment">/*virtual void fun1()</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; "parent: fun1" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span>:</span> <span class="keyword">public</span> parent, <span class="keyword">public</span> parent1</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	child obj_b;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存布局：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class child	size(12):</span><br><span class="line">1&gt;  	+---</span><br><span class="line">1&gt;  	| +--- (base class parent)</span><br><span class="line">1&gt;   0	| | b</span><br><span class="line">1&gt;  	| +---</span><br><span class="line">1&gt;  	| +--- (base class parent1)</span><br><span class="line">1&gt;   4	| | c</span><br><span class="line">1&gt;  	| +---</span><br><span class="line">1&gt;   8	| a</span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>



<p>可以看出，一般继承无虚函数的情况下，派生类对象的内存布局为，先存放基类成员，再存放自身成员变量，其大小是简单的基类对象大小与自身成员大小之和。继承多个基类时，数据成员按继承声明的前后顺序放置。</p>
<p><strong><em>\</em>2）存在虚函数的情况**</strong></p>
<p><strong><em>\</em>2.1 基类定义虚函数，派生类本身无虚函数**</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//public:</span></span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"parent: fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span>:</span> <span class="keyword">public</span> parent<span class="comment">/*, public parent1*/</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	child obj_b;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存布局：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class child	size(12):</span><br><span class="line">1&gt;  	+---</span><br><span class="line">1&gt;  	| +--- (base class parent)</span><br><span class="line">1&gt;   0	| | &#123;vfptr&#125;</span><br><span class="line">1&gt;   4	| | b</span><br><span class="line">1&gt;  	| +---</span><br><span class="line">1&gt;   8	| a</span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>

<p>这个和上面的一般继承没啥区别，只不过是基类中定义了虚表指针，然后被派生类一股脑继承下来</p>
<p><strong><em>\</em>2.2 继承多个基类**</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"parent: fun1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"parent1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span>:</span> <span class="keyword">public</span> parent, <span class="keyword">public</span> parent1</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	child obj_b;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存布局</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class child	size(20):</span><br><span class="line">1&gt;  	+---</span><br><span class="line">1&gt;  	| +--- (base class parent)</span><br><span class="line">1&gt;   0	| | &#123;vfptr&#125;</span><br><span class="line">1&gt;   4	| | b</span><br><span class="line">1&gt;  	| +---</span><br><span class="line">1&gt;  	| +--- (base class parent1)</span><br><span class="line">1&gt;   8	| | &#123;vfptr&#125;</span><br><span class="line">1&gt;  12	| | c</span><br><span class="line">1&gt;  	| +---</span><br><span class="line">1&gt;  16	| a</span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>

<p>可以看到，继承多个基类也和无虚函数的情况一样，这里和继承单个的区别在于，派生类会产生两个虚表指针，后面我们会用程序验证，这两个虚表指针指向不同的两个虚函数表，可以顺便总结一下，非虚继承下，派生类继承几个含有虚函数的基类，那么派生类的实例对象就会有几个虚表指针。</p>
<p><strong><em>\</em>2.3 含虚函数情况**</strong></p>
<p><strong><em>\</em>1.基类无虚函数，派生类自身定义有虚函数**</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="comment">/*virtual void fun2()</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; "parent" &lt;&lt; endl</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span>:</span> <span class="keyword">public</span> parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"child"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存布局</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class child	size(12):</span><br><span class="line">1&gt;  	+---</span><br><span class="line">1&gt;   0	| &#123;vfptr&#125;</span><br><span class="line">1&gt;  	| +--- (base class parent)</span><br><span class="line">1&gt;   4	| | b</span><br><span class="line">1&gt;  	| +---</span><br><span class="line">1&gt;   8	| a</span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>

<p>可以看出，虚表指针总是放在对象的最前面，哪怕它是定义在派生类中。</p>
<p>基类有虚函数，派生类无虚函数，这个简单，不赘述了</p>
<p><strong>*\</strong>*2.当基类，派生类自身都定义虚函数的情况**<em>**</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"parent"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span>:</span> <span class="keyword">public</span> parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"child"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存布局：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class child	size(12):</span><br><span class="line">1&gt;  	+---</span><br><span class="line">1&gt;  	| +--- (base class parent)</span><br><span class="line">1&gt;   0	| | &#123;vfptr&#125;</span><br><span class="line">1&gt;   4	| | b</span><br><span class="line">1&gt;  	| +---</span><br><span class="line">1&gt;   8	| a</span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>

<p>这个一开始以为派生类也会占据一个自身虚表指针空间的，一看发现错了。细看布局，你会发现子类对象中虚表指针是继承的父类对象的，那么子类对象本身就不会产生虚函数指针么？答案是肯定的。那么子类对象的虚函数指针在哪呢？位于同一个虚函数表中。下面我们通过程序验证一下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	child obj;</span><br><span class="line">	fun pFun = <span class="literal">NULL</span>;</span><br><span class="line">	pFun = (fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;obj));</span><br><span class="line">	pFun();</span><br><span class="line">	pFun = (fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;obj)+<span class="number">1</span>);</span><br><span class="line">	pFun();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>output：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parent</span><br><span class="line">child</span><br></pre></td></tr></table></figure>

<p>上面的语句 pFun = (fun)<em>((int</em>)<em>(int</em>)(&amp;obj)); 前面说过虚函数表实质是一个函数指针数组，数组里面存放的是虚函数指针。对象中只存放指向虚函数表的虚表指针，并且位于对象的最前面，也就是说虚表指针与对象是同一个地址。回过头看这条程序：(int<em>)(&amp;obj) 对对象地址也就是虚表指针（虚函数表的地址）强制转换，(int</em>)<em>(int</em>)(&amp;obj) 解引用虚表指针，定位到了虚函数表（函数指针数组），这指向了数组（首位置）。(fun)<em>((int</em>)<em>(int</em>)(&amp;obj)) 有了前面这个就好理解了，取数组首元素得到虚函数指针，然后强制转换。</p>
<p>从上面的测试输出可以看出，这种情况下派生类对象中只有一个虚表指针，派生类的虚函数指针位于同一个虚函数表中，且位于基类虚函数指针的后面。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  child::$vftable@:</span><br><span class="line">1&gt;  	| &amp;child_meta</span><br><span class="line">1&gt;  	|  0</span><br><span class="line">1&gt;   0	| &amp;parent::fun2 </span><br><span class="line">1&gt;   1	| &amp;child::fun1</span><br></pre></td></tr></table></figure>

<p>如果派生类中的虚函数名为fun2，自然的就同名覆盖了基类的。</p>
<p><strong>*\</strong>*2.3 多重继承情况**<em>**</em></p>
<p><strong><em>\</em>1）继承多个基类**</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_p</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"parent"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">adopter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"adopter"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span> :</span> <span class="keyword">public</span> parent, <span class="keyword">public</span> adopter</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_c</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"child"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存布局：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class child	size(20):</span><br><span class="line">1&gt;  	+---</span><br><span class="line">1&gt;  	| +--- (base class parent)</span><br><span class="line">1&gt;   0	| | &#123;vfptr&#125;</span><br><span class="line">1&gt;   4	| | a</span><br><span class="line">1&gt;  	| +---</span><br><span class="line">1&gt;  	| +--- (base class adopter)</span><br><span class="line">1&gt;   8	| | &#123;vfptr&#125;</span><br><span class="line">1&gt;  12	| | b</span><br><span class="line">1&gt;  	| +---</span><br><span class="line">1&gt;  16	| c</span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>

<p>由于两个基类都有虚函数，这样继承下来，子类对象便会有两个虚表指针，也就是说子类会有两个虚函数表。子类对象中的虚函数指针是存放在继承的第一个父类的虚函数表中</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  child::$vftable@parent@:</span><br><span class="line">1&gt;  	| &amp;child_meta</span><br><span class="line">1&gt;  	|  0</span><br><span class="line">1&gt;   0	| &amp;parent::fun_p </span><br><span class="line">1&gt;   1	| &amp;child::fun_c </span><br><span class="line">1&gt;  </span><br><span class="line">1&gt;  child::$vftable@adopter@:</span><br><span class="line">1&gt;  	| -8</span><br><span class="line">1&gt;   0	| &amp;adopter::fun_a</span><br></pre></td></tr></table></figure>

<p>那如果父类中只有一个有虚函数呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="comment">/*virtual*/</span> <span class="function"><span class="keyword">void</span> <span class="title">fun_p</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"parent"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">adopter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"adopter"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span> :</span> <span class="keyword">public</span> parent, <span class="keyword">public</span> adopter</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_c</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"child"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内存布局</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>&gt;  <span class="function">class child	<span class="title">size</span><span class="params">(<span class="number">16</span>)</span>:</span></span><br><span class="line">1&gt;  	+---</span><br><span class="line"><span class="number">1</span>&gt;  	| +--- (base class adopter)</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>	| | &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">4</span>	| | b</span><br><span class="line"><span class="number">1</span>&gt;  	| +---</span><br><span class="line"><span class="number">1</span>&gt;  	| +--- (base class parent)</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">8</span>	| | a</span><br><span class="line"><span class="number">1</span>&gt;  	| +---</span><br><span class="line"><span class="number">1</span>&gt;  <span class="number">12</span>	| c</span><br><span class="line"><span class="number">1</span>&gt;  	+---</span><br></pre></td></tr></table></figure>

<p>这里故意不在第一个父类定义虚函数，看内存布局会发现，父类adopter处于子类对象的最前面，因为它定义有虚函数，Visual Studio 编译器保证了虚表指针位于对象最前面的原则，这样如果继承的多个父类均有虚函数，那么存放位置根据继承顺序来，如果有个没有定义虚函数，则不管继承的顺序，均按照虚函数优先原则来，有虚函数的放置在最前面。</p>
<p><strong>*\</strong>*2）累积继承**<em>**</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_p</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"parent"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span> :</span> <span class="keyword">public</span> parent</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_c</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"child"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">grandchild</span> :</span> <span class="keyword">public</span> child</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_g</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"grandchild"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	grandchild obj_b;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内存布局</span></span><br><span class="line"><span class="number">1</span>&gt;  <span class="function">class grandchild	<span class="title">size</span><span class="params">(<span class="number">16</span>)</span> :</span></span><br><span class="line">1&gt;  	+-- -</span><br><span class="line"><span class="number">1</span>&gt; | +-- - (base class child)</span><br><span class="line"><span class="number">1</span>&gt; | | +-- - (base class parent)</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span> | | | &#123;vfptr&#125;</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">4</span> | | | a</span><br><span class="line"><span class="number">1</span>&gt; | | +-- -</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">8</span> | | b</span><br><span class="line"><span class="number">1</span>&gt; | +-- -</span><br><span class="line"><span class="number">1</span>&gt;  <span class="number">12</span> | c</span><br><span class="line"><span class="number">1</span>&gt;  	+-- -</span><br><span class="line"></span><br><span class="line"><span class="comment">//虚函数表</span></span><br><span class="line"><span class="number">1</span>&gt;  grandchild::$vftable@:</span><br><span class="line"><span class="number">1</span>&gt; | &amp;grandchild_meta</span><br><span class="line"><span class="number">1</span>&gt; | <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span> | &amp;parent::fun_p</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">1</span> | &amp;child::fun_c</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">2</span> | &amp;grandchild::fun_g</span><br></pre></td></tr></table></figure>

<p>从上面看，以及综合前面基类中含有虚函数的情况可以看出，子类对象中的虚表指针取决于继承的定义有虚函数的父类的个数（非虚拟继承），当然如果父类没有虚函数那就取决于本身有没有虚函数了。如果上面的这个子类（应该叫孙类），再继承parent，那么它会多一个虚表指针。而子类若自身也定义虚函数，则它不会产生虚表指针（继承的父类有虚表指针的情况下），而是把它的虚函数指针放置在继承的父类的虚函数表中，这是出于利用虚函数实现多态的目的，这里我们主要讨论内存布局情况，虚函数继承与多态，后面再说。 </p>
<p>在介绍钻石型继承前，我们再考虑上面论述的其中几种情况的虚拟继承下的类对象的内存布局：</p>
<p><strong><em>\</em>虚拟继承（虚基类）**</strong></p>
<p>我们就以上面的这个累积继承为例并扩展，阐述一下虚拟继承是如何影响类对象内存布局的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_p</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"parent"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> parent</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_c</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"child"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">grandchild</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> child</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"grandchild"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一看内存布局，可不是发生了一点点的微秒变化</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class child	size(20):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   0	| &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   4	| &#123;vbptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   8	| b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+--- (virtual base parent)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  12	| &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  16	| a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  class grandchild	size(32):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   0	| &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   4	| &#123;vbptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   8	| c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+--- (virtual base parent)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  12	| &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  16	| a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+--- (virtual base child)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  20	| &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  24	| &#123;vbptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  28	| b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>

<p>先看类child，对比2.3.2，一般继承，基类派生类均含虚函数的情况（sizeof(child_obj) = 12），这里虚拟继承，瞬间多了8 Byte，</p>
<p>首先虚拟继承，子类对象中自然会多出一个虚基类指针vbptr，但虚表指针还是在对象的最前面，还有一个最大的改变就是子类会产生两个虚函数表，这样实例化的对象便会有两个虚表指针，这颠覆了前面得出的结论，不能简单的按继承的含虚函数的父类的个数来判定了。</p>
<p>这里阐述的情况是虚拟继承的情况，对于前面子类含虚表指针个数与含虚函数父类个数的关系限于非虚拟继承情况下。对于虚拟继承，可以看出，它是全盘继承某个子类。</p>
<p>可以看出，</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  child::$vftable@child@:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| &amp;child_meta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	|  0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   0	| &amp;child::fun_c </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  child::$vbtable@:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   0	| -4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   1	| 8 (childd(child+4)parent)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  child::$vftable@parent@:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| -12</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   0	| &amp;parent::fun_p</span><br></pre></td></tr></table></figure>

<p>中间是虚基类指针。上面两个虚表指针指向不同的两个虚函数表，我们可以通过程序验证一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	child obj;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	fun pFun = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pFun = (fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;obj));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pFun();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pFun = (fun)*((<span class="keyword">int</span>*)*((<span class="keyword">int</span>*)(&amp;obj)+<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pFun();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">child</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parent</span><br></pre></td></tr></table></figure>

<p>对于上面的指针，注意与前面提到的相区别：虚函数表的地址位移和对象内的地址位移。</p>
<p><strong>*\</strong>*3、钻石型继承**<em>**</em></p>
<p>所谓钻石型继承就是继承方式形如下面的“菱形”结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  A</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> / \</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">B   C</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> \ /</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  D</span><br></pre></td></tr></table></figure>

<p>下面演示这样一种情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class_A</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"a"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class_B</span> :</span> <span class="keyword">public</span> class_A</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun_b</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"b"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class_C</span> :</span> <span class="keyword">public</span> class_A</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun_c</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"c"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class_D</span> :</span> <span class="keyword">public</span> class_B, <span class="keyword">public</span> class_C</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> d;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun_d</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"d"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	class_D obj;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存布局如下</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class class_D	size(20):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| +--- (base class class_B)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| | +--- (base class class_A)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   0	| | | a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| | +---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   4	| | b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| +---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| +--- (base class class_C)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| | +--- (base class class_A)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   8	| | | a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| | +---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  12	| | c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| +---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  16	| d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>

<p>上面的程序有问题，从内存布局就可以看出，如果调用基类成员a，就会产生二义性，究竟是调用哪个，因为BC内部都继承有A的成员变量，最后的子类对象都有a的两份拷贝。这时候虚基类就横空出世了，前面有讲到虚拟继承。如果上面采用虚继承，那么最后的子类D的实例只会拥有一个，看下面</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class_A</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"a"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class_B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> class_A</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_b</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"b"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class_C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> class_A</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_c</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"c"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class_D</span> :</span> <span class="keyword">public</span> class_B, <span class="keyword">public</span> class_C</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> d;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_d</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"d"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	class_D obj;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看内存布局前，先分析下这个派生类class_D的实例会占用多少内存。按照前面总结的来，class_D 非虚继承两个含有虚函数的基类，那么其对象中便会有两个虚表指针（自身的虚函数指针就放在第一个虚函数表中），一股脑继承下来，并且自身不会产生虚表指针。可以直接看继承的class_B，虚继承A，那么class_B就会占用12 Bytes（虚表指针，虚基类指针以及int成员变量），同理 class_C也会占用12 Bytes（虚继承自身也会产生多余的虚表指针），再考虑共继承的A，本身会有虚表指针，然后成员变量会放在派生类的最后，A的成员只会在派生类D中存在一份拷贝（* bytes），这是虚基类的目的，避免二义性，然后class_D，由于是一般继承，自身就是int 型4 Byte。总的下来就是 12+12+8+4 = 36 Bytes。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class class_D	size(36):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| +--- (base class class_B)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   0	| | &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   4	| | &#123;vbptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   8	| | b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| +---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| +--- (base class class_C)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  12	| | &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  16	| | &#123;vbptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  20	| | c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| +---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  24	| d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+--- (virtual base class_A)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  28	| &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  32	| a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>

<p>如果把最后的class_D 也虚继承 B和C（两个都虚继承才行），那么最后的大小会是多少呢？虚继承首先会多出虚基类指针，然后自身也会多余产生一个虚表指针，那么会多出8Bytes，最后的大小就是44 Bytes，挺大的。<br>如果只是class_D 只是虚继承其中一个基类，好吧，表示已经凌乱了，在Visual Studio 下，虽然大小不会改变，不会多出虚表指针和虚基类指针，但是内存布局却改变了，</p>
<p>代码不贴了，直接看内存布局也会知道继承关系：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class class_D	size(36):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| +--- (base class class_C)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   0	| | &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   4	| | &#123;vbptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;   8	| | c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	| +---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  12	| d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+--- (virtual base class_A)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  16	| &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  20	| a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+--- (virtual base class_B)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  24	| &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  28	| &#123;vbptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  32	| b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt;  	+---</span><br></pre></td></tr></table></figure>

<p>结合前面的虚继承内存布局会发现，虚继承的东西都是放在后面。进一步深究就没意义了。</p>
<p>下面的程序告诉你，虚表指针不一定总是在对象的最前面：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class_A</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"a"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class_B</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> class_A</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun_b</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"b"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	class_B obj;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	fun pFun = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pFun = (fun)*((<span class="keyword">int</span>*)*((<span class="keyword">int</span>*)(&amp;obj)+<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pFun();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//内存布局</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&gt;  <span class="function">class class_B	<span class="title">size</span><span class="params">(<span class="number">16</span>)</span> :</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">1&gt;  	+-- -</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span> | &#123;vbptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">4</span> | b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&gt;  	+-- -</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&gt;  	+-- - (<span class="keyword">virtual</span> base class_A)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">8</span> | &#123;vfptr&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &gt; <span class="number">12</span> | a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &gt; +-- -</span><br></pre></td></tr></table></figure>



<p>前面啰嗦了一大片，我们可以得出以下几点：</p>
<ol>
<li>一般继承下（无虚函数），派生类的内存布局是先放基类成员，多个基类的按继承的顺序放置，最后是派生类自身的成员变量，函数和static变量不在类对象中。这样派生类对象的大小便是继承的基类的大小与自身变量的大小之和。</li>
<li>一般继承下（含虚函数），与上面的区别就是考虑虚表指针了。1、派生类只继承一个基类的情况下，不管是基类定义有虚函数还是派生类本身有虚函数，或是两个都有虚函数，最后的派生类对象中只会有一个虚表指针，并且是位于对象的最前面。两个都有虚函数的话，派生类的虚函数指针会存放在虚函数表（数组）中基类的虚函数指针的后面。2、当派生类继承多个基类时，如果多个基类中只有一个基类有虚函数，那就和前面的一样。多个基类都有虚函数，那么派生类对象就会产生多个虚表指针，虚表指针的个数与继承的含虚函数的基类的个数一样，派生类的虚函数指针放在第一个虚函数表中。</li>
<li>虚继承下（有虚函数），虚继承除了多出一个虚基类指针外，整个对象的内存布局也会随之改变。只要是虚继承，那么对应的派生类就会产生一个虚基类指针。另外只要是虚继承，那么基类会并且只会在派生类对象中存在一份拷贝，并且虚继承的东西是放在后面，哪怕它带有虚表指针（虚表指针不一定都是在对象的最前面）。进一步总结虚继承下的虚表指针情况，由于虚继承，派生类会存在基类的一份完整拷贝，这样派生类会产生多余的自身的虚表指针。</li>
</ol>
<p>计算类对象大小的时候，考虑以上几点便很容易得出。附带一句，上面的测试和总结都是基于Visual Studio 编译器。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">C++对象模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-27 15:07:17 / 修改时间：15:09:47" itemprop="dateCreated datePublished" datetime="2020-12-27T15:07:17+08:00">2020-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在C++对象模型中，Nonstatic data members 被配置于每一个 class object 之内，static data members 则被存放在个别 class object 之外。Static 和nonstatic function members 也被放在个别的class object 之外。存在 virtual function 时，每个class 会产生出一堆指向 virtual function 的指针，这些指针存放在一个表中，称之为虚函数表 virtual table。其实质就是一个函数指针数组，里面存放的是虚函数指针。每一个 class object 被安插一个虚表指针 vptr，指向相关的 virtual table，虚表指针通常置于 class object 的第一位置。另外，当子类虚继承父类时，子类对象中还会安插虚基类指针。注意此处 class 和 class object 的区别。如此说来一个类实例当中存放的就是 nonstatic data member，虚表指针（存在虚函数时或父类中含有虚函数），虚基类指针（虚拟继承时）。类继承时体积会变大，但在虚拟继承的情况下，基类永远只存在一个实例。</p>
<p>每一个 static data member 只有一个实例，存放在程序的 data segment 之中，视作是全局变量，static成员独立于任何对象而存在，不是类类型对象的组成部分，(非const类型)必须在类定义体的外部定义，不同于普通数据成员，static成员不是通过类构造函数进行初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>   //测试</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//virtual void prin()&#123; return ; &#125;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> x;  <span class="comment">//编译时不分配内存</span></span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::x = <span class="number">0</span>;  <span class="comment">//此时分配内存</span></span><br><span class="line">                  <span class="comment">//将此语句注释，程序出错</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; &amp;Base::x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类中 static成员在编译时并不分配内存，把它当成全局函数在类外进行初始化时才分配内存，在类外初始化时记得标上数据类型，这样编译器才知道应该为该 static成员分配多大内存。</p>
<p>当类中申明或定义虚函数时，该类会产生出一堆指向虚函数的指针，放在虚函数表中，该类中有多少个虚函数，那个对应的虚函数指针一次存放在该虚函数表中，当类被实例化时，每个实例 class object 会被安插一个虚函数表指针，一般是在 class object 的第一个位置(visual studio C++ 环境)，指向相关虚函数表。</p>
<p>换言之，每个含有虚函数的类有一张虚函数表vtbl，其中每一项是一个虚函数地址，指向虚表的指针 vptr 是被安插在类实例 class object 中，并且它指向对象所属的类的虚表，这样的话即使类中申明了多个虚函数，那么class object 中只会占用一个指针大小的空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>    //测试</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> ; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> ; &#125;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *str = <span class="string">"sunburn"</span>;      <span class="comment">//常量区</span></span><br><span class="line">	Base b;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt; (<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b) &lt;&lt; <span class="built_in">endl</span>;         <span class="comment">//虚函数表地址</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>*)*(<span class="keyword">int</span> *)*(<span class="keyword">int</span>*)(&amp;b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//虚函数表中的第一个函数地址</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>那么虚函数表究竟存放在哪呢？看上面程序的测试结果</p>
<p><img src="/2020/12/27/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/20140216210542500" alt="img"></p>
<p>可以看出，虚函数表的地址为：0x0089cc64，常量字符串的地址为：0x0089cc70.所以在visual studio C++中，虚函数表示存放在常量段，不同的编译器可能会有区别。</p>
<p>所以虚函数表是属于一个类所有对象的，不是某个对象特有的，是一个类所有对象共有的。</p>
<p>如果一个子类虚继承父类，即虚继承时，需要一个虚基类表来记录需继承关系，这样子类就会多一个虚基类表指针，不管多重还是单一继承，子类虚基类表指针只有一个。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> ; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> ; &#125;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span>&#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">	<span class="keyword">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DDriver</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> Driver<span class="comment">/*,virtual public Base*/</span> <span class="comment">//添加该注释代码不会影响sizeof(dd)的大小</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base b;</span><br><span class="line"></span><br><span class="line">	Driver d;</span><br><span class="line"></span><br><span class="line">	DDriver dd;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(b) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//8 = 4(int) + 4(虚表指针)</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(d) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//20 = 4(int) + 4(虚基类表指针) + 4(虚表指针) + 8(父类b)</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(dd) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//28 = 4(int) + 4(虚基类表指针) + 20(父类d)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类对象 d 中由于申明了一个与父类 Base 不同名的虚函数，所以在虚继承时会额外安插一个虚表指针，虚继承时会出现子类中持有多个虚函数表的情况，非虚继承时则不会。如果改为非虚继承，那么该类中就只会持有一个虚函数表，且没有虚基类指针，则 sizeof(d) = 12。</p>
<p>class DDriver 中如果再虚继承 Base，其实例对象的大小不变，也就是说虚继承情况下，基类只存在一个实例。</p>
<p>这样，<strong>一个类的对象的内存大小包括</strong>：</p>
<ul>
<li>所有非静态数据成员的大小</li>
<li>由内存对齐而填补的内存大小</li>
<li>为了支持 virtual，由内部产生的额外负担</li>
</ul>
<p>在VC中数据成员的布局为 [C++对象模型很大部分取决于编译器] ：</p>
<ol>
<li>vptr 部分(如果基类有，则继承基类的)</li>
<li>vbptr (虚继承)</li>
<li>基类成员 (如果继承)</li>
<li>自身数据成员</li>
<li>虚基类数据成员 (按声明顺序)</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">C语言指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-27 15:04:46 / 修改时间：15:06:11" itemprop="dateCreated datePublished" datetime="2020-12-27T15:04:46+08:00">2020-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>指针是一个特殊的变量，它里面存储的数值被解释成为内存（用户空间的虚拟内存）里的一个地址。</p>
<h3 id="一、指针的属性"><a href="#一、指针的属性" class="headerlink" title="一、指针的属性"></a><strong>一、指针的属性</strong></h3><p>一个指针包含四个方面的内容：<strong>指针的类型、指针所指向的类型、指针所指向的内存区、指针本身所占据的内存区。</strong></p>
<p>接下来就下面几个例子作说明：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、 <span class="built_in">int</span> *p;</span><br><span class="line"><span class="number">2</span>、 char *p；</span><br><span class="line"><span class="number">3</span>、 <span class="built_in">int</span> **p;</span><br><span class="line"><span class="number">4</span>、 <span class="built_in">int</span> (*p)[<span class="number">3</span>];</span><br><span class="line"><span class="number">5</span>、 <span class="built_in">int</span> *(*p)[<span class="number">4</span>];<span class="number">12345</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-1、指针的类型"><a href="#1-1、指针的类型" class="headerlink" title="1.1、指针的类型"></a><strong>1.1、指针的类型</strong></h4><p><strong>从语法的角度，只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型，即指针本身所具有的类型。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、 <span class="keyword">int</span> *p;        <span class="comment">//指针的类型是 int*</span></span><br><span class="line"><span class="number">2</span>、 <span class="keyword">char</span> *p；      <span class="comment">//指针的类型是  char*</span></span><br><span class="line"><span class="number">3</span>、 <span class="keyword">int</span> **p;       <span class="comment">//指针的类型是 int**</span></span><br><span class="line"><span class="number">4</span>、 <span class="keyword">int</span> (*p)[<span class="number">3</span>];   <span class="comment">//指针的类型是 int(*)[3]</span></span><br><span class="line"><span class="number">5</span>、 <span class="keyword">int</span> *(*p)[<span class="number">4</span>];  <span class="comment">//指针的类型是 int*(*)[3]12345</span></span><br></pre></td></tr></table></figure>

<p>然后有的人还是不知道怎么读…（后面再说）<br>插播：指针类型说明原则：<strong>从变量名处起，根据运算符优先级结合，一步一步分析。</strong></p>
<hr>
<h4 id="1-2、指针所指向的类型"><a href="#1-2、指针所指向的类型" class="headerlink" title="1.2、指针所指向的类型"></a><strong>1.2、指针所指向的类型</strong></h4><p><strong>通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么看待，简而言之，就是编译器会在内存中预留出多大的内存空间给这个指针</strong></p>
<p>从语法上，把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、 <span class="keyword">int</span> *p;        <span class="comment">//指针所指向的类型是 int</span></span><br><span class="line"><span class="number">2</span>、 <span class="keyword">char</span> *p；      <span class="comment">//指针所指向的类型是 char</span></span><br><span class="line"><span class="number">3</span>、 <span class="keyword">int</span> **p;       <span class="comment">//指针所指向的类型是 int*</span></span><br><span class="line"><span class="number">4</span>、 <span class="keyword">int</span> (*p)[<span class="number">3</span>];   <span class="comment">//指针所指向的类型是 int()[3]</span></span><br><span class="line"><span class="number">5</span>、 <span class="keyword">int</span> *(*p)[<span class="number">4</span>];  <span class="comment">//指针所指向的类型是 int*()[3]12345</span></span><br></pre></td></tr></table></figure>

<p>注意指针的类型和指针所指向的类型是两个概念，当然第一个其实没什么卵用，后面这个概念才是重点。</p>
<p>指针所指向的类型，表示了编译器为给这个指针所指向的区域分配了多大内存，这个概念是非常重要的，尤其在指针进行自增自减，以及加减常数运算的时候。<br>比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、 <span class="keyword">int</span> *p;        <span class="comment">//对于这个编译器为p所指向的类型预留了4个字节的空间(int类型)，p++的时候，</span></span><br><span class="line">                  <span class="comment">//是以4个字节为单位进行递增的（p+2，实则是偏移了2*4个字节的位置）</span></span><br><span class="line"><span class="number">2</span>、 <span class="keyword">char</span> *p；      <span class="comment">//以一个字节为单位（char占用1个字节）</span></span><br><span class="line"><span class="number">3</span>、 <span class="keyword">int</span> **p;       <span class="comment">//以4个字节为单位（int * 占用4个字节）</span></span><br><span class="line"><span class="number">4</span>、 <span class="keyword">int</span> (*p)[<span class="number">3</span>];   <span class="comment">//首先这是个数组指针（指向一个大小为3的数组，里面存放的是int类型），以12个字节为单位</span></span><br><span class="line"><span class="number">5</span>、 <span class="keyword">int</span> *(*p)[<span class="number">4</span>];  <span class="comment">//同样12个字节为单位，数组里面存放的是int*类型（4个字节）</span></span><br><span class="line"><span class="number">6</span>、 <span class="class"><span class="keyword">struct</span> <span class="title">str</span> *<span class="title">p</span>;</span> <span class="comment">//就是以sizeof(struct str)为单位了</span></span><br><span class="line"><span class="number">7</span>、 <span class="keyword">void</span> *p;       <span class="comment">//p++,就出错了，因为p所指向的类型是未定义的，即编译器不知道该为这个p所指向的类型分配多大空间     12345678</span></span><br></pre></td></tr></table></figure>

<p>这个概念非常重要，尤其在处理指针偏移量的时候，是以该指针所指向的数据类型为单位。</p>
<p>在32位系统下，任何指针变量所占用的空间都是4个字节（32位），包括void*，这样意味着每个指针变量的寻址空间是0~2^32-1（即4G的寻址空间）。</p>
<hr>
<h4 id="1-3、指针所指向的内存区域地址"><a href="#1-3、指针所指向的内存区域地址" class="headerlink" title="1.3、指针所指向的内存区域地址"></a><strong>1.3、指针所指向的内存区域地址</strong></h4><p><strong>指针的值就是指针本身存储的数值，这个值被编译器当做一个地址，指针所指向的内存区就是从指针的数值所表示的那个内存地址开始，长度为 sizeof(指针所指向的类型)的一片内存区。</strong></p>
<p>结合上面的第二点（指针所指向的类型），定义一个指针，我们就可以知道这个指针的有效区域，什么意思呢，看下面</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、 <span class="keyword">int</span> *p; <span class="comment">//p数值表示这块区域的首地址，哪个地方结束呢，（unsigned long）p+sizeof(int)1</span></span><br></pre></td></tr></table></figure>

<p>编译器会划定长度为 sizeof(指针所指向的类型)的一片内存区给这个指针变量，就是说用户程序使用这个指针变量（解引用*）时，编译器得知道p所表示的地址后面还有多少的空间数据是属于这个指针变量的，不多也不少。</p>
<hr>
<h4 id="1-4、指针本身所占据的内存区"><a href="#1-4、指针本身所占据的内存区" class="headerlink" title="1.4、指针本身所占据的内存区"></a><strong>1.4、指针本身所占据的内存区</strong></h4><p>前面说了，32位平台里，指针本身占据了4个字节的长度。<br><strong>一个指针本身占据有内存的话，那么这个指针是一个左值，否则就不是一个左值。</strong></p>
<p>用哲学的观点解释就是，世界是物质的，一个变量要作为左值，它得自身占据一个内存空间， 不然赋值给它的对象放在哪</p>
<p>如果一个表达式的结果是一个指针，那么这个表达式就叫指针表达式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> *pa;</span><br><span class="line">pa = &amp;a;<span class="comment">//&amp;a是一个指针，但是它不能作为左值，因为&amp;a它本身没有占据明确的内存123</span></span><br></pre></td></tr></table></figure>

<p>x=y;<br><strong>左值</strong>：在这个上下文环境中，编译器认为 x 的含义是 x 所代表的地址。这个地址只有编译器知道，在编译的时候确定，编译器在一个特定的区域保存这个地址，我们无需知道；<br><strong>右值</strong>，在这个上下文环境中，编译器认为 y 的含义是 y 所代表的地址里面的内容，这个内容是什么，只有到运行时才知道。</p>
<p>pa 与 &amp;a 在编译器看来是不一样的。编译器没有为 &amp;a 这个东东分配一块内存来存其地址，皮之不存毛将安附焉。</p>
<hr>
<h3 id="二、指针的算术运算"><a href="#二、指针的算术运算" class="headerlink" title="二、指针的算术运算"></a><strong>二、指针的算术运算</strong></h3><h4 id="2-1、指针的加减整数"><a href="#2-1、指针的加减整数" class="headerlink" title="2.1、指针的加减整数"></a><strong>2.1、指针的加减整数</strong></h4><p>指针可以加上或减去一个整数。但是它加减的单位不是单纯的整数，而是整数*sizeof(指针所指向的类型)，这个在前面的第2点讲述了，这里不赘述。</p>
<p>强制类型转换不会改变原有指针的类型</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="keyword">str</span>[<span class="number">20</span>] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="keyword">str</span>;  <span class="comment">//str的类型不变</span></span><br><span class="line">++p;  <span class="comment">// *p的值？123</span></span><br></pre></td></tr></table></figure>

<p>str的类型不变是什么意思呢，就是str++还是以sizeof(char)为单位进行运算的。</p>
<p>p 被初始化为指向整型变量str，我们知道str表示这个char数组的首地址，第二行语句就是把这个首地址赋值给p，进行强制转换的意图就是重新把str所指向的这块区域进行细分，原来是char类型，是以1个字节为单位划分的，现在是int类型，就成了以4个字节为单位划分的。</p>
<p><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/20160116184402036" alt="这里写图片描述"></p>
<p>所以++p之后，p就到了图中p+1的位置处，那么++p之后<em>p的值呢？<br>为方便说明，我们令 pt = p+1; 那么pt对应的区域就是 o wo这四个字符占据的空间，然后转换为asscii码就是（十六进制） 6F,20,77,6F, *pt的值还需要考虑你测试机器的大小端模式，X86是小端模式，所以 *pt = 0x6F77206F = 1870078063<br>\</em> ((char*)p) = ‘o’</p>
<p>对此，我们要清楚的认识到，<strong>指针的运算实值是地址的偏移，加往后偏移，减则往前面偏移</strong>， 所以 a[-1]是正确的，当然前提是这个位置是定义了的，而不是未映射区域。由此可以导出一点，指针的偏移操作不能超出范围（指针语义上没错，但一旦应用程序中这样使用，保你崩溃）</p>
<p>另外，<strong>两个指针不能进行加法运算</strong>，进行加法后，得到的结构指向一个不知所向的地方；<strong>两个指针可以进行减法操作，但必须类型相同</strong>，一般用于确定两个同类型指针变量之间的偏移量，linux内核数据结构 list 就是很好的应用这一特性的典范。</p>
<hr>
<h4 id="2-2、运算符-amp-和"><a href="#2-2、运算符-amp-和" class="headerlink" title="2.2、运算符&amp;和*"></a><strong>2.2、运算符&amp;和*</strong></h4><p>这里讨论是C语言中的指针，&amp; 不涉及到C++中的引用语义。<br>这里 &amp; 是取地址运算符，之前我们说过世界是物质的，在计算机内存中也不例外，一个有效变量它总会在内存的某个地方占据一个对应的空间大小，用于存放这个数值，而&amp;则是获取这个变量存放的地址。</p>
<p>&amp;a 的结果自然是一个指针，<em>习惯称之为解引用，</em>p就是获取p所指向的内容。</p>
<hr>
<h3 id="三、指针和数组"><a href="#三、指针和数组" class="headerlink" title="三、指针和数组"></a><strong>三、指针和数组</strong></h3><p><strong>指针是指针，数组是数组，两个是不一样的东西</strong></p>
<ul>
<li>指针就是指针，指针变量在32位系统下，永远占4个byte，其值为某一个内存的地址，指针可以指向任何地方，但不是任何地方你都能通过这个指针访问到。</li>
<li>数组就是数组，其大小与元素的类型和个数有关，定义数组时，必须指定其元素的类型和个数、数组可以存任何类型的数据，但不能存函数，可以存函数指针。</li>
</ul>
<p><strong>指针与数组之间的恩恩怨怨起源于，数组名表示数组首元素的地址</strong></p>
<blockquote>
<p>C语言中，当一维数组作为函数参数的时候，编译器总是把它解析成一个指向其首元素首地址的指针。（仅限于一维数组）</p>
</blockquote>
<p>这也是为什么无法向函数传递一个数组，而必须在传递的同时指定数组的长度。</p>
<p>看下面</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//a  表示数组首元素的地址，即a[0]的地址，*a = 1</span></span><br><span class="line"><span class="comment">//&amp;a 表示数组的首地址</span></span><br><span class="line"><span class="comment">//&amp;a[0] 也表示数组首元素的地址1234</span></span><br></pre></td></tr></table></figure>

<p>有趣的事，上面三个变量的数值是一样的，其数值就是数组的首位置地址。但是意义是不同的，用前面第一章第2点的说法（指针所指的数据类型）来解释就是，这三个变量代表的意义是不同的，这就表示它们自增之后的数值就不一样了。<br><strong>a+n 的值是 &amp;a[0] + n * sizeof(int)；</strong><br><strong>&amp;a+1 的值是 &amp;a[0] + 1 * sizeof(a) = &amp;a[0] + 1*5*sizeof(int);</strong></p>
<p>那么 a 和 &amp;a[0] 的区别在哪呢，这两个变量作为右值的话，是没有区别的，都是表示数组首元素的地址，而不是数组的地址。</p>
<p>但是，a 不能作为左值，编译器没有为数组a分配一块内存来存其地址，另外我们只能访问数组的某个元素而无法把数组当一个总体进行访问。</p>
<p>因为数组名表示该数组首元素的地址，所以我们可以用指针获取这个地址值，然后增加偏移量来读取数组元素</p>
<p>就一维数组和一级指针而言，二者在一定程度上是等效的，根据上面的分析，很好理解应用。</p>
<hr>
<h4 id="二维数组与指针"><a href="#二维数组与指针" class="headerlink" title="二维数组与指针"></a><strong>二维数组与指针</strong></h4><p>看看二维数组，首先把内存看做是一个连续的一维大数组，二维只是我们为了方便处理把它意识形态上的划分为二维，其本质还是一维的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>];<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>上面声明了一个二维数组，三行四列，<br><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/20160116201704585" alt="这里写图片描述"></p>
<p>然后尝试用指针对这个二维数组进行元素访问。由上图可知，<strong>编译器总是将二维数组看成一个一维数组（更高维数也是一样的），而一维数组的每一个元素又都是一个数组。</strong><br>a[0]这个一维数组的三个元素分别为 a[0],a[1],a[2]，而这个a[0],a[1],a[2]又都是一个有四个元素的一维数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/20160116202758886" alt="这里写图片描述"></p>
<p>所以上面后面的a[0],a[1],a[2]的首地址分别为 &amp;a[0], &amp;a[0] + 1<em>sizeof(a[0]), &amp;a[0] + 2</em>sizeof(a[0]);</p>
<p>也就是说 a[i] 的首地址为 &amp;a[0] + i * sizeof(a[0]); 而后a[i] 中有是个int 类型的元素，其每个元素的首地址分别为 &amp;a[i], &amp;a[i] + sizeof(int),&amp;a[i] + 2<em>sizeof(int),&amp;a[i] + 3</em>sizeof(int);<br>所以 a[i][j] 的首地址为 &amp;a[i]+j*sizeof(int) ，在把 &amp;a[i] 的值用 &amp;a[0] 表示：</p>
<p>a[i][j]元素的首地址为 &amp;a[0] + i * sizeof(a[0]) + j<em>sizeof(int) , &amp;a[0] 和 a 作为右值是一样的，所以上面就等于 a + i * sizeof(a[0]) + j</em>sizeof(int) ;其中的a[0]就是上图中的包含4个int变量的一维数组。</p>
<p>再回到第一章的第二点（指针所指向的数据类型），a[0] 是一个一维数组，a 等效于 &amp;a[0]，a+i 就等同于 &amp;a[0] + i + sizeof(a[0]) //把a[0]当做一个整体元素看待，这里 a+i 就表示了a这个二维数组中的第i个一维数组，<em>(a+i) 就是取这个二维数组的第i个元素，这个元素是个一维数组，所以取到的值是这个一维数组的首地址，上面后面 + j*sizeof(int)，就是这个一维数组偏移 j*sizeof(int) 个字节位置，等效于</em> (a+i)+j，定位到了这个一维数组的第j个元素的首地址，所以再取这个元素值就是 * ( *(a+i)+j)。</p>
<p>所以，由此会衍生一个问题，就是二维数组的初始化声明的时候，第一个数字是可以不填写的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[][<span class="number">4</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;<span class="comment">//correct</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;<span class="comment">//error12</span></span><br></pre></td></tr></table></figure>

<p>原因相信你们都知道，看到第一个知道怎么划分，第二个声明呢，你会知道怎么划分么？3<em>4，3</em>5…</p>
<hr>
<h3 id="四、二级指针"><a href="#四、二级指针" class="headerlink" title="四、二级指针"></a><strong>四、二级指针</strong></h3><p>二级指针也是经常用的，比如函数传参，一级指针传参是为了修改其值，二级指针传值就是为了修改其一级指针，比如C语言实现链表结构，创建链表不带返回值时，就需要借助二级指针。</p>
<p>二级指针它终究是指针，它表示的也还是一个地址，只是这个地址里面的内容仍然是一个地址，对于一维数组需要 * 解引用一次，对于二维数组则需要 * 解引用两次。</p>
<hr>
<h4 id="二维数组和二级指针"><a href="#二维数组和二级指针" class="headerlink" title="二维数组和二级指针"></a><strong>二维数组和二级指针</strong></h4><p>首先，指针和数组是两个概念，一维数组和一级指针在一定程度上可以等效，因为，然后二维数组和二级指针就真没什么关系了。</p>
<p>事实上，我们可以利用一维数组与一级指针的某种等效关系，将两个“降维”处理再进行等效。</p>
<p>上一节说到，二维数组必须指定维数，必须指定后面的维数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[][<span class="number">4</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>] = a;<span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>看到“降维”了吧，p 是一个数组指针，指向一个数组，每个数组里面有4个int变量。<br>p 是一个数组指针，指向的是一个有4个 int 变量的数组，这里是{0,1,2,3} 四个元素，p+1 指向的数组里面的元素就是{4,5,6,7}</p>
<p>p+1 地址偏移了多少个字节，就看 p 这个指针指向的数据是什么类型的，这里是 一个存放四个 int 变量的数组，所以 p+1 偏移的字节数就是 4 * sizeof(int) bytes。<br><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/20160117125236102" alt="这里写图片描述"></p>
<p>那么回过头，可以不可以用 指针数组 替代呢？<br>回答这个问题前，我们先来了解下 数组指针 和 指针数组</p>
<hr>
<h3 id="五、复杂指针类型"><a href="#五、复杂指针类型" class="headerlink" title="五、复杂指针类型"></a><strong>五、复杂指针类型</strong></h3><h4 id="5-1、数组指针和指针数组"><a href="#5-1、数组指针和指针数组" class="headerlink" title="5.1、数组指针和指针数组"></a><strong>5.1、数组指针和指针数组</strong></h4><ul>
<li><strong>数组指针：首先它是一个指针，它指向一个数组。在32位系统下永远是占4个字节，至于它指向的数组占多少个字节，看声明。它是“指向数组的指针”的简称。</strong></li>
<li><strong>指针数组：首先他是一个数组，数组的元素都是指针，数组占多少字节由数组本身决定（指针本身占用的字节是固定的），它是“存储指针的数组”的简称。</strong></li>
</ul>
<p>到底如何判断是数组指针还是指针数组，以及后面的函数指针，函数指针数组等等更为复杂的指针类型，就涉及到<em>复杂指针的读法</em>了。<br>原则上：<strong>从变量名处起，根据运算符优先级结合，一步一步分析。</strong></p>
<p>这里先看数组指针和指针数组：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> *p1[<span class="number">10</span>];    <span class="comment">//A</span></span><br><span class="line"><span class="built_in">int</span> (*p2)[<span class="number">10</span>];  <span class="comment">//B12</span></span><br></pre></td></tr></table></figure>

<p>根据上面的元组，根据运算符优先级结合<br>对于A，[] 的优先级高于 * ，所以 p1 首先跟[] 结合，p1 是一个数组，这个数组存储的元素是什么类型的呢？ int<em>，所以 p1 是一个指针数组，且存放了10个这样的 int</em> 。<br>对于B，()的优先级高于[]，看()里面，* 与p2构成一个指针，所以p2首先是一个指针，再看外头的[]，这个指针指向一个数组，所以p2是一个数组指针，那么这个数组里面存放的数据类型是什么呢，int。</p>
<p><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/20160117131117792" alt="这里写图片描述"></p>
<p>从上面的分析步骤，我们看到一个指针也好看到一个数组也好，首先要有这么个概念：<strong>看到指针要分析它的四要素，其实主要就是第二个，即这个指针指向的数据类型是什么，看到数组要分析这个数组存放的数据类型是什么，看到函数要分析这个函数的参数和返回值是什么类型的。</strong></p>
<p>ok，再回到前面，我们得知，可以用数组指针代替一个二维数组，那么可否用指针数组来代替一个二维数组呢？</p>
<p>但是不行的，其实看了上面的指针数组和数组指针的内存布局，你就知道原因了，上图的第二个数组指针的内存布局和二维数组的内存布局是一样的，一个线性连续数组里面存放的都是int型变量，但是数组指针就不是了，里面存放的是 int*，数据类型都不一样了，你说能替代么？</p>
<p>那么很显然，<strong>二维数组也是不能通过二级指针替代的</strong>，二维数组需要明确知道第二维的维数(即第二个数字)，你用二级指针替代，编译器完全不知道内部内存的划分细节了，二级指针变量解引用一次后自增，编译器不知道该偏移多少字节位置。</p>
<hr>
<h4 id="5-2、函数指针"><a href="#5-2、函数指针" class="headerlink" title="5.2、函数指针"></a><strong>5.2、函数指针</strong></h4><p>函数指针顾名思义就是函数的指针，即指向一个函数的指针。<br>这个应用相当广泛，游览 linux kernel 的源码，随处可见，内核协议栈，VFS，文件操作函数等等充当各种接口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* (*fun1)(<span class="keyword">char</span> *p1, <span class="keyword">char</span> *p2);</span><br><span class="line"><span class="function"><span class="keyword">char</span>** <span class="title">fun2</span><span class="params">(<span class="keyword">char</span> *p1, <span class="keyword">char</span> *p2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fun3</span><span class="params">(<span class="keyword">char</span> *p1, <span class="keyword">char</span> *p2)</span></span>;<span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>根据上面的优先级结合原则，和另一原则，看到指针分析它指向数据类型，看到函数分析它的形参和返回值类型。</p>
<p>对于fun1，首先它是一个指针，从变量名处开始，()锁定优先级高，然后<em>与fun1结合，这个指针指向什么类型呢，看到后面有个()，说明这个指针指向一个函数，那麽这个函数的类型的，括号里面是函数形参，两个 char*</em>，返回值也是char<em>；<br>对于fun2，首先人家是一个函数（看优先级()高于 * ），不是指针类型，这个函数的返回值类型是char*</em>；<br>对于fun3，很普通的函数。</p>
<p>那么函数指针有何用处？最大的好处就是增加函数调用的灵活性，最常用于函数接口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment"> * read, write, poll, fsync, readv, writev can be called</span></span><br><span class="line"><span class="comment"> *   without the big kernel lock held in all filesystems.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">int</span> (*readdir) (struct file *, <span class="keyword">void</span> *, <span class="keyword">filldir_t</span>);</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> (*ioctl) (struct inode *, struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">    <span class="keyword">int</span> (*open) (struct inode *, struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*flush) (struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*release) (struct inode *, struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*fsync) (struct file *, struct dentry *, <span class="keyword">int</span> datasync);</span><br><span class="line">    <span class="keyword">int</span> (*fasync) (<span class="keyword">int</span>, struct file *, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*lock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*readv) (struct file *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*writev) (struct file *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">&#125;;<span class="number">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure>

<p>上面就是linux 内核中文件系统部分的源码，文件操作函数集，定义这个通用函数接口，编写内核驱动的时候，你可以自己实现对应的函数，然后把你的函数名赋值给上面的函数指针，这样就会调用你自己实现的函数了，这样就实现了，同样的函数接口可以通过调用不同的函数来实现不同的驱动。</p>
<hr>
<h4 id="5-3、函数指针数组"><a href="#5-3、函数指针数组" class="headerlink" title="5.3、函数指针数组"></a><strong>5.3、函数指针数组</strong></h4><p>首先它是一个数组，数组里面存放的是函数指针。<br>怎么定义一个函数指针数组？<br>层层封装，首先是一个数组 pf[3]，然后是指针数组 <em>pf[3]，再然后是函数指针数组 (</em>pf[3])()；ok 到了函数了，是什么形参什么返回值，个人需求了。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>* (*pf[<span class="number">3</span>])(<span class="built_in">int</span> *p);</span><br><span class="line"><span class="comment">//pf 是一个存放3个指针类型的数组，这个指针指向一个函数，这个函数的形参和返回值均是int* 类型12</span></span><br></pre></td></tr></table></figure>

<p>学过C++的一定知道，C++实现多态的虚函数表，实际上是一个函数指针数组。详见<a href="http://blog.csdn.net/wenqian1991/article/details/19205505" target="_blank" rel="noopener">C++对象模型</a></p>
<p>至于函数指针数组的指针，我们就不说了，举一反三，层层抽离、封装即可。</p>
<p>另外，函数名跟数组名是一个调调，都会被编译器解析为地址</p>
<hr>
<h4 id="5-4、复杂指针类型读法牛刀小试"><a href="#5-4、复杂指针类型读法牛刀小试" class="headerlink" title="5.4、复杂指针类型读法牛刀小试"></a><strong>5.4、复杂指针类型读法牛刀小试</strong></h4><h5 id="5-4-1-void-0"><a href="#5-4-1-void-0" class="headerlink" title="5.4.1 ( * (void(*) () )0 )();"></a><strong>5.4.1 ( * (void(*) () )0 )();</strong></h5><p>这是《C Traps and Pitfalls》这本经典书中的一个例子。怎么分析，读是层层剥离（优先级顺序），定义是层层封装（从右到左）</p>
<ol>
<li>void(*)()，这是一个函数指针，无参无返回值；</li>
<li>（void(*)()）0，这是将 0 强制转换为函数指针类型，0 是一个地址，就是说，这个函数保存在首地址为 0 的一段区域内（32平台下，这段区域长度是4个字节）；</li>
<li>（* （void(* ) ()）0），增加一个解引用符号 *，即取 0 地址开始的一段内存里面的内容，其内容就是保存在首地址为 0 的一段区域内的函数，直白点，内容就是一个函数；</li>
<li>( * (void(*) () )0 )()，函数调用。</li>
</ol>
<p>上面虽然没有看到习惯上的变量名，但是有 0 这个变量，常数也是变量啊</p>
<hr>
<h3 id="六、指针与结构体"><a href="#六、指针与结构体" class="headerlink" title="六、指针与结构体"></a><strong>六、指针与结构体</strong></h3><p>指针可以指向任何数据类型，自然也包括结构类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma pack(1)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> <span class="title">ss</span> = &#123;</span> <span class="number">20</span>, <span class="string">'w'</span>, <span class="number">40</span> &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> *<span class="title">pss</span> = &amp;<span class="title">ss</span>;</span></span><br><span class="line">    <span class="keyword">int</span> *ptr = (<span class="keyword">int</span> *) &amp;ss;<span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<p>上面的注释我就免了，如果看到这里，你还不知道，我只好说，你不适合走编程这条路。</p>
<p>我们都知道访问结构体成员的时候，我们都是这样的访问的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ss.a;</span><br><span class="line">pss-&gt;b;<span class="comment">//建议用这种，也最常用12</span></span><br></pre></td></tr></table></figure>

<p>那么后面我们可以不可以通过 ptr 指针来访问呢，答案是否定的，这是因为结构体成员对齐的原因。<br><strong>编译器在存放结构体对象的时候，一般会考虑字节对齐或双字节对齐等等，则需要在相邻两个非对齐成员（不同类型）之间补上若干个“填充字节”用于对齐。</strong><br>因为结构体是把不同个数据类型成员捆绑在一起，不像数组里面的元素都是同一种类型。</p>
<p>回到上面，为何不能用 ptr 指针访问？<br>首先你可以通过 <em>*ptr 获得第一个int 成员的值，</em> <em>ptr == 20；<br>第二个char成员呢，你可以这样获得 * (((char</em>)ptr)+1) ==’w’;<br>那么后面的成员b，你怎么通过 ptr 获得，由 ptr 偏移 sizeof(int) + sizeof(char) 个字节？你可以试试，但是我会告诉你得到的结果绝对不是40，除非你的编译器是对结构器不对齐的，或者你添加了 #pragma pack(1)</p>
<p><strong>看内存布局：</strong><br>默认对齐方式下：</p>
<p><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/20160117144211853" alt="这里写图片描述"></p>
<p>不对齐方式下（以1byte对齐），不注释#pragma pack(1)</p>
<p><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/20160117144345249" alt="这里写图片描述"></p>
<p>其余的不用看，直接看两种方式下，结构体中的成员的地址。</p>
<hr>
<h3 id="七、指针类型转换"><a href="#七、指针类型转换" class="headerlink" title="七、指针类型转换"></a><strong>七、指针类型转换</strong></h3><p>其实前面我们或多或少的讲到了指针类型转换，记住一个原则，你在应用指针类型转换的时候，你要清楚转换对象与被转换对象的内存布局，上面的指针与结构类型一节就涉及到了。</p>
<p><strong>强制类型转换之后，原来的指针的一切属性都没有被修改，转换后的指针，它所运算（指针加减）的单位变了。</strong></p>
<p>char* 强制转换为 int*，转换后加减的单位成了4个字节，但是原来的指针还是不变的。</p>
<p>指针类型转换，在linux 内核网络协议栈中尤为常见，而且那里还是结构体类型的强制转换，不过人家大神在写那些结构体的时候，设计的时候都是严格按照成员对齐方式的，即使从链路层抽离网络层的ip首部，之后还是可以正确访问到ip首部数据的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面代码来源于linux kernel 源码，以及博文中发送skb代码</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct iphdr *<span class="title">ip_hdr</span><span class="params">(<span class="keyword">const</span> struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (struct iphdr *)skb_network_header(skb);</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">    udph = (struct udphdr*)skb_push(skb, <span class="keyword">sizeof</span>(struct udphdr));</span><br><span class="line">    iph = (struct iphdr*)skb_push(skb, <span class="keyword">sizeof</span>(struct iphdr));</span><br><span class="line">    ethdr = (struct ethhdr*)skb_push(skb, <span class="keyword">sizeof</span>(struct ethhdr));<span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p>突然发现，linux kernel 源码真是一个学习C语言的好项目啊。</p>
<hr>
<h3 id="八、指针安全"><a href="#八、指针安全" class="headerlink" title="八、指针安全"></a><strong>八、指针安全</strong></h3><p>前面一到七章，从各个层面分析了C语言中指针的好处，这也是C语言风靡至今屹立不倒的一个重要原因，但技术总是一把双刃剑，在带来强大功能的同时，也会带来一些列安全问题。</p>
<p>正因为指针可以指向用户空间内存的任意位置，这就意味着，我们可以读取甚至修改用户空间中用户程序可以访问的任一内存。</p>
<p>这是比较恐怖的，万一你通过指针去修改的那块内存，恰恰是一个代码段，或者另一个线程空间，那么程序就会崩溃。</p>
<p>为什么说一个进程下的某一个线程崩溃了，就会导致进程崩溃？首先确定这个崩溃是由于内存访问造成的。因为线程没有自己独立的内存地址空间，一个进程下的所有线程都是共享进程下的内存地址空间的，在一个线程中把另外一个线程的栈空间写坏是再正常不过的事情了。因为一个线程都可以通过内存地址（指针）访问到其他线程的栈空间，所以指针数据的错误可以导致任何同地址空间内其他线程的崩溃，当然也可以导致进程崩溃。</p>
<p>所以编写程序，在使用指针时，程序员心里必须非常清楚：我的指针究竟指向了哪里，用指针访问数组的时候，注意不要越界。换言之，你要确保你用指针访问的内存区域是安全的，对它进行访问不会产生安全隐患，不要去访问未定义区域。</p>
<hr>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a><strong>结束语</strong></h3><p>至此，算是把C语言中的指针剖析的差不多了吧，本人做技术比较喜欢追溯内部细节和底层原理，知其然并知其所以然。</p>
<p>建议大家在学习C语言指针的时候，一定要手动编写程序逐个测试，做技术忌眼高手低。我个人初学（几年前了）的时候，比较喜欢调试，不是直接运行看结果，监视各个变量以及地址，再者就是通过反汇编看起汇编代码，熟悉内部原理。</p>
<p>visual studio 2013 这个 IDE 用于学习C和C++内部原理还是非常方便的，个人不打Windows和Linux的口水仗，但我还是喜欢在 linux下开发</p>
<p>阅读一些优秀的开源项目 linux kernel、STL（C++）等，在Windows下用SourceInsight看源码，然后在linux下开发，怪不得开发人员都要有两台电脑。</p>
<p>另外，由于 MarkDown 编辑器的原因，符号‘<em>’在该编辑器中是一个操作符，所以在可能在某些地方声明指针的时候，可能会出现</em> 被编辑器当作操作符处理了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/25/C++%E6%96%87%E4%BB%B61/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/25/C++%E6%96%87%E4%BB%B61/" class="post-title-link" itemprop="url">C++文件1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-25 22:05:04 / 修改时间：22:06:46" itemprop="dateCreated datePublished" datetime="2020-12-25T22:05:04+08:00">2020-12-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>基于C的文件操作<br>　　在ANSI C中，对文件的操作分为两种方式，即流式文件操作和I/O文件操作，下面就分别介绍之。</p>
<p>一、流式文件操作<br>这种方式的文件操作有一个重要的结构FILE，FILE在stdio.h中定义如下：</p>
<p><img src="/2020/12/25/C++%E6%96%87%E4%BB%B61/48304ba5e6f9fe08f3fa1abda7d326ab.png" alt="复制代码"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line"></span><br><span class="line">　　<span class="keyword">int</span> level;　　　　　　　　　　　<span class="comment">/* fill/empty level of buffer */</span> </span><br><span class="line"></span><br><span class="line">　　<span class="keyword">unsigned</span> flags; 　　　　　　 <span class="comment">/* File status flags */</span> </span><br><span class="line"></span><br><span class="line">　　<span class="keyword">char</span> fd;　　　　　　　　　　　 <span class="comment">/* File descriptor */</span> </span><br><span class="line"></span><br><span class="line">　　<span class="keyword">unsigned</span> <span class="keyword">char</span> hold;　　　　  <span class="comment">/* Ungetc char if no buffer */</span> </span><br><span class="line"></span><br><span class="line">　　<span class="keyword">int</span> bsize;　　　　　　　　　　 <span class="comment">/* Buffer size */</span> </span><br><span class="line"></span><br><span class="line">　　<span class="keyword">unsigned</span> <span class="keyword">char</span> _FAR *<span class="built_in">buffer</span>;　<span class="comment">/* Data transfer buffer */</span> </span><br><span class="line"></span><br><span class="line">　　<span class="keyword">unsigned</span> <span class="keyword">char</span> _FAR *curp;　　<span class="comment">/* Current active pointer */</span> </span><br><span class="line"></span><br><span class="line">　　<span class="keyword">unsigned</span> istemp;　　　　　　<span class="comment">/* Temporary file indicator */</span> </span><br><span class="line"></span><br><span class="line">　　short token;　　　　　　　　  <span class="comment">/* Used for validity checking */</span> </span><br><span class="line"></span><br><span class="line">&#125; FILE;　　　　　　　　　　　　  <span class="comment">/* This is the FILE object */</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/48304ba5e6f9fe08f3fa1abda7d326ab.png" alt="复制代码"></p>
<p>　　FILE这个结构包含了文件操作的基本属性，对文件的操作都要通过这个结构的指针来进行，此种文件操作常用的函数见下表 函数 功能 </p>
<p>　　fopen() 打开流<br>　　fclose() 关闭流<br>　　fputc() 写一个字符到流中<br>　　fgetc() 从流中读一个字符<br>　　fseek() 在流中定位到指定的字符<br>　　fputs() 写字符串到流<br>　　fgets() 从流中读一行或指定个字符<br>　　fprintf() 按格式输出到流<br>　　fscanf() 从流中按格式读取<br>　　feof() 到达文件尾时返回真值<br>　　ferror() 发生错误时返回其值<br>　　rewind() 复位文件定位器到文件开始处<br>　　remove() 删除文件<br>　　fread() 从流中读指定个数的字符<br>　　fwrite() 向流中写指定个数的字符<br>　　tmpfile() 生成一个临时文件流<br>　　tmpnam() 生成一个唯一的文件名</p>
<p>下面就介绍一下这些函数</p>
<p>1.fopen()<br>　　fopen的原型是：FILE *fopen(const char *filename,const char *mode)，fopen实现三个功能</p>
<p>　　为使用而打开一个流<br>　　把一个文件和此流相连接<br>　　给此流返回一个FILR指针<br>　　参数filename指向要打开的文件名，mode表示打开状态的字符串，其取值如下表</p>
<p>　　字符串 含义<br>　　“r” 以只读方式打开文件<br>　　“w” 以只写方式打开文件<br>　　“a” 以追加方式打开文件<br>　　“r+” 以读/写方式打开文件，如无文件出错<br>　　“w+” 以读/写方式打开文件，如无文件生成新文件</p>
<p>　　一个文件可以以文本模式或二进制模式打开，这两种的区别是：在文本模式中回车被当成一个字符’/n’，而二进制模式认为它是两个字符0x0D,0x0A；如果在文件中读到0x1B，文本模式会认为这是文件结束符，也就是二进制模型不会对文件进行处理，而文本方式会按一定的方式对数据作相应的转换。</p>
<p>　　系统默认的是以文本模式打开，可以修改全部变量_fmode的值来修改这个设置，例如_fmode=O_TEXT；就设置默认打开方式为文本模式；而_fmode=O_BINARY；则设置默认打开方式是二进制模式。</p>
<p>　　我们也可以在模式字符串中指定打开的模式，如”rb”表示以二进制模式打开只读文件，”w+t”或”wt+”表示以文本模式打开读/写文件。</p>
<p>　　此函数返回一个FILE指针，所以申明一个FILE指针后不用初始化，而是用fopen()来返回一个指针并与一个特定的文件相连，如果成败，返回NULL。</p>
<p>　　例:</p>
<p>　　FILE *fp;<br>　　if(fp=fopen(“123.456”,”wb”))<br>　　puts(“打开文件成功”);<br>　　else<br>　　puts(“打开文件成败”);</p>
<p>2.fclose()<br>　　fclose()的功能就是关闭用fopen()打开的文件，其原型是：int fclose(FILE *fp);如果成功，返回0,失败返回EOF。</p>
<p>　　在程序结束时一定要记得关闭打开的文件，不然可能会造成数据丢失的情况，我以前就经常犯这样的毛病。</p>
<p>　　例：fclose(fp);</p>
<p>3.fputc()<br>　　向流写一个字符，原型是int fputc(int c, FILE *stream); 成功返回这个字符,失败返回EOF。</p>
<p>　　例：fputc(‘X’,fp);</p>
<p>4.fgetc()<br>　　从流中读一个字符，原型是int fputc(FILE *stream); 成功返回这个字符,失败返回EOF。</p>
<p>　　例：char ch1=fgetc(fp);</p>
<p>\5. fseek()<br>　　此函数一般用于二进制模式打开的文件中，功能是定位到流中指定的位置，原型是int fseek(FILE *stream, long offset, int whence);如果成功返回0，参数offset是移动的字符数，whence是移动的基准，取值是</p>
<p>　　符号常量 值 基准位置<br>　　SEEK_SET 0 文件开头<br>　　SEEK_CUR 1 当前读写的位置<br>　　SEEK_END 2 文件尾部</p>
<p>　　例：fseek(fp,1234L,SEEK_CUR);//把读写位置从当前位置向后移动1234字节(L后缀表示长整数)</p>
<p>　　fseek(fp,0L,2);//把读写位置移动到文件尾</p>
<p>6.fputs()<br>　　写一个字符串到流中，原型int fputs(const char *s, FILE *stream);</p>
<p>　　例：fputs(“I Love You”,fp);</p>
<p>7.fgets()<br>　　从流中读一行或指定个字符，原型是char *fgets(char *s, int n, FILE *stream); 从流中读取n-1个字符，除非读完一行，参数s是来接收字符串，如果成功则返回s的指针，否则返回NULL。</p>
<p>　　例：如果一个文件的当前位置的文本如下</p>
<p>　　Love ,I Have</p>
<p>　　But ……..</p>
<p>　　如果用</p>
<p>　　fgets(str1,4,file1);</p>
<p>　　则执行后str1=”Lov”，读取了4-1=3个字符，而如果用</p>
<p>　　fgets(str1,23,file1);</p>
<p>　　则执行str=”Love ,I Have”，读取了一行(不包括行尾的’/n’)。</p>
<p>8.fprintf()<br>　　按格式输入到流，其原型是int fprintf(FILE *stream, const char *format[, argument, …]);其用法和printf()相同，不过不是写到控制台，而是写到流罢了</p>
<p>　　例：fprintf(fp,”%2d%s”,4,”Hahaha”);</p>
<p>9.fscanf()<br>　　从流中按格式读取，其原型是int fscanf(FILE *stream, const char *format[, address, …]);其用法和scanf()相同，不过不是从控制台读取，而是从流读取罢了。</p>
<p>　　例：fscanf(fp,”%d%d” ,&amp;x,&amp;y);</p>
<p>10.feof()<br>　　检测是否已到文件尾，是返回真，否则返回0，其原型是int feof(FILE *stream);</p>
<p>　　例：if(feof(fp))printf(“已到文件尾”);</p>
<p>11.ferror()<br>　　原型是int ferror(FILE *stream);返回流最近的错误代码，可用clearerr()来清除它，clearerr()的原型是void clearerr(FILE *stream);</p>
<p>　　例：printf(“%d”,ferror(fp));</p>
<p>12.rewind()<br>　　把当前的读写位置回到文件开始，原型是void rewind(FILE *stream);其实本函数相当于fseek(fp,0L,SEEK_SET);</p>
<p>　　例：rewind(fp);</p>
<p>13.remove()<br>　　删除文件，原型是int remove(const char *filename); 参数就是要删除的文件名，成功返回0。</p>
<p>　　例：remove(“c://io.sys”);</p>
<p>14.fread()<br>　　从流中读指定个数的字符，原型是size_t fread(void <em>ptr, size_t size, size_t n, FILE *stream);参数ptr是保存读取的数据，void</em>的指针可用任何类型的指针来替换，如char*、int *等等来替换；size是每块的字节数；n是读取的块数，如果成功，返回实际读取的块数(不是字节数)，本函数一般用于二进制模式打开的文件中。</p>
<p>　　例：</p>
<p>　　char x[4230];<br>　　FILE <em>file1=fopen(“c://msdos.sys”,”r”);<br>　　fread(x,200,12 ,file1);//共读取200</em>12=2400个字节</p>
<p>15.fwrite()<br>　　与fread对应，向流中写指定的数据，原型是size_t fwrite(const void <em>ptr, size_t size, size_t n, FILE *stream);参数ptr是要写入的数据指针，void</em>的指针可用任何类型的指针来替换，如char*、int *等等来替换；size是每块的字节数；n是要写的块数，如果成功，返回实际写入的块数(不是字节数)，本函数一般用于二进制模式打开的文件中。</p>
<p>　　例：</p>
<p>　　char x[]=”I Love You”;<br>　　fwire(x, 6,12,fp);//写入6*12=72字节</p>
<p>　　将把”I Love”写到流fp中12次，共72字节</p>
<p>16.tmpfile()<br>　　其原型是FILE *tmpfile(void); 生成一个临时文件，以”w+b”的模式打开，并返回这个临时流的指针，如果失败返回NULL。在程序结束时，这个文件会被自动删除。</p>
<p>　　例：FILE *fp=tmpfile();</p>
<p>17.tmpnam();<br>　　其原型为char *tmpnam(char *s); 生成一个唯一的文件名，其实tmpfile()就调用了此函数，参数s用来保存得到的文件名，并返回这个指针，如果失败，返回NULL。</p>
<p>borland c++ bulder的文件操作总结２</p>
<p>二、直接I/O文件操作<br>　　这是C提供的另一种文件操作，它是通过直接存/取文件来完成对文件的处理，而上篇所说流式文件操作是通过缓冲区来进行；流式文件操作是围绕一个FILE指针来进行，而此类文件操作是围绕一个文件的”句柄”来进行，什么是句柄呢？它是一个整数，是系统用来标识一个文件(在WINDOWS中，句柄的概念扩展到所有设备资源的标识)的唯一的记号。此类文件操作常用的函数如下表，这些函数及其所用的一些符号在io.h和fcntl.h中定义，在使用时要加入相应的头文件。</p>
<p>　　函数 说明<br>　　open() 打开一个文件并返回它的句柄<br>　　close() 关闭一个句柄<br>　　lseek() 定位到文件的指定位置<br>　　read() 块读文件<br>　　write() 块写文件<br>　　eof() 测试文件是否结束<br>　　filelength() 取得文件长度<br>　　rename() 重命名文件<br>　　chsize() 改变文件长度</p>
<p>下面就对这些函数一一说明：</p>
<p>1.open()<br>　　打开一个文件并返回它的句柄，如果失败，将返回一个小于0的值，原型是int open(const char *path, int access [, unsigned mode]); 参数path是要打开的文件名，access是打开的模式，mode是可选项。表示文件的属性，主要用于UNIX系统中，在DOS/WINDOWS这个参数没有意义。其中文件的打开模式如下表。</p>
<p>　　符号 含义 符号 含义 符号 含义<br>　　O_RDONLY 只读方式 O_WRONLY 只写方式 O_RDWR 读/写方式<br>　　O_NDELAY 用于UNIX系统 O_APPEND 追加方式 O_CREAT 如果文件不存在就创建<br>　　O_TRUNC 把文件长度截为0 O_EXCL 和O_CREAT连用，如果文件存在返回错误 O_BINARY 二进制方式<br>　　O_TEXT 文本方式</p>
<p>　　对于多个要求，可以用”|”运算符来连接，如O_APPEND|O_TEXT表示以文本模式和追加方式打开文件。</p>
<p>　　例：int handle=open(“c://msdos.sys”,O_BINARY|O_CREAT|O_WRITE)</p>
<p>2.close()<br>　　关闭一个句柄，原型是int close(int handle);如果成功返回0</p>
<p>　　例：close(handle)</p>
<p>3.lseek()<br>　　定位到指定的位置，原型是：long lseek(int handle, long offset, int fromwhere);参数offset是移动的量，fromwhere是移动的基准位置，取值和前面讲的fseek()一样，SEEK_SET：文件首部；SEEK_CUR：文件当前位置；SEEK_END：文件尾。此函数返回执行后文件新的存取位置。</p>
<p>　　例：</p>
<p>　　lseek(handle,-1234L,SEEK_CUR);//把存取位置从当前位置向前移动1234个字节。<br>　　x=lseek(hnd1,0L,SEEK_END);//把存取位置移动到文件尾，x=文件尾的位置即文件长度</p>
<p>4.read()<br>　　从文件读取一块，原型是int read(int handle, void *buf, unsigned len);参数buf保存读出的数据，len是读取的字节。函数返回实际读出的字节。</p>
<p>　　例：char x[200];read(hnd1,x,200);</p>
<p>5.write()<br>　　写一块数据到文件中，原型是int write(int handle, void *buf, unsigned len);参数的含义同read()，返回实际写入的字节。</p>
<p>　　例：char x[]=”I Love You”;write(handle,x,strlen(x));</p>
<p>6.eof()<br>　　类似feof()，测试文件是否结束，是返回1，否则返回0;原型是：int eof(int handle);</p>
<p>　　例：while(!eof(handle1)){……};</p>
<p>7.filelength()<br>　　返回文件长度，原型是long filelength(int handle);相当于lseek(handle,0L,SEEK_END)</p>
<p>　　例：long x=filelength(handle);</p>
<p>8.rename()<br>　　重命名文件，原型是int rename(const char *oldname, const char *newname); 参数oldname是旧文件名，newname是新文件名。成功返回0</p>
<p>　　例：rename(“c://config.sys”,”c://config.w40”);</p>
<p>9.chsize();<br>　　改变文件长度，原型是int chsize(int handle, long size);参数size表示文件新的长度，成功返回0，否则返回-1，如果指定的长度小于文件长度，则文件被截短；如果指定的长度大于文件长度，则在文件后面补’/0’。</p>
<p>　　例：chsize(handle,0x12345);</p>
<p>-——————————————————————————-</p>
<p>　　如果熟悉汇编可能会发现这种方式和汇编语言的DOS功能调用句柄式文件操作很像，比如open()就像DOS服务的3CH号功能调用，其实这种操作还有两种类型的函数就是直接用DOS功能来完成的，如_open()，_dos_open()等等。有兴趣可自已查询BCB的帮助。</p>
<p>　　同流式文件操作相同，这种也提供了Unicode字符操作的函数，如_wopen()等等，用于9X/NT下的宽字符编程，有兴趣可自已查询BCB的帮助。</p>
<p>　　另外，此种操作还有lock(),unlock(),locking()等用于多用户操作的函数，但在BCB中用得并不多，我就不介绍了，但如果要用C来写CGI，这些就必要的常识了，如果你有这方面的要求，那就得自已好好看帮助了。</p>
<p>　　到这里，我就把基于C的文件操作介绍完了，下一篇将介绍基于C++的文件操作，敬请期待。</p>
<p>在C++中，有一个stream这个类，所有的I/O都以这个”流”类为基础的，包括我们要认识的文件I/O，stream这个类有两个重要的运算符：</p>
<p>1、插入器(&lt;&lt;)<br>　　向流输出数据。比如说系统有一个默认的标准输出流(cout)，一般情况下就是指的显示器，所以，cout&lt;&lt;”Write Stdout”&lt;&lt;’/n’;就表示把字符串”Write Stdout”和换行字符(‘/n’)输出到标准输出流。</p>
<p>2、析取器(&gt;&gt;)<br>　　从流中输入数据。比如说系统有一个默认的标准输入流(cin)，一般情况下就是指的键盘，所以，cin&gt;&gt;x;就表示从标准输入流中读取一个指定类型(即变量x的类型)的数据。</p>
<p>在C++中，对文件的操作是通过stream的子类fstream(file stream)来实现的，所以，要用这种方式操作文件，就必须加入头文件fstream.h。下面就把此类的文件操作过程一一道来。</p>
<p>一、打开文件<br>　　在fstream类中，有一个成员函数open()，就是用来打开文件的，其原型是：</p>
<p>　　void open(const char* filename,int mode,int access);</p>
<p>　　参数：</p>
<p>　　filename：　　要打开的文件名<br>　　mode：　　　　要打开文件的方式<br>　　access：　　　打开文件的属性<br>　　打开文件的方式在类ios(是所有流式I/O类的基类)中定义，常用的值如下：</p>
<p>　　ios::app：　　　以追加的方式打开文件<br>　　ios::ate：　　　文件打开后定位到文件尾，ios:app就包含有此属性<br>　　ios::binary： 　以二进制方式打开文件，缺省的方式是文本方式。两种方式的区别见前文<br>　　ios::in：　　　 文件以输入方式打开<br>　　ios::out：　　　文件以输出方式打开<br>　　ios::nocreate： 不建立文件，所以文件不存在时打开失败　<br>　　ios::noreplace：不覆盖文件，所以打开文件时如果文件存在失败<br>　　ios::trunc：　　如果文件存在，把文件长度设为0<br>　　可以用”或”把以上属性连接起来，如ios::out|ios::binary</p>
<p>　　打开文件的属性取值是：</p>
<p>　　0：普通文件，打开访问<br>　　1：只读文件<br>　　2：隐含文件<br>　　4：系统文件<br>　　可以用”或”或者”+”把以上属性连接起来 ，如3或1|2就是以只读和隐含属性打开文件。</p>
<p>　　例如：以二进制输入方式打开文件c:/config.sys</p>
<p>　　fstream file1;<br>　　file1.open(“c://config.sys”,ios::binary|ios::in,0);</p>
<p>　　如果open函数只有文件名一个参数，则是以读/写普通文件打开，即：</p>
<p>　　file1.open(“c://config.sys”);&lt;=&gt;file1.open(“c://config.sys”,ios::in|ios::out,0);</p>
<p>　　另外，fstream还有和open()一样的构造函数，对于上例，在定义的时侯就可以打开文件了：</p>
<p>　　fstream file1(“c://config.sys”);</p>
<p>　　特别提出的是，fstream有两个子类：ifstream(input file stream)和ofstream(outpu file stream)，ifstream默认以输入方式打开文件，而ofstream默认以输出方式打开文件。</p>
<p>　　ifstream file2(“c://pdos.def”);//以输入方式打开文件<br>　　ofstream file3(“c://x.123”);//以输出方式打开文件</p>
<p>　　所以，在实际应用中，根据需要的不同，选择不同的类来定义：如果想以输入方式打开，就用ifstream来定义；如果想以输出方式打开，就用ofstream来定义；如果想以输入/输出方式来打开，就用fstream来定义。</p>
<p>二、关闭文件<br>　　打开的文件使用完成后一定要关闭，fstream提供了成员函数close()来完成此操作，如：file1.close();就把file1相连的文件关闭。</p>
<p>三、读写文件<br>　　读写文件分为文本文件和二进制文件的读取，对于文本文件的读取比较简单，用插入器和析取器就可以了；而对于二进制的读取就要复杂些，下要就详细的介绍这两种方式</p>
<p>　　1、文本文件的读写<br>　　文本文件的读写很简单：用插入器(&lt;&lt;)向文件输出；用析取器(&gt;&gt;)从文件输入。假设file1是以输入方式打开，file2以输出打开。示例如下：</p>
<p>　　file2&lt;&lt;”I Love You”;//向文件写入字符串”I Love You”<br>　　int i;<br>　　file1&gt;&gt;i;//从文件输入一个整数值。</p>
<p>　　这种方式还有一种简单的格式化能力，比如可以指定输出为16进制等等，具体的格式有以下一些</p>
<p>　　操纵符 功能 输入/输出<br>　　dec 格式化为十进制数值数据 输入和输出<br>　　endl 输出一个换行符并刷新此流 输出<br>　　ends 输出一个空字符 输出<br>　　hex 格式化为十六进制数值数据 输入和输出<br>　　oct 格式化为八进制数值数据 输入和输出<br>　　setpxecision(int p) 设置浮点数的精度位数 输出</p>
<p>　　比如要把123当作十六进制输出：file1&lt;<br>　　2、二进制文件的读写<br>　　①put()<br>　　put()函数向流写入一个字符，其原型是ofstream &amp;put(char ch)，使用也比较简单，如file1.put(‘c’);就是向流写一个字符’c’。</p>
<p>　　②get()<br>　　get()函数比较灵活，有3种常用的重载形式：</p>
<p>　　一种就是和put()对应的形式：ifstream &amp;get(char &amp;ch);功能是从流中读取一个字符，结果保存在引用ch中，如果到文件尾，返回空字符。如file2.get(x);表示从文件中读取一个字符，并把读取的字符保存在x中。</p>
<p>　　另一种重载形式的原型是： int get();这种形式是从流中返回一个字符，如果到达文件尾，返回EOF，如x=file2.get();和上例功能是一样的。</p>
<p>　　还有一种形式的原型是：ifstream &amp;get(char *buf,int num,char delim=’/n’)；这种形式把字符读入由 buf 指向的数组，直到读入了 num 个字符或遇到了由 delim 指定的字符，如果没使用 delim 这个参数，将使用缺省值换行符’/n’。例如：</p>
<p>　　file2.get(str1,127,’A’);//从文件中读取字符到字符串str1，当遇到字符’A’或读取了127个字符时终止。</p>
<p>　　③读写数据块<br>　　要读写二进制数据块，使用成员函数read()和write()成员函数，它们原型如下：</p>
<p>　　read(unsigned char *buf,int num);<br>　　write(const unsigned char *buf,int num);</p>
<p>　　read()从文件中读取 num 个字符到 buf 指向的缓存中，如果在还未读入 num 个字符时就到了文件尾，可以用成员函数 int gcount();来取得实际读取的字符数；而 write() 从buf 指向的缓存写 num 个字符到文件中，值得注意的是缓存的类型是 unsigned char *，有时可能需要类型转换。</p>
<p>　　例：</p>
<p>　　unsigned char str1[]=”I Love You”;<br>　　int n[5];<br>　　ifstream in(“xxx.xxx”);<br>　　ofstream out(“yyy.yyy”);<br>　　out.write(str1,strlen(str1));//把字符串str1全部写到yyy.yyy中<br>　　in.read((unsigned char*)n,sizeof(n));//从xxx.xxx中读取指定个整数，注意类型转换<br>　　in.close();out.close();</p>
<p>四、检测EOF<br>　　成员函数eof()用来检测是否到达文件尾，如果到达文件尾返回非0值，否则返回0。原型是int eof();</p>
<p>　　例：　　if(in.eof())ShowMessage(“已经到达文件尾！”);</p>
<p>五、文件定位<br>　　和C的文件操作方式不同的是，C++ I/O系统管理两个与一个文件相联系的指针。一个是读指针，它说明输入操作在文件中的位置；另一个是写指针，它下次写操作的位置。每次执行输入或输出时，相应的指针自动变化。所以，C++的文件定位分为读位置和写位置的定位，对应的成员函数是 seekg()和 seekp()，seekg()是设置读位置，seekp是设置写位置。它们最通用的形式如下：</p>
<p>　　istream &amp;seekg(streamoff offset,seek_dir origin);<br>　　ostream &amp;seekp(streamoff offset,seek_dir origin);</p>
<p>　　streamoff定义于 iostream.h 中，定义有偏移量 offset 所能取得的最大值，seek_dir 表示移动的基准位置，是一个有以下值的枚举：</p>
<p>　　ios::beg：　　文件开头<br>　　ios::cur：　　文件当前位置<br>　　ios::end：　　文件结尾<br>　　这两个函数一般用于二进制文件，因为文本文件会因为系统对字符的解释而可能与预想的值不同。</p>
<p>　　例：</p>
<p>　　file1.seekg(1234,ios::cur);//把文件的读指针从当前位置向后移1234个字节<br>　　file2.seekp(1234,ios::beg);//把文件的写指针从文件开头向后移1234个字节</p>
<p>-—————————————————————————————————————————————–</p>
<p>在BCB中也提供了文件操作的函数，这些函数的功能和前面所介绍的大致相同，但这类函数和BCB关系紧密，能使用BCB中的AnsiString等数据类型，在BCB中用这种方式的文件操作是最方便的，下面我就把这种文件操作详细介绍。</p>
<p>在BCB提供的这组文件操作函数中，可分为三种类型，就是：1、文件名函数，2、文件管理函数；3、文件I/O函数。</p>
<p>1、文件名函数<br>　　文件名函数可以对文件的名称、所在子目录、驱动器和扩展名等进行操作。下表列出这些函数及其功能。</p>
<p>　　函数 说明<br>　　ExpandFileName() 返回文件的全路径(含驱动器、路径)<br>　　ExtractFileExt() 从文件名中抽取扩展名<br>　　ExtractFileName() 从文件名中抽取不含路径的文件名<br>　　ExtractFilePath() 从文件名中抽取路径名<br>　　ExtractFileDir() 从文件名中抽取目录名<br>　　ExtractFileDrive() 从文件名中抽取驱动器名<br>　　ChangeFileExt() 改变文件的扩展名<br>　　ExpandUNCFileName() 返回含有网络驱动器的文件全路径<br>　　ExtractRelativePath() 从文件名中抽取相对路径信息<br>　　ExtractShortPathName() 把文件名转化为DOS的8·3格式<br>　　MatchesMask() 检查文件是否与指定的文件名格式匹配</p>
<p>　　下面就把这些函数作一一介绍：</p>
<p>　　⑴ExpandFileName()<br>　　原型：extern PACKAGE AnsiString __fastcall ExpandFileName(const AnsiString FileName);</p>
<p>　　功能：返回文件的全路径(含驱动器、路径)</p>
<p>　　参数：FileName:要处理的文件名</p>
<p>　　例：ShowMessage(ExpandFileName(Application-&gt;ExeName));//显示你的程序文件名，如C:/MyBCB/Sample1.EXE</p>
<p>　　⑵ExtractFileExt()<br>　　原型：extern PACKAGE AnsiString __fastcall ExtractFileExt(const AnsiString FileName);</p>
<p>　　功能：从文件名中抽取扩展名</p>
<p>　　参数：FileName:要处理的文件名（全路径）</p>
<p>　　例：ShowMessage(ExtractFileExt(Application-&gt;ExeName));//显示”.exe”</p>
<p>　　⑶ExtractFileName()<br>　　原型：extern PACKAGE AnsiString __fastcall ExtractFileName(const AnsiString FileName);</p>
<p>　　功能：从文件名中抽取不含路径的文件名</p>
<p>　　参数：FileName:要处理的文件名</p>
<p>　　例：ShowMessage(ExtractFileExt(“c://Winnt//SOL.EXE”));//显示”SOL.EXE”</p>
<p>　　⑷ExtractFilePath()<br>　　原型：extern PACKAGE AnsiString __fastcall ExtractFilePath(const AnsiString FileName);</p>
<p>　　功能：从文件名中抽取路径名</p>
<p>　　参数：FileName:要处理的文件名</p>
<p>　　例：ShowMessage(ExtractFilePath(“Winnt//SOL.EXE”));//显示”Winnt/“</p>
<p>　　⑸ExtractFileDir()<br>　　原型：extern PACKAGE AnsiString __fastcall ExtractFileDir(const AnsiString FileName);</p>
<p>　　功能：从文件名中抽取目录名(和上个函数不同，不包括最后的”/“)</p>
<p>　　参数：FileName:要处理的文件名</p>
<p>　　例：ShowMessage(ExtractFileDir(“Winnt//SOL.EXE”));//显示”Winnt”,注意和上个函数的区别</p>
<p>　　⑹ExtractFileDrive()<br>　　原型：extern PACKAGE AnsiString __fastcall ExtractFileDrive(const AnsiString FileName);</p>
<p>　　功能：从文件名中抽取驱动器名</p>
<p>　　参数：FileName:要处理的文件名</p>
<p>　　例：ShowMessage(ExtractFileDrive(“c://Winnt//SOL.EXE”));//显示”c:”</p>
<p>　　⑺ChangeFileExt()<br>　　原型：extern PACKAGE System::AnsiString __fastcall ChangeFileExt(const System::AnsiString FileName, const System::AnsiString Extension);</p>
<p>　　功能：更改文件名的扩展名，不是对真正的文件进行改名，只是对文件名这个字符串进行处理</p>
<p>　　参数：FileName:要改名的文件名，Extension：新的扩展名</p>
<p>　　例：ShowMessage(ChangeFileExt(“c://Winnt//SOL.EXE”,”.OOO”));//显示”c:/winnt/SOL.OOO”</p>
<p>　　⑻ExpandUNCFileName()<br>　　原型：extern PACKAGE AnsiString __fastcall ExpandUNCFileName(const AnsiString FileName);</p>
<p>　　功能：返回含有网络驱动器的文件全路径，格式为：//机器名/共享名/文件名</p>
<p>　　参数：FileName:要处理的文件名</p>
<p>　　例：ShowMessage(ExpandUNCFileName(“F://Winnt//SOL.EXE”));/<em>如果F:是映射的网络驱动器//NT40/WINNT，则显示”//NT40/WINNT/SOL.EXE”</em>/</p>
<p>　　⑼ExtractRelativePath()<br>　　原型：extern PACKAGE AnsiString __fastcall ExtractRelativePath(const AnsiString BaseName, const AnsiString DestName);</p>
<p>　　功能：从文件名中抽取相对路径信息，如”../sss/ss.asd”这种形式</p>
<p>　　参数：BaseName：基准文件名；DestName：目标文件名</p>
<p>　　例：ShowMessage(ExtractRelativePath(“D://Source//c//1.123”,”D://Source//Asm//dz.asm”));/<em>显示”../asm/dz.asm”</em>/</p>
<p>　　(10) ExtractShortPathName()<br>　　原型：extern PACKAGE AnsiString __fastcall ExtractShortPathName(const AnsiString FileName);</p>
<p>　　功能：把文件名转换为DOS的8、3格式</p>
<p>　　参数：FileName:要处理的文件名</p>
<p>　　例：ShowMessage(ExtractShortPathName(“E://Program Files//Dual Wheel Mouse//4dmain.exe”));/<em>显示”E:/Progra<del>1/dualwh</del>1/4dmain.exe”</em>/</p>
<p>　　⑾MatchesMask()<br>　　原型：extern PACKAGE bool __fastcall MatchesMask(const AnsiString Filename, const AnsiString Mask);</p>
<p>　　功能：检查文件是否与指定的文件名格式匹配</p>
<p>　　参数：FileName:要处理的文件名；Mask:文件名格式，支持通配符</p>
<p>　　例：ShowMessage(MatchesMask(“Lxf.exe”,”*.?x?));//显示”true”</p>
<p>2、文件管理函数<br>　　这类函数包括设置和读取驱动器、子目录和文件的有关的各种操作，下表列出这类操作常用的函数及其功能。</p>
<p>　　函数 功能<br>　　CreateDir() 创建新的子目录<br>　　DeleteFile() 删除文件<br>　　DirectoryExists() 判断目录是否存在<br>　　DiskFree() 获取磁盘剩余空间<br>　　DiskSize() 获取磁盘容量<br>　　FileExists() 判断文件是否存在<br>　　FileGetAttr() 获取文件属性<br>　　FileGetDate() 获取文件日期<br>　　GetCurrentDir() 获取当前目录<br>　　RemoveDir() 删除目录<br>　　SetCurrentDir() 设置当前目录</p>
<p>　　下面就把这些函数作一一介绍：</p>
<p>　　⑴CreateDir()<br>　　原型：extern PACKAGE bool __fastcall CreateDir(const System::AnsiString Dir);</p>
<p>　　功能：建立子目录，如果成功返回true，否则返回false</p>
<p>　　参数：Dir:要建立的子目录的名字</p>
<p>　　例：Create(“ASM”);//在当前目录下建立一个名为ASM的子目录</p>
<p>　　⑵DeleteFile()<br>　　原型：extern PACKAGE bool __fastcall DeleteFile(const System::AnsiString FileName);</p>
<p>　　功能：删除文件，如果成功返回true，否则返回false</p>
<p>　　参数：FileName:要删除的文件名</p>
<p>　　例：if(OpenDialog1-&gt;Execute())DeleteFile(OpenDialog1-&gt;FileName);</p>
<p>　　⑶DirectoryExists()<br>　　原型：extern PACKAGE bool __fastcall DirectoryExists(const System:: AnsiString Name);</p>
<p>　　功能：检测目录是否存在，如果存在返回true，否则返回false</p>
<p>　　参数：Name:要检测的目录名</p>
<p>　　例：if(!DirectoryExists(“ASM”))CreateDir(“ASM”);//如果ASM这个目录不存在则创建之</p>
<p>　　⑷DiskFree()<br>　　原型：extern PACKAGE __int64 __fastcall DiskFree(Byte Drive);</p>
<p>　　功能：检测磁盘剩余空间，返回值以字节为单位，如果指定的磁盘无效，返回-1</p>
<p>　　参数：Drive：磁盘的代号，0表示当前盘, 1=A,2=B,3=C 以此类推</p>
<p>　　例：ShowMessage(DiskFree(0));//显示当前盘的剩余空间</p>
<p>　　⑸DiskSize()<br>　　原型：extern PACKAGE __int64 __fastcall DiskSize(Byte Drive);</p>
<p>　　功能：检测磁盘容量，返回值以字节为单位，如果指定的磁盘无效，返回-1</p>
<p>　　参数：Drive：磁盘的代号，0表示当前盘, 1=A,2=B,3=C 以此类推</p>
<p>　　例：ShowMessage(DiskFree(0));//显示当前盘的容量</p>
<p>　　⑹FileExists()<br>　　原型：extern PACKAGE bool __fastcall FileExists(const AnsiString FileName);</p>
<p>　　功能：检测文件是否存在，如果存在返回true，否则返回false</p>
<p>　　参数：FileName:要检测的文件名</p>
<p>　　例：if(FileExists(“AAA.ASM”))DeleteFile(“AAA.ASM”);</p>
<p>　　⑺FileGetAttr()<br>　　原型：extern PACKAGE int __fastcall FileGetAttr(const AnsiString FileName);</p>
<p>　　功能：取得文件属性，如果出错返回-1</p>
<p>　　返回值如下表，如果返回$00000006表示是一个具有隐含和系统属性的文件(4+2)</p>
<p>　　常量 值 含义<br>　　faReadOnly $00000001 只读文件<br>　　faHidden $00000002 隐含文件<br>　　faSysFile $00000004 系统文件<br>　　faVolumeID $00000008 卷标<br>　　faDirectory $00000010 目录<br>　　faArchive $00000020 归档文件</p>
<p>　　例：if(FileGetAttr(“LLL.TXT”)&amp;0x2)ShowMessage(“这是一个有隐含属性的文件”);</p>
<p>　　与此对应的有FileSetAttr() ，请自已查阅帮助系统</p>
<p>　　⑻FileGetDate()<br>　　原型：extern PACKAGE int __fastcall FileGetDate(int Handle);</p>
<p>　　功能：返回文件的建立时间到1970-1-1日0时的秒数</p>
<p>　　参数：Handle:用FileOpen()打开的文件句柄。</p>
<p>　　例：</p>
<p>　　int i=FileOpen(“C://autoexec.bat”,fmOpenRead);<br>　　ShowMessage(FileGetDate(i));<br>　　FileClose(i);</p>
<p>　　与此对应的有FileSetDate()，请自已查阅帮助系统</p>
<p>　　⑼GetCurrentDir()<br>　　原型：extern PACKAGE AnsiString __fastcall GetCurrentDir();</p>
<p>　　功能：取得当前的目录名</p>
<p>　　例：ShowMessage(GetCurrentDir());</p>
<p>　　⑽RemoveDir()<br>　　原型：extern PACKAGE bool __fastcall RemoveDir(const AnsiString Dir);</p>
<p>　　功能：删除目录，如果成功返回true，否则返回false</p>
<p>　　参数：Dir:要删除的目录名</p>
<p>　　例：if(DiectoryExists(“ASM”))RemoveDir(“ASM”);</p>
<p>　　⑾SetCurrentDir()<br>　　原型：extern PACKAGE bool __fastcall SetCurrentDir(const AnsiString Dir);</p>
<p>　　功能：设置当前目录，如果成功返回true，否则返回false</p>
<p>　　参数：Dir:要切换到的目录名</p>
<p>　　例：SetCurrentDir(“C://WINDOWS”);</p>
<p>3、文件I/O函数<br>　　这类函数完成对文件的读写相关的操作，这种类型的操作和C的基于I/O文件操作类似，下表列出这类操作常用的函数及其功能。</p>
<p>　　FileOpen() 打开文件<br>　　FileClose() 关闭文件<br>　　FileRead() 读文件<br>　　FileSeek() 文件定位<br>　　FileWrite() 写文件<br>　　FileCreate() 创建文件</p>
<p>　　下面就对这些函数作详细介绍。</p>
<p>　　⑴FileOpen()<br>　　原型：extern PACKAGE int __fastcall FileOpen(const AnsiString FileName, int Mode);</p>
<p>　　功能：打开文件，如果成功返回其句柄，否则返回-1</p>
<p>　　参数：FileName:要打开的文件名；Mode：打开的方式，取值如下表，可用”或”(“|”)运算符连接。</p>
<p>　　常量 值 说明<br>　　————————————————————-<br>　　fmOpenRead 0 以只读属性打开<br>　　fmOpenWrite 1 以只写属性打开<br>　　fmOpenReadWrite 2 以读/写属性打开<br>　　fmShareCompat 0 兼容FCB方式(汇编中有相应的DOS功能调用，感兴趣自已查阅相关资料)<br>　　fmShareExclusive 16 共享方式：以独占方式打开，在关闭以前，别人不能访问<br>　　fmShareDenyWrite 32 共享方式：拒绝写访问<br>　　fmShareDenyRead 48 共享方式：拒绝读访问<br>　　fmShareDenyNone 64 共享方式：无限制，允许读写<br>　　例：int i=FileOpen(“C://WINDOWS//Win.ini”,fmOpenReadWrite|fmShareExclusive);</p>
<p>　　⑵FileClose()<br>　　原型：extern PACKAGE void __fastcall FileClose(int Handle);</p>
<p>　　功能：关闭打开的句柄。</p>
<p>　　参数：Handle:要关闭的句柄</p>
<p>　　例：FileClose(i);</p>
<p>　　⑶FileRead()<br>　　原型：extern PACKAGE int __fastcall FileRead(int Handle, void *Buffer, int Count);</p>
<p>　　功能：读文件，返回实际读取的字节数，句柄必须首先由FileOpen或FileCreate创建。</p>
<p>　　参数：Handle:要读取的句柄；Buffer:存放读取的数据的缓冲区；Count:想读取的字节数</p>
<p>　　例：char str[400];FileRead(hnd1,str,400);</p>
<p>　　⑷FileSeek()<br>　　原型：extern PACKAGE int __fastcall FileSeek(int Handle, int Offset, int Origin);</p>
<p>　　功能：移动文件读取指针，成功返回文件指针的位置，失败返回-1</p>
<p>　　参数：Handle:相关联的句柄；Offset:移动的量；Orgin:移动的基准，0=文件头，1=当前位置，2=文件尾。</p>
<p>　　例：ShowMessage(FileSeek(hnd1,0,2));//取得文件的长度</p>
<p>　　⑸FileWrite()<br>　　原型：extern PACKAGE int __fastcall FileWrite(int Handle, const void *Buffer, int Count);</p>
<p>　　功能：写文件，返回实际写入的字节数，句柄必须首先由FileOpen或FileCreate创建。</p>
<p>　　参数：Handle:要写入的句柄；Buffer:存放写入数据的缓冲区；Count:想写入的字节数</p>
<p>　　例：char str[]=”I Love You”;FileWrite(hnd1,str,strlen(str));</p>
<p>　　⑹FileCreate()<br>　　原型：extern PACKAGE int __fastcall FileCreate(const AnsiString FileName);</p>
<p>　　功能：创建文件。成功返回其句柄，否则返回-1</p>
<p>　　参数：FileName:要创建的文件名</p>
<p>　　例：if(!FileExists(“KC.C”))hnd1=FileCreate(“KC.C”);</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/24/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/24/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">游戏框架搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-24 23:04:50 / 修改时间：23:23:18" itemprop="dateCreated datePublished" datetime="2020-12-24T23:04:50+08:00">2020-12-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="游戏框架搭建"><a href="#游戏框架搭建" class="headerlink" title="游戏框架搭建"></a>游戏框架搭建</h1><p><strong>目标</strong> —— 使用 <strong>面相对象</strong> 设计 <strong>飞机大战游戏类</strong></p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>明确主程序职责</li>
<li>实现主程序类</li>
<li>准备游戏精灵组</li>
</ul>
<h2 id="01-明确主程序职责"><a href="#01-明确主程序职责" class="headerlink" title="01. 明确主程序职责"></a>01. 明确主程序职责</h2><ul>
<li>回顾 <strong>快速入门案例</strong>，一个游戏主程序的 <strong>职责</strong> 可以分为两个部分：<ul>
<li>游戏初始化</li>
<li>游戏循环</li>
</ul>
</li>
<li>根据明确的职责，设计 <code>PlaneGame</code> 类如下：</li>
</ul>
<p><img src="/2020/12/24/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/009_%E6%B8%B8%E6%88%8F%E4%B8%BB%E7%A8%8B%E5%BA%8F.png" alt></p>
<blockquote>
<p><strong>提示</strong> 根据 <strong>职责</strong> 封装私有方法，可以避免某一个方法的代码写得太过冗长</p>
<p>如果某一个方法编写的太长，既不好阅读，也不好维护！</p>
</blockquote>
<ul>
<li><strong>游戏初始化</strong> ——  <code>__init__()</code> 会调用以下方法： </li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td><code>__create_sprites(self)</code></td>
<td>创建所有精灵和精灵组</td>
</tr>
</tbody></table>
<ul>
<li><strong>游戏循环</strong> —— <code>start_game()</code> 会调用以下方法：</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td><code>__event_handler(self)</code></td>
<td>事件监听</td>
</tr>
<tr>
<td><code>__check_collide(self)</code></td>
<td>碰撞检测 —— 子弹销毁敌机、敌机撞毁英雄</td>
</tr>
<tr>
<td><code>__update_sprites(self)</code></td>
<td>精灵组更新和绘制</td>
</tr>
<tr>
<td><code>__game_over()</code></td>
<td>游戏结束</td>
</tr>
</tbody></table>
<h2 id="02-实现飞机大战主游戏类"><a href="#02-实现飞机大战主游戏类" class="headerlink" title="02. 实现飞机大战主游戏类"></a>02. 实现飞机大战主游戏类</h2><h3 id="2-1-明确文件职责"><a href="#2-1-明确文件职责" class="headerlink" title="2.1 明确文件职责"></a>2.1 明确文件职责</h3><p><img src="/2020/12/24/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/011_%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6%E8%81%8C%E8%B4%A3.png" alt></p>
<ul>
<li><code>plane_main</code> <ol>
<li>封装 <strong>主游戏类</strong></li>
<li>创建 <strong>游戏对象</strong></li>
<li><strong>启动游戏</strong></li>
</ol>
</li>
<li><code>plane_sprites</code><ul>
<li>封装游戏中 <strong>所有</strong> 需要使用的 <strong>精灵子类</strong></li>
<li>提供游戏的 <strong>相关工具</strong></li>
</ul>
</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul>
<li>新建 <code>plane_main.py</code> 文件，并且设置为可执行</li>
<li>编写 <strong>基础代码</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="keyword">from</span> plane_sprites <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlaneGame</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""飞机大战主游戏"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"游戏初始化"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_game</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"开始游戏..."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建游戏对象</span></span><br><span class="line">    game = PlaneGame()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始游戏</span></span><br><span class="line">    game.start_game()</span><br></pre></td></tr></table></figure>

<h3 id="2-3-游戏初始化部分"><a href="#2-3-游戏初始化部分" class="headerlink" title="2.3 游戏初始化部分"></a>2.3 游戏初始化部分</h3><ul>
<li>完成 <code>__init__()</code> 代码如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"游戏初始化"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 1. 创建游戏的窗口</span></span><br><span class="line">    self.screen = pygame.display.set_mode((<span class="number">480</span>, <span class="number">700</span>))</span><br><span class="line">    <span class="comment"># 2. 创建游戏的时钟</span></span><br><span class="line">    self.clock = pygame.time.Clock()</span><br><span class="line">    <span class="comment"># 3. 调用私有方法，精灵和精灵组的创建</span></span><br><span class="line">    self.__create_sprites()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__create_sprites</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h4 id="使用-常量-代替固定的数值"><a href="#使用-常量-代替固定的数值" class="headerlink" title="使用 常量 代替固定的数值"></a>使用 常量 代替固定的数值</h4><blockquote>
<ul>
<li>常量 —— 不变化的量</li>
<li>变量 —— 可以变化的量</li>
</ul>
</blockquote>
<p><strong>应用场景</strong></p>
<ul>
<li>在开发时，可能会需要使用 <strong>固定的数值</strong>，例如 <strong>屏幕的高度</strong> 是 <code>700</code></li>
<li>这个时候，建议 <strong>不要</strong> 直接使用固定数值，而应该使用 <strong>常量</strong></li>
<li>在开发时，为了保证代码的可维护性，尽量不要使用 <strong>魔法数字</strong> </li>
</ul>
<p><strong>常量的定义</strong></p>
<ul>
<li>定义 <strong>常量</strong> 和 定义 <strong>变量</strong> 的语法完全一样，都是使用 <strong>赋值语句</strong></li>
<li><strong>常量</strong> 的 <strong>命名</strong> 应该 <strong>所有字母都使用大写</strong>，<strong>单词与单词之间使用下划线连接</strong></li>
</ul>
<p><strong>常量的好处</strong></p>
<ul>
<li>阅读代码时，通过 <strong>常量名</strong> <strong>见名之意</strong>，不需要猜测数字的含义</li>
<li>如果需要 <strong>调整值</strong>，只需要 <strong>修改常量定义</strong> 就可以实现 <strong>统一修改</strong></li>
</ul>
<blockquote>
<p>提示：Python 中并没有真正意义的常量，只是通过命名的约定 —— 所有字母都是大写的就是常量，开发时不要轻易的修改！</p>
</blockquote>
<p><strong>代码调整</strong></p>
<ul>
<li>在 <code>plane_sprites.py</code> 中增加常量定义</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"></span><br><span class="line"><span class="comment"># 游戏屏幕大小</span></span><br><span class="line">SCREEN_RECT = pygame.Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">480</span>, <span class="number">700</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>plane_main.py</code> 中的窗口大小</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.screen = pygame.display.set_mode(SCREEN_RECT.size)</span><br></pre></td></tr></table></figure>

<h3 id="2-4-游戏循环部分"><a href="#2-4-游戏循环部分" class="headerlink" title="2.4 游戏循环部分"></a>2.4 游戏循环部分</h3><ul>
<li>完成 <code>start_game()</code> 基础代码如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_game</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""开始游戏"""</span></span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"开始游戏..."</span>)</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 1. 设置刷新帧率</span></span><br><span class="line">        self.clock.tick(<span class="number">60</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 事件监听</span></span><br><span class="line">        self.__event_handler()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 3. 碰撞检测</span></span><br><span class="line">        self.__check_collide()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 4. 更新精灵组</span></span><br><span class="line">        self.__update_sprites()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 5. 更新屏幕显示</span></span><br><span class="line">        pygame.display.update()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__event_handler</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""事件监听"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> event.type == pygame.QUIT:</span><br><span class="line">            PlaneGame.__game_over()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__check_collide</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""碰撞检测"""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__update_sprites</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""更新精灵组"""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__game_over</span><span class="params">()</span>:</span></span><br><span class="line">   <span class="string">"""游戏结束"""</span></span><br><span class="line"></span><br><span class="line">   print(<span class="string">"游戏结束"</span>)</span><br><span class="line">   pygame.quit()</span><br><span class="line">   exit()</span><br></pre></td></tr></table></figure>

<h2 id="03-准备游戏精灵组"><a href="#03-准备游戏精灵组" class="headerlink" title="03. 准备游戏精灵组"></a>03. 准备游戏精灵组</h2><h3 id="3-1-确定精灵组"><a href="#3-1-确定精灵组" class="headerlink" title="3.1 确定精灵组"></a>3.1 确定精灵组</h3><p><img src="/2020/12/24/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/010_%E7%B2%BE%E7%81%B5%E7%BB%84%E7%A1%AE%E5%AE%9A.png" alt></p>
<h3 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h3><ul>
<li>创建精灵组方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__create_sprites</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""创建精灵组"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 背景组</span></span><br><span class="line">    self.back_group = pygame.sprite.Group()</span><br><span class="line">    <span class="comment"># 敌机组</span></span><br><span class="line">    self.enemy_group = pygame.sprite.Group()</span><br><span class="line">    <span class="comment"># 英雄组</span></span><br><span class="line">    self.hero_group = pygame.sprite.Group()</span><br></pre></td></tr></table></figure>

<ul>
<li>更新精灵组方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__update_sprites</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""更新精灵组"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> group <span class="keyword">in</span> [self.back_group, self.enemy_group, self.hero_group]:</span><br><span class="line">    </span><br><span class="line">        group.update()</span><br><span class="line">        group.draw(self.screen)</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">匡俊桦</p>
  <div class="site-description" itemprop="description">回忆的沙漏将曾经屈指可数的日子渐渐淡去</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">233</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">匡俊桦</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">28:26</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
