<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/15/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="KJH">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/15/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day08%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day08%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记8</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:02:03" itemprop="dateModified" datetime="2020-12-23T23:02:03+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、Eclipse开发工具<br>2、超市库存管理系统</p>
<p>###01Eclipse的下载安装<br>    * A: Eclipse的下载安装        <br>        * a: 下载<br>            * <a href="http://www.eclipse.org" target="_blank" rel="noopener">http://www.eclipse.org</a><br>        * b: 安装<br>            * 只需要解压后就能使用<br>        * c: 卸载<br>            * 只需要将文件夹删除就可以了<br>        * d: 注意<br>            * 开发软件的安装目录中，尽量不要出现空格与中文<br>    * B: Eclipse的特点<br>        * a: 免费<br>        * b: 纯Java语言编写<br>        * c: 免安装<br>        * d: 扩展性强</p>
<p>###02Eclipse的工作空间和新建工程<br>    * A: Eclipse的工作空间和新建工程<br>        * a: 工作空间<br>            *  其实就是我们写的源代码所在的目录<br>        * b: 创建工程(项目)<br>            * 右键/Package Explore 空白区/new /Java Project/输入项目名称如day08/<br>        * c: 创建包(后面讲包的概念)<br>            *　打开上面建立的day08项目/右键/new/package/在弹出的对话框的name中输入报名如”com.itheima.tests”/finish<br>        * d: 创建类<br>            * 创建一个java类:右击包名/new/class/在对话框的name中输入类名/finish<br>    * B: 编译与执行<br>        * a: 编译<br>            * 自动编译，当java代码保存的时候，自动 编译class文件<br>        * b: 运行<br>            * 方式1：点击菜单工具栏中的 绿色带有三角形的 run按钮 运行<br>            * 方式2：点击菜单栏中Run， 点击Run 运行  快捷键是 ctrl+F11<br>            * 方式3：选中要运行的java文件，或者在编写代码的空白区域，右键选择 Run As –&gt; 运行java程序</p>
<p>​<br>###03Eclipse的HelloWorld编写<br>    * A:HelloWorld编写<br>        * a: 编写过程(参照上个知识点)<br>            * 建立day08项目<br>            * 建立包结构(包的概念还没有学到,不建立包的话,使用默认包结构default)<br>            * 创建HelloWorld类(自动生成main方法)<br>        * b: 案例代码<br>            public class HelloWorld {<br>                public static void main(String[] args) {<br>                    System.out.println(“Hello World”);<br>                }<br>            }</p>
<p>​    </p>
<p>###04Eclipse的字体设置<br>    * A: Eclipse的字体设置<br>        * a: 修改编译环境和运行环境<br>            * 编译环境：Window – Preferences – Java - Compiler<br>            * 运行环境：Window – Preferences – Java - Installed JREs</p>
<pre><code>* b: 显示行号与隐藏行号
    * 显示：在代码区域的左边空白区域，右键 -- Show Line Numbers
    * 隐藏：将上面的操作再做一遍

* c: 更改字体大小与颜色
    * Java代码区域的字体大小和颜色：
        * window -- Preferences -- General -- Appearance -- Colors And Fonts --Java修改 -- Java Edit Text Font--edit进行修改
    * 控制台
        * window -- Preferences -- General -- Appearance -- Colors And Fonts -- Debug -- Console font
    * 其他文件
        * window -- Preferences -- General -- Appearance -- Colors And Fonts -- Basic -- Text Font</code></pre><p>###05Eclipse的窗口设置<br>    * A: 窗口设置<br>        * a: 显示的窗口乱了，还原默认显示模式<br>            * Window – Perspective – Reset Prespective<br>        * b: 显示控制台<br>            * Window–Show View—Console        </p>
<p>###06Eclipse的去掉多余的注释<br>    * A: Eclipse的去掉多余的注释<br>        * a:如何去掉默认注释<br>            * Window – Preferences – Java – Code Style – Code Templates – Comments – Methods，点击Edit ，将注释部分删除 (不建议删除)<br>            * Window – Preferences – Java – Code Style – Code Templates – Code – Method body，点击Edit ，将注释部分删除<br>        * b: 切换工作空间<br>            * File – Switch Workspace – 指定工作空间 – ok</p>
<p>###07Eclipse的快捷键<br>    * A: Eclipse的快捷键<br>        * a: 内容辅助键  Alt+/<br>            * 自动补齐main方法  main 然后 Alt+/<br>            * 自动补齐输出语句  syso 然后 Alt+/<br>        * b: 格式化代码<br>            * Ctrl+Shift+f<br>            * 代码区域右键 – Source – Format<br>        * c: 自动导包<br>            * Ctrl+Shift+o<br>            * 如果当前类在多个包中都存在，这时候，使用Ctrl+shift+o,进行选择一个包导入即可。<br>        * d: 注释<br>            * 单行注释<br>                * 加注释： 先选中需要注释的内容，然后 Ctrl+/<br>                * 取消注释：先选中需要取消注释的内容， 然后 Ctrl+/<br>            * 多行注释<br>                * 加注释： 先选中需要注释的内容，然后 Ctrl+Shift+/<br>                * 取消注释：先选中需要取消注释的内容， 然后 Ctrl+Shift+<br>        * e: 补充<br>            * 代码上下移动<br>                * 选中代码alt+上/下箭头<br>            * 查看源码<br>                * 选中类名(F3或者Ctrl+鼠标点击)<br>            * 查找具体的类<br>                * ctrl + shift + t，输入要查找的类的名称–&gt;确定<br>            * 查找具体类的具体方法<br>                * ctrl + o<br>            * 给建议<br>                * ctrl+1,根据右边生成左边的数据类型,生成方法<br>            * 删除代码<br>                * ctrl + d<br>            * 抽取方法<br>                * alt + shift + m<br>            * 改名<br>                * alt + shift + r（类名，方法名，变量名）</p>
<p>###08Eclipse的断点调试<br>    * A:断点调试(又称为Debug调试)的作用<br>        * 调试程序<br>        * 查看程序执行流程<br>    * B:如何查看程序执行流程<br>        * 什么是断点：<br>            * 就是一个标记，从哪里开始。</p>
<pre><code>* 如何设置断点：
    * 你想看哪里的程序，你就在那个有效程序的左边双击即可。

* 在哪里设置断点：
    * 哪里不会点哪里。
    * 目前：我们就在每个方法的第一条有效语句上都加。

* 如何运行设置断点后的程序：
    * 右键 -- Debug as -- Java Application

* 看哪些地方：
    * Debug：断点测试的地方
        * 在这个地方，记住F6，或者点击也可以。一次看一行的执行过程。
    * Variables：查看程序的变量变化
    * ForDemo：被查看的源文件
    * Console：控制台

* 如何去断点：
    * a:再次双击即可
    * b:找到Debug视图，Variables界面，找到Breakpoints，并点击，然后看到所有的断点，最后点击那个双叉        </code></pre><p>###09Eclipse的工程删除和导入<br>    * A:删除项目<br>        * 选中项目 – 右键 – 删除<br>            * 从项目区域中删除<br>            * 从硬盘上删除<br>    * B:导入项目<br>        * 在项目区域右键找到import<br>        * 找到General，展开，并找到<br>        * Existing Projects into Workspace<br>        * 点击next,然后选择你要导入的项目<br>        * 注意：这里选择的是项目名称</p>
<p>###10超市管理系统功能介绍<br>    * A：超市管理系统功能介绍<br>        * a: 显示主菜单</p>
<pre><code>    ============欢迎光临ItCast超市============
    1: 货物 清单   2: 添加货物   3: 删除货物   4: 修改货物  5: 退出
    请您输入要操作的功能序号

* b: 货物清单

    输入1:货物清单
    ================商品库存清单================
    商品编号         商品名称                商品单价
    9527               少林寺酥饼核桃               12.7
    9008               尚康杂粮牡丹饼              5.6
    9879               新疆原产哈密瓜             599.6

* c: 添加新货物

    输入2:添加新货物    

    请输入新商品的编号:9523
    请输入新商品的名字:斯柯达苹果醋
    请输入新商品的单价:19.9
    商品添加成功

* d: 删除货物

    输入3:删除货物

    选择的是删除功能
    请输入商品的编号:9523
    货物信息删除完毕

* e: 修改货物

    输入4:修改货物

    选择的是修改功能
    请输入您要修改的商品的编号:9527
    输入新的商品编号:100
    输入新的商品名字:味道好凤梨干
    输入新的商品价格:6.5
    商品修改成功
* f: 输入5:退出系统</code></pre><p>###11超市管理系统案例分析<br>    * A: 超市管理系统案例分析<br>        * 完成超市商品初始化。创建商品，将商品添加到集合<br>        * 显示来到超市能做的操作，也就是显示主菜单<br>        * 根据接收到的功能选项，执行对应的功能<br>        * 库存货物查询<br>        * 添加新货物<br>        * 删除货物<br>        * 修改货物<br>        * 退出系统,结束main方法的运行<br>        * 循环，回到 2.显示主菜单</p>
<p>​<br>###12自定义商品类<br>    * A: 自定义商品类<br>        * a: 目的<br>            * 每种库存商品都拥有多项商品信息，为了方便管理每种商品的信息，我们对商品信息进行封装，编写FruitItem.java文件<br>        * b：案例代码<br>            public class FruitItem {<br>                int  ID;            //商品编号<br>                String  name;        //商品名称<br>                double  price;        //商品单价<br>                double  number;        //商品数量<br>                double  money;        //商品金额<br>            }<br>        * 补充<br>            * 上述代码中，对商品信息（编号、名称、单价、数量、金额）进行了封装。这样做的好处在于以后只要找到这个商品，就能够知道该商品的每项信息了。</p>
<p>###13初始化商品属性<br>    * A: 初始化商品属性<br>        * a: 案例代码<br>            import java.util.ArrayList;<br>            import java.util.Scanner;</p>
<pre><code>/*
 *   超市管理系统主
 *   实现:
 *     1. 商品数据的初始化
 *     2. 用户的菜单选择
 *     3. 根据选择执行不同的功能
 *       3.1 Read    查看商品
 *       3.2 Create  添加商品
 *       3.3 Delete  删除商品
 *       3.4 Update  修改商品
 *       
 *       
 *   所有功能 ,必须定义方法实现
 *   主方法main  调用作用
 */
public class Shopp {

    public static void main(String[] args) {
        //创建ArrayList集合,存储商品类型,存储数据类型FruitItem类型
        ArrayList&lt;FruitItem&gt; array = new ArrayList&lt;FruitItem&gt;();
        //调用商品初始化方法,传递集合
        init(array);

        }
    }    
    /*
     * 定义方法,实现商品数据的初始化
     * 先将一部分数据,存储集合中
     * 返回值: 无
     * 参数 : 集合
     * 方法名: init
     */
    public static void init(ArrayList&lt;FruitItem&gt; array){
        //创建出多个FruitItem类型,并且属性赋值
        FruitItem f1 = new FruitItem();
        f1.ID = 9527;
        f1.name = &quot;少林寺酥饼核桃&quot;;
        f1.price = 12.7;

        FruitItem f2 = new FruitItem();
        f2.ID = 9008;
        f2.name = &quot;尚康杂粮牡丹饼&quot;;
        f2.price = 5.6;

        FruitItem f3 = new FruitItem();
        f3.ID = 9879;
        f3.name = &quot;新疆原产哈密瓜&quot;;
        f3.price = 599.6;

        //创建的3个FruitItem类型变量,存储到集合中
        array.add(f1);
        array.add(f2);
        array.add(f3);
    }

}</code></pre><p>###14主菜单功能<br>    * A: 主菜单功能<br>        * a: 案例代码</p>
<pre><code>import java.util.ArrayList;
import java.util.Scanner;
/*
 *   超市管理系统主
 *   实现:
 *     1. 商品数据的初始化
 *     2. 用户的菜单选择
 *     3. 根据选择执行不同的功能
 *       3.1 Read    查看商品
 *       3.2 Create  添加商品
 *       3.3 Delete  删除商品
 *       3.4 Update  修改商品
 *       
 *       
 *   所有功能 ,必须定义方法实现
 *   主方法main  调用作用
 */
public class Shopp {

    public static void main(String[] args) {
        //创建ArrayList集合,存储商品类型,存储数据类型FruitItem类型
        ArrayList&lt;FruitItem&gt; array = new ArrayList&lt;FruitItem&gt;();
        //调用商品初始化方法,传递集合
        init(array);
        while(true){
            //调用菜单方法
            mainMenu();            
        }
    }    
    /*
     * 定义方法,实现主菜单
     * 提示用户哪些选择 让选择序号
     * 返回值: 无
     * 参数: 无
     */
    public static void mainMenu(){
        System.out.println();
        System.out.println(&quot;============欢迎光临ItCast超市============&quot;);
        System.out.println(&quot;1: 货物 清单   2: 添加货物   3: 删除货物   4: 修改货物  5: 退出&quot;);
        System.out.println(&quot;请您输入要操作的功能序号&quot;);
    }

    /*
     * 定义方法,实现商品数据的初始化
     * 先将一部分数据,存储集合中
     * 返回值: 无
     * 参数 : 集合
     * 方法名: init
     */
    public static void init(ArrayList&lt;FruitItem&gt; array){
        //创建出多个FruitItem类型,并且属性赋值
        FruitItem f1 = new FruitItem();
        f1.ID = 9527;
        f1.name = &quot;少林寺酥饼核桃&quot;;
        f1.price = 12.7;

        FruitItem f2 = new FruitItem();
        f2.ID = 9008;
        f2.name = &quot;尚康杂粮牡丹饼&quot;;
        f2.price = 5.6;

        FruitItem f3 = new FruitItem();
        f3.ID = 9879;
        f3.name = &quot;新疆原产哈密瓜&quot;;
        f3.price = 599.6;

        //创建的3个FruitItem类型变量,存储到集合中
        array.add(f1);
        array.add(f2);
        array.add(f3);
    }

}                </code></pre><p>###15用户选择功能<br>    * A: 用户选择功能<br>        * a: 案例代码<br>            import java.util.ArrayList;<br>            import java.util.Scanner;</p>
<pre><code>/*
 *   超市管理系统主
 *   实现:
 *     1. 商品数据的初始化
 *     2. 用户的菜单选择
 *     3. 根据选择执行不同的功能
 *       3.1 Read    查看商品
 *       3.2 Create  添加商品
 *       3.3 Delete  删除商品
 *       3.4 Update  修改商品
 *       
 *       
 *   所有功能 ,必须定义方法实现
 *   主方法main  调用作用
 */
public class Shopp {

    public static void main(String[] args) {
        //创建ArrayList集合,存储商品类型,存储数据类型FruitItem类型
        ArrayList&lt;FruitItem&gt; array = new ArrayList&lt;FruitItem&gt;();
        //调用商品初始化方法,传递集合
        init(array);
        while(true){
            //调用菜单方法
            mainMenu();
            //调用用户选择序号方法
            int choose = chooseFunction();
            switch (choose) {
            case 1:
                //调用1: 货物 清单
                showFruitList(array);
            break;

            case 2:
                //2: 添加货物
                addFruit(array);
            break;

            case 3:
                //3: 删除货物
                deleteFruit(array);
            break;

            case 4:
                //4: 修改货物
                updateFruit(array);
            break;

            case 5:
                return ;

            default:
                System.out.println(&quot;输入的序号没有&quot;);
                break;
            }
        }
    }    
    /*
     *  定义方法,实现接受用户的键盘输入
     *  返回编号
     */
    public static int chooseFunction(){
        Scanner sc = new Scanner(System.in);
        return sc.nextInt();
    }

    /*
     * 定义方法,实现主菜单
     * 提示用户哪些选择 让选择序号
     * 返回值: 无
     * 参数: 无
     */
    public static void mainMenu(){
        System.out.println();
        System.out.println(&quot;============欢迎光临ItCast超市============&quot;);
        System.out.println(&quot;1: 货物 清单   2: 添加货物   3: 删除货物   4: 修改货物  5: 退出&quot;);
        System.out.println(&quot;请您输入要操作的功能序号&quot;);
    }

    /*
     * 定义方法,实现商品数据的初始化
     * 先将一部分数据,存储集合中
     * 返回值: 无
     * 参数 : 集合
     * 方法名: init
     */
    public static void init(ArrayList&lt;FruitItem&gt; array){
        //创建出多个FruitItem类型,并且属性赋值
        FruitItem f1 = new FruitItem();
        f1.ID = 9527;
        f1.name = &quot;少林寺酥饼核桃&quot;;
        f1.price = 12.7;

        FruitItem f2 = new FruitItem();
        f2.ID = 9008;
        f2.name = &quot;尚康杂粮牡丹饼&quot;;
        f2.price = 5.6;

        FruitItem f3 = new FruitItem();
        f3.ID = 9879;
        f3.name = &quot;新疆原产哈密瓜&quot;;
        f3.price = 599.6;

        //创建的3个FruitItem类型变量,存储到集合中
        array.add(f1);
        array.add(f2);
        array.add(f3);
    }

}</code></pre><p>###16商品的清单功能<br>    * A: 商品的清单功能<br>        * a: 案例代码(显示商品清单的showFruitList(ArrayList<FruitItem>)方法的代码如下)<br>            /*<br>             *  定义方法,实现显示货物清单功能<br>             *  返回值: 无<br>             *  参数: 集合<br>             *  遍历集合,获取集合中的每个FruitItem变量,变量,调用属性<br>             <em>/<br>            public static void showFruitList(ArrayList<FruitItem> array){<br>                System.out.println();<br>                System.out.println(“================商品库存清单================”);<br>                System.out.println(“商品编号         商品名称                商品单价”);<br>                //遍历集合<br>                for(int i = 0 ; i &lt; array.size(); i++){<br>                    //集合get方法,获取出每个FruitItem变量,可以使用FruitItem接受get结果<br>                    FruitItem item = array.get(i);<br>                    //变量item调用类中属性<br>                    System.out.println(item.ID+”   “+item.name+”        “+item.price);<br>                }<br>            }<br>###17商品的添加功能<br>    * A: 商品的添加功能<br>        * a: 案例代码(商品添加功能的addFruit(ArrayList<FruitItem>)方法的代码如下)<br>            /</FruitItem></FruitItem></em><br>             * 定义方法,实现商品的添加功能<br>             * 返回值:无<br>             * 参数: 集合<br>             * 提示用户选择的是添加商品的功能<br>             *<br>             * 提示用户输入的是什么<br>             *<br>             * 创建FruitItem变量,变量调用的属性<br>             * 将输入的每个商品属性进行赋值<br>             <em>/<br>            public static void addFruit(ArrayList<FruitItem> array){<br>                System.out.println(“选择的是添加商品功能”);<br>                //创建Scanner变量<br>                Scanner sc = new Scanner(System.in);<br>                System.out.print(“请输入新商品的编号:”);<br>                //输入商品的编号<br>                int ID = sc.nextInt();<br>                //输入商品的名字<br>                System.out.print(“请输入新商品的名字:”);<br>                String name = sc.next();<br>                //输入商品的单价<br>                System.out.print(“请输入新商品的单价:”);<br>                double price = sc.nextDouble();<br>                //创建FruitItem变量<br>                FruitItem item = new FruitItem();<br>                //item.属性赋值<br>                item.ID = ID;<br>                item.name = name;<br>                item.price = price;<br>                array.add(item);<br>                System.out.println(“商品添加成功”);<br>            }<br>###18商品的删除功能<br>    * A: 商品的删除功能(删除商品deleteFruit(ArrayList<FruitItem>)方法的代码如下)<br>        * a: 案例代码<br>            /</FruitItem></FruitItem></em><br>             *  定义方法,实现商品的删除功能<br>             *  返回值:　无<br>             *  参数：　集合<br>             *<br>             *  删除依靠的是商品的编号<br>             *  提示用户选择的是删除功能<br>             *  键盘输入商品的编号<br>             *  遍历集合，获取集合中的每个FruitItem变量<br>             *  变量调用属性　ID， 和用户的输入的编号,对比,相同就删除<br>             */<br>            public static void deleteFruit(ArrayList<FruitItem> array){<br>                System.out.println(“选择的是删除功能”);<br>                System.out.print(“请输入商品的编号:”);<br>                Scanner sc = new Scanner(System.in);</FruitItem></FruitItem></p>
<pre><code>    int ID = sc.nextInt();
    //遍历集合
    for(int i = 0 ; i &lt; array.size(); i++){
        //获取到每个FruitItem变量
        FruitItem item = array.get(i);
        //变量,调用属性ID,和用户输入的编号比较
        if( item.ID == ID){
            //移除集合中的元素
            //集合的方法remove实现
            array.remove(i);
            System.out.println(&quot;删除成功&quot;);
            return;
        }
    }
    System.out.println(&quot;你输入的编号不存在&quot;);
}</code></pre><p>###19商品的修改功能<br>    * A: 商品的修改功能<br>        * a: 案例代码(修改商品updateFruit(ArrayList<FruitItem>)方法的代码如下)<br>            /*<br>             *  定义方法,实现商品的修改功能<br>             *  返回值:　无<br>             *  参数：　集合<br>             *<br>             *  提示用户选择的是修改功能<br>             *  提示用户输入需要修改的商品编号<br>             *  遍历集合,获取每个FruitItem变量<br>             *  变量调用ID属性,属性和用户输入的编号比较<br>             *  如果相同:<br>             *    修改调FruitItem中的属性值<br>             *    键盘输入<br>             */<br>            public static void updateFruit(ArrayList<FruitItem> array){<br>                System.out.println(“选择的是修改功能”);<br>                System.out.print(“请输入您要修改的商品的编号:”);</FruitItem></FruitItem></p>
<pre><code>    Scanner sc = new Scanner(System.in);
    int ID = sc.nextInt();
    //遍历集合,获取每个FruitItem变量
    for(int i = 0 ; i &lt; array.size(); i++){
        FruitItem item = array.get(i);
        //获取FruitItem的属性ID,和用户输入的ID比较
        if(item.ID == ID){
            System.out.print(&quot;输入新的商品编号:&quot;);
            item.ID = sc.nextInt();

            System.out.print(&quot;输入新的商品名字:&quot;);
            item.name = sc.next();

            System.out.print(&quot;输入新的商品价格:&quot;);
            item.price = sc.nextDouble();
            System.out.println(&quot;商品修改成功&quot;);
            return ;
        }
    }
    System.out.println(&quot;输入的编号不存在&quot;);
}</code></pre><p>###20总结</p>
<ul>
<li>把今天的知识点总结一遍。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day07%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day07%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记7</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:01:48" itemprop="dateModified" datetime="2020-12-23T23:01:48+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、循环练习<br>2、数组方法练习</p>
<p>###01奇数求和练习<br>    * A: 奇数求和练习<br>        * a: 题目分析<br>            * 为了记录累加和的值，我们需要定义一个存储累加和的变量<br>            * 我们要获取到1-100范围内的数<br>            * 判断当前数是否为奇数，是奇数，完成累加和操作<br>            * 累加完毕后，最终显示下累加和的值</p>
<pre><code>* b: 解题步骤
    * 定义一个用来记录累加和的变量
    * 使用for循环语句，完成1-100之间每个数的获取
    * 使用if条件语句，判断当前数是否是奇数，是奇数，进行累加和操作
    * 使用输出语句，打印累加和变量的值

* c: 案例代码
    public class Test01 {
        public static void main(String[] args) {
            int sum = 0;
            for (int i = 0; i &lt; 100; i++) {
                if (i%2==1) {
                    sum += i;
                }
            }
            System.out.println(&quot;累加和的值 &quot; + sum);
        }
    }</code></pre><p>###02水仙花练习功能实现<br>    * A: 水仙花练习功能实现<br>        * a: 题目分析<br>            * 明确什么样的数就是水仙花数。水仙花数是指一个3位数（100-999之间），其每位数字立方之和等于该3位数本身。<br>                如153 = 1<em>1</em>1 + 3<em>3</em>3 + 5<em>5</em>5，即 3位数本身 = 百位数立方 + 十位数立方 + 个位数立方;<br>            * 获取水仙花范围内的所有3位数（100-999之间的每个3位数）<br>            * 判断该3位数是否满足水仙花数，满足，打印该3位数</p>
<pre><code>* b: 解题步骤
    * 使用for循环，得到100-999之间的每个3位数
    * 获取3位数中百位数字、十位数字、个位数字
    * 使用if条件语句，判断该3位数是否满足水仙花数，满足，使用输出语句，打印该3位数

* c: 案例代码
    public class Test02 {
        public static void main(String[] args) {
            for (int i = 100; i &lt; 1000; i++) {
                int bai = i/100%10;
                int shi = i/10%10;
                int ge = i%10;

                if (i == bai*bai*bai + shi*shi*shi + ge*ge*ge) {
                    System.out.println(i);
                }
            }
        }
    }            </code></pre><p>###03ASCII编码表<br>    * A: ASCII编码表<br>        * a: 英文全称<br>            * American Standard Code for Information Interchange，美国标准信息交换代码<br>        * b: ASCII编码表由来<br>            * 计算机中，所有的数据在存储和运算时都要使用二进制数表示<br>            * a、b、c、d这样的52个字母（包括大写）、以及0、1等数字还有一些常用的符号, 在计算机中存储时也要使用二进制数来表示<br>            * 具体用哪些二进制数字表示哪个符号，当然每个人都可以约定自己的一套（这就叫编码）<br>            * 大家如果要想互相通信而不造成混乱，那么大家就必须使用相同的编码规则，于是美国有关的标准化组织就出台了ASCII编码，<br>                统一规定了上述常用符号用哪些二进制数来表示。<br>        * c: 中文编码表<br>            * GB2312<br>            * UNICODE<br>        * d: 字符中重要的ASCII码对应关系<br>            * a : 97<br>            * A : 65<br>            * 0 : 48</p>
<p>​    </p>
<p>###04char类型的存储<br>    * A: char类型的存储<br>        * a: 取值范围<br>            * short:占两个字节,是有符号数据,取值范围-32768-32767<br>            * char: 占两个字节,是无符号数据,取值范围0-65536</p>
<pre><code>* b: 类型转换
    * char类型的数据参加运算时要线程程int数据类型

* c: 案例代码
    /*
        ASCII编码表演示
        字符Java 数据类型,char
        整数Java 数据类型,int

        int 类型和 char 数据类型转换
        char  两个字节, int 四个字节

        char转成int类型的时候,类型自动提示,char数据类型,会查询编码表,得到整数
        int转成char类型的时候,强制转换,会查询编码表

        char存储汉字,查询Unicode编码表

        char可以和int计算,提示为int类型, 内存中两个字节
        char取值范围是0-65535, 无符号的数据类型
    */
    public class ASCIIDemo{
        public static void main(String[] args){
            char c = &apos;a&apos;;
            int i = c + 1;
            System.out.println(i);

            int j = 90;
            char h = (char)j;
            System.out.println(h);

            System.out.println( (char)6 );

            char k = &apos;你&apos;;
            System.out.println(k);</code></pre><p>​<br>                    char m = -1;<br>                }<br>            }    </p>
<p>###05输出所有英文字母<br>    * A: 输出所有英文字母<br>        * a: 题目分析<br>            * 一共26个大小写字母，那么，可以考虑循环26次。在每次循环中，完成指定字母的大小写打印<br>            * 找出ABCDEFG…XYZ这些字母之间的变化规律<br>                通过ASCII表发现，后面的字母比它前面的字母，ASCII值大1<br>                下一个字母 = 上一个字母 + 1<br>                如： A    B    C    D<br>                    65    66    67    68<br>            * 在每次循环中打印上一个字母大小写，并指定下一个字母</p>
<pre><code>* b: 解题步骤
    * 定义初始化大写变量，值为’A’； 初始化小写变量，值为’a’
    * 使用for循环，进行26次循环
    * 在每次循环中，打印大写字母、小写字母。
        每次打印完成后，更新大写字母值、小写字母值

* c: 案例代码
    public class Test04 {
        public static void main(String[] args) {
            char da = &apos;A&apos;;
            char xiao = &apos;a&apos;;
            for (int i = 0; i &lt; 26; i++) {
                System.out.println(&quot;大写字母 &quot;+da+&quot; ,小写字母 &quot;+xiao);
                da++; //更新大写字母值
                xiao++; //更新小写字母值
            }
        }
    }</code></pre><p>###0699乘法表的分析<br>    * A: 99乘法表的分析<br>        * a: 打印格式<br>            1<em>1=1<br>            1<em>2=2  2</em>2=4<br>            1<em>3=3  2</em>3=6  3<em>3=9<br>        * b: 题目分析<br>            通过观察发现，如果把1</em>1=1这样的内容 看做一颗<em>的话，那么打印结果就成了如下效果：<br>            *<br>            *</em><br>            <strong>*<br>            **</strong><br>            …<br>            这样，就是打印9行星，每行打印星的个数与当前行数相等。<br>            再观察“1<em>3=3 2</em>3=6 3*3=9”得出它们如下的变化规律：<br>                    每行第n次 +”</em>“+ 行号 +”=”+ 每行第n次 * 行号<br>                如:    1    +”*”+  2    +”=”+   1<em>2; // 相当于1*2=2<br>                    2    +”</em>“+  2    +”=”+   2<em>2; // 相当于2</em>2=4    </p>
<pre><code>* c: 解题步骤
    * 定义一个外层for循环，初始值从1开始，循环9次。用来控制打印的行数
    * 在外层for循环内部，定义一个for循环，初始值从1开始，循环次数与当前行数相等。用来完成每行打印指定次数的乘法公式 如1*1=1
    * 在内层for循环中，完成每行指定次数的乘法公式打印 如1*1=1
        System.out.print(k +&quot;*&quot;+ j +&quot;=&quot;+ j*k +&quot;\t&quot;);
        // 变量k代表：每行中的第n次
        // 变量j代表：行号
    * 在外循环中，当每行指定次数的乘法公式打印完毕后，通过System.out.println()切换到下一行。
        这样，再次打印乘法公式时，就在下一行输出打印了</code></pre><p>###0799乘法表的功能实现<br>    * A: 99乘法表的功能实现<br>        * a: 案例代码<br>            /*<br>                利用嵌套for循环,实现99乘法表示<br>                实现步骤:<br>                  1. 定义外循环控制行数<br>                  2. 内循环控制个数,个数,每次都在递增<br>                  3. 循环中输出,乘法表的格式   1*3=3<br>            */</p>
<pre><code>public class Test05 {
    public static void main(String[] args) {
        for (int j = 1; j &lt; 10; j++) {
            for (int k = 1; k &lt;= j; k++) {
                System.out.print(k +&quot;*&quot;+ j +&quot;=&quot;+ j*k +&quot;\t&quot;);
            }
            System.out.println();
        }
    }
}</code></pre><p>​                </p>
<p>###day07_08(基础语法)实现数组的遍历.avi(14:18)<br>###day07_09(基础语法)数组逆序原理.avi(17:55)<br>###day07_10(基础语法)数组逆序功能实现.avi(9:45)<br>###day07_11(基础语法)选择排序原理.avi(14:01)<br>###day07_12(基础语法)选择排序功能实现.avi(09:07)<br>###day07_13(基础语法)冒泡排序功能实现.avi(16:00)<br>###day07_14(基础语法)数组的折半查找原理.avi(13:15)<br>###day07_15(基础语法)数组的折半查找代码实现.avi(8:23)</p>
<p>###08实现数组的遍历<br>    * A: 实现数组的遍历<br>        * a: 题目分析<br>            * 通过循环，我们可以完成数组中元素的获取，数组名[索引]<br>            * 观察发现，每个数组元素之间加入了一个逗号”,”进行分隔；并且，整个数组的前后有一对中括号”[]”包裹数组所有元素。</p>
<pre><code>* b: 解题步骤
    * 使用输出语句完成打印 左边的中括号”[”
    * 使用循环，输出数组元素值。输出元素值分为两种情况，如下：
        * 最后一个数组元素，加上一个右边的中括号”]”
        * 非最后一个数组元素，加上一个逗号”,”

* c: 案例代码
    /*
        定义方法,实现数组的遍历
        遍历中,输出结果  [11,33,565,66,78,89]
        int[] arr = {3,4,45,7};
        结果包含字符串, [  ]  ,
        实现步骤:
          1. 定义方法实现数组的遍历
          2. 先打印[ 中括号
          3. 遍历数组
            输出数组的元素和逗号
            判断是否遍历到了数组的最后一个元素,如果是最后一个元素,输出]中括号
    */
    public class ArrayMethodTest{
        public static void main(String[] args){
            int[] arr = {11,44,55,33,66};
            printArray(arr);

            int[] arr2 = {22,88,99,33,66};
            printArray(arr2);

        }
        /*
           定义方法,实现功能
           返回值: void
           方法参数: 数组
        */
        public static void printArray(int[] arr){
            //输出一半中括号,不要换行打印
            System.out.print(&quot;[&quot;);
            //数组进行遍历
            for(int i = 0 ; i &lt; arr.length ; i++){
                //判断遍历到的元素,是不是数组的最后一个元素
                //如何判断 循环变量 到达 length-1
                if( i == arr.length-1 ){
                    //输出数组的元素和]
                    System.out.print(arr[i]+&quot;]&quot;);
                }else{
                //不是数组的最后一个元素,输出数组元素和逗号
                    System.out.print(arr[i]+&quot;,&quot;);
                }
            }
            System.out.println();
        }
    }</code></pre><p>###09数组逆序原理<br>    * A: 数组逆序原理<br>        * a: 题目分析(图解见day07_source/数组的逆序原理.JPG)<br>            * 通过观察发现，本题目要实现原数组元素倒序存放操作。即原数组存储元素为{11,22,33,44}，<br>                逆序后为原数组存储元素变为{44,33,22,11}。<br>            * 通过图解发现，想完成数组元素逆序，其实就是把数组中索引为start与end的元素进行互换。<br>            * 每次互换后，start索引位置后移，end索引位置前移，再进行互换<br>            * 直到start位置超越了end位置，互换结束，此时，数组元素逆序完成。</p>
<pre><code>* b: 解题步骤
    * 定义两个索引变量start值为0，变量end值为数组长度减去1（即数组最后一个元素索引）
    * 使用循环，完成数组索引start位置元素与end位置元素值互换。
    * 在循环换过程中，每次互换结束后，start位置后移1，end位置前移1
    * 在循环换过程中，最先判断start位置是否超越了end位置，若已超越，则跳出循环</code></pre><p>​<br>###10数组逆序功能实现<br>    * A：案例代码<br>        /*<br>           数组的逆序:<br>             数组中的元素,进行位置上的交换<br>             逆序 不等于 反向遍历<br>             就是数组中最远的两个索引,进行位置交换,实现数组的逆序<br>             使用的是数组的指针思想,就是变量,思想,可以随时变换索引<br>             反转 reverse<br>             实现步骤:<br>               1. 定义方法,实现数组的逆序<br>               2. 遍历数组<br>                 实现数组的最远索引换位置<br>                 使用临时的第三方变量<br>        */<br>        public class ArrayMethodTest_1{<br>            public static void main(String[] args){<br>                int[] arr = {3,5,7,1,0,9,-2};<br>                //调用数组的逆序方法<br>                reverse(arr);<br>                //看到数组的元素,遍历<br>                printArray(arr);<br>            }</p>
<pre><code>    /*
       定义方法,实现数组的逆序
       返回值: 没有返回值
       参数:   数组就是参数
    */
    public static void reverse(int[] arr){
        //利用循环,实现数组遍历,遍历过程中,最远端换位
        //for的第一项,定义2个变量, 最后,两个变量++ --
        for( int min = 0 , max = arr.length-1 ; min &lt; max  ; min++,max--){
            //对数组中的元素,进行位置交换
            //min索引和max索引的元素交换
            //定义变量,保存min索引
            int temp = arr[min];
            //max索引上的元素,赋值给min索引
            arr[min] =  arr[max];
            //临时变量,保存的数据,赋值到max索引上
            arr[max] = temp;
        }
    }
}</code></pre><p>###11选择排序原理<br>    * A: 选择排序原理<br>        * a: 题目分析(图解见day07_source/选择排序原理.JPG)<br>            * 通过观察发现，本题目要实现把数组元素{13,46,22,65,3}进行排序<br>            * 提到数组排序，就要进行元素值大小的比较，通过上图发现，我们想完成排序要经过若干次的比较才能够完成。<br>            * 上图中用每圈要比较的第一个元素与该元素后面的数组元素依次比较到数组的最后一个元素，把小的值放在第一个数组元素中，数组循环一圈后，则把最小元素值互换到了第一个元素中。<br>            * 数组再循环一圈后，把第二小的元素值互换到了第二个元素中。按照这种方式，数组循环多圈以后，就完成了数组元素的排序。这种排序方式我们称为选择排序。</p>
<p>​<br>        * b: 解题步骤<br>            * 使用for循环（外层循环），指定数组要循环的圈数（通过图解可知，数组循环的圈数为数组长度 - 1）<br>            * 在每一圈中，通过for循环（内层循环）完成数组要比较的第一个元素与该元素后面的数组元素依次比较到数组的最后一个元素，把小的值放在第一个数组元素中<br>            * 在每一圈中，要参与比较的第一个元素由第几圈循环来决定。如上图所示<br>                * 进行第一圈元素比较时，要比较的第一个元素为数组第一个元素，即索引为0的元素<br>                * 进行第二圈元素比较时，要比较的第一个元素为数组第二个元素，即索引为1的元素<br>                * 依次类推，得出结论：进行第n圈元素比较时，要比较的第一个元素为数组第n个元素，即数组索引为n-1的元素</p>
<p>###12选择排序功能实现<br>    * A: 案例代码<br>        /*<br>          数组的排序: 一般都是升序排列,元素,小到大的排列</p>
<pre><code>  两种排序的方式
     选择排序: 数组的每个元素都进行比较
     冒泡排序: 数组中相邻元素进行比较
     规则: 比较大小,位置交换
*/
public class ArrayMethodTest_2{
    public static void main(String[] args){
        int[] arr  = {3,1,4,2,56,7,0};
        //调用选择排序方法
        //selectSort(arr);
        printArray(arr);
    }
    /*
        定义方法,实现数组的选择排序
        返回值: 没有
        参数:  数组
        实现步骤:
          1.嵌套循环实现排序
            外循环,控制的是一共比较了多少次
            内循环,控制的是每次比较了多少个元素
          2. 判断元素的大小值
            小值,存储到小的索引
    */
    public static void selectSort(int[] arr){
        for(int i = 0 ; i &lt; arr.length - 1; i++){
            //内循环,是每次都在减少,修改变量的定义
            for(int j = i+1 ; j &lt; arr.length ; j++){
                //数组的元素进行判断
                if(arr[i] &gt; arr[j]){
                    //数组的换位
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp; 
                }
            }
        }
    }

    /*
       定义方法,实现功能
       返回值: void
       方法参数: 数组
    */
    public static void printArray(int[] arr){
        //输出一半中括号,不要换行打印
        System.out.print(&quot;[&quot;);
        //数组进行遍历
        for(int i = 0 ; i &lt; arr.length ; i++){
            //判断遍历到的元素,是不是数组的最后一个元素
            //如何判断 循环变量 到达 length-1
            if( i == arr.length-1 ){
                //输出数组的元素和]
                System.out.print(arr[i]+&quot;]&quot;);
            }else{
            //不是数组的最后一个元素,输出数组元素和逗号
                System.out.print(arr[i]+&quot;,&quot;);
            }
        }
        System.out.println();
    }
}</code></pre><p>###13冒泡排序功能实现<br>    * A: 冒泡排序功能实现<br>            * a: 题目分析<br>                * 通过观察发现，本题目要实现把数组元素{13,46,22,65,3}进行排序<br>                * 提到数组排序，就要进行元素值大小的比较，通过上图发现，我们想完成排序要经过若干次的比较才能够完成。<br>                * 上图中相邻的元素值依次比较，把大的值放后面的元素中，数组循环一圈后，则把最大元素值互换到了最后一个元素中。<br>                    数组再循环一圈后，把第二大的元素值互换到了倒数第二个元素中。按照这种方式，数组循环多圈以后，<br>                    就完成了数组元素的排序。这种排序方式我们称为冒泡排序。</p>
<pre><code>* b: 解题步骤
    * 使用for循环（外层循环），指定数组要循环的圈数（通过图解可知，数组循环的圈数为数组长度 - 1）
    * 在每一圈中，通过for循环（内层循环）完成相邻的元素值依次比较，把大的值放后面的元素中
    * 每圈内层循环的次数，由第几圈循环来决定。如上图所示
        * 进行第一圈元素比较时，内层循环次数为数组长度 - 1
        * 进行第二圈元素比较时，内层循环次数为数组长度 - 2
        * 依次类推，得出结论：进行第n圈元素比较时，内层循环次数为数组长度 - n

* c: 案例代码    
    /*
      数组的排序: 一般都是升序排列,元素,小到大的排列

      两种排序的方式
         选择排序: 数组的每个元素都进行比较
         冒泡排序: 数组中相邻元素进行比较
         规则: 比较大小,位置交换
    */
    public class ArrayMethodTest_2{
        public static void main(String[] args){
            int[] arr  = {3,1,4,2,56,7,0};
            //调用选择排序方法
            //selectSort(arr);

            //调用冒泡排序方法
            bubbleSort(arr);
            printArray(arr);
        }
        /*
           定义方法,实现数组的冒泡排序
           返回值: 没有
            参数:  数组
        */
        public static void bubbleSort(int[] arr){
            for(int i = 0 ; i &lt; arr.length - 1; i++){
                //每次内循环的比较,从0索引开始, 每次都在递减
                for(int j = 0 ; j &lt; arr.length-i-1; j++){
                    //比较的索引,是j和j+1
                    if(arr[j] &gt; arr[j+1]){
                        int temp = arr[j];
                        arr[j] = arr[j+1];
                        arr[j+1] = temp;
                    }
                }
            }
        }

        /*
           定义方法,实现功能
           返回值: void
           方法参数: 数组
        */
        public static void printArray(int[] arr){
            //输出一半中括号,不要换行打印
            System.out.print(&quot;[&quot;);
            //数组进行遍历
            for(int i = 0 ; i &lt; arr.length ; i++){
                //判断遍历到的元素,是不是数组的最后一个元素
                //如何判断 循环变量 到达 length-1
                if( i == arr.length-1 ){
                    //输出数组的元素和]
                    System.out.print(arr[i]+&quot;]&quot;);
                }else{
                //不是数组的最后一个元素,输出数组元素和逗号
                    System.out.print(arr[i]+&quot;,&quot;);
                }
            }
            System.out.println();
        }
    }</code></pre><p>###14数组的折半查找原理<br>    * A: 数组的折半查找原理(图解见day07_source/折半查找原理.JPG)<br>            * a: 题目分析<br>                * 通过观察发现，本题目要实现查找指定数值在元素有序的数组中存储的位置（索引），返回该位置（索引）。<br>                * 我们使用数组最中间位置的元素值与要查找的指定数值进行比较，若相等，返回中间元素值的索引<br>                * 最中间位置的元素值与要查找的指定数值进行比较，若不相等，则根据比较的结果，缩小查询范围为上次数组查询范围的一半；<br>                    再根据新的查询范围，更新最中间元素位置，然后使用中间元素值与要查找的指定数值进行比较<br>                        比较结果相等，返回中间元素值的索引<br>                        比较结果不相等，继续缩小查询范围为上次数组查询范围的一半，更新最中间元素位置，继续比较，依次类推。<br>                * 当查询范围缩小到小于0个元素时，则指定数值没有查询到，返回索引值-1。</p>
<pre><code>* b: 解题步骤
    * 定义3个用来记录索引值的变量，变量min记录当前范围最小索引值，初始值为0；变量max记录当前范围最大索引值，初始值为数组长度-1；变量mid记录当前当前范围最中间元素的索引值，初始值为(min+max) / 2
    * 使用循环，判断当前范围下，最中间元素值与指定查找的数值是否相等
        若相等，结束循环，返回当前范围最中间元素的索引值mid
        若不相等，根据比较结果，缩小查询范围为上一次查询范围的一般
        中间元素值 比 要查询的数值大，说明要查询的数值在当前范围的最小索引位置与中间索引位置之间，此时，更新查询范围为:
            范围最大索引值 = 上一次中间索引位置 -1；
        中间元素值 比 要查询的数值小，说明要查询的数值在当前范围的最大索引位置与中间索引位置之间，此时，更新查询范围为:
            范围最小索引值 = 上一次中间索引位置 +1；
        在新的查询范围中，更新中间元素值的位置，再次使用最中间元素值与指定查找的数值是否相等。
            中间索引值 = (范围最小索引值 +范围最大索引值) / 2;
    * 每次查询范围缩小一半后，使用if语句判断，查询范围是否小于0个元素，若小于0个元素，则说明指定数值没有查询到，返回索引值-1。</code></pre><p>###15数组的折半查找代码实现<br>    * A: 案例代码<br>        /*<br>           数组的查找功能<br>             在一个数组中,找一个元素,是否存在于数组中,如果存在,就返回索引</p>
<pre><code>     普通查询:
       找到元素在数组中出现的索引,如果没有这个 元素,结果就是负数

*/
public class ArrayMethodTest_3{
     public static void main(String[] args){
         int[] arr = {1,3,5,7,9,11,15};
         int index = binarySearch(arr,10);
         System.out.println(index);

     }

     /*
         定义方法,实现,折半查找
         返回值: 索引
         参数: 数组,被找的元素 
         实现步骤:
           1. 需要的变量定义
              三个,三个指针

           2. 进行循环折半
              可以折半的条件  min &lt;= max

           3. 让被找元素,和中间索引元素进行比较
               元素 &gt; 中间索引  小指针= 中间+1
               元素 &lt; 中间索引  大指针= 中间-1
               元素 == 中间索引  找到了,结束了,返回中间索引

            4. 循环结束,无法折半
              元素没有找到 ,返回-1
     */
     public static int binarySearch(int[] arr, int key){
         //定义三个指针变量
         int min = 0 ;
         int max = arr.length -1 ;
         int mid = 0;
         //循环折半,条件 min&lt;=max
         while( min &lt;= max){
             //公式,计算中间索引
             mid = (min+max)/2;
             //让被找元素,和中间索引元素进行比较
             if(key &gt; arr[mid]){
                 min = mid + 1;
             }else if (key &lt; arr[mid]){
                 max = mid - 1;
             }else{
                 //找到元素,返回元素索引
                 return mid;
             }
         }
         return -1;
     }

    /*
       定义方法,实现数组的普通查询
       返回值: 索引
       参数:   数组, 被找的元素

       实现步骤:
         1. 遍历数组
         2. 遍历过程中,使用元素和数组中的元素进行比较
            如果相同,返回元素在数组中的索引
            如果不同,返回负数
    */
    public static int search(int[] arr, int key){
        //遍历数组
        for(int i = 0 ; i &lt; arr.length ; i++){
            //数组元素,被查找的元素比较
            if(arr[i] == key){
                //返回索引
                return i;
            }
        }
        return -1;
    }
}</code></pre><p>###16总结</p>
<ul>
<li>把今天的知识点总结一遍。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day06%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day06%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:01:38" itemprop="dateModified" datetime="2020-12-23T23:01:38+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、自定义类型的定义及使用<br>2、自定义类的内存图<br>3、ArrayList集合的基本功能<br>4、随机点名器案例及库存案例代码优化</p>
<p>###01引用数据类型_类<br>    * A: 数据类型<br>        * a: java中的数据类型分为：基本类型和引用类型<br>    * B: 引用类型的分类<br>        * a: Java为我们提供好的类，比如说：Scanner,Random等。<br>        * b: 我们自己创建的类，按照类的定义标准，可以在类中包含多个方法与属性，来供我们使用。 </p>
<p>​<br>###02自定义类的概述<br>    * A: 自定义类的概述<br>        * java代码映射成现实事物的过程就是定义类的过程。<br>        * 举例：<br>            我们就拿一部手机进行分析，它能用来做什么呢？它可以打电话，上网，聊微信等，这些就是手机所提供的功能，也就是方法；手机也有它的特征，如颜色、尺寸大小、品牌型号等，这些就是手机的特征，也就是属性<br>        * 目前，我们只关注类中的属性，类中的方法在面向对象部分再进行学习。</p>
<p>​<br>###03自定义类的格式<br>    * A: 自定义类的格式<br>        * a: 使用类的形式,对现实中的事物进行描述。<br>        * b: 事物由方法和属性两部分组成。<br>            * 方法: 这个事物具备的功能。<br>            * 属性: 这个事物具备的特征。<br>        * c: 格式<br>            public class 类名{<br>                属性定义<br>                  修饰符 数据类型 变量名 = 值</p>
<pre><code>    方法定义
      修饰符 返回值类型  方法名(参数列表){

      }
}</code></pre><p>###04自定义的手机类<br>    * A: 自定义的手机类<br>        * a: 案例代码<br>            public class Phone{<br>                /*<br>                    定义手机的属性<br>                */<br>                String color ;<br>                String brand ;<br>                double size ;<br>            }</p>
<p>###05测试手机类<br>    * A: 调用方法执行流程<br>        * a: 实现引用类型的步骤<br>            * 1: 导入包 , 类都是在同一个文件夹,不需要导入包<br>            * 2: 创建引用类型的变量<br>            * 3: 变量.类型中的功能<br>        * b: 案例代码<br>            public class TestPhone{<br>                public static void main(String[] args){<br>                    // 2: 创建引用类型的变量<br>                    Phone p = new Phone();<br>                    //System.out.println(p);  //输出内存的地址</p>
<pre><code>         //3: 变量.类型中的功能
        //变量 p.的方式,调用类中的属性
        //属性就是变量 , 赋值和获取值
        p.color = &quot;土豪金&quot;;
        p.brand = &quot;爱立信&quot;;
        p.size = 5.0;

        //获取属性值
        System.out.println(p.color+&quot;  &quot;+p.brand+&quot;  &quot;+p.size);
    }
}</code></pre><p>###06自定义类的内存图_1<br>    * A: 自定义类的内存图_1<br>        * a: 参见\day06\day06(面向对象\day06_source\对象内存图.JPG</p>
<p>###07自定义类的内存图_2<br>    * A: 自定义类的内存图_1<br>        * a: 参见\day06\day06(面向对象\day06_source\对象内存图.JPG</p>
<p>###08两个引用类型变量内存图<br>    * A: 自定义类的内存图_1<br>        * a: 参见\day06\day06(面向对象\day06_source\两个引用变量内存图.JPG</p>
<p>###09自定义类的练习<br>    * A: 实体类的代码<br>        /*<br>            电饭锅，包含属性（品牌、容量大小、颜色等）<br>            定义类,描述事物,电饭锅<br>              属性: 品牌,大小 ,颜色</p>
<pre><code>        定义类,类名字,电饭锅
        类的范围,定义三个属性
    */
    public class DianFanGuo{
        //定义三个属性
        String brand ;
        double size ;
        String color ;
    }

    /*
       汽车，包含属性（品牌、排量、类型等）
       定义类,类名 Car
         属性 品牌 排量 类型
     */
    public class Car{
        //定义汽车三个属性
        String brand ;
        double paiLiang ;
        String type;
    }

     /*
       学生，包含属性（姓名，年龄，性别等）
       定义类,类名Student
         三个属性: 姓名,年龄,性别 (char)
    */
    public class Student{
        String name;
        int age ;
        char sex ;
    }

* B: 测试类的代码
    /*
       定义的测试类
       同时测试,电饭锅,汽车,学生
    */
    public class Test{
        public static void main(String[] args){
            //创建电饭锅引用类型
            DianFanGuo dfg = new DianFanGuo();

            dfg.brand = &quot;特斯拉&quot;;
            dfg.color = &quot;红色&quot;;
            dfg.size = 30;

            System.out.println(dfg.brand+&quot;  &quot;+dfg.color+&quot;  &quot;+dfg.size);

            //创建汽车引用类型
            Car c = new Car();
            c.brand = &quot;巨力&quot;;
            c.type = &quot;拖拉机&quot;;
            c.paiLiang = 0.5;

            System.out.println(c.brand+&quot;  &quot;+c.type+&quot;  &quot;+c.paiLiang);

            //创建学生引用类型
            Student stu = new Student();
            stu.name = &quot;张三&quot;;
            stu.age = 20;
            stu.sex = &apos;男&apos;;
            System.out.println(stu.name+&quot;  &quot;+stu.age+&quot;  &quot;+stu.sex);

        }
    }</code></pre><p>​<br>###10ArrayList创建变量的步骤<br>    * A: ArrayList创建变量的步骤<br>        * a: 导入包 java.util包中<br>        * b: 创建引用类型的变量<br>            数据类型&lt; 集合存储的数据类型&gt;  变量名 = new 数据类型&lt;集合存储的数据类型&gt;();<br>               集合存储的数据类型: 要将数据存储到集合的容器中<br>               创建集合引用变量的时候,必须要指定好,存储的类型是什么<br>        * c: 变量名.方法<br>            注意: 集合存储的数据,8个基本类型对应8个引用类型<br>             存储引用类型,不存储基本类型</p>
<p>###11ArrayList创建变量举例<br>    * A: ArrayList创建变量的示例代码<br>        import java.util.ArrayList;<br>        public class ArrayListDemo{<br>            public static void main(String[] args){<br>                //创建集合容器,指定存储的数据类型<br>                //存储字符串<br>                ArrayList<String> array = new ArrayList<String>();</String></String></p>
<pre><code>        //创建集合容器,存储整数
        ArrayList&lt;Integer&gt; array2 = new ArrayList&lt;Integer&gt;();

        //创建集合容器,存储手机类型
        ArrayList&lt;Phone&gt; array3 = new ArrayList&lt;Phone&gt;();
    }
}</code></pre><p>###12ArrayList的常见方法<br>    * A: ArrayList的常见方法<br>        * a: add(参数) 向集合中添加元素<br>        * b: get(int index) 取出集合中的元素,get方法的参数,写入索引<br>        * c: size() 返回集合的长度, 集合存储元素的个数<br>    * B: 案例代码<br>        import java.util.ArrayList;<br>        public class ArrayListDemo_1{<br>            public static void main(String[] args){<br>                //定义集合,存储字符串元素<br>                ArrayList<String> array = new ArrayList<String>();<br>                //调用集合方法add存储元素<br>                array.add(“abc”);<br>                array.add(“itcast”);<br>                array.add(“love”);<br>                array.add(“java”);<br>                //输出集合的长度,调用集合方法size, size方法的返回值类型 int<br>                int size = array.size();<br>                System.out.println(size);</String></String></p>
<pre><code>//获取出集合中的一个元素,获取1索引的元素
//集合的方法get, 获取元素后结果数据类型
String s = array.get(1);
System.out.println(s);</code></pre><p>​<br>                System.out.println(array.get(0));<br>                System.out.println(array.get(1));<br>                System.out.println(array.get(2));<br>                System.out.println(array.get(3));<br>            }<br>        }</p>
<p>###13ArrayList集合的遍历<br>    * A: 案例代码<br>        /*<br>           集合的遍历<br>           实现思想也是索引思想<br>           集合的索引从0开始,到 size()-1<br>           方法get(int index)<br>        */<br>        import java.util.ArrayList;<br>        public class ArrayListDemo_2{<br>            public static void main(String[] args){<br>                ArrayList<Integer> array = new ArrayList<Integer>();<br>                array.add(121);<br>                array.add(125);<br>                array.add(123);<br>                array.add(120);<br>                array.add(128);</Integer></Integer></p>
<pre><code>        //对集合进行遍历
        //使用方法 size+get组合进行遍历
        for(int i = 0 ; i &lt; array.size(); i++){
            System.out.println( array.get(i) );
        }
    }
}</code></pre><p>###14ArrayList补充方法<br>    * A: ArrayList补充方法<br>        * a: add(int 索引,存储的元素)     将元素添加到指定的索引上<br>        * b: set(int 索引,修改后的元素)     将指定索引的元素,进行修改<br>        * c: remove(int 索引)             删除指定索引上的元素<br>        * d: clear()                     清空集合中的所有元素<br>    * B: 案例代码<br>        import java.util.ArrayList;<br>        public class ArrayListDemo_3{<br>            public static void main(String[] args){</p>
<pre><code>        ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;();
        array.add(1);
        array.add(2);
        array.add(3);
        array.add(4);

        //在索引2上,添加元素7
        array.add(2,7);

        //将0索引上的元素,修改成10
        array.set(0,10);

        //将4索引上的元素,删除
        array.remove(4);

        array.clear();

        //使用方法 size+get组合进行遍历
        for(int i = 0 ; i &lt; array.size(); i++){
            System.out.println( array.get(i) );
        }
    }
}</code></pre><p>###15随机点名器案例分析<br>    * A: 随机点名器案例分析<br>        全班同学中随机的找出一名同学，打印这名同学的个人信息。<br>        我们对本案例进行分析，得出如下分析结果：<br>            1.存储全班同学信息（姓名、年龄）<br>                将容器换成集合，集合中存的是Student类型<br>            2.打印全班同学每一个人的信息（姓名、年龄）<br>                 遍历集合<br>            3.在班级总人数范围内，随机产生一个随机数，查找该随机数所对应的同学信息（姓名、年龄）<br>            随机点名器明确地分为了三个功能。如果将多个独立功能的代码写到一起，则代码相对冗长，我们可以针对不同的功能可以将其封装到一个方法中，将完整独立的功能分离出来。<br>            而在存储同学姓名时，如果对每一个同学都定义一个变量进行姓名存储，则会出现过多孤立的变量，很难一次性将全部数据持有。此时，我们采用ArrayList集合来解决多个学生信息的存储问题</p>
<p>###16随机点名器代码实现<br>    * A: 随机点名器案例代码<br>        /*<br>           随机点名器,集合改进 (学生的姓名和年龄)<br>           现实中有学生这个事物,使用定义类的形式,描述学生事物<br>           属性: 姓名,年龄</p>
<pre><code>   姓名存储了数组, 将容器换成是集合
   String[] s = {&quot;&quot;,&quot;&quot;};
   集合中,存储的是学生的姓名吗?  应该存储Student类型

   存储学生:
      学生类型,存储到集合中
   总览: 遍历集合
   随机: 随机数,作为索引,到集合中找到元素
   三个功能,共享的数据,集合容器,
   定义三个方法,必须参数传递集合
*/
import java.util.ArrayList;
import java.util.Random;
public class CallName{
    public static void main(String[] args){
        //定义集合,存储的是StudentName类型变量
        ArrayList &lt;StudentName&gt; array = new ArrayList&lt;StudentName&gt;();
        //调用添加方法
        add (array);
        //调用遍历集合
        printArrayList(array);

        randomStudentName(array);
    }
    /*
      随机数,当作集合的索引,到集合中找到元素
    */
    public static void randomStudentName(ArrayList&lt;StudentName&gt; array ){
        Random r = new Random();
        int number = r.nextInt( array.size());
        //随机数,索引,到集合中get
        StudentName s = array.get(number);
        System.out.println( s.name +&quot;  &quot;+s.age);
    }

    /*
        总览学生的信息,遍历集合
    */
    public static void printArrayList(ArrayList&lt;StudentName&gt; array){
        for(int i = 0 ; i &lt; array.size();i++){
            //存储集合的时候, 集合.add(sn1)  sn1 是StudentName类型变量
            //获取的时候,集合.get方法,获取出来的是什么, 还是StudentName类型变量
            StudentName s = array.get(i);
            System.out.println(s.name+&quot;  &quot;+s.age);
        }
    }

    /*
       定义方法,实现存储学生的姓名和年龄
       创建StudentName类型变量,存储到集合中
    */
    public static void add (ArrayList&lt;StudentName&gt; array){
        //创建StudentName类型变量
        StudentName sn1 = new StudentName();
        StudentName sn2 = new StudentName();
        StudentName sn3 = new StudentName();
        StudentName sn4 = new StudentName();
        StudentName sn5 = new StudentName();

        sn1.name = &quot;张三1&quot;;
        sn1.age = 201;

        sn2.name = &quot;张三2&quot;;
        sn2.age = 202;

        sn3.name = &quot;张三3&quot;;
        sn3.age = 203;

        sn4.name = &quot;张三4&quot;;
        sn4.age = 204;

        sn5.name = &quot;张三5&quot;;
        sn5.age = 205;

        //将StudentName变量,存储到集合中
        array.add(sn1);
        array.add(sn2);
        array.add(sn3);
        array.add(sn4);
        array.add(sn5);
    }
}</code></pre><p>###17库存案例分析加入集合<br>    * A: 库存案例分析加入集合<br>        * a: 参见\day06\day06(面向对象\day06_source\对象内存图.JPG</p>
<p>###18库存案例添加商品信息<br>    * A: 案例代码<br>        /*<br>           定义,.描述商品的类<br>           商品 4个属性<br>             商品名字  大小     价格    库存<br>              String    double   double  int</p>
<pre><code>    定义类,类名Goods
    这个类型的变量,存储到集合中
*/
public class Goods{
    //定义商品名字
    String brand ;
    //大小属性
    double size ;
    // 价格属性
    double price ;
    //库存属性
    int count ;
}

/*
    实现库存管理案例:
      1.存储商品信息
        存储商品类型变量
        将商品类型的变量,存储到集合中
*/
//import java.util.ArrayList;
import java.util.*;
public class Shopp{
    public static void main(String[] args){
        //创建ArrayList集合,存储Goods类型
        ArrayList&lt;Goods&gt; array = new ArrayList&lt;Goods&gt;();
        //调用添加商品信息的方法
        addGoods(array);
    }

    /*
       定义方法,将商品的信息存储到集合中
       集合是所有方法的共享数据,参数传递
    */
    public static void addGoods (ArrayList&lt;Goods&gt; array){
        //创建商品类型变量 Goods类型的变量
        Goods g1 = new Goods();
        Goods g2 = new Goods();
        g1.brand = &quot;MacBook&quot;;
        g1.size = 13.3;
        g1.price = 9999.99;
        g1.count = 3;

        g2.brand = &quot;Thinkpad&quot;;
        g2.size = 15.6;
        g2.price = 7999.99;
        g2.count = 1;

        //Goods类型的变量,存储到集合中
        array.add(g1);
        array.add(g2);
    }
}</code></pre><p>###19库存案例查看库存清单<br>    * A: 案例代码<br>        /*<br>            实现库存管理案例:<br>              1.存储商品信息<br>                存储商品类型变量<br>                将商品类型的变量,存储到集合中</p>
<pre><code>      2.查看库存清单
        将集合进行遍历, 获取出集合中存储的Goods类型变量
        输出每一个Goods类型的属性
        计算求和: 总库存,总金额
*/
//import java.util.ArrayList;
import java.util.*;
public class Shopp{
    public static void main(String[] args){
        //创建ArrayList集合,存储Goods类型
        ArrayList&lt;Goods&gt; array = new ArrayList&lt;Goods&gt;();
        //调用添加商品信息的方法
        addGoods(array);
    }

    /*
       定义方法,查看库存清单,遍历集合
    */
    public static void printStore(ArrayList&lt;Goods&gt; array){
        //输出表头
        System.out.println(&quot;----------商场库存清单----------&quot;);
        System.out.println(&quot;品牌型号     尺寸    价格    库存数&quot;);
        //定义变量,保存总库存数,和总金额
        int totalCount = 0 ;
        double totalMoney = 0;
        //遍历集合
        for(int i = 0 ; i &lt; array.size(); i++){
            //get(索引)获取出集合中的元素,存储的是Goods类,获取的也是Goods类型
            //使用Goods类型变量,接受get方法结果
            Goods g = array.get(i);
            System.out.println(g.brand+&quot;   &quot;+g.size+&quot;    &quot;+g.price+&quot;    &quot;+g.count);
            totalCount = totalCount+g.count;
            totalMoney = totalMoney + g.count*g.price;
        }
        System.out.println(&quot;总库存数: &quot;+totalCount);
        System.out.println(&quot;商品库存总金额: &quot;+totalMoney);
    }

    /*
       定义方法,将商品的信息存储到集合中
       集合是所有方法的共享数据,参数传递
    */
    public static void addGoods (ArrayList&lt;Goods&gt; array){
        //创建商品类型变量 Goods类型的变量
        Goods g1 = new Goods();
        Goods g2 = new Goods();
        g1.brand = &quot;MacBook&quot;;
        g1.size = 13.3;
        g1.price = 9999.99;
        g1.count = 3;

        g2.brand = &quot;Thinkpad&quot;;
        g2.size = 15.6;
        g2.price = 7999.99;
        g2.count = 1;

        //Goods类型的变量,存储到集合中
        array.add(g1);
        array.add(g2);
    }
}</code></pre><p>###20库存案例修改库存清单及测试代码的实现<br>    * A: 案例代码<br>        /*<br>            实现库存管理案例:<br>              1.存储商品信息<br>                存储商品类型变量<br>                将商品类型的变量,存储到集合中</p>
<pre><code>      2.查看库存清单
        将集合进行遍历, 获取出集合中存储的Goods类型变量
        输出每一个Goods类型的属性
        计算求和: 总库存,总金额

     3.修改商品的库存
        集合遍历 ,获取出集合中存储的Goods类型变量
        变量调用Goods类的属性count,值进行修改 (键盘输入)
*/
//import java.util.ArrayList;
import java.util.*;
public class Shopp{
    public static void main(String[] args){
        //创建ArrayList集合,存储Goods类型
        ArrayList&lt;Goods&gt; array = new ArrayList&lt;Goods&gt;();
        //调用添加商品信息的方法
        addGoods(array);
        //进入死循环中
        while(true){
            //调用选择功能的方法,获取到用户输入的功能序号
            int number = chooseFunction();
            //对序号判断,如果=1 进入查看库存功能  = 2 进入修改库存功能  =3 结束
            switch(number){
                case 1:
                //进入查看库存,调用查看库存的方法,传递存储商品信息的集合
                printStore(array);
                break;

                case 2:
                //进入修改库存功能,调用修改库存的方法,传递集合
                update(array);
                break;

                case 3:
                return ;

                default:
                 System.out.println(&quot;无此功能&quot;);
                 break;
            }
        }
    }
    /*
      方法定义,修改库存
      键盘的输入,将Goods中的属性值,修改
    */
    public static void update(ArrayList&lt;Goods&gt; array){
        Scanner sc = new Scanner(System.in);
        //遍历集合,获取集合中的每个元素
        for(int i = 0 ;  i &lt; array.size(); i++){
            //集合方法get获取的是集合的元素,元素类型Goods
            Goods g = array.get(i);
            System.out.println(&quot;请输入&quot;+g.brand+&quot;的库存数&quot;);
            //Goods属性,count进行修改
            g.count = sc.nextInt();
        }
    }
    /*
       定义方法,实现选择菜单,用户根据功能选择菜单
    */
    public static int chooseFunction(){
        System.out.println(&quot;-------------库存管理------------&quot;);
        System.out.println(&quot;1.查看库存清单&quot;);
        System.out.println(&quot;2.修改商品库存数量&quot;);
        System.out.println(&quot;3.退出&quot;);
        System.out.println(&quot;请输入要执行的操作序号：&quot;);
        Scanner sc = new Scanner(System.in);
        int number = sc.nextInt();
        return number;
    }

    /*
       定义方法,查看库存清单,遍历集合
    */
    public static void printStore(ArrayList&lt;Goods&gt; array){
        //输出表头
        System.out.println(&quot;----------商场库存清单----------&quot;);
        System.out.println(&quot;品牌型号     尺寸    价格    库存数&quot;);
        //定义变量,保存总库存数,和总金额
        int totalCount = 0 ;
        double totalMoney = 0;
        //遍历集合
        for(int i = 0 ; i &lt; array.size(); i++){
            //get(索引)获取出集合中的元素,存储的是Goods类,获取的也是Goods类型
            //使用Goods类型变量,接受get方法结果
            Goods g = array.get(i);
            System.out.println(g.brand+&quot;   &quot;+g.size+&quot;    &quot;+g.price+&quot;    &quot;+g.count);
            totalCount = totalCount+g.count;
            totalMoney = totalMoney + g.count*g.price;
        }
        System.out.println(&quot;总库存数: &quot;+totalCount);
        System.out.println(&quot;商品库存总金额: &quot;+totalMoney);
    }

    /*
       定义方法,将商品的信息存储到集合中
       集合是所有方法的共享数据,参数传递
    */
    public static void addGoods (ArrayList&lt;Goods&gt; array){
        //创建商品类型变量 Goods类型的变量
        Goods g1 = new Goods();
        Goods g2 = new Goods();
        g1.brand = &quot;MacBook&quot;;
        g1.size = 13.3;
        g1.price = 9999.99;
        g1.count = 3;

        g2.brand = &quot;Thinkpad&quot;;
        g2.size = 15.6;
        g2.price = 7999.99;
        g2.count = 1;

        //Goods类型的变量,存储到集合中
        array.add(g1);
        array.add(g2);
    }
}</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day05%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day05%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:01:24" itemprop="dateModified" datetime="2020-12-23T23:01:24+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、方法基础知识<br>2、方法高级内容<br>3、方法案例</p>
<p>###01方法的概述<br>    * A: 为什么要有方法<br>        * 提高代码的复用性<br>    * B: 什么是方法<br>        * 完成特定功能的代码块。 </p>
<p>​<br>###02方法的定义格式<br>    * A: 方法的格式<br>    *<br>            修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2…) {<br>                方法体语句;<br>                return 返回值;<br>            }<br>    * B: 方法的格式说明<br>        * 修饰符：目前就用 public static。后面我们再详细的讲解其他的修饰符。<br>        * 返回值类型：就是功能结果的数据类型。<br>        * 方法名：符合命名规则即可。方便我们的调用。<br>        * 参数：<br>            * 实际参数：就是实际参与运算的。<br>            * 形式参数；就是方法定义上的，用于接收实际参数的。<br>        * 参数类型：就是参数的数据类型<br>        * 参数名：就是变量名<br>        * 方法体语句：就是完成功能的代码。<br>        * return：结束方法的。<br>        * 返回值：就是功能的结果，由return带给调用者。 </p>
<p>​<br>###03定义方法计算面积<br>    * A: 定义方法计算面积<br>        public class MethodDemo{</p>
<pre><code>    public static void main(String[] args){
         //调用方法, 方法执行起来
         // 在方法main中,调用方法 getArea

         int area = getArea(5,6);
         System.out.println(&quot;面积是: &quot;+area);

    }
    /*
       要求: 计算一个长方形的面积
       定义方法解决这个要求
       分析方法定义过程:
          1.明确方法计算后的结果的数据类型 int  定义格式对应的就是返回值类型
          2.方法计算过程中,有没有未知的数据, 宽和长, 未知数据的数据类型 int
              未知数的变量,定义在方法的小括号内
    */
    public static int  getArea(int w, int h){
        //实现方法的功能主体
        //int area = w * h;
        return w * h;
    }
}</code></pre><p>###04调用方法<br>    * A: 调用方法<br>        * a: 在main函数中调用方法，让方法执行起来<br>        * b: 方法的形参<br>            * 方法要什么参数我们就给什么类型的参数。<br>        * c: 方法的返回值<br>            * 方法返回什么类型的值我们就用对应的数据类型的变量来接收</p>
<p>###05调用方法执行流程<br>    * A: 调用方法执行流程<br>        * a: 方法的定义是没有顺序的，写在main函数的上边或者下边都可以。<br>        * b: 方法的执行，是把实参传递给形参，从而来执行的。<br>        * c: 方法只有被调用才会执行。</p>
<p>###06方法调用的内存图<br>    * A: 方法调用的内存图<br>        * a: 参见\day05\day05(Java基础语法)\day05_source\方法内存图.JPG</p>
<p>###07方法调用的练习<br>    * A: 案例代码<br>        /*<br>           方法的定义练习<br>        */<br>        import java.util.Scanner;<br>        public class MethodDemo_1{<br>            public static void main(String[] args){<br>                //printRect();<br>                //int number = getNumber();<br>                //System.out.println(getNumber());<br>                //printRect2(3,5);<br>                double avg = getAvg(2,2,3);<br>                System.out.println(avg);<br>            }</p>
<pre><code>    /*
       定义有返回值有参数方法，如求三个数的平均值
       明确方法计算后的数据类型, 返回值类型 double
       明确方法未知数, 三个未知的整数
    */
    public static double getAvg(double a, double b,double c){
         return (a+b+c)/3;
    }

    /*
        定义无返回值有参数方法，如打印指定M行，每行N个*号的矩形
        明确方法计算后结果,控制台输出图形,没有返回值的
        方法中有没有未知数,图形行数,和列数,是未知的, 数据类型整数int
    */
    public static void printRect2(int m,int n){
        for(int i = 0 ; i &lt; m ; i++){
            for(int j = 0 ; j &lt; n ;  j++){
                System.out.print(&quot;*&quot;);
            }
            System.out.println();
        }
    }

    /*
       定义有返回值无参数方法，如键盘录入得到一个整数
       明确方法计算后结果的数据类型 int
       明确有没有未知数,没
    */
    public static int getNumber(){
        Scanner sc = new Scanner(System.in);
        //int number = sc.nextInt();
        return sc.nextInt();
    }

    /*
       定义无返回值无参数方法，如打印3行，每行3个*号的矩形
       为什么没有返回值:
           打印矩形 ,输出效果,不需要将结果返回
           明确未知数: 不需要未知数
    */
    public static void printRect(){
        for(int i = 0 ; i &lt; 3 ; i++){
            for(int j = 0 ; j &lt; 3 ;j++){
                System.out.print(&quot;*&quot;);
            }
            System.out.println();
        }
    }
}</code></pre><p>###08方法的定义和使用的注意事项<br>    * A: 方法的定义和使用的注意事项<br>        * a: 方法不能定义在另一个方法的里面<br>         * b: 写错方法名字<br>        * c: 写错了参数列表<br>        * d: 方法返回值是void,方法中可以省略return 不写<br>             return 下面不能有代码<br>        * e 方法返回值类型,和return 后面数据类型必须匹配<br>        * f: 方法重复定义问题<br>        * g: 调用方法的时候,返回值是void, 不能写在输出语句中</p>
<p>###09方法的重载<br>    * A: 方法的重载<br>        * 在同一个类中，方法名相同，参数列表不同。与返回值类型无关。</p>
<pre><code>    * 参数列表不同：
        * A:参数个数不同
        * B:参数类型不同
        * C:参数的顺序不同(算重载,但是在开发中不用)

* B: 案例代码
    public static int getSum(int a,int b){
        System.out.println(&quot;两个int参数&quot;);
        return a+b;
    }
    public static int getSum(int a,int b,int c){
        System.out.println(&quot;三个int参数&quot;);
        return a+b+c;
    }
    public static double getSum(double a,double b){
        System.out.println(&quot;两个double参数&quot;);
        return a+b;
    }</code></pre><p>​<br>###10方法重载注意事项<br>    * A: 方法重载注意事项<br>        * a: 参数列表必须不同<br>        * b: 重载和参数变量名无关<br>        * c: 重载和返回值类型无关<br>        * d: 重载和修饰符无关<br>        * e: 技巧: 重载看方法名和参数列表</p>
<p>​<br>###11方法参数是基本数据类型<br>    * A: 方法参数是基本数据类型<br>        * a: 方法参数是基本类型时，传递的是值。</p>
<p>###12方法参数是引用数据类型<br>    * A: 方法参数是引用数据类型<br>        * a: 方法参数是引用类型时，传递的是内存地址值。</p>
<p>###13随机点名器<br>    * A: 案例代码<br>        /*<br>           实现随机点名器<br>             1.存储所有学生姓名<br>             2.预览所有学生姓名,遍历数组<br>             3.随机数作为索引,到数组中找元素</p>
<pre><code>    将功能独立出来, 作成方法,调用方法即可

    定义三个功能, 用到同一个姓名数据
    姓名存储到数组中,三个方法,使用一个数组中的数据, 方法传递参数
*/
import java.util.Random;
public class CallName{
    public static void main(String[] args){
        //定义数组,存储学生姓名
        String[] names = new String[8];
        //调用添加姓名方法
        addStudent(names);
        //调用遍历数组方法
        printStudentName(names);
        //调用随机姓名的方法
        String name = randomStudentName(names);
        System.out.println(name);
    }
    /*
      定义方法,随机数,做索引,数组中找到学生姓名
      返回值?  学生姓名
      参数?  数组
    */
    public static String randomStudentName(String[] names){
        Random ran = new Random();
        int index = ran.nextInt(names.length);
        return names[index];
    }

    /*
       定义方法,遍历数组
       返回值? 没有
       参数? 数组
    */
    public static void printStudentName(String[] names){
        for(int i = 0 ; i &lt; names.length ;i++){
            System.out.println(names[i]);
        }
    }

    /*
       定义方法,实现向数组中添加学生姓名
       返回值? 没有,
       参数?  参数就是数组
    */
    public static void addStudent(String[] names){
        names[0] = &quot;张三&quot;;
        names[1] = &quot;李四&quot;;
        names[2] = &quot;王五&quot;;
        names[3] = &quot;李蕾&quot;;
        names[4] = &quot;韩梅梅&quot;;
        names[5] = &quot;小名&quot;;
        names[6] = &quot;老王&quot;;
        names[7] = &quot;小华&quot;;
    }
}</code></pre><p>###14库存案例代码实现_1<br>    * A: 案例代码<br>        /*<br>           实现商品的库存管理<br>             功能:<br>                1.展示用户选择功能清单<br>                2.根据选择的功能编号,进行不同的操作<br>                   A. 展示所有库存<br>                   B. 修改库存数量</p>
<pre><code>      分析:
        1.展示用户清单:
           输出语句, 用户输入, 选择功能序号
        2.根据选择,调用不同的方法
            switch语句
              case 1 2 3

           A  展示库存
             将存储商品的数组,遍历
           B  修改库存

              修改所有的库存数量
*/
import java.util.Scanner;
public class Shopp{
    public static void main(String[] args){

    }

    /*
       定义方法,展示所有的库存清单,遍历
       返回值,没有
       参数, 数组
    */
    public static void printStore(String[] brand,double[] size,double[] price,int[] count){
        System.out.println(&quot;----------商场库存清单----------&quot;);
        System.out.println(&quot;品牌型号     尺寸    价格    库存数&quot;);
        //定义变量,计算总库存数,和总价格
        int totalCount = 0;
        int totalMoney = 0;
        //遍历数组,将数组中所有的商品信息打印出来
        for(int i = 0 ; i &lt; brand.length ; i++){
            System.out.println(brand[i]+&quot;   &quot;+size[i]+&quot;    &quot;+price[i]+&quot;   &quot;+count[i]);
            totalCount += count[i];
            totalMoney += count[i]*price[i];
        }
        System.out.println(&quot;总库存数: &quot;+totalCount);
        System.out.println(&quot;商品库存总金额: &quot;+totalMoney);
    }

    /*
      定义方法,实现用户的选择功能,功能的需要返回来
      返回值, int
      参数, 没有
    */
    public static int chooseFunction(){
        System.out.println(&quot;-------------库存管理------------&quot;);
        System.out.println(&quot;1.查看库存清单&quot;);
        System.out.println(&quot;2.修改商品库存数量&quot;);
        System.out.println(&quot;3.退出&quot;);
        System.out.println(&quot;请输入要执行的操作序号：&quot;);
        //接受键盘输入
        Scanner sc = new Scanner(System.in);
        int chooseNumber = sc.nextInt();
        return chooseNumber;
    }
}</code></pre><p>###15库存案例代码实现_2<br>    * A: 案例代码<br>        /*<br>          定义方法,修改所有商品的库存<br>            用户输入1个,修改1个<br>            返回值,没有<br>            参数, 库存数的数组, 品名数组<br>        */<br>        public static void update(String[] brand, int[] count){<br>            //遍历数组,遍历到一个,修改一个<br>            //接受键盘输入<br>            Scanner sc = new Scanner(System.in);<br>            //遍历数组<br>            for(int i = 0; i &lt; brand.length ; i++){<br>                System.out.println(“请输入”+brand[i]+”的库存数”);<br>                //键盘输入,录入库存, 存储到库存的数组中<br>                int newCount = sc.nextInt();<br>                count[i] = newCount;<br>            }<br>            //int chooseNumber = sc.nextInt();<br>        }</p>
<p>###16库存案例代码测试<br>    * A: 案例<br>        /*<br>           实现商品的库存管理<br>             功能:<br>                1.展示用户选择功能清单<br>                2.根据选择的功能编号,进行不同的操作<br>                   A. 展示所有库存<br>                   B. 修改库存数量</p>
<pre><code>      分析:
        1.展示用户清单:
           输出语句, 用户输入, 选择功能序号
        2.根据选择,调用不同的方法
            switch语句
              case 1 2 3

           A  展示库存
             将存储商品的数组,遍历
           B  修改库存

              修改所有的库存数量
*/
import java.util.Scanner;
public class Shopp{
    public static void main(String[] args){
        //使用数组,保存商品的信息
        //品名,尺寸,价格,库存数, 定义5个数组
        String[] brand = {&quot;MacBookAir&quot;,&quot;ThinkpadT450&quot;};
        double[] size = {13.3,15.6};
        double[] price = {9998.97,6789.56};
        int[] count = {0,0};
        while(true){
            int choose = chooseFunction();
            switch(choose){
                case 1:
                  //调用查看库存清单方法
                  printStore(brand,size,price,count);
                break;

                case 2:
                  //调用修改库存的方法
                  update(brand,count);
                break;

                case 3:
                 return ;
                default:
                  System.out.println(&quot;没有这个功能&quot;);
                break;
            }
        }
    }
    /*
      定义方法,修改所有商品的库存
        用户输入1个,修改1个
        返回值,没有
        参数, 库存数的数组, 品名数组
    */
    public static void update(String[] brand, int[] count){
        //遍历数组,遍历到一个,修改一个
        //接受键盘输入
        Scanner sc = new Scanner(System.in);
        //遍历数组
        for(int i = 0; i &lt; brand.length ; i++){
            System.out.println(&quot;请输入&quot;+brand[i]+&quot;的库存数&quot;);
            //键盘输入,录入库存, 存储到库存的数组中
            int newCount = sc.nextInt();
            count[i] = newCount;
        }
        //int chooseNumber = sc.nextInt();
    }

    /*
       定义方法,展示所有的库存清单,遍历
       返回值,没有
       参数, 数组
    */
    public static void printStore(String[] brand,double[] size,double[] price,int[] count){
        System.out.println(&quot;----------商场库存清单----------&quot;);
        System.out.println(&quot;品牌型号     尺寸    价格    库存数&quot;);
        //定义变量,计算总库存数,和总价格
        int totalCount = 0;
        int totalMoney = 0;
        //遍历数组,将数组中所有的商品信息打印出来
        for(int i = 0 ; i &lt; brand.length ; i++){
            System.out.println(brand[i]+&quot;   &quot;+size[i]+&quot;    &quot;+price[i]+&quot;   &quot;+count[i]);
            totalCount += count[i];
            totalMoney += count[i]*price[i];
        }
        System.out.println(&quot;总库存数: &quot;+totalCount);
        System.out.println(&quot;商品库存总金额: &quot;+totalMoney);
    }

    /*
      定义方法,实现用户的选择功能,功能的需要返回来
      返回值, int
      参数, 没有
    */
    public static int chooseFunction(){
        System.out.println(&quot;-------------库存管理------------&quot;);
        System.out.println(&quot;1.查看库存清单&quot;);
        System.out.println(&quot;2.修改商品库存数量&quot;);
        System.out.println(&quot;3.退出&quot;);
        System.out.println(&quot;请输入要执行的操作序号：&quot;);
        //接受键盘输入
        Scanner sc = new Scanner(System.in);
        int chooseNumber = sc.nextInt();
        return chooseNumber;
    }
}</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day04%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day04%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:01:11" itemprop="dateModified" datetime="2020-12-23T23:01:11+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、流程控制语句switch<br>2、数组<br>3、随机点名器案例</p>
<p>###01switch语句解构<br>​    * A:switch语句解构<br>​    * a:switch只能针对某个表达式的值作出判断，从而决定程序执行哪一段代码。</p>
<pre><code>* b:格式如下:
      swtich(表达式){
          case 常量1 :
            要执行的语句;
          break;

          case 常量2 :
            要执行的语句;
          break;

          case 常量3 :
            要执行的语句;
          break;

          default:
            要执行的语句;
          break;
      }
* c: 执行流程:  表达式,和case后面的常量进行比较和哪个case后的常量相同,就执行哪个case后面的程序,遇到break,就全结束

* d: 关键字: switch case default break

  * e:举例
    如果等于1，则输出星期一
​    如果等于2，则输出星期二
​    如果等于3，则输出星期三
​    如果等于4，则输出星期四
​    如果等于5，则输出星期五
​    如果等于6，则输出星期六
​    如果等于7，则输出星期天</code></pre><p>###02switch语句的星期判断</p>
<ul>
<li><p>A: switch语句的星期判断<br> ​        * a: 明确需求<br> ​            需求:初始化int类型变量(1-7)代表星期几,使用switch语句进行判断,并打印出该整数对应的星期.<br> ​<br> ​        * </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> * b: 代码实现</span><br><span class="line">   ​			 public class SwitchDemo01 &#123;</span><br><span class="line">   ​				public static void main(String[] args) &#123;</span><br><span class="line">   ​					int week &#x3D; 5;</span><br><span class="line">   ​					switch (week) &#123;</span><br><span class="line">   ​					case 1:</span><br><span class="line">   ​						System.out.println(&quot;星期一&quot;);</span><br><span class="line">   ​						break;</span><br><span class="line">   ​					case 2:</span><br><span class="line">   ​						System.out.println(&quot;星期二&quot;);</span><br><span class="line">   ​						break;</span><br><span class="line">   ​					case 3:</span><br><span class="line">   ​						System.out.println(&quot;星期三&quot;);</span><br><span class="line">   ​						break;</span><br><span class="line">   ​					case 4:</span><br><span class="line">   ​						System.out.println(&quot;星期四&quot;);</span><br><span class="line">   ​						break;</span><br><span class="line">   ​					case 5:</span><br><span class="line">   ​						System.out.println(&quot;星期五&quot;);</span><br><span class="line">   ​						break;</span><br><span class="line">   ​					case 6:</span><br><span class="line">   ​						System.out.println(&quot;星期六&quot;);</span><br><span class="line">   ​						break;</span><br><span class="line">   ​					case 7:</span><br><span class="line">   ​						System.out.println(&quot;星期天&quot;);</span><br><span class="line">   ​						break;</span><br><span class="line">   ​					default:</span><br><span class="line">   ​						System.out.println(&quot;输入的数字不正确...&quot;);</span><br><span class="line">   ​						break;</span><br><span class="line">   ​					&#125;</span><br><span class="line">   ​				&#125;</span><br><span class="line">   ​			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>###03switch语句接受的数据类型<br>​    * A: switch语句接受的数据类型<br>​        * a:注意事项<br>​            switch语句中的表达式的数据类型,是有要求的<br>​            JDK1.0 - 1.4  数据类型接受 byte short int char<br>​            JDK1.5   数据类型接受 byte short int char enum(枚举)<br>​            JDK1.7   数据类型接受 byte short int char enum(枚举), String<br>​    </p>
<p>###04case穿透<br>​    * A:case穿透<br>​        * a: 在使用switch语句的过程中，如果多个case条件后面的执行语句是一样的，则该执行语句只需书写一次即可，这是一种简写的方式。<br>​        * b: 例如，要判断一周中的某一天是否为工作日，同样使用数字1~7来表示星期一到星期天，当输入的数字为1、2、3、4、5时就视为工作日，否则就视为休息日。</p>
<p>​                </p>
<p>###05数组的概述<br>​    * A: 数组的概述<br>​        * a:数组的需求<br>​            现在需要统计某公司员工的工资情况，例如计算平均工资、最高工资等。假设该公司有50名员工，用前面所学的知识完成，<br>​            那么程序首先需要声明50个变量来分别记住每位员工的工资，这样做会显得很麻烦.</p>
<pre><code>* b:数组的概述
    数组是指一组数据的集合，数组中的每个数据被称作元素。在数组中可以存放任意类型的元素，但同一个数组里存放的元素类型必须一致。</code></pre><p>###06数组的定义<br>​    * A：数组的定义<br>​    * b:格式:<br>​             数据类型[] 数组名 = new 数据类型[元素个数或数组长度];</p>
<pre><code>    * c:举例:
        int[] x = new int[100];
* c:要点说明
      1)数据类型: 数组中存储元素的数据类型
    2) [] 表示数组的意思
    3) 变量名  自定义标识符  
    4) new  创建容器关键字
    5)数据类型: 数组中存储元素的数据类型
    6)[]  表示数组的意思
    7)元素个数,就是数组中,可以存储多少个数据 (恒定, 定长)

    数组是一个容器: 存储到数组中的每个元素,都有自己的自动编号
    自动编号,最小值是0, 最大值,长度-1
    自动编号专业名次, 索引(index), 下标, 角标
    访问数组存储的元素,必须依赖于索引, 公式 数组名[索引]

    Java提供一个属性,操作索引的
    数组的一个属性,就是数组的长度, 属性的名字 length
    使用属性:  数组名.length  数据类型 int

    数组的最小索引是0, 最大索引数组.length-1</code></pre><p>###07JVM内存划分<br>​    * A：内存划分<br>​    * JVM对自己的内存划分为5个区域<br>​          * a: 寄存器:内存和CUP之间<br>​          * b: 本地方法栈: JVM调用了系统中的功能<br>​          * c: 方法和数据共享: 运行时期class文件进入的地方<br>​          * d: 方法栈:所有的方法运行的时候进入内存<br>​          * e: 堆:存储的是容器和对象<br>​        </p>
<p>###08数组的内存<br>    * A: 数组的内存<br>​    * int[] x;                    // 声明一个int[]类型的变量<br>​    *    x = new int[100];        // 创建一个长度为100的数组<br>​    *    接下来，通过两张内存图来详细地说明数组在创建过程中内存的分配情况。<br>​    *    第一行代码 int[] x; 声明了一个变量x，该变量的类型为int[]，即一个int类型的数组。变量x会占用一块内存单元，它没有被分配初始值<br>​    *    第二行代码 x = new int[100]; 创建了一个数组，将数组的地址赋值给变量x。在程序运行期间可以使用变量x来引用数组，这时内存中的状态会发生变化</p>
<p>​<br>###09使用索引访问数组的元素<br>​    * A: 使用索引访问数组的元素<br>​        * 组中有100个元素，初始值都为0。数组中的每个元素都有一个索引(也可称为角标)，要想访问数组中的元素可以通过“x[0]、x[1]、……、x[98]、x[99]”的形式。<br>​        * 需要注意的是，数组中最小的索引是0，最大的索引是“数组的长度-1”<br>​        </p>
<p>###10数组的length属性<br>​    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* A: lenth属性</span><br><span class="line">​		* a 在Java中，为了方便我们获得数组的长度，提供了一个length属性，在程序中可以通过“数组名.length”的方式来获得数组的长度，即元素的个数。</span><br><span class="line">​		* b 求数组的长度</span><br><span class="line">​			public class ArrayDemo01 &#123;</span><br><span class="line">​		 		public static void main(String[] args) &#123;</span><br><span class="line">​		 			int[] arr; &#x2F;&#x2F; 声明变量</span><br><span class="line">​		 			arr &#x3D; new int[3]; &#x2F;&#x2F; 创建数组对象</span><br><span class="line">​		 			System.out.println(&quot;arr[0]&#x3D;&quot; + arr[0]); &#x2F;&#x2F; 访问数组中的第一个元素</span><br><span class="line">​		 			System.out.println(&quot;arr[1]&#x3D;&quot; + arr[1]); &#x2F;&#x2F; 访问数组中的第二个元素</span><br><span class="line">​		 			System.out.println(&quot;arr[2]&#x3D;&quot; + arr[2]); &#x2F;&#x2F; 访问数组中的第三个元素</span><br><span class="line">​		 			System.out.println(&quot;数组的长度是：&quot; + arr.length); &#x2F;&#x2F; 打印数组长度</span><br><span class="line">​		 		&#125;</span><br><span class="line"> 			&#125;</span><br></pre></td></tr></table></figure>



<p>###11为数组的元素赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">	* A: 为数组的元素赋值</span><br><span class="line">​		* a: 如果在使用数组时，不想使用这些默认初始值，也可以显式地为这些元素赋值。</span><br><span class="line">​		* 	赋值过的元素已经变为新的数值,没有赋值的元素默认初始化的数值</span><br><span class="line">​		* b: 案例</span><br><span class="line">​		 	public class ArrayDemo02 &#123;</span><br><span class="line">​		 		public static void main(String[] args) &#123;</span><br><span class="line">​		 			int[] arr &#x3D; new int[4]; &#x2F;&#x2F; 定义可以存储4个整数的数组</span><br><span class="line">​		 			arr[0] &#x3D; 1; &#x2F;&#x2F; 为第1个元素赋值1</span><br><span class="line">​		 			arr[1] &#x3D; 2; &#x2F;&#x2F; 为第2个元素赋值2</span><br><span class="line">​		 			&#x2F;&#x2F; 下面的代码是打印数组中每个元素的值</span><br><span class="line">​		 			System.out.println(&quot;arr[0]&#x3D;&quot; + arr[0]);</span><br><span class="line">​		 			System.out.println(&quot;arr[1]&#x3D;&quot; + arr[1]);</span><br><span class="line">​		 			System.out.println(&quot;arr[2]&#x3D;&quot; + arr[2]);</span><br><span class="line">​					System.out.println(&quot;arr[3]&#x3D;&quot; + arr[3]);</span><br><span class="line">​		 		&#125;</span><br><span class="line"> 			&#125;</span><br></pre></td></tr></table></figure>




<p>###12数组的定义_2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">	* A: 定义数组格式2</span><br><span class="line">​		* a: 数组初始化</span><br><span class="line">​			动态初始化 : 在定义数组时只指定数组的长度，由系统自动为元素赋初值的方式称作动态初始化。</span><br><span class="line">​			1、类型[] 数组名 &#x3D; new 类型[长度];</span><br><span class="line">​			int[] arr &#x3D; new int[4];</span><br><span class="line">​			静态初始化: 在初始化数组时还有一种方式叫做静态初始化，就是在定义数组的同时就为数组的每个元素赋值。</span><br><span class="line">​			2、类型[] 数组名 &#x3D; new 类型[]&#123;元素，元素，……&#125;;</span><br><span class="line">​			int[] arr &#x3D; new int[]&#123;1,2,3,4&#125;;</span><br><span class="line">​			3、类型[] 数组名 &#x3D; &#123;元素，元素，元素，……&#125;;	 </span><br><span class="line">​			int[] arr &#x3D; &#123; 1, 2, 3, 4 &#125;;</span><br><span class="line">​</span><br></pre></td></tr></table></figure>


<p>​        </p>
<p>###13遍历数组<br>​    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* A:遍历数组</span><br><span class="line">​		* 在操作数组时，经常需要依次访问数组中的每个元素，这种操作称作数组的遍历</span><br><span class="line">​	* B:练习</span><br><span class="line">​		public class ArrayDemo04 &#123;</span><br><span class="line">​			public static void main(String[] args) &#123;</span><br><span class="line">​				int[] arr &#x3D; &#123; 1, 2, 3, 4, 5 &#125;; &#x2F;&#x2F; 定义数组</span><br><span class="line">​				&#x2F;&#x2F; 使用for循环遍历数组的元素</span><br><span class="line">​				for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">​					System.out.println(arr[i]); &#x2F;&#x2F; 通过索引访问元素</span><br><span class="line">​				&#125;</span><br><span class="line">​			&#125;</span><br><span class="line">​		&#125;</span><br></pre></td></tr></table></figure>


<p>​        上述代码中，定义一个长度为5的数组arr，数组的角标为0<del>4。由于for循环中定义的变量i的值在循环过程中为0</del>4，因此可以作为索引，依次去访问数组中的元素，并将元素的值打印出来</p>
<p>###14数组中常见的异常<br>​    * A: 数组操作中,常见的两个异常<br>​         数组的索引越界异常<br>​          空指针异常</p>
<pre><code>* B: 练习
    public class ArrayDemo_4{
        public static void main(String[] args){
            //数组的索引越界异常
            //int[] arr = {5,2,1};
            //数组中3个元素,索引 0,1,2
            //System.out.println(arr[3]);//java.lang.ArrayIndexOutOfBoundsException: 3

            //空指针异常
            int[] arr2 = {1,5,8};
            System.out.println(arr2[2]);
            arr2 = null; // arr2 不在保存数组的地址了
            System.out.println(arr2[2]);//java.lang.NullPointerException
        }
    }</code></pre><p>###15数组最值<br>​    * A: 数组获取最值的原理思想<br>​        * 定义数组的第一个元素arr[0]为最大值;循环arr数组,判断如果有比arr[0] 大的就交换,直到arr数组遍历完毕,那么arr[0]中就保存了最大的元素</p>
<p>​        </p>
<p>###16数组获取最值代码实现<br>​    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* A: 代码实现</span><br><span class="line">​		public class ArrayDemo05 &#123;</span><br><span class="line">​			public static void main(String[] args) &#123;</span><br><span class="line">​				int[] arr &#x3D; &#123; 4, 1, 6, 3, 9, 8 &#125;; 	&#x2F;&#x2F; 定义一个数组</span><br><span class="line">​				int max &#x3D; arr[0]; 					&#x2F;&#x2F; 定义变量max用于记住最大数，首先假设第一个元素为最大值</span><br><span class="line">​				&#x2F;&#x2F; 下面通过一个for循环遍历数组中的元素</span><br><span class="line">​				for (int x &#x3D; 1; x &lt; arr.length; x++) &#123;</span><br><span class="line">​					if (arr[x] &gt; max) &#123; 			&#x2F;&#x2F; 比较 arr[x]的值是否大于max</span><br><span class="line">​						max &#x3D; arr[x]; 				&#x2F;&#x2F; 条件成立，将arr[x]的值赋给max</span><br><span class="line">​					&#125;</span><br><span class="line">​				&#125;</span><br><span class="line">​				System.out.println(&quot;max&#x3D;&quot; + max); 	&#x2F;&#x2F; 打印最大值</span><br><span class="line">​			&#125;</span><br><span class="line">​		&#125;</span><br></pre></td></tr></table></figure>




<p>###17二维数组的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	* A 二维数组的作用</span><br><span class="line">​		* 要统计一个学校各个班级学生的考试成绩，又该如何实现呢？</span><br><span class="line">​		* 这时就需要用到多维数组，多维数组可以简单地理解为在数组中嵌套数组。</span><br><span class="line">​	* B 定义格式</span><br><span class="line">​		* a 第一种定义格式:</span><br><span class="line">​			*  int[][] arr &#x3D; new int[3][4];</span><br><span class="line">​			*  上面的代码相当于定义了一个3*4的二维数组，即二维数组的长度为3，二维数组中的每个元素又是一个长度为4的数组</span><br><span class="line">​		* b 第二种定义格式</span><br><span class="line">​			*  int[][] arr &#x3D; new int[3][];</span><br><span class="line">​			*  第二种方式和第一种类似，只是数组中每个元素的长度不确定</span><br><span class="line">​		* c 第三种定义格式</span><br><span class="line">​			*  	int[][] arr &#x3D; &#123;&#123;1,2&#125;,&#123;3,4,5,6&#125;,&#123;7,8,9&#125;&#125;;</span><br><span class="line">​			*  	二维数组中定义了三个元素，这三个元素都是数组，分别为&#123;1,2&#125;、&#123;3,4,5,6&#125;、&#123;7,8,9&#125;</span><br></pre></td></tr></table></figure>





<p>###18二维数组元素的访问<br>​    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> * A: 二维数组的访问</span><br><span class="line">​	 * 案例:</span><br><span class="line">​	  class ArrayDemo08 &#123;</span><br><span class="line">​		public static void main(String[] args)&#123;</span><br><span class="line">​		</span><br><span class="line">			&#x2F;&#x2F;定义二维数组的方式</span><br><span class="line">			int[][] arr &#x3D; new int[3][4];</span><br><span class="line">			System.out.println( arr );</span><br><span class="line">			System.out.println(&quot;二维数组的长度: &quot; + arr.length);</span><br><span class="line">			&#x2F;&#x2F;获取二维数组的3个元素</span><br><span class="line">			System.out.println( arr[0] );</span><br><span class="line">			System.out.println( arr[1] );</span><br><span class="line">			System.out.println( arr[2] );</span><br></pre></td></tr></table></figure>


<p>​    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">		System.out.println(&quot;打印第一个一维数组的元素值&quot;);</span><br><span class="line">​			System.out.println( arr[0][0] );</span><br><span class="line">​			System.out.println( arr[0][1] );&#x2F;&#x2F;访问的为二维数组中第1个一维数组的第2个元素</span><br><span class="line">​			System.out.println( arr[0][2] );</span><br><span class="line">​			System.out.println( arr[0][3] );</span><br><span class="line">​			</span><br><span class="line">			System.out.println(&quot;打印第二个一维数组的元素值&quot;);</span><br><span class="line">			System.out.println( arr[1][0] );</span><br><span class="line">			System.out.println( arr[1][1] );</span><br><span class="line">			System.out.println( arr[1][2] );</span><br><span class="line">			System.out.println( arr[1][3] );</span><br></pre></td></tr></table></figure>


<p>​            </p>
<pre><code>        System.out.println(&quot;打印第三个一维数组的元素值&quot;);
        System.out.println( arr[2][0] );
        System.out.println( arr[2][1] );
        System.out.println( arr[2][2] );
        System.out.println( arr[2][3] );
    }
}</code></pre><p>###19二维数组内存图<br>​     * A: 二维数组内存图<br>​     * 举例:int[][] arr = new int[3][2];<br>​     * 外层数组长在内存开辟连续的3个大的内存空间,每一个内存空间都对应的有地址值<br>​     * 每一个大内存空间里又开辟连续的两个小的内存空间.</p>
<p>###20二维数组的定义和访问<br>​    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> * A: 二维数组的定义和访问</span><br><span class="line">​		 * 格式1: </span><br><span class="line">​		 * 	int[][] arr &#x3D; new int[3][]; 不推荐</span><br><span class="line">​		 * 格式2</span><br><span class="line">​		 *  int[][] arr &#x3D; &#123;&#123;1,2,4&#125;,&#123;4,7&#125;,&#123;0,9,3&#125;&#125;;</span><br><span class="line">​		 *</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	 * B: 二维数组的访问</span><br><span class="line">​	 	 举例:int[][] arr &#x3D; &#123;&#123;1,2,4&#125;,&#123;5,8,7&#125;,&#123;0,9,3&#125;&#125;;  </span><br><span class="line">​		  想要打印数组中7这个元素需要先找到大的元素索引&#123;5,7&#125; 索引为2 ,在找7在&#123;5,7&#125;中的索引2</span><br><span class="line">​		  那么结果为 arr[2][2]  第一个[2]代表大数组中&#123;5,8,7&#125;这个元素索引</span><br><span class="line">​		  第二个[2]代表&#123;5,8,7&#125;中7元素的索引</span><br><span class="line">​</span><br></pre></td></tr></table></figure>



<p>###22二维数组的遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	  * A:二维数组遍历</span><br><span class="line">​		 int[][] arr &#x3D; &#123;&#123;1,2,4&#125;,&#123;4,7&#125;,&#123;0,9,3&#125;&#125;;</span><br><span class="line">  		 先使用for循环遍历arr这个二维数组,得到每一个元素为arr[i]为一维数组</span><br><span class="line">​		 再外层for循环中嵌套一个for循环遍历每一个一维数组arr[i],得到每一元素</span><br></pre></td></tr></table></figure>



<pre><code>*    B:举例:遍历二维数组
  public class ArrayArrayDemo_2{
      public static void main(String[] args){
          int[][] arr = { {1,2,3},{4,5},{6,7,8,9},{0} };

          //外循环,遍历二维数组
          for(int i = 0 ; i &lt; arr.length ;i++){
              //内循环,遍历每个一维数组 arr[0] arr[1] arr[i]
              for(int j = 0 ; j &lt; arr[i].length; j++){
                  System.out.print(arr[i][j]);
              }
              System.out.println();
          }
      }

* C:二维数组累加求和
 class ArrayDemo09 {
      public static void main(String[] args){
            int[][] arr2 = { {1,2},{3,4,5},{6,7,8,9,10} };
          int sum2 = 0;
          for (int i=0; i&lt;arr2.length; i++) {
              for (int j=0; j&lt;arr2[i].length; j++) {
                   //System.out.println(arr2[i][j])
                  sum2 += arr2[i][j];
              }
          }
          System.out.println(&quot;sum2= &quot;+ sum2);
      }
  }</code></pre><p>###23二维数组的求和练习<br>​    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> * A 例如要统计一个公司三个销售小组中每个小组的总销售额以及整个公司的销售额。如下所示</span><br><span class="line">​		* 第一小组销售额为&#123;11, 12&#125;万元</span><br><span class="line">​		* 第二小组销售额为&#123;21, 22, 23&#125;万元</span><br><span class="line">​		* 第三小组销售额为&#123;31, 32, 33, 34&#125;万元。</span><br></pre></td></tr></table></figure>



<pre><code>* B 代码实现
     public class ArrayDemo10 {
       public static void main(String[] args) {
           int[][] arr = new int[3][];             // 定义一个长度为3的二维数组
          arr[0] = new int[] { 11, 12 };             // 为数组的元素赋值
           arr[1] = new int[] { 21, 22, 23 };
           arr[2] = new int[] { 31, 32, 33, 34 };        
           int sum = 0;                             // 定义变量记录总销售额
           for (int i = 0; i &lt; arr.length; i++) { // 遍历数组元素
               int groupSum = 0; // 定义变量记录小组销售总额
           for (int j = 0; j &lt; arr[i].length; j++) { // 遍历小组内每个人的销售额
                   groupSum = groupSum + arr[i][j];
           }
               sum = sum + groupSum;             // 累加小组销售额
               System.out.println(&quot;第&quot; + (i + 1) + &quot;小组销售额为：&quot; + groupSum + &quot; 万元&quot;);
           }
           System.out.println(&quot;总销售额为: &quot; + sum + &quot; 万元&quot;);
       }
   }</code></pre><p>###24随机点名器案例分析<br>​     * A 随机点名器案例分析<br>​<br>​     * B: 需求<br>​         * 随机点名器，即在全班同学中随机的打印出一名同学名字。<br>​<br>​     * C:分析:<br>​         * 1)定义数组存数全班同学<br>​         * 2)生成随机数范围0 到 数组长度-1<br>​         * 3)根据这个索引找到数组中的同学名称</p>
<p>###25随机点名器代码实现<br>​    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> * A: 分析</span><br><span class="line">​	   	 随机点名器:</span><br><span class="line">​	     1  存储姓名</span><br><span class="line">​		 2. 预览所有人的姓名</span><br><span class="line">​		 3. 随机出一个人的姓名</span><br><span class="line">​	 * B 代码实现</span><br><span class="line">​		import java.util.Random;</span><br><span class="line">​		public class CallName&#123;</span><br><span class="line">​			public static void main(String[] args)&#123;</span><br><span class="line">​				&#x2F;&#x2F;存储姓名,姓名存储到数组中</span><br><span class="line">​				&#x2F;&#x2F;数组存储姓名,姓名的数据类型,String</span><br><span class="line">​				String[] names &#x3D; &#123;&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;李蕾&quot;,&quot;韩梅梅&quot;,&quot;小名&quot;,&quot;老王&quot;,&quot;小华&quot;,&quot;约翰逊&quot;,&quot;爱丽丝&quot;&#125;;</span><br><span class="line">​				</span><br><span class="line">				&#x2F;&#x2F;预览: 遍历数组,打印所有姓名</span><br><span class="line">				for(int i &#x3D; 0 ; i &lt; names.length ; i++)&#123;</span><br><span class="line">					System.out.println(names[i]);</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br></pre></td></tr></table></figure>


<p>​            </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	&#x2F;&#x2F;随机出一个人的名</span><br><span class="line">​				&#x2F;&#x2F;利用随机数,生成一个整数,作为索引,到数组中找到对应的元素</span><br><span class="line">​				Random ran &#x3D; new Random();</span><br><span class="line">​				&#x2F;&#x2F;随机数,范围必须是0-数组的最大索引</span><br><span class="line">​				int index &#x3D; ran.nextInt(names.length);&#x2F;&#x2F;index 就是随机数,作为索引</span><br><span class="line">​				System.out.println(names[index]);</span><br><span class="line">​			&#125;</span><br><span class="line">​		&#125;</span><br></pre></td></tr></table></figure>




<p>###25随机点名器代码实现_2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">		* A 代码优化:</span><br><span class="line">​		import java.util.Random;</span><br><span class="line">​		public class CallName&#123;</span><br><span class="line">​			public static void main(String[] args)&#123;</span><br><span class="line">​				String[] names &#x3D; &#123;&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;李蕾&quot;,&quot;韩梅梅&quot;,&quot;小名&quot;,&quot;老王&quot;,&quot;小华&quot;,&quot;约翰逊&quot;,&quot;爱丽丝&quot;&#125;;</span><br><span class="line">​				System.out.println(names[new Random().nextInt(names.length)]);</span><br><span class="line">​			&#125;</span><br><span class="line">​		&#125;</span><br></pre></td></tr></table></figure>



<p>###25总结<br>​    * 把今天的知识点总结一遍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day03%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day03%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:00:56" itemprop="dateModified" datetime="2020-12-23T23:00:56+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、引用类型变量的创建及使用<br>2、流程控制语句之选择语句<br>3、流程控制语句之循环语句<br>4、循环高级</p>
<p>###01创建引用类型变量公式<br>    * A: 创建引用类型变量公式<br>        * a: 我们要学的Scanner类是属于引用数据类型，我们先了解下引用数据类型。<br>        * b: 引用数据类型的定义格式<br>            * 与定义基本数据类型变量不同，引用数据类型的变量定义及赋值有一个相对固定的步骤或格式。<br>            * 数据类型  变量名  =  new 数据类型();<br>        * c: 引用数据类型的使用<br>            * 每种引用数据类型都有其功能，我们可以调用该类型实例的功能。<br>            * 变量名.方法名();</p>
<p>​<br>###02Scanner类的使用<br>    * A: Scanner类的使用<br>        * a: 导包import java.util.Scanner;<br>        * b：创建键盘录入对象 Scanner sc = new Scanner(System.in);<br>        * c: 读取键盘录入的一个整数<br>            * int enterNumber = sc.nextInt();<br>        * d: 读取键盘录入的字符串<br>            * String enterString = sc.next();<br>    * B: 案例代码<br>        import java.util.Scanner;<br>        public class Demo05Scanner{<br>            public static void main(String[] args)<br>            {<br>                Scanner sc = new Scanner(System.in);</p>
<pre><code>        int enterNumber = sc.nextInt();
        System.out.println(&quot;用户输入的整数为&quot;+enterNumber);

        String enterString = sc.next();
        System.out.println(&quot;用户输入的字符串为&quot;+enterString);
    }
}</code></pre><p>​<br>###03Random随机数类的使用_1<br>    * A: Random随机数类的使用_1<br>        * a: 功能<br>            * 生成随机数需要使用到引用类型随机数Random类<br>        * b: 使用方式<br>            * import导包：所属包java.util. Random<br>            * 创建实例格式：Random  random = new Random ();<br>            * 调用方法<br>                * nextInt(int maxValue)    产生[0,maxValue)范围的随机数,包含0不包含maxValue<br>                * nextDouble()  产生[0,1)范围的随机数<br>                如：<br>                    Random  random = new Random ();<br>                    int  myNumber = random.nextInt(100);//结果为0-99的一个数<br>    * B: 案例代码<br>        import java.util.Random;<br>        public class RandomDemo{<br>            public static void main(String[] args){<br>               Random ran = new Random();<br>               // Random类中的,产生随机数的功能<br>               int i = ran.nextInt(100);<br>               System.out.println(i);</p>
<pre><code>       //问题? 产生随机数,范围 1-100之间
       // nextInt(100) 0-99 + 1
    }
}</code></pre><p>​    </p>
<p>###04Random随机数类的使用_2<br>    * A: Random随机数类的使用_2<br>        * a: 调用方法<br>            * nextDouble()  产生[0,1)范围的随机数<br>            如：<br>                Random  random = new Random ();<br>                int  myNumber = random.nextDouble();//结果为0.0-1.0之间的数(包括0.0不包括1.0)</p>
<p>###05if语句格式第一种<br>    * A: if语句格式第一种<br>        * a: 书写格式<br>            if(比较表达式) {<br>                语句体;<br>            }<br>        * b：执行流程：<br>            * 先计算比较表达式的值，看其返回值是true还是false。<br>            * 如果是true，就执行语句体；<br>            * 如果是false，就不执行语句体；<br>    * B: 案例代码<br>        public class IfDemo{<br>            public static void main(String[] args){<br>                  int i = 5 ;<br>                  //对变量i进行if判断<br>                  if(i &gt; 5){<br>                      System.out.println(“if中的条件是true”);<br>                      i++;<br>                  }</p>
<pre><code>          System.out.println(i);
    }
}</code></pre><p>###06if语句格式第二种<br>    * A: if语句格式第二种<br>        * a: 书写格式<br>            if(比较表达式) {<br>                语句体1;<br>            }else {<br>                语句体2;<br>            }<br>        * b：执行流程：<br>            * 首先计算比较表达式的值，看其返回值是true还是false。<br>            * 如果是true，就执行语句体1；<br>            * 如果是false，就执行语句体2；<br>    * B: 案例代码<br>        public class IfElseDemo{<br>            public static void main(String[] args){<br>                 int i = 16 ;<br>                 //判断变量,是奇偶数, 除以2,看余数是0还是1<br>                 if( i % 2 == 0 ){<br>                     System.out.println(i+” 是偶数”);<br>                 }else{<br>                     System.out.println(i+” 是奇数”);<br>                 }<br>            }<br>        }</p>
<p>###07if语句格式第三种<br>    * A: if语句格式第三种<br>        * a: 书写格式<br>                if(比较表达式1) {<br>                    语句体1;<br>                }else if(比较表达式2) {<br>                    语句体2;<br>                }else if(比较表达式3) {<br>                    语句体3;<br>                }<br>                …<br>                else {<br>                    语句体n+1;<br>                }<br>        * b：执行流程：<br>            * 首先计算比较表达式1看其返回值是true还是false，<br>            * 如果是true，就执行语句体1，if语句结束。<br>            * 如果是false，接着计算比较表达式2看其返回值是true还是false，</p>
<pre><code>        * 如果是true，就执行语句体2，if语句结束。
        * 如果是false，接着计算比较表达式3看其返回值是true还是false，

        * 如果都是false，就执行语句体n+1。
* B: 案例代码
    public class IfElseIfDemo{
        public static void main(String[] args){
            //成绩判断要求 ,成绩&gt;80  成绩&gt;70  成绩&gt;60  不及格
            //定义变量,保存成绩
            int grade = 75;
            //使用if else if 语句对成绩判断
            if( grade &gt; 80 ){
                System.out.println(grade+&quot; 成绩是优&quot;);
            }else if ( grade &gt; 70){
                System.out.println(grade+&quot; 成绩是良&quot;);
            }else if ( grade &gt; 60){
                System.out.println(grade+&quot; 成绩是中&quot;);
            }else{
                System.out.println(grade+&quot; 成绩是差&quot;);
            }

        }
    }</code></pre><p>###08if语句和三元运算符的互换<br>    * A: 三元运算符<br>        * a: 概念<br>            * 用来完成简单的选择逻辑，即根据条件判断，从两个选择中选择一种执行<br>        * b: 使用格式<br>            * (条件表达式)？表达式1：表达式2；<br>        * c: 运算规则<br>            * 1: 判断条件表达式，结果为一个布尔值<br>            * 2: true，运算结果为表达式1<br>            * 3: false，运算结果为表达式2<br>    * B: 案例代码<br>        public class IfElseDemo_1{<br>            public static void main(String[] args){<br>                int j = 6;<br>                int i = 15;<br>                //使用if语句,判断出最大值<br>                if(i&gt;j){<br>                int j = 6;<br>                    System.out.println(i+” 是最大值”);<br>                }else{<br>                    System.out.println(j+” 是最大值”);<br>                }</p>
<pre><code>            //使用三元运算实现
            int k = i&gt;j ? i : j;
            System.out.println(k+&quot; 是最大值&quot;);
        }
    }
* C: 使用if语句还是三元表达式
    * 判断条件多,使用if
     * 三元,必须有结果的, if 可以没有结果的</code></pre><p>###09while循环<br>    * A: while循环结构<br>        * a: 使用格式<br>            初始化表达式；<br>            while(条件){<br>                循环体<br>            }<br>        * b: 执行顺序<br>              当条件是true,就执行循环体,执行完循环体后<br>              程序再次执行while中的条件,如果条件还是true,继续执行循环体<br>              直到条件是false的时候,循环就结束<br>    * B: 案例代码<br>        public class WhileDemo{<br>            public static void main(String[] args){<br>                //输出 1-4之间的整数<br>                //定义变量,整数类型, 循环的条件<br>                int i = 1;<br>                while( i &lt; 5 ){<br>                    System.out.println(i);<br>                    i++;<br>                }<br>            }<br>        }</p>
<p>​<br>###10for循环_1<br>    * A: for循环_1<br>        * a: 使用格式<br>             for(初始化变量 ; 条件 ; 增量){<br>                 循环体;<br>             }<br>        * b: 各模块解释<br>            初始化变量: 定义变量,作用是用来控制循环的次数<br>            条件: 当条件是true,执行循环体,条件是false,结束循环<br>            增量: 变量自增情况<br>    * B: 案例代码<br>        public class ForDemo{<br>            public static void main(String[] args){<br>                //for循环,输出0-10<br>                for(int i = 0 ; i &lt; 11 ; i++){<br>                    System.out.println(i);<br>                }<br>            }<br>        }</p>
<p>###11for循环_2<br>    * A: for循环的执行流程<br>        for（① ; ② ; ③）{<br>            ④<br>        }<br>        第一步，执行①<br>        第二步，执行②，如果判断结果为true，执行第三步，如果判断结果为false，执行第五步<br>        第三步，执行④<br>        第四步，执行③，然后重复执行第二步<br>        第五步，退出循环</p>
<p>###12for循环_3<br>    * A: 案例<br>        * a: 利用for循环,计算1+4的结果<br>    * B: 案例代码<br>        public class ForDemo_1{<br>            public static void main(String[] args){<br>                // 定义变量,记录求和后的数据<br>                int sum = 0;<br>                // 利用循环,将变量从1变化到4<br>                for(int i = 1 ; i &lt;= 4 ; i++){<br>                    //对变量进行求和<br>                    sum = sum + i;<br>                }<br>                System.out.println(sum);<br>            }<br>        }</p>
<p>###13do_while循环<br>    * A: do_while循环<br>        * a: 使用格式<br>            do{<br>               循环体;<br>            }while(条件);<br>        * b: 执行顺序<br>            先执行一次循环体，然后再判断条件，如果条件为true，继续执行循环体，<br>            如果条件为false，循环结束。<br>        * c: 特点<br>            * 无条件先执行一次<br>    * B: 案例代码<br>        public class DoWhileDemo{<br>            public static void main(String[] args){<br>                int i = 0;<br>                do{<br>                    System.out.println(i);<br>                    i++;<br>                }while( i &lt;  5);<br>            }<br>        }</p>
<p>###14死循环<br>    * A: 死循环概述<br>        * 无限循环存在的原因是并不知道循环多少次，而是根据某些条件，来控制循环<br>    * B: 死循环格式<br>        * while(true){}<br>        * for(;;){}</p>
<p>###15嵌套for循环_1<br>    * A: 嵌套循环的概述<br>        * 嵌套循环是指在一个循环语句的循环体中再定义一个循环语句的语法结构。while、do…while、for循环语句都可以进行嵌套，并且它们之间也可以互相嵌套，如最常见的在for循环中嵌套for循环。<br>    * B: 嵌套循环的格式<br>        for(初始化表达式; 循环条件; 操作表达式) {<br>            ………<br>            for(初始化表达式; 循环条件; 操作表达式) {<br>                执行语句<br>                ………<br>            }<br>            ………<br>        }<br>    * C: 各模块解释<br>        * 总的循环次数 =  内循环次数 * 外循环的次数<br>        * 内循环,是外循环的循环体</p>
<pre><code>* 外循环,控制的是行数
* 内循环,控制的是每行的个数</code></pre><p>###16嵌套for循环_2<br>    * A: 案例<br>        * a: 打印正三角形<br>    * B: 案例代码<br>        public class ForForDemo{<br>            public static void main(String[] args){<br>                for(int i = 0 ; i &lt; 9 ; i++){<br>                    for(int j = 0; j &lt; i+1 ;j++){<br>                        System.out.print(“* “);<br>                    }<br>                    System.out.println();<br>                }<br>            }<br>        }</p>
<p>###17break语句<br>    * A: break语句<br>        * a: 作用<br>            * 跳出所在的循环体<br>        * b: 书写位置<br>            * 必须出现在循环或选择结构内<br>        * c: 举例<br>            for(int i=0; i&lt;10; i++) {<br>                if(i&gt;5) {<br>                break;<br>            }<br>                System.out.println(“我爱Java”+i);<br>            }<br>            //会从0-5输出6次“我爱Java”<br>    * B: break详细解释<br>        * a: 作用<br>            * 在loop/switch选择或者循环过程中，我们总是满足布尔表达条件才能执行对应的代码，然而在这些逻辑过程中，<br>                可以使用一些关键字直接跳出正在执行的代码，去执行后边或者指定位置的代码，<br>                这些关键字一旦出现就可以跳转语句执行顺序。<br>        * b: 使用方式<br>            * 无法单独使用，必须将break关键字置于switch或循环语句中<br>        * c: 运行规律<br>            * 不需要判断任何条件，只要遇到break变直接跳出执行后续代码。会完全跳出选择或者循环结构<br>            * 只能跳出最近的代码块，不能跨越多级代码块</p>
<pre><code>* C：循环标号
    * a: 为什么使用循环标号
        * 当在双层循环或者循环内有switch选择语句时，我们发现，使用break或者continue所作用的对象均是内层语句，无法直接跳出外层循环，这时就需要使用标号语句跳转了.
    * b: 使用方式
        * 在外层循环外的某行前边，使用后边跟有冒号”:”的标识符，即定义完毕。
          使用时当在内层循环使用break或continue时后边紧跟之前定义的标号即可
    * c: 运行规律
        * 当外层循环外定义了标号
        * 内层使用break，终止内外双层循环。
        * 内层使用continue，终止内层循环，继续外层循环。</code></pre><p>###18continue语句<br>    * A: continue语句<br>        * a: 作用<br>            * 提前结束本次循环，继续进行下次循环<br>        * b: 使用方式<br>            * 无法单独使用，必须将continue关键字置于循环语句中<br>        * c：运行规律<br>            * 不需要判断任何条件，只要遇到continue变直接跳出本轮循环进行下次循环<br>        * d：案例代码<br>            public class ContinueDemo{<br>                public static void main(String[] args){<br>                    for(int i = 0 ; i &lt; 10 ; i++){<br>                        if(i%2==0){<br>                            continue;<br>                        }<br>                        System.out.println(i);<br>                    }<br>                }<br>            }<br>            //会把0-9之间所有的奇数打印到控制台上</p>
<p>###19猜数字小游戏<br>    * A: 猜数字小游戏<br>        * a: 分析<br>            * 用户给的数可能大于、小于、或等于被猜的数，这样就会出现三种情况，用前面讲的三元运算符可以实现，<br>                但是得用三元运算符的嵌套，比较麻烦！可以用更简单的方式if条件判断，可以有三个以上的条件<br>        * b: 需求分析<br>            * 后台预先生成一个随机数1-100，用户键盘录入猜数字<br>            * 如果猜对了，打印“恭喜您，答对了”<br>            * 如果猜错了<br>            * 猜大了：打印“sorry，您猜大了!”<br>            * 猜小了：打印“sorry，您猜小了!”<br>                    直到数字猜到为止<br>                    最多只能猜5次，否则提示“sorry，您没有机会了!”<br>    * B: 案例代码<br>        /*<br>            猜数字小游戏</p>
<pre><code>    完成猜数字小游戏：
    1、产生随机数
    后台预先生成一个随机数1-100，用户键盘录入猜数字
    2、通过if语句对用户猜的数与随机数进行比较
    如果猜对了，打印“恭喜您，答对了”
    如果猜错了
    猜大了：打印“sorry，您猜大了!”
    猜小了：打印“sorry，您猜小了!”
    3、通过for循环完成用户猜数的循环
    直到数字猜到为止
    最多只能猜5次，否则提示“sorry，您没有机会了!”

*/
import java.util.Random;
import java.util.Scanner;
//通过*的方式可以一次导入该包下所有的类，但是不建议使用。建议使用哪个导哪个。
//import java.util.*;
public class GuessNumber{
    public static void main(String[] args) {
        //1、产生随机数
        //后台预先生成一个随机数1-100，用户键盘录入猜数字
        //创建随机数对象
        Random random = new Random();
        //产生一个1-100的随机数
        int randomNumber = random.nextInt(100)+1;
        //System.out.println(&quot;我产生的随机数是：&quot;+randomNumber+&quot;你猜猜是多少？&quot;);  作弊专用

        //产生控制台录入的Scanner对象
        Scanner sc = new Scanner(System.in);
        //3、通过for循环完成用户猜数的循环
        //通过for循环完成猜数字逻辑
        for(int i=1; i&lt;=5; i++){
            //提示用户输入要猜的数，用变量接收
            System.out.println();
            System.out.println(&quot;请您输入一个1-100的数：&quot;);
            int guessNumber = sc.nextInt();

            //2、通过if语句对用户猜的数与随机数进行比较
            //如果猜对了
            if(guessNumber==randomNumber) {
                //打印猜对后的提示
                System.out.println(&quot;恭喜您，猜对了！&quot;);
                //跳出循环，不用再猜了
                break;
            }else {//如果猜错了
                //如果猜大了
                if(guessNumber&gt;randomNumber) {
                    System.out.println(&quot;sorry，您猜大了!&quot;);
                }else {//如果猜小了
                    System.out.println(&quot;sorry，您猜小了!&quot;);
                }
            }
            //如果猜到了最后的第5次仍然没有猜对就跳出循环
            if(i==5) {
                System.out.println(&quot;对不起，点太背，下次再来吧！&quot;);
                break;
            }
            //每次猜错后，都提示还有多少次机会
            System.out.println(&quot;请注意，您还有&quot;+(5-i)+&quot;次机会，请慎重作答！&quot;);
        }
    }
}</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day02%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day02%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 22:59:40" itemprop="dateModified" datetime="2020-12-23T22:59:40+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、变量<br>2、运算符</p>
<p>###01变量概述<br>    * A: 什么是变量?<br>        * a: 变量是一个内存中的小盒子（小容器），容器是什么？生活中也有很多容器，例如水杯是容器，用来装载水；你家里的大衣柜是容器，用来装载衣裤；饭盒是容器，用来装载饭菜。那么变量是装载什么的呢？答案是数据！结论：变量是内存中装载数据的小盒子，你只能用它来存数据和取数据。</p>
<p>###02计算机存储单元<br>    * A: 计算机中储存和运算的最小单位是?<br>        * a: 一个字节,也就是一个byte.<br>            * win+r–cmd–回车<br>        * b: 常用储存单位<br>            *1B（字节） = 8bit<br>            *1KB = 1024B<br>            *1MB = 1024KB<br>            *1GB = 1024MB<br>            *1TB = 1024GB<br>            *1PB = 1024TB</p>
<p>​<br>​<br>###03Java中数据类型四类八种<br>    * A: 数据类型四类八种<br>        *四类    八种    字节数    数据表示范围<br>        *整型    byte    1    -128～127<br>            short    2    -32768～32767<br>            int    4    -2147483648～2147483648<br>            long    8    -263～263-1<br>        *浮点型    float    4    -3.403E38～3.403E38<br>            double    8    -1.798E308～1.798E308<br>        *字符型    char    2    表示一个字符，如(‘a’，’A’，’0’，’家’)<br>        *布尔型    boolean    1    只有两个值true与false</p>
<p>###04常量和数据类型<br>    * A:常量的定义<br>        * a: 整形常量默认是int类型<br>        * b: 小数常量默认是double类型<br>        * c: 定义长整形数据如果值超过int取值范围后面要+”L”<br>        * d: 定义float类型的数据后面要+”f” 否则默认是double</p>
<p>###05变量创建的三要素<br>    * A: 定义变量的语法格式：<br>        数据类型  变量名  =  变量值;<br>        * int         a    =  100;<br>        * B:代码:<br>        public class Variable {<br>            public static void main(String[] args) {<br>                int a = 10;<br>                double b = 3.14;<br>                char c = ‘z’;<br>                String s = “i love java”;</p>
<pre><code>        a = 20;
        System.out.println(a);
    }
}</code></pre><p>​                </p>
<p>###06定义所有的基本数据类型变量<br>    * A: 案例演示<br>        * a: 八种基本类型数据的创建</p>
<p>###07定义字符串变量<br>    * A：案例演示<br>        * 创建字符串数据类型变量<br>        * String 是引用数据类型<br>###08变量定义使用注意事项<br>    * A：变量使用的注意事项<br>        * a: 变量定义后可以不赋值，使用时再赋值。不赋值不能使用。<br>            public static void main(String[] args) {<br>            int x;<br>            x = 20; //为x赋值20<br>            System.out.println(x);//读取x变量中的值，再打印<br>            }<br><br>        * c:    变量使用时有作用域的限制。<br>            public static void main(String[] args) {<br>            int x = 20;<br>            {<br>                int y = 20;<br>            }<br>            System.out.println(x);//读取x变量中的值，再打印<br>            System.out.println(y);//读取y变量中的值失败，失败原因，找不到y变量，因为超出了y变量作用范围，所以不能使用y变量<br>            }</p>
<pre><code>    </code></pre><p>    </p>
<p>###09数据类型转换_自动转换<br>    * A:     自动类型转换<br>        * a:表示范围小的数据类型转换成范围大的数据类型，这种方式称为自动类型转换<br>            自动类型转换格式：<br>            范围大的数据类型 变量 = 范围小的数据类型值；<br>            如：<br>                    double d = 1000;<br>                或<br>                    int i = 100;<br>                    double d2 = i;</p>
<p>​<br>###10数据类型转换_强制转换<br>    * A: 强制类型转换<br>        *a: 表示范围大的数据类型转换成范围小的数据类型，这种方式称为强制类型转换<br>        *b: 强制类型转换格式：<br>        范围小的数据类型  变量 = (范围小的数据类型) 范围大的数据类型值;<br>        如：<br>        int  i = (int)6.718;   //i的值为6<br>        或<br>        double  d = 3.14;<br>        int  i2 = (int)d;     //i2的值为3</p>
<p>###11算数运算符_1<br>    * A: 常见操作<br>        运算符    运算规则    范例        结果<br>        +    正号        +3        3<br>        +    加        2+3        5<br>        +    连接字符串    “中”+“国”    “中国”<br>        -    负号        int a=3;-a    -3<br>        -    减        3-1        2<br>        *    乘        2<em>3        6<br>        /    除        5/2        2<br>        %    取模        5/2        1<br>        ++    自增        int a=1;a++/++a    2<br>        –    自减        int b=3;a–/–a    2<br>    * B: 注意事项<br>        *a:加法运算符在连接字符串时要注意，只有直接与字符串相加才会转成字符串。<br>        *b:除法“/”当两边为整数时，取整数部分，舍余数。当其中一边为浮点型时，按正常规则相除。<br>        *c:“%”为整除取余符号，小数取余没有意义。结果符号与被取余符号相同。<br>        *d:整数做被除数，0不能做除数，否则报错。<br>        *e:小数做被除数，整除0结果为Infinity，对0取模结果为NaN<br>    * C:代码演示<br>    public class OperatorDemo1 {<br>        public static void main(String[] args) {<br>        /</em><br>         * 常量使用算数运算符<br>         */<br>        System.out.println(10+20);</p>
<pre><code>    /*
     * 变量使用算数运算符
     */
    int x = 10;
    int y = 20;
    //&quot;+&quot;作为加法运算使用
    int z = x + y; 
    //&quot;+&quot;作为连接字符串使用
    System.out.println(&quot;x=&quot;+x);
    System.out.println(&quot;y=&quot;+y);
    System.out.println(&quot;z=&quot;+z);
}</code></pre><p>}<br>###12算数运算符_2<br>    * A:算数运算符++、–的使用<br>        * a: ++运算符，会在原有值的基础上自增1<br>        * b: –运算符，会在原有值的基础上自减1。<br>    * B:++  – 位置的使用<br>        * a:++,–运算符后置时，先使用变量a原有值参与运算操作，运算操作完成后，变量a的值自增1或者自减1；<br>        * b:++，–运算符前置时，先将变量a的值自增1或者自减1，然后使用更新后的新值参与运算操作。<br>###13赋值运算符<br>    * A: 赋值运算符的使用<br>        运算符    运算规则    范例        结果<br>        =    赋值        int a=2        2<br>        +=    加后赋值    int a=2，a+=2    4<br>        -=    减后赋值    int a=2，a-=2    0<br>        <em>=    乘后赋值    int a=2，a</em>=2    4<br>        /=    整除后赋值    int a=2，a/=2    1<br>        %=    取模后赋值    int a=2，a%=2    0</p>
<pre><code>* B：案例演示

     * 赋值运算符
     * +=, -=, *=, /=, %= ： 
     * 上面的运算符作用：将等号左右两边计算，会将结果自动强转成等号左边的数据类型,再赋值给等号左边的
     * 注意：赋值运算符左边必须是变量

    public class OperatorDemo2 {
        public static void main(String[] args) {
            byte x = 10;
            x += 20;// 相当于 x = (byte)(x+20);
            System.out.println(x);
        }
    }</code></pre><p>###14比较运算符<br>    * A:比较运算符的使用<br>        运算符    运算规则    范例    结果<br>        ==    相等于        4==3    False<br>        !=    不等于        4!=3    True<br>        &lt;    小于        4&lt;3    False<br>        &gt;    大于        4&gt;3    True<br>        &lt;=    小于等于    4&lt;=3    False<br>        &gt;=    大于等于    4&gt;=3    True</p>
<p>​<br>###15逻辑运算符<br>    * A: 逻辑运算符的使用<br>        运算符    运算规则    范例        结果<br>        &amp;    与        false&amp;true    False<br>        |    或        false|true    True<br>        ^    异或        true^flase    True<br>        !    非        !true        Flase<br>        &amp;&amp;    短路与        false&amp;&amp;true    False<br>        ||    短路或        false||true    True</p>
<pre><code>规律小结:
    短路与&amp;&amp;:参与运算的两边数据，有false，则运算结果为false；
    短路或||:参与运算的两边数据，有true，则运算结果为true；
    逻辑非! : 参与运算的数据，原先是true则变成false，原先是false则变成true。</code></pre><p>​    </p>
<p>###16三元运算符<br>    * A: 格式:<br>        (条件表达式)？表达式1：表达式2；</p>
<pre><code>* B: 代码案例
    方式一：
    System.out.println( 3&gt;2 ? “正确” : “错误” ); 
    // 三元运算符运算后的结果为true，运算结果为表达式1的值“正确”，然后将结果“正确”，在控制台输出打印

    方式二：
    int a = 3;
    int b = 4;
    String result = (a==b) ? “相等” : “不相等”;  
    //三元运算符运算后的结果为false，运算结果为表达式2的值“不相等”，然后将结果赋值给了变量result

    方式三：
    int n = (3&gt;2 &amp;&amp; 4&gt;6) ? 100 : 200;
    //三元运算符运算后的结果为false，运算结果为表达式2的值200,然后将结果200赋值给了变量n</code></pre><p>​<br>​<br>###17运算符优先级<br>    优先级    描述        运算符<br>    1    括号        ()、[]<br>    2    正负号        +、-<br>    3    自增自减，非    ++、–、!<br>    4    乘除，取余    <em>、/、%<br>    5    加减        +、-<br>    6    移位运算    &lt;&lt;、&gt;&gt;、&gt;&gt;&gt;<br>    7    大小关系    &gt;、&gt;=、&lt;、&lt;=<br>    8    相等关系    ==、!=<br>    9    按位与        &amp;<br>    10    按位异或    ^<br>    11    按位或        |<br>    12    逻辑与        &amp;&amp;<br>    13    逻辑或        ||<br>    14    条件运算    ?:<br>    15    赋值运算    =、+=、-=、</em>=、/=、%=<br>    16    位赋值运算    &amp;=、|=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=</p>
<p>###18    商场库存清单案例<br>    A: 案例分析.<br>        * a:观察清单后，可将清单分解为三个部分（清单顶部、清单中部、清单底部）<br>        * b:清单顶部为固定的数据，直接打印即可<br>        * c:清单中部为商品，为变化的数据，需要记录商品信息后，打印<br>            经过观察，我们确定一项商品应该有如下几个属性：<br>            品牌型号: 即商品名称，String型<br>            尺寸：物品大小，double型<br>            价格：物品单价，double型<br>            配置：这一项为每种商品的配置信息，String型<br>            库存数：这一项为每种商品的库存个数，int型</p>
<pre><code>    * d:清单底部包含了统计操作，需经过计算后，打印
        我们发现两个单独的可变化量
        总库存数：所有商品总个数，int型
        库存商品总金额：所有商品金额，double型

B: 案例代码实现
    //步骤一:  创建Demo01库存清单.java文件，编写main主方法
    public class Demo01库存清单 {
        public static void main(String[] args) {
        }
    }
    //步骤二:  记录每种库存商品信息
    //苹果笔记本电脑
    String macBrand = &quot;MacBookAir&quot;;
    double macSize = 13.3;
    double macPrice = 6988.88;
    int macCount = 5;

    //联想Thinkpad笔记本电脑
    String thinkpadBrand = &quot;ThinkpadT450&quot;;
    double thinkpadSize = 14.0;
    double thinkpadPrice = 5999.99;
    int thinkpadCount = 10;

    //华硕ASUS笔记本电脑
    String ASUSBrand = &quot;ASUS-FL5800&quot;;
    double ASUSSize = 15.6;
    double ASUSPrice = 4999.50;
    int ASUSCount = 18;

    //步骤三: 统计库存总个数、库存总金额
    int totalCount = macCount + thinkpadCount + ASUSCount;
    double totalMoney = (macCount * macPrice) + (thinkpadCount * thinkpadPrice) + (ASUSCount * ASUSPrice);

    //步骤四: 列表顶部
    System.out.println(&quot;------------------------------商城库存清单-----------------------------&quot;);
    System.out.println(&quot;品牌型号    尺寸    价格    库存数&quot;);

    步骤四:打印库存清单中部信息
    //列表中部
    System.out.println(macBrand+&quot;    &quot;+macSize+&quot;    &quot;+macPrice+&quot;    &quot;+macCount);
    System.out.println(thinkpadBrand+&quot;    &quot;+thinkpadSize+&quot;    &quot;+thinkpadPrice+&quot;    &quot;+thinkpadCount);
    System.out.println(ASUSBrand+&quot;    &quot;+ASUSSize+&quot;    &quot;+ASUSPrice+&quot;    &quot;ASUSCount);
    打印库存清单底部信息
    //列表底部
    System.out.println(&quot;-----------------------------------------------------------------------&quot;);
    System.out.println(&quot;总库存数：&quot;+totalCount); 
    System.out.println(&quot;库存商品总金额：&quot;+totalMoney);</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/C++%E5%A4%8D%E4%B9%A0(%E5%88%9D%E8%AF%86STL)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/C++%E5%A4%8D%E4%B9%A0(%E5%88%9D%E8%AF%86STL)/" class="post-title-link" itemprop="url">C++复习(初识STL)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 16:49:29" itemprop="dateCreated datePublished" datetime="2020-12-22T16:49:29+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-27 16:24:43" itemprop="dateModified" datetime="2020-12-27T16:24:43+08:00">2020-12-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1、STL简介"><a href="#1、STL简介" class="headerlink" title="1、STL简介"></a>1、STL简介</h2><p>STL简称标准模板库，它是所有C++编译器和操作系统平台都支持的一种库。</p>
<p>STL的内容从广义上分为三个部分：容器、迭代器、算法。</p>
<p>STL的一个基本理念就是将数据和操作分离，数据又容器类别加以管理，操作则由算法管理，迭代器则用于连接两者(类似指针)。STL的结构如下：</p>
<p><img src="/2020/12/22/C++%E5%A4%8D%E4%B9%A0(%E5%88%9D%E8%AF%86STL)/qq_pic_merged_1609041808915.jpg" alt></p>
<p>在C++标准中，STL被组织在13个头文件中:<algorithm>、<deque>、<functional> <iterator> <vector> <list> <map> <memory> <numric> <queue> <set> <stack> <utility>。</utility></stack></set></queue></numric></memory></map></list></vector></iterator></functional></deque></algorithm></p>
<h3 id="1-1、容器"><a href="#1-1、容器" class="headerlink" title="1.1、容器"></a>1.1、容器</h3><p>容器类集合在C++中就是标准模板库(STL)。</p>
<p>容器的定义为：在数据存储上，有一种对象类型，它可以装入<strong>其它对象</strong>或<strong>指向**</strong>其它<strong>对象的</strong>指针<strong>，这种对象类型就叫做容器。简单地说，</strong>容器就是保存其它对象的对象**。并且容器类里面还有一系列成员函数用来处理其它对象的方法。</p>
<p>另外容器是可以自由扩展的，即可以自行申请或者释放空间，并且用最优的算法来执行命令。</p>
<p>以下是STL中的主要容器:</p>
<p>template<typename t></typename></p>
<p>vector<T> 是一种<strong>向量，也可以说成是可以自由扩展的数组。</strong></T></p>
<p>list<T> 是一种<strong>双向链表</strong>容器。</T></p>
<p>queue<T> 是一种<strong>队列</strong>容器。</T></p>
<p>stack<T> 是一种栈容器。</T></p>
<p>priority<T> 是一种<strong>按值排序的队列</strong>容器。</T></p>
<p>set<T> 是一种<strong>集合</strong>容器，集合里面是相同的数据类，但不允许有重复元素。</T></p>
<p>multiset<T> 是一种<strong>允许出现重复元素</strong>的集合容器。</T></p>
<p>map&lt;key,value&gt; 隐射，是一种关联数组容器，即<strong>键值对</strong>元素。</p>
<p>multimap&lt;key,value&gt; 是一种允许出现重复key值得关联数组容器。</p>
<p>其中以上容器可分为两大类：序列式容器和关联式容器。</p>
<p><strong>序列式容器:vector、list、deque</strong></p>
<p><strong>关联式容器:set、map、multiset、multipap</strong></p>
<h3 id="1-2、迭代器"><a href="#1-2、迭代器" class="headerlink" title="1.2、迭代器"></a>1.2、迭代器</h3><p>迭代器是STL中最基本的一部分，它用于将容器与算法联系起来，起着粘合剂的作用，几乎所有STL提供的算法都是通过迭代器存取元素来实现的，<strong>类似于指针，但是比指针功能多，只有当参数类型是C++基本数据类型时，迭代器就是指针。</strong></p>
<p>STL中定义了5中类型的迭代器：</p>
<p>输入迭代器：用于读取数据</p>
<p>输出迭代器：用于写入数据</p>
<p>前向迭代器：既可以输入也可以输出，并且可以对一个值进行多次读写</p>
<p>双向迭代器：既可以用来读也可以用来写，比前向迭代器多一个后向元素操作功能</p>
<p>随机访问迭代器：可以随机访问容器中的数据，在双向迭代器上增加了功能，功能最强大。</p>
<p>每一种容器都支持某一种类型的迭代器。</p>
<h3 id="1-3、算法"><a href="#1-3、算法" class="headerlink" title="1.3、算法"></a>1.3、算法</h3><p>STL提供了大概70个实现算法的<strong>模板函数</strong>，即适用于不同容器进行操作。</p>
<h2 id="2、序列式容器"><a href="#2、序列式容器" class="headerlink" title="2、序列式容器"></a>2、序列式容器</h2><h3 id="2-1、序列式容器概述。"><a href="#2-1、序列式容器概述。" class="headerlink" title="2.1、序列式容器概述。"></a>2.1、序列式容器概述。</h3><p>序列式容器也叫做顺序性容器，<strong>各元素之间有顺序的线性表</strong>，是一种<strong>线性结构</strong>的有序群集。</p>
<p>容器中的元素都是可排序的(有顺序的)，但未必是已经有序的。序列式容器最重要的特点就是可以在首端删除元素，在尾端添加元素，而双向序列容器(deque)，允许在两端添加和删除元素。</p>
<p>序列式容器一般有两种存储方式:连续存储(vector、deque)和链式存储(list)。</p>
<p>序列中每个元素都有固定的位置，除非用删除或者插入的操作改变这个位置，这个位置和元素本身无关，和操作的<strong>逻辑顺序有关。</strong></p>
<h4 id="2-1-1、vector向量的实现以及访问特点"><a href="#2-1-1、vector向量的实现以及访问特点" class="headerlink" title="2.1.1、vector向量的实现以及访问特点"></a>2.1.1、vector向量的实现以及访问特点</h4><p><strong>vector向量容器一种支持高效的随机访问和高效向尾部插入新元素的容器。向量容器一般实现为一个动态分配的数组</strong>，向量中的元素连续地存放在这个数组中，因此对向量容器进行随机访问，具有和动态访问数组类似的效率。</p>
<p>向量容器具有自动扩展容器的功能，即每次插入一个新元素都是“分配新空间-复制元素-释放原空间”，这样<strong>效率会低，但是实际分配的空间则会大于所需要的空间。</strong></p>
<p>另外<strong>当要删除元素时，多出的闲置空间并不会被释放</strong>，因为再插入新元素时可能会重新占用这些空间，即有两个概念：向量容器的容量(capacity)为空间所能存储的最多元素的大小，向量容器的大小(size)为容器实际存储元素的个数。</p>
<p>向量容器中插入新元素时，插入位置之后的元素都要被顺序地往后移动，并且插入位置越靠前，执行插入所需的时间就越多，但<strong>在向量尾部插入元素的效率就比较高</strong>，<strong>因此在总体上向量容器的插入操作效率并不高。</strong></p>
<p><strong>在向向量容器中插入元素时，如果插入操作引起了向量容器的扩展，那么执行插入之前的所获得的一切迭代器、指针、引用都会失效，因为空间被重新分配了，元素的内存地址发生了变化。</strong></p>
<p>如果插入操作没有引起向量容器的扩展，那么只有处于插入位置之后的迭代器、指针、引用失效，因为只有插入位置后面的元素被移动了。</p>
<p>向量容器中删除元素时与插入相类似，即被删除元素越靠前，所需时间就越多，<strong>但是删除操作不会引起容器容量的改变</strong>，因此被删除元素之前的迭代器、指针、引用都能够继续使用，被删除元素之后的</p>
<p>则会失效。</p>
<h4 id="2-1-2、deque双端队列的实现以及访问特点"><a href="#2-1-2、deque双端队列的实现以及访问特点" class="headerlink" title="2.1.2、deque双端队列的实现以及访问特点"></a>2.1.2、deque双端队列的实现以及访问特点</h4><p>deque与vector不同，它是双端开口的，是一种支持向两端插入数据并支持随机访问的容器。双端队列中的数据被表示为一个分段数组，容器中的元素分段存放在一个个大小固定的数组中，此外容器还需要维护一个存放这些数组首地址的索引数组。如图所示</p>
<p>分段数组的大小是固定的，并且它们的首地址被连续地存储在索引数组中，因此可以对双端队列进行随机访问。</p>
<p><img src="/2020/12/22/C++%E5%A4%8D%E4%B9%A0(%E5%88%9D%E8%AF%86STL)/qq_pic_merged_1609041824548.jpg" alt></p>
<p>注意：<strong>deque容器在首尾进行添加、删除效率都很高</strong>，而在中间就不高，并且在首尾删除时只会让被删除元素的迭代器、指针、引用失效，不会影响其它元素，并且在删除元素之后，不使用的内存区块会被释放掉，这点与vector不一样。而在中间删除时则会使所有的迭代器、指针、引用失效。</p>
<p>deque容器的插入效率比较低，因为每插入一个数据，就需要将插入点到另外一段之间的所有元素向容器的另外一端移动，并且插入位置越靠近中间，所需时间越多，这样插入也会使所有的迭代器、指针、引用失效。</p>
<h4 id="2-1-3、list列表的实现及访问特点"><a href="#2-1-3、list列表的实现及访问特点" class="headerlink" title="2.1.3、list列表的实现及访问特点"></a>2.1.3、list列表的实现及访问特点</h4><p><strong>列表是一种不能随机访问，但可以高效地在任意位置插入和删除元素的容器，列表容器一般实现为链表，并且是双向链表。</strong>如图所示：</p>
<p><img src="/2020/12/22/C++%E5%A4%8D%E4%B9%A0(%E5%88%9D%E8%AF%86STL)/qq_pic_merged_1609043291908.jpg" alt></p>
<p>在列表中插入新的元素 只需要为新元素新建立一个新链表节点，并修改前后两个结点的指针，而不需要移动任何已有元素，因此效率很高，并且不会使任何已有的迭代器、指针、引用失效。</p>
<p>在列表中删除元素时，需要释放掉被删除元素所占用的空间，然后修改前后两个结点的指针，也不需要移动任何元素，因此效率很高，并且执行删除操作时，只会使指向被删除元素的迭代器、指针、引用失效。</p>
<p>即：</p>
<p><strong>需要进行大量的随机访问操作时，使用vector</strong></p>
<p><strong>需要进行大量的随机插入或者删除操作时，使用list</strong></p>
<h3 id="2-2、vector类模板"><a href="#2-2、vector类模板" class="headerlink" title="2.2、vector类模板"></a>2.2、vector类模板</h3><p>vector是STL中一种自定义数据类型，包含在头文件<vector>中，定义如下：</vector></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> = <span class="title">allocator</span>&lt;T&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span>;</span></span><br></pre></td></tr></table></figure>

<p>vetor是将元素放置于一个动态数组当中加以管理的容器，是最简单的序列式容器。</p>
<h4 id="2-2-1、创建vecor对象"><a href="#2-2-1、创建vecor对象" class="headerlink" title="2.2.1、创建vecor对象"></a>2.2.1、创建vecor对象</h4><p>vector类模板中定义了不同的重载构造函数，因此vector对象的创建与初始化也有不同的方式，</p>
<p>1、指定容器大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;元素类型&gt; 对象名(容器大小)</span><br></pre></td></tr></table></figure>

<p>&lt;&gt;中的类型是容器中元素的类型，例如<int>就表示此容器中存储的是int类型的数据。</int></p>
<p><strong>注意：vector对象在定义后所有元素都会被初始化，如果是基本数据类型，啧啧都会被初始化为0，如果是其它数据类型容器，则由类的默认构造函数初始化。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//创建一个容量大小为10的int类型容器v1</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">5</span>)</span></span>;<span class="comment">//创建一个容量为5的string类型容器v2</span></span><br></pre></td></tr></table></figure>

<p>这种情况下，指定了容器大小，但是没有指定初始值，标准库就好自动创建一个初始值赋值给数组中的所有元素，这个初始值由元素类型而定。</p>
<p>2、指定初始值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;元素类型&gt; 对象名(容器大小,元素初始值);</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>,<span class="number">1</span>)</span></span>;<span class="comment">//10个元素的初始值都为1</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">3</span>,<span class="string">"aa"</span>)</span></span>;<span class="comment">//3个元素的初始值都为“aa"</span></span><br></pre></td></tr></table></figure>

<p>3、列表初始化(C++11新标准)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;<span class="comment">//v1有两个元素1，2</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v2=&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;;<span class="comment">//v2有3个元素，分别为字符串a b c</span></span><br></pre></td></tr></table></figure>

<p>注意：列表初始化有两种方式，带”=“符号和不带”=“符号都可以。</p>
<p>4、初始化状态为空</p>
<p>vector对象可以初始化状态为空，即既没有指定容器大小，也没有指定初始值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;<span class="comment">//创建一个空的int型对象</span></span><br></pre></td></tr></table></figure>

<p>5、用vector对象来初始化另外一个容器对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(v1)</span></span>;<span class="comment">//用v1来初始化v2</span></span><br><span class="line">Vector&lt;<span class="keyword">int</span>&gt; v3=v2;<span class="comment">//用v2数组给v3数组赋值</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：用一个vector对象来初始化另外一个容器对象时，两个vector对象的元素类型必须相同，因为它调用的是vector的复制构造函数。</strong></p>
<p>复制构造函数会创建一个临时对象来为容器复制，这样为造成效率低下，我们可以用emplace_back()函数代替，它可以直接给对象赋值。</p>
<p>访问vector对象可以用随机迭代器，也就是下标的形式来访问。</p>
<p><strong>注意：空的vector容器不可以使用下标直接赋值，例如vector<int> v; v[2]=2;是错误语句，因为此时v是空的，不包含任何元素，所有没有相对应的下标来给元素赋值。</int></strong></p>
<h4 id="2-2-2、emplace-back-函数"><a href="#2-2-2、emplace-back-函数" class="headerlink" title="2.2.2、emplace_back()函数"></a><strong>2.2.2、emplace_back()函数</strong></h4><p>c++开发中我们会经常用到插入操作对stl的各种容器进行操作，比如vector,map,set等。在引入右值引用，转移构造函数，转移复制运算符之前，通常使用push_back()向容器中加入一个右值元素(临时对象)时，首先会调用构造函数构造这个临时对象，然后需要调用拷贝构造函数将这个临时对象放入容器中。原来的临时变量释放。这样造成的问题就是临时变量申请资源的浪费。<br>引入了右值引用，转移构造函数后，push_back()右值时就会调用构造函数和转移构造函数,如果可以在插入的时候直接构造，就只需要构造一次即可。这就是c++11 新加的emplace_back。</p>
<p>emplace_back函数原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">emplace_back</span> (<span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure>

<p>在容器尾部添加一个元素，这个元素原地构造，不需要触发拷贝构造和转移构造。而且调用形式更加简洁，直接根据参数初始化临时对象的成员。<br>一个很有用的例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">President</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> country;  </span><br><span class="line">    <span class="keyword">int</span> year;  </span><br><span class="line"> </span><br><span class="line">    President(<span class="built_in">std</span>::<span class="built_in">string</span> p_name, <span class="built_in">std</span>::<span class="built_in">string</span> p_country, <span class="keyword">int</span> p_year)  </span><br><span class="line">        : name(<span class="built_in">std</span>::<span class="built_in">move</span>(p_name)), country(<span class="built_in">std</span>::<span class="built_in">move</span>(p_country)), year(p_year)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am being constructed.\n"</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    President(<span class="keyword">const</span> President&amp; other)</span><br><span class="line">        : name(<span class="built_in">std</span>::<span class="built_in">move</span>(other.name)), country(<span class="built_in">std</span>::<span class="built_in">move</span>(other.country)), year(other.year)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am being copy constructed.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    President(President&amp;&amp; other)  </span><br><span class="line">        : name(<span class="built_in">std</span>::<span class="built_in">move</span>(other.name)), country(<span class="built_in">std</span>::<span class="built_in">move</span>(other.country)), year(other.year)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am being moved.\n"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    President&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> President&amp; other);  </span><br><span class="line">&#125;;  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;President&gt; elections;  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"emplace_back:\n"</span>;  </span><br><span class="line">    elections.emplace_back(<span class="string">"Nelson Mandela"</span>, <span class="string">"South Africa"</span>, <span class="number">1994</span>); <span class="comment">//没有类的创建  </span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;President&gt; reElections;  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\npush_back:\n"</span>;  </span><br><span class="line">    reElections.push_back(President(<span class="string">"Franklin Delano Roosevelt"</span>, <span class="string">"the USA"</span>, <span class="number">1936</span>));  </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nContents:\n"</span>;  </span><br><span class="line">    <span class="keyword">for</span> (President <span class="keyword">const</span>&amp; president: elections) &#123;  </span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; president.name &lt;&lt; <span class="string">" was elected president of "</span>  </span><br><span class="line">            &lt;&lt; president.country &lt;&lt; <span class="string">" in "</span> &lt;&lt; president.year &lt;&lt; <span class="string">".\n"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> (President <span class="keyword">const</span>&amp; president: reElections) &#123;  </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; president.name &lt;&lt; <span class="string">" was re-elected president of "</span>  </span><br><span class="line">            &lt;&lt; president.country &lt;&lt; <span class="string">" in "</span> &lt;&lt; president.year &lt;&lt; <span class="string">".\n"</span>;  </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">emplace_back:</span><br><span class="line">I am being constructed.</span><br><span class="line"> </span><br><span class="line">push_back:</span><br><span class="line">I am being constructed.</span><br><span class="line">I am being moved.</span><br><span class="line"> </span><br><span class="line">Contents:</span><br><span class="line">Nelson Mandela was elected president of South Africa in <span class="number">1994.</span></span><br></pre></td></tr></table></figure>

<p> <strong>新版本的原型展示： void push_back(const value_type&amp; x); void push_back(value_type&amp;&amp; x); &lt;typename… Args&gt; reference emplace_back(Args&amp;&amp;… args); 两者区别：push_back传入一个事先存在的元素对象，调用的是拷贝或移动构造来生成这个新压入的元素对象：construct(<em>des, class_name&amp;|&amp;&amp; x)） emplace_back：多个事先存在的对象，调用示义：construct(</em>des, other_type &amp;x|&amp;&amp;x, type_name &amp;|&amp;&amp;,…) emplace_back传参不定，编译器需要在调用时才生成具体的实现，push_back只是emplace_back的两个偏移化版本！ push_back只能用类中的拷贝或移动构造，而emplace_back还可以是类中的其他多参数的构造函数，这是优点也是缺点（代码翻倍）&amp;&amp;在普通函数中作为参数时，是万能引用，并不是右值引用，在函数体中会使用forward完美转发，调用时是复制或移动和你传的值有关，你传左值它就用左值版本，传右值就用右值版本，心里要有数。如果一个类没有上诉的拷贝或移动构造，则不能用于STL容器中，如果没有相应参数类型的构造实现，emplace_back编译不过，找不到它需要的对应构造函数.. move和copy构造唯一区别：move时，指针属性只是简单的拷贝指针，而copy中，指针属性被拷贝的同时，它所指的具体内容也还需要深度copy下去…我们在实现类的两个构造时特别要注意这一点，move中要将旧对象的指针属性置nullptr，这意味着相应的对象不再适合使用了（它必须是临时对象的原因！转移后，内部的指针属性失效！） move和copy的性能对比：正如上说，move只是指针优化，如果类本身没有指针属性，则它不需要move，我们也不必强制move不可，copy和move在内置类型和简单类型（指无指针属性、即构造时不需要new）没区别</strong></p>
<h4 id="2-2-3、获取容器的容量和大小"><a href="#2-2-3、获取容器的容量和大小" class="headerlink" title="2.2.3、获取容器的容量和大小"></a>2.2.3、获取容器的容量和大小</h4><p>vector提供了两个函数capacity()和size()来分别获取容器的容量和大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v.capacity();</span><br><span class="line">v.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>

<p>其中v为创建的向量对象。</p>
<h4 id="2-2-4、预留容器容量reserve"><a href="#2-2-4、预留容器容量reserve" class="headerlink" title="2.2.4、预留容器容量reserve()"></a>2.2.4、预留容器容量reserve()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.reserve(<span class="keyword">int</span> elem);</span><br></pre></td></tr></table></figure>

<p>elem为要预留容器的容量最小容量。</p>
<h4 id="2-2-5、赋值函数assign"><a href="#2-2-5、赋值函数assign" class="headerlink" title="2.2.5、赋值函数assign()"></a>2.2.5、赋值函数assign()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v.assign(n,elem);<span class="comment">//将n个elem元素赋值给容器</span></span><br><span class="line">v.assign(<span class="built_in">begin</span>,<span class="built_in">end</span>);<span class="comment">//将[begin,end)迭代器所指区间赋值给容器</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：第二种赋值方式是左闭右开的形式。</strong></p>
<h4 id="2-2-6、访问容器的元素-、at"><a href="#2-2-6、访问容器的元素-、at" class="headerlink" title="2.2.6、访问容器的元素[]、at()"></a>2.2.6、访问容器的元素[]、at()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v[<span class="keyword">int</span> idx];</span><br><span class="line">v.at(<span class="keyword">int</span> idx);<span class="comment">//返回索引指向的数据，与[]用法相同</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-7、从尾部插入和删除元素push-back、pop-back"><a href="#2-2-7、从尾部插入和删除元素push-back、pop-back" class="headerlink" title="2.2.7、从尾部插入和删除元素push_back、pop_back"></a>2.2.7、从尾部插入和删除元素push_back、pop_back</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v.push_back(type elem&amp; t);</span><br><span class="line">v.pop_back();</span><br></pre></td></tr></table></figure>

<p>push_back()函数是向vector容器末尾添加元素，即先创建一个空的vector对象，再调用push_back()函数向其中添加元素，而pop_bakc()用于弹出vector容器末尾的一个元素。</p>
<p><strong>注意：由于vector是可自由扩展容器大小的容器，因此很容易因为没有初始化容量而导致浪费大部分时间用于自动申请空间上，因此最好先定义一个大小足够的空vector对象，再在运行时向其中添加元素。</strong></p>
<h4 id="2-2-8、获取头部和尾部元素"><a href="#2-2-8、获取头部和尾部元素" class="headerlink" title="2.2.8、获取头部和尾部元素"></a>2.2.8、获取头部和尾部元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v.front();</span><br><span class="line">v.back();</span><br></pre></td></tr></table></figure>

<p><strong>它们分别返回容器的头尾元素的引用。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">begin</span>();</span><br><span class="line">v.<span class="built_in">end</span>();</span><br></pre></td></tr></table></figure>

<p><strong>begin和end则返回头尾元素的迭代器(相当于指针),并且begin返回第一个元素的迭代器，end返回最后一个元素的下一个位置的迭代器。</strong></p>
<h4 id="2-2-9、插入和删除元素"><a href="#2-2-9、插入和删除元素" class="headerlink" title="2.2.9、插入和删除元素"></a>2.2.9、插入和删除元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v.insert(pos,elem);<span class="comment">//在pos位置上插入元素elem，返回新数据的位置</span></span><br><span class="line">v.insert(pos,n,elem);<span class="comment">//在pos位置上插入n个elem元素，无返回值</span></span><br><span class="line">v.insert(pos,<span class="built_in">begin</span>,<span class="built_in">end</span>);<span class="comment">//在pos位置上插入[begin,end)区间的数据，无返回值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v.erase(pos);<span class="comment">//移除pos位置上的元素，返回下一个数据的位置</span></span><br><span class="line">v.erase(<span class="built_in">begin</span>,<span class="built_in">end</span>);<span class="comment">//移除[begin,end)区间的数据，返回下一个严肃的位置</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：insert和erase函数中的位置只能是由begin()或者end()返回的迭代器来指示，而不能用纯粹的数字来作为参数。</strong></p>
<h4 id="2-2-10、翻转函数reverse-begin-end"><a href="#2-2-10、翻转函数reverse-begin-end" class="headerlink" title="2.2.10、翻转函数reverse(begin,end)"></a>2.2.10、翻转函数reverse(begin,end)</h4><h4 id="2-2-11、判空函数empty"><a href="#2-2-11、判空函数empty" class="headerlink" title="2.2.11、判空函数empty()"></a>2.2.11、判空函数empty()</h4><h4 id="2-2-12、重新设置容器大小函数resize"><a href="#2-2-12、重新设置容器大小函数resize" class="headerlink" title="2.2.12、重新设置容器大小函数resize()"></a>2.2.12、重新设置容器大小函数resize()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V.resize(n);</span><br><span class="line">v.resize(n,elem);</span><br></pre></td></tr></table></figure>

<p><strong>注意：当容器原来大小小于要设置的大小n时，会扩容，相反则会销毁多余部分。</strong></p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*vector容器示例</span></span><br><span class="line"><span class="comment">	vector&lt;int&gt; v;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	v.empty(); // 判断容器v是否是空。v.empty() == 1表示v为空</span></span><br><span class="line"><span class="comment">	v.push_back(10); // 添加元素10到v</span></span><br><span class="line"><span class="comment">	v.pop_back(); //  从v中取出元素，容器中的该元素就删除了</span></span><br><span class="line"><span class="comment">	v.size(); // 获取容器的大小</span></span><br><span class="line"><span class="comment">	sort(v.begin(), v.end());  // 对v中元素排序，sort函数参见sort的用法</span></span><br><span class="line"><span class="comment">	// sort(v.begin(), v.end(), cmp); // 需要定义cmp函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = myv.<span class="built_in">begin</span>(); it != myv.<span class="built_in">end</span>(); it++) <span class="comment">//通过迭代器访问容器值 </span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assignfun1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> <span class="comment">//给容器赋值，参数需要用引用或指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">21</span>, <span class="number">4</span>, <span class="number">55</span>, <span class="number">22</span>, <span class="number">46</span>, <span class="number">79</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">78</span>, <span class="number">34</span>, <span class="number">100</span> &#125;;</span><br><span class="line">	v.assign(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">//用数组给v容器赋值</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assignfun2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> <span class="comment">//给容器赋值，参数需要用引用或指针 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		v.push_back(i); <span class="comment">//</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Multi</span>  //类模板,用于<span class="title">for_each</span>函数中 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Multi(<span class="keyword">const</span> T&amp; v) :value(v) &#123;&#125;  <span class="comment">//构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T&amp; elem)</span> <span class="keyword">const</span> </span>&#123; elem *= value; &#125; <span class="comment">//重载()运算符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VectorFun</span><span class="params">()</span><span class="comment">//vector容器的使用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, k;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itv;</span><br><span class="line"></span><br><span class="line">	assignfun1(v);</span><br><span class="line">	<span class="comment">//assignfun2(v);</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>; <span class="comment">// 可以用下标来访问这个容器，跟数组类似 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"使用迭代器来输出数据：\n"</span>;</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"翻转数据："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	reverse(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); <span class="comment">// reverse函数功能：翻转字符串 ，翻转数组， 用于STL的翻转。</span></span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//排序</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">//调用sort()算法将容器中元素从小到大排列 //less&lt;int&gt;(),其他：equal_to, not_equal_to,less_equal,greater_equal</span></span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">	sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());<span class="comment">//调用sort()算法将容器中元素从大到小排列 //greater&lt;int&gt;()</span></span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"查找："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"input num="</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">	itv = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), k);</span><br><span class="line">	<span class="comment">//find()算法用于在[begin, last)区间查找value元素是否存在。</span></span><br><span class="line">	<span class="comment">//如果存在，就返回指向这个元素的迭代器，如果不存在，就返回end。</span></span><br><span class="line">	<span class="keyword">if</span> (itv != v.<span class="built_in">end</span>())</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"find ok="</span> &lt;&lt; *itv &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"No find.\n"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//for_ each()函数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"对每个元素乘以5，结果为：\n"</span>;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), Multi&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>));</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//累加</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"累加："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"累加和="</span> &lt;&lt; accumulate(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//需要头文件 //#include &lt;numeric&gt; </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printlist</span><span class="params">(<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; myl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = myl.<span class="built_in">begin</span>(); it != myl.<span class="built_in">end</span>(); it++) <span class="comment">//通过迭代器访问容器值 </span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListFun</span><span class="params">()</span> <span class="comment">//list容器的操作 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">21</span>, <span class="number">4</span>, <span class="number">55</span>, <span class="number">22</span>, <span class="number">46</span>, <span class="number">79</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">78</span>, <span class="number">34</span>, <span class="number">100</span> &#125;;</span><br><span class="line">	mylist.assign(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">//用数组给v容器赋值</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nList容器：\n"</span>;</span><br><span class="line">	printlist(mylist);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//排序，list容器本身有sort函数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"从小到大排序：\n"</span>;</span><br><span class="line">	mylist.sort();<span class="comment">//升序 </span></span><br><span class="line">	printlist(mylist);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"从大到小排序：\n"</span>;</span><br><span class="line">	mylist.sort(greater&lt;<span class="keyword">int</span>&gt;());<span class="comment">//降序 </span></span><br><span class="line">	printlist(mylist);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//vector容器的使用 </span></span><br><span class="line">	VectorFun();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//list容器的使用 </span></span><br><span class="line">	ListFun();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//容器中存储结构体数据（对象数据）的操作方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">	<span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assignfun1</span><span class="params">(<span class="built_in">vector</span>&lt;student&gt;&amp; v)</span> <span class="comment">//给容器赋值，参数需要用引用或指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	student arr[] = &#123; &#123;<span class="number">1001</span>,<span class="string">"name1"</span>,<span class="string">'F'</span>,<span class="number">90</span>&#125;,&#123;<span class="number">1002</span>,<span class="string">"name2"</span>,<span class="string">'M'</span>,<span class="number">95</span>&#125;,&#123;<span class="number">1003</span>,<span class="string">"name3"</span>,<span class="string">'M'</span>,<span class="number">91</span>&#125; &#125;;</span><br><span class="line">	v.assign(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(student)); <span class="comment">//用数组给v容器赋值</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assignfun2</span><span class="params">(<span class="built_in">vector</span>&lt;student&gt;&amp; v)</span> <span class="comment">//给容器赋值，参数需要用引用或指针 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	student s1, s2;</span><br><span class="line">	s1.num = <span class="number">2001</span>;</span><br><span class="line">	s1.name = <span class="string">"name21"</span>;</span><br><span class="line">	s1.sex = <span class="string">'F'</span>;</span><br><span class="line">	s1.score = <span class="number">92</span>;</span><br><span class="line"></span><br><span class="line">	s2.num = <span class="number">2002</span>;</span><br><span class="line">	s2.name = <span class="string">"name22"</span>;</span><br><span class="line">	s2.sex = <span class="string">'M'</span>;</span><br><span class="line">	s2.score = <span class="number">96</span>;</span><br><span class="line"></span><br><span class="line">	v.push_back(s1);</span><br><span class="line">	v.push_back(s2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">vector</span>&lt;student&gt; myv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;student&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = myv.<span class="built_in">begin</span>(); it != myv.<span class="built_in">end</span>(); it++) <span class="comment">//通过迭代器访问容器值 </span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; it-&gt;num &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;name &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;sex &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;score &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpnum</span><span class="params">(student a, student b)</span> <span class="comment">//按num由大到小 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a.num &gt; b.num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpscore</span><span class="params">(student a, student b)</span> <span class="comment">//按score由小到大 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a.score &lt; b.score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">findnum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	findnum(<span class="keyword">int</span> num) :cmp_num(num) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(student s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cmp_num == s.num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> cmp_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">findname</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	findname(<span class="built_in">string</span> cmp_string) :cmp_name(cmp_string) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(student s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cmp_name == s.name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> cmp_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findprint</span><span class="params">(<span class="built_in">vector</span>&lt;student&gt;::iterator itv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"find ok="</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; itv-&gt;num &lt;&lt; <span class="string">" "</span> &lt;&lt; itv-&gt;name &lt;&lt; <span class="string">" "</span> &lt;&lt; itv-&gt;sex &lt;&lt; <span class="string">" "</span> &lt;&lt; itv-&gt;score &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, k;</span><br><span class="line">	<span class="built_in">string</span> namestr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;student&gt; v;</span><br><span class="line">	<span class="built_in">vector</span>&lt;student&gt;::iterator itv;</span><br><span class="line"></span><br><span class="line">	assignfun1(v);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"使用迭代器来输出数据：\n"</span>;</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; v[i].num &lt;&lt; <span class="string">" "</span> &lt;&lt; v[i].name &lt;&lt; <span class="string">" "</span> &lt;&lt; v[i].sex &lt;&lt; <span class="string">" "</span> &lt;&lt; v[i].score &lt;&lt; <span class="string">"\n"</span>; <span class="comment">// 可以用下标来访问这个容器，跟数组类似 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	assignfun2(v);</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"翻转数据："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	reverse(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); <span class="comment">// reverse函数功能：翻转字符串 ，翻转数组， 用于STL的翻转。</span></span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//排序</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"排序："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmpnum); <span class="comment">//cmpnum是比较函数 </span></span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">	sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmpscore);</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"查找："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"input num="</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">	itv = find_if(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), findnum(k));</span><br><span class="line">	<span class="comment">//find()算法用于在[begin, last)区间查找value元素是否存在。</span></span><br><span class="line">	<span class="comment">//如果存在，就返回指向这个元素的迭代器，如果不存在，就返回end。</span></span><br><span class="line">	<span class="keyword">if</span> (itv != v.<span class="built_in">end</span>())</span><br><span class="line">		findprint(itv);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"No find.\n"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"input name="</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; namestr;</span><br><span class="line">	itv = find_if(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), findname(namestr));</span><br><span class="line">	<span class="keyword">if</span> (itv != v.<span class="built_in">end</span>())</span><br><span class="line">		findprint(itv);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"No find.\n"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/C++%E5%A4%8D%E4%B9%A0(%E5%BC%82%E5%B8%B8%E5%92%8C%E6%96%AD%E8%A8%80)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/C++%E5%A4%8D%E4%B9%A0(%E5%BC%82%E5%B8%B8%E5%92%8C%E6%96%AD%E8%A8%80)/" class="post-title-link" itemprop="url">C++复习(异常和断言)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 16:48:56" itemprop="dateCreated datePublished" datetime="2020-12-22T16:48:56+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 22:54:26" itemprop="dateModified" datetime="2020-12-23T22:54:26+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/C++%E5%A4%8D%E4%B9%A0(IO%E6%B5%81)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/C++%E5%A4%8D%E4%B9%A0(IO%E6%B5%81)/" class="post-title-link" itemprop="url">C++复习(IO流)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 16:48:14" itemprop="dateCreated datePublished" datetime="2020-12-22T16:48:14+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-25 22:13:54" itemprop="dateModified" datetime="2020-12-25T22:13:54+08:00">2020-12-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>C++中有两种IO操作，一种是由C语言继承来的IO函数输入输出语句，一种是面向对象的IO流类库，IO流不是C++语言的一部分，而是标准C++库的一部分，是C++类的一个集合。</p>
<h2 id="1、C-中的输入输出"><a href="#1、C-中的输入输出" class="headerlink" title="1、C++中的输入输出"></a>1、C++中的输入输出</h2><p>输入输出是数据传递的过程，数据如流水一般从一处流到另外一处。</p>
<h3 id="1-1、C-中输入输出的分类"><a href="#1-1、C-中输入输出的分类" class="headerlink" title="1.1、C++中输入输出的分类"></a>1.1、C++中输入输出的分类</h3><p>程序的输入是指将文件中的数据传递给程序(读)，输出是指将程序中的结果传递给文件(写),C++系统将输入输出分为三类。</p>
<h4 id="1-1-1、标准IO"><a href="#1-1-1、标准IO" class="headerlink" title="1.1.1、标准IO"></a>1.1.1、标准IO</h4><p>内存与标准输入输出设备(<strong>键盘和显示器)之间的数据传递，即从键盘输入数据，输出到显示器屏幕</strong>，这种输入输出称为标准输入输出，简称标准IO。</p>
<h4 id="1-1-2、文件IO"><a href="#1-1-2、文件IO" class="headerlink" title="1.1.2、文件IO"></a>1.1.2、文件IO</h4><p>以磁盘(或光盘、硬盘)文件为对象进行输入和输出，例如从硬盘文件中输入数据，或数据输出到硬盘文件。这种<strong>以外存文件为对象</strong>的输入输出称为文件的输入输出，简称文件IO。</p>
<h4 id="1-1-3、串IO"><a href="#1-1-3、串IO" class="headerlink" title="1.1.3、串IO"></a>1.1.3、串IO</h4><p>对内存中指定的空间进行输入输出，通常指定一个<strong>字符数组为存储空间</strong>(实际上可以利用该空间存储任何信息)，这种输入输出称为字符串输入输出，简称串IO。</p>
<p><strong>输入输出的数据的传递过程会形成不同的IO流，C++将这些流定义了不同的类，用类来定义流对象以实现数据的传递。</strong></p>
<h3 id="1-2、C-IO流类的安全性和可扩展性"><a href="#1-2、C-IO流类的安全性和可扩展性" class="headerlink" title="1.2、C++IO流类的安全性和可扩展性"></a>1.2、C++IO流类的安全性和可扩展性</h3><h4 id="1-2-1、C-IO流类的安全性"><a href="#1-2-1、C-IO流类的安全性" class="headerlink" title="1.2.1、C++IO流类的安全性"></a>1.2.1、C++IO流类的安全性</h4><p>C++系统会对输入输出的数据类型进行严格的检查，防止出现C语言中scanf()输入整型变量i的值时没有写上&amp;取地址符号而造成把输入的数值存储到地址编号为1的内存中，或printf()函数没有写上格式控制符等。</p>
<h4 id="1-2-2、C-IO流类的可扩展性"><a href="#1-2-2、C-IO流类的可扩展性" class="headerlink" title="1.2.2、C++IO流类的可扩展性"></a>1.2.2、C++IO流类的可扩展性</h4><p><strong>C++可以输入输出用户自定义的数据类型，而C语言不行。</strong></p>
<h2 id="2、IO流类库简介"><a href="#2、IO流类库简介" class="headerlink" title="2、IO流类库简介"></a>2、IO流类库简介</h2><p>C++中的IO流时由stream来完成的，stream就是一条数据流，字符序列在其中“川流不息”，stream数据流主要包括输入流和输出流，可以进行输入输出操作。</p>
<p><strong>输入</strong>操作是指数据流出stream，即把stream流中的数据<strong>读取</strong>出来。</p>
<p><strong>输出</strong>操作时指数据流入stream，即将数据<strong>写入</strong>到流中的某个地方。</p>
<p>IO流类库中不同的stream类就是用来进行不同数据的读写输入输出的。</p>
<h3 id="2-1、IO流类库"><a href="#2-1、IO流类库" class="headerlink" title="2.1、IO流类库"></a>2.1、IO流类库</h3><p>C++为实现数据的输入输出定义了一个庞大的流类库，<strong>它以ios为根基类</strong>，直接派生了四个类：</p>
<p>输入流类istream、输出流类ostream、文件流基类fstream、字符串流基类strstreambase。</p>
<p>这四个直接派生类又派生出其它的类，形成了标准IO流类库、文件流类库和字符串流类库。</p>
<p>输入输出流类iostream，它同时继承了输入流类和输出流类。</p>
<p>输入文件流类ifstream，它同时继承了输入流类和文件流基类。</p>
<p>输出文件流类ofstream，它同时是继承了输出流类和文件流类。</p>
<p>输入输出文件流类fstream，它同时继承了输入输出流类和文件流基类。</p>
<p>输入字符串流类istrstream，它同时继承了输入流类和字符串流基类。</p>
<p>输出字符串流类ostrstream，它同时继承了输出流类和字符串流基类。</p>
<p>输出输出字符串流类strstream，它同时继承了输出输出流类和字符串流基类。</p>
<p>其中的每一个类都称做相应的流或流类，用来完成某一方面的功能，根据一个流或流类定义出的对象也被称为流对象。以下是它们之间的派生关系：</p>
<p><img src="/2020/12/22/C++%E5%A4%8D%E4%B9%A0(IO%E6%B5%81)/qq_pic_merged_1608870137595.jpg" alt></p>
<p><strong>即：C++流类库中定义的各种流可以给用户直接使用，它们分别包含在iostream、fstream、strstream三个头文件中。</strong></p>
<p>其中：<strong>标准IO操作iostream、文件IO操作fstream串IO操作strstream或者sstream(新版本C++支持)</strong></p>
<h3 id="2-2、缓冲区类"><a href="#2-2、缓冲区类" class="headerlink" title="2.2、缓冲区类"></a>2.2、缓冲区类</h3><p>在对数据进行输入输出时，为了减少输入输出的次数，节省计算机自由，常常需要使用到缓冲区，C++提供了一个缓冲区流类库，它以streambuf为父类的类层次，主要完成信息通过缓冲区的交换，因为streambuf是一个抽象类，不会直接使用，一般都是是用它的三个派生类。</p>
<h4 id="2-2-1、stdiobuf类"><a href="#2-2-1、stdiobuf类" class="headerlink" title="2.2.1、stdiobuf类"></a>2.2.1、stdiobuf类</h4><p>stdiobuf类主要用于C++语言的流类层次方法和C语言的标准输入输出方法火鹤使用时系统的缓冲区管理。</p>
<h4 id="2-2-2、filebuf类"><a href="#2-2-2、filebuf类" class="headerlink" title="2.2.2、filebuf类"></a>2.2.2、filebuf类</h4><p>filebuf类在streambuf类的基础上增加了文件处理功能，使用文件来保存缓冲区中的字符序列。</p>
<h4 id="2-2-3、strstreambuf类"><a href="#2-2-3、strstreambuf类" class="headerlink" title="2.2.3、strstreambuf类"></a>2.2.3、strstreambuf类</h4><p>strstreambuf类在streambuf类的基础上增加了动态内存管理功能，strstreambuf类实现从内存到缓冲区的信息交换和从缓冲区到内存的信息交换，从而可以在计算机内存之间交换数据信息。</p>
<h4 id="2-2-4、缓冲区类型"><a href="#2-2-4、缓冲区类型" class="headerlink" title="2.2.4、缓冲区类型"></a>2.2.4、缓冲区类型</h4><p>C++在定义一些流对象时都会自带有缓冲区，它提供的缓冲区有三种类型：<strong>全缓冲、行缓冲、无缓冲。</strong></p>
<h5 id="2-2-4-1、全缓冲"><a href="#2-2-4-1、全缓冲" class="headerlink" title="2.2.4.1、全缓冲"></a>2.2.4.1、全缓冲</h5><p>全缓冲指知道缓冲区被填满时才调用IO函数。对于读操作来说，知道读入内容的字节数等于缓冲区大小或者文件已经到达结尾，才进行实际的IO操作，将外村文件内容读入缓冲区；对于写操作来说，知道缓冲区被填满，才进行实际的IO操作，将缓冲区内容写到外存文件中。例如<strong>磁盘文件的读写。</strong></p>
<h5 id="2-2-4-2、行缓冲"><a href="#2-2-4-2、行缓冲" class="headerlink" title="2.2.4.2、行缓冲"></a>2.2.4.2、行缓冲</h5><p>档在输入和输出遇到换行符或者缓冲区被填满时，才执行真正的IO操作，这时，我们输入的字符先存放在缓冲区，等按下回车键时才进行实际的IO操作。<strong>标准的输入输出一般都是行缓冲。</strong></p>
<h5 id="2-2-4-3、无缓冲"><a href="#2-2-4-3、无缓冲" class="headerlink" title="2.2.4.3、无缓冲"></a>2.2.4.3、无缓冲</h5><p>没有缓冲区。<strong>例如标准错误信息输出对象cerr。</strong></p>
<h5 id="2-2-4-4、用户自定义缓冲区"><a href="#2-2-4-4、用户自定义缓冲区" class="headerlink" title="2.2.4.4、用户自定义缓冲区"></a>2.2.4.4、用户自定义缓冲区</h5><p>用户可以使用上述缓冲区类来自定义缓冲区。<strong>但在使用时需要注意对缓冲的刷新。</strong>即当数据存储在缓冲区时，如果要执行IO操作，需要刷新缓冲区，将缓冲区中的数据读或者写道某一个指定地方，其中刷新缓冲区方式为：</p>
<p>1、缓冲区满时</p>
<p>2、执行flush()函数，可以执行IO操作并且清空缓冲区</p>
<p>3、执行endl语句，该控制符可以将光标移动到输出设备中下一行开头处，并且清空缓冲区</p>
<p>4、关闭文件</p>
<h2 id="3、标准输出流和标准输入流"><a href="#3、标准输出流和标准输入流" class="headerlink" title="3、标准输出流和标准输入流"></a>3、标准输出流和标准输入流</h2><p>标准输入输出流的对象和操作方法都是由istream和ostream两个类提供的，这两个类虚继承至ios基类，它们预定义了标准输入输出流对象，并且提供了多种形式的输入输出功能。(头文件iostream)</p>
<h3 id="3-1、提取运算符和插入运算符"><a href="#3-1、提取运算符和插入运算符" class="headerlink" title="3.1、提取运算符和插入运算符"></a>3.1、提取运算符和插入运算符</h3><p>C++在进行输入时需要从流中提取数据，在输出时需要向流中插入数据，提取和插入是通过在流类库中<strong>重载”&gt;&gt;”和”&lt;&lt;”运算符来实现</strong>的。</p>
<h4 id="3-1-1、”-gt-gt-”运算符-提取运算符"><a href="#3-1-1、”-gt-gt-”运算符-提取运算符" class="headerlink" title="3.1.1、”&gt;&gt;”运算符(提取运算符)"></a>3.1.1、”&gt;&gt;”运算符(提取运算符)</h4><p>提取运算符”&gt;&gt;”，又叫<strong>输入运算符</strong>，它的<strong>本义是右移操作</strong>，常用于位运算中，例如i=2，i&gt;&gt;1,此时i=1，即十进制下右移一位除以2，左移一位乘以2。但是C++的IO流为了实现从流中提取数据，就<strong>在istream类中重载了”&gt;&gt;”运算符，其中有18种形式</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="keyword">char</span>*);</span><br><span class="line"><span class="keyword">inline</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="keyword">unsigned</span> <span class="keyword">char</span>*);</span><br><span class="line"><span class="keyword">inline</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="keyword">signed</span> <span class="keyword">char</span>*);</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="keyword">char</span>&amp;);</span><br><span class="line"><span class="keyword">inline</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="keyword">unsigned</span> <span class="keyword">char</span>&amp;);</span><br><span class="line"><span class="keyword">inline</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="keyword">signed</span> <span class="keyword">char</span>&amp;);</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(short&amp;);</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="keyword">unsigned</span> short&amp;);</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="keyword">int</span>&amp;);</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="keyword">unsigned</span> <span class="keyword">int</span>&amp;);</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="keyword">long</span>&amp;);</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="keyword">unsigned</span> <span class="keyword">long</span>&amp;);</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="keyword">float</span>&amp;);</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="keyword">double</span>&amp;);</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="keyword">long</span> <span class="keyword">double</span>&amp;);</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(streambuf*);</span><br><span class="line"><span class="keyword">inline</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; (_cdecl*_f)(istream&amp;));</span><br><span class="line"><span class="keyword">inline</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(ios&amp; (_cdecl*_f)(ios&amp;));</span><br></pre></td></tr></table></figure>

<p>其中按功能可以分为三类：前十五个用于基本数据类型的输入，第16个可以直接把提取的输入流数据插入道缓冲区buf中，最后两个则建立了支持istream环境和支持ios环境的用户自定义数据类型的输入。</p>
<p><strong>注意：istream类的对象cin调用&gt;&gt;运算符时，从流中提取数据，把数据传送个cin对象，但会跳过输入流中的空格、tab键、换行符等空白字符。</strong></p>
<p><strong>并且重载的输入运算符”&gt;&gt;”都是返回流类的istream的引用，这就使得”&gt;&gt;”运算符可以连用，例如cin&gt;&gt;a&gt;&gt;b&gt;&gt;c。</strong>(依次输入a、b、c)</p>
<h4 id="3-1-2、”-lt-lt-”运算符-插入运算符"><a href="#3-1-2、”-lt-lt-”运算符-插入运算符" class="headerlink" title="3.1.2、”&lt;&lt;”运算符(插入运算符)"></a>3.1.2、”&lt;&lt;”运算符(插入运算符)</h4><p>插入运算符”&lt;&lt;”，又叫<strong>输出运算符</strong>，它的本义是<strong>左移操作</strong>，常用于位运算中，例如i=2，i&lt;&lt;1,此时i=4，即十进制下右移一位除以2，左移一位乘以2。但是C++的IO流为了实现从流中提取数据，就<strong>在ostream类中重载了”&lt;&lt;”运算符，其中有19种形式</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">char</span>*);</span><br><span class="line"><span class="keyword">inline</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*);</span><br><span class="line"><span class="keyword">inline</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">const</span> <span class="keyword">signed</span> <span class="keyword">char</span>*);</span><br><span class="line"><span class="keyword">inline</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">char</span>);</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">unsigned</span> <span class="keyword">char</span>);</span><br><span class="line"><span class="keyword">inline</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">signed</span> <span class="keyword">char</span>);</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(short);</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">unsigned</span> short);</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">int</span>);</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">long</span>);</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"><span class="keyword">inline</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">float</span>);</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">double</span>);</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">long</span> <span class="keyword">double</span>);</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">const</span> <span class="keyword">void</span>*);</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(stream* buf);</span><br><span class="line"><span class="keyword">inline</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(istream&amp; (_cdecl*_f)(ostream&amp;));</span><br><span class="line"><span class="keyword">inline</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ios&amp; (_cdecl*_f)(ios&amp;));</span><br></pre></td></tr></table></figure>

<p>其中按功能可以分为三类：前十六个用于基本数据类型的输出，第17个可以直接从缓冲区buf中提取数据插入道输出流中，最后两个则建立了支持istream环境和支持ios环境的用户自定义数据类型的输入。</p>
<p><strong>注意：ostream类重载了”&lt;&lt;”运算符，与输入运算符”&gt;&gt;”相比，输出运算符在输出数据时有很多格式控制细节。</strong></p>
<h3 id="3-2、预定义流对象"><a href="#3-2、预定义流对象" class="headerlink" title="3.2、预定义流对象"></a>3.2、预定义流对象</h3><p>为了方便用户对基本输入输出流进行操作，C++提供了四个预定义的标准流对象：cin、cout、cerr和clog。当用户在程序中包含了<strong>iostream头文件时，编译器调用相应的构造函数产生了这四个标准流对象，这样用户就可以直接使用了。</strong></p>
<p>其中：</p>
<p>cin是istream类的对象，用于处理标准输入(即键盘输入)</p>
<p>cout是ostream类的对象，用于处理标准输出(即屏幕输出)</p>
<p>cerr和clog都是ostream类的对象，用于处理标准出错信息，并将信息显示道屏幕上。</p>
<p>预定义流对象表如下：</p>
<table>
<thead>
<tr>
<th>对象名</th>
<th>所属类</th>
<th>对应设备</th>
<th>含义</th>
<th>结合使用</th>
</tr>
</thead>
<tbody><tr>
<td>cin</td>
<td>istream</td>
<td>键盘</td>
<td>标准输入，有缓冲</td>
<td>&gt;&gt;</td>
</tr>
<tr>
<td>cout</td>
<td>ostream</td>
<td>屏幕</td>
<td>标准输出，有缓冲</td>
<td>&lt;&lt;</td>
</tr>
<tr>
<td>cerr</td>
<td>ostream</td>
<td>屏幕</td>
<td>标准错误输出，无缓冲</td>
<td>&lt;&lt;</td>
</tr>
<tr>
<td>clog</td>
<td>ostream</td>
<td>屏幕</td>
<td>标准错误输出，有缓冲</td>
<td>&lt;&lt;</td>
</tr>
</tbody></table>
<h4 id="3-2-1、cin"><a href="#3-2-1、cin" class="headerlink" title="3.2.1、cin"></a>3.2.1、cin</h4><p>cin是istream类的对象，它从标准输入设备(键盘)获取数据，程序中的变量通过提取运算符”&gt;&gt;”从流中提取数据，然后送给cin对象，由cin将对象送到指定地方。</p>
<p>注意：</p>
<p>1、<strong>cin是带缓冲区的输入流对象，只有在输入完数据并且按下回车键之后，该行数据才被送到键盘缓冲区，形成输入流，提取运算符”&gt;&gt;”才能从中提取数据。</strong>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a;</span><br></pre></td></tr></table></figure>

<p>此时从键盘输入10，则10只是存入缓冲区里面而不能为”&gt;&gt;”运算符所提取，而只有当按下回车键之后，相当于执行endl语句(清空缓冲区)，而缓冲区内的内容才被刷新形成输入流，被”&gt;&gt;”运算符提取，然后传递给cin对象，由cin对象送到变量a中存储。</p>
<p>如果从键盘输入abc，则提取操作会失败，此时cin流被设置为出错状态，只有在正常状态下才可以此从输入流中提取数据。</p>
<p>2、cin对象支持多个变量的读取，因为”&gt;&gt;”运算符都被重载为istream类的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> a;</span><br><span class="line"><span class="keyword">float</span> f;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;f;</span><br></pre></td></tr></table></figure>

<p>只是此时注意，如果直接在键盘上打上abc123，则a为abc123，还会等待下一个输入为f赋值，必须要abc空格123，此时才会对应赋值，<strong>因为cin读到空格、换行、tab键等空白字符时会清空缓冲区，等待下一次输入。</strong></p>
<p><strong>3、cin对象可以对不同类型的变量进行读入，并且也需要对应类型输入正确</strong></p>
<h4 id="3-2-2、cout"><a href="#3-2-2、cout" class="headerlink" title="3.2.2、cout"></a>3.2.2、cout</h4><p>cout是ostream类预定义的对象，对应的标准设备为屏幕，称作标准输出对象或屏幕输出对象，但也可以重定向输出道磁盘文件中。用户可以通过cout对象调用ostream类的插入运算符”&lt;&lt;”和成员函数来输出信息。</p>
<p>注意：</p>
<p>1、可以利用cout对象直接输出常量值,直接把要输出的内容放在输出运算符”&lt;&lt;”后即可，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">18238947</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"absfggdfsdfd"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>2、可以利用cout对象输出变量的值，并且在用cout输出变量值时，不用指定输出格式，输出运算符”&lt;&lt;”会根据变量的数据类型自动调用相匹配的重载函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10249</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">string</span> str1=<span class="string">"asflkjdfkjhfasd"</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>3、可以利用cout对象输出指针、引用类型的数据，并且与printf()函数用法一致，只是不需要格式控制符号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">19l</span>24;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; b=a;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出a的值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p=&amp;a;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出a的地址</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出a的值</span></span><br></pre></td></tr></table></figure>

<p><strong>4、可以利用cout对象进行连续输出</strong>，与输入运算符”&gt;&gt;”相同，输出运算符”&lt;&lt;”重载函数返回的都是ostream类对象的引用，因此也可以进行多次输出。</p>
<p><strong>5、cout也有格式化输出</strong></p>
<h4 id="3-2-3、cerr和clog"><a href="#3-2-3、cerr和clog" class="headerlink" title="3.2.3、cerr和clog"></a>3.2.3、cerr和clog</h4><p>cerr与clog都是ostream类预定义的流对象，都是用于标准错误输出，默认设备都是显示器，只是cerr没有缓冲，意味着信息将被直接发送给屏幕，不会等到缓冲区填满或遇到换行符才输出错误信息。</p>
<h3 id="3-3、标准输出流"><a href="#3-3、标准输出流" class="headerlink" title="3.3、标准输出流"></a>3.3、标准输出流</h3><p><strong>ostream预定义了三个输出流对象cout、cerr、elog</strong>，而且还重载了插入运算符”&lt;&lt;”，使用它可以输出各种类型的数据，这是标准输出流的基本用法，而ostream还提供了put()、write()等<strong>成员函数</strong>用来<strong>输出数据。</strong></p>
<h4 id="3-3-1、put-函数"><a href="#3-3-1、put-函数" class="headerlink" title="3.3.1、put()函数"></a>3.3.1、put()函数</h4><p>在ostream类中定义了可以<strong>输出单个字符的成员函数put()</strong>，其函数声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">put</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">put</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> ch)</span></span>;</span><br></pre></td></tr></table></figure>

<p>put()函数可以将一个字符型变量的值或一个字符常量输出到屏幕上，其返回值也是ostream类对象引用，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=<span class="string">'a'</span>;</span><br><span class="line">    <span class="built_in">cout</span>.<span class="built_in">put</span>(ch)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>.<span class="built_in">put</span>(<span class="string">'a'</span>).<span class="built_in">put</span>(<span class="string">'b'</span>).<span class="built_in">put</span>(<span class="string">'c'</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2、write-函数"><a href="#3-1-2、write-函数" class="headerlink" title="3.1.2、write()函数"></a>3.1.2、write()函数</h4><p>write()函数可以将一个字符串的部分或者全部字符送到输出流，其函数声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">write</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str,<span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>该函数第一个参数是要输出的字符串首地址，第二个参数是要输出的字符个数，若要输出全部字符，则第二个参数的值可以通过函数strlen()求出，函数返回值也是ostream类对象的引用，所以它也可以多次输出。</strong></p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* p =<span class="string">"创制博客"</span>;</span><br><span class="line">    <span class="built_in">cout</span>.<span class="built_in">write</span>(p,<span class="number">8</span>).<span class="built_in">put</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="built_in">cout</span>.<span class="built_in">write</span>(p,<span class="built_in">strlen</span>(p))&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4、标准输入流"><a href="#3-4、标准输入流" class="headerlink" title="3.4、标准输入流"></a>3.4、标准输入流</h3><p>C++中的istream类提供了多种形式的输入功能 ：istream类重载了提取运算符”&gt;&gt;”，使用它可以输出各种类型的数据，这事标准输入流最基本的用法，另外，istream还提供了成员函数get()实现字符的输入，getline()函数实现字符串的输入，read()函数实现无格式输入等。</p>
<h4 id="3-4-1、get-函数"><a href="#3-4-1、get-函数" class="headerlink" title="3.4.1、get()函数"></a>3.4.1、get()函数</h4><p>cin是istream类的对象，它提供了从输入流中获<strong>取单个字符的成员函数get()</strong>，三种声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span><span class="params">(<span class="keyword">char</span>&amp; ch)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span><span class="params">(<span class="keyword">char</span>* dst,streamsize <span class="built_in">size</span>,<span class="keyword">char</span> delimiter = <span class="string">'\0'</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第一种形式表示从输入流中读取一个字符，<strong>返回该字符的ascii码值</strong>，遇到文件结束符时，返回EOF。</p>
<p>第二种形式表示从输入流中读取一个字符，存储在ch中。</p>
<p>第三种形式表示从输入流中连续读取最多size-1个字符(因为最后一个字符要留给字符’\0’)，存储到首地址为dst的内存当中，delimiter时结束符，<strong>如果不传第三个参数，默认结束符是’\0’，也可以设置结束符是其它字符</strong>，遇到这个字符就结束读取，<strong>并且结束符不包含在所读取的字符串内</strong>，如果一直读取到size-1个字符也没有遇到结束符，那么会在结束读取时自动补’\0’在末尾。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"first call:"</span>&lt;&lt;<span class="built_in">cin</span>.<span class="built_in">get</span>()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//第一种形式</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">get</span>(ch);<span class="comment">//第二种形式</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"second call:"</span>&lt;&lt;ch&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">get</span>(str,<span class="number">8</span>,<span class="string">'T'</span>);<span class="comment">//第三种形式</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"third call:"</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">abcdeTfg</span><br><span class="line"><span class="number">97</span></span><br><span class="line">b</span><br><span class="line">cde</span><br></pre></td></tr></table></figure>

<h4 id="3-4-2、getline-函数"><a href="#3-4-2、getline-函数" class="headerlink" title="3.4.2、getline()函数"></a>3.4.2、getline()函数</h4><p>使用get()函数可以一次读取一个字符，而<strong>getline()函数可以一次读取一个指定长度的字符串</strong>。其函数声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span><span class="params">(<span class="keyword">char</span>* dst,streamsize <span class="built_in">size</span>,<span class="keyword">char</span> delimiter = <span class="string">'\n'</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>与get()函数的第三种重载方式相同，<strong>但是默认结束符为’\n’，它还可以读取空格、tab键等空白内容。</strong></p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">line</span>,<span class="built_in">max</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">100</span>],str2[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>.getline(str1,<span class="number">100</span>))<span class="comment">//若想结束循环，请按ctrl+z</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">line</span>=<span class="built_in">cin</span>.gcount();<span class="comment">//获取getline()函数实际读入的字符个数 \n也算</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">line</span>&gt;<span class="built_in">max</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">max</span>=<span class="built_in">line</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(str2,str1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"the longest string is"</span>&lt;&lt;str2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"the longest string's length is"</span>&lt;&lt;<span class="built_in">max</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-4-2-1、cin-gt-gt"><a href="#3-4-2-1、cin-gt-gt" class="headerlink" title="3.4.2.1、cin&gt;&gt;"></a>3.4.2.1、cin&gt;&gt;</h5><p>用法1：输入一个数字或字符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a+b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法2：接收一个字符串，遇“空格”、“TAB”、“回车”就结束</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入：jkljkljkl<br>输出：jkljkljkl</p>
<p>输入：jkljkl jkljkl    //遇空格结束<br>输出：jkljkl</p>
<h5 id="3-4-2-2、cin-getline"><a href="#3-4-2-2、cin-getline" class="headerlink" title="3.4.2.2、cin.getline()"></a>3.4.2.2、cin.getline()</h5><p>用法:接收一个字符串，可以接收空格并输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> m[<span class="number">20</span>];</span><br><span class="line">	<span class="built_in">cin</span>.getline(m,<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入：jkljkljkl<br>输出：jklj</p>
<p><em>接收5个字符到m中，其中最后一个为’\0’，所以只看到4个字符输出</em>；</p>
<p>如果把5改成20：<br>输入：jkljkljkl<br>输出：jkljkljkl</p>
<p>输入：jklf fjlsjf fjsdklf<br>输出：jklf fjlsjf fjsdklf</p>
<p>延伸：<br>1、cin.getline()实际上有三个参数，cin.getline(接收字符串的变量,接收字符个数,结束字符)<br>2、当第三个参数省略时，系统默认为’\0’<br>3、如果将例子中cin.getline()改为cin.getline(m,5,’a’);当输入jlkjkljkl时输出jklj，输入jkaljkljkl时，输出jk</p>
<h5 id="3-4-2-3、getline"><a href="#3-4-2-3、getline" class="headerlink" title="3.4.2.3、getline()"></a>3.4.2.3、getline()</h5><p>用法：接收一个字符串，可以接收空格并输出，需包含“#include<string>”</string></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	getline(<span class="built_in">cin</span>,str);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入：jkljkljkl<br>输出：jkljkljkl</p>
<p>输入：jkl jfksldfj jklsjfl<br>输出：jkl jfksldfj jklsjfl</p>
<h5 id="3-4-2-4、注意的问题"><a href="#3-4-2-4、注意的问题" class="headerlink" title="3.4.2.4、注意的问题"></a>3.4.2.4、注意的问题</h5><p>1、cin.getline()属于istream流，而getline()属于string流，是不一样的两个函数</p>
<p>2、当同时使用cin&gt;&gt;,getline()时，需要注意的是，在cin&gt;&gt;输入流完成之后，getline()之前，需要通过s</p>
<p>tr=”\n”;</p>
<p>getline(cin,str);</p>
<p>的方式将回车符作为输入流cin以清除缓存，如果不这样做的话，在控制台上就不会出现getline()的输入提示，而直接跳过，因为程序默认地将之前的变量作为输入流。</p>
<p>看下面一段程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="comment">//standard input(cin)</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"Please enter an integer value as your age: "</span>;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;age;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"Your ager is: "</span>&lt;&lt;age&lt;&lt;<span class="string">".\n"</span>;</span><br><span class="line">  <span class="comment">//cin and string</span></span><br><span class="line">  <span class="built_in">string</span> mystr;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"What's your name? "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  mystr=<span class="string">"\n"</span>;</span><br><span class="line">  getline(<span class="built_in">cin</span>,mystr);<span class="comment">//附加部分</span></span><br><span class="line">  getline(<span class="built_in">cin</span>,mystr);<span class="comment">//或getchar();</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello,"</span>&lt;&lt;mystr&lt;&lt;<span class="string">".\n"</span>;</span><br><span class="line">  <span class="keyword">char</span> sex;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"Please enter a F or M as your sex: "</span>;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;sex;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"Your sex is: "</span>&lt;&lt;sex&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"What's your favorite team? "</span>;</span><br><span class="line">  mystr=<span class="string">"\n"</span>;</span><br><span class="line">  getline(<span class="built_in">cin</span>,mystr);<span class="comment">//附加部分</span></span><br><span class="line">  getline(<span class="built_in">cin</span>,mystr);<span class="comment">//或getchar();</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"I like "</span>&lt;&lt;mystr&lt;&lt;<span class="string">".\n"</span>;</span><br><span class="line"></span><br><span class="line">  system(<span class="string">"pause"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其结果为：</p>
<p><img src="/2020/12/22/C++%E5%A4%8D%E4%B9%A0(IO%E6%B5%81)/022007479802935.png" alt></p>
<p>如果去掉附加部分：</p>
<p><img src="/2020/12/22/C++%E5%A4%8D%E4%B9%A0(IO%E6%B5%81)/022007493403151.png" alt></p>
<h4 id="3-4-3、read-函数"><a href="#3-4-3、read-函数" class="headerlink" title="3.4.3、read()函数"></a>3.4.3、read()函数</h4><p>istream类还提供了一个成员函数read()，它可以从输入流中读取部分或全部数据到指定的内存空间，其函数声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">read</span><span class="params">(<span class="keyword">char</span>* dst,streamsize <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>与get()函数、getline()函数类似，它第一个参数也是读取的size-1个字符存储在首地址为dst的内存空间中。<strong>并且没有其它限制，直接读取数据。</strong></p>
<h4 id="3-4-4、ignore-函数"><a href="#3-4-4、ignore-函数" class="headerlink" title="3.4.4、ignore()函数"></a>3.4.4、ignore()函数</h4><p>跳过输入流中的n个字符或者是遇到指定的终止符号时提前结束跳过字符，其函数声明为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">ignore</span><span class="params">(streamsize num =<span class="number">1</span>,<span class="keyword">int</span> delim = EOF)</span></span>;</span><br></pre></td></tr></table></figure>

<p>它从输入流中读取字符，直到已经读了num个字符(默认为1)或者是直到字符delim(默认为EOF)被读入时结束。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">cin</span>.ignore(<span class="number">6</span>,<span class="string">'T'</span>);<span class="comment">//跳过前面6个字符，如果有T，则T终止跳跃</span></span><br><span class="line">    <span class="built_in">cin</span>.getline(str,<span class="number">8</span>);<span class="comment">//开始读取输入的7个字符，并存储到str中</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">abcTefgThijklmn</span><br><span class="line">    defgThi</span><br></pre></td></tr></table></figure>

<h4 id="3-4-5、putback-函数"><a href="#3-4-5、putback-函数" class="headerlink" title="3.4.5、putback()函数"></a>3.4.5、putback()函数</h4><p>它把上一次通过get()或者getline()读取的字符再放回输入流中，函数声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">putback</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-6、peek-函数"><a href="#3-4-6、peek-函数" class="headerlink" title="3.4.6、peek()函数"></a>3.4.6、peek()函数</h4><p>它用于观测下一个字符，检查输入流中的下一个字符，它不会删除该字符，字符指针也不会移动，返回值是指针指向的当前字符。其函数声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-7、gcount-函数"><a href="#3-4-7、gcount-函数" class="headerlink" title="3.4.7、gcount()函数"></a>3.4.7、gcount()函数</h4><p>它用于<strong>计算</strong>最后一个非格式化方法(get()、getline()、read()、ignore())<strong>读取到的字符数</strong>。</p>
<h3 id="3-5、格式化控制"><a href="#3-5、格式化控制" class="headerlink" title="3.5、格式化控制"></a>3.5、格式化控制</h3><h4 id="3-5-1、格式标志"><a href="#3-5-1、格式标志" class="headerlink" title="3.5.1、格式标志"></a>3.5.1、格式标志</h4><h5 id="3-5-1-1、格式化状态"><a href="#3-5-1-1、格式化状态" class="headerlink" title="3.5.1.1、格式化状态"></a>3.5.1.1、格式化状态</h5><h5 id="3-5-1-2、格式化操控符"><a href="#3-5-1-2、格式化操控符" class="headerlink" title="3.5.1.2、格式化操控符"></a>3.5.1.2、格式化操控符</h5><h6 id="3-5-1-2-1、setf-函数"><a href="#3-5-1-2-1、setf-函数" class="headerlink" title="3.5.1.2.1、setf()函数"></a>3.5.1.2.1、setf()函数</h6><h6 id="3-5-1-2-2、unsetf-函数"><a href="#3-5-1-2-2、unsetf-函数" class="headerlink" title="3.5.1.2.2、unsetf()函数"></a>3.5.1.2.2、unsetf()函数</h6><h6 id="3-5-1-2-3、flags-函数"><a href="#3-5-1-2-3、flags-函数" class="headerlink" title="3.5.1.2.3、flags()函数"></a>3.5.1.2.3、flags()函数</h6><h4 id="3-5-2、精度、域宽、填充字符的设置"><a href="#3-5-2、精度、域宽、填充字符的设置" class="headerlink" title="3.5.2、精度、域宽、填充字符的设置"></a>3.5.2、精度、域宽、填充字符的设置</h4><h5 id="3-5-2-1、浮点数精度设置"><a href="#3-5-2-1、浮点数精度设置" class="headerlink" title="3.5.2.1、浮点数精度设置"></a>3.5.2.1、浮点数精度设置</h5><h5 id="3-5-2-2、域宽设置"><a href="#3-5-2-2、域宽设置" class="headerlink" title="3.5.2.2、域宽设置"></a>3.5.2.2、域宽设置</h5><h5 id="3-5-2-3、填充字符设置"><a href="#3-5-2-3、填充字符设置" class="headerlink" title="3.5.2.3、填充字符设置"></a>3.5.2.3、填充字符设置</h5><h4 id="3-5-3、操作符的格式控制"><a href="#3-5-3、操作符的格式控制" class="headerlink" title="3.5.3、操作符的格式控制"></a>3.5.3、操作符的格式控制</h4><h5 id="3-5-3-1、无参操作符"><a href="#3-5-3-1、无参操作符" class="headerlink" title="3.5.3.1、无参操作符"></a>3.5.3.1、无参操作符</h5><h5 id="3-5-3-2、有参操作符"><a href="#3-5-3-2、有参操作符" class="headerlink" title="3.5.3.2、有参操作符"></a>3.5.3.2、有参操作符</h5><h3 id="3-6、文件流"><a href="#3-6、文件流" class="headerlink" title="3.6、文件流"></a>3.6、文件流</h3><p>文件流是以外存文件作为输入输出对象的数据流，C++提供了三个类来支持文件的输入输出：</p>
<p>1、ifstream 输入文件流类 用于把文件中的数据读取到流中(读取)</p>
<p>2、ofstream 输出文件流类 用于把流中的数据写入文件(写)</p>
<p>3、fstream 输入输出文件流类，既可以读取也可以写</p>
<h4 id="3-6-1、构建文件流对象"><a href="#3-6-1、构建文件流对象" class="headerlink" title="3.6.1、构建文件流对象"></a>3.6.1、构建文件流对象</h4><p>文件流并没有像标准IO流预定义了输入输出流对象，所以在使用文件流时需要调用相应的类的构造函数来构建流对象，即：</p>
<p>1、调用默认构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifstream ifs;</span><br><span class="line">ofstream ofs;</span><br><span class="line">fstream fs;</span><br></pre></td></tr></table></figure>

<p>2、调用构造函数时指定文件名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">"filename"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">"filename"</span>)</span></span>;</span><br><span class="line"><span class="function">fstream <span class="title">fs</span><span class="params">(<span class="string">"filename"</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ifstream ifs;</span><br><span class="line">......指定文件</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">ifs&gt;&gt;ch;<span class="comment">//读取文件数据</span></span><br></pre></td></tr></table></figure>

<p>在使用文件流对象进行输入输出时，同样可以使用插入运算符”&lt;&lt;”和提取运算符”&gt;&gt;”，因为它们是预先设计好的，用于在输入输出流对象中传递数据，而一般的提取运算符是由空白符为分隔，如果需要读取一行再对文本进行分析，可以使用非格式化成员输出函数getline()。</p>
<h4 id="3-6-2、文件的打开和关闭"><a href="#3-6-2、文件的打开和关闭" class="headerlink" title="3.6.2、文件的打开和关闭"></a>3.6.2、文件的打开和关闭</h4><p>在看C++编程思想中，每个练习基本都是使用ofstream,ifstream,fstream。</p>
<p><img src="/2020/12/22/C++%E5%A4%8D%E4%B9%A0(IO%E6%B5%81)/iostream.gif" alt="img"></p>
<p>这里主要是讨论fstream的内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;  </span></span></span><br><span class="line"><span class="number">2.</span>ofstream         <span class="comment">//文件写操作 内存写入存储设备   </span></span><br><span class="line"><span class="number">3.</span>ifstream         <span class="comment">//文件读操作，存储设备读区到内存中  </span></span><br><span class="line"><span class="number">4.f</span>stream          <span class="comment">//读写操作，对打开的文件可进行读写操作   </span></span><br><span class="line"><span class="number">1.</span>打开文件</span><br></pre></td></tr></table></figure>

<p>在fstream类中，成员函数open（）实现打开文件的操作，从而将数据流和文件进行关联，通过ofstream,ifstream,fstream对象进行对文件的读写操作</p>
<p>函数：open（）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> * filename,  </span></span></span><br><span class="line"><span class="function"><span class="params">           ios_base::openmode mode = ios_base::in | ios_base::out )</span></span>;  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">wchar_t</span> *_Filename,  </span></span></span><br><span class="line"><span class="function"><span class="params">       ios_base::openmode mode= ios_base::in | ios_base::out,  </span></span></span><br><span class="line">       int prot = ios_base::_Openprot)；</span><br></pre></td></tr></table></figure>

<p>参数： filename  操作文件名</p>
<p>​      mode    打开文件的方式</p>
<p>​      prot     打开文件的属性              //基本很少用到，在查看资料时，发现有两种方式</p>
<p>打开文件的方式在ios类(所以流式I/O的基类)中定义，有如下几种方式：</p>
<table>
<thead>
<tr>
<th>ios::in</th>
<th>为输入(读)而打开文件</th>
</tr>
</thead>
<tbody><tr>
<td>ios::out</td>
<td>为输出(写)而打开文件</td>
</tr>
<tr>
<td>ios::ate</td>
<td>初始位置：文件尾</td>
</tr>
<tr>
<td>ios::app</td>
<td>所有输出附加在文件末尾</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果文件已存在则先删除该文件</td>
</tr>
<tr>
<td>ios::binary</td>
<td>二进制方式</td>
</tr>
</tbody></table>
<p>这些方式是能够进行组合使用的，以“或”运算（“|”）的方式：例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ofstream out;  </span><br><span class="line">out.<span class="built_in">open</span>(<span class="string">"Hello.txt"</span>, ios::in|ios::out|ios::binary)  <span class="comment">//根据自己需要进行适当的选取</span></span><br></pre></td></tr></table></figure>

<p>打开文件的属性同样在ios类中也有定义：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>普通文件，打开操作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>只读文件</td>
</tr>
<tr>
<td>2</td>
<td>隐含文件</td>
</tr>
<tr>
<td>4</td>
<td>系统文件</td>
</tr>
</tbody></table>
<p>对于文件的属性也可以使用“或”运算和“+”进行组合使用，这里就不做说明了。</p>
<p>很多程序中，可能会碰到ofstream out(“Hello.txt”), ifstream in(“…”),fstream foi(“…”)这样的的使用，并没有显式的去调用open（）函数就进行文件的操作，直接调用了其默认的打开方式，因为在stream类的构造函数中调用了open()函数,并拥有同样的构造函数，所以在这里可以直接使用流对象进行文件的操作，默认方式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"..."</span>, ios::out)</span></span>;  </span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"..."</span>, ios::in)</span></span>;  </span><br><span class="line"><span class="function">fstream <span class="title">foi</span><span class="params">(<span class="string">"..."</span>, ios::in|ios::out)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当使用默认方式进行对文件的操作时，你可以使用成员函数is_open()对文件是否打开进行验证</p>
<p>2.关闭文件</p>
<p>当文件读写操作完成之后，我们必须将文件关闭以使文件重新变为可访问的。成员函数close()，它负责将缓存中的数据排放出来并关闭文件。这个函数一旦被调用，原先的流对象就可以被用来打开其它的文件了，这个文件也就可以重新被其它的进程所访问了。为防止流对象被销毁时还联系着打开的文件，析构函数将会自动调用关闭函数close。</p>
<p>3.文本文件的读写</p>
<p>类ofstream, ifstream 和fstream 是分别从ostream, istream 和iostream 中引申而来的。这就是为什么 fstream 的对象可以使用其父类的成员来访问数据。</p>
<p>一般来说，我们将使用这些类与同控制台(console)交互同样的成员函数(cin 和 cout)来进行输入输出。如下面的例题所示，我们使用重载的插入操作符&lt;&lt;：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// writing on a text file  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fiostream.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"out.txt"</span>)</span></span>;  </span><br><span class="line"><span class="keyword">if</span> (out.is_open())   </span><br><span class="line">&#123;  </span><br><span class="line">        out &lt;&lt; <span class="string">"This is a line.\n"</span>;  </span><br><span class="line">        out &lt;&lt; <span class="string">"This is another line.\n"</span>;  </span><br><span class="line">         out.<span class="built_in">close</span>();  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line"><span class="comment">//结果: 在out.txt中写入：  </span></span><br><span class="line">This is a <span class="built_in">line</span>.  </span><br><span class="line">This is another <span class="built_in">line</span></span><br></pre></td></tr></table></figure>

<p>从文件中读入数据也可以用与 cin&gt;&gt;的使用同样的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reading a text file  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">256</span>];  </span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"test.txt"</span>)</span></span>;  </span><br><span class="line">      <span class="keyword">if</span> (! in.is_open())  </span><br><span class="line">     &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Error opening file"</span>; <span class="built_in">exit</span> (<span class="number">1</span>); &#125;  </span><br><span class="line">      <span class="keyword">while</span> (!in.eof() )  </span><br><span class="line">       &#123;  </span><br><span class="line">       	   in.getline (<span class="built_in">buffer</span>,<span class="number">100</span>);  </span><br><span class="line">           <span class="built_in">cout</span> &lt;&lt; <span class="built_in">buffer</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">      &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//结果 在屏幕上输出  </span></span><br><span class="line">    This is a <span class="built_in">line</span>.  </span><br><span class="line">    This is another <span class="built_in">line</span></span><br></pre></td></tr></table></figure>


<p>上面的例子读入一个文本文件的内容，然后将它打印到屏幕上。注意我们使用了一个新的成员函数叫做eof ，它是ifstream 从类 ios 中继承过来的，当到达文件末尾时返回true 。</p>
<h3 id="状态标志符的验证-Verification-of-state-flags"><a href="#状态标志符的验证-Verification-of-state-flags" class="headerlink" title="状态标志符的验证(Verification of state flags)"></a>状态标志符的验证(Verification of state flags)</h3><p>除了eof()以外，还有一些验证流的状态的成员函数（所有都返回bool型返回值）：</p>
<ul>
<li><p><strong>bad()</strong></p>
<p>如果在读写过程中出错，返回 true 。例如：当我们要对一个不是打开为写状态的文件进行写入时，或者我们要写入的设备没有剩余空间的时候。</p>
</li>
<li><p><strong>fail()</strong></p>
<p>除了与bad() 同样的情况下会返回 true 以外，加上格式错误时也返回true ，例如当想要读入一个整数，而获得了一个字母的时候。</p>
</li>
<li><p><strong>eof()</strong></p>
<p>如果读文件到达文件末尾，返回true。</p>
</li>
<li><p><strong>good()</strong></p>
<p>这是最通用的：如果调用以上任何一个函数返回true 的话，此函数返回 false 。</p>
</li>
</ul>
<p>要想重置以上成员函数所检查的状态标志，你可以使用成员函数clear()，没有参数。</p>
<h3 id="获得和设置流指针-get-and-put-stream-pointers"><a href="#获得和设置流指针-get-and-put-stream-pointers" class="headerlink" title="获得和设置流指针(get and put stream pointers)"></a>获得和设置流指针(get and put stream pointers)</h3><p>所有输入/输出流对象(i/o streams objects)都有至少一个流指针：</p>
<ul>
<li>ifstream， 类似istream, 有一个被称为get pointer的指针，指向下一个将被读取的元素。</li>
<li>ofstream, 类似 ostream, 有一个指针 put pointer ，指向写入下一个元素的位置。</li>
<li>fstream, 类似 iostream, 同时继承了get 和 put</li>
</ul>
<p>我们可以通过使用以下成员函数来读出或配置这些指向流中读写位置的流指针：</p>
<ul>
<li><p><strong>tellg() 和 tellp()</strong></p>
<p>这两个成员函数不用传入参数，返回pos_type 类型的值(根据ANSI-C++ 标准) ，就是一个整数，代表当前get 流指针的位置 (用tellg) 或 put 流指针的位置(用tellp).</p>
</li>
<li><p><strong>seekg() 和seekp()</strong></p>
<p>这对函数分别用来改变流指针get 和put的位置。两个函数都被重载为两种不同的原型：</p>
<p>seekg ( pos_type position ); seekp ( pos_type position );</p>
<p>使用这个原型，流指针被改变为指向从文件开始计算的一个绝对位置。要求传入的参数类型与函数 tellg 和tellp 的返回值类型相同。</p>
<p>seekg ( off_type offset, seekdir direction ); seekp ( off_type offset, seekdir direction );</p>
<p>使用这个原型可以指定由参数direction决定的一个具体的指针开始计算的一个位移(offset)。它可以是：</p>
<table>
<thead>
<tr>
<th>ios::beg</th>
<th>从流开始位置计算的位移</th>
</tr>
</thead>
<tbody><tr>
<td>ios::cur</td>
<td>从流指针当前位置开始计算的位移</td>
</tr>
<tr>
<td>ios::end</td>
<td>从流末尾处开始计算的位移</td>
</tr>
</tbody></table>
</li>
</ul>
<p>流指针 get 和 put 的值对文本文件(text file)和二进制文件(binary file)的计算方法都是不同的，因为文本模式的文件中某些特殊字符可能被修改。由于这个原因，建议对以文本文件模式打开的文件总是使用seekg 和 seekp的第一种原型，而且不要对tellg 或 tellp 的返回值进行修改。对二进制文件，你可以任意使用这些函数，应该不会有任何意外的行为产生。</p>
<p>以下例子使用这些函数来获得一个二进制文件的大小：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// obtaining file size  </span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;  </span></span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream.h&gt;  </span></span></span><br><span class="line">     </span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> * filename = <span class="string">"test.txt"</span>;  </span><br><span class="line">     </span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">long</span> l,m;  </span><br><span class="line">       <span class="function">ifstream <span class="title">in</span><span class="params">(filename, ios::in|ios::binary)</span></span>;  </span><br><span class="line">      l = in.tellg();  </span><br><span class="line">      in.seekg (<span class="number">0</span>, ios::<span class="built_in">end</span>);  </span><br><span class="line">      m = in.tellg();  </span><br><span class="line">      in.<span class="built_in">close</span>();  </span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"size of "</span> &lt;&lt; filename;  </span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">" is "</span> &lt;&lt; (m-l) &lt;&lt; <span class="string">" bytes.\n"</span>;  </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">      </span><br><span class="line"> <span class="comment">//结果:  </span></span><br><span class="line"> <span class="built_in">size</span> of example.txt is <span class="number">40</span> bytes.</span><br></pre></td></tr></table></figure>

<h3 id="4-二进制文件"><a href="#4-二进制文件" class="headerlink" title="4.二进制文件"></a>4.二进制文件</h3><p>在二进制文件中，使用&lt;&lt; 和&gt;&gt;，以及函数（如getline）来操作符输入和输出数据，没有什么实际意义，虽然它们是符合语法的。</p>
<p>文件流包括两个为顺序读写数据特殊设计的成员函数：write 和 read。第一个函数 (write) 是ostream 的一个成员函数，都是被ofstream所继承。而read 是istream 的一个成员函数，被ifstream 所继承。类 fstream 的对象同时拥有这两个函数。它们的原型是：</p>
<p>write ( char * buffer, streamsize size ); read ( char * buffer, streamsize size );</p>
<p>这里 buffer 是一块内存的地址，用来存储或读出数据。参数size 是一个整数值，表示要从缓存（buffer）中读出或写入的字符数。</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reading binary file  </span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream.h&gt;  </span></span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * filename = <span class="string">"test.txt"</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">char</span> * <span class="built_in">buffer</span>;  </span><br><span class="line">       <span class="keyword">long</span> <span class="built_in">size</span>;  </span><br><span class="line">       <span class="function">ifstream <span class="title">in</span> <span class="params">(filename, ios::in|ios::binary|ios::ate)</span></span>;  </span><br><span class="line">       <span class="built_in">size</span> = in.tellg();  </span><br><span class="line">       in.seekg (<span class="number">0</span>, ios::beg);  </span><br><span class="line">       <span class="built_in">buffer</span> = <span class="keyword">new</span> <span class="keyword">char</span> [<span class="built_in">size</span>];  </span><br><span class="line">       in.<span class="built_in">read</span> (<span class="built_in">buffer</span>, <span class="built_in">size</span>);  </span><br><span class="line">       in.<span class="built_in">close</span>();  </span><br><span class="line">         </span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"the complete file is in a buffer"</span>;  </span><br><span class="line">         </span><br><span class="line">       <span class="keyword">delete</span>[] <span class="built_in">buffer</span>;  </span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//运行结果：  </span></span><br><span class="line">   The complete file is in a <span class="built_in">buffer</span></span><br></pre></td></tr></table></figure>

<h3 id="5-缓存和同步-Buffers-and-Synchronization"><a href="#5-缓存和同步-Buffers-and-Synchronization" class="headerlink" title="5.缓存和同步(Buffers and Synchronization)"></a>5.缓存和同步(Buffers and Synchronization)</h3><p>当我们对文件流进行操作的时候，它们与一个streambuf 类型的缓存(buffer)联系在一起。这个缓存（buffer）实际是一块内存空间，作为流(stream)和物理文件的媒介。例如，对于一个输出流， 每次成员函数put (写一个单个字符)被调用，这个字符不是直接被写入该输出流所对应的物理文件中的，而是首先被插入到该流的缓存（buffer）中。</p>
<p>当缓存被排放出来(flush)时，它里面的所有数据或者被写入物理媒质中（如果是一个输出流的话），或者简单的被抹掉(如果是一个输入流的话)。这个过程称为同步(synchronization)，它会在以下任一情况下发生：</p>
<ul>
<li><strong>当文件被关闭时:</strong> 在文件被关闭之前，所有还没有被完全写出或读取的缓存都将被同步。</li>
<li><strong>当缓存buffer 满时:</strong>缓存Buffers 有一定的空间限制。当缓存满时，它会被自动同步。</li>
<li><strong>控制符明确指明:</strong>当遇到流中某些特定的控制符时，同步会发生。这些控制符包括：flush 和endl。</li>
<li><strong>明确调用函数sync():</strong> 调用成员函数sync() (无参数)可以引发立即同步。这个函数返回一个int 值，等于-1 表示流没有联系的缓存或操作失败。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">KJH</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">181</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KJH</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

<span id="busuanzi_container_site_uv">
  本站总访问量<span id="busuanzi_value_site_uv"></span>次
</span>
        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
