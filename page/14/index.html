<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/14/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="KJH">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day16%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day16%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记16</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:10:01" itemprop="dateModified" datetime="2020-12-23T23:10:01+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、正则表达式的定义及使用<br>2、Date类的用法<br>3、Calendar类的用法</p>
<p>==========================================第一阶段========================================</p>
<p>###01正则表达式的概念和作用<br>    * A: 正则表达式的概念和作用<br>        * a: 正则表达式的概述<br>            * 正则表达式也是一个字符串，用来定义匹配规则，在Pattern类中有简单的规则定义。<br>              可以结合字符串类的方法使用。<br>            * 简单记：正则表达式是具有特殊含义的字符串。<br>        * b: 正则表达式的作用<br>        * 比如注册邮箱,邮箱有用户名和密码,一般会对其限制长度,这个限制长度的事情就是正则表达式做的</p>
<p>​<br>###02正则表达式语法规则<br>    * A: 正则表达式语法规则<br>        * a: 字符<br>            * x  代表的是字符x<br>            * \ 代表的是反斜线字符’&#39;<br>            * \t 代表的是制表符<br>            * \n 代表的是换行符<br>            * \r 代表的是回车符<br>        * b: 字符类<br>            * [abc]    a、b 或 c（简单类）<br>            * [^abc]   任何字符，除了 a、b 或 c（否定）<br>            * [a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围）<br>            * [0-9]    0到9的字符都包括<br>            * [a-zA-Z_0-9] 代表的字母或者数字或者下划线(即单词字符)<br>        * c: 预定义字符类<br>            * . 任何字符。<br>            * \d 数字：[0-9]<br>            * \w 单词字符：[a-zA-Z_0-9]如”com.itheima.tests”/finish<br>        * d: 边界匹配器<br>            * ^  代表的是行的开头<br>            * $  代表的是行的结尾<br>            * \b 代表的是单词边界<br>        * e: 数量词<br>            * X?     X，一次或一次也没有<br>            * X*     X，零次或多次<br>            * X+     X，一次或多次<br>            * X{n}   X，恰好 n 次<br>            * X{n,}  X，至少 n 次<br>            * X{n,m} X，至少 n 次，但是不超过 m 次</p>
<p>###03正则表达式练习和相关的String类方法<br>    * A: 正则表达式练习和相关的String类方法<br>        * a: boolean matches(String 正则的规则)<br>            * “abc”.matches(“[a]”)<br>            * 匹配成功返回true<br>        * b: String[] split(String 正则的规则)<br>            * “abc”.split(“a”)<br>            * 使用规则将字符串进行切割<br>        * c: String replaceAll( String 正则规则,String 字符串)<br>            * “abc0123”.repalceAll(“[\d]”,”#”)<br>            * 按照正则的规则,替换字符串</p>
<p>​<br>###04正则表达式匹配练习<br>    * A: 正则表达式匹配练习<br>        * a: 案例代码<br>            public class RegexDemo {<br>                public static void main(String[] args) {<br>                    checkTel();<br>                }</p>
<p>​<br>                /*<br>                 *  检查手机号码是否合法<br>                 *  1开头 可以是34578  0-9 位数固定11位<br>                 */<br>                public static void checkTel(){<br>                    String telNumber = “1335128005”;<br>                    //String类的方法matches<br>                    boolean b = telNumber.matches(“1[34857][\d]{9}”);<br>                    System.out.println(b);<br>                }</p>
<pre><code>    /*
     *  检查QQ号码是否合法
     *  0不能开头,全数字, 位数5,10位
     *  123456 
     *  \\d  \\D匹配不是数字
     */
    public static void checkQQ(){
        String QQ = &quot;123456&quot;;
        //检查QQ号码和规则是否匹配,String类的方法matches
        boolean b = QQ.matches(&quot;[1-9][\\d]{4,9}&quot;);
        System.out.println(b);
    }
}</code></pre><p>###05正则表达式切割练习<br>    * A: 正则表达式切割练习<br>        * a: 案例代码<br>            public class RegexDemo1 {<br>                public static void main(String[] args) {<br>                    split_1();<br>                    split_2();<br>                    split_3();</p>
<pre><code>    }

    /*
     * String类方法split对字符串进行切割
     * 192.168.105.27 按照 点切割字符串
     */
    public static void split_3(){
        String ip = &quot;192.168.105.27&quot;;
        String[] strArr = ip.split(&quot;\\.&quot;);
        System.out.println(&quot;数组的长度&quot;+strArr.length);
        for(int i = 0 ; i &lt; strArr.length ; i++){
            System.out.println(strArr[i]);
        }
    }

    /*
     * String类方法split对字符串进行切割
     * 18 22 40 65 按照空格切割字符串
     */
    public static void split_2(){
        String str = &quot;18    22     40          65&quot;;
        String[] strArr = str.split(&quot; +&quot;);
        System.out.println(&quot;数组的长度&quot;+strArr.length);
        for(int i = 0 ; i &lt; strArr.length ; i++){
            System.out.println(strArr[i]);
        }
    }

    /*
     *  String类方法split对字符串进行切割
     *  12-25-36-98  按照-对字符串进行切割
     */
    public static void split_1(){
        String str = &quot;12-25-36-98&quot;;
        //按照-对字符串进行切割,String类方法split
        String[] strArr = str.split(&quot;-&quot;);
        System.out.println(&quot;数组的长度&quot;+strArr.length);
        for(int i = 0 ; i &lt; strArr.length ; i++){
            System.out.println(strArr[i]);
        }
    }
}        </code></pre><p>​<br>###06正则表达式替换练习<br>    * A: 正则表达式替换练习<br>        * a: 案例代码<br>            public class RegexDemo1 {<br>                public static void main(String[] args) {<br>                    replaceAll_1();<br>                }</p>
<pre><code>    /*
     * &quot;Hello12345World6789012&quot;将所有数字替换掉
     * String类方法replaceAll(正则规则,替换后的新字符串)
     */
    public static void replaceAll_1(){
        String str = &quot;Hello12345World6789012&quot;;
        str = str.replaceAll(&quot;[\\d]+&quot;, &quot;#&quot;);
        System.out.println(str);
    }
}</code></pre><p>###07正则表达式邮箱地址验证<br>    * A: 正则表达式邮箱地址验证<br>        * a: 案例代码<br>            public class RegexDemo2 {<br>                public static void main(String[] args) {<br>                    checkMail();<br>                }<br>                /*<br>                 *  检查邮件地址是否合法<br>                 *  规则:<br>                 *   <a href="mailto:1234567@qq.com">1234567@qq.com</a><br>                 *   <a href="mailto:mym_ail@sina.com">mym_ail@sina.com</a><br>                 *   <a href="mailto:nimail@163.com">nimail@163.com</a><br>                 *   <a href="mailto:wodemail@yahoo.com.cn">wodemail@yahoo.com.cn</a><br>                 *<br>                 *   @: 前  数字字母_ 个数不能少于1个<br>                 *   @: 后  数字字母     个数不能少于1个<br>                 *   .: 后面 字母<br>                 *<br>                 */<br>                public static void checkMail(){<br>                    String email =”<a href="mailto:abc123@sina.com">abc123@sina.com</a>“;<br>                    boolean b = email.matches(“[a-zA-Z0-9_]+@[0-9a-z]+(\.[a-z]+)+”);<br>                    System.out.println(b);<br>                }<br>            }</p>
<p>###08毫秒值概念<br>    * A: 毫秒值概念<br>        * a: 时间和日期类<br>            * java.util.Date<br>        * b: 毫秒概念<br>            * 1000毫秒=1秒<br>        * c: 毫秒的0点<br>             * System.currentTimeMillis() 返回值long类型参数<br>             * 获取当前日期的毫秒值   3742769374405<br>             * 时间原点; 公元1970年1月1日,午夜0:00:00 英国格林威治  毫秒值就是0<br>             * 时间2088年8月8日<br>             * 时间和日期的计算，必须依赖毫秒值</p>
<p>###09Date类的构造方法<br>    * A: Date类的构造方法<br>        * a: 空参构造<br>            * public Date()<br>        * b: 带参构造<br>            * public Date(long times)</p>
<p>​<br>==============================第二阶段====================================        </p>
<p>​<br>###10Date类的get和set方法<br>    * A：Date类的get和set方法<br>        * public long getTime()<br>            * 将当前的日期对象，转为对应的毫秒值<br>        * public void setTime(long times);<br>            * 根据给定的毫秒值，生成对应的日期对象</p>
<p>###11日期格式化SimpleDateFormat<br>    * A: 日期格式化SimpleDateFormat<br>        * a: 对日期进行格式化(自定义)<br>            * 对日期格式化的类 java.text.DateFormat 抽象类, 普通方法,也有抽象的方法<br>            * 实际使用是子类 java.text.SimpleDateFormat 可以使用父类普通方法,重写了抽象方法<br>        * b: 对日期进行格式化的步骤<br>            * 1: 创建SimpleDateFormat对象<br>                * 在类构造方法中,写入字符串的日期格式 (自己定义)<br>            * 2: SimpleDateFormat调用方法format对日期进行格式化<br>                * public String format(Date date) 传递日期对象,返回字符串<br>                * 日期模式:<br>                 * yyyy    年份<br>                 * MM      月份<br>                * dd      月中的天数<br>                * HH       0-23小时<br>                * mm      小时中的分钟<br>                 * ss      秒<br>                 * yyyy年MM月dd日 HH点mm分钟ss秒  汉字修改,: -  字母表示的每个字段不可以随便写</p>
<p>​<br>###12字符串转成日期对象<br>    * A: 字符串转成日期对象<br>        * a: 使用步骤<br>            * 1: 创建SimpleDateFormat的对象<br>                * 构造方法中,指定日期模式<br>            * 2: 子类对象,调用方法 parse 传递String,返回Date<br>                * 注意: 时间和日期的模式yyyy-MM-dd, 必须和字符串中的时间日期匹配</p>
<p>###13Calendar类_1<br>    * A: Calendar类_1<br>        * a: 日历类(抽象类)<br>            * java.util.Calendar<br>        * b: 创建对象<br>            * Calendar类写了静态方法 getInstance() 直接返回了子类的对象<br>            * 不需要直接new子类的对象,通过静态方法直接获取</p>
<p>###14Calendar类_2<br>    * A: Calendar类_2<br>        * a: 成员方法<br>            * getTime() 把日历对象,转成Date日期对象<br>            * get(日历字段) 获取指定日历字段的值<br>        * b: 代码演示<br>            Calendar c = Calendar.getInstance();<br>            // 获取年份<br>            int year = c.get(Calendar.YEAR);<br>            // 获取月份<br>            int month = c.get(Calendar.MONTH) + 1;<br>            // 获取天数<br>            int day = c.get(Calendar.DAY_OF_MONTH);<br>            System.out.println(year + “年” + month + “月” + day + “日”);</p>
<p>​<br>###15Calendar类_3<br>    * A: Calendar类_3<br>        * a: 成员方法<br>            * set(int field,int value)  设置指定的时间<br>        * b: 代码演示<br>            /*<br>             * Calendar类的set方法 设置日历 set(int field,int value) field 设置的是哪个日历字段 value<br>             * 设置后的具体数值<br>             *<br>             * set(int year,int month,int day) 传递3个整数的年,月,日<br>             */<br>            public static void function_1() {<br>                Calendar c = Calendar.getInstance();<br>                // 设置,月份,设置到10月分<br>                // c.set(Calendar.MONTH, 9);</p>
<pre><code>    // 设置年,月,日
    c.set(2099, 4, 1);

    // 获取年份
    int year = c.get(Calendar.YEAR);
    // 获取月份
    int month = c.get(Calendar.MONTH) + 1;
    // 获取天数
    int day = c.get(Calendar.DAY_OF_MONTH);
    System.out.println(year + &quot;年&quot; + month + &quot;月&quot; + day + &quot;日&quot;);
}</code></pre><p>###16Calendar类_4<br>    * A: Calendar类_4<br>        * a: 成员方法<br>            * add(int field, int value) 进行整数的偏移<br>            * int get(int field) 获取指定字段的值<br>        * b: 案例演示<br>            /*<br>             * Calendar类方法add 日历的偏移量,<br>             * 可以指定一个日历中的字段,<br>             * 进行整数的偏移 add(int field, int value)<br>             */<br>            public static void function_2() {<br>                Calendar c = Calendar.getInstance();<br>                // 让日历中的天数,向后偏移280天<br>                c.add(Calendar.DAY_OF_MONTH, -280);<br>                // 获取年份<br>                int year = c.get(Calendar.YEAR);<br>                // 获取月份<br>                int month = c.get(Calendar.MONTH) + 1;<br>                // 获取天数<br>                int day = c.get(Calendar.DAY_OF_MONTH);<br>                System.out.println(year + “年” + month + “月” + day + “日”);<br>            }</p>
<p>###17日期练习_活了多少天<br>    * A: 日期练习_活了多少天<br>        * a: 案例代码<br>            /*<br>             *  计算活了多少天<br>             *   生日  今天的日期<br>             *   两个日期变成毫秒值,减法<br>             */<br>            public static void function() throws Exception {<br>                System.out.println(“请输入出生日期 格式 YYYY-MM-dd”);<br>                //获取出生日期,键盘输入<br>                String birthdayString = new Scanner(System.in).next();<br>                //将字符串日期,转成Date对象<br>                //创建SimpleDateFormat对象,写日期模式<br>                SimpleDateFormat sdf = new SimpleDateFormat(“yyyy-MM-dd”);<br>                //调用方法parse,字符串转成日期对象<br>                Date birthdayDate = sdf.parse(birthdayString);</p>
<pre><code>    //获取今天的日期对象
    Date todayDate = new Date();

    //将两个日期转成毫秒值,Date类的方法getTime
    long birthdaySecond = birthdayDate.getTime();
    long todaySecond = todayDate.getTime();
    long secone = todaySecond-birthdaySecond;

    if(secone &lt; 0){
        System.out.println(&quot;还没出生呢&quot;);
    }
    else{
    System.out.println(secone/1000/60/60/24);
    }

}</code></pre><p>###18日期练习_闰年计算<br>    * A: 日期练习_闰年计算<br>        * a: 案例代码<br>            /*<br>             *  闰年计算<br>             *  2000 3000<br>             *  高级的算法: 日历设置到指定年份的3月1日,add向前偏移1天,获取天数,29闰年<br>             */<br>            public static void function_1(){<br>                Calendar c = Calendar.getInstance();<br>                //将日历,设置到指定年的3月1日<br>                c.set(2088, 2, 1);<br>                //日历add方法,向前偏移1天<br>                c.add(Calendar.DAY_OF_MONTH, -1);<br>                //get方法获取天数<br>                int day = c.get(Calendar.DAY_OF_MONTH);<br>                System.out.println(day);<br>            }</p>
<p>###19总结</p>
<ul>
<li>把今天的知识点总结一遍。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day15%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day15%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记15</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:08:39" itemprop="dateModified" datetime="2020-12-23T23:08:39+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、Object<br>2、String<br>3、StringBuilder</p>
<p>=======================第一节课开始=============================================</p>
<p>###01API概念</p>
<pre><code>* A:API(Application Programming Interface) 
    * 应用程序编程接口
* B:Java API
    * 就是Java提供给我们使用的类，这些类将底层的实现封装了起来，
    * 我们不需要关心这些类是如何实现的，只需要学习这些类如何使用。
* C: 演示查看Object类中的相关方法</code></pre><p>###02Object类概述<br>    * A:Object类概述<br>        * 类层次结构的根类<br>        * 所有类都直接或者间接的继承自该类<br>        * Object中描述的所有方法子类都可以使用<br>        * 所有类在创建对象的时候，最终找的父类就是Object。<br>    * B:构造方法<br>        * public Object()<br>        * 回想面向对象中为什么说：<br>            * 子类的构造方法默认访问的是父类的无参构造方法</p>
<p>​<br>###03equals方法比较内存地址<br>    * A:equals方法比较内存地址<br>        * a: Object类中的equals方法<br>            * 用于比较两个对象是否相同，Object类中就是使用两个对象的内存地址在比较。<br>            * Object类中的equals方法内部使用的就是==比较运算符。</p>
<pre><code>* b: 案例代码

    public class Person extends Object{
        private String name;
        private int age;

        public Person(){}

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
        /*
         * 将父类的equals方法写过来,重写父类的方法
         * 但是,不改变父类方法的源代码, 方法equals 比较两个对象的内存地址
         *                 
         */
        public boolean equals(Object obj){                    
            return this == obj;
        }        

        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
        public int getAge() {
            return age;
        }
        public void setAge(int age) {
            this.age = age;
        }                 
    }
    //测试代码
    public class TestEquals {
        public static void main(String[] args) {
            //Person类继承Object类,继承下来了父类的方法equals
            Person p1 = new Person(&quot;李四&quot;,20);
            Person p2 = new Person(&quot;张三&quot;,20);</code></pre><p>​<br>                    //Person对象p1,调用父类的方法equals,进行对象的比较<br>                    boolean b = p1.equals(p1);<br>                    System.out.println(b);</p>
<pre><code>    }
}</code></pre><p>###04重写equals方法<br>    * A: 重写equals方法<br>        * a: 开发中要比较两个对象是否相同，经常会根据对象中的属性值进行比较<br>        * b: 在开发经常需要子类重写equals方法根据对象的属性值进行比较。<br>        * c: ==号和equals方法的区别<br>            * ==是一个比较运算符号,既可以比较基本数据类型,也可以比较引用数据类型,基本数据类型比较的是值,引用数据类型比较的是地址值<br>            * equals方法是一个方法,只能比较引用数据类型,所有的对象都会继承Object类中的方法,如果没有重写Object类中的equals方法,<br>                equals方法和==号比较引用数据类型无区别,重写后的equals方法比较的是对象中的属性<br>        * d: 案例代码<br>            public class Person extends Object{<br>                private String name;<br>                private int age;</p>
<pre><code>public Person(){}

public Person(String name, int age) {
    this.name = name;
    this.age = age;
}
/*
 * 重写父类的方法toString()
 * 没有必要让调用者看到内存地址
 * 要求: 方法中,返回类中所有成员变量的值
 */
public String toString(){
    return name + age;
}</code></pre><p>​<br>                /*<br>                 * 将父类的equals方法写过来,重写父类的方法<br>                 * 但是,不改变父类方法的源代码, 方法equals 比较两个对象的内存地址<br>                 *<br>                 * 两个对象,比较地址,没有意义<br>                 * 比较两个对象的成员变量,age<br>                 * 两个对象变量age相同,返回true,不同返回false<br>                 *<br>                 * 重写父类的equals,自己定义自己对象的比较方式<br>                 */<br>                public boolean equals(Object obj){<br>                    if( this == obj){<br>                        return true;<br>                    }</p>
<pre><code>        //对参数obj,非null判断
        if( obj == null){
            return false;
        }

        if( obj instanceof Person){
            // 参数obj接受到是Person对象,才能转型
            // 对obj参数进行类型的向下转型,obj转成Person类型
            Person p = (Person)obj;
            return this.age ==  p.age;
        }
        return false;
    }                

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }                 
}
//测试代码
public class TestEquals {
    public static void main(String[] args) {
        //Person类继承Object类,继承下来了父类的方法equals
        Person p1 = new Person(&quot;李四&quot;,20);
        Person p2 = new Person(&quot;张三&quot;,20);</code></pre><p>​<br>                    //Person对象p1,调用父类的方法equals,进行对象的比较<br>                    boolean b = p1.equals(p1);<br>                    System.out.println(b);</p>
<pre><code>    }
}            </code></pre><p>###05重写toString方法<br>    * A: 重写toString方法<br>        * a: 为什么要重写toString方法<br>            * toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。<br>            * 由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。<br>            * Object类中的toString的核心代码<br>                getClass().getName() + “@” + Integer.toHexString(hashCode())<br>            * 由于默认情况下的数据对我们来说没有意义，一般建议重写该方法。<br>        * b: 案例核心代码(重写Person类中的toString方法)<br>            /*<br>             * 重写父类的方法toString()<br>             * 没有必要让调用者看到内存地址<br>             * 要求: 方法中,返回类中所有成员变量的值<br>             <em>/<br>            public String toString(){<br>                return name + age;<br>            }<br>            //Eclipse中自动生成的toString<br>            @Override<br>            public String toString() {<br>                return “Person [name=” + name + “, age=” + age + “]”;<br>            }<br>            //测试代码<br>            public class TestToString {<br>                public static void main(String[] args) {<br>                    //调用Person类的方法toString()<br>                    //输出语句中,写的是一个对象,默认调用对象的toString方法<br>                    Person p = new Person(“张三”,20);<br>                    String s = p.toString();<br>                    System.out.println(p);<br>                    System.out.println(s);<br>                    /</em><br>                     * System.out.println(p);<br>                     * System.out.println(p.toString());<br>                     */</p>
<pre><code>        /*Random r = new Random();
        System.out.println(r.toString());

        Scanner sc = new Scanner(System.in);
        System.out.println(sc.toString());*/
    }
}</code></pre><p>========================================================第二节课开始===================================================</p>
<p>###06String类的概念和不变性<br>    * A: String类的概念和不变性<br>        * a:String类<br>            * API中的String类的描述，发现String 类代表字符串<br>            * Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。<br>            * 字符串是常量,在创建之后不能更改<br>            * 其实就是说一旦这个字符串确定了，那么就会在内存区域中就生成了这个字符串。字符串本身不能改变，但str变量中记录的地址值是可以改变的。<br>            * 源码分析,String类底层采用的是字符数组:<br>                private final char value[]<br>                private 修饰说明value只能在String类内部使用,而且又没有提供get方法,所以外部无法获取value数组,就无法改变数组中元素的值<br>                final修饰说明value是常量,一旦创建,就不能被改变,value一旦被初始化成某个数组,将永远指向这个数组,不可能再指向其它的数组了</p>
<pre><code>* b: 案例代码
    /*
     *   String类特点:
     *     一切都是对象,字符串事物 &quot;&quot; 也是对象
     *     类是描述事物,String类,描述字符串对象的类
     *     所有的 &quot;&quot; 都是String类的对象
     *     
     *     字符串是一个常量,一旦创建,不能改变
     */
    public class StringDemo {
        public static void main(String[] args) {
            //引用变量str执行内存变化
            //定义好的字符串对象,不变
            String str = &quot;itcast&quot;;
            System.out.println(str);
            str = &quot;itheima&quot;;
            System.out.println(str);</code></pre><p>​<br>                }<br>            }</p>
<p>###07String类创建方式和比较<br>    * A: String类创建方式和比较<br>        * a: 创建对象的数量比较<br>            * String s3 = “abc”;<br>                * 在内存中只有一个对象。这个对象在字符串常量池中<br>            * String s4 = new String(“abc”);<br>                * 在内存中有两个对象。一个new的对象在堆中，一个字符串本身对象，在字符串常量池中<br>        * b: 案例代码<br>            public class StringDemo2 {<br>                public static void main(String[] args) {<br>                    //字符串定义方式2个, 直接=  使用String类的构造方法<br>                    String str1 = new String(“abc”);<br>                    String str2 = “abc”;<br>                    System.out.println(str1);<br>                    System.out.println(str2);</p>
<pre><code>        System.out.println(str1==str2);//引用数据类型,比较对象的地址 false
        System.out.println(str1.equals(str2));//true
    }
}</code></pre><p>###08String类构造方法<br>    * A: String类构造方法<br>        * a: 常见构造方法<br>            * public String():空构造<br>            * public String(byte[] bytes):把字节数组转成字符串<br>            * public String(byte[] bytes,int index,int length):把字节数组的一部分转成字符串<br>            * public String(String original):把字符串常量值转成字符串<br>        * b: 案例代码<br>            public class StringDemo3 {<br>                public static void main(String[] args) {<br>                    function_1();<br>                }<br>                /*<br>                 *  定义方法,String类的构造方法<br>                 *  String(byte[] bytes)  传递字节数组<br>                 *  字节数组转成字符串<br>                 *  通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。<br>                 *  平台 : 机器操作系统<br>                 *  默认字符集: 操作系统中的默认编码表, 默认编码表GBK<br>                 *  将字节数组中的每个字节,查询了编码表,得到的结果<br>                 *  字节是负数,汉字的字节编码就是负数, 默认编码表 ,一个汉字采用2个字节表示<br>                 *<br>                 *  String(byte[] bytes, int offset, int length) 传递字节数组<br>                 *  字节数组的一部分转成字符串<br>                 *  offset 数组的起始的索引<br>                 *  length 个数,转几个   , 不是结束的索引<br>                 */<br>                public static void function(){<br>                    byte[] bytes = {97,98,99,100};<br>                    //调用String类的构造方法,传递字节数组<br>                    String s = new String(bytes);<br>                    System.out.println(s);</p>
<pre><code>        byte[] bytes1 ={65,66,67,68,69};
        //调用String构造方法,传递数组,传递2个int值
        String s1 = new String(bytes1,1,3);
        System.out.println(s1);
    }
}</code></pre><p>###09String类构造方法_2<br>    * A: String类构造方法<br>        * a: 常见构造方法<br>            * public String(char[] value):把字符数组转成字符串<br>            * public String(char[] value,int index,int count):把字符数组的一部分转成字符串<br>    * B: 案例代码<br>         /*<br>          *  String类构造方法<br>          *  String类的构造方法,重载形式<br>          *<br>          <em>/<br>        public class StringDemo3 {<br>            public static void main(String[] args) {<br>                function_1();<br>            }<br>            /</em><br>             * String(char[] value) 传递字符数组<br>             * 将字符数组,转成字符串, 字符数组的参数,不查询编码表<br>             *<br>             * String(char[] value, int offset, int count) 传递字符数组<br>             * 将字符数组的一部分转成字符串<br>             * offset  数组开始索引<br>             * count   个数<br>             */<br>            public static void function_1(){<br>                char[] ch = {‘a’,’b’,’c’,’d’,’e’,’f’};<br>                //调用String构造方法,传递字符数组<br>                String s = new String(ch);<br>                System.out.println(s);</p>
<pre><code>        String s1 = new String(ch,1,4);
        System.out.println(s1);
    }
}</code></pre><p>​<br>###10String类的其他方法<br>    * A：String类的其他方法<br>        * a: 方法介绍<br>            * int length(): 返回字符串的长度<br>            * String substring(int beginIndex,int endIndex): 获取字符串的一部分<br>            * String substring(int beginIndex): 获取字符串的一部分<br>            * boolean startsWith(String prefix): 判断一个字符串是不是另一个字符串的前缀,开头<br>            * boolean endsWith(String prefix): 判断一个字符串是不是另一个字符串的后缀,结尾<br>            * boolean contains (String s): 判断一个字符串中,是否包含另一个字符串<br>            * int indexOf(char ch):  查找一个字符,在字符串中第一次出现的索引,被查找的字符不存在,返回-1<br>            * byte[] getBytes(): 将字符串转成字节数组,此功能和String构造方法相反,byte数组相关的功能,查询编码表<br>            * char[] toCharArray(): 将字符串转成字符数组,功能和构造方法相反<br>            * boolean equals(Object obj): 方法传递字符串,判断字符串中的字符是否完全相同,如果完全相同返回true<br>            * boolean equalsIgnoreCase(String s): 传递字符串,判断字符串中的字符是否相同,忽略大小写            </p>
<pre><code>* b: 案例代码

    public class StringDemo4 {
        public static void main(String[] args) {
            function_9();
        }
        /*
         *  boolean equals(Object obj)
         *  方法传递字符串,判断字符串中的字符是否完全相同,如果完全相同返回true
         *  
         *  boolean equalsIgnoreCase(String s)
         *  传递字符串,判断字符串中的字符是否相同,忽略大小写
         */
        public static void function_9(){
            String str1 = &quot;Abc&quot;;
            String str2 = &quot;abc&quot;;
            //分别调用equals和equalsIgnoreCase
            boolean b1 = str1.equals(str2);
            boolean b2 = str1.equalsIgnoreCase(str2);
            System.out.println(b1);
            System.out.println(b2);
        }

        /*
         * char[] toCharArray() 将字符串转成字符数组
         * 功能和构造方法相反
         */
        public static void function_8(){
            String str = &quot;itcast&quot;;
            //调用String类的方法toCharArray()
            char[] ch = str.toCharArray();
            for(int i = 0 ; i &lt; ch.length ; i++){
                System.out.println(ch[i]);
            }
        }

        /*
         *  byte[] getBytes() 将字符串转成字节数组
         *  此功能和String构造方法相反
         *  byte数组相关的功能,查询编码表
         */
        public static void function_7(){
            String str = &quot;abc&quot;;
            //调用String类方法getBytes字符串转成字节数组
            byte[] bytes = str.getBytes();
            for(int i = 0 ; i &lt; bytes.length ; i++){
                System.out.println(bytes[i]);
            }
        }

        /*
         *  int indexOf(char ch)
         *  查找一个字符,在字符串中第一次出现的索引
         *  被查找的字符不存在,返回-1
         */
        public static void function_6(){
            String str = &quot;itcast.cn&quot;;
            //调用String类的方法indexOf
            int index = str.indexOf(&apos;x&apos;);
            System.out.println(index);
        }

        /*
         *  boolean contains (String s)
         *  判断一个字符串中,是否包含另一个字符串
         */
        public static void function_5(){
            String str = &quot;itcast.cn&quot;;
            //调用String类的方法contains
            boolean b =str.contains(&quot;ac&quot;);
            System.out.println(b);
        }

        /*
         * boolean endsWith(String prefix)
         * 判断一个字符串是不是另一个字符串的后缀,结尾
         * Demo.java
         *     .java
         */
        public static void function_4(){
            String str = &quot;Demo.java&quot;;
            //调用String类方法endsWith
            boolean b = str.endsWith(&quot;.java&quot;);
            System.out.println(b);
        }

        /*
         * boolean startsWith(String prefix)  
         * 判断一个字符串是不是另一个字符串的前缀,开头
         * howareyou
         * hOw
         */
          public static void function_3(){
              String str = &quot;howareyou&quot;;
              //调用String类的方法startsWith
              boolean b = str.startsWith(&quot;hOw&quot;);
              System.out.println(b);
          }

        /*
         *  String substring(int beginIndex,int endIndex) 获取字符串的一部分
         *  返回新的字符串
         *  包含头,不包含尾巴
         *  
         *  String substring(int beginIndex)获取字符串的一部分
         *  包含头,后面的字符全要
         */
        public static void function_2(){
            String str = &quot;howareyou&quot;;
            //调用String类方法substring获取字符串一部分
            str= str.substring(1, 5);
            System.out.println(str);

            String str2 = &quot;HelloWorld&quot;;
            str2 = str2.substring(1);
            System.out.println(str2);
        }

        /*
         *  int length() 返回字符串的长度
         *  包含多少个字符
         */
        public static void function(){
            String str = &quot;cfxdf#$REFewfrt54GT&quot;;
            //调用String类方法length,获取字符串长度
            int length = str.length();
            System.out.println(length);
        }
    }</code></pre><p>###11String类练习<br>    * A: 获取指定字符串中，大写字母、小写字母、数字的个数<br>        * a: 题目分析<br>            * 为了统计大写字母、小写字母、数字的个数。创建3个计数的变量。<br>            * 为了获取到字符串中的每个字符，进行字符串的遍历，得到每个字符。<br>            * 对得到的字符进行判断，如果该字符为大写字母，则大写字母个数+1；如果该字符为小写字母，则小写字母个数+1；如果该字符为数字，则数字个数+1。<br>            * 显示大写字母、小写字母、数字的个数</p>
<pre><code>* b: 解题步骤
    * 略
* 案例代码
    public class StringTest {
        public static void main(String[] args) {
            getCount(&quot;A%A3eBr1FFy&quot;);                    
        }

        /*
         * 获取指定字符串中，大写字母、小写字母、数字的个数。
         * 思想:
         *   1. 计数器,就是int变量,满足一个条件 ++
         *   2. 遍历字符串, 长度方法length() + charAt() 遍历
         *   3. 字符判断是大写,是小写,还是数字
         */
        public static void getCount(String str){
            //定义三个变量,计数
            int upper = 0;
            int lower = 0;
            int digit = 0;
            //对字符串遍历
            for(int i = 0 ; i &lt; str.length() ; i++){
                //String方法charAt,索引,获取字符
                char c = str.charAt(i);
                //利用编码表 65-90  97-122  48-57
                if(c &gt;=&apos;A&apos; &amp;&amp; c &lt;=90){
                    upper++;
                }else if( c &gt;= 97 &amp;&amp; c &lt;= 122){
                    lower++;
                }else if( c &gt;= 48 &amp;&amp; c &lt;=&apos;9&apos;){
                    digit++;
                }
            }
            System.out.println(upper);
            System.out.println(lower);
            System.out.println(digit);
        }
    }</code></pre><p>###12String类练习_2<br>    * A: 将字符串中，第一个字母转换成大写，其他字母转换成小写，并打印改变后的字符串。<br>        * a: 题目分析<br>            * 把字符串分为两个部分，第一部分为字符串中第一个字母，第二部分为剩下的字符串。<br>            * 把第一部分字符串转换成大写字母，把第二部分字符串转换成小写字母<br>            * 把两部分字符串连接在一起，得到一个完整的字符串<br>        * b: 解题步骤<br>            * 略<br>        * C: 案例代码<br>            public class StringTest {<br>                public static void main(String[] args) {</p>
<pre><code>        System.out.println(toConvert(&quot;aBc5%4dEF&quot;));

    }

    /*
     *  将字符串的首字母转成大写,其他内容转成小写
     *  思想:
     *    获取首字母, charAt(0)  substring(0,1)
     *    转成大写 toUpperCase()
     *    
     *    获取剩余字符串, substring(1)  toLowerCase()
     */
    public static String toConvert(String str){
        //定义变量,保存首字母,和剩余字符
        String first = str.substring(0,1);
        String after = str.substring(1);
        //调用String类方法,大写,小写转换
        first = first.toUpperCase();
        after = after.toLowerCase();
        return first+after;
    }
}</code></pre><p>###13String类练习_3<br>    * A: 查询大字符串中，出现指定小字符串的次数<br>        * a: 题目分析<br>            * 在大串中，查找小串出现的位置，出现了就次数+1<br>            * 在上次小串出现位置的后面继续查找，需要更改大串的内容为上次未查询到的字符串。<br>            * 回到第一步，继续查找小串出现的位置，直到大串中查询不到小串为止<br>        * b: 解题步骤<br>            * 略<br>        * C: 案例代码<br>            package cn.itcast.demo02;</p>
<pre><code>public class StringTest {
    public static void main(String[] args) {        
        System.out.println(getStringCount(&quot;hellojava,nijavahaojava,javazhenbang&quot;, &quot;java&quot;));
    }
    /*
     *  获取一个字符串中,另一个字符串出现的次数
     *  思想:
     *    1. indexOf到字符串中到第一次出现的索引
     *    2. 找到的索引+被找字符串长度,截取字符串
     *    3. 计数器++
     */
    public static int getStringCount(String str, String key){
        //定义计数器
        int count = 0;
        //定义变量,保存indexOf查找后的索引的结果
        int index = 0;
        //开始循环找,条件,indexOf==-1 字符串没有了
        while(( index = str.indexOf(key) )!= -1){
            count++;
            //获取到的索引,和字符串长度求和,截取字符串
            str = str.substring(index+key.length());
        }
        return count;
    }
}</code></pre><p>======================================================================第三节课开始=========================================================</p>
<p>###14StringBuffer特点可变字符数组<br>    * A:StringBuffer类概述<br>        * 通过JDK提供的API，查看StringBuffer类的说明<br>        * 线程安全的可变字符序列<br>        * 底层采用字符数组实现,初始容量为16<br>    * B:StringBuffer和String的区别<br>        * String是一个不可变的字符序列<br>        * StringBuffer是一个可变的字符序列</p>
<p>###15StringBuffer类的方法<br>    * A: StringBuffer类的方法<br>        * a: 方法介绍<br>            * StringBuffer append(), 将任意类型的数据,添加缓冲区<br>                *  append 返回值,写return this<br>                *  调用者是谁,返回值就是谁<br>            * delete(int start,int end): 删除缓冲区中字符<br>                *  开始索引包含,结尾索引不包含<br>            * insert(int index, 任意类型): 将任意类型数据,插入到缓冲区的指定索引上<br>            * replace(int start,int end, String str): 将指定的索引范围内的所有字符,替换成新的字符串<br>            * reverse(): 将缓冲区中的字符反转<br>            * String toString(): 继承Object,重写toString()<br>                *   将缓冲区中的所有字符,变成字符串<br>        * b: 案例代码<br>            public class StringBufferDemo {<br>                public static void main(String[] args) {<br>                    function_5();<br>                }<br>                /*<br>                 *  StringBuffer类的方法<br>                 *   String toString() 继承Object,重写toString()<br>                 *   将缓冲区中的所有字符,变成字符串<br>                 */<br>                public static void function_5(){<br>                    StringBuffer buffer = new StringBuffer();<br>                    buffer.append(“abcdef”);<br>                    buffer.append(12345);</p>
<pre><code>        //将可变的字符串缓冲区对象,变成了不可变String对象
        String s = buffer.toString();
        System.out.println(s);
    }

    /*
     *  StringBuffer类的方法
     *    reverse() 将缓冲区中的字符反转
     */
    public static void function_4(){
        StringBuffer buffer = new StringBuffer();
        buffer.append(&quot;abcdef&quot;);

        buffer.reverse();

        System.out.println(buffer);
    }

    /*
     *  StringBuffer类方法
     *    replace(int start,int end, String str)
     *    将指定的索引范围内的所有字符,替换成新的字符串
     */
    public static void function_3(){
        StringBuffer buffer = new StringBuffer();
        buffer.append(&quot;abcdef&quot;);

        buffer.replace(1, 4, &quot;Q&quot;);

        System.out.println(buffer);
    }

    /*
     *  StringBuffer类方法 insert
     *    insert(int index, 任意类型)
     *  将任意类型数据,插入到缓冲区的指定索引上
     */
     public static void function_2(){
         StringBuffer buffer = new StringBuffer();
         buffer.append(&quot;abcdef&quot;);     

         buffer.insert(3, 9.5);
         System.out.println(buffer);
     }

    /*
     * StringBuffer类方法
     *   delete(int start,int end) 删除缓冲区中字符
     *   开始索引包含,结尾索引不包含
     */
    public static void function_1(){
        StringBuffer buffer = new StringBuffer();
        buffer.append(&quot;abcdef&quot;);

        buffer.delete(1,5);
        System.out.println(buffer);
    }

    /*
     *  StringBuffer类方法
     *   StringBuffer append, 将任意类型的数据,添加缓冲区
     *   append 返回值,写return this
     *   调用者是谁,返回值就是谁
     */
    public static void function(){
        StringBuffer buffer = new StringBuffer();
        //调用StringBuffer方法append向缓冲区追加内容
        buffer.append(6).append(false).append(&apos;a&apos;).append(1.5);
        System.out.println(buffer);
    }
}</code></pre><p>​<br>###16StringBuilder类<br>    * A:StringBuilder的概述<br>        * 通过查看API了解一下StringBuilder类<br>    * B:面试题<br>        * String,StringBuffer,StringBuilder的区别<br>            * StringBuffer和StringBuilder的区别<br>                * StringBuffer是jdk1.0版本的,是线程安全的,效率低<br>                * StringBuilder是jdk1.5版本的,是线程不安全的,效率高</p>
<pre><code>* String和StringBuffer,StringBuilder的区别
    * String是一个不可变的字符序列
    * StringBuffer,StringBuilder是可变的字符序列</code></pre><p>###17StringBuffer类案例拼接数组<br>    * A: StringBuffer类案例拼接数组<br>        * a: 题目分析<br>            * 定义StringBuffer对象<br>            * 遍历数组,按照格式要求拼接处新的字符串,追加到StringBuffer容器中<br>            * 将StringBuffer中的内容以String的形式返回<br>        * b: 解题步骤<br>            * 略<br>        * C: 案例代码<br>            public class StringBufferTest {<br>                public static void main(String[] args) {<br>                    int[] arr = {4,1,4,56,7,8,76};<br>                    System.out.println(toString(arr));<br>                }<br>               /*<br>                * int[] arr = {34,12,89,68};将一个int[]中元素转成字符串<br>                * 格式 [34,12,89,68]<br>                * String s = “[“<br>                * 数组遍历<br>                *   s+= arr[i];<br>                *  s+”]”<br>                *  StringBuffer实现,节约内存空间, String + 在缓冲区中,append方法<br>                */<br>                public static String toString(int[] arr){<br>                    //创建字符串缓冲区<br>                    StringBuffer buffer = new StringBuffer();<br>                    buffer.append(“[“);<br>                    //数组遍历<br>                    for(int i = 0 ; i &lt; arr.length;i++){<br>                        //判断是不是数组的最后一个元素<br>                        if(i == arr.length-1){<br>                            buffer.append(arr[i]).append(“]”);<br>                        }else{<br>                            buffer.append(arr[i]).append(“,”);<br>                        }<br>                    }<br>                    return buffer.toString();<br>                }<br>            }<br>###18总结</p>
<ul>
<li>把今天的知识点总结一遍。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day14%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day14%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记14</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:08:29" itemprop="dateModified" datetime="2020-12-23T23:08:29+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、Eclipse常用快捷键操作<br>2、Eclipse文档注释导出帮助文档<br>3、Eclipse项目的jar包导出与使用jar包<br>4、不同修饰符混合使用细节<br>5、辨析何时定义变量为成员变量<br>6、类、抽象类、接口作为方法参数<br>7、类、抽象类、接口作为方法返回值</p>
<p>第1章 Eclipse的应用<br>###01 day14_01(面向对象)eclipse快捷键.avi(14:33)<br>###02 day14_02(面向对象)java中的文档注释和制作.avi(15:08)<br>###03 day14_03(面向对象)eclipse生成jar包(08:37)<br>###04 day14_04(面向对象)JAVA_HOME配置.avi(03:27)<br>###05 day14_05(面向对象)导入jar包.avi(12:13)</p>
<p>第2章    面向对象<br>###06 day14_07(面向对象)类中的修饰符(09:33)<br>###07 day14_08(面向对象)局部变量和成员变量解析(11:01)</p>
<p>第3章    自定义数据类型的使用<br>###08 day14_09(面向对象)类作为方法的参数(08:12)<br>###09 day14_10(面向对象)类作为方法的返回值(07:50)<br>###10 day14_11(面向对象)抽象类作为方法的参数(10:37)<br>###11 day14_12(面向对象)抽象类作为方法的返回值(09:24)<br>###12 day14_13(面向对象)抽象类作为方法的返回值_1(01:53)<br>###13 day14_14(面向对象)接口作为方法的参数(05:55)<br>###14 day14_15(面向对象)接口作为方法的参数_常量调用(03:31)<br>###15 day14_16(面向对象)接口作为方法的返回值(03:33)<br>###16 day14_17(面向对象)抽象类作为方法返回值的案例(09:31)</p>
<p>第三节课 星级酒店案例<br>###17 day14_18(面向对象)酒店案例分析(09:12)<br>###18 day14_19(面向对象)酒店案例功能实现(14:57)</p>
<p>============上面的内容,方便我们只做ppt,word教案以及书写下面的简要的笔记=================</p>
<p>=======================第一节课开始=============================================</p>
<p>###01eclipse快捷键<br>    * A:     Ctrl+T：查看所选中类的继承树<br>        例如，在下面代码中，选中Teacher类名，然后按Ctrl+T，就会显示出Teacher类的继承关系</p>
<pre><code>* B:    查看所选中方法的源代码
    Ctrl+滑动鼠标点击方法名，或者选中方法名后，按F3键查看所选中方法的源代码。</code></pre><p>###02java中的文档注释和制作<br>    * A: 在eclipse使用时，可以配合文档注释，导出对类的说明文档，从而供其         他人阅读学习与使用。<br>        通过使用文档注释，将类或者方法进行注释用@简单标注基本信息。如@author 作者、@version代码版本、@param方法参数、@return方法返回值等。</p>
<p>​<br>###03eclipse生成jar包<br>###04JAVA_HOME配置<br>###05导入jar包<br>    * A:     导入jar包：即把指定的jar包，加入到指项目中，提供给项目使用。<br>        导入jar包的过程是将jar包加入到项目的.classpath文件中去，让项目识别，便可以使用jar包中所有的.class文件类。<br>        以下是加入步骤：<br>        1：项目根文件夹下创建lib文件夹，用于同一管理所有的jar文件<br>        2：把jar文件复制到lib文件夹中<br>        3：右键点击jar文件，点击Build Path，选择Add to Build Path，此时查看项目根文件夹下的.classpath文件，发现新加入的jar包路径被配置到了该文件中。说明可以使用jar包中所有类了。</p>
<pre><code>注意：
    Jar包加入后，必须Add to Build Path才能使用
    Jar包加入后，加入的类也必须导包，如果加入的类其包名与现有类包名相同，则视作在同一个包下。(不常见)</code></pre><p>==============================第二节课开始====================================        </p>
<p>​                </p>
<p>###07不同修饰符使用细节</p>
<pre><code>A: 常用来修饰类、方法、变量的修饰符如下：
    public 权限修饰符，公共访问, 类,方法,成员变量
    protected 权限修饰符，受保护访问, 方法,成员变量
    默认什么也不写 也是一种权限修饰符，默认访问, 类,方法,成员变量
    private 权限修饰符，私有访问, 方法,成员变量
    static 静态修饰符  方法,成员变量
    final 最终修饰符   类,方法,成员变量,局部变量
    abstract 抽象修饰符  类 ,方法

B: 不能同时使用的修饰符
    同时，abstract与private不能同时使用；
    同时，abstract与static不能同时使用；
    同时，abstract与final不能同时使用。</code></pre><p>    C: 修饰类能够使用的修饰符：<br>        修饰类只能使用public、默认的、final、abstract关键字<br>        使用最多的是 public关键字</p>
<pre><code>    a:代码案例
        public class Demo {} //最常用的方式
        class Demo2{}
        public final class Demo3{}
        public abstract class Demo4{}

D:修饰成员变量能够使用的修饰符：
    public : 公共的
    protected : 受保护的
        : 默认的
    private ：私有的
    final : 最终的
    static : 静态的
    使用最多的是 private

    a: 代码案例
        public int count = 100;
        protected int count2 = 100;
        int count3 = 100;
        private int count4 = 100; //最常用的方式
        public final int count5 = 100;
        public static int count6 = 100;</code></pre><p>    E:修饰构造方法能够使用的修饰符：<br>        public : 公共的<br>        protected : 受保护的<br>            : 默认的<br>        private ：私有的<br>        使用最多的是 public</p>
<pre><code>a:代码案例
    public Demo(){} //最常用的方式
    protected Demo(){}
    Demo(){}
    private Demo(){}

    修饰成员方法能够使用的修饰符：
        public : 公共的
        protected : 受保护的
            : 默认的
        private ：私有的
        final : 最终的
        static : 静态的
        abstract : 抽象的
        使用最多的是 public
    public void method1(){}//最常用的方式
    protected void method2(){}
    void method3(){}
    private void method4(){}
    public final void method5(){}
    public static void method6(){}//最常用的方式
    public abstract void method7();//最常用的方式</code></pre><p>###07局部变量和成员变量解析<br>    * A：程序编译<br>            数学工具类<br>    public class MathTool {<br>        //求两个数的和的二倍<br>        public double sum2times(int number,int number2) {<br>            return (number+number2)<em>2;<br>        }<br>        //求两个数的积<br>        public double area(int number,int number2) {<br>            return number</em>number2;<br>        }<br>    }</p>
<p>    长方形类<br>    public class CFX {<br>        //因为长与宽，在现实事物中属于事物的一部分，所以定义成员变量<br>        private int chang;<br>        private int kuan;</p>
<pre><code>    public CFX(int chang, int kuan) {
        this.chang = chang;
        this.kuan = kuan;
    }

    //求长与宽的周长
    public double zhouChang() {
        return (chang+kuan)*2;
    }
    //求长与宽的面积
    public double mianJi() {
        return chang*kuan;
    }
    public int getChang() {
        return chang;
    }
    public void setChang(int chang) {
        this.chang = chang;
    }
    public int getKuan() {
        return kuan;
    }
    public void setKuan(int kuan) {
        this.kuan = kuan;
    }
}</code></pre><p>###08类作为方法的参数<br>    * A：    类作为方法参数<br>        在编写程序中，会经常碰到调用的方法要接收的是一个类类型的情况，那么这时，要向方法中传入该类的对象。</p>
<pre><code>如下代码演示：
    class Person{
        public void show(){
            System.out.println(&quot;show方法执行了&quot;);
        }
    }
    //测试类
    public class Test {
        public static void main(String[] args) {
            //创建Person对象
            Person p = new Person();
            //调用method方法
            method(p);
        }

    //定义一个方法method，用来接收一个Person对象，在方法中调用Person对象的show方法
    public static void method(Person p){
        p.show();
    }</code></pre><p>###09抽象类作为方法参数与返回值<br>    * A:     抽象类作为方法参数<br>        今后开发中，抽象类作为方法参数的情况也很多见。当遇到方法参数为抽象类类型时，要传入一个实现抽象类所有抽象方法的子类对象。如下代码演示：<br>        //抽象类<br>        abstract class Person{<br>            public abstract void show();<br>        }<br>        class Student extends Person{<br>            @Override<br>            public void show() {<br>                System.out.println(“重写了show方法”);<br>            }<br>        }<br>        //测试类<br>        public class Test {<br>            public static void main(String[] args) {<br>                //通过多态的方式，创建一个Person类型的变量，而这个对象实际是Student<br>                Person p = new Student();<br>                //调用method方法<br>                method(p);<br>            }</p>
<pre><code>        //定义一个方法method，用来接收一个Person类型对象，在方法中调用Person对象的show方法
        public static void method(Person p){//抽象类作为参数
            //通过p变量调用show方法,这时实际调用的是Student对象中的show方法
            p.show();    
    }
    }


* B:    抽象类作为方法返回值
    抽象类作为方法返回值的情况，也是有的，这时需要返回一个实现抽象类所有抽象方法的子类对象。如下代码演示：
    //抽象类
    abstract class Person{
        public abstract void show();
    }
    class Student extends Person{
        @Override
        public void show() {
            System.out.println(&quot;重写了show方法&quot;);
        }
    }
    //测试类
    public class Test {
        public static void main(String[] args) {
            //调用method方法，获取返回的Person对象
            Person p = method();
            //通过p变量调用show方法,这时实际调用的是Student对象中的show方法
            p.show();
        }

        //定义一个方法method，用来获取一个Person对象，在方法中完成Person对象的创建
        public static Person method(){
            Person p = new Student();
            return p;
        }
    }</code></pre><p>​<br>###10接口作为方法参数与返回值<br>    * A:     接口作为方法参数<br>        接口作为方法参数的情况是很常见的，经常会碰到。当遇到方法参数为接口类型时，那么该方法要传入一个接口实现类对象。如下代码演示。<br>        //接口<br>        interface Smoke{<br>            public abstract void smoking();<br>        }<br>        class Student implements Smoke{<br>            @Override<br>            public void smoking() {<br>                System.out.println(“课下吸口烟，赛过活神仙”);<br>            }<br>        }<br>        //测试类<br>        public class Test {<br>            public static void main(String[] args) {<br>                //通过多态的方式，创建一个Smoke类型的变量，而这个对象实际是Student<br>                Smoke s = new Student();<br>                //调用method方法<br>                method(s);<br>            }</p>
<pre><code>        //定义一个方法method，用来接收一个Smoke类型对象，在方法中调用Smoke对象的show方法
        public static void method(Smoke sm){//接口作为参数
            //通过sm变量调用smoking方法，这时实际调用的是Student对象中的smoking方法
            sm.smoking();
        }
    }

* B:    接口作为方法返回值
    接口作为方法返回值的情况，在后面的学习中会碰到。当遇到方法返回值是接口类型时，那么该方法需要返回一个接口实现类对象。如下代码演示。

    //接口
    interface Smoke{
        public abstract void smoking();
    }
    class Student implements Smoke{
        @Override
        public void smoking() {
            System.out.println(&quot;课下吸口烟，赛过活神仙&quot;);
        }
    }
    //测试类
    public class Test {
        public static void main(String[] args) {
            //调用method方法，获取返回的会吸烟的对象
            Smoke s = method();
            //通过s变量调用smoking方法,这时实际调用的是Student对象中的smoking方法
            s.smoking();
        }

        //定义一个方法method，用来获取一个具备吸烟功能的对象，并在方法中完成吸烟者的创建
        public static Smoke method(){
            Smoke sm = new Student();
            return sm;
        }
    }</code></pre><p>​<br>==============================第三节课开始====================================<br>###11星级酒店案例<br>    * A:     根据“某五星级酒店，资金雄厚……都有自己的工作要做。”分析出，该题        目中包含酒店，可以把它封装成类，多名员工）。</p>
<pre><code>    class 员工 {
         属性：姓名
    属性：工号
    方法：工作
    }
    class 厨师 extends 员工{}
    class 服务员 extends 员工{}
    class 经理 extends 员工 {
         属性：奖金
    }

    员工的类型有经理、厨师、服务员，它们有共同的属性（姓名、工号、），经理额外属性（奖金）。

        根据“向酒店中，增加多名员工（其中包含1名经理，1名厨师、2名服务员）”。分析出，要创建一个酒店对象，并添加4名员工到酒店对象的员工集合中。
    酒店员工集合添加新员工： 经理对象
    酒店员工集合添加新员工： 厨师对象
    酒店员工集合添加新员工： 服务员对象
    酒店员工集合添加新员工： 服务员对象

        根据“获取酒店幸运员工”。分析出，从酒店员工集合随机得到一名员工对象。
    1. 从酒店员工集合长度范围内，随机产生一个随机数
    2. 使用该随机数作为集合的索引，返回该索引处对应的员工对象

        根据“酒店开设VIP服务，酒店的厨师与服务员可以提供VIP服务。（厨师做菜加量、服务员给顾客倒酒）”。分析出，这是要增加一个VIP的接口，接口中提供个VIP服务的方法。让厨师与服务员实现该接口。
    interface VIP服务{
         抽象方法：服务
    }
    class 厨师 extends 员工 implements VIP服务{ 重写服务方法 }
    class 服务员 extends 员工 implements VIP服务{ 重写服务方法 }

B:
    VIP服务</code></pre><p>public interface VIP {<br>     public abstract void server(); //服务<br>}</p>
<p>    员工<br>/*</p>
<ul>
<li>员工：<br>  姓名 String<br>  工号 String</li>
</ul>
<p> */<br>public abstract class YuanGong {<br>    // 成员变量<br>    private String xingMing;<br>    private String gongHao;<br>    // 构造方法<br>    public YuanGong() {<br>        super();<br>    }<br>    public YuanGong(String xingMing, String gongHao) {<br>        super();<br>        this.xingMing = xingMing;<br>        this.gongHao = gongHao;</p>
<pre><code>}
// 抽象方法
public abstract void work();

// getters与setters
public String getXingMing() {
    return xingMing;
}
public void setXingMing(String xingMing) {
    this.xingMing = xingMing;
}
public String getGongHao() {
    return gongHao;
}
public void setGongHao(String gongHao) {
    this.gongHao = gongHao;
}</code></pre><p>}</p>
<p>    服务员<br>/*</p>
<ul>
<li><p>定义员工的子类 服务员类</p>
</li>
<li><p>/<br>public class FuWuYuan extends YuanGong implements VIP {<br>  public FuWuYuan() {</p>
<pre><code>super();</code></pre><p>  }</p>
<p>  public FuWuYuan(String xingMing, String gongHao) {</p>
<pre><code>super(xingMing, gongHao);</code></pre><p>  }<br>  @Override<br>  public void work() {</p>
<pre><code>System.out.println(&quot;亲，全身心为您服务，记得给好评哦&quot;);</code></pre><p>  }<br>  @Override<br>  public void server() {</p>
<pre><code>System.out.println(&quot;给顾客倒酒&quot;);</code></pre><p>  }<br>}</p>
</li>
</ul>
<p>    经理<br>/*</p>
<ul>
<li><p>经理在员工的基础上，添加了奖金成员</p>
</li>
<li><p>/<br>public class JingLi extends YuanGong {<br>  private double jiangJin;</p>
<p>  public JingLi() {</p>
<pre><code>super();</code></pre><p>  }<br>  public JingLi(String xingMing, String gongHao, double jiangJin) {</p>
<pre><code>super(xingMing, gongHao);
this.jiangJin = jiangJin;</code></pre><p>  }</p>
<p>  public double getJiangJin() {</p>
<pre><code>return jiangJin;</code></pre><p>  }<br>  public void setJiangJin(double jiangJin) {</p>
<pre><code>this.jiangJin = jiangJin;</code></pre><p>  }</p>
<p>  @Override<br>  public void work() {</p>
<pre><code>System.out.println(&quot;哪个员工让顾客不满意，我扣谁钱&quot;);</code></pre><p>  };<br>}</p>
</li>
</ul>
<p>    厨师<br>/*</p>
<ul>
<li><p>定义员工的子类 厨师类</p>
</li>
<li><p>/<br>public class ChuShi extends YuanGong implements VIP{<br>  public ChuShi() {</p>
<pre><code>super();</code></pre><p>  }<br>  public ChuShi(String xingMing, String gongHao) {</p>
<pre><code>super(xingMing, gongHao);</code></pre><p>  }</p>
<p>  @Override<br>  public void work() {</p>
<pre><code>System.out.println(&quot;我做饭，放心吃吧，包您满意&quot;);</code></pre><p>  }<br>  @Override<br>  public void server() {</p>
<pre><code>System.out.println(&quot;做菜加量加料&quot;);</code></pre><p>  }<br>}</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day13%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day13%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记13</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:08:17" itemprop="dateModified" datetime="2020-12-23T23:08:17+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、final 关键字<br>2、static 关键字<br>3、匿名对象<br>4、内部类<br>5、包的声明与访问<br>6、访问修饰符<br>7、代码块</p>
<p>第一节课<br>###01(面向对象)final关键字概念.avi                               02:20<br>###02(面向对象)final修饰类.avi                                    04:25<br>###03(面向对象)final修饰方法.avi                                 04:01<br>###04(面向对象)final修饰局部变量.avi                             05:57<br>###05(面向对象)final修饰成员变量.avi                              10:04<br>###06(面向对象)static的概念.avi                                 09:28</p>
<p>第二节课<br>###07(面向对象)static修饰的对象特有数据.avi                      06:53<br>###08(面向对象)static的内存图.avi                               14:09<br>###09(面向对象)static注意事项_静态不能直接调用非静态.avi         08:02<br>###10(面向对象)static静态的使用场景.avi                            08:14<br>###11(面向对象)对象中的静态调用.avi                              06:45<br>###12(面向对象)定义静态常量.avi                                  03:44</p>
<p>第三节课<br>###13(面向对象)匿名对象.avi                                      12:46<br>###14(面向对象)内部类.avi                                       03:34<br>###15(面向对象)成员内部类的调用格式.avi                         09:19<br>###16(面向对象)成员内部类的同名变量调用.avi                     02:59<br>###17(面向对象)局部内部类.avi                                  07:18<br>###18(面向对象)匿名内部类.avi                                      12:22 </p>
<p>第四节课<br>###19(面向对象)匿名内部类_2.avi                                 04:19<br>###20(面向对象)包的概念.avi                                      02:29<br>###21(面向对象)导入包.avi                                     06:48<br>###22(面向对象)权限修饰符.avi                                    12:47<br>###23(面向对象)代码块.avi                                      05:17</p>
<p>============上面的内容,方便我们只做ppt,word教案以及书写下面的简要的笔记=================</p>
<p>=======================第一节课开始=============================================</p>
<p>###01final关键字概念<br>    * A: 概述<br>            继承的出现提高了代码的复用性，并方便开发。但随之也有问题，有些类在描述完之后，不想被继承，<br>            或者有些类中的部分方法功能是固定的，不想让子类重写。可是当子类继承了这些特殊类之后，<br>            就可以对其中的方法进行重写，那怎么解决呢？<br>            要解决上述的这些问题，需要使用到一个关键字final，final的意思为最终，不可变。<br>            final是个修饰符，它可以用来修饰类，类的成员，以及局部变量。</p>
<p>###02final修饰类义<br>    * A: final 修饰类<br>            final修饰类不可以被继承，但是可以继承其他类。<br>    * B: 案例<br>            class Yy {}<br>            final class Fu extends Yy{} //可以继承Yy类<br>            class Zi extends Fu{} //不能继承Fu类</p>
<p>​<br>​<br>###03final修饰方法<br>    * A: final修饰方法<br>                final修饰的方法不可以被覆盖,但父类中没有被final修饰方法，子类覆盖后可以加final。<br>    * B: 案例<br>             class Fu {<br>                // final修饰的方法，不可以被覆盖，但可以继承使用<br>                public final void method1(){}<br>                public void method2(){}<br>            }<br>            class Zi extends Fu {<br>                //重写method2方法<br>                public final void method2(){}<br>            }</p>
<p>###04final修饰局部变量<br>    * A:修饰基本数据类型变量<br>        final修饰的变量称为常量，这些变量只能赋值一次</p>
<pre><code>* B:案例1
        final int i = 20;
        i = 30; //赋值报错，final修饰的变量只能赋值一次

* C: 修饰引用数据类型
        引用类型的变量值为对象地址值，地址值不能更改，但是地址内的对象属性值可以修改

* D: 修饰引用数据类型
        final Person p = new Person();
        Person p2 = new Person();
        p = p2; //final修饰的变量p，所记录的地址值不能改变
        p.name = &quot;小明&quot;;//可以更改p对象中name属性值
        p不能为别的对象，而p对象中的name或age属性值可更改。</code></pre><p>​<br>###05final修饰成员变量<br>    * A: 修饰成员变量<br>         修饰成员变量，需要在创建对象前赋值，否则报错。(当没有显式赋值时，多个构造方法的均需要为其赋值。)</p>
<pre><code>* B: 案例
        class Demo {
            //直接赋值
            final int m = 100;

            //final修饰的成员变量，需要在创建对象前赋值，否则报错。
            final int n; 
            public Demo(){
                //可以在创建对象时所调用的构造方法中，为变量n赋值
                n = 2016;
            }
        }</code></pre><p>###06static的概念<br>    * A：概念<br>        当在定义类的时候，类中都会有相应的属性和方法。而属性和方法都是通过创建本类对象调用的。<br>        当在调用对象的某个方法时，这个方法没有访问到对象的特有数据时，方法创建这个对象有些多余。<br>        可是不创建对象，方法又调用不了，这时就会想，那么我们能不能不创建对象，就可以调用方法呢？<br>        可以的，我们可以通过static关键字来实现。static它是静态修饰符，一般用来修饰类中的成员。</p>
<p>==============================第二节课开始====================================    </p>
<p>###07static修饰的对象特有数据<br>    * A：特点1:<br>            被static修饰的成员变量属于类，不属于这个类的某个对象。<br>            （也就是说，多个对象在访问或修改static修饰的成员变量时，其中一个对象将static成员变量值进行了修改，<br>            其他对象中的static成员变量值跟着改变，即多个对象共享同一个static成员变量）<br>    * B: 代码演示<br>            class Demo {<br>                public static int num = 100;<br>            }</p>
<pre><code>class Test {
    public static void main(String[] args) {
        Demo d1 = new Demo();
        Demo d2 = new Demo();
        d1.num = 200;
        System.out.println(d1.num); //结果为200
        System.out.println(d2.num); //结果为200
    }
}</code></pre><p>​    </p>
<p>###08static的内存图<br>    * A: 略<br>            参考day13_source 静态的内存图.jpg</p>
<p>​<br>###09static注意事项_静态不能直接调用非静态<br>    * A: 注意事项<br>            被static修饰的成员可以并且建议通过类名直接访问。</p>
<pre><code>* B: 访问静态成员的格式：
        类名.静态成员变量名
        类名.静态成员方法名(参数)
        对象名.静态成员变量名             ------不建议使用该方式，会出现警告
        对象名.静态成员方法名(参数)     ------不建议使用该方式，会出现警告

* C: 代码演示
        class Demo {
            //静态成员变量
            public static int num = 100;
            //静态方法
            public static void method(){
                System.out.println(&quot;静态方法&quot;);
            }
        }
        class Test {
            public static void main(String[] args) {
                System.out.println(Demo.num);
                Demo.method();
            }
        }</code></pre><p>​        </p>
<p>###10static静态的使用场景<br>    * A: 使用场景<br>        static可以修饰成员变量和成员方法。<br>        什么时候使用static修饰成员变量？<br>            加static修饰成员的时候，这个成员会被类的所有对象所共享。一般我们把共性数据定义为静态的变量<br>        什么时候使用static修饰成员方法？<br>            静态的方法只能访问静态的成员，如果静态方法中引用到了静态的其他成员，那么这个方法需要声明为静态的方法。</p>
<p>###11对象中的静态调用<br>    * A: 对象的静态调用<br>      在多态中，非静态编译看父类，运行看子类，父类没有编译失败。<br>      但多态中的静态方法,编译看父类,运行仍然看父类。因为静态和对象没有关系，属于静态绑定。</p>
<pre><code>* B: 举例
    public class Test{
        public static void main(String[] args){
            Fu f = new Zi();
            f.show();   //父类的引用和父类的方法绑定,和对象无关,不会在运行时动态的执行子类特有的方法。
        }
    }</code></pre><p>###12定义静态常量<br>    * A: 静态常量<br>        开发中，我们想在类中定义一个静态常量，通常使用public static final修饰的变量来完成定义。<br>        此时变量名用全部大写，多个单词使用下划线连接。<br>    * B: 定义格式：<br>        public static final 数据类型 变量名 = 值;</p>
<pre><code>* C: 如下演示：
    class Company {
        public static final String COMPANY_NAME = &quot;传智播客&quot;;
        public static void method(){
            System.out.println(&quot;一个静态方法&quot;);
        }
    }

    当我们想使用类的静态成员时，不需要创建对象，直接使用类名来访问即可。
    System.out.println(Company.COMPANY_NAME); //打印传智播客
    Company.method(); // 调用一个静态方法

* D: 注意：
    接口中的每个成员变量都默认使用public static final修饰。
    所有接口中的成员变量已是静态常量，由于接口没有构造方法，所以必须显示赋值。可以直接用接口名访问。
    interface Inter {
        public static final int COUNT = 100;
    }
        访问接口中的静态变量
    Inter.COUNT</code></pre><p>​<br>==============================第三节课开始====================================</p>
<p>###13匿名对象<br>    * A:匿名对象的概述<br>        * 匿名对象是指创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。<br>    * B:案例<br>        public class Person{<br>            public void eat(){<br>                System.out.println();<br>        }<br>        }</p>
<pre><code>    创建一个普通对象
    Person p = new Person();
    创建一个匿名对象
    new Person();

* C: 匿名对象的特点
    a:创建匿名对象直接使用，没有变量名。
        new Person().eat()  //eat方法被一个没有名字的Person对象调用了。

    b:匿名对象在没有指定其引用变量时，只能使用一次。
        new Person().eat(); 创建一个匿名对象，调用eat方法
        new Person().eat(); 想再次调用eat方法，重新创建了一个匿名对象

    c:匿名对象可以作为方法接收的参数、方法返回值使用
        class Demo {
            public static Person getPerson(){
                //普通方式
                //Person p = new Person();    
                //return p;

                //匿名对象作为方法返回值
                return new Person(); 
            }

            public static void method(Person p){}
        }

        class Test {
            public static void main(String[] args) {
                //调用getPerson方法，得到一个Person对象
                Person person = Demo.getPerson();

                //调用method方法
                Demo.method(person);
                //匿名对象作为方法接收的参数
                Demo.method(new Person());
            }
        }</code></pre><p>​<br>###14内部类<br>    * A: 内部类的概述<br>        将类写在其他类的内部，可以写在其他类的成员位置和局部位置，这时写在其他类内部的类就称为内部类。<br>        其他类也称为外部类。<br>    * B: 什么时候使用内部类<br>        在描述事物时，若一个事物内部还包含其他可能包含的事物，比如在描述汽车时，汽车中还包含这发动机，<br>        这时发动机就可以使用内部类来描述。<br>        class 汽车 { //外部类<br>            class 发动机 { //内部类<br>            }<br>        }<br>    * C: 内部类的分类<br>        内部类分为成员内部类与局部内部类。<br>        我们定义内部类时，就是一个正常定义类的过程，同样包含各种修饰符、继承与实现关系等。<br>        在内部类中可以直接访问外部类的所有成员。</p>
<p>###15成员内部类的调用格式<br>    * A: 格式<br>        成员内部类，定义在外部类中的成员位置。与类中的成员变量相似，可通过外部类对象进行访问<br>    * B: 定义格式<br>        class 外部类 {<br>            修饰符 class 内部类 {<br>                //其他代码<br>            }<br>        }</p>
<pre><code>* C: 访问方式
    外部类名.内部类名 变量名 = new 外部类名().new 内部类名();

* D: 成员内部类代码演示
    class Body {//外部类，身体
         private boolean life= true; //生命状态
         public class Heart { //内部类，心脏
             public void jump() {
                 System.out.println(&quot;心脏噗通噗通的跳&quot;)
                    System.out.println(&quot;生命状态&quot; + life); //访问外部类成员变量
            }
        }
    }

    访问内部类
    public static void main(String[] args) {
        //创建内部类对象
        Body.Heart bh = new Body().new Heart();
        //调用内部类中的方法
        bh.jump();
    }</code></pre><p>​        </p>
<p>###16成员内部类的同名变量调用<br>    * A: 代码实现<br>        public class Outer {<br>            int i  = 1;<br>            class Inner {<br>                int i  = 2;<br>                public void inner(){<br>                    int i = 3;<br>                    System.out.println(Outer.this.i);<br>                }<br>            }<br>        }</p>
<p>​<br>###17局部内部类<br>    * A 局部内部类，定义在外部类方法中的局部位置。与访问方法中的局部变量相似，可通过调用方法进行访问.<br>    * B 定义格式<br>        class 外部类 {<br>            修饰符 返回值类型 方法名(参数) {<br>                class 内部类 {<br>                    //其他代码<br>                }<br>            }<br>        }<br>    * C 访问方式<br>        在外部类方法中，创建内部类对象，进行访问</p>
<pre><code>* D 局部内部类代码演示
    定义类
    class Party {//外部类，聚会
        public void puffBall(){// 吹气球方法
            class Ball {// 内部类，气球
                  public void puff(){
                    System.out.println(&quot;气球膨胀了&quot;);
                  }
            }
            //创建内部类对象，调用puff方法
            new Ball().puff();
        }
    }
    访问内部类
    public static void main(String[] args) {    
        //创建外部类对象
        Party p = new Party();
        //调用外部类中的puffBall方法
        p.puffBall();
    }</code></pre><p>==============================第四节课开始====================================</p>
<p>###18匿名内部类<br>     * A: 概述<br>     内部类是为了应对更为复杂的类间关系。查看源代码中会涉及到，而在日常业务中很难遇到，这里不做赘述。<br>     最常用到的内部类就是匿名内部类，它是局部内部类的一种。<br>     定义的匿名内部类有两个含义：<br>     临时定义某一指定类型的子类<br>     定义后即刻创建刚刚定义的这个子类的对象</p>
<pre><code>* B: 本质
 匿名内部类的本质是一个实现了接口或继承了某个类的子类匿名对象.

* C: 案例
public interface Smoking {
    public abstract void smoking();
    }
    /*
     *  实现类,实现接口 重写接口抽象方法,创建实现类对象
     *  class XXX implements Smoking{
     *      public void smoking(){
     *      
     *      }
     *  }
     *  XXX x = new XXX();
     *  x.smoking(); 
     *  Smoking s = new XXX();
     *  s.smoking();
     *  
     *  匿名内部类,简化问题:  定义实现类,重写方法,建立实现类对象,合为一步完成
     */

测试类:
public class Test {
    public static void main(String[] args) {
        //使用匿名内部类
        /*
         *  定义实现类,重写方法,创建实现类对象,一步搞定
         *  格式:
         *    new 接口或者父类(){
         *       重写抽象方法
         *    };
         *    从 new开始,到分号结束
         *    创建了接口的实现类的对象
         */
        new Smoking(){
            public void smoking(){
                System.out.println(&quot;人在吸烟&quot;);
            }
        }.smoking();
    }
}</code></pre><p>###19匿名内部类_2<br>     * A: 匿名内部类案例演示<br>        public abstract class Animal {<br>            public abstract void eat();<br>            public abstract void sleep();<br>        }</p>
<pre><code>测试代码
/*
 *    new Animal(){
            public void eat(){
                System.out.println(&quot;在吃饭&quot;);
            } 
            public void sleep(){
                System.out.println(&quot;在睡觉&quot;);
            }
         };
    以上代码,就是Animal的子类的对象
    多态性, 父类引用 = 子类的对象

 */
public class Test2 {
    public static void main(String[] args) {
        Animal a= new Animal(){
            public void eat(){
                System.out.println(&quot;在吃饭&quot;);
            } 
            public void sleep(){
                System.out.println(&quot;在睡觉&quot;);
            }
         };
         a.eat();
         a.sleep();
    }
}</code></pre><p>###20包的概念<br>     * A: 概念<br>        java的包，其实就是我们电脑系统中的文件夹，包里存放的是类文件。<br>        当类文件很多的时候，通常我们会采用多个包进行存放管理他们，这种方式称为分包管理。<br>        在项目中，我们将相同功能的类放到一个包中，方便管理。并且日常项目的分工也是以包作为边界。<br>        类中声明的包必须与实际class文件所在的文件夹情况相一致，即类声明在a包下，则生成的.class文件必须在a文件夹下，否则，程序运行时会找不到类。</p>
<pre><code>* B 声明格式
    通常使用公司网址反写，可以有多层包，包名采用全部小写字母，多层包之间用”.”连接
        类中包的声明格式： 
    package 包名.包名.包名…;
        如：黑马程序员网址itheima.com那么网址反写就为com.itheima
            传智播客 itcast.cn  那么网址反写就为 cn.itcast
        注意：声明包的语句，必须写在程序有效代码的第一行（注释不算）
    代码演示：
    package cn.itcast; //包的声明，必须在有效代码的第一行

    import java.util.Scanner;
    import java.util.Random;

    public class Demo {}

* C: 包的访问
    在访问类时，为了能够找到该类，必须使用含有包名的类全名（包名.类名）。
    包名.包名….类名
    如： java.util.Scanner
         java.util.Random
        cn.itcast.Demo
    带有包的类，创建对象格式：包名.类名 变量名 = new包名.类名();
         cn.itcast.Demo d = new cn.itcast.Demo();
        前提：包的访问与访问权限密切相关，这里以一般情况来说，即类用public修饰的情况。

        类的简化访问
    当我们要使用一个类时，这个类与当前程序在同一个包中（即同一个文件夹中），或者这个类是java.lang包中的类时通常可以省略掉包名，直接使用该类。
    如：cn.itcast包中有两个类，PersonTest类，与Person类。我们在PersonTest类中，访问Person类时，由于是同一个包下，访问时可以省略包名，即直接通过类名访问 Person。
    类名 变量名 = new类名();
    Person p = new Person();

        当我们要使用的类，与当前程序不在同一个包中（即不同文件夹中），要访问的类必须用public修饰才可访问。
    package cn.itcst02;
    public class Person {}</code></pre><p>​<br>###22导入包<br>      * A:导入包<br>        我们每次使用类时，都需要写很长的包名。很麻烦，我们可以通过import导包的方式来简化。<br>        可以通过导包的方式使用该类，可以避免使用全类名编写（即，包类.类名）。<br>        导包的格式：<br>        import 包名.类名;</p>
<pre><code>    当程序导入指定的包后，使用类时，就可以简化了。演示如下
//导入包前的方式
//创建对象
java.util.Random r1 = new java.util.Random();
java.util.Random r2 = new java.util.Random();
java.util.Scanner sc1 = new java.util.Scanner(System.in);
java.util.Scanner sc2 = new java.util.Scanner(System.in);

//导入包后的方式
import java.util.Random;
import java.util.Scanner;
//创建对象
Random r1 = new Random();
Random r2 = new Random();
Scanner sc1 = new Scanner(System.in);
Scanner sc2 = new Scanner(System.in);
import导包代码书写的位置：在声明包package后，定义所有类class前，使用导包import包名.包名.类名;</code></pre><p>​<br>###23权限修饰符<br>     * A 权限修饰符有哪些<br>             在Java中提供了四种访问权限，使用不同的访问权限时，被修饰的内容会有不同的访问权限，<br>             以下表来说明不同权限的访问能力：<br>                                    public            protected      default        private<br>             同一类中                  √                   √             √               √<br>             同一包中(子类与无关类)      √                   √              √<br>             不同包的子类              √                   √<br>             不同包中的无关类          √<br>    * B: 小结<br>        归纳一下：在日常开发过程中，编写的类、方法、成员变量的访问<br>        要想仅能在本类中访问使用private修饰；<br>        要想本包中的类都可以访问不加修饰符即可；<br>        要想本包中的类与其他包中的子类可以访问使用protected修饰<br>        要想所有包中的所有类都可以访问使用public修饰。<br>        注意：如果类用public修饰，则类名必须与文件名相同。一个文件中只能有一个public修饰的类。</p>
<p>###24代码块<br>     * A: 概述:<br>        程序中用大括号括起来的代码叫代码块<br>     * B: 分类<br>      局部代码块  构造代码块  静态代码块  同步代码块</p>
<pre><code> * C 局部代码块:
    局部代码块是定义在方法或语句中
    特点：
        以”{}”划定的代码区域，此时只需要关注作用域的不同即可
        方法和类都是以代码块的方式划定边界的

      class Demo{
            public static void main(String[] args)    {
                {
                         int x = 1;
                         System.out.println(&quot;普通代码块&quot; + x);
                }
                int x = 99;
                System.out.println(&quot;代码块之外&quot; + x);
            }
      }
      结果：
        普通代码块1
        代码块之外99
      局部代码块作用:可以限定变量的声明周期.

* D: 构造代码块
    构造代码块是定义在类中成员位置的代码块
    特点：
        优先于构造方法执行，构造代码块用于执行所有对象均需要的初始化动作
        每创建一个对象均会执行一次构造代码块。
    public class Person {
        private String name;
        private int age;

         //构造代码块
        {
            System.out.println(&quot;构造代码块执行了&quot;);
        }
        Person(){
            System.out.println(&quot;Person无参数的构造函数执行&quot;);
        }
        Person(int age){
            this.age = age;
            System.out.println(&quot;Person（age）参数的构造函数执行&quot;);
        }
    }
    class PersonDemo{
        public static void main(String[] args)    {
            Person p = new Person();
            Person p1 = new Person(23);
        }
    }

* E: 静态代码块
    静态代码块是定义在成员位置，使用static修饰的代码块。
    特点：
        它优先于主方法执行、优先于构造代码块执行，当以任意形式第一次使用到该类时执行。
        该类不管创建多少对象，静态代码块只执行一次。
        可用于给静态变量赋值，用来给类进行初始化。
        public class Person {
            private String name;
            private int age;
             //静态代码块
            static{
                System.out.println(&quot;静态代码块执行了&quot;);
            }
        }

* F: 同步代码块(多线程学习)</code></pre><p>###25总结<br>    * 把今天的知识点总结一遍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day12%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day12%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记12</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:08:06" itemprop="dateModified" datetime="2020-12-23T23:08:06+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、构造方法<br>2、this关键字<br>3、super关键字<br>4、综合案例</p>
<p>第一节课<br>###01(面向对象)构造方法引入.avi                03：33<br>###02(面向对象)构造方法作用.avi                05：56<br>###03(面向对象)构造方法的定义和运行特点.avi        09：21<br>###04(面向对象)默认添加的构造方法.avi            04：32<br>###05(面向对象)构造方法的调用赋值.avi            05：22<br>###06(面向对象)构造方法的内存.avi                 09：44</p>
<p>第二节课<br>###07(面向对象)构造方法的重载.avi                 08：41<br>###08(面向对象)构造方法和一般方法区别.avi        02：31<br>###09(面向对象)this在构造方法之间的调用.avi     15：12<br>###10(面向对象)this在构造方法调用的内存图.avi    08：45<br>###11(面向对象)this简易应用.avi                  02：12</p>
<p>第三节课<br>###12(面向对象)super关键字_1.avi                 03：02<br>###13(面向对象)super关键字_2.avi                 08：59<br>###14(面向对象)子类父类的内存图.avi             16：04<br>###15(面向对象)super关键字_3.avi                11：38</p>
<p>第四节课<br>###16(面向对象)super关键字_4.avi                 08：17<br>###17(面向对象)创建子类对象过程的细节.avi       03：27<br>###18(面向对象)super的应用.avi                 13：02<br>###19(面向对象)完整员工案例分析.avi            05：50<br>###20(面向对象)完整员工案例代码实现.avi         10：46</p>
<p>============上面的内容,方便我们只做ppt,word教案以及书写下面的简要的笔记=================</p>
<p>=======================第一节课开始=============================================</p>
<p>###01构造方法引入<br>    * A:构造方法的引入<br>            在开发中经常需要在创建对象的同时明确对象的属性值，比如员工入职公司就要明确他的姓名、年龄等属性信息。<br>            那么，创建对象就要明确属性值，那怎么解决呢？也就是在创建对象的时候就要做的事情，当使用new关键字创建对象时，怎么给对象的属性初始化值呢？<br>            这就要学习Java另外一门小技术，构造方法。<br>    * B: 那什么是构造方法呢？<br>             从字面上理解即为构建创造时用的方法，即就是对象创建时要执行的方法。既然是对象创建时要执行的方法，那么只要在new对象时，<br>            知道其执行的构造方法是什么，就可以在执行这个方法的时候给对象进行属性赋值。</p>
<p>###02构造方法作用<br>    * A: 构造方法的作用:<br>            在new的同时给成员变量赋值,给对象属性进行初始化。<br>    * B: 举例:<br>            Perons p = new Person(“张三”,23); 在new 的时候给p对象的name属性和age属性进行赋值,使这个对象的属性有值。</p>
<p>​<br>###03构造方法的定义和运行特点<br>    * A: 构造方法定义<br>            构造方法的格式：<br>            修饰符 构造方法名(参数列表)<br>            {<br>            }</p>
<pre><code>* B: 构造方法的体现：
        构造方法没有返回值类型。也不需要写返回值。因为它是为构建对象的，对象创建完，方法就执行结束。
        构造方法名称必须和类型保持一致。
        构造方法没有具体的返回值。
        构造方法的代码体现：

* C: 构造方法举例
        class Person {
            // Person的成员属性age和name
            private int age;
            private String name;

            // Person的构造方法，拥有参数列表
            Person(int a, String nm) {
                // 接受到创建对象时传递进来的值，将值赋给成员属性
                age = a;
                name = nm;
            }
        }

* D: 构造方法运行特点:
        在new 对象的时候自动调用执行。</code></pre><p>###04默认添加的构造方法<br>    * A: 每一class类都必须有一个构造方法，构造方法不写也有。<br>         编译的时候，javac，系统会自动检查类中是否有构造方法，如果没有编译器就会自动添加一个构造方法<br>         比如Person类， 编译器添加一个无参构造 public Person(){}</p>
<p>###05构造方法的调用赋值<br>    * A: 理解构造方法的格式和基本功能之后，现在就要研究构造方法是怎么执行的呢？在创建对象的时候是如何初始化的呢？<br>         构造方法是专门用来创建对象的，也就是在new对象时要调用构造方法。现在来看看如何调用构造方法。</p>
<pre><code>* B: 案例
        class Person {
            // Person的成员属性age和name
            private int age;
            private String name;

            // Person的构造方法，拥有参数列表
            Person(int a, String nm) {
                // 接受到创建对象时传递进来的值，将值赋给成员属性
                age = a;
                name = nm;
            }

            public void speak() {
                System.out.println(&quot;name=&quot; + name + &quot;,age=&quot; + age);
            }
        }

        class PersonDemo {
            public static void main(String[] args) {
                // 创建Person对象，并明确对象的年龄和姓名
                Person p2 = new Person(23, &quot;张三&quot;);
                p2.speak();
            }
        }

    上述代码演示了创建对象时构造方法的调用。即在创建对象时，会调用与参数列表对应的构造方法</code></pre><p>###06构造方法的内存<br>        A:内存加载的过程<br>            有一个Person类, 创建Person 对象new Person()<br>            1、首先会将main方法压入栈中，执行main方法中的 new Person(23,”张三”);<br>            2、在堆内存中分配一片区域，用来存放创建的Person对象，这片内存区域会有属于自己的内存地址（0x88）。然后给成员变量进行默认初始化（name=null，age=0）。<br>            3、执行构造方法中的代码（age = a ; name = nm;）,将变量a对应的23赋值给age，将变量nm对应的”张三赋值给name，这段代码执行结束后，成员变量age和name的值已经改变。执行结束之后构造方法弹栈，Person对象创建完成。将Person对象的内存地址0x88赋值给p2。</p>
<p>==============================第二节课开始====================================    </p>
<p>###07构造方法的重载<br>    * A：当在描述事物时，要不要在类中写构造方法呢？这时要根据描述事物的特点来确定，当描述的事物在创建其对象时就要明确属性的值，这时就需要在定义类的时候书写带参数的构造方法。<br>    *    若创建对象时不需要明确具体的数据，这时可以不用书写构造方法（不书写也有默认的构造方法）。<br>            构造方法的细节：<br>            1、一个类中可以有多个构造方法，多个构造方法是以重载的形式存在的<br>            2、构造方法是可以被private修饰的，作用：其他程序无法创建该类的对象。<br>    * B: 举例<br>        class Person {<br>            private int age;<br>            private String name;</p>
<pre><code>    // 私有无参数的构造方法，即外界不能通过new Person();语句创建本类对象
    private Person() {
    }

    // 多个构造方法是以重载的形式存在
    Person(int a) {
        age = a;
    }

    Person(String nm, int a) {
        name = nm;
        age = a;
    }
}</code></pre><p>​        </p>
<p>###08构造方法和一般方法区别<br>    * A: 目前为止，学习两种方法，分别为构造方法和一般方法，那么他们之间有什么异同呢？<br>        1.格式不同<br>         构造方法 : 修饰符  类名(参数类型 参数 …){<br>            初始化成员变量<br>        }<br>        一般方法: 需要有返回值类型<br>        2.作用不同<br>        构造方法一般用来给成员变量初始化;<br>        一般方法根据需求而定;<br>        3.调用方式不同<br>        构造方法创建对象时调用, 或者this() super() 语句调用<br>        普通方法需要对象调用或者静态方法直接调用静态方法.<br>        4.执行不同<br>        构造方法在对象创建时就执行了，而且只执行一次。<br>        一般方法是在对象创建后，需要使用时才被对象调用，并可以被多次调用。</p>
<p>​<br>###09this在构造方法之间的调用<br>    * A: 在之前学习方法之间调用时，可以通过方法名进行调用。可是针对构造方法，无法通过构造方法名来相互调用。<br>        构造方法之间的调用，可以通过this关键字来完成。<br>        构造方法调用格式：<br>        this(参数列表);</p>
<pre><code>* B:调用构造方法的案例
    class Person {
        // Person的成员属性
        private int age;
        private String name;

        // 无参数的构造方法
        Person() {
        }

        // 给姓名初始化的构造方法
        Person(String nm) {
            name = nm;
        }

        // 给姓名和年龄初始化的构造方法
        Person(String nm, int a) {
            // 由于已经存在给姓名进行初始化的构造方法 name = nm;因此只需要调用即可
            // 调用其他构造方法，需要通过this关键字来调用
            this(nm);
            // 给年龄初始化
            age = a;
        }
    }</code></pre><p>###10this在构造方法调用的内存图<br>    * A: 被加载的代码<br>        class Person {<br>            private int age;<br>            private String name;</p>
<pre><code>    Person() {
    }
    Person(String nm) {
        name = nm;
    }
    Person(String nm, int a) {
        this(nm);
        age = a;
    }
}

class PersonDemo {
    public static void main(String[] args) {
        Person p = new Person(&quot;张三&quot;, 23);
    }
}</code></pre><p>​<br>    * B: 构造方法调用的原理图<br>    *   图略<br>        1、先执行main方法，main方法压栈，执行其中的new Person(“张三”,23);<br>        2、堆内存中开辟空间，并为其分配内存地址0x33，，紧接着成员变量默认初始化（name=null  age = 0）；<br>        3、拥有两个参数的构造方法（Person（String nm , int a））压栈，在这个构造方法中有一个隐式的this，因为构造方法是给对象初始化的，那个对象调用到这个构造方法，this就指向堆中的那个对象。<br>        4、由于Person（String nm , int a）构造方法中使用了this(nm);构造方法Person(String nm)就会压栈，并将“张三”传递给nm。在Person（String nm , int a）构造方法中同样也有隐式的this，this的值同样也为0x33，这时会执行其中name = nm，即把“张三”赋值给成员的name。当赋值结束后Person（String nm , int a）构造方法弹栈。<br>        5、程序继续执行构造方法（Person（String nm , int a）中的age = a；这时会将23赋值给成员属性age。赋值结束构造方法（Person（String nm , int a）弹栈。<br>        6、当构造方法（Person（String nm , int a）弹栈结束后，Person对象在内存中创建完成，并将0x33赋值给main方法中的p引用变量。<br>        注意：<br>        this到底代表什么呢？this代表的是对象，具体代表哪个对象呢？哪个对象调用了this所在的方法，this就代表哪个对象。<br>        调用其他构造方法的语句必须定义在构造方法的第一行，原因是初始化动作要最先执行。</p>
<p>###11this简易应用<br>    * A: 当在方法中出现了局部变量和成员变量同名的时候，那么在方法中怎么区别局部变量成员变量呢？可以在成员变量名前面加上this.来区别成员变量和局部变量<br>    * B: 举例1<br>        class Person {<br>            private int age;<br>            private String name;</p>
<pre><code>        // 给姓名和年龄初始化的构造方法
        Person(String name, int age) {
            // 当需要访问成员变量是，只需要在成员变量前面加上this.即可
            this.name = name;
            this.age = age;
        }

        public void speak() {
            System.out.println(&quot;name=&quot; + this.name + &quot;,age=&quot; + this.age);
        }
    }

    class PersonDemo {
        public static void main(String[] args) {
            Person p = new Person(&quot;张三&quot;, 23);
            p.speak();
        }
    }

* C: 举例2
    学习完了构造方法、this的用法之后，现在做个小小的练习。
    需求：在Person类中定义功能，判断两个人是否是同龄人
    class Person {
        private int age;
        private String name;

        // 给姓名和年龄初始化的构造方法
        Person(String name, int age) {
            // 当需要访问成员变量是，只需要在成员变量前面加上this.即可
            this.name = name;
            this.age = age;
        }

        public void speak() {
            System.out.println(&quot;name=&quot; + this.name + &quot;,age=&quot; + this.age);
        }

        // 判断是否为同龄人
        public boolean equalsAge(Person p) {
            // 使用当前调用该equalsAge方法对象的age和传递进来p的age进行比较
            // 由于无法确定具体是哪一个对象调用equalsAge方法，这里就可以使用this来代替
            /*
             * if(this.age == p.age) { return true; } return false;
             */
            return this.age = p.age;
        }
    }</code></pre><p>==============================第三节课开始====================================</p>
<p>​<br>###12super关键字_1</p>
<pre><code>* A: 子父类中构造方法的调用
    在创建子类对象时，父类的构造方法会先执行，因为子类中所有构造方法的第一行有默认的隐式super();语句。
* B: 格式：
    调用本类中的构造方法
    this(实参列表);
    调用父类中的空参数构造方法
    super();
    调用父类中的有参数构造方法
    super(实参列表);</code></pre><p>###13super关键字_2<br>    * A:子类构造方法,有一个默认添加的构造方法<br>        public class Student extends Person {<br>             public Student(){<br>                 super();<br>             }<br>        }<br>    * B :为什么子类对象创建都要访问父类中的构造方法？因为子类继承了父类的内容，所以创建对象时，必须要先看父类是如何对其内容进行初始化的，看如下程序<br>        public class Test {<br>            public static void main(String[] args) {<br>                new Zi();<br>            }</p>
<pre><code>}
class Fu{
    int num ;
    Fu(){
        System.out.println(&quot;Fu构造方法&quot;+num);
        num = 4;
    }
}
class Zi extends Fu{
    Zi(){
         //super(); 调用父类空参数构造方法
        System.out.println(&quot;Zi构造方法&quot;+num);
    }
}

执行结果：</code></pre><p>　　     Fu构造方法0<br>　　     Zi构造方法4</p>
<pre><code>通过结果发现，子类构造方法执行时中，调用了父类构造方法，这说明，子类构造方法中有一句super()。
那么，子类中的构造方法为什么会有一句隐式的super()呢？
原因：子类会继承父类中的内容，所以子类在初始化时，必须先到父类中去执行父类的初始化动作。这样，才可以使用父类中的内容。
当父类中没有空参数构造方法时，子类的构造方法必须有显示的super语句，指定要访问的父类有参数构造方法。</code></pre><p>​<br>###14子类父类的内存图<br>        略:<br>        具体见 day12_source/子类父类的内存图.JPG    </p>
<p>###15super关键字_3<br>    * A: 创建子类对象的时候会必须调用父类的构造方法。<br>       子类默认会调用父类的无参构造， 但如果父类没有无参构造，子类的构造方法继续调用父类的无参构造就会报错。<br>       因此子类构造方法的第一行需要调用父类的构造方法，既可以调用父类的无参构造，也可以调用父类的有参构造，这样语法上就不会报错。</p>
<p>###16super关键字_4<br>    * A: 构造方法第一行,写this()还是super()<br>    *  this() 是调用本类的构造方法,super()是调用父类的构造方法, 且两条语句不能同时存在<br>    *  保证子类的所有构造方法调用到父类的构造方法即可</p>
<pre><code>* B: 小结:
* 无论如何,子类的所有构造方法,直接或间接必须调用到父类构造方法;
* 子类的构造方法什么都不写,默认的构造方法第一行super()</code></pre><p>​<br>###17创建子类对象过程的细节<br>    * A 创建子类对象过程的细节<br>    * 如果子类的构造方法第一行写了this调用了本类其他构造方法，那么super调用父类的语句还有吗？<br>    * 这时是没有的，因为this()或者super(),只能定义在构造方法的第一行，因为初始化动作要先执行。<br>    * 父类构造方法中是否有隐式的super呢？<br>    * 也是有的。记住：只要是构造方法默认第一行都是super();<br>    * 父类的父类是谁呢？super调用的到底是谁的构造方法呢？<br>    * Java体系在设计，定义了一个所有对象的父类Object</p>
<pre><code>* 注意：
    类中的构造方法默认第一行都有隐式的super()语句，在访问父类中的空参数构造方法。所以父类的构造方法既可以给自己的对象初始化，也可以给自己的子类对象初始化。
    如果默认的隐式super()语句在父类中没有对应的构造方法，那么必须在构造方法中通过this或者super的形式明确要调用的构造方法。</code></pre><p>==============================第四节课开始====================================</p>
<p>###18super的应用<br>     * A: 练习：描述学生和工人这两个类，将他们的共性name和age抽取出来存放在父类中，并提供相应的get和set方法，同时需要在创建学生和工人对象就必须明确姓名和年龄<br>     * 案例:<br>        //定义Person类，将Student和Worker共性抽取出来<br>        class Person {<br>            private String name;<br>            private int age;<br>            public Person(String name, int age) {<br>                // super();<br>                this.name = name;<br>                this.age = age;<br>            }<br>            public String getName() {<br>                return name;<br>            }<br>            public void setName(String name) {<br>                this.name = name;<br>            }<br>            public int getAge() {<br>                return age;<br>            }<br>            public void setAge(int age) {<br>                this.age = age;<br>            }<br>        }<br>        class Student extends Person {<br>            // Student类的构造方法<br>            Student(String name, int age) {<br>                // 使用super关键字调用父类构造方法，进行相应的初始化动作<br>                super(name, age);<br>            }<br>            public void study() {// Studnet中特有的方法<br>                System.out.println(this.getName() + “同学在学习”);<br>            }<br>        }<br>        class Worker extends Person {<br>            Worker(String name, int age) {<br>                // 使用super关键字调用父类构造方法，进行相应的初始化动作<br>                super(name, age);<br>            }<br>            public void work() {// Worker 中特有的方法<br>                System.out.println(this.getName() + “工人在工作”);<br>            }<br>        }<br>        public class Test {<br>            public static void main(String[] args) {<br>                Student stu = new Student(“小明”,23);<br>        stu.study();</p>
<pre><code>Worker w = new Worker(&quot;小李&quot;,45);
w.work();
    }
}</code></pre><p>###19完整员工案例分析<br>     * A: 项目介绍<br>        某IT公司有多名员工，按照员工负责的工作不同，进行了部门的划分（研发部员工、维护部员工）。研发部根据所需研发的内容不同，又分为JavaEE工程师、Android工程师；维护部根据所需维护的内容不同，又分为网络维护工程师、硬件维护工程师。<br>        公司的每名员工都有他们自己的员工编号、姓名，并要做它们所负责的工作。<br>        工作内容<br>        JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站<br>        Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件<br>        网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通<br>        硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机<br>        请根据描述，完成员工体系中所有类的定义，并指定类之间的继承关系。进行XX工程师类的对象创建，完成工作方法的调用。</p>
<pre><code>* B: 案例分析
    根据上述部门的描述，得出如下的员工体系图

    根据员工信息的描述，确定每个员工都有员工编号、姓名、要进行工作。则，把这些共同的属性与功能抽取到父类中（员工类），关于工作的内容由具体的工程师来进行指定。
    工作内容
    JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站
    Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件
    网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通
    硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机
    创建JavaEE工程师对象，完成工作方法的调用</code></pre><p>###20案例代码实现<br>     * A:定义员工类(抽象类)<br>        public abstract class Employee {<br>            private String id;// 员工编号<br>            private String name; // 员工姓名</p>
<pre><code>    //空参数构造方法
    public Employee() {
        super();
    }
    //有参数构造方法
    public Employee(String id, String name) {
        super();
        this.id = id;
        this.name = name;
    }
    public String getId() {
        return id;
    }
    public void setId(String id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    //工作方法（抽象方法）
    public abstract void work(); 
}

* B :    定义研发部员工类Developer 继承 员工类Employee
public abstract class Developer extends Employee {
    //空参数构造方法
    public Developer() {
        super();
    }
    //有参数构造方法
    public Developer(String id, String name) {
        super(id, name);
    }
}

* C:    定义维护部员工类Maintainer 继承 员工类Employee
public abstract class Maintainer extends Employee {
    //空参数构造方法
    public Maintainer() {
        super();
    }
    //有参数构造方法
    public Maintainer(String id, String name) {
        super(id, name);
    }
}

* D:    定义JavaEE工程师 继承 研发部员工类，重写工作方法
public class JavaEE extends Developer {
    //空参数构造方法
    public JavaEE() {
        super();
    }
    //有参数构造方法
    public JavaEE(String id, String name) {
        super(id, name);
    }

    @Override
    public void work() {
        System.out.println(&quot;员工号为 &quot; + getId() + &quot; 的 &quot; + getName() + &quot; 员工，正在研发淘宝网站&quot;);
    }
}

* E:    定义Android工程师 继承 研发部员工类，重写工作方法
public class Android extends Developer {
    //空参数构造方法
    public Android() {
        super();
    }
    //有参数构造方法
    public Android(String id, String name) {
        super(id, name);
    }

    @Override
    public void work() {
        System.out.println(&quot;员工号为 &quot; + getId() + &quot; 的 &quot; + getName() + &quot; 员工，正在研发淘宝手机客户端软件&quot;);
    }
}

* F:    定义Network网络维护工程师 继承 维护部员工类，重写工作方法
public class Network extends Maintainer {
    //空参数构造方法
    public Network() {
        super();
    }
    //有参数构造方法
    public Network(String id, String name) {
        super(id, name);
    }

    @Override
    public void work() {
        System.out.println(&quot;员工号为 &quot; + getId() + &quot; 的 &quot; + getName() + &quot; 员工，正在检查网络是否畅通&quot;);
    }
}

* G:    定义Hardware硬件维护工程师 继承 维护部员工类，重写工作方法
public class Hardware extends Maintainer {
    //空参数构造方法
    public Hardware() {
        super();
    }
    //有参数构造方法
    public Hardware(String id, String name) {
        super(id, name);
    }

    @Override
    public void work() {
        System.out.println(&quot;员工号为 &quot; + getId() + &quot; 的 &quot; + getName() + &quot; 员工，正在修复打印机&quot;);
    }
}

* H:    在测试类中，创建JavaEE工程师对象，完成工作方法的调用
public class Test {
    public static void main(String[] args) {
        //创建JavaEE工程师员工对象，该员工的编号000015，员工的姓名 小明
        JavaEE ee = new JavaEE(&quot;000015&quot;, &quot;小明&quot;);
        //调用该员工的工作方法
        ee.work();
    }
}</code></pre><p>###21总结<br>    * 把今天的知识点总结一遍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day11%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day11%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记11</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:07:51" itemprop="dateModified" datetime="2020-12-23T23:07:51+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、接口<br>2、多态</p>
<p>第一节课<br>###01(面向对象)接口概述.avi                        (02:33)<br>###02(面向对象)接口抽象方法定义.avi                  (11:47)<br>###03(面向对象)接口的实现类.avi                    (07:44)<br>###04(面向对象)接口中的成员变量的特点.avi          (09:36)<br>###05(面向对象)接口中的成员方法的特点.avi          (03:59)<br>###06(面向对象)实现类还是一个抽象类.avi           (04:20)</p>
<p>第二节课<br>###07(面向对象)类和接口的多实现.avi               (12:38)<br>###08(面向对象)类在继承类的同时实现多接口.avi      (04:07)<br>###09(面向对象)接口的多继承.avi                    (06:07)<br>###10(面向对象)接口思想.avi                        (08:40)<br>###11(面向对象)接口和抽象类的区别.avi             (08:38)</p>
<p>第三节课</p>
<p>###12(面向对象)多态的概述.avi                      (05:22)<br>###13(面向对象)多态调用的三种形式.avi              (09:53)<br>###14(面向对象)多态中成员方法的特点.avi             (07:42)<br>###15(面向对象)instanceof关键字.avi              (13:34)<br>###16(面向对象)多态的向上转型.avi                  (09:33)</p>
<p>第四节课</p>
<p>###17(面向对象)多态的向下转型.avi                 (06:46)<br>###18(面向对象)多态转型的案例.avi                 (10:00)<br>###19(面向对象)笔记本案例功能分析.avi           (04:58)<br>###20(面向对象)笔记本案例代码实现.avi           (15:35)</p>
<p>============上面的内容,方便我们只做ppt,word教案以及书写下面的简要的笔记=================</p>
<p>=======================第一节课开始=============================================</p>
<p>###01接口的概念<br>    * A:接口的概念<br>        接口是功能的集合，同样可看做是一种数据类型，是比抽象类更为抽象的”类”。<br>        接口只描述所应该具备的方法，并没有具体实现，具体的实现由接口的实现类(相当于接口的子类)来完成。这样将功能的定义与实现分离，优化了程序设计。<br>        请记住：一切事物均有功能，即一切事物均有接口。</p>
<p>​<br>###02接口的定义<br>    * A: 接口的定义<br>            与定义类的class不同，接口定义时需要使用interface关键字。<br>            定义接口所在的仍为.java文件，虽然声明时使用的为interface关键字的编译后仍然会产生.class文件。这点可以让我们将接口看做是一种只包含了功能声明的特殊类。</p>
<p>​<br>    * B : 定义格式<br>            public interface 接口名 {<br>                抽象方法1;<br>                抽象方法2;<br>                抽象方法3;<br>            }<br>    * C: 定义步骤<br>            使用interface代替了原来的class，其他步骤与定义类相同：<br>            接口中的方法均为公共访问的抽象方法<br>            接口中无法定义普通的成员变量</p>
<p>​<br>​<br>###03接口的实现类<br>    * A: 类与接口的关系<br>            类与接口的关系为实现关系，即类实现接口。实现的动作类似继承，只是关键字不同，实现使用implements。<br>            其他类(实现类)实现接口后，就相当于声明：”我应该具备这个接口中的功能”。实现类仍然需要重写方法以实现具体的功能。<br>    * B: 类实现接口的格式<br>            class 类 implements 接口 {<br>                重写接口中方法<br>            }<br>    * C:注意事项<br>             在类实现接口后，该类就会将接口中的抽象方法继承过来，此时该类需要重写该抽象方法，完成具体的逻辑。<br>            接口中定义功能，当需要具有该功能时，可以让类实现该接口，只声明了应该具备该方法，是功能的声明。<br>            在具体实现类中重写方法，实现功能，是方法的具体实现。</p>
<p>###04接口中成员变量的特点<br>    * A:成员变量特点<br>         * a 接口中可以定义变量，但是变量必须有固定的修饰符修饰，public static final 所以接口中的变量也称之为常量，其值不能改变。后面我们会讲解static与final关键字</p>
<pre><code>* B:案例
        interface Demo { ///定义一个名称为Demo的接口。
            public static final int NUM = 3;// NUM的值不能改变
        }</code></pre><p>​<br>###05接口中成员方法的特点<br>    * A: 成员方法特点<br>        * a 接口中可以定义方法，方法也有固定的修饰符，public abstract<br>        * b 子类必须覆盖掉接口中所有的抽象方法后，子类才可以实例化。否则子类是一个抽象类。</p>
<pre><code>* B: 案例
        interface Demo { ///定义一个名称为Demo的接口。
            public abstract void show1();
            public abstract void show2();
        }

        //定义子类去覆盖接口中的方法。类与接口之间的关系是 实现。通过 关键字 implements
        class DemoImpl implements Demo { //子类实现Demo接口。
            //重写接口中的方法。
            public void show1(){}
            public void show2(){}
        }</code></pre><p>###06实现类还是一个抽象类<br>    A: 接口的实现类<br>       一个类如果实现类接口,有两种操作方法:<br>       第一:实现类是非抽象类,就需要重写接口中所有的抽象方法.<br>       第二:实现类也声明为抽象类,那么实现类可以不重写接口中的抽象方法。</p>
<p>​<br>==============================第二节课开始====================================    </p>
<p>###07类和接口的多实现<br>    * A：接口的多实现<br>        了解了接口的特点后，那么想想为什么要定义接口，使用抽象类描述也没有问题，接口到底有啥用呢？<br>        接口最重要的体现：解决多继承的弊端。将多继承这种机制在java中通过多实现完成了。</p>
<pre><code>* B 多实现的优点
    * 怎么解决多继承的弊端呢？
    * 弊端：多继承时，当多个父类中有相同功能时，子类调用会产生不确定性。
    * 其实核心原因就是在于多继承父类中功能有主体，而导致调用运行时，不确定运行哪个主体内容。
    * 为什么多实现能解决了呢？
    * 因为接口中的功能都没有方法体，由子类来明确。

* C :案例演示
    interface Fu2{
        void show2();
    }
    class Zi implements Fu1,Fu2 {    // 多实现。同时实现多个接口。
        public void show1(){}
        public void show2(){}
    }</code></pre><p>###08类在继承类的同时实现多接口<br>    * A: 继承的同时实现接口<br>        * 接口和类之间可以通过实现产生关系，同时也学习了类与类之间可以通过继承产生关系。当一个类已经继承了一个父类，它又需要扩展额外的功能，这时接口就派上用场了。<br>        * 子类通过继承父类扩展功能，通过继承扩展的功能都是子类应该具备的基础功能。如果子类想要继续扩展其他类中的功能呢？这时通过实现接口来完成。<br>        * 接口的出现避免了单继承的局限性。父类中定义的事物的基本功能。接口中定义的事物的扩展功能。</p>
<pre><code>* B: 代码演示
    class Fu {
        public void show(){}
    }
    interface Inter {
        pulbic abstract void show1();
    }
    class Zi extends Fu implements Inter {
        public void show1() {
        }
    }

    接口的出现避免了单继承的局限性。父类中定义的事物的基本功能。接口中定义的事物的扩展功能。</code></pre><p>###09接口的多继承<br>    * A: 接口的多继承<br>        * 学习类的时候，知道类与类之间可以通过继承产生关系，接口和类之间可以通过实现产生关系，那么接口与接口之间会有什么关系。<br>        * 多个接口之间可以使用extends进行继承。</p>
<pre><code>* B 代码演示
     interface Fu1{
        void show();
    }
    interface Fu2{
        void show1();
    }
    interface Fu3{
        void show2();
    }
    interface Zi extends Fu1,Fu2,Fu3{
        void show3();
    }

    在开发中如果多个接口中存在相同方法，这时若有个类实现了这些接口，那么就要实现接口中的方法，由于接口中的方法是抽象方法，子类实现后也不会发生调用的不确定性。</code></pre><p>###10接口思想<br>    * A:接口的思想<br>        * 前面学习了接口的代码体现，现在来学习接口的思想，接下里从生活中的例子进行说明。<br>        * 举例：我们都知道电脑上留有很多个插口，而这些插口可以插入相应的设备，这些设备为什么能插在上面呢？<br>        * 主要原因是这些设备在生产的时候符合了这个插口的使用规则，否则将无法插入接口中，更无法使用。发现这个插口的出现让我们使用更多的设备。</p>
<pre><code>* B: 接口的好处    
    * 总结：接口在开发中的它好处
    * 1、接口的出现扩展了功能。
    * 2、接口其实就是暴漏出来的规则。
    * 3、接口的出现降低了耦合性，即设备与设备之间实现了解耦。

    * 接口的出现方便后期使用和维护，一方是在使用接口（如电脑），一方在实现接口（插在插口上的设备）。例如：笔记本使用这个规则（接口），电脑外围设备实现这个规则（接口）。</code></pre><p>###11接口和抽象类的区别<br>    * A: 明白了接口思想和接口的用法后，接口和抽象类的区别是什么呢？接口在生活体现也基本掌握，那在程序中接口是如何体现的呢？<br>        通过实例进行分析和代码演示抽象类和接口的用法。<br>    * B: 举例：<br>        *    犬：<br>                行为：<br>                吼叫；<br>                吃饭；<br>        * 缉毒犬：<br>                行为：<br>                吼叫；<br>                吃饭；<br>                缉毒；</p>
<pre><code>* C:思考：
    * 由于犬分为很多种类，他们吼叫和吃饭的方式不一样，在描述的时候不能具体化，也就是吼叫和吃饭的行为不能明确。
    * 当描述行为时，行为的具体动作不能明确，这时，可以将这个行为写为抽象行为，那么这个类也就是抽象类。
    * 可是当缉毒犬有其他额外功能时，而这个功能并不在这个事物的体系中。这时可以让缉毒犬具备犬科自身特点的同时也有其他额外功能，可以将这个额外功能定义接口中。

* D: 代码演示
    interface 缉毒{
        public abstract void 缉毒();
    }
    //定义犬科的这个提醒的共性功能
    abstract class 犬科{
    public abstract void 吃饭();
    public abstract void 吼叫();
    }
    // 缉毒犬属于犬科一种，让其继承犬科，获取的犬科的特性，
    //由于缉毒犬具有缉毒功能，那么它只要实现缉毒接口即可，这样即保证缉毒犬具备犬科的特性，也拥有了缉毒的功能
    class 缉毒犬 extends 犬科 implements 缉毒{

        public void 缉毒() {
        }
        void 吃饭() {
        }
        void 吼叫() {
        }
    }
    class 缉毒猪 implements 缉毒{
        public void 缉毒() {
        }
    }

* E: 接口和抽象类区别总结
     相同点:
        都位于继承的顶端,用于被其他类实现或继承;
        都不能直接实例化对象;
        都包含抽象方法,其子类都必须覆写这些抽象方法;
    区别:
        抽象类为部分方法提供实现,避免子类重复实现这些方法,提高代码重用性;接口只能包含抽象方法;
        一个类只能继承一个直接父类(可能是抽象类),却可以实现多个接口;(接口弥补了Java的单继承)
        抽象类是这个事物中应该具备的你内容, 继承体系是一种 is..a关系
        接口是这个事物中的额外内容,继承体系是一种 like..a关系

    二者的选用:
        优先选用接口,尽量少用抽象类;
        需要定义子类的行为,又要为子类提供共性功能时才选用抽象类;</code></pre><p>==============================第三节课开始====================================</p>
<p>###12多态概述<br>    * A: 多态概述<br>        多态是继封装、继承之后，面向对象的第三大特性。<br>        现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。<br>        Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。<br>        Java中多态的代码体现在一个子类对象(实现类对象)既可以给这个子类(实现类对象)引用变量赋值，又可以给这个子类(实现类对象)的父类(接口)变量赋值。<br>        如Student类可以为Person类的子类。那么一个Student对象既可以赋值给一个Student类型的引用，也可以赋值给一个Person类型的引用。<br>        最终多态体现为父类引用变量可以指向子类对象。<br>        多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态。<br>        在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。</p>
<p>###13多态调用的三种格式<br>    * A:多态的定义格式：<br>        * 就是父类的引用变量指向子类对象<br>             父类类型  变量名 = new 子类类型();<br>             变量名.方法名();</p>
<pre><code>* B: 普通类多态定义的格式
        父类 变量名 = new 子类();
        举例：    
            class Fu {}
            class Zi extends Fu {}
            //类的多态使用
            Fu f = new Zi();
* C: 抽象类多态定义格式            
        抽象类 变量名 = new 抽象类子类();
        举例：    
        abstract class Fu {
                 public abstract void method();
                 }
        class Zi extends Fu {
        public void method(){
                      System.out.println(“重写父类抽象方法”);
        }
        }
        //类的多态使用
        Fu fu= new Zi();
* D: 接口多态定义的格式
        接口 变量名 = new 接口实现类();
        如： interface Fu {
                     public abstract void method();
        }
        class Zi implements Fu {
                     public void method(){
                      System.out.println(“重写接口抽象方法”);
        }
        }
        //接口的多态使用
        Fu fu = new Zi();
* E: 注意事项
        同一个父类的方法会被不同的子类重写。在调用方法时，调用的为各个子类重写后的方法。
        如 Person p1 = new Student();
           Person p2 = new Teacher();
           p1.work(); //p1会调用Student类中重写的work方法
           p2.work(); //p2会调用Teacher类中重写的work方法
        当变量名指向不同的子类对象时，由于每个子类重写父类方法的内容不同，所以会调用不同的方法。</code></pre><p>###14多态成员方法的特点<br>    * A: 掌握了多态的基本使用后，那么多态出现后类的成员有啥变化呢？前面学习继承时，我们知道子父类之间成员变量有了自己的特定变化，<br>        * 那么当多态出现后，成员变量在使用上有没有变化呢？<br>        * 多态出现后会导致子父类中的成员变量有微弱的变化</p>
<pre><code>* B: 代码演示
    class Fu {
        int num = 4;
    }
    class Zi extends Fu {
        int num = 5;
    }
    class Demo {
        public static void main(String[] args)     {
            Fu f = new Zi();
            System.out.println(f.num);
            Zi z = new Zi();
            System.out.println(z.num);
        }
    }

* C: 多态成员变量
    当子父类中出现同名的成员变量时，多态调用该变量时：
    编译时期：参考的是引用型变量所属的类中是否有被调用的成员变量。没有，编译失败。
    运行时期：也是调用引用型变量所属的类中的成员变量。
    简单记：编译和运行都参考等号的左边。编译运行看左边。

* D: 多态出现后会导致子父类中的成员方法有微弱的变化。看如下代码
    class Fu {
        int num = 4;
        void show()    {
            System.out.println(&quot;Fu show num&quot;);
        }
    }
    class Zi extends Fu {
        int num = 5;
        void show()    {
            System.out.println(&quot;Zi show num&quot;);
        }
    }
    class Demo {
        public static void main(String[] args)     {
            Fu f = new Zi();
            f.show();
        }
    }

* E: 多态成员方法
    编译时期：参考引用变量所属的类，如果没有类中没有调用的方法，编译失败。
    运行时期：参考引用变量所指的对象所属的类，并运行对象所属类中的成员方法。
    简而言之：编译看左边，运行看右边。</code></pre><p>###15instanceof关键字<br>    * A: 作用<br>         可以通过instanceof关键字来判断某个对象是否属于某种数据类型。如学生的对象属于学生类，学生的对象也属于人类</p>
<pre><code>* 格式:
    boolean  b  = 对象  instanceof  数据类型;

* 举例:
    Person p1 = new Student(); // 前提条件，学生类已经继承了人类
    boolean flag = p1 instanceof Student; //flag结果为true
    boolean flag2 = p2 instanceof Teacher; //flag结果为false</code></pre><p>###16多态-向上转型<br>    * A: 多态的转型分为向上转型与向下转型两种：</p>
<pre><code>* B: 向上转型：当有子类对象赋值给一个父类引用时，便是向上转型，多态本身就是向上转型的过程。
    使用格式：
    父类类型  变量名 = new 子类类型();
    如：Person p = new Student();</code></pre><p>​    </p>
<p>==============================第四节课开始====================================</p>
<p>###17多态-向下转型<br>    * A: 向下转型：一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用转为子类引用，这个过程是向下转型。如果是直接创建父类对象，是无法向下转型的！<br>        使用格式：<br>        子类类型 变量名 = (子类类型) 父类类型的变量;<br>        如:Student stu = (Student) p;  //变量p 实际上指向Student对象</p>
<p>###18多态的好处和弊端<br>    * A: 多态的好处和弊端<br>        * 当父类的引用指向子类对象时，就发生了向上转型，即把子类类型对象转成了父类类型。<br>          向上转型的好处是隐藏了子类类型，提高了代码的扩展性。<br>        * 但向上转型也有弊端，只能使用父类共性的内容，而无法使用子类特有功能，功能有限制。</p>
<pre><code>* B: 看如下代码
    //描述动物类，并抽取共性eat方法
    abstract class Animal {
        abstract void eat();
    }

    // 描述狗类，继承动物类，重写eat方法，增加lookHome方法
    class Dog extends Animal {
        void eat() {
            System.out.println(&quot;啃骨头&quot;);
        }

        void lookHome() {
            System.out.println(&quot;看家&quot;);
        }
    }

    // 描述猫类，继承动物类，重写eat方法，增加catchMouse方法
    class Cat extends Animal {
        void eat() {
            System.out.println(&quot;吃鱼&quot;);
        }

        void catchMouse() {
            System.out.println(&quot;抓老鼠&quot;);
        }
    }

    public class Test {
        public static void main(String[] args) {
            Animal a = new Dog(); //多态形式，创建一个狗对象
            a.eat(); // 调用对象中的方法，会执行狗类中的eat方法
            // a.lookHome();//使用Dog类特有的方法，需要向下转型，不能直接使用

            // 为了使用狗类的lookHome方法，需要向下转型
    // 向下转型过程中，可能会发生类型转换的错误，即ClassCastException异常
            // 那么，在转之前需要做健壮性判断 
            if( !a instanceof Dog){ // 判断当前对象是否是Dog类型
                     System.out.println(&quot;类型不匹配，不能转换&quot;); 
                     return; 
            } 
            Dog d = (Dog) a; //向下转型
            d.lookHome();//调用狗类的lookHome方法
        }
    }


* C 多态总结:
    什么时候使用向上转型：
        当不需要面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作，这时就可以使用向上转型。
        如：Animal a = new Dog();
            a.eat();
    什么时候使用向下转型
        当要使用子类特有功能时，就需要使用向下转型。
            如：Dog d = (Dog) a; //向下转型
                d.lookHome();//调用狗类的lookHome方法
            向下转型的好处：可以使用子类特有功能。
            弊端是：需要面对具体的子类对象；在向下转型时容易发生ClassCastException类型转换异常。在转换之前必须做类型判断。
        如：if( !a instanceof Dog){…}</code></pre><p>###19多态举例<br>     * A: 毕老师和毕姥爷的故事<br>     * 案例:<br>      /*<br>        描述毕老师和毕姥爷，<br>        毕老师拥有讲课和看电影功能<br>        毕姥爷拥有讲课和钓鱼功能<br>      */<br>        class 毕姥爷 {<br>            void 讲课() {<br>                System.out.println(“政治”);<br>            }</p>
<pre><code>    void 钓鱼() {
        System.out.println(&quot;钓鱼&quot;);
    }
}

// 毕老师继承了毕姥爷，就有拥有了毕姥爷的讲课和钓鱼的功能，
// 但毕老师和毕姥爷的讲课内容不一样，因此毕老师要覆盖毕姥爷的讲课功能
class 毕老师 extends 毕姥爷 {
    void 讲课() {
        System.out.println(&quot;Java&quot;);
    }

    void 看电影() {
        System.out.println(&quot;看电影&quot;);
    }
}

public class Test {
    public static void main(String[] args) {
        // 多态形式
        毕姥爷 a = new 毕老师(); // 向上转型
        a.讲课(); // 这里表象是毕姥爷，其实真正讲课的仍然是毕老师，因此调用的也是毕老师的讲课功能
        a.钓鱼(); // 这里表象是毕姥爷，但对象其实是毕老师，而毕老师继承了毕姥爷，即毕老师也具有钓鱼功能

        // 当要调用毕老师特有的看电影功能时，就必须进行类型转换
        毕老师 b = (毕老师) a; // 向下转型
        b.看电影();
    }</code></pre><p>###20笔记本电脑案例<br>     * A:案例介绍<br>         * 定义USB接口（具备开启功能、关闭功能），笔记本要使用USB设备，即笔记本在生产时需要预留可以插入USB设备的USB接口，即就是笔记本具备使用USB设备的功能，<br>         * 但具体是什么USB设备，笔记本并不关心，只要符合USB规格的设备都可以。鼠标和键盘要想能在电脑上使用，那么鼠标和键盘也必须遵守USB规范，不然鼠标和键盘的生产出来无法使用<br>        * 进行描述笔记本类，实现笔记本使用USB鼠标、USB键盘<br>            USB接口，包含开启功能、关闭功能<br>            笔记本类，包含运行功能、关机功能、使用USB设备功能<br>            鼠标类，要符合USB接口<br>            键盘类，要符合USB接口</p>
<pre><code>* B: 案例分析
    * 阶段一：
        使用笔记本，笔记本有运行功能，需要笔记本对象来运行这个功能
    * 阶段二：
        想使用一个鼠标，又有一个功能使用鼠标，并多了一个鼠标对象。
    * 阶段三：
        还想使用一个键盘 ，又要多一个功能和一个对象
    * 问题：每多一个功能就需要在笔记本对象中定义一个方法，不爽，程序扩展性极差。
        降低鼠标、键盘等外围设备和笔记本电脑的耦合性。</code></pre><p>###21笔记本电脑案例代码实现<br>     * A: 代码实现<br>        定义鼠标、键盘，笔记本三者之间应该遵守的规则<br>        interface USB {<br>            void open();// 开启功能</p>
<pre><code>    void close();// 关闭功能
}

    鼠标实现USB规则
class Mouse implements USB {
    public void open() {
        System.out.println(&quot;鼠标开启&quot;);
    }

    public void close() {
        System.out.println(&quot;鼠标关闭&quot;);
    }
}

    键盘实现USB规则
class KeyBoard implements USB {
    public void open() {
        System.out.println(&quot;键盘开启&quot;);
    }

    public void close() {
        System.out.println(&quot;键盘关闭&quot;);
    }
}

    定义笔记本
class NoteBook {
    // 笔记本开启运行功能
    public void run() {
        System.out.println(&quot;笔记本运行&quot;);
    }

    // 笔记本使用usb设备，这时当笔记本对象调用这个功能时，必须给其传递一个符合USB规则的USB设备
    public void useUSB(USB usb) {
        // 判断是否有USB设备
        if (usb != null) {
            usb.open();
            usb.close();
        }
    }

    public void shutDown() {
        System.out.println(&quot;笔记本关闭&quot;);
    }
}

public class Test {
    public static void main(String[] args) {
        // 创建笔记本实体对象
        NoteBook nb = new NoteBook();
        // 笔记本开启
        nb.run();

        // 创建鼠标实体对象
        Mouse m = new Mouse();
        // 笔记本使用鼠标
        nb.useUSB(m);

        // 创建键盘实体对象
        KeyBoard kb = new KeyBoard();
        // 笔记本使用键盘
        nb.useUSB(kb);

        // 笔记本关闭
        nb.shutDown();
    }
}</code></pre><p>###22总结<br>    * 把今天的知识点总结一遍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day10%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day10%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记10</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:06:07" itemprop="dateModified" datetime="2020-12-23T23:06:07+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、继承<br>2、抽象类<br>3、综合案例—员工类系列定义</p>
<p>###01继承的概述<br>     *A:继承的概念<br>        *a:继承描述的是事物之间的所属关系，通过继承可以使多种事物之间形成一种关系体系<br>        *b:在Java中，类的继承是指在一个现有类的基础上去构建一个新的类，<br>            构建出来的新类被称作子类，现有类被称作父类<br>      *B:继承关系的子类特点<br>        *a:子类会自动拥有父类所有非private修饰的属性和方法</p>
<p>###02继承的定义格式和使用<br>     <em>A:继承的格式<br>        class 子类 extends 父类 {}<br>     *B:雇员(Employee)与研发部员工(Developer)案例:<br>        *cn.itcast.demo01包下:<br>        *Employee.java:<br>             /</em><br>             * 定义员工类Employee<br>             */<br>            class Employee {<br>                String name; // 定义name属性</p>
<pre><code>        public void work() {// 定义员工的工作方法
            System.out.println(&quot;尽心尽力地工作&quot;);
        }
    }
*Developer.java:
    /*
     * 定义研发部员工类Developer 继承 员工类Employee
     * 继承了父类中所有非private修饰的成员变量
     */
    class Developer extends Employee {
        // 定义一个打印name的方法
        public void printName() {
            System.out.println(&quot;name=&quot; + name);
        }
    }
*测试员工类与研发部员工类:
    /*
      * 定义测试类
     */
    public class Example01 {
        public static void main(String[] args) {
            Developer d = new Developer(); // 创建一个研发部员工类对象
            d.name = &quot;小明&quot;; // 为该员工类的name属性进行赋值
            d.printName(); // 调用该员工的printName()方法
            d.work(); // 调用Developer类继承来的work()方法
        }
    }

*通过子类对象既可以调用自身的非private修饰的成员,也可以调用父类的非private修饰的成员</code></pre><p>###03继承的好处<br>    *A:继承的好处：<br>        *1、继承的出现提高了代码的复用性，提高软件开发效率。<br>        *2、继承的出现让类与类之间产生了关系，提供了多态的前提。</p>
<p>###04继承的注意事项<br>     *A:继承的注意事项<br>         *a:在Java中，类只支持单继承，不允许多继承，也就是说一个类只能有一个直接父类，例如下面这种情况是不合法的。<br>             class A{}<br>             class B{}<br>             class C extends A,B{}  // C类不可以同时继承A类和B类<br>          假如支持多继承例如:<br>             class A{<br>                 int a=3;<br>                public void method(){</p>
<pre><code>            }
         } 
         class B{
             int a=5;
             public void method(){

             }
         }
         class C extends A,B{

         } 
         class Demo{
             public static void main(String[] args){
                 C c=new C();
                 System.out.println(c.a);//到底是调用A的还是B的成员变量??无法确定
                 c.method();//到底是调用A的还是B的成员方法??无法确定
             }    
         }
   
      *b:多个类可以继承一个父类，例如下面这种情况是允许的(就像你爹可以多个儿子,但是这些儿子都只有一个爹)
         class A{}
         class B extends A{}
         class C extends A{}   // 类B和类C都可以继承类A
     
     *c:在Java中，多层继承是可以的，
        即一个类的父类可以再去继承另外的父类，
        例如C类继承自B类，而B类又可以去继承A类，这时，C类也可称作A类的子类。下面这种情况是允许的。
         class A{}
         class B extends A{}   // 类B继承类A，类B是类A的子类
         class C extends B{}   // 类C继承类B，类C是类B的子类，同时也是类A的子类</code></pre><p><br>          *d:在Java中，子类和父类是一种相对概念，<br>            也就是说一个类是某个类父类的同时，也可以是另一个类的子类。<br>            例如上面的这种情况中，B类是A类的子类，同时又是C类的父类。</p>
<p>###05继承的体系.avi 11:00<br>   *A:继承的体系:</p>
<pre><code>                          动物(吃)
                            |
                   -------------------------
                   |                        |
                猫科动物(吃,胎生)      爬行动物(吃,卵生)
                   |                            |
 -------------------------------        -----------------      
 |                             |        |                |
猫(吃,抓老鼠,胎生)   虎(吃,领地,胎生)  蛇(吃,冬眠,卵生)  鳄鱼(吃,潜水,卵生)</code></pre><p>​<br>        *a:动物体系是对每个具体事物共性的抽取,子类的共性抽取形成父类<br>        *b:父类:具有所有子类的共性内容<br>           子类:不但有共性还有自身特有的内容<br>        *c:整个继承体系,越向上越抽象,越向下越具体</p>
<p>###06继承后子类父类成员变量的特点<br>     A:继承后子类父类成员变量的特点<br>       a:子类的对象调用成员变量的时候,子类自己有,使用子类,子类自己没有调用的父类<br>           class Fu{<br>                //Fu中的成员变量。<br>                int num = 5;<br>            }</p>
<pre><code>       class Zi extends Fu{
           //Zi中的成员变量
           int num2 = 6;
           //Zi中的成员方法
           public void show()
           {
               //访问父类中的num
               System.out.println(&quot;Fu num=&quot;+num);
               //访问子类中的num2
               System.out.println(&quot;Zi num2=&quot;+num2);
           }
       }

       class Demo{
           public static void main(String[] args) 
           {
               Zi z = new Zi(); //创建子类对象
               z.show(); //调用子类中的show方法
           }
       }
b:当子父类中出现了同名成员变量
    class Fu{
       //Fu中的成员变量。
       int num = 5;
   }

   class Zi extends Fu{
       //Zi中的成员变量
       int num = 6;
       void show(){   
           //子类的局部变量
           int num=7

           //直接访问,遵循就近查找原则
           System.out.println(num);//7

           //子父类中出现了同名的成员变量时
           //在子类中需要访问父类中非私有成员变量时，需要使用super关键字
           //访问父类中的num
           System.out.println(&quot;Fu num=&quot;+super.num);//5


           //访问子类中的num2
           System.out.println(&quot;Zi num2=&quot;+this.num);//6
       }
   }

   class Demo5 {
       public static void main(String[] args) 
       {
           Zi z = new Zi(); //创建子类对象
           z.show(); //调用子类中的show方法
       }
   }</code></pre><p>###07继承后子类父类成员方法的特性_子类重写父类方法<br>    A:继承后子类父类成员方法的特性<br>      a:子类的对象调用方法的时候,子类自己有,使用子类,子类自己没有调用的父类<br>        class Fu{<br>            public void show(){<br>                System.out.println(“Fu类中的show方法执行”);<br>            }<br>        }<br>        class Zi extends Fu{<br>            public void show2(){<br>                System.out.println(“Zi类中的show2方法执行”);<br>            }<br>        }<br>        public  class Test{<br>            public static void main(String[] args) {<br>                Zi z = new Zi();<br>                z.show(); //子类中没有show方法，但是可以找到父类方法去执行<br>                z.show2();<br>            }<br>        }  </p>
<pre><code>b:为什么要有重写?
    class Fu{
        public void method(){
            //上千行代码
           //Fu类中的方法最先存在,那么如果项目需求变了,该方法
           //功能不能够满足我们的需求,此时我们也不会去改这个方法
           //因为项目中可能有大量的功能已经使用到该方法,如果随意修改可能使调用该方法的功能出现问题
           //所以使用重写方式基于原有功能提供更强的功能
        }   
    }
    class Zi extends Fu{

    }
c:子类中出现与父类一模一样的方法时，会出现覆盖操作，也称为override重写、复写或者覆盖
  class Fu{
       public void show(){
           System.out.println(&quot;Fu show&quot;);
       }
  }

  class Zi extends Fu{
       //子类复写了父类的show方法
       public void show(){
           System.out.println(&quot;Zi show&quot;);
       }
   }
  public  class Test{
       public static void main(String[] args) {
           Zi z = new Zi();
           z.show(); //Zi show 子类有直接使用子类
       }
   }  </code></pre><p>###08方法覆盖的需求<br>    A:方法覆盖的需求<br>        a:案例:比如手机，当描述一个手机时，它具有发短信，打电话，显示来电号码功能，<br>        后期由于手机需要在来电显示功能中增加显示姓名和头像，<br>        这时可以重新定义一个类描述智能手机，并继承原有描述手机的类。<br>        并在新定义的类中覆盖来电显示功能，在其中增加显示姓名和头像功能</p>
<pre><code>b:分析:我们不改装(破坏)原来的手机,而是再买一个新的智能手机,不但有原有的功能,而且还有特有功能
       例:厂商发布新手机都是基于原有手机的升级,不会拿着原有的手机在卖,新产一款 
  1:分析类的构建:
       手机类
        属性(成员变量):无
        行为(成员方法):
           发短信
           打电话
           来电显示:显示来电号码
      智能手机类:
        属性(成员变量):无
        行为(成员方法):
          发短信
          打电话
          来电显示:显示来电号码,显示姓名和头像

      手机类和智能手机类有共性内容:
          发短信
          打电话
          显示来电号码

  2:继承关系分析:
    对于发短信和打电话功能,让智能手机直接沿用(继承)手机的就可以
    但是在智能手机中的来电显示不但实现号码,还显示姓名和头像,同样的都是来电显示功能,智能手机的来电显示比手机的功能更加强大,我们考虑使用重写</code></pre><p>###09方法覆盖的手机案例实现<br>        //手机类<br>        class Phone{<br>            public void sendMessage(){<br>                System.out.println(“发短信”);<br>            }<br>            public void call(){<br>                System.out.println(“打电话”);<br>            }<br>            public void showNum(){<br>                System.out.println(“来电显示号码”);<br>            }<br>        }</p>
<pre><code>//智能手机类
class NewPhone extends Phone{
    //覆盖父类的来电显示号码功能，并增加自己的显示姓名和图片功能
    //从现实生活角度考虑沿用原有的showNum方法名便于用户更快熟悉和接受,而不是再起个新的名字
    //用户还需要花费大量时间慢慢接受

    public void showNum(){
        //调用父类已经存在的功能使用super
        //如果不加super这是调用子类自身的showNum(),自己调用自己,递归
        //方法不断入栈导致内存溢出
        super.showNum();


        //增加自己特有显示姓名和图片功能
        System.out.println(&quot;显示来电姓名&quot;);
        System.out.println(&quot;显示头像&quot;);
    }
}

public class Test {
    public static void main(String[] args) {
        new NewPhone().showNum();//来电显示  显示来电姓名 显示头像
    }
}</code></pre><p>###10方法覆盖的注意事项<br>   A:方法覆盖的注意事项<br>    a:权限:子类方法覆盖父类方法，必须要保证权限大于等于父类权限。<br>      四大权限:public&gt;默认=protected&gt;private</p>
<pre><code>  class Fu{    
       void show(){

       }
       public void method(){

       }
   }
   class Zi() extends Fu{
       public void show(){//编译运行没问题

       }  
       void method(){//编译错误

       }     
   }
b:方法定义:子类方法和要重写的父类的方法:方法的方法名和参数列表都要一样。
  关于方法的返回值:
    如果是基本数据类型,子类的方法和重写的父类的方法返回值类型必须相同
    如果是引用数据类型,子类的方法和重写的父类的方法返回值类型可以相同或者子类方法的返回值类型是父类方法返回值类型的子类
    class Fu{    
       int show(){

       }
       public Fu method(){

       }

       public Fu method2(){

       }

   }
   class Zi() extends Fu{
       public int show(){//返回值为基本类型的重写

       }  
       public Fu method(){//子类的方法和重写的父类的方法返回值类型可以相同

       }     
       public Zi method2(){//子类方法的返回值类型是父类方法返回值类型的子类

       }     
   }
c:重载与重写对比:
   重载:
       权限修饰符(public private 默认):无关
       方法名:重载的两个方法的方法名必须相同
       形参列表:
         形参类型的顺序不同
         形参的个数不同
         形参的类型不同
         三者至少满足一个
       返回值类型:
         重载与返回值类型无关
   重写:
       权限修饰符(public private 默认): 
         子类方法的权限&gt;=父类的方法的权限
       方法名: 
         子类方法和父类方法必须相同
       形参列表: 
          子类方法和父类方法的形参列表必须相同
       返回值类型:
         基本类数据类型:
           必须相同
         引用数据类型:
          子类方法的返回值类型和父类方法的返回值类型相同
          或者
          子类方法的返回值类型是父类方法的返回值类型的 子类</code></pre><p>###11抽象类的产生<br>      A:抽象类的产生<br>        a:分析事物时，发现了共性内容，就出现向上抽取。会有这样一种特殊情况，就是方法功能声明相同，但方法功能主体不同。那么这时也可以抽取，但只抽取方法声明，不抽取方法主体。那么此方法就是一个抽象方法。<br>###12抽象类的定义格式<br>     A:抽象方法定义的格式：<br>       a:public abstract 返回值类型 方法名(参数);<br>         抽象类定义的格式：<br>         abstract class 类名 {</p>
<pre><code>  }
b:抽象类示例代码：
   /*
     *  定义类开发工程师类
     *    EE开发工程师 :  工作
     *    Android开发工程师 : 工作
     *    
     *    根据共性进行抽取,然后形成一个父类Develop
     *    定义方法,工作: 怎么工作,具体干什么呀
     *    
     *    抽象类,不能实例化对象, 不能new的
     *    不能创建对象的原因:  如果真的让你new了, 对象.调用抽象方法,抽象方法没有主体,根本就不能运行
     *    抽象类使用: 定义类继承抽象类,将抽象方法进行重写,创建子类的对象
     */
    public abstract class Develop {
       //定义方法工作方法,但是怎么工作,说不清楚了,讲不明白
        //就不说, 方法没有主体的方法,必须使用关键字abstract修饰
        //抽象的方法,必须存在于抽象的类中,类也必须用abstract修饰
        public abstract void work();
    }</code></pre><p>###13抽象类的使用方式<br>    A:抽象类的使用方式<br>     /*<br>     *  定义类,JavaEE的开发人员<br>     *  继承抽象类Develop,重写抽象的方法<br>     */<br>    public class JavaEE extends Develop{<br>        //重写父类的抽象方法<br>        //去掉abstract修饰符,加上方法主体<br>        public void work(){<br>            System.out.println(“JavaEE工程师在开发B/S 软件”);</p>
<pre><code>    }
}
/*
 *  定义Android类,继承开发人员类
 *  重写抽象方法
 */
public class Android extends Develop{
     public void work(){
         System.out.println(&quot;Android工程师开发手机软件&quot;);
     }
}

/*
 *  测试抽象类
 *    创建他的子类的对象,使用子类的对象调用方法
 */
public class Test {
    public static void main(String[] args) {
         JavaEE ee = new JavaEE();
         ee.work();//&quot;JavaEE工程师在开发B/S 软件&quot;

         Android and = new Android();
         and.work();//&quot;Android工程师开发手机软件&quot;
    }
}</code></pre><p>###14抽象类特点<br>  A:抽象类的特点<br>    a:抽象类和抽象方法都需要被abstract修饰。抽象方法一定要定义在抽象类中。<br>    b:抽象类不可以直接创建对象，原因：调用抽象方法没有意义。<br>    c:只有覆盖了抽象类中所有的抽象方法后，其子类才可以创建对象。否则该子类还是一个抽象类。<br>    之所以继承抽象类，更多的是在思想，是面对共性类型操作会更简单。<br>      abstract class A{<br>          public abstract void func();<br>          public abstract void func2();<br>      }<br>      class A2 extends A{//A2把A中的两个抽象方法都重写掉了<br>                           //A2类不再是抽象类<br>           public void func(){}<br>           public void func2(){}<br>      }</p>
<pre><code>abstract class A3 extends A{//含有抽象方法的类一定是抽象类
     public void func(){

     }
     //public abstract void func2();//func2相当于被继承下来
}</code></pre><p>###15抽象类的设计思想 4:40<br>    A:抽象类的设计思想<br>      a:抽象类的作用:继承的体系抽象类,强制子类重写抽象的方法<br>        抽象员工:<br>          规定一个方法,work工作<br>          EE员工,Android员工 </p>
<pre><code>     Develop类 抽象类
     abstract work();
         |
  -------------
 |             |
EE            Android  //是我开发的一员必须工作
work(){}       work(){}</code></pre><p>###16抽象类的细节<br>   A:抽象类的细节<br>     a:抽象类一定是个父类？<br>        是的，因为不断抽取而来的。<br>     b:抽象类中是否可以不定义抽象方法?<br>       是可以的，那这个抽象类的存在到底有什么意义呢？不让该类创建对象,方法可以直接让子类去使用<br>       (适配器设计模式)<br>        /*<br>         *   抽象类,可以没有抽象方法,可以定义带有方法体的方法<br>         *   让子类继承后,可以直接使用<br>         */<br>        public  abstract class Animal {<br>             public void sleep(){<br>                 System.out.println(“动物睡觉”);<br>             }</p>
<pre><code>   }
   public class Cat extends Animal{

   }     

   public class Test {
       public static void main(String[] args) {
           //Cat c = new Cat();
           new Cat().sleep();//不让该类创建对象,方法可以直接让子类去使用
       }
   }
c:抽象关键字abstract不可以和哪些关键字共存？    </code></pre><p>      1:private：私有的方法子类是无法继承到的，也不存在覆盖，<br>                 而abstract和private一起使用修饰方法，abstract既要子类去实现这个方法,<br>                 而private修饰子类根本无法得到父类这个方法。互相矛盾。 </p>
<pre><code>/*
 *   抽象类,可以没有抽象方法,可以定义带有方法体的方法
 *   让子类继承后,可以直接使用
 */
public  abstract class Animal {

     // private abstract void show();
     //抽象方法,需要子类重写, 如果父类方法是私有的,子类继承不了,也就没有了重写
}</code></pre><p><br>     2:final，暂时不关注，后面学<br>     3:static，暂时不关注，后面学</p>
<p>###17员工案例分析<br>A:员工案例分析:<br>  a:需求描述:<br>        某IT公司有多名员工，按照员工负责的工作不同，进行了部门的划分（研发部员工、维护部员工）。<br>          研发部根据所需研发的内容不同，又分为JavaEE工程师、Android工程师；<br>          维护部根据所需维护的内容不同，又分为网络维护工程师、硬件维护工程师。</p>
<pre><code>公司的每名员工都有他们自己的员工编号、姓名，并要做它们所负责的工作。
    工作内容
    JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站
    Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件
    网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通
    硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机</code></pre><p>  b:继承体系:<br>                        员工<br>                         |<br>       ——————————————–<br>       |                                          |<br>     研发部员工                                 维护部员工<br>       |                                          |</p>
<hr>
<p>   |            |                             |         |<br>JavaEE工程师   Android工程师         网络维护工程师    硬件维护工程师</p>
<p>  c:详细描述:<br>    根据员工信息的描述，确定每个员工都有员工编号、姓名、要进行工作。<br>     则，把这些共同的属性与功能抽取到父类中（员工类），<br>     关于工作的内容由具体的工程师来进行指定。<br>    工作内容<br>        JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站<br>        Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件<br>        网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通<br>        硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机<br>    创建JavaEE工程师对象，完成工作方法的调用</p>
<p>###18员工案例Employee类的编写<br>   A:员工案例Employee类的编写:按照分析的继承体系来逐个实现<br>         /*<br>         *  定义员工类<br>         *    内容,都是所有子类的共性抽取<br>         *      属性: 姓名,工号<br>         *      方法: 工作<br>         */<br>       public abstract class Employee {<br>            private String id;// 员工编号<br>            private String name; // 员工姓名</p>
<pre><code>       public String getId() {
           return id;
       }
       public void setId(String id) {
           this.id = id;
       }
       public String getName() {
           return name;
       }
       public void setName(String name) {
           this.name = name;
       }

       //工作方法（抽象方法）
       public abstract void work(); 
}</code></pre><p>###19员工案例的子类的编写<br>   B:员工案例的子类的编写:<br>     /*<br>     *  定义研发员工类<br>     *    属于员工中的一种, 继承员工类<br>     *    抽象类Develop 给自己的员工定义自己有的属性<br>     */<br>    public abstract class Develop extends Employee{</p>
<pre><code>}

/*
 *  描述JavaEE开发工程师类
 *    工号,姓名 工作方法
 *  其他的员工,也具备这些共性,抽取到父类中,自己就不需要定义了
 *  是研发部员工的一种,继承研发部类
 */
public class JavaEE extends Develop{
    //重写他父类的父类的抽象方法
    public void work(){
        //调用父类的get方法,获取name,id值
        System.out.println(&quot;JavaEE的工程师开发淘宝&quot;+ super.getName()+&quot;..&quot;+super.getId());
    }
}
/*
*定义Android工程师 继承 研发部员工类，重写工作方法
*/
public class Android extends Developer {
  @Override
   public void work() {
    System.out.println(&quot;员工号为 &quot; + getId() + &quot; 的 &quot; + getName() + &quot; 员工，正在研发淘宝手机客户端软件&quot;);
  }
}


/*
 *   定义维护员工类,属于员工中的一种
 *   继承员工类
 *   抽象类Maintainer 给自己的员工定义自己有的属性
 */
public abstract class Maintainer extends Employee{

}

/*
 *  描述的是网络维护工程师
 *  属于维护部的员工,继承维护部类
 */
public class Network extends Maintainer{
    public void work(){
        System.out.println(&quot;网络工程师在检查网络是否畅通&quot;+super.getName()+&quot;...&quot;+super.getId());
    }
}</code></pre><p><br>    /*<br>     *定义Hardware硬件维护工程师 继承 维护部员工类，重写工作方法<br>     */<br>    public class Hardware extends Maintainer {<br>        @Override<br>        public void work() {<br>            System.out.println(“员工号为 “ + getId() + “ 的 “ + getName() + “ 员工，正在修复打印机”);<br>        }<br>    }</p>
<p>###20总结</p>
<ul>
<li>把今天的知识点总结一遍。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day09%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day09%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记9</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:02:15" itemprop="dateModified" datetime="2020-12-23T23:02:15+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、面向对象思想<br>2、类与对象的关系<br>3、局部变量和成员变量的关系<br>4、封装思想<br>5、private,this关键字<br>6、随机点名器</p>
<p>###01面向对象和面向过程的思想<br>    * A: 面向过程与面向对象都是我们编程中，编写程序的一种思维方式<br>        * a: 面向过程的程序设计方式，是遇到一件事时，思考“我该怎么做”，然后一步步实现的过程。<br>        * b: 面向对象的程序设计方式，是遇到一件事时，思考“我该让谁来做”，然后那个“谁”就是对象，他要怎么做这件事是他自己的事，反正最后一群对象合力能把事就好就行了。</p>
<p>###02面向对象的思想的生活案例<br>    * A: 买电脑（组装机）<br>        * a: 面向过程：自己该怎么做<br>        * b: 面向对象：找人帮我们做</p>
<p>​<br>###03面向对象好处<br>    * A: 面向对象好处<br>        * a: 面向对象思维方式是一种更符合人们思考习惯的思想<br>        * b: 面向过程思维方式中更多的体现的是执行者（自己做事情），面向对象中更多的体现是指挥者（指挥对象做事情）。<br>        * c: 面向对象思维方式将复杂的问题简单化。</p>
<p>###04大象装进冰箱的代码案例<br>    * A: 需求：把大象装冰箱里<br>        * a: 面向过程<br>            * 自己打开冰箱门<br>            * 自己将大象装进去<br>            * 自己关闭冰箱门<br>        * b: 面向对象<br>            * 分析发现打开、装、关闭都是冰箱的功能。即冰箱对象具    备如下功能<br>            * 冰箱打开<br>            * 冰箱存储<br>            * 冰箱关闭</p>
<pre><code>* B: 通过伪代码描述大象和冰箱
    * 描述大象：
        class 大象
        {
        }
    * 描述冰箱
        class冰箱
        {
            void 打开(){}
            void 存储(大象){}
            void 关闭(){}
        }</code></pre><p>​<br>    * C: 使用对象：<br>        * 1、创建冰箱的对象<br>            * 冰箱 bx = new 冰箱();<br>        * 2、调用冰箱的功能<br>            * 对象.功能()；<br>            * bx.打开();<br>            * bx.存储(new 大象());<br>            * bx.关闭();<br>    * D：总结：<br>        * 1、先按照名词提炼问题领域中的对象<br>        * 2、对对象进行描述，其实就是在明确对象中应该具备的属性和功能<br>        * 3、通过new的方式就可以创建该事物的具体对象<br>        * 4、通过该对象调用它以后的功能。</p>
<p>###05定义小汽车类<br>    * A: 分析小汽车的属性和功能<br>        * 属性<br>            * 颜色<br>            * 轮胎个数<br>        * 功能<br>            * 运行<br>    * B: 通过伪代码描述小汽车<br>        * 小汽车{<br>            * 颜色<br>            * 轮胎个数<br>            * 运行(){}<br>        * }<br>    * C：通过JAVA代码描述小汽车<br>        * public class Car {<br>            * String color;<br>            * int number;</p>
<pre><code>    * void run() {
        * System.out.println(color + &quot;:&quot; + number);
    * }
* }</code></pre><p>###01测试汽车类<br>    * A: 创见对象的格式<br>        * a: 类名 变量名 = new 类名();<br>    * B: 测试汽车类<br>        public class CarDemo {<br>            public static void main(String[] args) {<br>                /*<br>                 测试：Car类中的run方法。<br>                 */<br>                // 1,创建Car的对象。给对象起个名字。<br>                Car c = new Car();// c是类类型的变量。c指向了一个具体的Car类型的对象。<br>                // 2,通过已有的对象调用该对象的功能。格式：对象.对象成员;<br>                // 3,可以该对象的属性赋值。<br>                c.color = “red”;<br>                c.number = 4;<br>                c.run();<br>            }<br>        }</p>
<p>###02对象的内存图<br>    * 见课后资料：对象的内存图.JPG</p>
<p>###03类和对象的关系<br>    * A: 类和对象的关系<br>        * 类是对某一类事物的抽象描述，而对象用于表示现实中该类事物的个体<br>    * B: 举例<br>        * 可以将玩具模型看作是一个类，将一个个玩具看作对象，从玩具模型和玩具之间的关系便可以看出类与对象之间的关系</p>
<p>###04成员变量和局部变量的区别</p>
<ul>
<li>区别一：定义的位置不同<ul>
<li>定义在类中的变量是成员变量</li>
<li>定义在方法中或者{}语句里面的变量是局部变量</li>
</ul>
</li>
<li>区别二：在内存中的位置不同<ul>
<li>成员变量存储在对内存的对象中</li>
<li>局部变量存储在栈内存的方法中</li>
</ul>
</li>
<li>区别三：声明周期不同<ul>
<li>成员变量随着对象的出现而出现在堆中，随着对象的消失而从堆中消失</li>
<li>局部变量随着方法的运行而出现在栈中，随着方法的弹栈而消失</li>
</ul>
</li>
<li>区别四：初始化不同<ul>
<li>成员变量因为在堆内存中，所有默认的初始化值</li>
<li>局部变量没有默认的初始化值，必须手动的给其赋值才可以使用。</li>
</ul>
</li>
</ul>
<p>###01方法参数是基本数据类型和引用数据类型<br>    * A.基本类型<br>        class Demo<br>        {<br>            public static void main(String[] args)<br>            {<br>                int x = 4;<br>                show(x);<br>                System.out.println(“x=”+x);<br>            }<br>            public static void show(int x)<br>            {<br>                x = 5;</p>
<pre><code>        }
    }     
    基本类型作为参数传递时，其实就是将基本类型变量x空间中的值复制了一份传递给调用的方法show()，当在show()方法中x接受到了复制的值，再在show()方法中对x变量进行操作，这时只会影响到show中的x。当show方法执行完成，弹栈后，程序又回到main方法执行，main方法中的x值还是原来的值。
* B.引用类型
    class Demo 
    {
        int x ;
        public static void main(String[] args) 
        {

            Demo d = new Demo();
            d.x = 5;
            show(d);
            System.out.println(&quot;x=&quot;+d.x);
        }
        public static void show(Demo d)
        {
            d.x = 6;
        }
    }     
    当引用变量作为参数传递时，这时其实是将引用变量空间中的内存地址(引用)复制了一份传递给了show方法的d引用变量。这时会有两个引用同时指向堆中的同一个对象。当执行show方法中的d.x=6时，会根据d所持有的引用找到堆中的对象，并将其x属性的值改为6.show方法弹栈。
    由于是两个引用指向同一个对象，不管是哪一个引用改变了引用的所指向的对象的中的值，其他引用再次使用都是改变后的值。
* C.结论
    * 对于基本类型形式参数改变不会影响到实际参数
    * 对于引用类型形式参数改变会影响到实际参数 </code></pre><p>###02封装的概述<br>    * A.面向对象三大特征<br>        * 封装、继承、多态<br>    * B.封装表现<br>        * 1、方法就是一个最基本封装体<br>        * 2、类其实也是一个封装体<br>    * C.封装的好处<br>        * 1、提高了代码的复用性<br>        * 2、隐藏了实现细节，还要对外提供可以访问的方式。便于调用者的使用。这是核心之一，也可以理解为就是封装的概念<br>        * 3、提高了安全性<br>###03封装的生活中的举例<br>    * A.封装的生活中的举例<br>        机箱：<br>        一台电脑，它是由CPU、主板、显卡、内存、硬盘、电源等部件组长，其实我们将这些部件组装在一起就可以使用电脑了，但是发现这些部件都散落在外面，很容造成不安全因素，于是，使用机箱壳子，把这些部件都装在里面，并在机箱壳上留下一些插口等，若不留插口，大家想想会是什么情况。<br>        总结：机箱其实就是隐藏了办卡设备的细节，对外提供了插口以及开关等访问内部细节的方式。<br>    * B.总结<br>        * 机箱其实就是隐藏了办卡设备的细节，对外提供了插口以及开关等访问内部细节的方式</p>
<p>###04private关键字<br>    * A.private概述<br>        * private可以修饰成员内容包括成员方法和成员变量<br>        * 被private修饰的内容不能在其他类访问<br>    * B.使用步骤<br>        * 1、通过private修饰属性<br>    * C.完整代码<br>        class Person {<br>            private int age;<br>            private String name;</p>
<pre><code>    public void show() {
        System.out.println(&quot;age=&quot; + age + &quot;,name&quot; + name);
    }
}</code></pre><p>###01get和set方法<br>    * A.get和set方法<br>        * 年龄已被私有，错误的值无法赋值，可是正确的值也赋值不了，这样还是不行，那肿么办呢？按照之前所学习的封装的原理，隐藏后，还需要提供访问方式。只要对外提供可以访问的方法，让其他程序访问这些方法。同时在方法中可以对数据进行验证。<br>一般对成员属性的访问动作：赋值(设置 set)，取值(获取 get)，因此对私有的变量访问的方式可以提供对应的 setXxx或者getXxx的方法。<br>        class Person {<br>            // 私有成员变量<br>            private int age;<br>            private String name;</p>
<pre><code>    // 对外提供设置成员变量的方法
    public void setAge(int a) {
        // 由于是设置成员变量的值，这里可以加入数据的验证
        if (a &lt; 0 || a &gt; 130) {
            System.out.println(a + &quot;不符合年龄的数据范围&quot;);
            return;
        }
        age = a; 
    }

    // 对外提供访问成员变量的方法
    public void getAge() {
        return age;
    }
}
* 总结
    * 类中不需要对外提供的内容都私有化，包括属性和方法。</code></pre><p>以后再描述事物，属性都私有化，并提供setXxx getXxx方法对其进行访问<br>        * 注意<br>            * 私有仅仅是封装的体现形式而已<br>###02私有化Person类带get,set<br>    * 标准代码<br>        package cn.itcast.demo05;</p>
<pre><code>    /*
     *   类描述人:
     *     属性: 姓名和年龄
     *     方法: 说话
     *   
     *   私有化所有的属性 (成员变量) ,必须写对应的get/set方法
     *   凡是自定义的类,自定义成员变量,应该私有化,提供get/set
     *   
     *   this关键字:
     *     区分成员变量和局部变量同名情况
     *     方法中,方位成员变量,写this.
     */
    public class Person {
        private String name;
        private int age;

        // set方法,变量name,age赋值
        public void setAge(int age) {
            this.age = age;
        }

        public void setName(String name) {
            this.name = name;
        }

        // get方法,变量name,age获取值
        public int getAge() {
            return age;
        }

        public String getName() {
            return name;
        }

        public void speak() {
            String  name = &quot;哈哈&quot;;
            int age = 16;

            System.out.println(&quot;人在说话  &quot; + this.name + &quot;...&quot; + this.age);
        }
    }
* 标准测试代码
    package cn.itcast.demo05;

    public class PersonTest {
        public static void main(String[] args) {
            Person p = new Person();
            //调用set方法,对成员变量赋值
            p.setAge(18);
            p.setName(&quot;旺财&quot;);
            p.speak();</code></pre><p>​<br>                //调用get方法,获取成员变量的值<br>        //        System.out.println(p.getName());<br>        //        System.out.println(p.getAge());<br>            }<br>        }</p>
<p>###03this关键字_区分成员变量和局部变量的同名<br>    * A.什么时候用<br>        * 当类中存在成员变量和局部变量同名的时候为了区分，就需要使用this关键字<br>    * B.代码<br>        class Person {<br>            private int age;<br>            private String name;</p>
<pre><code>    public void speak() {
        this.name = &quot;小强&quot;;
        this.age = 18;
        System.out.println(&quot;name=&quot; + this.name + &quot;,age=&quot; + this.age);
    }
}

class PersonDemo {
    public static void main(String[] args) {
        Person p = new Person();
        p.speak();
    }
}</code></pre><p>###04this内存图<br>    * A.this内存图<br>        * 见附件：this内存图.jpg</p>
<p>###01this的年龄比较<br>    * A.需求：在Person类中定义功能，判断两个人是否是同龄人<br>    * B.代码<br>        class Person {<br>            private int age;<br>            private String name;</p>
<pre><code>    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void speak() {
        System.out.println(&quot;name=&quot; + this.name + &quot;,age=&quot; + this.age);
    }

    // 判断是否为同龄人
    public boolean equalsAge(Person p) {
        // 使用当前调用该equalsAge方法对象的age和传递进来p的age进行比较
        // 由于无法确定具体是哪一个对象调用equalsAge方法，这里就可以使用this来代替
        /*
         * if(this.age == p.age) { return true; } return false;
         */
        return this.age == p.age;
    }
}</code></pre><p>###02随机点名器案例重构<br>    * A.需求：随机点名器，即在全班同学中随机的找出一名同学，打印这名同学的个人信息<br>        它具备以下3个内容：<br>        存储所有同学姓名<br>        总览全班同学姓名<br>        随机点名其中一人，打印到控制台<br>    * B.代码<br>        import java.util.ArrayList;<br>        import java.util.Random;<br>        import java.util.Scanner;</p>
<pre><code>/**
 * 思路：
 * 第一步：存储全班同学信息
 * 第二步：打印全班同学每一个人的信息
 * 第三部：随机对学生点名，打印学生信息
 */
public class Test {
    public static void main(String[] args) {
        ArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); //1.1创建一个可以存储多个同学名字的容器
         //1.存储全班同学信息
        addStudent(list);
         //2.打印全班同学每一个人的信息（姓名、年龄）
        printStudent(list);
         //3.随机对学生点名，打印学生信息
        randomStudent(list);
    }
    public static void addStudent(ArrayList&lt;Student&gt; list) {
        //键盘输入多个同学名字存储到容器中
        Scanner sc = new Scanner(System.in);
        for (int i = 0; i &lt; 3; i++) {
            //创建学生
            Student s = new Student();
            System.out.println(&quot;存储第&quot;+i+&quot;个学生姓名：&quot;);
            String name = sc.next();
            s.setName(name);
            System.out.println(&quot;存储第&quot;+i+&quot;个学生年龄：&quot;);
            int age = sc.nextInt();
            s.setAge(age);
            //添加学生到集合
            list.add(s);
        }
    }
    /**
     2.打印全班同学每一个人的信息（姓名、年龄）
     */
    public static void printStudent (ArrayList&lt;Student&gt; list) {
        for (int i = 0; i &lt; list.size(); i++) {
            Student s = list.get(i);
            System.out.println(&quot;姓名：&quot;+s.getName() +&quot;,年龄：&quot;+s.getAge());
        }
    }
    /**
     3.随机对学生点名，打印学生信息
     */
    public static void randomStudent (ArrayList&lt;Student&gt; list) {
        //在班级总人数范围内，随机产生一个随机数
        int index = new Random().nextInt(list.size());
        //在容器（ArrayList集合）中，查找该随机数所对应的同学信息（姓名、年龄）
        Student s = list.get(index);
        System.out.println(&quot;被随机点名的同学：&quot;+s.getName() + &quot;，年龄:&quot; + s.getAge());
    }
}

/**
 * 学生信息类
 */
public class Student {
    private String name; // 姓名
    private int age; // 年龄

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}    </code></pre><p>​        </p>
<p>###03总结</p>
<ul>
<li><p>A.类与对象</p>
<ul>
<li>类，用于描述多个对象的共同特征，它是对象的模板。</li>
<li>对象，用于描述现实中的个体，它是类的实例。</li>
<li>类的定义：使用关键字class来定义java中的类</li>
<li>格式：</li>
<li>class 类名 {</li>
<li>//属性</li>
<li>数据类型 变量名;</li>
<li>…</li>
<li>//方法</li>
<li>修饰符 返回值类型 方法名(参数){   }</li>
<li>…</li>
<li>}</li>
<li></li>
</ul>
</li>
<li><p>B.创建对象：</p>
<ul>
<li>格式：</li>
<li>类名 对象名 = new 类名();</li>
</ul>
</li>
<li><p>C.封装（private关键字）</p>
<ul>
<li>封装，把对象的属性与方法的实现细节隐藏，仅对外提供一些公共的访问方式</li>
<li>封装的体现：</li>
<li>变量:使用 private 修饰，这就是变量的封装</li>
<li>方法:也是一种封装，封装了多条代码</li>
<li>类： 也是一种封装，封装了多个方法</li>
</ul>
</li>
<li><p>D.private关键字，私有的意思</p>
<ul>
<li>它可以用来修饰类中的成员(成员变量，成员方法)</li>
<li>private的特点：</li>
<li>private修饰的成员只能在当前类中访问，其他类中无法直接访问</li>
</ul>
</li>
<li><p>E.this关键字</p>
<ul>
<li>this关键字，本类对象的引用</li>
<li>this是在方法中使用的，哪个对象调用了该方法，那么，this就代表调用该方法的对象引用</li>
<li>this什么时候存在的？当创建对象的时候，this存在的</li>
<li>this的作用：用来区别同名的成员变量与局部变量（this.成员变量）</li>
<li>public void setName(String name) {</li>
<li>this.name = name;</li>
<li>}</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day08%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day08%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记8</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:02:03" itemprop="dateModified" datetime="2020-12-23T23:02:03+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、Eclipse开发工具<br>2、超市库存管理系统</p>
<p>###01Eclipse的下载安装<br>    * A: Eclipse的下载安装        <br>        * a: 下载<br>            * <a href="http://www.eclipse.org" target="_blank" rel="noopener">http://www.eclipse.org</a><br>        * b: 安装<br>            * 只需要解压后就能使用<br>        * c: 卸载<br>            * 只需要将文件夹删除就可以了<br>        * d: 注意<br>            * 开发软件的安装目录中，尽量不要出现空格与中文<br>    * B: Eclipse的特点<br>        * a: 免费<br>        * b: 纯Java语言编写<br>        * c: 免安装<br>        * d: 扩展性强</p>
<p>###02Eclipse的工作空间和新建工程<br>    * A: Eclipse的工作空间和新建工程<br>        * a: 工作空间<br>            *  其实就是我们写的源代码所在的目录<br>        * b: 创建工程(项目)<br>            * 右键/Package Explore 空白区/new /Java Project/输入项目名称如day08/<br>        * c: 创建包(后面讲包的概念)<br>            *　打开上面建立的day08项目/右键/new/package/在弹出的对话框的name中输入报名如”com.itheima.tests”/finish<br>        * d: 创建类<br>            * 创建一个java类:右击包名/new/class/在对话框的name中输入类名/finish<br>    * B: 编译与执行<br>        * a: 编译<br>            * 自动编译，当java代码保存的时候，自动 编译class文件<br>        * b: 运行<br>            * 方式1：点击菜单工具栏中的 绿色带有三角形的 run按钮 运行<br>            * 方式2：点击菜单栏中Run， 点击Run 运行  快捷键是 ctrl+F11<br>            * 方式3：选中要运行的java文件，或者在编写代码的空白区域，右键选择 Run As –&gt; 运行java程序</p>
<p>​<br>###03Eclipse的HelloWorld编写<br>    * A:HelloWorld编写<br>        * a: 编写过程(参照上个知识点)<br>            * 建立day08项目<br>            * 建立包结构(包的概念还没有学到,不建立包的话,使用默认包结构default)<br>            * 创建HelloWorld类(自动生成main方法)<br>        * b: 案例代码<br>            public class HelloWorld {<br>                public static void main(String[] args) {<br>                    System.out.println(“Hello World”);<br>                }<br>            }</p>
<p>​    </p>
<p>###04Eclipse的字体设置<br>    * A: Eclipse的字体设置<br>        * a: 修改编译环境和运行环境<br>            * 编译环境：Window – Preferences – Java - Compiler<br>            * 运行环境：Window – Preferences – Java - Installed JREs</p>
<pre><code>* b: 显示行号与隐藏行号
    * 显示：在代码区域的左边空白区域，右键 -- Show Line Numbers
    * 隐藏：将上面的操作再做一遍

* c: 更改字体大小与颜色
    * Java代码区域的字体大小和颜色：
        * window -- Preferences -- General -- Appearance -- Colors And Fonts --Java修改 -- Java Edit Text Font--edit进行修改
    * 控制台
        * window -- Preferences -- General -- Appearance -- Colors And Fonts -- Debug -- Console font
    * 其他文件
        * window -- Preferences -- General -- Appearance -- Colors And Fonts -- Basic -- Text Font</code></pre><p>###05Eclipse的窗口设置<br>    * A: 窗口设置<br>        * a: 显示的窗口乱了，还原默认显示模式<br>            * Window – Perspective – Reset Prespective<br>        * b: 显示控制台<br>            * Window–Show View—Console        </p>
<p>###06Eclipse的去掉多余的注释<br>    * A: Eclipse的去掉多余的注释<br>        * a:如何去掉默认注释<br>            * Window – Preferences – Java – Code Style – Code Templates – Comments – Methods，点击Edit ，将注释部分删除 (不建议删除)<br>            * Window – Preferences – Java – Code Style – Code Templates – Code – Method body，点击Edit ，将注释部分删除<br>        * b: 切换工作空间<br>            * File – Switch Workspace – 指定工作空间 – ok</p>
<p>###07Eclipse的快捷键<br>    * A: Eclipse的快捷键<br>        * a: 内容辅助键  Alt+/<br>            * 自动补齐main方法  main 然后 Alt+/<br>            * 自动补齐输出语句  syso 然后 Alt+/<br>        * b: 格式化代码<br>            * Ctrl+Shift+f<br>            * 代码区域右键 – Source – Format<br>        * c: 自动导包<br>            * Ctrl+Shift+o<br>            * 如果当前类在多个包中都存在，这时候，使用Ctrl+shift+o,进行选择一个包导入即可。<br>        * d: 注释<br>            * 单行注释<br>                * 加注释： 先选中需要注释的内容，然后 Ctrl+/<br>                * 取消注释：先选中需要取消注释的内容， 然后 Ctrl+/<br>            * 多行注释<br>                * 加注释： 先选中需要注释的内容，然后 Ctrl+Shift+/<br>                * 取消注释：先选中需要取消注释的内容， 然后 Ctrl+Shift+<br>        * e: 补充<br>            * 代码上下移动<br>                * 选中代码alt+上/下箭头<br>            * 查看源码<br>                * 选中类名(F3或者Ctrl+鼠标点击)<br>            * 查找具体的类<br>                * ctrl + shift + t，输入要查找的类的名称–&gt;确定<br>            * 查找具体类的具体方法<br>                * ctrl + o<br>            * 给建议<br>                * ctrl+1,根据右边生成左边的数据类型,生成方法<br>            * 删除代码<br>                * ctrl + d<br>            * 抽取方法<br>                * alt + shift + m<br>            * 改名<br>                * alt + shift + r（类名，方法名，变量名）</p>
<p>###08Eclipse的断点调试<br>    * A:断点调试(又称为Debug调试)的作用<br>        * 调试程序<br>        * 查看程序执行流程<br>    * B:如何查看程序执行流程<br>        * 什么是断点：<br>            * 就是一个标记，从哪里开始。</p>
<pre><code>* 如何设置断点：
    * 你想看哪里的程序，你就在那个有效程序的左边双击即可。

* 在哪里设置断点：
    * 哪里不会点哪里。
    * 目前：我们就在每个方法的第一条有效语句上都加。

* 如何运行设置断点后的程序：
    * 右键 -- Debug as -- Java Application

* 看哪些地方：
    * Debug：断点测试的地方
        * 在这个地方，记住F6，或者点击也可以。一次看一行的执行过程。
    * Variables：查看程序的变量变化
    * ForDemo：被查看的源文件
    * Console：控制台

* 如何去断点：
    * a:再次双击即可
    * b:找到Debug视图，Variables界面，找到Breakpoints，并点击，然后看到所有的断点，最后点击那个双叉        </code></pre><p>###09Eclipse的工程删除和导入<br>    * A:删除项目<br>        * 选中项目 – 右键 – 删除<br>            * 从项目区域中删除<br>            * 从硬盘上删除<br>    * B:导入项目<br>        * 在项目区域右键找到import<br>        * 找到General，展开，并找到<br>        * Existing Projects into Workspace<br>        * 点击next,然后选择你要导入的项目<br>        * 注意：这里选择的是项目名称</p>
<p>###10超市管理系统功能介绍<br>    * A：超市管理系统功能介绍<br>        * a: 显示主菜单</p>
<pre><code>    ============欢迎光临ItCast超市============
    1: 货物 清单   2: 添加货物   3: 删除货物   4: 修改货物  5: 退出
    请您输入要操作的功能序号

* b: 货物清单

    输入1:货物清单
    ================商品库存清单================
    商品编号         商品名称                商品单价
    9527               少林寺酥饼核桃               12.7
    9008               尚康杂粮牡丹饼              5.6
    9879               新疆原产哈密瓜             599.6

* c: 添加新货物

    输入2:添加新货物    

    请输入新商品的编号:9523
    请输入新商品的名字:斯柯达苹果醋
    请输入新商品的单价:19.9
    商品添加成功

* d: 删除货物

    输入3:删除货物

    选择的是删除功能
    请输入商品的编号:9523
    货物信息删除完毕

* e: 修改货物

    输入4:修改货物

    选择的是修改功能
    请输入您要修改的商品的编号:9527
    输入新的商品编号:100
    输入新的商品名字:味道好凤梨干
    输入新的商品价格:6.5
    商品修改成功
* f: 输入5:退出系统</code></pre><p>###11超市管理系统案例分析<br>    * A: 超市管理系统案例分析<br>        * 完成超市商品初始化。创建商品，将商品添加到集合<br>        * 显示来到超市能做的操作，也就是显示主菜单<br>        * 根据接收到的功能选项，执行对应的功能<br>        * 库存货物查询<br>        * 添加新货物<br>        * 删除货物<br>        * 修改货物<br>        * 退出系统,结束main方法的运行<br>        * 循环，回到 2.显示主菜单</p>
<p>​<br>###12自定义商品类<br>    * A: 自定义商品类<br>        * a: 目的<br>            * 每种库存商品都拥有多项商品信息，为了方便管理每种商品的信息，我们对商品信息进行封装，编写FruitItem.java文件<br>        * b：案例代码<br>            public class FruitItem {<br>                int  ID;            //商品编号<br>                String  name;        //商品名称<br>                double  price;        //商品单价<br>                double  number;        //商品数量<br>                double  money;        //商品金额<br>            }<br>        * 补充<br>            * 上述代码中，对商品信息（编号、名称、单价、数量、金额）进行了封装。这样做的好处在于以后只要找到这个商品，就能够知道该商品的每项信息了。</p>
<p>###13初始化商品属性<br>    * A: 初始化商品属性<br>        * a: 案例代码<br>            import java.util.ArrayList;<br>            import java.util.Scanner;</p>
<pre><code>/*
 *   超市管理系统主
 *   实现:
 *     1. 商品数据的初始化
 *     2. 用户的菜单选择
 *     3. 根据选择执行不同的功能
 *       3.1 Read    查看商品
 *       3.2 Create  添加商品
 *       3.3 Delete  删除商品
 *       3.4 Update  修改商品
 *       
 *       
 *   所有功能 ,必须定义方法实现
 *   主方法main  调用作用
 */
public class Shopp {

    public static void main(String[] args) {
        //创建ArrayList集合,存储商品类型,存储数据类型FruitItem类型
        ArrayList&lt;FruitItem&gt; array = new ArrayList&lt;FruitItem&gt;();
        //调用商品初始化方法,传递集合
        init(array);

        }
    }    
    /*
     * 定义方法,实现商品数据的初始化
     * 先将一部分数据,存储集合中
     * 返回值: 无
     * 参数 : 集合
     * 方法名: init
     */
    public static void init(ArrayList&lt;FruitItem&gt; array){
        //创建出多个FruitItem类型,并且属性赋值
        FruitItem f1 = new FruitItem();
        f1.ID = 9527;
        f1.name = &quot;少林寺酥饼核桃&quot;;
        f1.price = 12.7;

        FruitItem f2 = new FruitItem();
        f2.ID = 9008;
        f2.name = &quot;尚康杂粮牡丹饼&quot;;
        f2.price = 5.6;

        FruitItem f3 = new FruitItem();
        f3.ID = 9879;
        f3.name = &quot;新疆原产哈密瓜&quot;;
        f3.price = 599.6;

        //创建的3个FruitItem类型变量,存储到集合中
        array.add(f1);
        array.add(f2);
        array.add(f3);
    }

}</code></pre><p>###14主菜单功能<br>    * A: 主菜单功能<br>        * a: 案例代码</p>
<pre><code>import java.util.ArrayList;
import java.util.Scanner;
/*
 *   超市管理系统主
 *   实现:
 *     1. 商品数据的初始化
 *     2. 用户的菜单选择
 *     3. 根据选择执行不同的功能
 *       3.1 Read    查看商品
 *       3.2 Create  添加商品
 *       3.3 Delete  删除商品
 *       3.4 Update  修改商品
 *       
 *       
 *   所有功能 ,必须定义方法实现
 *   主方法main  调用作用
 */
public class Shopp {

    public static void main(String[] args) {
        //创建ArrayList集合,存储商品类型,存储数据类型FruitItem类型
        ArrayList&lt;FruitItem&gt; array = new ArrayList&lt;FruitItem&gt;();
        //调用商品初始化方法,传递集合
        init(array);
        while(true){
            //调用菜单方法
            mainMenu();            
        }
    }    
    /*
     * 定义方法,实现主菜单
     * 提示用户哪些选择 让选择序号
     * 返回值: 无
     * 参数: 无
     */
    public static void mainMenu(){
        System.out.println();
        System.out.println(&quot;============欢迎光临ItCast超市============&quot;);
        System.out.println(&quot;1: 货物 清单   2: 添加货物   3: 删除货物   4: 修改货物  5: 退出&quot;);
        System.out.println(&quot;请您输入要操作的功能序号&quot;);
    }

    /*
     * 定义方法,实现商品数据的初始化
     * 先将一部分数据,存储集合中
     * 返回值: 无
     * 参数 : 集合
     * 方法名: init
     */
    public static void init(ArrayList&lt;FruitItem&gt; array){
        //创建出多个FruitItem类型,并且属性赋值
        FruitItem f1 = new FruitItem();
        f1.ID = 9527;
        f1.name = &quot;少林寺酥饼核桃&quot;;
        f1.price = 12.7;

        FruitItem f2 = new FruitItem();
        f2.ID = 9008;
        f2.name = &quot;尚康杂粮牡丹饼&quot;;
        f2.price = 5.6;

        FruitItem f3 = new FruitItem();
        f3.ID = 9879;
        f3.name = &quot;新疆原产哈密瓜&quot;;
        f3.price = 599.6;

        //创建的3个FruitItem类型变量,存储到集合中
        array.add(f1);
        array.add(f2);
        array.add(f3);
    }

}                </code></pre><p>###15用户选择功能<br>    * A: 用户选择功能<br>        * a: 案例代码<br>            import java.util.ArrayList;<br>            import java.util.Scanner;</p>
<pre><code>/*
 *   超市管理系统主
 *   实现:
 *     1. 商品数据的初始化
 *     2. 用户的菜单选择
 *     3. 根据选择执行不同的功能
 *       3.1 Read    查看商品
 *       3.2 Create  添加商品
 *       3.3 Delete  删除商品
 *       3.4 Update  修改商品
 *       
 *       
 *   所有功能 ,必须定义方法实现
 *   主方法main  调用作用
 */
public class Shopp {

    public static void main(String[] args) {
        //创建ArrayList集合,存储商品类型,存储数据类型FruitItem类型
        ArrayList&lt;FruitItem&gt; array = new ArrayList&lt;FruitItem&gt;();
        //调用商品初始化方法,传递集合
        init(array);
        while(true){
            //调用菜单方法
            mainMenu();
            //调用用户选择序号方法
            int choose = chooseFunction();
            switch (choose) {
            case 1:
                //调用1: 货物 清单
                showFruitList(array);
            break;

            case 2:
                //2: 添加货物
                addFruit(array);
            break;

            case 3:
                //3: 删除货物
                deleteFruit(array);
            break;

            case 4:
                //4: 修改货物
                updateFruit(array);
            break;

            case 5:
                return ;

            default:
                System.out.println(&quot;输入的序号没有&quot;);
                break;
            }
        }
    }    
    /*
     *  定义方法,实现接受用户的键盘输入
     *  返回编号
     */
    public static int chooseFunction(){
        Scanner sc = new Scanner(System.in);
        return sc.nextInt();
    }

    /*
     * 定义方法,实现主菜单
     * 提示用户哪些选择 让选择序号
     * 返回值: 无
     * 参数: 无
     */
    public static void mainMenu(){
        System.out.println();
        System.out.println(&quot;============欢迎光临ItCast超市============&quot;);
        System.out.println(&quot;1: 货物 清单   2: 添加货物   3: 删除货物   4: 修改货物  5: 退出&quot;);
        System.out.println(&quot;请您输入要操作的功能序号&quot;);
    }

    /*
     * 定义方法,实现商品数据的初始化
     * 先将一部分数据,存储集合中
     * 返回值: 无
     * 参数 : 集合
     * 方法名: init
     */
    public static void init(ArrayList&lt;FruitItem&gt; array){
        //创建出多个FruitItem类型,并且属性赋值
        FruitItem f1 = new FruitItem();
        f1.ID = 9527;
        f1.name = &quot;少林寺酥饼核桃&quot;;
        f1.price = 12.7;

        FruitItem f2 = new FruitItem();
        f2.ID = 9008;
        f2.name = &quot;尚康杂粮牡丹饼&quot;;
        f2.price = 5.6;

        FruitItem f3 = new FruitItem();
        f3.ID = 9879;
        f3.name = &quot;新疆原产哈密瓜&quot;;
        f3.price = 599.6;

        //创建的3个FruitItem类型变量,存储到集合中
        array.add(f1);
        array.add(f2);
        array.add(f3);
    }

}</code></pre><p>###16商品的清单功能<br>    * A: 商品的清单功能<br>        * a: 案例代码(显示商品清单的showFruitList(ArrayList<FruitItem>)方法的代码如下)<br>            /*<br>             *  定义方法,实现显示货物清单功能<br>             *  返回值: 无<br>             *  参数: 集合<br>             *  遍历集合,获取集合中的每个FruitItem变量,变量,调用属性<br>             <em>/<br>            public static void showFruitList(ArrayList<FruitItem> array){<br>                System.out.println();<br>                System.out.println(“================商品库存清单================”);<br>                System.out.println(“商品编号         商品名称                商品单价”);<br>                //遍历集合<br>                for(int i = 0 ; i &lt; array.size(); i++){<br>                    //集合get方法,获取出每个FruitItem变量,可以使用FruitItem接受get结果<br>                    FruitItem item = array.get(i);<br>                    //变量item调用类中属性<br>                    System.out.println(item.ID+”   “+item.name+”        “+item.price);<br>                }<br>            }<br>###17商品的添加功能<br>    * A: 商品的添加功能<br>        * a: 案例代码(商品添加功能的addFruit(ArrayList<FruitItem>)方法的代码如下)<br>            /</FruitItem></FruitItem></em><br>             * 定义方法,实现商品的添加功能<br>             * 返回值:无<br>             * 参数: 集合<br>             * 提示用户选择的是添加商品的功能<br>             *<br>             * 提示用户输入的是什么<br>             *<br>             * 创建FruitItem变量,变量调用的属性<br>             * 将输入的每个商品属性进行赋值<br>             <em>/<br>            public static void addFruit(ArrayList<FruitItem> array){<br>                System.out.println(“选择的是添加商品功能”);<br>                //创建Scanner变量<br>                Scanner sc = new Scanner(System.in);<br>                System.out.print(“请输入新商品的编号:”);<br>                //输入商品的编号<br>                int ID = sc.nextInt();<br>                //输入商品的名字<br>                System.out.print(“请输入新商品的名字:”);<br>                String name = sc.next();<br>                //输入商品的单价<br>                System.out.print(“请输入新商品的单价:”);<br>                double price = sc.nextDouble();<br>                //创建FruitItem变量<br>                FruitItem item = new FruitItem();<br>                //item.属性赋值<br>                item.ID = ID;<br>                item.name = name;<br>                item.price = price;<br>                array.add(item);<br>                System.out.println(“商品添加成功”);<br>            }<br>###18商品的删除功能<br>    * A: 商品的删除功能(删除商品deleteFruit(ArrayList<FruitItem>)方法的代码如下)<br>        * a: 案例代码<br>            /</FruitItem></FruitItem></em><br>             *  定义方法,实现商品的删除功能<br>             *  返回值:　无<br>             *  参数：　集合<br>             *<br>             *  删除依靠的是商品的编号<br>             *  提示用户选择的是删除功能<br>             *  键盘输入商品的编号<br>             *  遍历集合，获取集合中的每个FruitItem变量<br>             *  变量调用属性　ID， 和用户的输入的编号,对比,相同就删除<br>             */<br>            public static void deleteFruit(ArrayList<FruitItem> array){<br>                System.out.println(“选择的是删除功能”);<br>                System.out.print(“请输入商品的编号:”);<br>                Scanner sc = new Scanner(System.in);</FruitItem></FruitItem></p>
<pre><code>    int ID = sc.nextInt();
    //遍历集合
    for(int i = 0 ; i &lt; array.size(); i++){
        //获取到每个FruitItem变量
        FruitItem item = array.get(i);
        //变量,调用属性ID,和用户输入的编号比较
        if( item.ID == ID){
            //移除集合中的元素
            //集合的方法remove实现
            array.remove(i);
            System.out.println(&quot;删除成功&quot;);
            return;
        }
    }
    System.out.println(&quot;你输入的编号不存在&quot;);
}</code></pre><p>###19商品的修改功能<br>    * A: 商品的修改功能<br>        * a: 案例代码(修改商品updateFruit(ArrayList<FruitItem>)方法的代码如下)<br>            /*<br>             *  定义方法,实现商品的修改功能<br>             *  返回值:　无<br>             *  参数：　集合<br>             *<br>             *  提示用户选择的是修改功能<br>             *  提示用户输入需要修改的商品编号<br>             *  遍历集合,获取每个FruitItem变量<br>             *  变量调用ID属性,属性和用户输入的编号比较<br>             *  如果相同:<br>             *    修改调FruitItem中的属性值<br>             *    键盘输入<br>             */<br>            public static void updateFruit(ArrayList<FruitItem> array){<br>                System.out.println(“选择的是修改功能”);<br>                System.out.print(“请输入您要修改的商品的编号:”);</FruitItem></FruitItem></p>
<pre><code>    Scanner sc = new Scanner(System.in);
    int ID = sc.nextInt();
    //遍历集合,获取每个FruitItem变量
    for(int i = 0 ; i &lt; array.size(); i++){
        FruitItem item = array.get(i);
        //获取FruitItem的属性ID,和用户输入的ID比较
        if(item.ID == ID){
            System.out.print(&quot;输入新的商品编号:&quot;);
            item.ID = sc.nextInt();

            System.out.print(&quot;输入新的商品名字:&quot;);
            item.name = sc.next();

            System.out.print(&quot;输入新的商品价格:&quot;);
            item.price = sc.nextDouble();
            System.out.println(&quot;商品修改成功&quot;);
            return ;
        }
    }
    System.out.println(&quot;输入的编号不存在&quot;);
}</code></pre><p>###20总结</p>
<ul>
<li>把今天的知识点总结一遍。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day07%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day07%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记7</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:01:48" itemprop="dateModified" datetime="2020-12-23T23:01:48+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、循环练习<br>2、数组方法练习</p>
<p>###01奇数求和练习<br>    * A: 奇数求和练习<br>        * a: 题目分析<br>            * 为了记录累加和的值，我们需要定义一个存储累加和的变量<br>            * 我们要获取到1-100范围内的数<br>            * 判断当前数是否为奇数，是奇数，完成累加和操作<br>            * 累加完毕后，最终显示下累加和的值</p>
<pre><code>* b: 解题步骤
    * 定义一个用来记录累加和的变量
    * 使用for循环语句，完成1-100之间每个数的获取
    * 使用if条件语句，判断当前数是否是奇数，是奇数，进行累加和操作
    * 使用输出语句，打印累加和变量的值

* c: 案例代码
    public class Test01 {
        public static void main(String[] args) {
            int sum = 0;
            for (int i = 0; i &lt; 100; i++) {
                if (i%2==1) {
                    sum += i;
                }
            }
            System.out.println(&quot;累加和的值 &quot; + sum);
        }
    }</code></pre><p>###02水仙花练习功能实现<br>    * A: 水仙花练习功能实现<br>        * a: 题目分析<br>            * 明确什么样的数就是水仙花数。水仙花数是指一个3位数（100-999之间），其每位数字立方之和等于该3位数本身。<br>                如153 = 1<em>1</em>1 + 3<em>3</em>3 + 5<em>5</em>5，即 3位数本身 = 百位数立方 + 十位数立方 + 个位数立方;<br>            * 获取水仙花范围内的所有3位数（100-999之间的每个3位数）<br>            * 判断该3位数是否满足水仙花数，满足，打印该3位数</p>
<pre><code>* b: 解题步骤
    * 使用for循环，得到100-999之间的每个3位数
    * 获取3位数中百位数字、十位数字、个位数字
    * 使用if条件语句，判断该3位数是否满足水仙花数，满足，使用输出语句，打印该3位数

* c: 案例代码
    public class Test02 {
        public static void main(String[] args) {
            for (int i = 100; i &lt; 1000; i++) {
                int bai = i/100%10;
                int shi = i/10%10;
                int ge = i%10;

                if (i == bai*bai*bai + shi*shi*shi + ge*ge*ge) {
                    System.out.println(i);
                }
            }
        }
    }            </code></pre><p>###03ASCII编码表<br>    * A: ASCII编码表<br>        * a: 英文全称<br>            * American Standard Code for Information Interchange，美国标准信息交换代码<br>        * b: ASCII编码表由来<br>            * 计算机中，所有的数据在存储和运算时都要使用二进制数表示<br>            * a、b、c、d这样的52个字母（包括大写）、以及0、1等数字还有一些常用的符号, 在计算机中存储时也要使用二进制数来表示<br>            * 具体用哪些二进制数字表示哪个符号，当然每个人都可以约定自己的一套（这就叫编码）<br>            * 大家如果要想互相通信而不造成混乱，那么大家就必须使用相同的编码规则，于是美国有关的标准化组织就出台了ASCII编码，<br>                统一规定了上述常用符号用哪些二进制数来表示。<br>        * c: 中文编码表<br>            * GB2312<br>            * UNICODE<br>        * d: 字符中重要的ASCII码对应关系<br>            * a : 97<br>            * A : 65<br>            * 0 : 48</p>
<p>​    </p>
<p>###04char类型的存储<br>    * A: char类型的存储<br>        * a: 取值范围<br>            * short:占两个字节,是有符号数据,取值范围-32768-32767<br>            * char: 占两个字节,是无符号数据,取值范围0-65536</p>
<pre><code>* b: 类型转换
    * char类型的数据参加运算时要线程程int数据类型

* c: 案例代码
    /*
        ASCII编码表演示
        字符Java 数据类型,char
        整数Java 数据类型,int

        int 类型和 char 数据类型转换
        char  两个字节, int 四个字节

        char转成int类型的时候,类型自动提示,char数据类型,会查询编码表,得到整数
        int转成char类型的时候,强制转换,会查询编码表

        char存储汉字,查询Unicode编码表

        char可以和int计算,提示为int类型, 内存中两个字节
        char取值范围是0-65535, 无符号的数据类型
    */
    public class ASCIIDemo{
        public static void main(String[] args){
            char c = &apos;a&apos;;
            int i = c + 1;
            System.out.println(i);

            int j = 90;
            char h = (char)j;
            System.out.println(h);

            System.out.println( (char)6 );

            char k = &apos;你&apos;;
            System.out.println(k);</code></pre><p>​<br>                    char m = -1;<br>                }<br>            }    </p>
<p>###05输出所有英文字母<br>    * A: 输出所有英文字母<br>        * a: 题目分析<br>            * 一共26个大小写字母，那么，可以考虑循环26次。在每次循环中，完成指定字母的大小写打印<br>            * 找出ABCDEFG…XYZ这些字母之间的变化规律<br>                通过ASCII表发现，后面的字母比它前面的字母，ASCII值大1<br>                下一个字母 = 上一个字母 + 1<br>                如： A    B    C    D<br>                    65    66    67    68<br>            * 在每次循环中打印上一个字母大小写，并指定下一个字母</p>
<pre><code>* b: 解题步骤
    * 定义初始化大写变量，值为’A’； 初始化小写变量，值为’a’
    * 使用for循环，进行26次循环
    * 在每次循环中，打印大写字母、小写字母。
        每次打印完成后，更新大写字母值、小写字母值

* c: 案例代码
    public class Test04 {
        public static void main(String[] args) {
            char da = &apos;A&apos;;
            char xiao = &apos;a&apos;;
            for (int i = 0; i &lt; 26; i++) {
                System.out.println(&quot;大写字母 &quot;+da+&quot; ,小写字母 &quot;+xiao);
                da++; //更新大写字母值
                xiao++; //更新小写字母值
            }
        }
    }</code></pre><p>###0699乘法表的分析<br>    * A: 99乘法表的分析<br>        * a: 打印格式<br>            1<em>1=1<br>            1<em>2=2  2</em>2=4<br>            1<em>3=3  2</em>3=6  3<em>3=9<br>        * b: 题目分析<br>            通过观察发现，如果把1</em>1=1这样的内容 看做一颗<em>的话，那么打印结果就成了如下效果：<br>            *<br>            *</em><br>            <strong>*<br>            **</strong><br>            …<br>            这样，就是打印9行星，每行打印星的个数与当前行数相等。<br>            再观察“1<em>3=3 2</em>3=6 3*3=9”得出它们如下的变化规律：<br>                    每行第n次 +”</em>“+ 行号 +”=”+ 每行第n次 * 行号<br>                如:    1    +”*”+  2    +”=”+   1<em>2; // 相当于1*2=2<br>                    2    +”</em>“+  2    +”=”+   2<em>2; // 相当于2</em>2=4    </p>
<pre><code>* c: 解题步骤
    * 定义一个外层for循环，初始值从1开始，循环9次。用来控制打印的行数
    * 在外层for循环内部，定义一个for循环，初始值从1开始，循环次数与当前行数相等。用来完成每行打印指定次数的乘法公式 如1*1=1
    * 在内层for循环中，完成每行指定次数的乘法公式打印 如1*1=1
        System.out.print(k +&quot;*&quot;+ j +&quot;=&quot;+ j*k +&quot;\t&quot;);
        // 变量k代表：每行中的第n次
        // 变量j代表：行号
    * 在外循环中，当每行指定次数的乘法公式打印完毕后，通过System.out.println()切换到下一行。
        这样，再次打印乘法公式时，就在下一行输出打印了</code></pre><p>###0799乘法表的功能实现<br>    * A: 99乘法表的功能实现<br>        * a: 案例代码<br>            /*<br>                利用嵌套for循环,实现99乘法表示<br>                实现步骤:<br>                  1. 定义外循环控制行数<br>                  2. 内循环控制个数,个数,每次都在递增<br>                  3. 循环中输出,乘法表的格式   1*3=3<br>            */</p>
<pre><code>public class Test05 {
    public static void main(String[] args) {
        for (int j = 1; j &lt; 10; j++) {
            for (int k = 1; k &lt;= j; k++) {
                System.out.print(k +&quot;*&quot;+ j +&quot;=&quot;+ j*k +&quot;\t&quot;);
            }
            System.out.println();
        }
    }
}</code></pre><p>​                </p>
<p>###day07_08(基础语法)实现数组的遍历.avi(14:18)<br>###day07_09(基础语法)数组逆序原理.avi(17:55)<br>###day07_10(基础语法)数组逆序功能实现.avi(9:45)<br>###day07_11(基础语法)选择排序原理.avi(14:01)<br>###day07_12(基础语法)选择排序功能实现.avi(09:07)<br>###day07_13(基础语法)冒泡排序功能实现.avi(16:00)<br>###day07_14(基础语法)数组的折半查找原理.avi(13:15)<br>###day07_15(基础语法)数组的折半查找代码实现.avi(8:23)</p>
<p>###08实现数组的遍历<br>    * A: 实现数组的遍历<br>        * a: 题目分析<br>            * 通过循环，我们可以完成数组中元素的获取，数组名[索引]<br>            * 观察发现，每个数组元素之间加入了一个逗号”,”进行分隔；并且，整个数组的前后有一对中括号”[]”包裹数组所有元素。</p>
<pre><code>* b: 解题步骤
    * 使用输出语句完成打印 左边的中括号”[”
    * 使用循环，输出数组元素值。输出元素值分为两种情况，如下：
        * 最后一个数组元素，加上一个右边的中括号”]”
        * 非最后一个数组元素，加上一个逗号”,”

* c: 案例代码
    /*
        定义方法,实现数组的遍历
        遍历中,输出结果  [11,33,565,66,78,89]
        int[] arr = {3,4,45,7};
        结果包含字符串, [  ]  ,
        实现步骤:
          1. 定义方法实现数组的遍历
          2. 先打印[ 中括号
          3. 遍历数组
            输出数组的元素和逗号
            判断是否遍历到了数组的最后一个元素,如果是最后一个元素,输出]中括号
    */
    public class ArrayMethodTest{
        public static void main(String[] args){
            int[] arr = {11,44,55,33,66};
            printArray(arr);

            int[] arr2 = {22,88,99,33,66};
            printArray(arr2);

        }
        /*
           定义方法,实现功能
           返回值: void
           方法参数: 数组
        */
        public static void printArray(int[] arr){
            //输出一半中括号,不要换行打印
            System.out.print(&quot;[&quot;);
            //数组进行遍历
            for(int i = 0 ; i &lt; arr.length ; i++){
                //判断遍历到的元素,是不是数组的最后一个元素
                //如何判断 循环变量 到达 length-1
                if( i == arr.length-1 ){
                    //输出数组的元素和]
                    System.out.print(arr[i]+&quot;]&quot;);
                }else{
                //不是数组的最后一个元素,输出数组元素和逗号
                    System.out.print(arr[i]+&quot;,&quot;);
                }
            }
            System.out.println();
        }
    }</code></pre><p>###09数组逆序原理<br>    * A: 数组逆序原理<br>        * a: 题目分析(图解见day07_source/数组的逆序原理.JPG)<br>            * 通过观察发现，本题目要实现原数组元素倒序存放操作。即原数组存储元素为{11,22,33,44}，<br>                逆序后为原数组存储元素变为{44,33,22,11}。<br>            * 通过图解发现，想完成数组元素逆序，其实就是把数组中索引为start与end的元素进行互换。<br>            * 每次互换后，start索引位置后移，end索引位置前移，再进行互换<br>            * 直到start位置超越了end位置，互换结束，此时，数组元素逆序完成。</p>
<pre><code>* b: 解题步骤
    * 定义两个索引变量start值为0，变量end值为数组长度减去1（即数组最后一个元素索引）
    * 使用循环，完成数组索引start位置元素与end位置元素值互换。
    * 在循环换过程中，每次互换结束后，start位置后移1，end位置前移1
    * 在循环换过程中，最先判断start位置是否超越了end位置，若已超越，则跳出循环</code></pre><p>​<br>###10数组逆序功能实现<br>    * A：案例代码<br>        /*<br>           数组的逆序:<br>             数组中的元素,进行位置上的交换<br>             逆序 不等于 反向遍历<br>             就是数组中最远的两个索引,进行位置交换,实现数组的逆序<br>             使用的是数组的指针思想,就是变量,思想,可以随时变换索引<br>             反转 reverse<br>             实现步骤:<br>               1. 定义方法,实现数组的逆序<br>               2. 遍历数组<br>                 实现数组的最远索引换位置<br>                 使用临时的第三方变量<br>        */<br>        public class ArrayMethodTest_1{<br>            public static void main(String[] args){<br>                int[] arr = {3,5,7,1,0,9,-2};<br>                //调用数组的逆序方法<br>                reverse(arr);<br>                //看到数组的元素,遍历<br>                printArray(arr);<br>            }</p>
<pre><code>    /*
       定义方法,实现数组的逆序
       返回值: 没有返回值
       参数:   数组就是参数
    */
    public static void reverse(int[] arr){
        //利用循环,实现数组遍历,遍历过程中,最远端换位
        //for的第一项,定义2个变量, 最后,两个变量++ --
        for( int min = 0 , max = arr.length-1 ; min &lt; max  ; min++,max--){
            //对数组中的元素,进行位置交换
            //min索引和max索引的元素交换
            //定义变量,保存min索引
            int temp = arr[min];
            //max索引上的元素,赋值给min索引
            arr[min] =  arr[max];
            //临时变量,保存的数据,赋值到max索引上
            arr[max] = temp;
        }
    }
}</code></pre><p>###11选择排序原理<br>    * A: 选择排序原理<br>        * a: 题目分析(图解见day07_source/选择排序原理.JPG)<br>            * 通过观察发现，本题目要实现把数组元素{13,46,22,65,3}进行排序<br>            * 提到数组排序，就要进行元素值大小的比较，通过上图发现，我们想完成排序要经过若干次的比较才能够完成。<br>            * 上图中用每圈要比较的第一个元素与该元素后面的数组元素依次比较到数组的最后一个元素，把小的值放在第一个数组元素中，数组循环一圈后，则把最小元素值互换到了第一个元素中。<br>            * 数组再循环一圈后，把第二小的元素值互换到了第二个元素中。按照这种方式，数组循环多圈以后，就完成了数组元素的排序。这种排序方式我们称为选择排序。</p>
<p>​<br>        * b: 解题步骤<br>            * 使用for循环（外层循环），指定数组要循环的圈数（通过图解可知，数组循环的圈数为数组长度 - 1）<br>            * 在每一圈中，通过for循环（内层循环）完成数组要比较的第一个元素与该元素后面的数组元素依次比较到数组的最后一个元素，把小的值放在第一个数组元素中<br>            * 在每一圈中，要参与比较的第一个元素由第几圈循环来决定。如上图所示<br>                * 进行第一圈元素比较时，要比较的第一个元素为数组第一个元素，即索引为0的元素<br>                * 进行第二圈元素比较时，要比较的第一个元素为数组第二个元素，即索引为1的元素<br>                * 依次类推，得出结论：进行第n圈元素比较时，要比较的第一个元素为数组第n个元素，即数组索引为n-1的元素</p>
<p>###12选择排序功能实现<br>    * A: 案例代码<br>        /*<br>          数组的排序: 一般都是升序排列,元素,小到大的排列</p>
<pre><code>  两种排序的方式
     选择排序: 数组的每个元素都进行比较
     冒泡排序: 数组中相邻元素进行比较
     规则: 比较大小,位置交换
*/
public class ArrayMethodTest_2{
    public static void main(String[] args){
        int[] arr  = {3,1,4,2,56,7,0};
        //调用选择排序方法
        //selectSort(arr);
        printArray(arr);
    }
    /*
        定义方法,实现数组的选择排序
        返回值: 没有
        参数:  数组
        实现步骤:
          1.嵌套循环实现排序
            外循环,控制的是一共比较了多少次
            内循环,控制的是每次比较了多少个元素
          2. 判断元素的大小值
            小值,存储到小的索引
    */
    public static void selectSort(int[] arr){
        for(int i = 0 ; i &lt; arr.length - 1; i++){
            //内循环,是每次都在减少,修改变量的定义
            for(int j = i+1 ; j &lt; arr.length ; j++){
                //数组的元素进行判断
                if(arr[i] &gt; arr[j]){
                    //数组的换位
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp; 
                }
            }
        }
    }

    /*
       定义方法,实现功能
       返回值: void
       方法参数: 数组
    */
    public static void printArray(int[] arr){
        //输出一半中括号,不要换行打印
        System.out.print(&quot;[&quot;);
        //数组进行遍历
        for(int i = 0 ; i &lt; arr.length ; i++){
            //判断遍历到的元素,是不是数组的最后一个元素
            //如何判断 循环变量 到达 length-1
            if( i == arr.length-1 ){
                //输出数组的元素和]
                System.out.print(arr[i]+&quot;]&quot;);
            }else{
            //不是数组的最后一个元素,输出数组元素和逗号
                System.out.print(arr[i]+&quot;,&quot;);
            }
        }
        System.out.println();
    }
}</code></pre><p>###13冒泡排序功能实现<br>    * A: 冒泡排序功能实现<br>            * a: 题目分析<br>                * 通过观察发现，本题目要实现把数组元素{13,46,22,65,3}进行排序<br>                * 提到数组排序，就要进行元素值大小的比较，通过上图发现，我们想完成排序要经过若干次的比较才能够完成。<br>                * 上图中相邻的元素值依次比较，把大的值放后面的元素中，数组循环一圈后，则把最大元素值互换到了最后一个元素中。<br>                    数组再循环一圈后，把第二大的元素值互换到了倒数第二个元素中。按照这种方式，数组循环多圈以后，<br>                    就完成了数组元素的排序。这种排序方式我们称为冒泡排序。</p>
<pre><code>* b: 解题步骤
    * 使用for循环（外层循环），指定数组要循环的圈数（通过图解可知，数组循环的圈数为数组长度 - 1）
    * 在每一圈中，通过for循环（内层循环）完成相邻的元素值依次比较，把大的值放后面的元素中
    * 每圈内层循环的次数，由第几圈循环来决定。如上图所示
        * 进行第一圈元素比较时，内层循环次数为数组长度 - 1
        * 进行第二圈元素比较时，内层循环次数为数组长度 - 2
        * 依次类推，得出结论：进行第n圈元素比较时，内层循环次数为数组长度 - n

* c: 案例代码    
    /*
      数组的排序: 一般都是升序排列,元素,小到大的排列

      两种排序的方式
         选择排序: 数组的每个元素都进行比较
         冒泡排序: 数组中相邻元素进行比较
         规则: 比较大小,位置交换
    */
    public class ArrayMethodTest_2{
        public static void main(String[] args){
            int[] arr  = {3,1,4,2,56,7,0};
            //调用选择排序方法
            //selectSort(arr);

            //调用冒泡排序方法
            bubbleSort(arr);
            printArray(arr);
        }
        /*
           定义方法,实现数组的冒泡排序
           返回值: 没有
            参数:  数组
        */
        public static void bubbleSort(int[] arr){
            for(int i = 0 ; i &lt; arr.length - 1; i++){
                //每次内循环的比较,从0索引开始, 每次都在递减
                for(int j = 0 ; j &lt; arr.length-i-1; j++){
                    //比较的索引,是j和j+1
                    if(arr[j] &gt; arr[j+1]){
                        int temp = arr[j];
                        arr[j] = arr[j+1];
                        arr[j+1] = temp;
                    }
                }
            }
        }

        /*
           定义方法,实现功能
           返回值: void
           方法参数: 数组
        */
        public static void printArray(int[] arr){
            //输出一半中括号,不要换行打印
            System.out.print(&quot;[&quot;);
            //数组进行遍历
            for(int i = 0 ; i &lt; arr.length ; i++){
                //判断遍历到的元素,是不是数组的最后一个元素
                //如何判断 循环变量 到达 length-1
                if( i == arr.length-1 ){
                    //输出数组的元素和]
                    System.out.print(arr[i]+&quot;]&quot;);
                }else{
                //不是数组的最后一个元素,输出数组元素和逗号
                    System.out.print(arr[i]+&quot;,&quot;);
                }
            }
            System.out.println();
        }
    }</code></pre><p>###14数组的折半查找原理<br>    * A: 数组的折半查找原理(图解见day07_source/折半查找原理.JPG)<br>            * a: 题目分析<br>                * 通过观察发现，本题目要实现查找指定数值在元素有序的数组中存储的位置（索引），返回该位置（索引）。<br>                * 我们使用数组最中间位置的元素值与要查找的指定数值进行比较，若相等，返回中间元素值的索引<br>                * 最中间位置的元素值与要查找的指定数值进行比较，若不相等，则根据比较的结果，缩小查询范围为上次数组查询范围的一半；<br>                    再根据新的查询范围，更新最中间元素位置，然后使用中间元素值与要查找的指定数值进行比较<br>                        比较结果相等，返回中间元素值的索引<br>                        比较结果不相等，继续缩小查询范围为上次数组查询范围的一半，更新最中间元素位置，继续比较，依次类推。<br>                * 当查询范围缩小到小于0个元素时，则指定数值没有查询到，返回索引值-1。</p>
<pre><code>* b: 解题步骤
    * 定义3个用来记录索引值的变量，变量min记录当前范围最小索引值，初始值为0；变量max记录当前范围最大索引值，初始值为数组长度-1；变量mid记录当前当前范围最中间元素的索引值，初始值为(min+max) / 2
    * 使用循环，判断当前范围下，最中间元素值与指定查找的数值是否相等
        若相等，结束循环，返回当前范围最中间元素的索引值mid
        若不相等，根据比较结果，缩小查询范围为上一次查询范围的一般
        中间元素值 比 要查询的数值大，说明要查询的数值在当前范围的最小索引位置与中间索引位置之间，此时，更新查询范围为:
            范围最大索引值 = 上一次中间索引位置 -1；
        中间元素值 比 要查询的数值小，说明要查询的数值在当前范围的最大索引位置与中间索引位置之间，此时，更新查询范围为:
            范围最小索引值 = 上一次中间索引位置 +1；
        在新的查询范围中，更新中间元素值的位置，再次使用最中间元素值与指定查找的数值是否相等。
            中间索引值 = (范围最小索引值 +范围最大索引值) / 2;
    * 每次查询范围缩小一半后，使用if语句判断，查询范围是否小于0个元素，若小于0个元素，则说明指定数值没有查询到，返回索引值-1。</code></pre><p>###15数组的折半查找代码实现<br>    * A: 案例代码<br>        /*<br>           数组的查找功能<br>             在一个数组中,找一个元素,是否存在于数组中,如果存在,就返回索引</p>
<pre><code>     普通查询:
       找到元素在数组中出现的索引,如果没有这个 元素,结果就是负数

*/
public class ArrayMethodTest_3{
     public static void main(String[] args){
         int[] arr = {1,3,5,7,9,11,15};
         int index = binarySearch(arr,10);
         System.out.println(index);

     }

     /*
         定义方法,实现,折半查找
         返回值: 索引
         参数: 数组,被找的元素 
         实现步骤:
           1. 需要的变量定义
              三个,三个指针

           2. 进行循环折半
              可以折半的条件  min &lt;= max

           3. 让被找元素,和中间索引元素进行比较
               元素 &gt; 中间索引  小指针= 中间+1
               元素 &lt; 中间索引  大指针= 中间-1
               元素 == 中间索引  找到了,结束了,返回中间索引

            4. 循环结束,无法折半
              元素没有找到 ,返回-1
     */
     public static int binarySearch(int[] arr, int key){
         //定义三个指针变量
         int min = 0 ;
         int max = arr.length -1 ;
         int mid = 0;
         //循环折半,条件 min&lt;=max
         while( min &lt;= max){
             //公式,计算中间索引
             mid = (min+max)/2;
             //让被找元素,和中间索引元素进行比较
             if(key &gt; arr[mid]){
                 min = mid + 1;
             }else if (key &lt; arr[mid]){
                 max = mid - 1;
             }else{
                 //找到元素,返回元素索引
                 return mid;
             }
         }
         return -1;
     }

    /*
       定义方法,实现数组的普通查询
       返回值: 索引
       参数:   数组, 被找的元素

       实现步骤:
         1. 遍历数组
         2. 遍历过程中,使用元素和数组中的元素进行比较
            如果相同,返回元素在数组中的索引
            如果不同,返回负数
    */
    public static int search(int[] arr, int key){
        //遍历数组
        for(int i = 0 ; i &lt; arr.length ; i++){
            //数组元素,被查找的元素比较
            if(arr[i] == key){
                //返回索引
                return i;
            }
        }
        return -1;
    }
}</code></pre><p>###16总结</p>
<ul>
<li>把今天的知识点总结一遍。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">KJH</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">179</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KJH</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

<span id="busuanzi_container_site_uv">
  本站总访问量<span id="busuanzi_value_site_uv"></span>次
</span>
        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
