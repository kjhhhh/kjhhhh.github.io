<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:type" content="website">
<meta property="og:title" content="KJHの博客">
<meta property="og:url" content="http://yoursite.com/page/36/index.html">
<meta property="og:site_name" content="KJHの博客">
<meta property="og:description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="匡俊桦">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/36/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>KJHの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KJHの博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录&回忆</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day29%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day29%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记29</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:13:30" itemprop="dateModified" datetime="2020-12-23T23:13:30+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、JDBC<br>2、DBUtils</p>
<p>###01JDBC概念和数据库驱动程序<br>    * A: JDBC概念和数据库驱动程序<br>        * a: JDBC概述<br>            * JDBC（Java Data Base Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，<br>                可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。是Java访问数据库的标准规范<br>            * JDBC提供了一种基准,据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。<br>            * JDBC需要连接驱动，驱动是两个设备要进行通信，满足一定通信数据格式，数据格式由设备提供商规定，<br>                设备提供商为设备提供驱动软件，通过软件可以与该设备进行通信。<br>            * 我们使用的是mysql的驱动mysql-connector-java-5.1.39-bin.jar<br>        * b: 总结<br>            * JDBC是java提供给开发人员的一套操作数据库的接口<br>            * 数据库驱动就是实现该接口的实现类</p>
<p>###02JDBC原理<br>    * A: JDBC原理<br>        * a: 描述<br>            * Java提供访问数据库规范称为JDBC，而生产厂商提供规范的实现类称为驱动<br>            * DBC是接口，驱动是接口的实现，没有驱动将无法完成数据库连接，从而不能操作数据库！<br>                每个数据库厂商都需要提供自己的驱动，用来连接自己公司的数据库，也就是说驱动一般都由数据库生成厂商提供。<br>            * 图解见day29_source/JDBC实现原理.JPG</p>
<p>###03准备数据<br>    * A: 准备数据<br>        * a: 创建数据库和表结构<br>            #创建数据库<br>            create database mybase;<br>            #使用数据库<br>            use mybase;<br>            ###创建分类表<br>            create table sort(<br>              sid int PRIMARY KEY AUTO_INCREMENT,<br>              sname varchar(100),<br>              sprice DOUBLE,<br>              sdesc VARCHAR(500)<br>            );</p>
<pre><code>* b: 向表中插入数据
    #初始化数据
    insert into sort(sname,sprice,sdesc) values(&apos;家电&apos;,2000, &apos;优惠的促销&apos;);
    insert into sort(sname,sprice,sdesc) values(&apos;家具&apos;,8900, &apos;家具价格上调,原材料涨价&apos;);
    insert into sort(sname,sprice,sdesc) values(&apos;儿童玩具&apos;,290, &apos;赚家长的钱&apos;);
    insert into sort(sname,sprice,sdesc) values(&apos;生鲜&apos;,500.99, &apos;生鲜商品&apos;);
    insert into sort(sname,sprice,sdesc) values(&apos;服装&apos;,24000, &apos;换季销售&apos;);
    insert into sort(sname,sprice,sdesc) values(&apos;洗涤&apos;,50, &apos;洗发水促销&apos;);            </code></pre><p>###04JDBC的开发步骤<br>    * A: JDBC的开发步骤<br>        * a: 步骤介绍<br>            1.注册驱动<br>                告知JVM使用的是哪一个数据库的驱动<br>            2.获得连接<br>                使用JDBC中的类,完成对MySQL数据库的连接<br>            3.获得语句执行平台<br>                通过连接对象获取对SQL语句的执行者对象<br>            4.执行sql语句<br>                使用执行者对象,向数据库执行SQL语句<br>                获取到数据库的执行后的结果<br>            5.处理结果<br>            6.释放资源  一堆close()</p>
<p>###05导入mysql数据库驱动程序jar包<br>    * A: 导入mysql数据库驱动程序jar包<br>        * a: 步骤<br>            * 创建lib目录，用于存放当前项目需要的所有jar包<br>            * 选择jar包，右键执行build path / Add to Build Path</p>
<p>###06注册数据库驱动程序<br>    * A: 注册数据库驱动程序<br>        * a: 案例代码<br>            public class JDBCDemo {<br>                public static void main(String[] args)throws ClassNotFoundException,SQLException{<br>                    //1.注册驱动 反射技术,将驱动类加入到内容<br>                    // 使用java.sql.DriverManager类静态方法 registerDriver(Driver driver)<br>                    // Diver是一个接口,参数传递,MySQL驱动程序中的实现类<br>                    //DriverManager.registerDriver(new Driver());<br>                    //驱动类源代码,注册2次驱动程序<br>                    Class.forName(“com.mysql.jdbc.Driver”);<br>                }<br>            }</p>
<p>​<br>​<br>###07获取数据库的连接对象<br>    * A：获取数据库的连接对象<br>        * a: 案例代码<br>            public class JDBCDemo {<br>                public static void main(String[] args)throws ClassNotFoundException,SQLException{<br>                    //1.注册驱动 反射技术,将驱动类加入到内容<br>                    // 使用java.sql.DriverManager类静态方法 registerDriver(Driver driver)<br>                    // Diver是一个接口,参数传递,MySQL驱动程序中的实现类<br>                    //DriverManager.registerDriver(new Driver());<br>                    //驱动类源代码,注册2次驱动程序<br>                    Class.forName(“com.mysql.jdbc.Driver”);</p>
<pre><code>        //2.获得数据库连接  DriverManager类中静态方法
        //static Connection getConnection(String url, String user, String password)  
        //返回值是Connection接口的实现类,在mysql驱动程序
        //url: 数据库地址  jdbc:mysql://连接主机IP:端口号//数据库名字
        String url = &quot;jdbc:mysql://localhost:3296/mybase&quot;;
        //用户名和密码用自己的
        String username=&quot;root&quot;;
        String password=&quot;123&quot;;
        Connection con = DriverManager.getConnection(url, username, password);
        System.out.println(con);                    
    }
}</code></pre><p>​<br>###08获取SQL语句的执行对象对象<br>    * A: 获取SQL语句的执行对象对象<br>        * a: 案例代码<br>            public class JDBCDemo {<br>                public static void main(String[] args)throws ClassNotFoundException,SQLException{<br>                    //1.注册驱动 反射技术,将驱动类加入到内容<br>                    // 使用java.sql.DriverManager类静态方法 registerDriver(Driver driver)<br>                    // Diver是一个接口,参数传递,MySQL驱动程序中的实现类<br>                    //DriverManager.registerDriver(new Driver());<br>                    //驱动类源代码,注册2次驱动程序<br>                    Class.forName(“com.mysql.jdbc.Driver”);</p>
<pre><code>        //2.获得数据库连接  DriverManager类中静态方法
        //static Connection getConnection(String url, String user, String password)  
        //返回值是Connection接口的实现类,在mysql驱动程序
        //url: 数据库地址  jdbc:mysql://连接主机IP:端口号//数据库名字
        String url = &quot;jdbc:mysql://localhost:3296/mybase&quot;;
        String username=&quot;root&quot;;
        String password=&quot;123&quot;;
        Connection con = DriverManager.getConnection(url, username, password);

        //3.获得语句执行平台, 通过数据库连接对象,获取到SQL语句的执行者对象
        // con对象调用方法   Statement createStatement() 获取Statement对象,将SQL语句发送到数据库
        // 返回值是 Statement接口的实现类对象,,在mysql驱动程序
        Statement stat = con.createStatement();
        System.out.println(stat);
    }
}</code></pre><p>###09执行insert语句获取结果集<br>    * A: 执行insert语句获取结果集<br>        * a: 案例代码<br>            public class JDBCDemo {<br>                public static void main(String[] args)throws ClassNotFoundException,SQLException{<br>                    //1.注册驱动 反射技术,将驱动类加入到内容<br>                    // 使用java.sql.DriverManager类静态方法 registerDriver(Driver driver)<br>                    // Diver是一个接口,参数传递,MySQL驱动程序中的实现类<br>                    //DriverManager.registerDriver(new Driver());<br>                    //驱动类源代码,注册2次驱动程序<br>                    Class.forName(“com.mysql.jdbc.Driver”);</p>
<pre><code>        //2.获得数据库连接  DriverManager类中静态方法
        //static Connection getConnection(String url, String user, String password)  
        //返回值是Connection接口的实现类,在mysql驱动程序
        //url: 数据库地址  jdbc:mysql://连接主机IP:端口号//数据库名字
        String url = &quot;jdbc:mysql://localhost:3296/mybase&quot;;
        String username=&quot;root&quot;;
        String password=&quot;123&quot;;
        Connection con = DriverManager.getConnection(url, username, password);

        //3.获得语句执行平台, 通过数据库连接对象,获取到SQL语句的执行者对象
        // con对象调用方法   Statement createStatement() 获取Statement对象,将SQL语句发送到数据库
        // 返回值是 Statement接口的实现类对象,,在mysql驱动程序
        Statement stat = con.createStatement();
        //    4.执行sql语句
        // 通过执行者对象调用方法执行SQL语句,获取结果
        // int executeUpdate(String sql)  执行数据库中的SQL语句, insert delete update
        // 返回值int,操作成功数据表多少行
        int row = stat.executeUpdate
                (&quot;INSERT INTO sort(sname,sprice,sdesc) VALUES(&apos;汽车用品&apos;,50000,&apos;疯狂涨价&apos;)&quot;);
        System.out.println(row);

        //6.释放资源  一堆close()
        stat.close();
        con.close();
    }
}</code></pre><p>###10执行select语句获取结果集<br>    * A: 执行select语句获取结果集<br>        * a: 案例代码<br>            public class JDBCDemo1 {<br>                public static void main(String[] args) throws Exception{<br>                    //1. 注册驱动<br>                    Class.forName(“com.mysql.jdbc.Driver”);<br>                    //2. 获取连接对象<br>                    String url = “jdbc:mysql://localhost:3296/mybase”;<br>                    String username=”root”;<br>                    String password=”123”;<br>                    Connection con = DriverManager.getConnection(url, username, password);<br>                    //3 .获取执行SQL 语句对象<br>                    Statement stat = con.createStatement();<br>                    // 拼写查询的SQL<br>                    String sql = “SELECT * FROM sort”;<br>                    //4. 调用执行者对象方法,执行SQL语句获取结果集<br>                    // ResultSet executeQuery(String sql)  执行SQL语句中的select查询<br>                    // 返回值ResultSet接口的实现类对象,实现类在mysql驱动中<br>                    ResultSet rs = stat.executeQuery(sql);<br>                    //5 .处理结果集<br>                    // ResultSet接口方法 boolean next() 返回true,有结果集,返回false没有结果集<br>                    while(rs.next()){<br>                        //获取每列数据,使用是ResultSet接口的方法 getXX方法参数中,建议写String列名<br>                        System.out.println(rs.getInt(“sid”)+”   “+rs.getString(“sname”)+<br>                                “   “+rs.getDouble(“sprice”)+”   “+rs.getString(“sdesc”));<br>                    }</p>
<pre><code>        rs.close();
        stat.close();
        con.close();
    }
}</code></pre><p>​<br>###11SQL注入攻击<br>    * A: SQL注入攻击<br>        * a: 注入问题<br>            * 假设有登录案例SQL语句如下:<br>            * SELECT * FROM 用户表 WHERE NAME = 用户输入的用户名 AND PASSWORD = 用户输的密码;<br>            * 此时，当用户输入正确的账号与密码后，查询到了信息则让用户登录。<br>                但是当用户输入的账号为XXX 密码为：XXX’  OR ‘a’=’a时，则真正执行的代码变为：<br>                * SELECT * FROM 用户表 WHERE NAME = ‘XXX’ AND PASSWORD =’ XXX’  OR ’a’=’a’;<br>            * 此时，上述查询语句时永远可以查询出结果的。那么用户就直接登录成功了，显然我们不希望看到这样的结果，这便是SQL注入问题。<br>        * b: 案例演示<br>            CREATE TABLE users(<br>                 id INT PRIMARY KEY AUTO_INCREMENT,<br>                 username VARCHAR(100),<br>                 PASSWORD VARCHAR(100)<br>            );</p>
<pre><code>INSERT INTO users (username,PASSWORD) VALUES (&apos;a&apos;,&apos;1&apos;),(&apos;b&apos;,&apos;2&apos;);

SELECT * FROM users;

-- 登录查询
SELECT * FROM users WHERE username=&apos;dsfsdfd&apos; AND PASSWORD=&apos;wrethiyu&apos;1 
OR 1=1

SELECT * FROM users WHERE username=&apos;a&apos; AND PASSWORD=&apos;1&apos;OR&apos;1=1&apos;
键盘录入：
1
1&apos;OR&apos; 1=1</code></pre><p>​<br>###12SQL注入攻击用户登录案例<br>    * A: SQL注入攻击用户登录案例<br>        * a: 案例代码<br>            public class JDBCDemo2 {<br>                public static void main(String[] args)throws Exception {<br>                    Class.forName(“com.mysql.jdbc.Driver”);<br>                    String url = “jdbc:mysql://localhost:3296/mybase”;<br>                    String username = “root”;<br>                    String password = “123”;<br>                    Connection con = DriverManager.getConnection(url, username, password);<br>                    Statement stat = con.createStatement();</p>
<pre><code>        Scanner sc = new Scanner(System.in);
        String user = sc.nextLine();
        String pass = sc.nextLine();

        //执行SQL语句,数据表,查询用户名和密码,如果存在,登录成功,不存在登录失败
//        String sql = &quot;SELECT * FROM users WHERE username=&apos;dsfsdfd&apos; AND PASSWORD=&apos;wrethiyu&apos; OR 1=1&quot;;
        String sql = &quot;SELECT * FROM users WHERE username=&apos;&quot;+user+&quot;&apos; AND PASSWORD=&apos;&quot;+pass+&quot;&apos;&quot;;
        System.out.println(sql);
        ResultSet rs = stat.executeQuery(sql);
        while(rs.next()){
            System.out.println(rs.getString(&quot;username&quot;)+&quot;   &quot;+rs.getString(&quot;password&quot;));
        }

        rs.close();
        stat.close();
        con.close();
    }
}</code></pre><p>​<br>###13PrepareStatement接口预编译SQL语句<br>    * A: PrepareStatement接口预编译SQL语句<br>        * a: 预处理对象<br>            * 使用PreparedStatement预处理对象时，建议每条sql语句所有的实际参数，都使用逗号分隔。<br>            * String sql = “insert into sort(sid,sname) values(?,?)”;;<br>            * PreparedStatement预处理对象代码：<br>            * PreparedStatement psmt = conn.prepareStatement(sql)</p>
<pre><code>* b: 执行SQL语句的方法介绍
    * int executeUpdate(); --执行insert update delete语句.
    * ResultSet executeQuery(); --执行select语句.
    * boolean execute(); --执行select返回true 执行其他的语句返回false.
* c: 设置实际参数
    * void setXxx(int index, Xxx xx) 将指定参数设置为给定Java的xx值。在将此值发送到数据库时，驱动程序将它转换成一个 SQL Xxx类型值。
    * 例如：
        * setString(2, &quot;家用电器&quot;) 把SQL语句中第2个位置的占位符？ 替换成实际参数 &quot;家用电器&quot;
* d: 案例代码
    /*
     *  Java程序实现用户登录,用户名和密码,数据库检查
     *  防止注入攻击
     *  Statement接口实现类,作用执行SQL语句,返回结果集
     *  有一个子接口PreparedStatement  (SQL预编译存储,多次高效的执行SQL) 
     *  PreparedStatement的实现类数据库的驱动中,如何获取接口的实现类
     *  
     *  是Connection数据库连接对象的方法
     *  PreparedStatement prepareStatement(String sql) 

     */
    public class JDBCDemo3 {
        public static void main(String[] args)throws Exception {
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            String url = &quot;jdbc:mysql://localhost:3296/mybase&quot;;
            String username = &quot;root&quot;;
            String password = &quot;123&quot;;
            Connection con = DriverManager.getConnection(url, username, password);
            Scanner sc = new Scanner(System.in);
            String user = sc.nextLine();
            String pass = sc.nextLine();

            //执行SQL语句,数据表,查询用户名和密码,如果存在,登录成功,不存在登录失败
            String sql = &quot;SELECT * FROM users WHERE username=? AND PASSWORD=?&quot;;
            //调用Connection接口的方法prepareStatement,获取PrepareStatement接口的实现类
            //方法中参数,SQL语句中的参数全部采用问号占位符
            PreparedStatement pst =  con.prepareStatement(sql);
            System.out.println(pst);
            //调用pst对象set方法,设置问号占位符上的参数
            pst.setObject(1, user);
            pst.setObject(2, pass);

            //调用方法,执行SQL,获取结果集
            ResultSet rs = pst.executeQuery();
            while(rs.next()){
                System.out.println(rs.getString(&quot;username&quot;)+&quot;   &quot;+rs.getString(&quot;password&quot;));
            }

            rs.close();
            pst.close();
            con.close();
        }
    }</code></pre><p>​<br>###14PrepareStatement接口预编译SQL语句执行修改<br>    * A: PrepareStatement接口预编译SQL语句执行修改<br>        * 案例代码<br>            /*<br>             *  使用PrepareStatement接口,实现数据表的更新操作<br>             */<br>            public class JDBCDemo {<br>                public static void main(String[] args) throws Exception{<br>                    Class.forName(“com.mysql.jdbc.Driver”);<br>                    String url = “jdbc:mysql://localhost:3296/mybase”;<br>                    String username=”root”;<br>                    String password=”123”;<br>                    Connection con = DriverManager.getConnection(url, username, password);    </p>
<pre><code>        //拼写修改的SQL语句,参数采用?占位
        String sql = &quot;UPDATE sort SET sname=?,sprice=? WHERE sid=?&quot;;
        //调用数据库连接对象con的方法prepareStatement获取SQL语句的预编译对象
        PreparedStatement pst = con.prepareStatement(sql);
        //调用pst的方法setXXX设置?占位
        pst.setObject(1, &quot;汽车美容&quot;);
        pst.setObject(2, 49988);
        pst.setObject(3, 7);
        //调用pst方法执行SQL语句
        pst.executeUpdate();

        pst.close();
        con.close();
    }
}</code></pre><p>​<br>###15PrepareStatement接口预编译SQL语句执行查询<br>    * A: PrepareStatement接口预编译SQL语句执行查询<br>        * a: 案例代码<br>            /*<br>             *  PrepareStatement接口实现数据表的查询操作<br>             */<br>            public class JDBCDemo1 {<br>                public static void main(String[] args) throws Exception{<br>                    Class.forName(“com.mysql.jdbc.Driver”);<br>                    String url = “jdbc:mysql://localhost:3296/mybase”;<br>                    String username=”root”;<br>                    String password=”123”;<br>                    Connection con = DriverManager.getConnection(url, username, password);    </p>
<pre><code>        String sql = &quot;SELECT * FROM sort&quot;;

        PreparedStatement pst = con.prepareStatement(sql);

        //调用pst对象的方法,执行查询语句,Select
        ResultSet rs=pst.executeQuery();
        while(rs.next()){
            System.out.println(rs.getString(&quot;sid&quot;)+&quot;  &quot;+rs.getString(&quot;sname&quot;)+&quot;  &quot;+rs.getString(&quot;sprice&quot;)+&quot;  &quot;+rs.getString(&quot;sdesc&quot;));
        }
        rs.close();
        pst.close();
        con.close();
    }
}</code></pre><p>​<br>###16JDBC的工具类和测试<br>    * A: JDBC的工具类和测试<br>        * a: 案例代码<br>            //JDBCUtils工具类代码<br>            public class JDBCUtils {<br>                private JDBCUtils(){}<br>                private static Connection con ;</p>
<pre><code>static{
    try{
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        String url = &quot;jdbc:mysql://localhost:3296/mybase&quot;;
        String username=&quot;root&quot;;
        String password=&quot;123&quot;;
        con = DriverManager.getConnection(url, username, password);
    }catch(Exception ex){
        throw new RuntimeException(ex+&quot;数据库连接失败&quot;);
    }
}

/*
 * 定义静态方法,返回数据库的连接对象
 */
public static Connection getConnection(){
    return con;
}</code></pre><p>​<br>                public static void close(Connection con,Statement stat){</p>
<pre><code>     if(stat!=null){
         try{
             stat.close();
         }catch(SQLException ex){}
     }

     if(con!=null){
         try{
             con.close();
         }catch(SQLException ex){}
     }

}</code></pre><p>​<br>                public static void close(Connection con,Statement stat , ResultSet rs){<br>                     if(rs!=null){<br>                         try{<br>                             rs.close();<br>                         }catch(SQLException ex){}<br>                     }</p>
<pre><code>             if(stat!=null){
                 try{
                     stat.close();
                 }catch(SQLException ex){}
             }

             if(con!=null){
                 try{
                     con.close();
                 }catch(SQLException ex){}
             }

        }
    }
//测试JDBCUtils工具类的代码
public class TestJDBCUtils {
    public static void main(String[] args)throws Exception {
        Connection con = JDBCUtils.getConnection();
        PreparedStatement pst = con.prepareStatement(&quot;SELECT sname FROM sort&quot;);
        ResultSet rs = pst.executeQuery();
        while(rs.next()){
            System.out.println(rs.getString(&quot;sname&quot;));
        }
        JDBCUtils.close(con, pst, rs);
    }
}</code></pre><p>###17数据表数据存储对象<br>    * A: 数据表数据存储对象<br>        * a: 准备工作<br>            * 导入jar包<br>            * 拷贝day32定义的工具类JDBCUtils</p>
<pre><code>* b: 案例代码
    //定义实体类Sort
    public class Sort {
        private int sid;
        private String sname;
        private double sprice;
        private String sdesc;
        public Sort(int sid, String sname, double sprice, String sdesc) {
            this.sid = sid;
            this.sname = sname;
            this.sprice = sprice;
            this.sdesc = sdesc;
        }
        public Sort(){}
        public int getSid() {
            return sid;
        }
        public void setSid(int sid) {
            this.sid = sid;
        }
        public String getSname() {
            return sname;
        }
        public void setSname(String sname) {
            this.sname = sname;
        }
        public double getSprice() {
            return sprice;
        }
        public void setSprice(double sprice) {
            this.sprice = sprice;
        }
        public String getSdesc() {
            return sdesc;
        }
        public void setSdesc(String sdesc) {
            this.sdesc = sdesc;
        }
        @Override
        public String toString() {
            return &quot;Sort [sid=&quot; + sid + &quot;, sname=&quot; + sname + &quot;, sprice=&quot; + sprice + &quot;, sdesc=&quot; + sdesc + &quot;]&quot;;
        }                
    }

    /*
     *  JDBC读取数据表sort,每行数据封装到Sort类的对象中
     *  很多个Sort类对象,存储到List集合中
     */
    public class JDBCDemo {
        public static void main(String[] args) throws Exception{
            //使用JDBC工具类,直接获取数据库连接对象
            Connection con = JDBCUtils.getConnection();
            //连接获取数据库SQL语句执行者对象
            PreparedStatement pst = con.prepareStatement(&quot;SELECT * FROM sort&quot;);
            //调用查询方法,获取结果集
            ResultSet rs = pst.executeQuery();
            //创建集合对象
            List&lt;Sort&gt; list = new ArrayList&lt;Sort&gt;();
            while(rs.next()){
                //获取到每个列数据,封装到Sort对象中
                Sort s = new Sort(rs.getInt(&quot;sid&quot;),rs.getString(&quot;sname&quot;),rs.getDouble(&quot;sprice&quot;),rs.getString(&quot;sdesc&quot;));
                //封装的Sort对象,存储到集合中
                list.add(s);
            }
            JDBCUtils.close(con, pst, rs);
            //遍历List集合
            for(Sort s : list){
                System.out.println(s);
            }
        }
    }</code></pre><p>​            </p>
<p>​<br>​<br>###18properties配置文件<br>    * A: properties配置文件<br>        * a: 相关介绍<br>            * 开发中获得连接的4个参数（驱动、URL、用户名、密码）通常都存在配置文件中，方便后期维护，程序如果需要更换数据库，<br>                只需要修改配置文件即可。<br>            * 通常情况下，我们习惯使用properties文件，此文件我们将做如下要求：<br>                1.    文件位置：任意，建议src下<br>                2.    文件名称：任意，扩展名为properties<br>                3.    文件内容：一行一组数据，格式是“key=value”.<br>                    a)    key命名自定义，如果是多个单词，习惯使用点分隔。例如：jdbc.driver<br>                    b)    value值不支持中文，如果需要使用非英文字符，将进行unicode转换。</p>
<p>###19properties文件的创建和编写<br>    * A: properties文件的创建和编写<br>        * a: properties文件的创建<br>            * src路径下建立database.properties(其实就是一个文本文件)<br>        * b: properties文件的编写(内容如下)<br>            driverClass=com.mysql.jdbc.Driver<br>            url=jdbc:mysql://localhost:3296/mybase<br>            username=root<br>            password=123        </p>
<p>###20加载配置文件<br>    * A: 加载配置文件<br>        * a: 案例代码<br>            /*<br>             *  加载properties配置文件<br>             *  IO读取文件,键值对存储到集合<br>             *  从集合中以键值对方式获取数据库的连接信息,完成数据库的连接<br>             */<br>            public class PropertiesDemo {<br>                public static void main(String[] args) throws Exception{<br>                    FileInputStream fis = new FileInputStream(“database.properties”);<br>                    System.out.println(fis);<br>                    //使用类的加载器<br>                    InputStream in = PropertiesDemo.class.getClassLoader().getResourceAsStream(“database.properties”);<br>                    System.out.println(in);<br>                    Properties pro = new Properties();<br>                    pro.load(in);<br>                    System.out.println(in);<br>                }<br>            }</p>
<p>###21通过配置文件连接数据库<br>    * A: 通过配置文件连接数据库<br>        * a: 案例代码<br>            /*<br>             *  加载properties配置文件<br>             *  IO读取文件,键值对存储到集合<br>             *  从集合中以键值对方式获取数据库的连接信息,完成数据库的连接<br>             */<br>            public class PropertiesDemo {<br>                public static void main(String[] args) throws Exception{<br>                    FileInputStream fis = new FileInputStream(“database.properties”);<br>                    System.out.println(fis);<br>                    //使用类的加载器<br>                    InputStream in = PropertiesDemo.class.getClassLoader().getResourceAsStream(“database.properties”);<br>                    System.out.println(in);<br>                    Properties pro = new Properties();<br>                    pro.load(in);<br>                    //获取集合中的键值对<br>                    String driverClass=pro.getProperty(“driverClass”);<br>                    String url = pro.getProperty(“url”);<br>                    String username = pro.getProperty(“username”);<br>                    String password = pro.getProperty(“password”);<br>                    Class.forName(driverClass);<br>                    Connection con = DriverManager.getConnection(url, username, password);<br>                    System.out.println(con);</p>
<pre><code>    }
}</code></pre><p>​<br>###22读取配置文件的工具类<br>    * A: 读取配置文件的工具类<br>        * a: 案例代码<br>            /*<br>             *  编写数据库连接的工具类,JDBC工具类<br>             *  获取连接对象采用读取配置文件方式<br>             *  读取文件获取连接,执行一次,static{}<br>             */<br>            public class JDBCUtilsConfig {<br>                private static Connection con ;<br>                private static String driverClass;<br>                private static String url;<br>                private static String username;<br>                private static String password;</p>
<pre><code>static{
    try{
        readConfig();
        Class.forName(driverClass);
        con = DriverManager.getConnection(url, username, password);
    }catch(Exception ex){
        throw new RuntimeException(&quot;数据库连接失败&quot;);
    }
}

private static void readConfig()throws Exception{
    InputStream in = JDBCUtilsConfig.class.getClassLoader().getResourceAsStream(&quot;database.properties&quot;);
     Properties pro = new Properties();
     pro.load(in);
     driverClass=pro.getProperty(&quot;driverClass&quot;);
     url = pro.getProperty(&quot;url&quot;);
     username = pro.getProperty(&quot;username&quot;);
     password = pro.getProperty(&quot;password&quot;);
}</code></pre><p>​<br>                public static Connection getConnection(){<br>                    return con;<br>                }</p>
<pre><code>}            </code></pre><p>###23测试工具类<br>    * A: 测试工具类<br>        * a: 案例代码<br>            public class TestJDBCUtils {<br>                public static void main(String[] args) {<br>                    Connection con = JDBCUtilsConfig.getConnection();<br>                    System.out.println(con);<br>                }<br>            }</p>
<p>###24总结<br>    * 把今天的知识点总结一遍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day28%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day28%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记28</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:13:46" itemprop="dateModified" datetime="2020-12-23T23:13:46+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、网络三要素及传输协议<br>2、实现UDP协议的发送端和接收端<br>3、实现TCP协议的客户端和服务器<br>4、TCP上传文件案例</p>
<p>=======================第一节课开始=============================================</p>
<p>###01网络模型<br>  *A:网络模型<br>     TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能，接下来针对这四层进行详细地讲解。<br>       链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>       网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>       传输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>       应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</p>
<p>###02IP地址<br> *A:IP地址<br>      在TCP/IP协议中，这个标识号就是IP地址，它可以唯一标识一台计算机，<br>      目前，IP地址广泛使用的版本是IPv4，它是由4个字节大小的二进制数来表示，如：00001010000000000000000000000001。<br>      由于二进制形式表示的IP地址非常不便记忆和处理，因此通常会将IP地址写成十进制的形式，<br>      每个字节用一个十进制数字(0-255)表示，数字间用符号“.”分开，如 “192.168.1.100”<br>      127.0.0.1 为本地主机地址(本地回环地址)<br>###03端口号<br> *A:端口号<br>    通过IP地址可以连接到指定计算机，但如果想访问目标计算机中的某个应用程序，还需要指定端口号。<br>    在计算机中，不同的应用程序是通过端口号区分的。<br>    端口号是用两个字节（16位的二进制数）表示的，它的取值范围是0<del>65535，<br>    其中，0</del>1023之间的端口号用于一些知名的网络服务和应用，用户的普通应用程序需要使用1024以上的端口号，从而避免端口号被另外一个应用或服务所占用</p>
<p>###04InetAddress类<br>  <em>A:InetAddress类<br>     /</em><br>      *  表示互联网中的IP地址<br>      *    java.net.InetAddress<br>      *  静态方法<br>      *    static InetAddress  getLocalHost()   LocalHost本地主机<br>      *    返回本地主机,返回值InetAddress对象<br>      *<br>      *    static InetAddress getByName(String hostName)传递主机名,获取IP地址对象<br>      *<br>      *  非静态方法<br>      *     String getHoustAddress()获取主机IP地址<br>      *     String getHoustName()获取主机名<br>      *<br>      <em>/<br>     public class InetAddressDemo {<br>      public static void main(String[] args)throws UnknownHostException {<br>        function_1();<br>      }<br>      /</em><br>       * static InetAddress getByName(String hostName)传递主机名,获取IP地址对象<br>       */<br>      public static void function_1()throws UnknownHostException {<br>        InetAddress inet = InetAddress.getByName(“<a href="http://www.baidu.com&quot;" target="_blank" rel="noopener">www.baidu.com&quot;</a>);<br>        System.out.println(inet);<br>      }</p>
<pre><code> /*
  *  static InetAddress  getLocalHost()   LocalHost本地主机
  */
 public static void function() throws UnknownHostException{
   InetAddress inet = InetAddress.getLocalHost();
   //输出结果就是主机名,和 IP地址
   System.out.println(inet.toString());

   String ip = inet.getHostAddress();
   String name = inet.getHostName();
   System.out.println(ip+&quot;   &quot;+name);

   /*String host = inet.toString();
   String[] str = host.split(&quot;/&quot;);
   for(String s : str){
     System.out.println(s);
   }*/
 }
}</code></pre><p>###05UDP协议<br>   A:UDP协议<br>     a:UDP协议概述:<br>      UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。<br>      简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。<br>     b:UDP协议特点:<br>      由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，<br>      因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p>
<p>###06TCP协议<br>  *A:TCP协议<br>    TCP协议是面向连接的通信协议，即在传输数据前先在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。<br>    在TCP连接中必须要明确客户端与服务器端，<br>      由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。<br>      第一次握手，客户端向服务器端发出连接请求，等待服务器确认<br>      第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求<br>      第三次握手，客户端再次向服务器端发送确认信息，确认连接</p>
<p>========================================第二节课=========================================<br>###07数据包和发送对象介绍<br>  *A:数据包和发送对象介绍:<br>    DatagramPacket数据包的作用就如同是“集装箱”，<br>       可以将发送端或者接收端的数据封装起来。然而运输货物只有“集装箱”是不够的，还需要有码头。<br>       在程序中需要实现通信只有DatagramPacket数据包也同样不行，为此JDK中提供的一个DatagramSocket类。<br>       DatagramSocket类的作用就类似于码头，使用这个类的实例对象就可以发送和接收DatagramPacket数据包<br>    DatagramPacket:封装数据<br>    DatagramSocket:发送DatagramPacket</p>
<p>###08UDP发送端<br>   <em>A:UDP发送端<br>         /</em><br>        *  实现UDP协议的发送端:<br>        *    实现封装数据的类 java.net.DatagramPacket  将你的数据包装<br>        *    实现数据传输的类 java.net.DatagramSocket  将数据包发出去<br>        *<br>        *  实现步骤:<br>        *    1. 创建DatagramPacket对象,封装数据, 接收的地址和端口<br>        *    2. 创建DatagramSocket<br>        *    3. 调用DatagramSocket类方法send,发送数据包<br>        *    4. 关闭资源<br>        *<br>        *    DatagramPacket构造方法:<br>        *      DatagramPacket(byte[] buf, int length, InetAddress address, int port)<br>        *<br>        *    DatagramSocket构造方法:<br>        *      DatagramSocket()空参数<br>        *      方法: send(DatagramPacket d)<br>        *<br>        */<br>       public class UDPSend {<br>        public static void main(String[] args) throws IOException{<br>          //创建数据包对象,封装要发送的数据,接收端IP,端口<br>          byte[] date = “你好UDP”.getBytes();<br>          //创建InetAddress对象,封装自己的IP地址<br>          InetAddress inet = InetAddress.getByName(“127.0.0.1”);<br>          DatagramPacket dp = new DatagramPacket(date, date.length, inet,6000);<br>          //创建DatagramSocket对象,数据包的发送和接收对象<br>          DatagramSocket ds = new DatagramSocket();<br>          //调用ds对象的方法send,发送数据包<br>          ds.send(dp);<br>          //关闭资源<br>          ds.close();<br>        }<br>       }</p>
<p>###09UDP接收端<br>   <em>A:UDP接收端<br>       /</em><br>        *  实现UDP接收端<br>        *    实现封装数据包 java.net.DatagramPacket 将数据接收<br>        *    实现输出传输     java.net.DatagramSocket 接收数据包<br>        *<br>        *  实现步骤:<br>        *     1. 创建DatagramSocket对象,绑定端口号<br>        *         要和发送端端口号一致<br>        *     2. 创建字节数组,接收发来的数据<br>        *     3. 创建数据包对象DatagramPacket<br>        *     4. 调用DatagramSocket对象方法<br>        *        receive(DatagramPacket dp)接收数据,数据放在数据包中<br>        *     5. 拆包<br>        *          发送的IP地址<br>        *            数据包对象DatagramPacket方法getAddress()获取的是发送端的IP地址对象<br>        *            返回值是InetAddress对象<br>        *          接收到的字节个数<br>        *            数据包对象DatagramPacket方法 getLength()<br>        *          发送方的端口号<br>        *            数据包对象DatagramPacket方法 getPort()发送端口<br>        *     6. 关闭资源<br>        */<br>       public class UDPReceive {<br>        public static void main(String[] args)throws IOException {<br>          //创建数据包传输对象DatagramSocket 绑定端口号<br>          DatagramSocket ds = new DatagramSocket(6000);<br>          //创建字节数组<br>          byte[] data = new byte[1024];<br>          //创建数据包对象,传递字节数组<br>          DatagramPacket dp = new DatagramPacket(data, data.length);<br>          //调用ds对象的方法receive传递数据包<br>          ds.receive(dp);</p>
<pre><code> }
}</code></pre><p>###10UDP接收端的拆包<br>   *A:UDP接收端的拆包 </p>
<pre><code>/*
 *  实现UDP接收端
 *    实现封装数据包 java.net.DatagramPacket 将数据接收
 *    实现输出传输     java.net.DatagramSocket 接收数据包
 *    
 *  实现步骤:
 *     1. 创建DatagramSocket对象,绑定端口号
 *         要和发送端端口号一致
 *     2. 创建字节数组,接收发来的数据
 *     3. 创建数据包对象DatagramPacket
 *     4. 调用DatagramSocket对象方法
 *        receive(DatagramPacket dp)接收数据,数据放在数据包中
 *     5. 拆包
 *          发送的IP地址
 *            数据包对象DatagramPacket方法getAddress()获取的是发送端的IP地址对象
 *            返回值是InetAddress对象
 *          接收到的字节个数
 *            数据包对象DatagramPacket方法 getLength()
 *          发送方的端口号
 *            数据包对象DatagramPacket方法 getPort()发送端口
 *     6. 关闭资源
 */
public class UDPReceive {
  public static void main(String[] args)throws IOException {
    //创建数据包传输对象DatagramSocket 绑定端口号
    DatagramSocket ds = new DatagramSocket(6000);
    //创建字节数组
    byte[] data = new byte[1024];
    //创建数据包对象,传递字节数组
    DatagramPacket dp = new DatagramPacket(data, data.length);
    //调用ds对象的方法receive传递数据包
    ds.receive(dp);

    //获取发送端的IP地址对象
    String ip=dp.getAddress().getHostAddress();

    //获取发送的端口号
    int port = dp.getPort();

    //获取接收到的字节个数
    int length = dp.getLength();
    System.out.println(new String(data,0,length)+&quot;...&quot;+ip+&quot;:&quot;+port);
    ds.close();
  }
}</code></pre><p>###11键盘输入的聊天<br>   <em>A:键盘输入的聊天<br>    *a:发送端:<br>      /</em><br>       * 实现UDP发送,键盘输入的形式<br>       * 输入完毕,发送给接收端<br>       <em>/<br>      public class UDPSend {<br>        public static void main(String[] args) throws IOException{<br>          Scanner sc = new Scanner(System.in);<br>          DatagramSocket ds = new DatagramSocket();<br>          InetAddress inet = InetAddress.getByName(“127.0.0.1”);<br>          while(true){<br>          String message = sc.nextLine();<br>          /*if(“886”.equals(message)){<br>            break;<br>          }</em>/<br>          byte[] date = message.getBytes();<br>          DatagramPacket dp = new DatagramPacket(date, date.length, inet,6000);<br>          ds.send(dp);<br>          }<br>        //  ds.close();<br>        }<br>      }</p>
<pre><code>/*
 *  实现UDP接收端
 *  永不停歇的接收端
 */
public class UDPReceive {
 public static void main(String[] args)throws IOException {
   //创建数据包传输对象DatagramSocket 绑定端口号
   DatagramSocket ds = new DatagramSocket(6000);
   //创建字节数组
   byte[] data = new byte[1024];
   //创建数据包对象,传递字节数组
   while(true){
   DatagramPacket dp = new DatagramPacket(data, data.length);
   //调用ds对象的方法receive传递数据包
   ds.receive(dp);

   //获取发送端的IP地址对象
   String ip=dp.getAddress().getHostAddress();

   //获取发送的端口号
   int port = dp.getPort();

   //获取接收到的字节个数
   int length = dp.getLength();
   System.out.println(new String(data,0,length)+&quot;...&quot;+ip+&quot;:&quot;+port);
   }
   //ds.close();
 }
}</code></pre><p>=======================第三节课======================================<br>###12TCP的客户端和服务器<br>   *A:TCP的客户端和服务器<br>      TCP通信同UDP通信一样，都能实现两台计算机之间的通信，通信的两端都需要创建socket对象。<br>      区别在于，UDP中只有发送端和接收端，不区分客户端与服务器端，计算机之间可以任意地发送数据。<br>      而TCP通信是严格区分客户端与服务器端的，在通信时，必须先由客户端去连接服务器端才能实现通信，<br>      服务器端不可以主动连接客户端，并且服务器端程序需要事先启动，等待客户端的连接。<br>      在JDK中提供了两个类用于实现TCP程序，一个是ServerSocket类，用于表示服务器端，一个是Socket类，用于表示客户端。<br>      通信时，首先创建代表服务器端的ServerSocket对象，该对象相当于开启一个服务，并等待客户端的连接，然后创建代表客户端的Socket对象向服务器端发出连接请求，服务器端响应请求，两者建立连接开始通信。</p>
<p>###13TCP的客户端程序<br>  <em>A:TCP的客户端程序<br>   /</em><br>    *  实现TCP客户端,连接到服务器<br>    *  和服务器实现数据交换<br>    *  实现TCP客户端程序的类 java.net.Socket<br>    *<br>    *  构造方法:<br>    *      Socket(String host, int port)  传递服务器IP和端口号<br>    *      注意:构造方法只要运行,就会和服务器进行连接,连接失败,抛出异常<br>    *<br>    *    OutputStream  getOutputStream() 返回套接字的输出流<br>    *      作用: 将数据输出,输出到服务器<br>    *<br>    *    InputStream getInputStream() 返回套接字的输入流<br>    *      作用: 从服务器端读取数据<br>    *<br>    *    客户端服务器数据交换,必须使用套接字对象Socket中的获取的IO流,自己new流,不行<br>    */<br>   public class TCPClient {<br>    public static void main(String[] args)throws IOException {<br>      //创建Socket对象,连接服务器<br>      Socket socket = new Socket(“127.0.0.1”, 8888);<br>      //通过客户端的套接字对象Socket方法,获取字节输出流,将数据写向服务器<br>      OutputStream out = socket.getOutputStream();<br>      out.write(“服务器OK”.getBytes());</p>
<pre><code>  socket.close();
}</code></pre><p>   }</p>
<p>###14TCP的服务器程序accept方法<br>   A:TCP的服务器程序accept方法<br>     /*<br>      *  实现TCP服务器程序<br>      *  表示服务器程序的类 java.net.ServerSocket<br>      *  构造方法:<br>      *    ServerSocket(int port) 传递端口号<br>      *<br>      *  很重要的事情: 必须要获得客户端的套接字对象Socket<br>      *    Socket  accept()<br>      */<br>     public class TCPServer {<br>      public static void main(String[] args) throws IOException{<br>        ServerSocket server = new ServerSocket(8888);<br>        //调用服务器套接字对象中的方法accept() 获取客户端套接字对象<br>        Socket socket = server.accept();<br>        //通过客户端套接字对象,socket获取字节输入流,读取的是客户端发送来的数据<br>        InputStream in = socket.getInputStream();<br>        byte[] data = new byte[1024];<br>        int len = in.read(data);<br>        System.out.println(new String(data,0,len));</p>
<pre><code>   socket.close();
   server.close();
 }
}</code></pre><p>###15TCP的服务器程序读取客户端数据<br>   A:TCP的服务器程序读取客户端数据</p>
<pre><code>/*
 *  实现TCP客户端,连接到服务器
 *  和服务器实现数据交换
 *  实现TCP客户端程序的类 java.net.Socket
 *  
 *  构造方法:
 *      Socket(String host, int port)  传递服务器IP和端口号
 *      注意:构造方法只要运行,就会和服务器进行连接,连接失败,抛出异常
 *      
 *    OutputStream  getOutputStream() 返回套接字的输出流
 *      作用: 将数据输出,输出到服务器
 *      
 *    InputStream getInputStream() 返回套接字的输入流
 *      作用: 从服务器端读取数据
 *      
 *    客户端服务器数据交换,必须使用套接字对象Socket中的获取的IO流,自己new流,不行
 */
public class TCPClient {
  public static void main(String[] args)throws IOException {
    //创建Socket对象,连接服务器
    Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888);
    //通过客户端的套接字对象Socket方法,获取字节输出流,将数据写向服务器
    OutputStream out = socket.getOutputStream();
    out.write(&quot;服务器OK&quot;.getBytes());
    socket.close();
  }
}
/*
 *  实现TCP服务器程序
 *  表示服务器程序的类 java.net.ServerSocket
 *  构造方法:
 *    ServerSocket(int port) 传递端口号
 *  
 *  很重要的事情: 必须要获得客户端的套接字对象Socket
 *    Socket  accept()
 */
public class TCPServer {
  public static void main(String[] args) throws IOException{
    ServerSocket server = new ServerSocket(8888);
    //调用服务器套接字对象中的方法accept() 获取客户端套接字对象
    Socket socket = server.accept();
    //通过客户端套接字对象,socket获取字节输入流,读取的是客户端发送来的数据
    InputStream in = socket.getInputStream();
    byte[] data = new byte[1024];
    int len = in.read(data);
    System.out.println(new String(data,0,len));

  }
}</code></pre><p>###16TCP的服务器和客户端的数据交换<br>   A:TCP的服务器和客户端的数据交换<br>      /*<br>       *  实现TCP客户端,连接到服务器<br>       *  和服务器实现数据交换<br>       *  实现TCP客户端程序的类 java.net.Socket<br>       *<br>       *  构造方法:<br>       *      Socket(String host, int port)  传递服务器IP和端口号<br>       *      注意:构造方法只要运行,就会和服务器进行连接,连接失败,抛出异常<br>       *<br>       *    OutputStream  getOutputStream() 返回套接字的输出流<br>       *      作用: 将数据输出,输出到服务器<br>       *<br>       *    InputStream getInputStream() 返回套接字的输入流<br>       *      作用: 从服务器端读取数据<br>       *<br>       *    客户端服务器数据交换,必须使用套接字对象Socket中的获取的IO流,自己new流,不行<br>       */<br>      public class TCPClient {<br>        public static void main(String[] args)throws IOException {<br>          //创建Socket对象,连接服务器<br>          Socket socket = new Socket(“127.0.0.1”, 8888);<br>          //通过客户端的套接字对象Socket方法,获取字节输出流,将数据写向服务器<br>          OutputStream out = socket.getOutputStream();<br>          out.write(“服务器OK”.getBytes());</p>
<pre><code>    //读取服务器发回的数据,使用socket套接字对象中的字节输入流
    InputStream in = socket.getInputStream();
    byte[] data = new byte[1024];
    int len = in.read(data);
    System.out.println(new String(data,0,len));

    socket.close();
  }
}
/*
 *  实现TCP服务器程序
 *  表示服务器程序的类 java.net.ServerSocket
 *  构造方法:
 *    ServerSocket(int port) 传递端口号
 *  
 *  很重要的事情: 必须要获得客户端的套接字对象Socket
 *    Socket  accept()
 */
public class TCPServer {
  public static void main(String[] args) throws IOException{
    ServerSocket server = new ServerSocket(8888);
    //调用服务器套接字对象中的方法accept() 获取客户端套接字对象
    Socket socket = server.accept();
    //通过客户端套接字对象,socket获取字节输入流,读取的是客户端发送来的数据
    InputStream in = socket.getInputStream();
    byte[] data = new byte[1024];
    int len = in.read(data);
    System.out.println(new String(data,0,len));

    //服务器向客户端回数据,字节输出流,通过客户端套接字对象获取字节输出流
    OutputStream out = socket.getOutputStream();
    out.write(&quot;收到,谢谢&quot;.getBytes());

    socket.close();
    server.close();
  }
}</code></pre><p>###17TCP的中的流对象<br>    *A:TCP的中的流对象<br>        参见图解TCP中的流对象.jpg  </p>
<p>======================================第四节课=================================================<br>###18TCP图片上传案例分析<br>    *A:图片上传案例分析<br>         参见图解TCP上传图片案例.jpg  </p>
<p>###19TCP上传客户端<br>   <em>A TCP上传客户端<br>   /</em><br>    *  实现TCP图片上传客户端<br>    *  实现步骤:<br>    *    1. Socket套接字连接服务器<br>    *    2. 通过Socket获取字节输出流,写图片<br>    *    3. 使用自己的流对象,读取图片数据源<br>    *         FileInputStream<br>    *    4. 读取图片,使用字节输出流,将图片写到服务器<br>    *       采用字节数组进行缓冲<br>    *    5. 通过Socket套接字获取字节输入流<br>    *       读取服务器发回来的上传成功<br>    *    6. 关闭资源<br>    */<br>   public class TCPClient {<br>    public static void main(String[] args) throws IOException{<br>      Socket socket = new Socket(“127.0.0.1”, 8000);<br>      //获取字节输出流,图片写到服务器<br>      OutputStream out = socket.getOutputStream();<br>      //创建字节输入流,读取本机上的数据源图片<br>      FileInputStream fis = new FileInputStream(“c:\t.jpg”);<br>      //开始读写字节数组<br>      int len = 0 ;<br>      byte[] bytes = new byte[1024];<br>      while((len = fis.read(bytes))!=-1){<br>        out.write(bytes, 0, len);<br>      }<br>      //给服务器写终止序列<br>      //socket.shutdownOutput();</p>
<pre><code>  //获取字节输入流,读取服务器的上传成功
  InputStream in = socket.getInputStream();

  len = in.read(bytes);
  System.out.println(new String(bytes,0,len));

  fis.close();
  socket.close();
}</code></pre><p>   }<br>###20TCP上传服务器<br>   A:TCP上传服务器<br>   /*<br>    *  TCP图片上传服务器<br>    *   1. ServerSocket套接字对象,监听端口8000<br>    *   2. 方法accept()获取客户端的连接对象<br>    *   3. 客户端连接对象获取字节输入流,读取客户端发送图片<br>    *   4. 创建File对象,绑定上传文件夹<br>    *       判断文件夹存在, 不存,在创建文件夹<br>    *   5. 创建字节输出流,数据目的File对象所在文件夹<br>    *   6. 字节流读取图片,字节流将图片写入到目的文件夹中<br>    *   7. 将上传成功会写客户端<br>    *   8. 关闭资源<br>    *<br>    */<br>   public class TCPServer {<br>    public static void main(String[] args) throws IOException{<br>      ServerSocket server = new ServerSocket(8000);<br>      Socket socket = server.accept();<br>      //通过客户端连接对象,获取字节输入流,读取客户端图片<br>      InputStream in = socket.getInputStream();<br>      //将目的文件夹封装到File对象<br>      File upload = new File(“d:\upload”);<br>      if(!upload.exists())<br>        upload.mkdirs();</p>
<pre><code>  //创建字节输出流,将图片写入到目的文件夹中                         
  FileOutputStream fos = new FileOutputStream(upload+&quot;t.jpg&quot;);
  //读写字节数组
  byte[] bytes = new byte[1024];
  int len = 0 ;
  while((len = in.read(bytes))!=-1){
    fos.write(bytes, 0, len);
  }
  //通过客户端连接对象获取字节输出流
  //上传成功写回客户端
  socket.getOutputStream().write(&quot;上传成功&quot;.getBytes());

  fos.close();
  socket.close();
  server.close();
}</code></pre><p>   }<br>###21TCP图片上传问题解决<br>/*</p>
<ul>
<li><p>实现TCP图片上传客户端</p>
</li>
<li><p>实现步骤:</p>
</li>
<li><ol>
<li>Socket套接字连接服务器</li>
</ol>
</li>
<li><ol start="2">
<li>通过Socket获取字节输出流,写图片</li>
</ol>
</li>
<li><ol start="3">
<li>使用自己的流对象,读取图片数据源</li>
</ol>
</li>
<li><p>FileInputStream</p>
</li>
<li><ol start="4">
<li>读取图片,使用字节输出流,将图片写到服务器</li>
</ol>
</li>
<li><p>采用字节数组进行缓冲</p>
</li>
<li><ol start="5">
<li>通过Socket套接字获取字节输入流</li>
</ol>
</li>
<li><p>读取服务器发回来的上传成功</p>
</li>
<li><ol start="6">
<li>关闭资源</li>
</ol>
</li>
<li><p>/<br>public class TCPClient {<br>  public static void main(String[] args) throws IOException{<br>  Socket socket = new Socket(“127.0.0.1”, 8000);<br>  //获取字节输出流,图片写到服务器<br>  OutputStream out = socket.getOutputStream();<br>  //创建字节输入流,读取本机上的数据源图片<br>  FileInputStream fis = new FileInputStream(“c:\t.jpg”);<br>  //开始读写字节数组<br>  int len = 0 ;<br>  byte[] bytes = new byte[1024];<br>  while((len = fis.read(bytes))!=-1){</p>
<pre><code>out.write(bytes, 0, len);</code></pre><p>  }<br>  //给服务器写终止序列<br>  socket.shutdownOutput();//想服务端写入一个结束标志</p>
<p>  //获取字节输入流,读取服务器的上传成功<br>  InputStream in = socket.getInputStream();</p>
<p>  len = in.read(bytes);<br>  System.out.println(new String(bytes,0,len));</p>
<p>  fis.close();<br>  socket.close();<br>  }<br>}</p>
</li>
</ul>
<p>###TCP上传文件名<br>  <em>A:TCP上传文件名<br>   /</em><br>    *  TCP图片上传服务器<br>    *   1. ServerSocket套接字对象,监听端口8000<br>    *   2. 方法accept()获取客户端的连接对象<br>    *   3. 客户端连接对象获取字节输入流,读取客户端发送图片<br>    *   4. 创建File对象,绑定上传文件夹<br>    *       判断文件夹存在, 不存,在创建文件夹<br>    *   5. 创建字节输出流,数据目的File对象所在文件夹<br>    *   6. 字节流读取图片,字节流将图片写入到目的文件夹中<br>    *   7. 将上传成功会写客户端<br>    *   8. 关闭资源<br>    *<br>    */<br>   public class TCPServer {<br>    public static void main(String[] args) throws IOException{<br>      ServerSocket server = new ServerSocket(8000);<br>      Socket socket = server.accept();<br>      //通过客户端连接对象,获取字节输入流,读取客户端图片<br>      InputStream in = socket.getInputStream();<br>      //将目的文件夹封装到File对象<br>      File upload = new File(“d:\upload”);<br>      if(!upload.exists())<br>        upload.mkdirs();</p>
<pre><code>  //防止文件同名被覆盖,从新定义文件名字
  //规则:  域名+毫秒值+6位随机数
  String filename=&quot;itcast&quot;+System.currentTimeMillis()+new Random().nextInt(999999)+&quot;.jpg&quot;;
  //创建字节输出流,将图片写入到目的文件夹中                         
  FileOutputStream fos = new FileOutputStream(upload+File.separator+filename);
  //读写字节数组
  byte[] bytes = new byte[1024];
  int len = 0 ;
  while((len = in.read(bytes))!=-1){
    fos.write(bytes, 0, len);
  }
  //通过客户端连接对象获取字节输出流
  //上传成功写回客户端
  socket.getOutputStream().write(&quot;上传成功&quot;.getBytes());

  fos.close();
  socket.close();
  server.close();
}</code></pre><p>   }</p>
<p>###多线程上传案例<br>*A:多线程上传案例<br>  public class TCPThreadServer {<br>    public static void main(String[] args) throws IOException {<br>      ServerSocket server = new ServerSocket(8000);<br>      while (true) {<br>        // 获取到一个客户端,必须开启新线程,为这个客户端服务<br>        Socket socket = server.accept();<br>        new Thread(new Upload(socket)).start();<br>      }<br>    }<br>  }</p>
<p>  public class Upload implements Runnable {</p>
<pre><code>private Socket socket;

public Upload(Socket socket) {
  this.socket = socket;
}

public void run() {
  try {
    // 通过客户端连接对象,获取字节输入流,读取客户端图片
    InputStream in = socket.getInputStream();
    // 将目的文件夹封装到File对象
    File upload = new File(&quot;d:\\upload&quot;);
    if (!upload.exists())
      upload.mkdirs();

    // 防止文件同名被覆盖,从新定义文件名字
    // 规则: 域名+毫秒值+6位随机数
    String filename = &quot;itcast&quot; + System.currentTimeMillis() + new Random().nextInt(999999) + &quot;.jpg&quot;;
    // 创建字节输出流,将图片写入到目的文件夹中
    FileOutputStream fos = new FileOutputStream(upload + File.separator + filename);
    // 读写字节数组
    byte[] bytes = new byte[1024];
    int len = 0;
    while ((len = in.read(bytes)) != -1) {
      fos.write(bytes, 0, len);
    }
    // 通过客户端连接对象获取字节输出流
    // 上传成功写回客户端
    socket.getOutputStream().write(&quot;上传成功&quot;.getBytes());

    fos.close();
    socket.close();
  } catch (Exception ex) {

  }
}</code></pre><p>  }</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day27%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day27%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记27</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:12:58" itemprop="dateModified" datetime="2020-12-23T23:12:58+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、多线程安全问题<br>2、等待唤醒机制</p>
<p>=======================第一节课开始=============================================</p>
<p>###01线程操作共享数据的安全问题<br>  *A:线程操作共享数据的安全问题<br>    如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。<br>    程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<p>###02售票的案例<br> <em>A:售票的案例<br>     /</em><br>      * 多线程并发访问同一个数据资源<br>      * 3个线程,对一个票资源,出售<br>      */<br>     public class ThreadDemo {<br>      public static void main(String[] args) {<br>        //创建Runnable接口实现类对象<br>        Tickets t = new Tickets();<br>        //创建3个Thread类对象,传递Runnable接口实现类<br>        Thread t0 = new Thread(t);<br>        Thread t1 = new Thread(t);<br>        Thread t2 = new Thread(t);</p>
<pre><code>   t0.start();
   t1.start();
   t2.start();

 }
}

public class Tickets implements Runnable{

 //定义出售的票源
 private int ticket = 100;
 private Object obj = new Object();

 public void run(){
   while(true){

       if( ticket &gt; 0){

         System.out.println(Thread.currentThread().getName()+&quot; 出售第 &quot;+ticket--);
       }

   }
 }
}</code></pre><p>###03线程安全问题引发<br> <em>A:线程安全问题引发<br>    /</em><br>     * 多线程并发访问同一个数据资源<br>     * 3个线程,对一个票资源,出售<br>     */<br>    public class ThreadDemo {<br>     public static void main(String[] args) {<br>       //创建Runnable接口实现类对象<br>       Tickets t = new Tickets();<br>       //创建3个Thread类对象,传递Runnable接口实现类<br>       Thread t0 = new Thread(t);<br>       Thread t1 = new Thread(t);<br>       Thread t2 = new Thread(t);</p>
<pre><code>   t0.start();
   t1.start();
   t2.start();

 }
}
/*
 *  通过线程休眠,出现安全问题
 */
public class Tickets implements Runnable{

 //定义出售的票源
 private int ticket = 100;
 private Object obj = new Object();

 public void run(){
   while(true){

     //对票数判断,大于0,可以出售,变量--操作
       if( ticket &gt; 0){
         try{
            Thread.sleep(10); //加了休眠让其他线程有执行机会
         }catch(Exception ex){}
         System.out.println(Thread.currentThread().getName()+&quot; 出售第 &quot;+ticket--);
       }
   }
 }
}</code></pre><p>###04同步代码块解决线程安全问题<br>  <em>A:同步代码块解决线程安全问题<br>      *A:售票的案例<br>          /</em><br>           * 多线程并发访问同一个数据资源<br>           * 3个线程,对一个票资源,出售<br>           */<br>          public class ThreadDemo {<br>           public static void main(String[] args) {<br>             //创建Runnable接口实现类对象<br>             Tickets t = new Tickets();<br>             //创建3个Thread类对象,传递Runnable接口实现类<br>             Thread t0 = new Thread(t);<br>             Thread t1 = new Thread(t);<br>             Thread t2 = new Thread(t);</p>
<pre><code>   t0.start();
   t1.start();
   t2.start();

 }
}
/*
 *  通过线程休眠,出现安全问题
 *  解决安全问题,Java程序,提供技术,同步技术
 *  公式:
 *    synchronized(任意对象){
 *      线程要操作的共享数据
 *    }
 *    同步代码块
 */
public class Tickets implements Runnable{

 //定义出售的票源
 private int ticket = 100;
 private Object obj = new Object();

 public void run(){
   while(true){
     //线程共享数据,保证安全,加入同步代码块
     synchronized(obj){
     //对票数判断,大于0,可以出售,变量--操作
       if( ticket &gt; 0){
         try{
            Thread.sleep(10);
         }catch(Exception ex){}
         System.out.println(Thread.currentThread().getName()+&quot; 出售第 &quot;+ticket--);
       }
     }
   }
 }
}</code></pre><p>###05同步代码块的执行原理<br>   A:同步代码块的执行原理<br>     同步代码块: 在代码块声明上 加上synchronized<br>     synchronized (锁对象) {<br>       可能会产生线程安全问题的代码<br>     }<br>     同步代码块中的锁对象可以是任意的对象；但多个线程时，要使用同一个锁对象才能够保证线程安全。</p>
<p>=======================第二节课开始=============================================<br>###06同步的上厕所原理<br>  *A:同步的上厕所原理<br>    a:不使用同步:线程在执行的过程中会被打扰<br>       线程比喻成人<br>       线程执行代码就是上一个厕所<br>      第一个人正在上厕所,上到一半,被另外一个人拉出来<br>    b:使用同步:<br>       线程比喻成人<br>       线程执行代码就是上一个厕所<br>       锁比喻成厕所门<br>      第一个人上厕所,会锁门<br>      第二个人上厕所,看到门锁上了,等待第一个人上完再去上厕所</p>
<p>###07同步方法<br>  <em>A:同步方法:<br>  /</em></p>
<ul>
<li><p>多线程并发访问同一个数据资源</p>
</li>
<li><p>3个线程,对一个票资源,出售<br> */<br>public class ThreadDemo {</p>
<p>public static void main(String[] args) {<br> //创建Runnable接口实现类对象<br> Tickets t = new Tickets();<br> //创建3个Thread类对象,传递Runnable接口实现类<br> Thread t0 = new Thread(t);<br> Thread t1 = new Thread(t);<br> Thread t2 = new Thread(t);</p>
<p> t0.start();<br> t1.start();<br> t2.start();</p>
<p>}<br>}</p>
<p><em>A:同步方法<br>/</em></p>
<ul>
<li><p>采用同步方法形式,解决线程的安全问题</p>
</li>
<li><p>好处: 代码简洁</p>
</li>
<li><p>将线程共享数据,和同步,抽取到一个方法中</p>
</li>
<li><p>在方法的声明上,加入同步关键字</p>
</li>
<li></li>
<li><p>问题:</p>
</li>
<li><p>同步方法有锁吗,肯定有,同步方法中的对象锁,是本类对象引用 this</p>
</li>
<li><p>如果方法是静态的呢,同步有锁吗,绝对不是this</p>
</li>
<li><p>锁是本类自己.class 属性</p>
</li>
<li><p>静态方法,同步锁,是本类类名.class属性</p>
</li>
<li><p>/<br>public class Tickets implements Runnable{</p>
<p>//定义出售的票源<br>private  int ticket = 100;</p>
<p>public void run(){<br> while(true){<br>   payTicket();<br> }<br>}</p>
<p>public  synchronized void payTicket(){<br>   if( ticket &gt; 0){</p>
<pre><code>try{
   Thread.sleep(10);
}catch(Exception ex){}
System.out.println(Thread.currentThread().getName()+&quot; 出售第 &quot;+ticket--);</code></pre><p>   }</p>
<p>}<br>}</p>
</li>
</ul>
</li>
</ul>
<p>###08JDK1.5新特性Lock接口<br>   *A:JDK1.5新特性Lock接口<br>        查阅API，查阅Lock接口描述，Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。<br>       Lock接口中的常用方法<br>            void lock()<br>            void unlock()<br>      Lock提供了一个更加面对对象的锁，在该锁中提供了更多的操作锁的功能。<br>      我们使用Lock接口,以及其中的lock()方法和unlock()方法替代同步，对电影院卖票案例中Ticket</p>
<p>###09Lock接口改进售票案例<br>   <em>A:Lock接口改进售票案例<br>      /</em><br>       * 多线程并发访问同一个数据资源<br>       * 3个线程,对一个票资源,出售<br>       */<br>      public class ThreadDemo {<br>        public static void main(String[] args) {<br>          //创建Runnable接口实现类对象<br>          Tickets t = new Tickets();<br>          //创建3个Thread类对象,传递Runnable接口实现类<br>          Thread t0 = new Thread(t);<br>          Thread t1 = new Thread(t);<br>          Thread t2 = new Thread(t);</p>
<pre><code>    t0.start();
    t1.start();
    t2.start();

  }
}
/*
 *  使用JDK1.5 的接口Lock,替换同步代码块,实现线程的安全性
 *  Lock接口方法:
 *     lock() 获取锁
 *     unlock()释放锁
 *  实现类ReentrantLock
 */
public class Tickets implements Runnable{

  //定义出售的票源
  private int ticket = 100;
  //在类的成员位置,创建Lock接口的实现类对象
  private Lock lock = new ReentrantLock();

  public void run(){
    while(true){
      //调用Lock接口方法lock获取锁
        lock.lock();
      //对票数判断,大于0,可以出售,变量--操作
        if( ticket &gt; 0){
          try{
             Thread.sleep(10);
             System.out.println(Thread.currentThread().getName()+&quot; 出售第 &quot;+ticket--);
          }catch(Exception ex){

          }finally{
            //释放锁,调用Lock接口方法unlock
            lock.unlock();
          }
        }
    }
  }
}</code></pre><p>=======================第三节课开始=============================================<br>###10线程的死锁原理<br>   *A:线程的死锁原理<br>     当线程任务中出现了多个同步(多个锁)  时，如果同步中嵌套了其他的同步。这时容易引发一种现象：程序出现无限等待，这种现象我们称为死锁。这种情况能避免就避免掉。<br>        synchronzied(A锁){<br>            synchronized(B锁){</p>
<pre><code>    }
}</code></pre><p>###11线程的死锁代码实现<br>   *A:线程的死锁代码实现<br>       public class DeadLock implements Runnable{<br>        private int i = 0;<br>        public void run(){<br>          while(true){<br>            if(i%2==0){<br>              //先进入A同步,再进入B同步<br>              synchronized(LockA.locka){<br>                System.out.println(“if…locka”);<br>                synchronized(LockB.lockb){<br>                  System.out.println(“if…lockb”);<br>                }<br>              }<br>            }else{<br>              //先进入B同步,再进入A同步<br>              synchronized(LockB.lockb){<br>                System.out.println(“else…lockb”);<br>                synchronized(LockA.locka){<br>                  System.out.println(“else…locka”);<br>                }<br>              }<br>            }<br>            i++;<br>          }<br>        }<br>       }</p>
<pre><code>public class DeadLockDemo {
  public static void main(String[] args) {
    DeadLock dead = new DeadLock();
    Thread t0 = new Thread(dead);
    Thread t1 = new Thread(dead);
    t0.start();
    t1.start();
  }
}


public class LockA {
  private LockA(){}

  public  static final LockA locka = new LockA();
}</code></pre><p>​<br>      public class LockB {<br>        private LockB(){}</p>
<pre><code>  public static final LockB lockb = new LockB();
}</code></pre><p> ###12线程等待与唤醒案例介绍<br>   *A:线程等待与唤醒案例介绍<br>     等待唤醒机制所涉及到的方法：<br>         wait（） :等待，将正在执行的线程释放其执行资格 和 执行权，并存储到线程池中。<br>         notify（）：唤醒，唤醒线程池中被wait（）的线程，一次唤醒一个，而且是任意的。<br>         notifyAll（）： 唤醒全部：可以将线程池中的所有wait() 线程都唤醒。<br>       其实，所谓唤醒的意思就是让 线程池中的线程具备执行资格。必须注意的是，这些方法都是在 同步中才有效。同时这些方法在使用时必须标明所属锁，这样才可以明确出这些方法操作的到底是哪个锁上的线程。</p>
<p>###13线程等待与唤醒案例资源类编写<br>  <em>A:线程等待与唤醒案例资源类编写<br>    /</em><br>     *  定义资源类,有2个成员变量<br>     *  name,sex<br>     *  同时有2个线程,对资源中的变量操作<br>     *  1个对name,age赋值<br>     *  2个对name,age做变量的输出打印<br>     */<br>    public class Resource {<br>      public String name;<br>      public String sex;<br>    }</p>
<p>###14线程等待与唤醒案例输入和输出线程<br>   A:线程等待与唤醒案例输入和输出线程<br>     /*<br>       *  输入的线程,对资源对象Resource中成员变量赋值<br>       *  一次赋值 张三,男<br>       *  下一次赋值 lisi,nv<br>     */<br>      public class Input implements Runnable {<br>        private Resource r=new Resource();</p>
<pre><code>  public void run() {
    int i=0;
    while(true){
      if(i%2==0){
         r.name=&quot;张三&quot;;
         r.sex=&quot;男&quot;;
       }else{
          r.name=&quot;lisi&quot;;
          r.sex=&quot;女&quot;;
        }
      i++;
    }
  }
}

/*
 *  输出线程,对资源对象Resource中成员变量,输出值
 */
public class Output implements Runnable {
  private Resource r=new Resource() ;

  public void run() {
    while(true){
       System.out.println(r.name+&quot;...&quot;+r.sex); 
      }
    }
}</code></pre><p>=================================第四节课=========================================<br>###15线程等待与唤醒案例测试类<br>   A:线程等待与唤醒案例测试类<br>      /*<br>       *  开启输入线程和输出线程,实现赋值和打印值<br>       */<br>      public class ThreadDemo{<br>        public static void main(String[] args) {</p>
<pre><code>    Resource r = new Resource();

    Input in = new Input();
    Output out = new Output();

    Thread tin = new Thread(in);
    Thread tout = new Thread(out);

    tin.start();
    tout.start();
  }
}</code></pre><p>###16线程等待与唤醒案例null值解决<br>   A:线程等待与唤醒案例null值解决<br>        /*<br>        *  输入的线程,对资源对象Resource中成员变量赋值<br>        *  一次赋值 张三,男<br>        *  下一次赋值 lisi,nv<br>      */<br>       public class Input implements Runnable {<br>         private Resource r;<br>         public Input(Resource r){<br>           this.r=r;<br>         }</p>
<pre><code>  public void run() {
    int i=0;
    while(true){
      if(i%2==0){
         r.name=&quot;张三&quot;;
         r.sex=&quot;男&quot;;
       }else{
          r.name=&quot;lisi&quot;
          r.sex=&quot;女&quot;
        }
      i++;
    }
  }
}

/*
 *  输出线程,对资源对象Resource中成员变量,输出值
 */ 
public class Output implements Runnable {
  private Resource r;
  public Output(Resource r){
     this.r=r;
  } 
  public void run() {
    while(true){
       System.out.println(r.name+&quot;...&quot;+r.sex); 
      }
    }
  }

}
/*
 *  开启输入线程和输出线程,实现赋值和打印值
 */
public class ThreadDemo{
  public static void main(String[] args) {

    Resource r = new Resource();

    Input in = new Input(r);
    Output out = new Output(r);

    Thread tin = new Thread(in);
    Thread tout = new Thread(out);

    tin.start();
    tout.start();
  }
}</code></pre><p>###17线程等待与唤醒案例数据安全解决<br>    A:线程等待与唤醒案例数据安全解决<br>            /*<br>              *  输入的线程,对资源对象Resource中成员变量赋值<br>              *  一次赋值 张三,男<br>              *  下一次赋值 lisi,nv<br>            */<br>             public class Input implements Runnable {<br>               private Resource r;<br>               public Input(Resource r){<br>                 this.r=r;<br>               }</p>
<pre><code>  public void run() {
    int i=0;
    while(true){
     synchronized(r){
      if(i%2==0){
         r.name=&quot;张三&quot;;
         r.sex=&quot;男&quot;;
       }else{
          r.name=&quot;lisi&quot;
          r.sex=&quot;女&quot;
        }
      i++;
    }

  }
}

/*
 *  输出线程,对资源对象Resource中成员变量,输出值
 */ 
public class Output implements Runnable {
  private Resource r;
  public Output(Resource r){
     this.r=r;
  } 
  public void run() {
    while(true){
       synchronized(r){
        System.out.println(r.name+&quot;...&quot;+r.sex); 
       }
      }
    }
  }

}
/*
 *  开启输入线程和输出线程,实现赋值和打印值
 */
public class ThreadDemo{
  public static void main(String[] args) {

    Resource r = new Resource();

    Input in = new Input(r);
    Output out = new Output(r);

    Thread tin = new Thread(in);
    Thread tout = new Thread(out);

    tin.start();
    tout.start();
  }
}</code></pre><p>###18线程等待与唤醒案例通信的分析<br>    *A:线程等待与唤醒案例通信的分析<br>        输入:赋值后,执行方法wait()永远等待<br>        输出:变量值打印输出,在输出等待之前,唤醒<br>        输入的notify(),自己在wait()永远等待<br>        输入:被唤醒后,重新对变量赋值,赋值后,必须唤醒输出的线程notify(),<br>             自己的wait()</p>
<p>###19线程等待与唤醒案例的实现<br>   *A 线程等待与唤醒案例的实现</p>
<pre><code>/*
 *  定义资源类,有2个成员变量
 *  name,sex
 *  同时有2个线程,对资源中的变量操作
 *  1个对name,age赋值
 *  2个对name,age做变量的输出打印
 */
public class Resource {
 public String name;
 public String sex;
 public boolean flag = false;
}

/*
 *  输入的线程,对资源对象Resource中成员变量赋值
 *  一次赋值 张三,男
 *  下一次赋值 lisi,nv
 */
public class Input implements Runnable {
 private Resource r ;

 public Input(Resource r){
   this.r = r;
 }

 public void run() {
   int i = 0 ;
   while(true){
     synchronized(r){
       //标记是true,等待
         if(r.flag){
           try{r.wait();}catch(Exception ex){}
         }

       if(i%2==0){
         r.name = &quot;张三&quot;;
         r.sex = &quot;男&quot;;
       }else{
         r.name = &quot;lisi&quot;;
         r.sex = &quot;nv&quot;;
       }
       //将对方线程唤醒,标记改为true
       r.flag = true;
       r.notify();
     }
     i++;
   }
 }

}

/*
 *  输出线程,对资源对象Resource中成员变量,输出值
 */
public class Output implements Runnable {
 private Resource r ;

 public Output(Resource r){
   this.r = r;
 }
 public void run() {
   while(true){
     synchronized(r){  
       //判断标记,是false,等待
     if(!r.flag){
       try{r.wait();}catch(Exception ex){}
       }
     System.out.println(r.name+&quot;..&quot;+r.sex);
     //标记改成false,唤醒对方线程
     r.flag = false;
     r.notify();
     }
   }
 }

}

/*
 *  开启输入线程和输出线程,实现赋值和打印值
 */
public class ThreadDemo{
 public static void main(String[] args) {

   Resource r = new Resource();

   Input in = new Input(r);
   Output out = new Output(r);

   Thread tin = new Thread(in);
   Thread tout = new Thread(out);

   tin.start();
   tout.start();
 }
}</code></pre><p>###20eclipse问题<br>   A:eclipse问题</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day26%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day26%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记26</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:12:47" itemprop="dateModified" datetime="2020-12-23T23:12:47+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、多线程<br>2、线程池</p>
<p>=======================第一节课开始=============================================</p>
<p>###01进程概念<br>*A:进程概念<br>   *a:进程：进程指正在运行的程序。确切的来说，当一个程序进入内存运行，<br>        即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能。</p>
<p>###02线程的概念<br> *A:线程的概念<br>   *a:线程：线程是进程中的一个执行单元(执行路径)，负责当前进程中程序的执行，<br>          一个进程中至少有一个线程。一个进程中是可以有多个线程的，<br>          这个应用程序也可以称之为多线程程序。<br>    简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程</p>
<p>###03深入线程的概念<br>  A:深入线程的概念<br>    什么是多线程呢？<br>     即就是一个程序中有多个线程在同时执行。<br>     一个核心的CPU在多个线程之间进行着随即切换动作,由于切换时间很短(毫秒甚至是纳秒级别),导致我们感觉不出来</p>
<pre><code>单线程程序：即，若有多个任务只能依次执行。当上一个任务执行结束后，下一个任务开始执行。如去            网吧上网，网吧只能让一个人上网，当这个人下机后，下一个人才能上网。
多线程程序：即，若有多个任务可以同时执行。如，去网吧上网，网吧能够让多个人同时上网。</code></pre><p>###04迅雷的多线程下载<br>   A:迅雷的多线程下载<br>     多线程,每个线程都读一个文件</p>
<p>###05线程的运行模式<br>   A:线程的运行模式<br>    a:分时调度<br>      所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p>
<pre><code>b:抢占式调度
 优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。

 大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。

 实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。
 其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。</code></pre><p>###06main的主线程<br>  <em>A:main的主线程<br>    /</em><br>     *  程序中的主线程<br>     */<br>    public class Demo {<br>      public static void main(String[] args) {<br>        System.out.println(0/0);<br>        function();<br>        System.out.println(Math.abs(-9));<br>      }</p>
<pre><code>  public static void function(){
    for(int i = 0 ; i &lt; 10000;i++){
      System.out.println(i);
    }
  }
}</code></pre><p>=======================第二节课开始=============================================<br>###07Thread类介绍<br>  A:Thread类介绍:Thread是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程。<br>     发现创建新执行线程有两种方法。<br>     a:一种方法是将类声明为 Thread 的子类。该子类应重写 Thread 类的 run 方法。创建对象，开启线程。run方法相当于其他线程的main方法。<br>     b:另一种方法是声明一个实现 Runnable 接口的类。该类然后实现 run 方法。然后创建Runnable的子类对象，传入到某个线程的构造方法中，开启线程。</p>
<p>###08实现线程程序继承Thread<br>   <em>A:实现线程程序继承Thread<br>        /</em><br>       * 创建和启动一个线程<br>       *   创建Thread子类对象<br>       *   子类对象调用方法start()<br>       *      让线程程序执行,JVM调用线程中的run<br>       <em>/<br>      public class ThreadDemo {<br>        public static void main(String[] args) {<br>          SubThread st = new SubThread();<br>          SubThread st1 = new SubThread();<br>          st.start();<br>          st1.start();<br>          for(int i = 0; i &lt; 50;i++){<br>            System.out.println(“main…”+i);<br>          }<br>        }<br>      }<br>      /</em><br>       *  定义子类,继承Thread<br>       *  重写方法run<br>       */<br>      public class SubThread  extends Thread{<br>        public void run(){<br>          for(int i = 0; i &lt; 50;i++){<br>            System.out.println(“run…”+i);<br>          }<br>        }<br>      }</p>
<p>​     </p>
<p>###09线程执行的随机性<br>   <em>A:线程执行的随机性<br>    /</em><br>      代码分析:<br>         整个程序就只有三个线程,<br>         一个是主线程<br>           启动另外两个线程<br>            st.start();<br>            st1.start();<br>            for(int i = 0; i &lt; 50;i++){<br>              System.out.println(“main…”+i);<br>            }<br>         一个是st(Thread-0)线程<br>         for(int i = 0; i &lt; 50;i++){<br>           System.out.println(“run…”+i);<br>         }<br>         一个是st1(Thread-1)线程下 </p>
<pre><code>*/
 public class ThreadDemo {
   public static void main(String[] args) {
     SubThread st = new SubThread();
     SubThread st1 = new SubThread();
     st.start();
     st1.start();
     for(int i = 0; i &lt; 50;i++){
       System.out.println(&quot;main...&quot;+i);
     }
   }
 }
 /*
  *  定义子类,继承Thread 
  *  重写方法run 
  */
 public class SubThread  extends Thread{
   public void run(){
     for(int i = 0; i &lt; 50;i++){
       System.out.println(&quot;run...&quot;+i);
     }
   }
 }</code></pre><p>###10为什么要继承Thread<br>   *A:什么要继承Thread<br>    a:我们为什么要继承Thread类，并调用其的start方法才能开启线程呢？<br>       继承Thread类：因为Thread类用来描述线程，具备线程应该有功能。那为什么不直接创建Thread类的对象呢？<br>       如下代码：<br>        Thread t1 = new Thread();<br>        t1.start();//这样做没有错，但是该start调用的是Thread类中的run方法<br>                  //而这个run方法没有做什么事情，更重要的是这个run方法中并没有定义我们需要让线程执行的代码。</p>
<pre><code>b:创建线程的目的是什么？
 是为了建立程序单独的执行路径，让多部分代码实现同时执行。也就是说线程创建并执行需要给定线程要执行的任务。
 对于之前所讲的主线程，它的任务定义在main函数中。自定义线程需要执行的任务都定义在run方法中。</code></pre><p>###11多线程内存图解<br>   *A:多线程内存图解<br>      多线程执行时，到底在内存中是如何运行的呢？<br>        多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。<br>        当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。</p>
<p>=======================第三节课开始=============================================<br>###12获取线程名字Thread类方法getName<br>   <em>A:获取线程名字Thread类方法getName<br>    /</em><br>     *  获取线程名字,父类Thread方法<br>     *    String getName()<br>     */<br>    public class NameThread extends Thread{</p>
<pre><code>  public NameThread(){
    super(&quot;小强&quot;);
  }

  public void run(){
    System.out.println(getName());
  }
}

/*
 *  每个线程,都有自己的名字
 *  运行方法main线程,名字就是&quot;main&quot;
 *  其他新键的线程也有名字,默认 &quot;Thread-0&quot;,&quot;Thread-1&quot;
 *  
 *  JVM开启主线程,运行方法main,主线程也是线程,是线程必然就是
 *  Thread类对象
 */
public class ThreadDemo {
  public static void main(String[] args) {
    NameThread nt = new NameThread();
    nt.start();</code></pre><p>​         </p>
<pre><code>  }
}</code></pre><p>###13获取线程名字Thread类方法currentThread<br>  <em>A:获取线程名字Thread类方法currentThread<br>   /</em><br>    *  获取线程名字,父类Thread方法<br>    *    String getName()<br>    */<br>   public class NameThread extends Thread{</p>
<pre><code>public void run(){
  System.out.println(getName());
}</code></pre><p>   }</p>
<p>   /*<br>    *  每个线程,都有自己的名字<br>    *  运行方法main线程,名字就是”main”<br>    *  其他新键的线程也有名字,默认 “Thread-0”,”Thread-1”<br>    *<br>    *  JVM开启主线程,运行方法main,主线程也是线程,是线程必然就是<br>    *  Thread类对象<br>    *  Thread类中,静态方法<br>    *   static Thread currentThread()返回正在执行的线程对象<br>    */<br>   public class ThreadDemo {<br>     public static void main(String[] args) {<br>       NameThread nt = new NameThread();<br>       nt.start();</p>
<pre><code>  /*Thread t =Thread.currentThread();
  System.out.println(t.getName());*/
  System.out.println(Thread.currentThread().getName());


}</code></pre><p>   }</p>
<p>###14线程名字设置<br>   A:线程名字设置<br>      /*<br>       *  获取线程名字,父类Thread方法<br>       *    String getName()<br>       */<br>      public class NameThread extends Thread{</p>
<pre><code>  public NameThread(){
    super(&quot;小强&quot;);
  }

  public void run(){
    System.out.println(getName());
  }
}

/*
 *  每个线程,都有自己的名字
 *  运行方法main线程,名字就是&quot;main&quot;
 *  其他新键的线程也有名字,默认 &quot;Thread-0&quot;,&quot;Thread-1&quot;
 *  
 *  JVM开启主线程,运行方法main,主线程也是线程,是线程必然就是
 *  Thread类对象
 *  Thread类中,静态方法
 *   static Thread currentThread()返回正在执行的线程对象
 */
public class ThreadDemo {
  public static void main(String[] args) {
    NameThread nt = new NameThread();
    nt.setName(&quot;旺财&quot;);
    nt.start();

  }
}</code></pre><p>###15Thread类方法sleep<br>   A:Thread类方法sleep<br>     public class ThreadDemo {<br>      public static void main(String[] args) throws Exception{<br>        /<em>for(int i = 0 ; i &lt; 5 ;i++){<br>          Thread.sleep(50);<br>          System.out.println(i);<br>        }</em>/</p>
<pre><code>   new SleepThread().start();
 }
}

public class SleepThread extends Thread{
 public void run(){
   for(int i = 0 ; i &lt; 5 ;i++){
     try{
       Thread.sleep(500);//睡眠500ms,500ms已到并且cpu切换到该线程继续向下执行
     }catch(Exception ex){

     }
     System.out.println(i);
   }
 }
}</code></pre><p>###16实现线程的另一种方式实现Runnable接口<br>   A:实现线程的另一种方式实现Runnable接口<br>       /*<br>      *  实现接口方式的线程<br>      *    创建Thread类对象,构造方法中,传递Runnable接口实现类<br>      *    调用Thread类方法start()<br>      */<br>     public class ThreadDemo {<br>      public static void main(String[] args) {<br>        SubRunnable sr = new SubRunnable();<br>        Thread t = new Thread(sr);<br>        t.start();<br>        for(int i = 0 ; i &lt; 50; i++){<br>          System.out.println(“main…”+i);<br>        }<br>      }<br>     }</p>
<pre><code>/*
 *  实现线程成功的另一个方式,接口实现
 *  实现接口Runnable,重写run方法
 */
public class SubRunnable implements Runnable{
 public void run(){
   for(int i = 0 ; i &lt; 50; i++){
     System.out.println(&quot;run...&quot;+i);
   }
 }
}</code></pre><p>###17实现接口方式的好处<br>    A:实现接口方式的好处<br>     第二种方式实现Runnable接口避免了单继承的局限性，所以较为常用。<br>     实现Runnable接口的方式，更加的符合面向对象，线程分为两部分，一部分线程对象，一部分线程任务。<br>     继承Thread类，线程对象和线程任务耦合在一起。<br>     一旦创建Thread类的子类对象，既是线程对象，有又有线程任务。<br>     实现runnable接口，将线程任务单独分离出来封装成对象，类型就是Runnable接口类型。Runnable接口对线程对象和线程任务进行解耦。<br>     (降低紧密性或者依赖性,创建线程和执行任务不绑定)</p>
<p>###18匿名内部类实现线程程序<br>    <em>A:匿名内部类实现线程程序<br>    /</em><br>     *  使用匿名内部类,实现多线程程序<br>     *  前提: 继承或者接口实现<br>     *  new 父类或者接口(){<br>     *     重写抽象方法<br>     *  }<br>     */<br>    public class ThreadDemo {<br>      public static void main(String[] args) {<br>        //继承方式  XXX extends Thread{ public void run(){}}<br>        new Thread(){<br>          public void run(){<br>            System.out.println(“!!!”);<br>          }<br>        }.start();</p>
<pre><code>//实现接口方式  XXX implements Runnable{ public void run(){}}

Runnable r = new Runnable(){
  public void run(){
    System.out.println(&quot;###&quot;);
  }
};
new Thread(r).start();</code></pre><p>​<br>        new Thread(new Runnable(){<br>          public void run(){<br>            System.out.println(“@@@”);<br>          }<br>        }).start();</p>
<pre><code>  }
}</code></pre><p>=======================第四节课开始=============================================</p>
<p>###19线程的状态图<br>   A:线程的状态图<br>        a:参见线程状态图.jpg</p>
<p>###20线程池的原理<br>   A:线程池的原理<br>      1.在java中，如果每个请求到达就创建一个新线程，开销是相当大的。<br>      2.在实际使用中，创建和销毁线程花费的时间和消耗的系统资源都相当大，甚至可能要比在处理实际的用户请求的时间和资源要多的多。<br>      3.除了创建和销毁线程的开销之外，活动的线程也需要消耗系统资源。<br>        如果在一个jvm里创建太多的线程，可能会使系统由于过度消耗内存或“切换过度”而导致系统资源不足。<br>        为了防止资源不足，需要采取一些办法来限制任何给定时刻处理的请求数目，尽可能减少创建和销毁线程的次数，特别是一些资源耗费比较大的线程的创建和销毁，尽量利用已有对象来进行服务。<br>      线程池主要用来解决线程生命周期开销问题和资源不足问题。通过对多个任务重复使用线程，线程创建的开销就被分摊到了多个任务上了，而且由于在请求到达时线程已经存在，所以消除了线程创建所带来的延迟。这样，就可以立即为请求服务，使用应用程序响应更快。另外，通过适当的调整线程中的线程数目可以防止出现资源不足的情况。</p>
<p>###21JDK5实现线程池<br>    A:JDK5实现线程池<br>        /*<br>       *  JDK1.5新特性,实现线程池程序<br>       *  使用工厂类 Executors中的静态方法创建线程对象,指定线程的个数<br>       *   static ExecutorService newFixedThreadPool(int 个数) 返回线程池对象<br>       *   返回的是ExecutorService接口的实现类 (线程池对象)<br>       *<br>       *   接口实现类对象,调用方法submit (Ruunable r) 提交线程执行任务<br>       *<br>       */<br>      public class ThreadPoolDemo {<br>        public static void main(String[] args) {<br>          //调用工厂类的静态方法,创建线程池对象<br>          //返回线程池对象,是返回的接口<br>          ExecutorService es = Executors.newFixedThreadPool(2);<br>            //调用接口实现类对象es中的方法submit提交线程任务<br>          //将Runnable接口实现类对象,传递<br>          es.submit(new ThreadPoolRunnable());<br>          es.submit(new ThreadPoolRunnable());<br>          es.submit(new ThreadPoolRunnable());</p>
<pre><code>  }
}

public class ThreadPoolRunnable implements Runnable {
  public void run(){
    System.out.println(Thread.currentThread().getName()+&quot; 线程提交任务&quot;);
  }
}</code></pre><p>###22实现线程的Callable接口方式<br>  A:实现线程的Callable接口方式<br>     /*<br>      *  实现线程程序的第三个方式,实现Callable接口方式<br>      *  实现步骤<br>      *    工厂类 Executors静态方法newFixedThreadPool方法,创建线程池对象<br>      *    线程池对象ExecutorService接口实现类,调用方法submit提交线程任务<br>      *    submit(Callable c)<br>      <em>/<br>     public class ThreadPoolDemo1 {<br>      public static void main(String[] args)throws Exception {<br>        ExecutorService es = Executors.newFixedThreadPool(2);<br>        //提交线程任务的方法submit方法返回 Future接口的实现类<br>        Future<String> f = es.submit(new ThreadPoolCallable());<br>        String s = f.get();<br>        System.out.println(s);<br>      }<br>     }<br>     /</String></em><br>      * Callable 接口的实现类,作为线程提交任务出现<br>      * 使用方法返回值<br>      */</p>
<pre><code>import java.util.concurrent.Callable;

public class ThreadPoolCallable implements Callable&lt;String&gt;{
 public String call(){
   return &quot;abc&quot;;
 }
}</code></pre><p>###23线程实现异步计算<br>  A:线程实现异步计算</p>
<pre><code>/*
 * 使用多线程技术,求和
 * 两个线程,1个线程计算1+100,另一个线程计算1+200的和
 * 多线程的异步计算
 */
public class ThreadPoolDemo {
  public static void main(String[] args)throws Exception {
    ExecutorService es = Executors.newFixedThreadPool(2);
    Future&lt;Integer&gt; f1 =es.submit(new GetSumCallable(100));
    Future&lt;Integer&gt; f2 =es.submit(new GetSumCallable(200));
    System.out.println(f1.get());
    System.out.println(f2.get());
    es.shutdown();
  }
}</code></pre><p>​     </p>
<pre><code>public class GetSumCallable implements Callable&lt;Integer&gt;{
  private int a;
  public GetSumCallable(int a){
    this.a=a;
  }

  public Integer call(){
    int sum = 0 ;
    for(int i = 1 ; i &lt;=a ; i++){
      sum = sum + i ;
    }
    return sum;
  }
}</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day25%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day25%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记25</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:12:34" itemprop="dateModified" datetime="2020-12-23T23:12:34+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、Properties集合<br>2、序列化流与反序列化流<br>3、打印流<br>4、commons-IO</p>
<p>###01Properties集合的特点<br>    * A: Properties集合的特点<br>        * a: Properties类介绍<br>            * Properties 类表示了一个持久的属性集。Properties 可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串<br>        * b: 特点<br>            * Hashtable的子类，map集合中的方法都可以用。<br>            * 该集合没有泛型。键值都是字符串。<br>            * 它是一个可以持久化的属性集。键值可以存储到集合中，也可以存储到持久化的设备(硬盘、U盘、光盘)上。键值的来源也可以是持久化的设备。<br>            * 有和流技术相结合的方法。<br>        * c: 方法介绍<br>            * load(InputStream inputStream)  把指定流所对应的文件中的数据，读取出来，保存到Propertie集合中<br>            * load(Reader reader) 按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）<br>            * store(OutputStream outputStream,String commonts) 把集合中的数据，保存到指定的流所对应的文件中，参数commonts代表对描述信息<br>            * stroe(Writer writer,String comments) 以适合使用 load(Reader) 方法的格式，将此 Properties 表中的属性列表（键和元素对）写入输出字符</p>
<p>​<br>​<br>###02Properties集合存储键值对<br>    * A: Properties集合存储键值对<br>        * a: 方法介绍<br>            *  集合对象Properties类,继承Hashtable,实现Map接口<br>            *  可以和IO对象结合使用,实现数据的持久存储<br>            * 使用Properties集合,存储键值对<br>            * setProperty等同与Map接口中的put<br>            * setProperty(String key, String value)<br>            * 通过键获取值, getProperty(String key)<br>        * b: 案例代码<br>            public class PropertiesDemo {<br>                public static void main(String[] args)throws IOException {<br>                    function_2();<br>                }<br>                /*<br>                 * 使用Properties集合,存储键值对<br>                 * setProperty等同与Map接口中的put<br>                 * setProperty(String key, String value)<br>                 * 通过键获取值, getProperty(String key)<br>                 */<br>                public static void function(){<br>                    Properties pro = new Properties();<br>                    pro.setProperty(“a”, “1”);<br>                    pro.setProperty(“b”, “2”);<br>                    pro.setProperty(“c”, “3”);<br>                    System.out.println(pro);</p>
<pre><code>        String value = pro.getProperty(&quot;c&quot;);
        System.out.println(value);

        //方法stringPropertyNames,将集合中的键存储到Set集合,类似于Map接口的方法keySet
        Set&lt;String&gt; set = pro.stringPropertyNames();
        for(String key : set){
            System.out.println(key+&quot;...&quot;+pro.getProperty(key));
        }
    }
}</code></pre><p>​<br>###03Properties集合的方法load<br>    * A: Properties集合的方法load<br>        * a: 方法介绍<br>            * Properties集合特有方法 load<br>            * load(InputStream in)<br>            * load(Reader r)<br>            * 传递任意的字节或者字符输入流<br>            * 流对象读取文件中的键值对,保存到集合</p>
<pre><code>* b: 案例代码        
        public class PropertiesDemo {
            public static void main(String[] args)throws IOException {
                function_1();
            }                                    
            /*
             * Properties集合特有方法 load
             * load(InputStream in)
             * load(Reader r)
             * 传递任意的字节或者字符输入流
             * 流对象读取文件中的键值对,保存到集合
             */
            public static void function_1()throws IOException{
                Properties pro = new Properties();
                FileReader fr = new FileReader(&quot;c:\\pro.properties&quot;);
                //调用集合的方法load,传递字符输入流
                pro.load(fr);
                fr.close();
                System.out.println(pro);
            }                    
        }</code></pre><p>###04Properties集合的方法store<br>    * A: Properties集合的方法store<br>        * a: 方法介绍<br>            * Properties集合的特有方法store<br>            * store(OutputStream out)<br>            * store(Writer w)<br>            * 接收所有的字节或者字符的输出流,将集合中的键值对,写回文件中保存<br>        * b: 案例代码<br>            public class PropertiesDemo {<br>                public static void main(String[] args)throws IOException {<br>                    function_2();<br>                }<br>                /*<br>                 * Properties集合的特有方法store<br>                 * store(OutputStream out)<br>                 * store(Writer w)<br>                 * 接收所有的字节或者字符的输出流,将集合中的键值对,写回文件中保存<br>                 */<br>                public static void function_2()throws IOException{<br>                    Properties pro = new Properties();<br>                    pro.setProperty(“name”, “zhangsan”);<br>                    pro.setProperty(“age”, “31”);<br>                    pro.setProperty(“email”, “<a href="mailto:123456789@163.com">123456789@163.com</a>“);<br>                    FileWriter fw = new FileWriter(“c:\pro.properties”);<br>                    //键值对,存回文件,使用集合的方法store传递字符输出流<br>                    pro.store(fw, “”);<br>                    fw.close();<br>                }<br>            }</p>
<p>###05对象的序列化与反序列化<br>    * A: 对象的序列化与反序列化<br>        * a: 基本概念<br>            * 对象的序列化<br>                * 对象中的数据，以流的形式，写入到文件中保存过程称为写出对象，对象的序列化<br>                * ObjectOutputStream将对象写道文件中，实现序列化<br>            * 对象的反序列化<br>                * 在文件中，以流的形式，将对象读出来，读取对象，对象的反序列化<br>                * ObjectInputStream 将文件对象读取出来</p>
<p>###06ObjectOutputStream流写对象<br>    * A: ObjectOutputStream流写对象<br>        * a: 简单介绍<br>             *  IO流对象,实现对象Person序列化,和反序列化<br>             *  ObjectOutputStream 写对象,实现序列化<br>             *  ObjectInputStream 读取对象,实现反序列化</p>
<pre><code>* b: 案例代码
    public class Person implements Serializable{
        public String name;
        public int age;
        public Person(String name, int age) {
            super();
            this.name = name;
            this.age = age;
        }
        public Person(){}

        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
        public int getAge() {
            return age;
        }
        public void setAge(int age) {
            this.age = age;
        }
        @Override
        public String toString() {
            return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;
        }                
    }

    public class ObjectStreamDemo {
        public static void main(String[] args)throws IOException, ClassNotFoundException {
    //        writeObject();
            readObject();
        }
        /*
         * ObjectOutputStream
         * 构造方法: ObjectOutputStream(OutputSteam out)
         * 传递任意的字节输出流
         * void writeObject(Object obj)写出对象的方法
         */
        public static void writeObject() throws IOException{
            //创建字节输出流,封装文件
            FileOutputStream fos = new FileOutputStream(&quot;c:\\person.txt&quot;);
            //创建写出对象的序列化流的对象,构造方法传递字节输出流
            ObjectOutputStream oos = new ObjectOutputStream(fos);
            Person p = new Person(&quot;lisi&quot;,25);
            //调用序列化流的方法writeObject,写出对象
            oos.writeObject(p);
            oos.close();
        }
    }</code></pre><p>###07ObjectInputStream流读取对象<br>    * A: ObjectInputStream流读取对象<br>        * a: 简单介绍<br>            * ObjectInputStream<br>            * 构造方法:ObjectInputStream(InputStream in)<br>            * 传递任意的字节输入流,输入流封装文件,必须是序列化的文件<br>            * Object readObject()  读取对象<br>        * b: 案例代码<br>            /*<br>             *  IO流对象,实现对象Person序列化,和反序列化<br>             *  ObjectOutputStream 写对象,实现序列化<br>             *  ObjectInputStream 读取对象,实现反序列化<br>             <em>/<br>            public class ObjectStreamDemo {<br>                public static void main(String[] args)throws IOException, ClassNotFoundException {<br>                    readObject();<br>                }<br>                /</em><br>                 * ObjectInputStream<br>                 * 构造方法:ObjectInputStream(InputStream in)<br>                 * 传递任意的字节输入流,输入流封装文件,必须是序列化的文件<br>                 * Object readObject()  读取对象<br>                 */<br>                public static void readObject() throws IOException, ClassNotFoundException{<br>                    FileInputStream fis = new FileInputStream(“c:\person.txt”);<br>                    //创建反序列化流,构造方法中,传递字节输入流<br>                    ObjectInputStream ois = new ObjectInputStream(fis);<br>                    //调用反序列化流的方法 readObject()读取对象<br>                    Object obj =ois.readObject();<br>                    System.out.println(obj);<br>                    ois.close();<br>                }<br>            }</p>
<p>###08静态不能序列化<br>    * A: 静态不能序列化<br>        * a: 原因<br>            * 序列化是把对象数据进行持久化存储<br>            * 静态的东西不属于对象，而属于类</p>
<p>###09transient关键字<br>    * A: transient关键字<br>        * a: 作用<br>            * 被transient修饰的属性不会被序列化<br>            * transient关键字只能修饰成员变量</p>
<p>​<br>###10Serializable接口的含义<br>    * A：Serializable接口的含义<br>        * a: 作用<br>            * 给需要序列化的类上加标记。该标记中没有任何抽象方法<br>            * 只有实现了 Serializable接口的类的对象才能被序列化</p>
<p>###11序列化中的序列号冲突问题<br>    * A: 序列化中的序列号冲突问题<br>        * a: 问题产生原因<br>            * 当一个类实现Serializable接口后，创建对象并将对象写入文件，之后更改了源代码(比如：将成员变量的修饰符有private改成public)，<br>                再次从文件中读取对象时会报异常<br>            * 见day25_source文件夹下的”序列号的冲突.JPG”文件</p>
<p>###12序列化中自定义的序列号<br>    * A: 序列化中自定义的序列号<br>        * a: 定义方式<br>            * private static final long serialVersionUID = 1478652478456L;<br>                * 这样每次编译类时生成的serialVersionUID值都是固定的     </p>
<pre><code>* b: 案例代码
    public class Person implements Serializable{
        public String name;
        public /*transient阻止成员变量序列化*/ int age;
        //类,自定义了序列号,编译器不会计算序列号
        private static final long serialVersionUID = 1478652478456L;

        public Person(String name, int age) {
            super();
            this.name = name;
            this.age = age;
        }
        public Person(){}

        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
        public int getAge() {
            return age;
        }
        public void setAge(int age) {
            this.age = age;
        }
        @Override
        public String toString() {
            return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;
        }                
    }</code></pre><p>###13打印流和特性<br>    * A: 打印流和特性<br>        * a: 概述<br>            * 打印流添加输出数据的功能，使它们能够方便地打印各种数据值表示形式.<br>            * 打印流根据流的分类：<br>                * 字节打印流    PrintStream<br>                * 字符打印流    PrintWriter<br>            * 方法：<br>                * void print(String str): 输出任意类型的数据，<br>                * void println(String str): 输出任意类型的数据，自动写入换行操作<br>        * b: 特点<br>            * 此流不负责数据源,只负责数据目的<br>            * 为其他输出流,添加功能<br>            * 永远不会抛出IOException，但是可能抛出别的异常<br>            * 两个打印流的方法,完全一致<br>            * 构造方法,就是打印流的输出目的端<br>            * PrintStream构造方法<br>                * 接收File类型,接收字符串文件名,接收字节输出流OutputStream<br>            * PrintWriter构造方法<br>                * 接收File类型,接收字符串文件名,接收字节输出流OutputStream, 接收字符输出流Writer</p>
<p>​<br>###14打印流输出目的是File对象<br>    * A: 打印流输出目的是File对象<br>        * a: 案例代码<br>            public class PrintWriterDemo {<br>                public static void main(String[] args) throws  IOException {<br>                    function_3();</p>
<pre><code>    }

    /*
     * 打印流,向File对象的数据目的写入数据
     * 方法print println  原样输出
     * write方法走码表
     */
    public static void function() throws FileNotFoundException{
        File file = new File(&quot;c:\\1.txt&quot;);
        PrintWriter pw = new PrintWriter(file);
        pw.println(true);
        pw.write(100);
        pw.close();
    }
}</code></pre><p>###15输出语句是char数组<br>    * A: 输出语句是char数组<br>        * a: 案例代码<br>            public class Demo {<br>                public static void main(String[] args) {<br>                    int[] arr = {1};<br>                    System.out.println(arr);</p>
<pre><code>            char[] ch = {&apos;a&apos;,&apos;b&apos;};
            System.out.println(ch);

            byte[] b = {};
            System.out.println(b);
        }
    }
* b: 结果分析
    * println数组，只有打印字符数组时只有容，其余均打印数组的地址
        * 因为api中定义了打印字符数组的方法，其底层是在遍历数组中的元素
        * 而其他打印数组的方法，都是将数组对象编程Object，其底层再将对象编程String，调用了String s = String.valueOf(x);方法</code></pre><p>###16打印流输出目的是String和流对象<br>    * A: 打印流输出目的是String和流对象<br>        * a: 案例代码<br>            public class PrintWriterDemo {<br>                public static void main(String[] args) throws  IOException {<br>                    function_2();</p>
<pre><code>    }

    /*
     * 打印流,输出目的,是流对象
     * 可以是字节输出流,可以是字符的输出流
     * OutputStream  Writer
     */
    public static void function_2() throws IOException{
    //    FileOutputStream fos = new FileOutputStream(&quot;c:\\3.txt&quot;);
        FileWriter fw = new FileWriter(&quot;c:\\4.txt&quot;);
        PrintWriter pw = new PrintWriter(fw);
        pw.println(&quot;打印流&quot;);
        pw.close();
    }
    /*
     * 打印流,输出目的,String文件名
     */
    public static void function_1() throws FileNotFoundException{
        PrintWriter pw = new PrintWriter(&quot;c:\\2.txt&quot;);
        pw.println(3.5);
        pw.close();
    }    

}</code></pre><p>###17打印流开启自动刷新<br>    * A: 打印流开启自动刷新<br>        * 案例代码<br>            public class PrintWriterDemo {<br>                public static void main(String[] args) throws  IOException {<br>                    function_3();</p>
<pre><code>    }
    /* 
     * 打印流,可以开启自动刷新功能
     * 满足2个条件:
     *   1. 输出的数据目的必须是流对象
     *       OutputStream  Writer
     *   2. 必须调用println,printf,format三个方法中的一个,启用自动刷新
     */
    public static void function_3()throws  IOException{
        //File f = new File(&quot;XXX.txt&quot;);
        FileOutputStream fos = new FileOutputStream(&quot;c:\\5.txt&quot;);
        PrintWriter pw = new PrintWriter(fos,true);
        pw.println(&quot;i&quot;);
        pw.println(&quot;love&quot;);
        pw.println(&quot;java&quot;);
        pw.close();
    }
}</code></pre><p>###18打印流复制文本文件<br>    * A: 打印流复制文本文件<br>        * a: 案例代码<br>            /*<br>             * 打印流实现文本复制<br>             *   读取数据源  BufferedReader+File 读取文本行<br>             *   写入数据目的 PrintWriter+println 自动刷新<br>             */<br>            public class PrintWriterDemo1 {<br>                public static void main(String[] args) throws IOException{<br>                    BufferedReader bfr = new BufferedReader(new FileReader(“c:\a.txt”));<br>                    PrintWriter pw = new PrintWriter(new FileWriter(“d:\a.txt”),true);<br>                    String line = null;<br>                    while((line = bfr.readLine())!=null){<br>                        pw.println(line);<br>                    }<br>                    pw.close();<br>                    bfr.close();<br>                }<br>            }</p>
<p>###19commons-io工具类介绍<br>    * A: commons-io工具类介绍<br>        * a: 工具类介绍<br>            * 解压缩commons-io-2.4.zip文件<br>            * commons-io-2.4.jar需要导入到项目中的jar包，里面存放的是class文件<br>            * commons-io-2.4-sources.jar工具类中原代码<br>            * docs是帮助文档</p>
<p>###20使用工具类commons_io<br>    * A: 使用工具类commons_io<br>        * a: 导入jar包<br>            * 加入classpath的第三方jar包内的class文件才能在项目中使用<br>            * 创建lib文件夹<br>            * 将commons-io.jar拷贝到lib文件夹<br>            * 右键点击commons-io.jar，Build Path→Add to Build Path<br>        * b: 学会如何看源代码</p>
<p>###21IO工具类FilenameUtils<br>    * A: IO工具类FilenameUtils<br>        * a: 方法介绍<br>            * getExtension(String path)：获取文件的扩展名；<br>            * getName()：获取文件名；<br>            * isExtension(String fileName,String ext)：判断fileName是否是ext后缀名；<br>        * b: 案例代码<br>            public class Commons_IODemo {<br>                public static void main(String[] args) {<br>                    function_2();<br>                }<br>                /*<br>                 * FilenameUtils类的方法<br>                 * static boolean isExtension(String filename,String extension)<br>                 * 判断文件名的后缀是不是extension<br>                 */<br>                public static void function_2(){<br>                    boolean b = FilenameUtils.isExtension(“Demo.java”, “java”);<br>                    System.out.println(b);<br>                }</p>
<pre><code>    /*
     * FilenameUtils类的方法
     * static String getName(String filename)
     * 获取文件名
     */
    public static void function_1(){
        String name = FilenameUtils.getName(&quot;c:\\windows\\&quot;);
        System.out.println(name);
    }

    /*
     * FilenameUtils类的方法
     * static String getExtension(String filename)
     * 获取文件名的扩展名
     */
     public static void function(){
         String name = FilenameUtils.getExtension(&quot;c:\\windows&quot;);
         System.out.println(name);
     }
}</code></pre><p>###22IO工具类FileUtils<br>    * A: IO工具类FileUtils<br>        * a: 方法介绍<br>            * readFileToString(File file)：读取文件内容，并返回一个String；<br>            * writeStringToFile(File file，String content)：将内容content写入到file中；<br>            * copyDirectoryToDirectory(File srcDir,File destDir);文件夹复制<br>            * copyFile(File srcFile,File destFile);文件复制</p>
<pre><code>* b: 案例代码
    public class Commons_IODemo1 {
        public static void main(String[] args)throws IOException {
            function_3();
        }
        /*
         * FileUtils工具类方法
         * static void copyDirectoryToDirectory(File src,File desc)
         * 复制文件夹
         */
        public static void function_3() throws IOException{
            FileUtils.copyDirectoryToDirectory(new File(&quot;d:\\demo&quot;), new File(&quot;c:\\&quot;));
        }

        /*
         * FileUtils工具类的方法
         * static void copyFile(File src,File desc)
         * 复制文件
         */
        public static void function_2() throws IOException{
            FileUtils.copyFile(new File(&quot;c:\\k.jpg&quot;),new File(&quot;d:\\k.jpg&quot;));
        }

        /*
         * FileUtils工具类的方法
         * static void writeStringToFile(File src,String date)
         * 将字符串直接写到文件中
         */
        public static void function_1() throws IOException{
            FileUtils.writeStringToFile(new File(&quot;c:\\b.txt&quot;),&quot;我爱Java编程&quot;);
        }

        /*
         * FileUtils工具类的方法
         * static String readFileToString(File src)读取文本,返回字符串
         */
         public static void function() throws IOException{
             String s = FileUtils.readFileToString(new File(&quot;c:\\a.txt&quot;));
             System.out.println(s);
         }
    }</code></pre><p>###23总结<br>    * 把今天的知识点总结一遍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/35/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><span class="page-number current">36</span><a class="page-number" href="/page/37/">37</a><span class="space">&hellip;</span><a class="page-number" href="/page/48/">48</a><a class="extend next" rel="next" href="/page/37/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">匡俊桦</p>
  <div class="site-description" itemprop="description">回忆的沙漏将曾经屈指可数的日子渐渐淡去</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">238</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">匡俊桦</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">29:11</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
