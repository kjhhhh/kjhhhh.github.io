<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:type" content="website">
<meta property="og:title" content="KJHの博客">
<meta property="og:url" content="http://yoursite.com/page/37/index.html">
<meta property="og:site_name" content="KJHの博客">
<meta property="og:description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="匡俊桦">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/37/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>KJHの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KJHの博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录&回忆</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day24%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day24%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记24</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:12:25" itemprop="dateModified" datetime="2020-12-23T23:12:25+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、转换流<br>2、缓冲流</p>
<p>=======================第一节课开始=============================================</p>
<p>###01转换流概述<br>    * A: 转换流概述<br>        * a: 转换流概述<br>            * OutputStreamWriter 是字符流通向字节流的桥梁：可使用指定的字符编码表，将要写入流中的字符编码成字节<br>            * 将字符串按照指定的编码表转成字节，在使用字节流将这些字节写出去</p>
<p>​<br>###02转换流_字符转字节的过程<br>    * A: 转换流_字符转字节的过程<br>        * a.图解<br>            * 详见day24_source/转换流.JPG图片</p>
<p>​<br>###03OutputStreamWriter写文本文件<br>    * A: OutputStreamWriter写文本文件<br>        * a: OutputStreamWriter<br>            * java.io.OutputStreamWriter 继承Writer类<br>            * 就是一个字符输出流，写文本文件<br>            * write()字符，字符数组，字符串<br>            * 字符通向字节的桥梁，将字符流转字节流<br>            * OutputStreamWriter 使用方式<br>                * 构造方法：<br>                    * OutputStreamWriter(OuputStream out)接收所有的字节输出流<br>                    * 字节输出流：  FileOutputStream<br>                    * OutputStreamWriter(OutputStream out, String charsetName)<br>                    * String charsetName 传递编码表名字 GBK  UTF-8<br>            * OutputStreamWriter 有个子类，  FileWriter<br>        * b: 案例代码</p>
<pre><code>public class OutputStreamWriterDemo {
    public static void main(String[] args)throws IOException {
//        writeGBK();
        writeUTF();
    }
    /*
     * 转换流对象OutputStreamWriter写文本
     * 采用UTF-8编码表写入
     */
    public static void writeUTF()throws IOException{
        //创建字节输出流，绑定文件
        FileOutputStream fos = new FileOutputStream(&quot;c:\\utf.txt&quot;);
        //创建转换流对象，构造方法保证字节输出流，并指定编码表是UTF-8
        OutputStreamWriter osw = new OutputStreamWriter(fos,&quot;UTF-8&quot;);
        osw.write(&quot;你好&quot;);
        osw.close();
    }

    /*
     * 转换流对象 OutputStreamWriter写文本
     * 文本采用GBK的形式写入
     */
    public static void writeGBK()throws IOException{
        //创建字节输出流，绑定数据文件
        FileOutputStream fos = new FileOutputStream(&quot;c:\\gbk.txt&quot;);
        //创建转换流对象，构造方法，绑定字节输出流，使用GBK编码表
        OutputStreamWriter osw = new OutputStreamWriter(fos);
        //转换流写数据
        osw.write(&quot;你好&quot;);

        osw.close();
    }
}</code></pre><p>###04转换流_字节转字符流过程<br>    * A: 转换流_字节转字符流过程<br>        * a: InputStreamReader<br>            * java.io.InputStreamReader 继承 Reader<br>            * 字符输入流，读取文本文件<br>            * 字节流向字符的敲了，将字节流转字符流<br>            * 读取的方法:<br>                * read() 读取1个字符，读取字符数组<br>            * 技巧<br>                * OuputStreamWriter写了文件<br>                * InputStreamReader读取文件<br>            * OutputStreamWriter(OutputStream out)所有字节输出流<br>            * InputStreamReader(InputStream in) 接收所有的字节输入流<br>            * 可以传递的字节输入流： FileInputStream<br>            * InputStreamReader(InputStream in,String charsetName) 传递编码表的名字<br>        * b: 图解<br>            * 详见day24_source/转换流.JPG图片</p>
<p>###05InputSteamReader读取文本文件<br>    * A: InputSteamReader读取文本文件<br>        * a: 案例代码<br>            public class InputStreamReaderDemo {<br>                public static void main(String[] args) throws IOException {<br>            //        readGBK();<br>                    readUTF();<br>                }<br>                /*<br>                 *  转换流,InputSteamReader读取文本<br>                 *  采用UTF-8编码表,读取文件utf<br>                 <em>/<br>                public static void readUTF()throws IOException{<br>                    //创建自己输入流,传递文本文件<br>                    FileInputStream fis = new FileInputStream(“c:\utf.txt”);<br>                    //创建转换流对象,构造方法中,包装字节输入流,同时写编码表名<br>                    InputStreamReader isr = new InputStreamReader(fis,”UTF-8”);<br>                    char[] ch = new char[1024];<br>                    int len = isr.read(ch);<br>                    System.out.println(new String(ch,0,len));<br>                    isr.close();<br>                }<br>                /</em><br>                 *  转换流,InputSteamReader读取文本<br>                 *  采用系统默认编码表,读取GBK文件<br>                 */<br>                public static void readGBK()throws IOException{<br>                    //创建自己输入流,传递文本文件<br>                    FileInputStream fis = new FileInputStream(“c:\gbk.txt”);<br>                    //创建转换流对象,构造方法,包装字节输入流<br>                    InputStreamReader isr = new InputStreamReader(fis);<br>                    char[] ch = new char[1024];<br>                    int len = isr.read(ch);<br>                    System.out.println(new String(ch,0,len));</p>
<pre><code>        isr.close();
    }
}</code></pre><p>​<br>###06转换流子类父类的区别<br>    * A: 转换流子类父类的区别<br>        * a: 继承关系<br>            OutputStreamWriter:<br>                |–FileWriter:<br>            InputStreamReader:<br>                |–FileReader;<br>        * b: 区别<br>            * OutputStreamWriter和InputStreamReader是字符和字节的桥梁：也可以称之为字符转换流。字符转换流原理：字节流+编码表。<br>            * FileWriter和FileReader：作为子类，仅作为操作字符文件的便捷类存在。<br>                当操作的字符文件，使用的是默认编码表时可以不用父类，而直接用子类就完成操作了，简化了代码。<br>            * 以下三句话功能相同<br>                * InputStreamReader isr = new InputStreamReader(new FileInputStream(“a.txt”));//默认字符集。<br>                * InputStreamReader isr = new InputStreamReader(new FileInputStream(“a.txt”),”GBK”);//指定GBK字符集。<br>                * FileReader fr = new FileReader(“a.txt”);</p>
<p>###07缓冲流概述<br>    * A: 缓冲流概述<br>        * a: 概述<br>            * 可提高IO流的读写速度<br>            * 分为字节缓冲流与字符缓冲流 </p>
<p>​<br>###08字节输出流缓冲流BufferedOutputStream<br>    * A: 字节输出流缓冲流BufferedOutputStream<br>        * a: BufferedOutputStream<br>            * 字节输出流的缓冲流<br>            * java.io.BufferedOuputStream 作用: 提高原有输出流的写入效率<br>            * BufferedOuputStream 继承 OutputStream<br>            * 方法,写入 write 字节,字节数组<br>            * 构造方法:<br>                * BufferedOuputStream(OuputStream out)<br>                * 可以传递任意的字节输出流, 传递的是哪个字节流,就对哪个字节流提高效率  </p>
<pre><code>* b: 案例代码
    public class BufferedOutputStreamDemo {
        public static void main(String[] args)throws IOException {
            //创建字节输出流,绑定文件
            //FileOutputStream fos = new FileOutputStream(&quot;c:\\buffer.txt&quot;);
            //创建字节输出流缓冲流的对象,构造方法中,传递字节输出流
            BufferedOutputStream bos = new
                    BufferedOutputStream(new FileOutputStream(&quot;c:\\buffer.txt&quot;));

            bos.write(55);

            byte[] bytes = &quot;HelloWorld&quot;.getBytes();

            bos.write(bytes);

            bos.write(bytes, 3, 2);

            bos.close();
        }
    }</code></pre><p>###09字节输入流缓冲流BufferedInputStream<br>    * A: 字节输入流缓冲流BufferedInputStream<br>        * a: BufferedInputStream<br>            * 字节输入流的缓冲流<br>            * 继承InputStream,标准的字节输入流<br>            * 读取方法  read() 单个字节,字节数组<br>            * 构造方法:<br>                * BufferedInputStream(InputStream in)<br>                * 可以传递任意的字节输入流,传递是谁,就提高谁的效率<br>                * 可以传递的字节输入流 FileInputStream<br>        * b: 案例代码<br>            public class BufferedInputStreamDemo {<br>                public static void main(String[] args) throws IOException{<br>                    //创建字节输入流的缓冲流对象,构造方法中包装字节输入流,包装文件<br>                    BufferedInputStream bis = new<br>                            BufferedInputStream(new FileInputStream(“c:\buffer.txt”));<br>                    byte[] bytes = new byte[10];<br>                    int len = 0 ;<br>                    while((len = bis.read(bytes))!=-1){<br>                        System.out.print(new String(bytes,0,len));<br>                    }<br>                    bis.close();<br>                }<br>            }</p>
<p>​<br>###10四种文件复制方式的效率比较<br>    * A：四种文件复制方式的效率比较<br>        * a: 四中复制方式<br>            * 字节流读写单个字节                    125250 毫秒<br>            * 字节流读写字节数组                    193    毫秒  OK<br>            * 字节流缓冲区流读写单个字节            1210   毫秒<br>            * 字节流缓冲区流读写字节数组            73     毫秒  OK        </p>
<pre><code>* b: 案例代码

    public class Copy {
        public static void main(String[] args)throws IOException {
            long s = System.currentTimeMillis();
            copy_4(new File(&quot;c:\\q.exe&quot;), new File(&quot;d:\\q.exe&quot;));
            long e = System.currentTimeMillis();
            System.out.println(e-s);
        }
        /*
         * 方法,实现文件复制
         *  4. 字节流缓冲区流读写字节数组
         */
        public static void copy_4(File src,File desc)throws IOException{
            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));
            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(desc));
            int len = 0 ;
            byte[] bytes = new byte[1024];
            while((len = bis.read(bytes))!=-1){
                bos.write(bytes,0,len);
            }
            bos.close();
            bis.close();
        }
        /*
         * 方法,实现文件复制
         *  3. 字节流缓冲区流读写单个字节
         */
        public static void copy_3(File src,File desc)throws IOException{
            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));
            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(desc));
            int len = 0 ;
            while((len = bis.read())!=-1){
                bos.write(len);
            }
            bos.close();
            bis.close();
        }

        /*
         * 方法,实现文件复制
         *  2. 字节流读写字节数组
         */
        public static void copy_2(File src,File desc)throws IOException{
            FileInputStream fis = new FileInputStream(src);
            FileOutputStream fos = new FileOutputStream(desc);
            int len = 0 ;
            byte[] bytes = new byte[1024];
            while((len = fis.read(bytes))!=-1){
                fos.write(bytes,0,len);
            }
            fos.close();
            fis.close();
        }

        /*
         * 方法,实现文件复制
         *  1. 字节流读写单个字节
         */
        public static void copy_1(File src,File desc)throws IOException{
            FileInputStream fis = new FileInputStream(src);
            FileOutputStream fos = new FileOutputStream(desc);
            int len = 0 ;
            while((len = fis.read())!=-1){
                fos.write(len);
            }
            fos.close();
            fis.close();
        }
    }</code></pre><p>​<br>###11字符输出流缓冲流BufferedWriter<br>    * A: 字符输出流缓冲流BufferedWriter<br>        * a: BufferedWriter<br>            * 字符输出流缓冲区流<br>            * java.io.BufferedWriter 继承 Writer<br>            * 写入方法 write () 单个字符,字符数组,字符串</p>
<pre><code>    * 构造方法:
        * BufferedWriter(Writer w)传递任意字符输出流
        * 传递谁,就高效谁
        * 能传递的字符输出流 FileWriter, OutputStreamWriter
* b: 案例代码
    public class BufferedWrierDemo {
        public static void main(String[] args) throws IOException{
            //创建字符输出流,封装文件
            FileWriter fw = new FileWriter(&quot;c:\\buffer.txt&quot;);
            BufferedWriter bfw = new BufferedWriter(fw);

            bfw.write(100);
            bfw.flush();
            bfw.write(&quot;你好&quot;.toCharArray());
            bfw.flush();</code></pre><p>​<br>                    bfw.write(“你好”);</p>
<pre><code>bfw.flush();</code></pre><p>​<br>                    bfw.write(“我好好”);</p>
<pre><code>        bfw.flush();

        bfw.write(&quot;大家都好&quot;);
        bfw.flush();

        bfw.close();

    }
}</code></pre><p>###12字符输出流缓冲流BufferedWriter特有方法newLine<br>    * A: 字符输出流缓冲流BufferedWriter特有方法newLine<br>        * a: 方法介绍<br>            * void  newLine() 写换行</p>
<pre><code>    * newLine()文本中换行, \r\n也是文本换行
    * 方法具有平台无关性
    * Windows  \r\n
    * Linux    \n

    * newLine()运行结果,和操作系统是相互关系
    * JVM: 安装的是Windows版本,newLine()写的就是\r\n
    * 安装的是Linux版本,newLine()写的就是\n
    /*
     *  将数据源 c:\\a.txt
     *  复制到 d:\\a.txt  数据目的
     *  字节输入流,绑定数据源
     *  字节输出流,绑定数据目的
     *  
     *  输入,读取1个字节
     *  输出,写1个字节
     */
* b: 案例代码
    public class BufferedWrierDemo {
        public static void main(String[] args) throws IOException{
            //创建字符输出流,封装文件
            FileWriter fw = new FileWriter(&quot;c:\\buffer.txt&quot;);
            BufferedWriter bfw = new BufferedWriter(fw);

            bfw.write(100);
            bfw.flush();
            bfw.write(&quot;你好&quot;.toCharArray());
            bfw.flush();

            bfw.write(&quot;你好&quot;);
            bfw.newLine();
            bfw.flush();</code></pre><p>​<br>                    bfw.write(“我好好”);<br>                    bfw.newLine();<br>                    bfw.flush();</p>
<pre><code>        bfw.write(&quot;大家都好&quot;);
        bfw.flush();

        bfw.close();

    }
}</code></pre><p>###13字符输入流缓冲流BufferedReader<br>    * A: 字符输入流缓冲流BufferedReader<br>        * a: 概述<br>            * 从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取<br>            * public String readLine() 读取一个文本行，包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null</p>
<p>###14字符输入流缓冲流BufferedReader读取文本行<br>    * A: 字符输入流缓冲流BufferedReader读取文本行<br>        * a: BufferedReader<br>            * 字符输入流缓冲流<br>            * java.io.BufferedReader 继承 Reader<br>            * 读取功能 read() 单个字符,字符数组<br>            * 构造方法:<br>                * BufferedReader(Reader r)<br>                * 可以任意的字符输入流<br>                   FileReader  InputStreamReader<br>            * BufferedReader自己的功能<br>                * String readLine() 读取文本行 \r\n<br>                    * 方法读取到流末尾,返回null<br>        * b: 小特点<br>             * 获取内容的方法一般都有返回值<br>             * int 没有返回的都是负数<br>             * 引用类型 找不到返回null<br>             * boolean 找不到返回false</p>
<pre><code>* c: 案例代码
    public class BufferedReaderDemo {
        public static void main(String[] args) throws IOException {
            int lineNumber = 0;
            //创建字符输入流缓冲流对象,构造方法传递字符输入流,包装数据源文件
            BufferedReader bfr = new BufferedReader(new FileReader(&quot;c:\\a.txt&quot;));
            //调用缓冲流的方法 readLine()读取文本行
            //循环读取文本行, 结束条件 readLine()返回null
            String line = null;
            while((line = bfr.readLine())!=null){
                lineNumber++;
                System.out.println(lineNumber+&quot;  &quot;+line);
            }
            bfr.close();
        }
    }

    /*
     * String line = bfr.readLine();
            System.out.println(line);

            line = bfr.readLine();
            System.out.println(line);

            line = bfr.readLine();
            System.out.println(line);

            line = bfr.readLine();
            System.out.println(line);

            line = bfr.readLine();
            System.out.println(line);
     */</code></pre><p>###15字符流缓冲区流复制文本文件<br>    * A: 字符流缓冲区流复制文本文件<br>        * a: 案例代码<br>            /*<br>             *  使用缓冲区流对象,复制文本文件<br>             *  数据源  BufferedReader+FileReader 读取<br>             *  数据目的 BufferedWriter+FileWriter 写入<br>             *  读取文本行, 读一行,写一行,写换行<br>             */<br>            public class Copy_1 {<br>                public static void main(String[] args) throws IOException{<br>                    BufferedReader bfr = new BufferedReader(new FileReader(“c:\w.log”));<br>                    BufferedWriter bfw = new BufferedWriter(new FileWriter(“d:\w.log”));<br>                    //读取文本行, 读一行,写一行,写换行<br>                    String line = null;<br>                    while((line = bfr.readLine())!=null){<br>                        bfw.write(line);<br>                        bfw.newLine();<br>                        bfw.flush();<br>                    }<br>                    bfw.close();<br>                    bfr.close();<br>                }<br>            }</p>
<p>​<br>###16IO流对象的操作规律<br>    * A: IO流对象的操作规律<br>        * a: 明确一：要操作的数据是数据源还是数据目的。<br>            * 源：InputStream    Reader<br>            * 目的：OutputStream Writer<br>            * 先根据需求明确要读，还是要写。</p>
<pre><code>* b: 明确二：要操作的数据是字节还是文本呢？
    * 源：
        * 字节：InputStream
        * 文本：Reader
    * 目的：
        * 字节：OutputStream
        * 文本：Writer
* c: 明确三：明确数据所在的具体设备。
    * 源设备：
        * 硬盘：文件  File开头。
        * 内存：数组，字符串。
        * 键盘：System.in;
        * 网络：Socket
    * 目的设备：
        * 硬盘：文件  File开头。
        * 内存：数组，字符串。
        * 屏幕：System.out
        * 网络：Socket
        * 完全可以明确具体要使用哪个流对象。
* d: 明确四：是否需要额外功能呢？
    * 额外功能：
        * 转换吗？转换流。InputStreamReader OutputStreamWriter
        * 高效吗？缓冲区对象。BufferedXXX
        * 已经明确到了具体的体系上。</code></pre><p>###17总结<br>    * 把今天的知识点总结一遍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day23%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day23%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记23</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:12:08" itemprop="dateModified" datetime="2020-12-23T23:12:08+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、字节流<br>2、字符流</p>
<p>=======================第一节课开始=============================================</p>
<p>###01输入和输出</p>
<pre><code>* A:输入和输出
    * a: 参照物
        * 到底是输入还是输出，都是以Java程序为参照
    * b: Output
        * 把内存中的数据存储到持久化设备上这个动作称为输出（写）Output操作
        * 程序到文件称为输出
    * c: Input
        * 把持久设备上的数据读取到内存中的这个动作称为输入（读）Input操作
        * 文件到程序称为输入
    * d: IO操作
        * 把上面的这种输入和输出动作称为IO操作</code></pre><p>###02字节输出流OutputStream<br>    * A: 字节输出流OutputStream<br>        * a.概念<br>            * IO流用来处理设备之间的数据传输<br>            * Java对数据的操作是通过流的方式<br>            * Java用于操作流的类都在IO包中<br>            * 流按流向分为两种：输入流，输出流。<br>            * 流按操作类型分为两种：<br>                * 字节流 : 字节流可以操作任何数据,因为在计算机中任何数据都是以字节的形式存储的<br>                * 字符流 : 字符流只能操作纯字符数据，比较方便。<br>        * b.IO流常用父类<br>            * 字节流的抽象父类：<br>                * InputStream<br>                * OutputStream<br>            * 字符流的抽象父类：<br>                * Reader<br>                * Writer<br>        * c.IO程序书写<br>            * 使用前，导入IO包中的类<br>            * 使用时，进行IO异常处理<br>            * 使用后，释放资源<br>        * d: 方法介绍<br>            *  void close(): 关闭此输出流并释放与此流有关的所有系统资源。<br>            *  void write(byte[] b)： 将 b.length 个字节从指定的 byte 数组写入此输出流<br>            *  void write(byte[] b, int off, int len) ：将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。<br>            * abstract  void write(int b) ： 将指定的字节写入此输出流。</p>
<p>​<br>​<br>###03字节输出流FileOutputStream写字节<br>    * A: 字节输出流FileOutputStream写字节<br>        * a: FileOutputStream<br>            * 写入数据文件,学习父类方法,使用子类对象<br>        * b: FileOutputStream构造方法<br>            * 作用：绑定输出的输出目的<br>            * FileOutputStream(File file)<br>                * 创建一个向指定 File 对象表示的文件中写入数据的文件输出流。<br>            * FileOutputStream(File file, boolean append)<br>                * 创建一个向指定 File 对象表示的文件中写入数据的文件输出流，以追加的方式写入。<br>            * FileOutputStream(String name)<br>                * 创建一个向具有指定名称的文件中写入数据的输出文件流。<br>            * FileOutputStream(String name, boolean append)<br>                * 创建一个向具有指定 name 的文件中写入数据的输出文件流，以追加的方式写入。<br>        * c: 流对象使用步骤<br>            *  1. 创建流子类的对象,绑定数据目的<br>            *  2. 调用流对象的方法write写<br>            *  3. close释放资源<br>        * d: 注意事项<br>            * 流对象的构造方法,可以创建文件,如果文件存在,直接覆盖</p>
<pre><code>* e: 案例代码

    /*
     *   FileOutputStream
     *   写入数据文件,学习父类方法,使用子类对象
     *   
     *   子类中的构造方法: 作用:绑定输出的输出目的
     *     参数:
     *       File    封装文件
     *       String  字符串的文件名
     *   
     *   流对象使用步骤
     *     1. 创建流子类的对象,绑定数据目的
     *     2. 调用流对象的方法write写
     *     3. close释放资源
     *     
     *    流对象的构造方法,可以创建文件,如果文件存在,直接覆盖
     */
    public class FileOutputStreamDemo {
        public static void main(String[] args)throws IOException {
            FileOutputStream fos = new FileOutputStream(&quot;c:\\a.txt&quot;);
            //流对象的方法write写数据
            //写1个字节
            fos.write(97);
            //关闭资源
            fos.close();

        }
    }</code></pre><p>​    </p>
<p>###04字节输出流FileOutputStream写字节数组<br>    * A: 字节输出流FileOutputStream写字节数组<br>        * a: 方法介绍<br>            *  void write(byte[] b)： 将 b.length 个字节从指定的 byte 数组写入此输出流<br>            *  void write(byte[] b, int off, int len) ：将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。<br>        * b: 案例代码<br>            /*<br>             *   FileOutputStream<br>             *   写入数据文件,学习父类方法,使用子类对象<br>             *<br>             *   子类中的构造方法: 作用:绑定输出的输出目的<br>             *     参数:<br>             *       File    封装文件<br>             *       String  字符串的文件名<br>             *<br>             *   流对象使用步骤<br>             *     1. 创建流子类的对象,绑定数据目的<br>             *     2. 调用流对象的方法write写<br>             *     3. close释放资源<br>             *<br>             *    流对象的构造方法,可以创建文件,如果文件存在,直接覆盖<br>             */<br>            public class FileOutputStreamDemo {<br>                public static void main(String[] args)throws IOException {<br>                    FileOutputStream fos = new FileOutputStream(“c:\a.txt”);<br>                    //流对象的方法write写数据<br>                    //写字节数组<br>                    byte[] bytes = {65,66,67,68};<br>                    fos.write(bytes);</p>
<pre><code>        //写字节数组的一部分,开始索引,写几个
        fos.write(bytes, 1, 2);

        //写入字节数组的简便方式
        //写字符串
        fos.write(&quot;hello&quot;.getBytes());

        //关闭资源
        fos.close();

    }
}</code></pre><p>###05文件的续写和换行符号<br>    * A: 文件的续写和换行符号<br>        * a: 文件的续写<br>            *  FileOutputStream构造方法, 的第二个参数中,加入true<br>        * b: 换行符号<br>            * 在文件中,写入换行,符号换行  \r\n<br>            * \r\n 可以写在上一行的末尾, 也可以写在下一行的开头<br>        * c: 案例代码<br>                /*<br>                 *  FileOutputStream 文件的续写和换行问题<br>                 *  续写: FileOutputStream构造方法, 的第二个参数中,加入true<br>                 *  在文件中,写入换行,符号换行  \r\n<br>                 *  \r\n 可以写在上一行的末尾, 也可以写在下一行的开头<br>                 */<br>                public class FileOutputStreamDemo1 {<br>                    public static void main(String[] args)throws IOException {<br>                        File file = new File(“c:\b.txt”);<br>                        FileOutputStream fos = new FileOutputStream(file,true);<br>                        fos.write(“hello\r\n”.getBytes());<br>                        fos.write(“world”.getBytes());<br>                        fos.close();<br>                    }<br>                }</p>
<p>​<br>###06IO中的异常处理<br>    * A: IO中的异常处理<br>        * a:IO流的异常处理<br>            * try catch finally</p>
<pre><code>* b: 细节
    * 1. 保证流对象变量,作用域足够
    * 2. catch里面,怎么处理异常
        * 输出异常的信息,目的看到哪里出现了问题
        * 停下程序,从新尝试
    * 3. 如果流对象建立失败了,需要关闭资源吗
        * new 对象的时候,失败了,没有占用系统资源
        * 释放资源的时候,对流对象判断null
        * 变量不是null,对象建立成功,需要关闭资源

* c: 案例代码
    public class FileOutputStreamDemo3 {
        public static void main(String[] args) {
            //try 外面声明变量,try 里面建立对象
            FileOutputStream fos = null;
            try{
                fos = new FileOutputStream(&quot;s:\\a.txt&quot;);
                fos.write(100);
            }catch(IOException ex){
                System.out.println(ex);
                throw new RuntimeException(&quot;文件写入失败,重试&quot;);
            }finally{
                try{
                    if(fos!=null)
                      fos.close();
                }catch(IOException ex){
                    throw new RuntimeException(&quot;关闭资源失败&quot;);
                }
            }
        }
    }</code></pre><p>​<br>###07字节输入流InputStream<br>    * A: 字节输入流InputStream<br>        * a: 方法介绍<br>            * abstract  int read() ：<br>                * 从输入流中读取数据的下一个字节。<br>            * int read(byte[] b)<br>                * 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。<br>            * int read(byte[] b, int off, int len)<br>                * 将输入流中最多 len 个数据字节读入 byte 数组。<br>            * void close()<br>                * 关闭此输入流并释放与该流关联的所有系统资源。</p>
<p>​<br>        * b: 案例代码<br>            /*<br>             *   字节输入流<br>             *     java.io.InputStream 所有字节输入流的超类<br>             *   作用: 读取任意文件,每次只读取1个字节<br>             *   读取的方法  read<br>             *     int  read() 读取1个字节<br>             *     int  read(byte[] b) 读取一定量的字节,存储到数组中<br>             */<br>            public class InputStreamDemo {</p>
<pre><code>}</code></pre><p>​<br>###08字节输入流FileInputStream读取字节<br>    * A: 字节输入流FileInputStream读取字节<br>        * a: 方法介绍<br>            * abstract  int read() ：<br>                * 从输入流中读取数据的下一个字节，返回-1表示文件结束<br>            * int read(byte[] b)<br>                * 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。<br>                * 读入缓冲区的字节总数，如果因为已经到达文件末尾而没有更多的数据，则返回 -1。<br>            * int read(byte[] b, int off, int len)<br>                * 将输入流中最多 len 个数据字节读入 byte 数组。<br>            * void close()<br>                * 关闭此输入流并释放与该流关联的所有系统资源。<br>        * b: 案例代码<br>            /*<br>             *  FileInputStream读取文件<br>             *<br>             *  构造方法: 为这个流对象绑定数据源<br>             *<br>             *    参数:<br>             *      File 类型对象<br>             *      String 对象<br>             *   输入流读取文件的步骤<br>             *     1. 创建字节输入流的子类对象<br>             *     2. 调用读取方法read读取<br>             *     3. 关闭资源<br>             *<br>             *     read()方法,<br>             *       read()执行一次,就会自动读取下一个字节<br>             *       返回值,返回的是读取到的字节, 读取到结尾返回-1<br>             */<br>            public class FileInputStreamDemo {<br>                public static void main(String[] args) throws IOException{<br>                    FileInputStream fis = new FileInputStream(“c:\a.txt”);<br>                    //读取一个字节,调用方法read 返回int<br>                    //使用循环方式,读取文件,  循环结束的条件  read()方法返回-1<br>                    int len = 0;//接受read方法的返回值</p>
<pre><code>        while( (len = fis.read()) != -1){
            System.out.print((char)len);
        }
        //关闭资源
        fis.close();
    }
}

/*
 * int i = fis.read();
        System.out.println(i);

        i = fis.read();
        System.out.println(i);

        i = fis.read();
        System.out.println(i);

        i = fis.read();
        System.out.println(i);
 */</code></pre><p>###09字节输入流FileInputStream读取字节数组<br>    * A: 字节输入流FileInputStream读取字节数组<br>        * a: 方法介绍<br>            * int read(byte[] b)<br>                * 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。<br>                * 读入缓冲区的字节总数，如果因为已经到达文件末尾而没有更多的数据，则返回 -1。<br>            * int read(byte[] b, int off, int len)<br>                * 将输入流中最多 len 个数据字节读入 byte 数组。<br>        * b: 案例代码<br>            /*<br>             *  FileInputStream读取文件<br>             *   读取方法  int read(byte[] b) 读取字节数组<br>             *   数组作用: 缓冲的作用, 提高效率<br>             *   read返回的int,表示什么含义 读取到多少个有效的字节数<br>             */<br>            public class FileInputStreamDemo1 {<br>                public static void main(String[] args) throws IOException {<br>                    FileInputStream fis = new FileInputStream(“c:\a.txt”);<br>                    // 创建字节数组<br>                    byte[] b = new byte[2];</p>
<pre><code>        int len = fis.read(b);
        System.out.println(new String(b));// ab
        System.out.println(len);// 2

        len = fis.read(b);
        System.out.println(new String(b));// cd
        System.out.println(len);// 2

        len = fis.read(b);
        System.out.println(new String(b));// ed
        System.out.println(len);// 1

        len = fis.read(b);
        System.out.println(new String(b));// ed
        System.out.println(len);// -1

        fis.close();
    }
}</code></pre><p>###10字节输入流FileInputStream读取字节数组的实现原理<br>    * A：字节输入流FileInputStream读取字节数组的实现原理<br>        * a: 原理<br>            * 参见day23_source文件夹中的”读取数组的原理.jpg”</p>
<p>​<br>        * b: 案例代码</p>
<pre><code>public class FileInputStreamDemo1 {
    public static void main(String[] args) throws IOException {
        FileInputStream fis = new FileInputStream(&quot;c:\\a.txt&quot;);
        //创建字节数组
        byte[] b = new byte[1024];

        int len = 0 ;
        while( (len = fis.read(b)) !=-1){
            System.out.print(new String(b,0,len));
        }
        fis.close();
    }
}</code></pre><p>​<br>###11文件复制原理<br>    * A: 文件复制原理<br>        * a: 见day23_source/文件复制原理.jpg</p>
<p>###12字节流复制文件读取单个字节<br>    * A: 字节流复制文件读取单个字节<br>        * a: 案例代码<br>            /*<br>             *  将数据源 c:\a.txt<br>             *  复制到 d:\a.txt  数据目的<br>             *  字节输入流,绑定数据源<br>             *  字节输出流,绑定数据目的<br>             *<br>             *  输入,读取1个字节<br>             *  输出,写1个字节<br>             */<br>            public class Copy {<br>                public static void main(String[] args) {<br>                    //定义两个流的对象变量<br>                    FileInputStream fis = null;<br>                    FileOutputStream fos = null;<br>                    try{<br>                        //建立两个流的对象,绑定数据源和数据目的<br>                        fis = new FileInputStream(“c:\t.zip”);<br>                        fos = new FileOutputStream(“d:\t.zip”);<br>                        //字节输入流,读取1个字节,输出流写1个字节<br>                        int len = 0 ;<br>                        while((len = fis.read())!=-1){<br>                            fos.write(len);<br>                        }<br>                    }catch(IOException ex){<br>                        System.out.println(ex);<br>                        throw new RuntimeException(“文件复制失败”);<br>                    }finally{<br>                        try{<br>                            if(fos!=null)<br>                                fos.close();<br>                        }catch(IOException ex){<br>                            throw new RuntimeException(“释放资源失败”);<br>                        }finally{<br>                            try{<br>                                if(fis!=null)<br>                                    fis.close();<br>                            }catch(IOException ex){<br>                                throw new RuntimeException(“释放资源失败”);<br>                            }<br>                        }<br>                    }<br>                }<br>            }</p>
<p>###13字节流复制文件读取字节数组<br>    * A: 字节流复制文件读取字节数组<br>        * a: 案例代码<br>            /*<br>             *  字节流复制文件<br>             *   采用数组缓冲提高效率<br>             *   字节数组<br>             *   FileInputStream 读取字节数组<br>             *   FileOutputStream 写字节数组<br>             <em>/<br>            public class Copy_1 {<br>                public static void main(String[] args) {<br>                    long s = System.currentTimeMillis();<br>                    FileInputStream fis = null;<br>                    FileOutputStream fos = null;<br>                    try{<br>                        fis = new FileInputStream(“c:\t.zip”);<br>                        fos = new FileOutputStream(“d:\t.zip”);<br>                        //定义字节数组,缓冲<br>                        byte[] bytes = new byte[1024</em>10];<br>                        //读取数组,写入数组<br>                        int len = 0 ;<br>                        while((len = fis.read(bytes))!=-1){<br>                            fos.write(bytes, 0, len);<br>                        }<br>                    }catch(IOException ex){<br>                        System.out.println(ex);<br>                        throw new RuntimeException(“文件复制失败”);<br>                    }finally{<br>                        try{<br>                            if(fos!=null)<br>                                fos.close();<br>                        }catch(IOException ex){<br>                            throw new RuntimeException(“释放资源失败”);<br>                        }finally{<br>                            try{<br>                                if(fis!=null)<br>                                    fis.close();<br>                            }catch(IOException ex){<br>                                throw new RuntimeException(“释放资源失败”);<br>                            }<br>                        }<br>                    }<br>                    long e = System.currentTimeMillis();<br>                    System.out.println(e-s);<br>                }<br>            }</p>
<p>###14编码表<br>    * A: 编码表<br>        * a: 定义：<br>            * 生活中字符和计算机二进制的对应关系表,就是编码表<br>        * b: 分类<br>            * 1、ascii： 一个字节中的7位就可以表示。对应的字节都是正数。0-xxxxxxx<br>            * 2、iso-8859-1:拉丁码表 latin，用了一个字节用的8位。1-xxxxxxx  负数。<br>            * 3、GB2312:简体中文码表。包含6000-7000中文和符号。用两个字节表示。两个字节第一个字节是负数,第二个字节可能是正数<br>                * GBK:目前最常用的中文码表，2万的中文和符号。用两个字节表示，其中的一部分文字，第一个字节开头是1，第二字节开头是0<br>                * GB18030：最新的中文码表，目前还没有正式使用。<br>            * 4、unicode：国际标准码表:无论是什么文字，都用两个字节存储。<br>                * Java中的char类型用的就是这个码表。char c = ‘a’;占两个字节。<br>                * Java中的字符串是按照系统默认码表来解析的。简体中文版 字符串默认的码表是GBK。<br>            * 5、UTF-8:基于unicode，一个字节就可以存储数据，不要用两个字节存储，而且这个码表更加的标准化，在每一个字节头加入了编码信息(后期到api中查找)。<br>            * 6、能识别中文的码表：GBK、UTF-8；正因为识别中文码表不唯一，涉及到了编码解码问题。<br>                * 对于我们开发而言；常见的编码 GBK  UTF-8  ISO-8859-1<br>                * 文字—&gt;(数字) ：编码。 “abc”.getBytes()  byte[]<br>                * (数字)—&gt;文字  : 解码。 byte[] b={97,98,99}  new String(b) </p>
<p>###15字符输出流写文本FileWriter类<br>    * A: 字符输出流写文本FileWriter类<br>        * a: 方法介绍<br>            *  void write(int c)<br>                *  写入单个字符<br>            * void write(String str)<br>                * 写入字符串<br>            * void write(String str, int off, int len)<br>                * 写入字符串的某一部分<br>            * void write(char[] cbuf)<br>                * 写入字符数组<br>            * abstract  void write(char[] cbuf, int off, int len)<br>                *  写入字符数组的某一部分<br>        * b: 案例代码<br>            /*<br>             *   字符输出流<br>             *     java.io.Writer 所有字符输出流的超类<br>             *   写文件,写文本文件<br>             *<br>             *   写的方法 write<br>             *     write(int c) 写1个字符<br>             *     write(char[] c)写字符数组<br>             *     write(char[] c,int,int)字符数组一部分,开始索引,写几个<br>             *     write(String s) 写入字符串<br>             *<br>             *   Writer类的子类对象 FileWriter<br>             *<br>             *   构造方法:  写入的数据目的<br>             *     File 类型对象<br>             *     String 文件名<br>             *<br>             *   字符输出流写数据的时候,必须要运行一个功能,刷新功能<br>             *   flush()<br>             */<br>            public class WriterDemo {<br>                public static void main(String[] args) throws IOException{<br>                    FileWriter fw = new FileWriter(“c:\1.txt”);</p>
<pre><code>        //写1个字符
        fw.write(100);
        fw.flush();

        //写1个字符数组
        char[] c = {&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;};
        fw.write(c);
        fw.flush();

        //写字符数组一部分
        fw.write(c, 2, 2);
        fw.flush();

        //写如字符串
        fw.write(&quot;hello&quot;);
        fw.flush();

        fw.close();
    }
}</code></pre><p>​<br>###16字符输入流读取文本FileReader类<br>    * A: 字符输入流读取文本FileReader类<br>        * a: 方法介绍<br>            *  int read()<br>                * 读取单个字符<br>            * int read(char[] cbuf)<br>                * 将字符读入数组<br>            * abstract  int read(char[] cbuf, int off, int len)<br>                * 将字符读入数组的某一部分。<br>        * b: 案例代码<br>            /*<br>             *  字符输入流读取文本文件,所有字符输入流的超类<br>             *    java.io.Reader<br>             *  专门读取文本文件<br>             *<br>             *  读取的方法 : read()<br>             *   int read() 读取1个字符<br>             *   int read(char[] c) 读取字符数组<br>             *<br>             *   Reader类是抽象类,找到子类对象 FileReader<br>             *<br>             *   构造方法: 绑定数据源<br>             *     参数:<br>             *        File  类型对象<br>             *        String文件名<br>             <em>/<br>            public class ReaderDemo {<br>                public static void main(String[] args) throws IOException{<br>                    FileReader fr = new FileReader(“c:\1.txt”);<br>                    /*int len = 0 ;<br>                    while((len = fr.read())!=-1){<br>                        System.out.print((char)len);<br>                    }</em>/<br>                    char[] ch = new char[1024];<br>                    int len = 0 ;<br>                    while((len = fr.read(ch))!=-1){<br>                        System.out.print(new String(ch,0,len));<br>                    }</p>
<pre><code>        fr.close();
    }
}</code></pre><p>​<br>###17flush方法和close方法区别<br>    * A: flush方法和close方法区别<br>        *a: flush()方法<br>            * 用来刷新缓冲区的,刷新后可以再次写出,只有字符流才需要刷新<br>        *b: close()方法<br>            * 用来关闭流释放资源的的,如果是带缓冲区的流对象的close()方法,不但会关闭流,还会再关闭流之前刷新缓冲区,关闭后不能再写出 </p>
<p>###18字符流复制文本文件<br>    * A: 字符流复制文本文件<br>        * a: 案例代码<br>            /*<br>             *  字符流复制文本文件,必须文本文件<br>             *  字符流查询本机默认的编码表,简体中文GBK<br>             *  FileReader读取数据源<br>             *  FileWriter写入到数据目的<br>             */<br>            public class Copy_2 {<br>                public static void main(String[] args) {<br>                    FileReader fr = null;<br>                    FileWriter fw = null;<br>                    try{<br>                        fr = new FileReader(“c:\1.txt”);<br>                        fw = new FileWriter(“d:\1.txt”);<br>                        char[] cbuf = new char[1024];<br>                        int len = 0 ;<br>                        while(( len = fr.read(cbuf))!=-1){<br>                            fw.write(cbuf, 0, len);<br>                            fw.flush();<br>                        }</p>
<pre><code>        }catch(IOException ex){
            System.out.println(ex);
            throw new RuntimeException(&quot;复制失败&quot;);
        }finally{
            try{
                if(fw!=null)
                    fw.close();
            }catch(IOException ex){
                throw new RuntimeException(&quot;释放资源失败&quot;);
            }finally{
                try{
                    if(fr!=null)
                        fr.close();
                }catch(IOException ex){
                    throw new RuntimeException(&quot;释放资源失败&quot;);
                }
            }
        }
    }
}</code></pre><p>###19总结<br>    * 把今天的知识点总结一遍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day22%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day22%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记22</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:11:56" itemprop="dateModified" datetime="2020-12-23T23:11:56+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、File<br>2、递归</p>
<p>=======================第一节课开始=============================================</p>
<p>###01IO技术概述.avi（02:49）<br>    * A:IO技术概述<br>        * a: Output<br>            * 把内存中的数据存储到持久化设备上这个动作称为输出（写）Output操作<br>        * b: Input<br>            * 把持久设备上的数据读取到内存中的这个动作称为输入（读）Input操作<br>        * c: IO操作<br>            * 把上面的这种输入和输出动作称为IO操作</p>
<p>###02File类的概述和作用<br>    * A:File类的概述和作用<br>        * a: File的概念<br>            * File类是文件和目录路径名的抽象表示形式<br>            * Java中把文件或者目录（文件夹）都封装成File对象<br>            * 我们要去操作硬盘上的文件，或者文件夹只要找到File这个类即可</p>
<p>###03File类静态的成员变量<br>    * A:File类静态的成员变量<br>        * a: pathSeparator<br>            * 与系统有关的路径分隔符，为了方便，它被表示为一个字符串<br>        * b: separator<br>            * 与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串</p>
<pre><code>* c: 案例代码

    /*
     *  java.io.File
     *    将操作系统中的,文件,目录(文件夹),路径,封装成File对象
     *    提供方法,操作系统中的内容
     *    File与系统无关的类
     *    文件 file
     *    目录 directory
     *    路径 path
     */
    public class FileDemo {
        public static void main(String[] args) {
            //File类静态成员变量
            //与系统有关的路径分隔符
            String separator = File.pathSeparator;
            System.out.println(separator);// 是一个分号,目录的分割(window中环境变量配置各个路径用分号分割，表示一个完整的路径结束)  Linux中是冒号 :

            //与系统有关的默认名称分隔符
            separator = File.separator;
            System.out.println(separator);// 向右 \  目录名称分割  Linux / 
        }
    }</code></pre><p>​    </p>
<p>###04File类构造方法_1<br>    * A: File类构造方法_1<br>        * a: File(String pathname)<br>            * 通过将给定路径名字符串转换为一个File对象,之后可以使用File中的方法<br>            * windows中的路径或文件名不区分大小写<br>        * d: 案例代码<br>            public class FileDemo1 {<br>                public static void main(String[] args) {<br>                    function();<br>                }<br>                /*<br>                 *  File(String pathname)<br>                 *  传递路径名: 可以写到文件夹,可以写到一个文件<br>                 *  c:\abc   c:\abc\Demo.java<br>                 *  将路径封装File类型对象<br>                 */<br>                public static void function(){<br>                    File file = new File(“d:\eclipse”);<br>                    System.out.println(file);<br>                }<br>            }</p>
<p>###05相对路径和绝对路径<br>    * A: 相对路径和绝对路径<br>        * a: 绝对路径<br>            * 绝对路径是一个固定的路径,从盘符开始<br>        * b: 相对路径<br>            * 相对路径相对于某个位置,在eclipse下是指当前项目下<br>        * c: 路径<br>                绝对路径<br>                    在系统中具有唯一性<br>                    c:\windows\system32<br>                相对路径<br>                    表示路径之间的关系<br>                    D:\develop\Java\jdk1.7.0_72\bin<br>                    D:\develop\Java\jre7<br>                    路径之间关系<br>                        Java 父目录是D:\develop<br>                        Java 子目录是：jdk1.7.0_72<br>                    父路径是 唯一性<br>                    子目录是可以多个</p>
<p>​<br>###06File类的构造方法_2<br>    * A: File类的构造方法_2<br>        * a:File(String parent, String child)<br>            * 根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 对象</p>
<pre><code>* b: File(File parent, String child)

* c: 案例代码
public class FileDemo1 {
    public static void main(String[] args) {
        function_2();
    }
    /*
     *  File(File parent,String child)
     *  传递路径,传递File类型父路径,字符串子路径
     *  好处: 父路径是File类型,父路径可以直接调用File类方法
     */
    public static void function_2(){
        File parent = new File(&quot;d:&quot;);
        File file = new File(parent,&quot;eclipse&quot;);
        System.out.println(file);
    }

    /*
     *  File(String parent,String child)
     *  传递路径,传递字符串父路径,字符串子路径
     *  好处: 单独操作父路径和子路径
     */
    public static void function_1(){
        File file = new File(&quot;d:&quot;,&quot;eclipse&quot;);
        System.out.println(file);
    }
}</code></pre><p>​<br>###07File类创建文件功能<br>    * A: File类创建文件功能<br>        * a: public boolean createNewFile()<br>            * 创建文件 如果存在这样的文件，就不创建了</p>
<pre><code>* b: 案例代码
    public class FileDemo2 {
        public static void main(String[] args)throws IOException {
            function();
        }                        
        /*
         *  File创建文件的功能
         *  boolean createNewFile()
         *  创建的文件路径和文件名,在File构造方法中给出
         *  文件已经存在了,不在创建
         */
        public static void function()throws IOException{
            File file = new File(&quot;c:\\a.txt&quot;);
            boolean b = file.createNewFile();
            System.out.println(b);
        }
    }</code></pre><p>​<br>###08File类创建目录功能<br>    * A: File类创建目录功能<br>        * a: 创建目录<br>            * public boolean mkdir():创建文件夹 如果存在这样的文件夹，就不创建了<br>            * public boolean mkdirs():创建文件夹,如果父文件夹不存在，会帮你创建出来<br>        * b: 案例代码<br>            public class FileDemo2 {<br>                public static void main(String[] args)throws IOException {<br>                    function_1();<br>                }<br>                /*<br>                 *  File创建文件夹功能<br>                 *  boolean mkdirs() 创建多层文件夹<br>                 *  创建的路径也在File构造方法中给出<br>                 *  文件夹已经存在了,不在创建<br>                 */<br>                public static void function_1(){<br>                    File file = new File(“c:\abc”);<br>                    boolean b = file.mkdirs();<br>                    System.out.println(b);<br>                }<br>            }</p>
<p>###09File类删除功能<br>    * A: File类删除功能<br>        * a: 删除功能<br>            * public boolean delete():删除文件或者文件夹<br>    * B: 案例代码<br>        public class FileDemo2 {<br>            public static void main(String[] args)throws IOException {<br>                function_2();<br>            }<br>            /*<br>             *  File类的删除功能<br>             *  boolean delete()<br>             *  删除的文件或者是文件夹,在File构造方法中给出<br>             *  删除成功返回true,删除失败返回false<br>             *  删除方法,不走回收站,直接从硬盘中删除<br>             *  删除有风险,运行需谨慎<br>             */<br>            public static void function_2(){<br>                File file = new File(“c:\a.txt”);<br>                boolean b = file.delete();<br>                System.out.println(b);<br>            }<br>        }</p>
<p>###10File类获取功能<br>    * A：File类获取功能<br>        * a: 方法介绍<br>            * String getName(): 返回路径中表示的文件或者文件夹名<br>                * 获取路径中的最后部分的名字<br>            * long length(): 返回路径中表示的文件的字节数<br>            * String getAbsolutePath(): 获取绝对路径,返回String对象<br>            * File   getAbsoluteFile() : 获取绝对路径,返回File对象<br>                * eclipse环境中,写一个相对路径,绝对位置工程根目录<br>            * String getParent(): 获取父路径,返回String对象<br>            * File getParentFile(): 获取父路径,返回File对象</p>
<pre><code>* b: 案例代码

    public class FileDemo3 {
        public static void main(String[] args) {
            function_3();
        }
        /*
         * File类的获取功能
         * String getParent() 返回String对象
         * File getParentFile()返回File对象
         * 获取父路径
         */
        public static void function_3(){
            File file = new File(&quot;d:\\eclipse\\eclipse.exe&quot;);
            File parent = file.getParentFile();
            System.out.println(parent);
        }

        /*
         * File类获取功能
         * String getAbsolutePath() 返回String对象
         * File   getAbsoluteFile() 返回File对象
         * 获取绝对路径
         * eclipse环境中,写的是一个相对路径,绝对位置工程根目录
         */
        public static void function_2(){
            File file = new File(&quot;src&quot;);
            File absolute = file.getAbsoluteFile();
            System.out.println(absolute);
        }

        /*
         * File类获取功能
         * long length()
         * 返回路径中表示的文件的字节数
         */
        public static void function_1(){
            File file = new File(&quot;d:\\eclipse\\eclipse.exe&quot;);
            long length = file.length();
            System.out.println(length);
        }

        /*
         *  File类的获取功能
         *  String getName()
         *  返回路径中表示的文件或者文件夹名
         *  获取路径中的最后部分的名字
         */
        public static void function(){
            File file = new File(&quot;d:\\eclipse\\eclipse.exe&quot;);
            String name = file.getName();
            System.out.println(name);

            /*String path = file.getPath();
            System.out.println(path);*/
    //        System.out.println(file);
        }
    }</code></pre><p>​<br>###11File类判断功能<br>    * A: File类判断功能<br>        * a: 方法介绍<br>            * boolean exists(): 判断File构造方法中封装路径是否存在<br>                * 存在返回true,不存在返回false<br>            * boolean isDirectory(): 判断File构造方法中封装的路径是不是文件夹<br>                * 如果是文件夹,返回true,不是文件返回false<br>            * boolean isFile(): 判断File构造方法中封装的路径是不是文件<br>                * 如果是文件,返回true,不是文件返回false</p>
<pre><code>* b: 案例代码
    public class FileDemo4 {
        public static void main(String[] args) {
            function_1();
        }
        /*
         *  File判断功能
         *  boolean isDirectory()
         *  判断File构造方法中封装的路径是不是文件夹
         *  如果是文件夹,返回true,不是文件返回false
         *  
         *  boolean isFile()
         *  判断File构造方法中封装的路径是不是文件
         */
        public static void function_1(){
            File file = new File(&quot;d:\\eclipse\\eclipse.exe&quot;);
            if(file.exists()){
                boolean b = file.isDirectory();
                System.out.println(b);
            }
        }

        /*
         *  File判断功能
         *  boolean exists()
         *  判断File构造方法中封装路径是否存在
         *  存在返回true,不存在返回false
         */
        public static void function(){
            File file = new File(&quot;src&quot;);
            boolean b = file.exists();
            System.out.println(b);
        }
    }</code></pre><p>###12File类list获取功能<br>    * A: File类list获取功能<br>        * a: 方法介绍<br>            * String[] list()：获取到File构造方法中封装的路径中的文件和文件夹名 (遍历一个目录)<br>                * 返回只有名字<br>            * File[] listFiles()：获取到,File构造方法中封装的路径中的文件和文件夹名 (遍历一个目录)<br>                * 返回的是目录或者文件的全路径<br>            * static File[] listRoots(): 列出可用的文件系统根 </p>
<pre><code>* b: 案例代码
    public class FileDemo {
        public static void main(String[] args) {
            function_2();
        }
        public static void function_2(){
            //获取系统中的所有根目录
            File[] fileArr = File.listRoots();
            for(File f : fileArr){
                System.out.println(f);
            }
        }

        /*
         *  File类的获取功能
         *  File[] listFiles()
         *  获取到,File构造方法中封装的路径中的文件和文件夹名 (遍历一个目录)
         *  返回的是目录或者文件的全路径
         */
        public static void function_1(){
            File file = new File(&quot;d:\\eclipse&quot;);
            File[] fileArr = file.listFiles();
            for(File f : fileArr){
                System.out.println(f);
            }
        }

        /*
         *  File类的获取功能
         *  String[] list()
         *  获取到,File构造方法中封装的路径中的文件和文件夹名 (遍历一个目录)
         *  返回只有名字
         */
        public static void function(){
            File file = new File(&quot;c:&quot;);
            String[] strArr = file.list();
            System.out.println(strArr.length);
            for(String str : strArr){
                System.out.println(str);
            }
        }
    }</code></pre><p>###13文件过滤器<br>    * A: 文件过滤器<br>        * a: 作用<br>            * 过滤一个目录下的指定扩展名的文件，或者包含某些关键字的文件夹</p>
<pre><code>* b: 方法介绍
    * public String[] list(FilenameFilter filter)
    * public File[] listFiles(FileFilter filter)

* C: 案例代码    
    /*
     *  自定义过滤器
     *  实现FileFilter接口,重写抽象方法
     */
    public class MyFilter implements FileFilter{
        public boolean accept(File pathname)  {
            /*
             * pathname 接受到的也是文件的全路径
             * c:\\demo\\1.txt
             * 对路径进行判断,如果是java文件,返回true,不是java文件,返回false
             * 文件的后缀结尾是.java
             */
            //String name = pathname.getName();
            return pathname.getName().endsWith(&quot;.java&quot;);

        }
    }

    /*
     *  File类的获取,文件获取过滤器
     *  遍历目录的时候,可以根据需要,只获取满足条件的文件
     *  遍历目录方法 listFiles()重载形式
     *  listFiles(FileFilter filter)接口类型
     *  传递FileFilter接口的实现类
     *  自定义FileFilter接口实现类,重写抽象方法,
     *  接口实现类对象传递到遍历方法listFiles
     */
    public class FileDemo1 {
        public static void main(String[] args) {
            File file = new File(&quot;c:\\demo&quot;);
            File[] fileArr = file.listFiles(new MyFilter());
            for(File f : fileArr){
                System.out.println(f);
            }
        }
    }</code></pre><p>###14文件过滤器_原理分析<br>    * A:文件过滤器_原理分析<br>        * listFiles()遍历目录的同时，获取到了文件名全路径，调用过滤器的方法accept，将获取到的路径传递给accept方法的参数pathname<br>        * accept方法接收了参数pathname，参数是listFiles传递来的<br>        * 在accept方法中，进行判断，如果这个路径是Java文件，返回true，走着返回false<br>        * 一旦方法返回了true<br>        * listFiles将路径保存到File数组中</p>
<p>###15递归遍历全目录<br>    * A: 递归遍历全目录<br>        * a: 案例代码<br>            /*<br>             *  对一个目录的下的所有内容,进行完全的遍历<br>             *  编程技巧,方法的递归调用,自己调用自己<br>             <em>/<br>            public class FileDemo {<br>                public static void main(String[] args) {<br>                    File dir = new File(“d:\eclipse”);<br>                    getAllDir(dir);<br>                }<br>                /</em><br>                 *  定义方法,实现目录的全遍历<br>                 */<br>                public static void getAllDir(File dir){<br>                    System.out.println(dir);<br>                    //调用方法listFiles()对目录,dir进行遍历<br>                    File[] fileArr = dir.listFiles();<br>                    for(File f : fileArr){<br>                        //判断变量f表示的路径是不是文件夹<br>                        if(f.isDirectory()){<br>                            //是一个目录,就要去遍历这个目录<br>                            //本方法,getAllDir,就是给个目录去遍历<br>                            //继续调用getAllDir,传递他目录<br>                            getAllDir(f);<br>                        }else{<br>                            System.out.println(f);<br>                        }<br>                    }<br>                }<br>            }</p>
<p>​<br>###16递归概念和注意事项<br>    * A:递归概念和注意事项<br>        * a: 递归概念<br>            * 递归，指在当前方法内调用自己的这种现象<br>            * 递归分为两种，直接递归和间接递归<br>            * 直接递归称为方法自身调用自己。间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法<br>        * b: 注意事项<br>            * 递归一定要有出口, 必须可以让程序停下<br>            * 递归次数不能过多<br>            * 构造方法,禁止递归</p>
<p>###17递归求和计算<br>    * A: 递归求和计算<br>        * a: 题目分析<br>            * 1+2+3+…+(n-1)+n:求1到n的和<br>            * 总结规律：1到n的和等于1到(n-1)的和再加n<br>            * getSum(n-1)+ n<br>            * 递归出口：getSum(1) return 1;</p>
<pre><code>* b: 案例代码    
    /*
     *  方法的递归调用
     *    方法自己调用自己
     *  适合于,方法中运算的主体不变,但是运行的时候,参与运行的方法参数会变化
     *  注意:
     *     递归一定要有出口, 必须可以让程序停下
     *     递归次数不能过多
     *     构造方法,禁止递归
     */
    public class DiGuiDemo {
        public static void main(String[] args) {
            int sum = getSum(3);
            System.out.println(sum);
        }</code></pre><p>​<br>                /*<br>                 *  计算 1+2+3+100和 = 5050<br>                 *  计算规律:<br>                 *    n+(n-1)+(n-2)<br>                 *    100+(100-1)+(99-1)+…1<br>                 */<br>                public static int getSum(int n){<br>                    if( n == 1)<br>                        return 1;<br>                    return n + getSum(n-1);<br>                }</p>
<pre><code>}</code></pre><p>###18递归求阶乘<br>    * A: 递归求和计算<br>        * a: 题目分析<br>            * 5!=5<em>4</em>3<em>2</em>1<br>            *   =5<em>4!<br>            * 4!=4<em>3!<br>            * 3!=3</em>2!<br>            * 2!=2*1!<br>            * 1!=1<br>            * n!=n</em>(n-1)!<br>            * 递归出口：n<em>getJieCheng(n-1):  getJieCheng(1) return 1;<br>        * b: 案例代码<br>            /</em><br>             *  方法的递归调用<br>             *    方法自己调用自己<br>             *  适合于,方法中运算的主体不变,但是运行的时候,参与运行的方法参数会变化<br>             *  注意:<br>             *     递归一定要有出口, 必须可以让程序停下<br>             *     递归次数不能过多<br>             *     构造方法,禁止递归<br>             */<br>            public class DiGuiDemo {<br>                public static void main(String[] args) {<br>                    System.out.println(getJieCheng(5));</p>
<pre><code>    }

    /* 
     *  计算阶乘 5!
     *   5*4*3*2*1
     */
    public static int getJieCheng(int n){
        if ( n == 1)
            return 1;
        return n * getJieCheng(n-1);
    }                                
}</code></pre><p>###19递归计算斐波那契数列<br>    * A: 递归计算斐波那契数列<br>        * a：题目分析<br>            * 1 1 2 3 5 8 13 21<br>            * 从第三项开始，后面的每一项都等于前面两项的和，第一项和第二项的值为1，作为程序的出口<br>        * b: 案例代码<br>            /*<br>             *  方法的递归调用<br>             *    方法自己调用自己<br>             *  适合于,方法中运算的主体不变,但是运行的时候,参与运行的方法参数会变化<br>             *  注意:<br>             *     递归一定要有出口, 必须可以让程序停下<br>             *     递归次数不能过多<br>             *     构造方法,禁止递归<br>             <em>/<br>            public class DiGuiDemo {<br>                public static void main(String[] args) {<br>                    System.out.println(getFBNQ(12));<br>                }<br>                /</em><br>                 *  方法递归,计算斐波那契数列<br>                 *<br>                 */<br>                public static int getFBNQ(int month){<br>                    if( month == 1)<br>                        return 1;<br>                    if( month == 2)<br>                        return 1;<br>                    return getFBNQ(month-1)+getFBNQ(month-2);<br>                }<br>            }<br>###20遍历目录下的所有java文件<br>    * A: 遍历目录下的所有java文件<br>        * a: 案例代码<br>            public class MyJavaFilter implements FileFilter {<br>                public boolean accept(File pathname) {<br>                    //判断获取的是目录,直接返回true<br>                    if(pathname.isDirectory())<br>                        return true;<br>                    return pathname.getName().toLowerCase().endsWith(“.java”);<br>                }</p>
<pre><code>}
/*
 *  遍历目录,获取目录下的所有.java文件
 *  遍历多级目录,方法递归实现
 *  遍历的过程中,使用过滤器
 */
public class FileDemo1 {
    public static void main(String[] args) {
        getAllJava(new File(&quot;c:\\demo&quot;));
//        new File(&quot;c:\\demo&quot;).delete();
    }
    /*
     * 定义方法,实现遍历指定目录
     * 获取目录中所有的.java文件
     */
    public static void getAllJava(File dir){
        //调用File对象方法listFiles()获取,加入过滤器
        File[] fileArr = dir.listFiles(new MyJavaFilter());
        for(File f : fileArr){
            //对f路径,判断是不是文件夹
            if(f.isDirectory()){
                //递归进入文件夹遍历
                getAllJava(f);
            }else{
                System.out.println(f);
            }
        }
    }
}</code></pre><p>###21总结<br>    * 把今天的知识点总结一遍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day21%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day21%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记21</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:11:42" itemprop="dateModified" datetime="2020-12-23T23:11:42+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、异常概述和继承体系<br>2、异常原因以及处理方式<br>3、运行时期异常<br>4、方法重写的异常处理<br>5、Throwable类常见方法<br>6、自定义异常</p>
<p>第一节课 异常的继续体系和异常处理(46:21)<br>###01异常的概述.avi(01:43)<br>###02异常的继续体系和错误的区别.avi(07:56)<br>###03异常对象的产生原因和处理方式.avi(13:25)<br>###04方法内部抛出对象throw关键字.avi(13:38)<br>###05方法声明异常关键字throws.avi(09:37)</p>
<p>第二节课 异常处理方式讲解(42:37)<br>###06(异常)try…catch异常处理.avi(19:50)<br>###07(异常)多catch处理.avi(02:46)<br>###08(异常)多catch处理细节.avi(10:44)<br>###09(异常)finally代码块.avi(04:21)<br>###10(异常)调用抛出异常方法try和throws处理方式.avi(04:54)</p>
<p>第三节课 运行时期异常和方法重写的异常处理(39:45)<br>###11(异常)运行时期异常的特点.avi(11:00)<br>###12(异常)运行异常的案例.avi(08:53)<br>###13(异常)方法重写时候异常的处理.avi(11:6)<br>###14(异常)Throwable类方法.avi(08:45)</p>
<p>第四节课 自定义异常与总结(13:32)<br>###15(异常)自定义异常.avi(13:32)</p>
<p>============上面的内容,方便我们只做ppt,word教案以及书写下面的简要的笔记=================</p>
<p>=======================第一节课开始=============================================</p>
<p>###01异常的概述<br>    * A: 异常的概述<br>        * a:什么是异常<br>            * Java代码在运行时期发生的问题就是异常。<br>        * b:异常类<br>            * 在Java中，把异常信息封装成了一个类。<br>            * 当出现了问题时，就会创建异常类对象并抛出异常相关的信息（如异常出现的位置、原因等）。<br>        * c：我们见过的异常：数组角标越界异常ArrayIndexOutOfBoundsException,空指针异常NullPointerException</p>
<p>###02异常的继续体系和错误的区别<br>    * A: 异常的继承体系<br>        Throwable: 它是所有错误与异常的超类（祖宗类）<br>            |- Error 错误<br>            |- Exception 编译期异常,进行编译JAVA程序时出现的问题<br>                |- RuntimeException 运行期异常, JAVA程序运行过程中出现的问题<br>    * B：异常与错误的区别<br>        * a：异常<br>            * 指程序在编译、运行期间发生了某种异常(XxxException)，我们可以对异常进行具体的处理。<br>            * 若不处理异常，程序将会结束运行。<br>            * 案例演示：<br>                public static void main(String[] args) {<br>                    int[] arr = new int[3];<br>                    System.out.println(arr[0]);<br>                    System.out.println(arr[3]);<br>                    // 该句运行时发生了数组索引越界异常ArrayIndexOutOfBoundsException，<br>                    // 由于没有处理异常，导致程序无法继续执行，程序结束。<br>                    System.out.println(“over”); // 由于上面代码发生了异常，此句代码不会执行<br>                }</p>
<pre><code>* b：错误
    * 指程序在运行期间发生了某种错误(XxxError)，Error错误通常没有具体的处理方式，程序将会结束运行。
    * Error错误的发生往往都是系统级别的问题，都是jvm所在系统发生的，并反馈给jvm的。
    * 我们无法针对处理，只能修正代码。
    * 案例演示：
        public static void main(String[] args) {
            int[] arr = new int[1024*1024*100];
            //该句运行时发生了内存溢出错误OutOfMemoryError，开辟了过大的数组空间，
            //导致JVM在分配数组空间时超出了JVM内存空间，直接发生错误。
        }</code></pre><p>###03异常对象的产生原因和处理方式<br>    * A: 异常对象的产生原因<br>        * 案例代码：<br>            * 工具类<br>            class ArrayTools{<br>                //对给定的数组通过给定的角标获取元素。<br>                public static int getElement(int[] arr,int index)    {<br>                    int element = arr[index];<br>                    return element;<br>                }<br>            }<br>            * 测试类<br>            class ExceptionDemo2 {<br>                public static void main(String[] args)     {<br>                    int[] arr = {34,12,67};<br>                    int num = ArrayTools.getElement(arr,4)<br>                    System.out.println(“num=”+num);<br>                    System.out.println(“over”);<br>                }<br>            }<br>        * 原因分析：<br>            * a: 由于没找到4索引，导致运行时发生了异常。这个异常JVM认识：ArrayIndexOutOfBoundsException。<br>                这个异常Java本身有描述：异常的名称、异常的内容、异常的产生位置。<br>                java将这些信息直接封装到异常对象中。new ArrayIndexOutOfBoundsException(4);<br>            * b：throw new ArrayIndexOutOfBoundsException(4);产生异常对象。JVM将产生的异常抛给调用者main()方法。<br>            * c：main()方法接收到了数组索引越界异常对象。<br>                由于main()方法并没有进行处理异常，main()方法就会继续把异常抛给调用者JVM。<br>                当JVM收到异常后，将异常对象中的名称、异常内容、位置都显示在就控制台上。同时让程序立刻终止。<br>    * B：异常的处理方式<br>        * a：JVM的默认处理方式<br>            * 把异常的名称,原因,位置等信息输出在控制台，同时会结束程序。<br>            * 一旦有异常发生，其后来的代码不能继续执行。<br>        * b：解决程序中异常的手动方式<br>            * a)：编写处理代码 try…catch…finally<br>            * b)：抛出 throws</p>
<p>###04方法内部抛出对象throw关键字<br>    在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。<br>    * A: 什么时候使用throw关键字？<br>        * 当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，<br>          数据若不合法，就应该告诉调用者，传递合法的数据进来。<br>          这时需要使用抛出异常的方式来告诉调用者。<br>    * B: 使用throw关键字具体操作<br>        * a: 创建一个异常对象。封装一些提示信息(信息可以自己编写)。<br>        * b: 通过关键字throw将这个异常对象告知给调用者。throw 异常对象；<br>        throw 用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。<br>    * C: throw关键字使用格式<br>        * throw new 异常类名(参数);<br>        * 例如：<br>            throw new NullPointerException(“要访问的arr数组不存在”);<br>            throw new ArrayIndexOutOfBoundsException(“该索引在数组中不存在，已超出范围”);<br>    * D：案例演示<br>        * throw的使用</p>
<p>###05方法声明异常关键字throws<br>    * A: 声明<br>        * 将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。<br>    * B: 声明异常格式<br>        * 修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2… {   }<br>    * C：注意事项：<br>        * throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。<br>    * D：代码演示：<br>        * 多个异常的处理</p>
<p>​<br>​<br>==============================第二节课开始====================================        </p>
<p>​                </p>
<p>###06try…catch异常处理<br>    * A: 捕获<br>        * Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理<br>    * B: 捕获异常格式<br>        try {<br>            //需要被检测的语句。<br>        }<br>        catch(异常类 变量) { //参数。<br>            //异常的处理语句。<br>        }<br>        finally {<br>            //一定会被执行的语句。<br>        }<br>    * C: 格式说明<br>        * a: try<br>            * 该代码块中编写可能产生异常的代码。<br>        * b: catch<br>            * 用来进行某种异常的捕获，实现对捕获到的异常进行处理。<br>        * c: finally：<br>            * 有一些特定的代码无论异常是否发生，都需要执行。<br>            * 另外，因为异常会引发程序跳转，导致有些语句执行不到。<br>            * 而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。<br>        * d：try…catch…处理掉异常后，程序可以继续执行<br>    * D：案例演示<br>        * 捕获异常格式</p>
<p>###07多catch处理<br>    * A：一个try 多个catch组合<br>        * 对代码进行异常检测，并对检测的异常传递给catch处理。对每种异常信息进行不同的捕获处理。<br>    * B：多catch处理的格式<br>        void show(){ //不用throws<br>            try{<br>                throw new Exception();//产生异常，直接捕获处理<br>            }catch(XxxException e){<br>                //处理方式<br>            }catch(YyyException e){<br>                //处理方式<br>            }catch(ZzzException e){<br>                //处理方式<br>            }<br>        }<br>        注意事项：在捕获异常处理中，变量也是有作用域的，如可以定义多个catch中异常变量名为e。</p>
<p>###08多catch处理细节<br>    * A：细节：多个catch小括号中，写的是异常类的类名，有没有顺序的概念？<br>        * 有顺序关系。<br>    * B：平级异常：<br>        * 抛出的异常类之间,没有继承关系,没有顺序<br>            NullPointerException extends RuntimeException<br>            NoSuchElementException extends RuntimeException<br>            ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException extends RuntimeException<br>    * C：上下级关系的异常<br>        * 越高级的父类,越写在下面<br>            NullPointerException extends RuntimeException extends Exception</p>
<p>###09finally代码块<br>    * A: finally的特点<br>        * 被finally控制的语句体一定会执行<br>    * B：finally的作用<br>        * finally,无论程序是否有异常出现,程序必须执行释放资源在<br>          如：IO流操作和数据库操作中会见到</p>
<p>###10调用抛出异常方法try和throws处理方式<br>    * A: 在实际开发中使用哪种异常处理方式呢？<br>        * 能自己处理的尽量自己处理。(建议用try…catch)</p>
<p>​<br>==============================第三节课开始====================================<br>​<br>###11运行时期异常的特点<br>    * A: 运行时期异常的概述:<br>        * RuntimeException和他的所有子类异常,都属于运行时期异常。<br>            NullPointerException,ArrayIndexOutOfBoundsException等都属于运行时期异常.<br>    * B：运行时期异常的特点<br>        * a：方法中抛出运行时期异常,方法定义中无需throws声明,调用者也无需处理此异常。<br>        * b：运行时期异常一旦发生,需要程序人员修改源代码。<br>        设计原因:<br>            运行异常,不能发生,但是如果发生了,程序人员停止程序修改源代码<br>            运行异常: 一旦发生,不要处理,请你修改源代码,运行异常一旦发生,后面的代码没有执行的意义</p>
<p>###12运行异常的案例<br>    * A: 计算圆的面积案例<br>        定义方法,计算圆形的面积<br>        传递参数0,或者负数,计算的时候没有问题<br>        但是,违反了真实情况<br>        参数小于=0, 停止程序,不要在计算了<br>    * B：数组索引越界案例<br>        使用数组中不存在的索引<br>        public class RuntimeExceptionDemo {<br>            public static void main(String[] args) {<br>                    double d = getArea(1);<br>                    System.out.println(d);<br>            }</p>
<pre><code>    /*
     *  定义方法,计算圆形的面积
     *  传递参数0,或者负数,计算的时候没有问题
     *  但是,违反了真实情况
     *  参数小于=0, 停止程序,不要在计算了
     */
    public static double getArea(double r){
        if(r &lt;= 0)
            throw new RuntimeException(&quot;圆形不存在&quot;);
        return r*r*Math.PI;
    }

    public static void function(){
        int[] arr = {1,2,3};
        //对数组的5索引进行判断,如果5索引大于100,请将5索引上的数据/2,否则除以3
        //索引根本就没有
        if(arr[5] &gt; 100){
            arr[5] = arr[5]/2;
        }else{
            arr[5] = arr[5]/3;
        }
}</code></pre><p>###13方法重写时候异常的处理<br>    * A：方法重写时候异常的处理<br>        * a：子类覆盖父类方法时，如果父类的方法声明异常，子类只能声明父类异常或者该异常的子类，或者不声明。<br>            例如：<br>            class Fu {<br>                public void method () throws RuntimeException {<br>                }<br>            }<br>            class Zi extends Fu {<br>                public void method() throws RuntimeException { }  //抛出父类一样的异常<br>                //public void method() throws NullPointerException{ } //抛出父类子异常<br>            }<br>        * b：当父类方法声明多个异常时，子类覆盖时只能声明多个异常的子集。<br>            例如：<br>            class Fu {<br>                public void method () throws NullPointerException, ClassCastException{<br>                }<br>            }<br>            class Zi extends Fu {<br>                public void method()throws NullPointerException, ClassCastException { }<br>                public void method() throws NullPointerException{ } //抛出父类异常中的一部分<br>                public void method() throws ClassCastException { } //抛出父类异常中的一部分<br>            }<br>        * c：当被覆盖的方法没有异常声明时，子类覆盖时无法声明异常的。<br>            例如：<br>            class Fu {<br>                public void method (){<br>                }<br>            }<br>            class Zi extends Fu {<br>                public void method() throws Exception { }//错误的方式<br>            }<br>    * B：问题：父类中会存在下列这种情况，接口也有这种情况。<br>                接口中没有声明异常，而实现的子类覆盖方法时发生了异常，怎么办？<br>         回答：无法进行throws声明，只能catch的捕获。<br>                万一问题处理不了呢？catch中继续throw抛出，但是只能将异常转换成RuntimeException子类抛出。</p>
<p>###14Throwable类方法<br>    * A: 常见方法<br>        * a：getMessage()方法<br>            返回该异常的详细信息字符串，即异常提示信息<br>        * b：toString()方法<br>            返回该异常的名称与详细信息字符串<br>        * c：printStackTrace()方法<br>            在控制台输出该异常的名称与详细信息字符串、异常出现的代码位置<br>    * B：案例演示<br>        异常的常用方法代码演示<br>            try {<br>                Person p= null;<br>                if (p==null) {<br>                    throw new NullPointerException(“出现空指针异常了，请检查对象是否为null”);<br>                }<br>            } catch (NullPointerException e) {<br>                String message = e.getMesage();<br>                System.out.println(message ); </p>
<pre><code>    String result = e.toString();
    System.out.println(result);    

    e.printStackTrace(); 
}</code></pre><p>​<br>​<br>======================第四节课开始=========</p>
<p>###15自定义异常<br>    * A: 自定义异常的定义<br>        * a：通过阅读源码，发现规律：<br>            每个异常中都调用了父类的构造方法，把异常描述信息传递给了父类，让父类帮我们进行异常信息的封装。<br>        * b：格式：<br>            Class 异常名 extends Exception{ //或继承RuntimeException<br>                public 异常名(){<br>                }<br>                public 异常名(String s){<br>                    super(s);<br>                }<br>            }    </p>
<pre><code>    * c：自定义异常继承Exception演示
    * d：自定义异常继承RuntimeException演示
* B：自定义异常的练习
    在Person类的有参数构造方法中，进行年龄范围的判断，
    若年龄为负数或大于200岁，则抛出NoAgeException异常，异常提示信息“年龄数值非法”。
    要求：在测试类中，调用有参数构造方法，完成Person对象创建，并进行异常的处理。

* C：关于构造方法抛出异常总结
    构造函数到底抛出这个NoAgeException是继承Exception呢？还是继承RuntimeException呢？
    * a：继承Exception，必须要throws声明，一声明就告知调用者进行捕获，一旦问题处理了调用者的程序会继续执行。
    * b：继承RuntimeExcpetion,不需要throws声明的，这时调用是不需要编写捕获代码的，因为调用根本就不知道有问题。
        一旦发生NoAgeException，调用者程序会停掉，并有jvm将信息显示到屏幕，让调用者看到问题，修正代码。</code></pre><p>​<br>###16总结</p>
<ul>
<li>把今天的知识点总结一遍。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day20%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day20%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">java学习笔记20</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:13" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:13+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 23:11:25" itemprop="dateModified" datetime="2020-12-23T23:11:25+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、Map接口<br>2、模拟斗地主洗牌发牌</p>
<p>=======================第一节课开始=============================================</p>
<p>###01Map集合概述<br>  A:Map集合概述:<br>    我们通过查看Map接口描述,发现Map接口下的集合与Collection接口下的集合，它们存储数据的形式不同<br>        a:Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。<br>    <br>        b:Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。<br>    <br>        Collection中的集合称为单列集合，Map中的集合称为双列集合。<br>        需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。<br>    Map<br>     |–HashMap<br>     |–LinkedHashMap</p>
<p>###02Map接口中的常用方法<br>  A:Map接口中的常用方法<br>       /*<br>        *  Map接口中的常用方法<br>        *    使用Map接口的实现类 HashMap<br>        <em>/<br>       public class MapDemo {<br>           public static void main(String[] args) {<br>               function_2();<br>           }<br>           /</em><br>            *  移除集合中的键值对,返回被移除之前的值<br>            *  V remove(K)<br>            */<br>           public static void function_2(){<br>               Map&lt;Integer,String&gt; map = new HashMap&lt;Integer, String&gt;();<br>               map.put(1, “a”);<br>               map.put(2, “b”);<br>               map.put(3, “c”);<br>               System.out.println(map);</p>
<pre><code>        String value = map.remove(33);
        System.out.println(value);
        System.out.println(map);
    }

    /*
     * 通过键对象,获取值对象
     * V get(K)
     * 如果集合中没有这个键,返回null
     */
    public static void function_1(){
        //创建集合对象,作为键的对象整数,值的对象存储字符串
        Map&lt;Integer,String&gt; map = new HashMap&lt;Integer, String&gt;();
        map.put(1, &quot;a&quot;);
        map.put(2, &quot;b&quot;);
        map.put(3, &quot;c&quot;);
        System.out.println(map);

        String value = map.get(4);
        System.out.println(value);
    }

    /*
     *  将键值对存储到集合中
     *  V put(K,V) K 作为键的对象, V作为值的对象
     *  存储的是重复的键,将原有的值,覆盖
     *  返回值一般情况下返回null,
     *  存储重复键的时候,返回被覆盖之前的值
     */
    public static void function(){
        //创建集合对象,HashMap,存储对象,键是字符串,值是整数
        Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();
        map.put(&quot;a&quot;, 1);

        map.put(&quot;b&quot;, 2);

        map.put(&quot;c&quot;, 3);

        System.out.println(map);
    }
}</code></pre><p>###03Map集合遍历方式keySet方法<br>  A:Map集合遍历方式keySet方法<br>     1.获取Map集合中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键<br>     2.遍历键的Set集合，得到每一个键<br>     3.根据键利用get(key)去Map找所对应的值<br>     /*<br>      *  Map集合的遍历<br>      *    利用键获取值<br>      *    Map接口中定义方法keySet<br>      *    所有的键,存储到Set集合<br>      <em>/<br>     public class MapDemo1 {<br>         public static void main(String[] args) {<br>             /</em><br>              *  1. 调用map集合的方法keySet,所有的键存储到Set集合中<br>              *  2. 遍历Set集合,获取出Set集合中的所有元素 (Map中的键)<br>              *  3. 调用map集合方法get,通过键获取到值<br>              */<br>             Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();<br>             map.put(“a”, 11);<br>             map.put(“b”, 12);<br>             map.put(“c”, 13);<br>             map.put(“d”, 14);</p>
<pre><code>        //1. 调用map集合的方法keySet,所有的键存储到Set集合中
        Set&lt;String&gt; set = map.keySet();
        //2. 遍历Set集合,获取出Set集合中的所有元素 (Map中的键)
        Iterator&lt;String&gt; it = set.iterator();
        while(it.hasNext()){
            //it.next返回是Set集合元素,也就是Map中的键
            //3. 调用map集合方法get,通过键获取到值
            String key = it.next();
            Integer value = map.get(key);
            System.out.println(key+&quot;....&quot;+value);
        }

        System.out.println(&quot;=======================&quot;);


        for(String key : map.keySet()){
            Integer value = map.get(key);
            System.out.println(key+&quot;....&quot;+value);
        }
    }
}</code></pre><p>###04Map集合Entry对象<br>   A:Map集合Entry对象<br>     interface Map{<br>         interface Entry{//Entry是Map的一个内部接口<br>                        //由Map的子类的内部类实现</p>
<pre><code>    }
}
class HashMap{
    static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {//Entry对象指的就是该类的对象
       final K key;
             V value;
    }
}
在Map类设计时，提供了一个嵌套接口：Entry。
Entry将键值对的对应关系封装成了对象。
即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对（Entry）对象中获取对应的键与对应的值。
  a:Entry是Map接口中提供的一个静态内部嵌套接口。
  b:相关方法
     getKey()方法：获取Entry对象中的键
  getValue()方法：获取Entry对象中的值
  entrySet()方法：用于返回Map集合中所有的键值对(Entry)对象，以Set集合形式返回。</code></pre><p>###05Map集合遍历方式entrySet方法<br>   A:Map集合遍历方式entrySet方法<br>    *<br>     *  Map集合获取方式<br>     *  entrySet方法,键值对映射关系(结婚证)获取<br>     *  实现步骤:<br>     *    1. 调用map集合方法entrySet()将集合中的映射关系对象,存储到Set集合<br>     *        Set&lt;Entry &lt;K,V&gt; &gt;<br>     *    2. 迭代Set集合<br>     *    3. 获取出的Set集合的元素,是映射关系对象<br>     *    4. 通过映射关系对象方法 getKet, getValue获取键值对<br>     *<br>     *    创建内部类对象 外部类.内部类 = new<br>     */<br>    public class MapDemo2 {<br>        public static void main(String[] args) {<br>            Map&lt;Integer,String&gt; map = new HashMap&lt;Integer, String&gt;();<br>            map.put(1, “abc”);<br>            map.put(2, “bcd”);<br>            map.put(3, “cde”);<br>            //1. 调用map集合方法entrySet()将集合中的映射关系对象,存储到Set集合<br>            Set&lt;Map.Entry &lt;Integer,String&gt; &gt;  set = map.entrySet();<br>            //2. 迭代Set集合<br>            Iterator&lt;Map.Entry &lt;Integer,String&gt; &gt; it = set.iterator();<br>            while(it.hasNext()){<br>                //  3. 获取出的Set集合的元素,是映射关系对象<br>                // it.next 获取的是什么对象,也是Map.Entry对象<br>                Map.Entry&lt;Integer, String&gt; entry = it.next();<br>                //4. 通过映射关系对象方法 getKet, getValue获取键值对<br>                Integer key = entry.getKey();<br>                String value = entry.getValue();<br>                System.out.println(key+”….”+value);<br>            }</p>
<pre><code>    }
}</code></pre><p>=======================第二节课开始============================================<br>###06Map集合遍历方式增强for循环<br>   A:Map集合遍历方式增强for循环<br>     A:Map集合遍历方式entrySet方法<br>      *<br>       *  Map集合获取方式<br>       *  entrySet方法,键值对映射关系(结婚证)获取<br>       *  实现步骤:<br>       *    1. 调用map集合方法entrySet()将集合中的映射关系对象,存储到Set集合<br>       *        Set&lt;Entry &lt;K,V&gt; &gt;<br>       *    2. 迭代Set集合<br>       *    3. 获取出的Set集合的元素,是映射关系对象<br>       *    4. 通过映射关系对象方法 getKet, getValue获取键值对<br>       *<br>       *    创建内部类对象 外部类.内部类 = new<br>       */<br>      public class MapDemo2 {<br>          public static void main(String[] args) {<br>              Map&lt;Integer,String&gt; map = new HashMap&lt;Integer, String&gt;();<br>              map.put(1, “abc”);<br>              map.put(2, “bcd”);<br>              map.put(3, “cde”);<br>              //1. 调用map集合方法entrySet()将集合中的映射关系对象,存储到Set集合<br>              Set&lt;Map.Entry &lt;Integer,String&gt; &gt;  set = map.entrySet();<br>              //2. 迭代Set集合<br>              Iterator&lt;Map.Entry &lt;Integer,String&gt; &gt; it = set.iterator();<br>              while(it.hasNext()){<br>                  //  3. 获取出的Set集合的元素,是映射关系对象<br>                  // it.next 获取的是什么对象,也是Map.Entry对象<br>                  Map.Entry&lt;Integer, String&gt; entry = it.next();<br>                  //4. 通过映射关系对象方法 getKet, getValue获取键值对<br>                  Integer key = entry.getKey();<br>                  String value = entry.getValue();<br>                  System.out.println(key+”….”+value);<br>              }</p>
<pre><code>        System.out.println(&quot;=========================&quot;);
        for(Map.Entry&lt;Integer, String&gt; entry : map.entrySet()){
            System.out.println(entry.getKey()+&quot;...&quot;+entry.getValue());
        }
    }
}

注意：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。</code></pre><p>###07HashMap集合存储和遍历<br>  A:HashMap集合存储和遍历<br>     /*<br>      *  使用HashMap集合,存储自定义的对象<br>      *  自定义对象,作为键,出现,作为值出现<br>      <em>/<br>     public class HashMapDemo {<br>         public static void main(String[] args) {<br>             function_1();<br>         }<br>         /</em><br>          * HashMap 存储自定义对象Person,作为键出现<br>          * 键的对象,是Person类型,值是字符串<br>          * 保证键的唯一性,存储到键的对象,重写hashCode equals<br>          */<br>         public static void function_1(){<br>             HashMap&lt;Person, String&gt; map = new HashMap&lt;Person, String&gt;();<br>             map.put(new Person(“a”,20), “里约热内卢”);<br>             map.put(new Person(“b”,18), “索马里”);<br>             map.put(new Person(“b”,18), “索马里”);<br>             map.put(new Person(“c”,19), “百慕大”);<br>             for(Person key : map.keySet()){<br>                 String value = map.get(key);<br>                 System.out.println(key+”…”+value);<br>             }<br>             System.out.println(“===================”);<br>             for(Map.Entry&lt;Person, String&gt; entry : map.entrySet()){<br>                 System.out.println(entry.getKey()+”…”+entry.getValue());<br>             }<br>         }</p>
<pre><code>    /*
     * HashMap 存储自定义的对象Person,作为值出现
     * 键的对象,是字符串,可以保证唯一性
     */
    public static void function(){
        HashMap&lt;String, Person&gt; map = new HashMap&lt;String, Person&gt;();
        map.put(&quot;beijing&quot;, new Person(&quot;a&quot;,20));
        map.put(&quot;tianjin&quot;, new Person(&quot;b&quot;,18));
        map.put(&quot;shanghai&quot;, new Person(&quot;c&quot;,19));
        for(String key : map.keySet()){
            Person value = map.get(key);
            System.out.println(key+&quot;...&quot;+value);
        }
        System.out.println(&quot;=================&quot;);
        for(Map.Entry&lt;String, Person&gt; entry : map.entrySet()){
            String key = entry.getKey();
            Person value = entry.getValue();
            System.out.println(key+&quot;...&quot;+value);
        }
    }
}</code></pre><p>###08LinkedHashMap的特点<br>   *A:LinkedHashMap的特点</p>
<pre><code>/*
 *  LinkedHashMap继承HashMap
 *  保证迭代的顺序
 */
public class LinkedHashMapDemo {
    public static void main(String[] args) {
        LinkedHashMap&lt;String, String&gt; link = new LinkedHashMap&lt;String, String&gt;();
        link.put(&quot;1&quot;, &quot;a&quot;);
        link.put(&quot;13&quot;, &quot;a&quot;);
        link.put(&quot;15&quot;, &quot;a&quot;);
        link.put(&quot;17&quot;, &quot;a&quot;);
        System.out.println(link);
    }
}</code></pre><p>###09Hashtable的特点<br>   <em>A:Hashtable的特点<br>       /</em><br>        *  Map接口实现类 Hashtable<br>        *  底层数据结果哈希表,特点和HashMap是一样的<br>        *  Hashtable 线程安全集合,运行速度慢<br>        *  HashMap 线程不安全的集合,运行速度快<br>        *<br>        *  Hashtable命运和Vector是一样的,从JDK1.2开始,被更先进的HashMap取代<br>        *<br>        *  HashMap 允许存储null值,null键<br>        *  Hashtable 不允许存储null值,null键<br>        *<br>        *  Hashtable他的孩子,子类 Properties 依然活跃在开发舞台<br>        */<br>       public class HashtableDemo {<br>           public static void main(String[] args) {<br>               Map&lt;String,String&gt; map = new Hashtable&lt;String,String&gt;();<br>               map.put(null, null);<br>               System.out.println(map);<br>           }<br>       }</p>
<p>###10静态导入<br>   <em>A:静态导入:如果本类中有和静态导入的同名方法会优先使用本类的<br>               如果还想使用静态导入的,依然需要类名来调用<br>       /</em><br>        * JDK1.5新特性,静态导入<br>        * 减少开发的代码量<br>        * 标准的写法,导入包的时候才能使用<br>        *<br>        * import static java.lang.System.out;最末尾,必须是一个静态成员<br>        */<br>       import static java.lang.System.out;<br>       import static java.util.Arrays.sort;</p>
<pre><code>public class StaticImportDemo {
    public static void main(String[] args) {
        out.println(&quot;hello&quot;);

        int[] arr = {1,4,2};
        sort(arr);
    }
}</code></pre><p>###11方法的可变参数<br>   <em>A:方法的可变参数<br>     /</em><br>      *  JDK1.5新的特性,方法的可变参数<br>      *  前提: 方法参数数据类型确定,参数的个数任意<br>      *  可变参数语法: 数据类型…变量名<br>      *  可变参数,本质就是一个数组<br>      */<br>     public class VarArgumentsDemo {<br>         public static void main(String[] args) {<br>             //调用一个带有可变参数的方法,传递参数,可以任意<br>         //    getSum();<br>             int sum = getSum(5,34,3,56,7,8,0);<br>             System.out.println(sum);</p>
<pre><code>    }

    /*
     * 定义方法,计算10个整数和
     * 方法的可变参数实现
     */
    public static int getSum(int...a){
        int sum = 0 ;
        for(int i : a){
            sum = sum + i;
        }
        return sum;
    }

    /*
     * 定义方法,计算3个整数和
     */
    /*public static int getSum(int a,int b ,int c){
        return a+b+c;
    }*/

    /*
     * 定义方法,计算2个整数和
     */
    /*public static int getSum(int a,int b){
        return a+b;
    }*/
}</code></pre><p>###12可变参数的注意事项<br>   <em>A:可变参数的注意事项<br>       /</em><br>        * 可变参数的注意事项<br>        * 1. 一个方法中,可变参数只能有一个<br>        * 2. 可变参数,必须写在参数列表的最后一位<br>        */<br>        public static void function(Object…o){</p>
<pre><code>}</code></pre><p>=======================第三节课开始=============================================<br>###13Collections工具类<br>   A:Collections工具类<br>      /*<br>       *  集合操作的工具类<br>       *    Collections<br>       <em>/<br>      public class CollectionsDemo {<br>          public static void main(String[] args) {<br>              function_2();<br>          }<br>          /</em><br>           * Collections.shuffle方法<br>           * 对List集合中的元素,进行随机排列<br>           */<br>          public static void function_2(){<br>              List<Integer> list = new ArrayList<Integer>();<br>              list.add(1);<br>              list.add(5);<br>              list.add(9);<br>              list.add(11);<br>              list.add(8);<br>              list.add(10);<br>              list.add(15);<br>              list.add(20);<br>              System.out.println(list);</Integer></Integer></p>
<pre><code>        //调用工具类方法shuffle对集合随机排列
        Collections.shuffle(list);
        System.out.println(list);
    }

    /*
     * Collections.binarySearch静态方法
     * 对List集合进行二分搜索,方法参数,传递List集合,传递被查找的元素
     */
    public static void function_1(){
        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        list.add(1);
        list.add(5);
        list.add(8);
        list.add(10);
        list.add(15);
        list.add(20);
        //调用工具类静态方法binarySearch
        int index = Collections.binarySearch(list, 16);
        System.out.println(index);
    }

    /*
     *  Collections.sort静态方法
     *  对于List集合,进行升序排列
     */
    public static void function(){
        //创建List集合
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(&quot;ewrew&quot;);
        list.add(&quot;qwesd&quot;);
        list.add(&quot;Qwesd&quot;);
        list.add(&quot;bv&quot;);
        list.add(&quot;wer&quot;);
        System.out.println(list);
        //调用集合工具类的方法sort
        Collections.sort(list);
        System.out.println(list);
    }
}</code></pre><p>###14集合的嵌套<br>   A:集合的嵌套<br>    /*<br>     *  Map集合的嵌套,Map中存储的还是Map集合<br>     *  要求:<br>     *    传智播客<br>     *      Java基础班<br>     *        001  张三<br>     *        002  李四<br>     *<br>     *      Java就业班<br>     *        001  王五<br>     *        002  赵六<br>     *  对以上数据进行对象的存储<br>     *   001 张三  键值对<br>     *   Java基础班: 存储学号和姓名的键值对<br>     *   Java就业班:<br>     *   传智播客: 存储的是班级<br>     *<br>     *   基础班Map   &lt;学号,姓名&gt;<br>     *   传智播客Map  &lt;班级名字, 基础班Map&gt;<br>     */<br>    public class MapMapDemo {<br>        public static void main(String[] args) {<br>            //定义基础班集合<br>            HashMap&lt;String, String&gt; javase = new HashMap&lt;String, String&gt;();<br>            //定义就业班集合<br>            HashMap&lt;String, String&gt; javaee = new HashMap&lt;String, String&gt;();<br>            //向班级集合中,存储学生信息<br>            javase.put(“001”, “张三”);<br>            javase.put(“002”, “李四”);</p>
<pre><code>    javaee.put(&quot;001&quot;, &quot;王五&quot;);
    javaee.put(&quot;002&quot;, &quot;赵六&quot;);
    //定义传智播客集合容器,键是班级名字,值是两个班级容器
    HashMap&lt;String, HashMap&lt;String,String&gt;&gt; czbk =
            new HashMap&lt;String, HashMap&lt;String,String&gt;&gt;();
    czbk.put(&quot;基础班&quot;, javase);
    czbk.put(&quot;就业班&quot;, javaee);

     keySet(czbk);

}</code></pre><p>###15集合的嵌套keySet遍历<br>   A:集合的嵌套keySet遍历<br>       /*<br>        *  Map集合的嵌套,Map中存储的还是Map集合<br>        *  要求:<br>        *    传智播客<br>        *      Java基础班<br>        *        001  张三<br>        *        002  李四<br>        *<br>        *      Java就业班<br>        *        001  王五<br>        *        002  赵六<br>        *  对以上数据进行对象的存储<br>        *   001 张三  键值对<br>        *   Java基础班: 存储学号和姓名的键值对<br>        *   Java就业班:<br>        *   传智播客: 存储的是班级<br>        *<br>        *   基础班Map   &lt;学号,姓名&gt;<br>        *   传智播客Map  &lt;班级名字, 基础班Map&gt;<br>        */<br>       public class MapMapDemo {<br>           public static void main(String[] args) {<br>               //定义基础班集合<br>               HashMap&lt;String, String&gt; javase = new HashMap&lt;String, String&gt;();<br>               //定义就业班集合<br>               HashMap&lt;String, String&gt; javaee = new HashMap&lt;String, String&gt;();<br>               //向班级集合中,存储学生信息<br>               javase.put(“001”, “张三”);<br>               javase.put(“002”, “李四”);</p>
<pre><code>    javaee.put(&quot;001&quot;, &quot;王五&quot;);
    javaee.put(&quot;002&quot;, &quot;赵六&quot;);
    //定义传智播客集合容器,键是班级名字,值是两个班级容器
    HashMap&lt;String, HashMap&lt;String,String&gt;&gt; czbk =
            new HashMap&lt;String, HashMap&lt;String,String&gt;&gt;();
    czbk.put(&quot;基础班&quot;, javase);
    czbk.put(&quot;就业班&quot;, javaee);

     keySet(czbk);

}</code></pre><p>​<br>​<br>           public static void keySet(HashMap&lt;String,HashMap&lt;String,String&gt;&gt; czbk){<br>               //调用czbk集合方法keySet将键存储到Set集合<br>               Set<String> classNameSet = czbk.keySet();<br>               //迭代Set集合<br>               Iterator<String> classNameIt = classNameSet.iterator();<br>               while(classNameIt.hasNext()){<br>                   //classNameIt.next获取出来的是Set集合元素,czbk集合的键<br>                   String classNameKey = classNameIt.next();<br>                   //czbk集合的方法get获取值,值是一个HashMap集合<br>                   HashMap&lt;String,String&gt; classMap = czbk.get(classNameKey);<br>                   //调用classMap集合方法keySet,键存储到Set集合<br>                   Set<String> studentNum = classMap.keySet();<br>                   Iterator<String> studentIt = studentNum.iterator();</String></String></String></String></p>
<pre><code>            while(studentIt.hasNext()){
                //studentIt.next获取出来的是classMap的键,学号
                String numKey = studentIt.next();
                //调用classMap集合中的get方法获取值
                String nameValue = classMap.get(numKey);
                System.out.println(classNameKey+&quot;..&quot;+numKey+&quot;..&quot;+nameValue);
            }
        }

        System.out.println(&quot;==================================&quot;);
        for(String className: czbk.keySet()){
           HashMap&lt;String, String&gt; hashMap = czbk.get(className);    
           for(String numKey : hashMap.keySet()){
               String nameValue = hashMap.get(numKey);
               System.out.println(className+&quot;..&quot;+numKey+&quot;..&quot;+nameValue);
           }
        }
    }

} </code></pre><p>###16集合的嵌套entrySet遍历<br>    A:集合的嵌套entrySet遍历<br>    /*<br>     *  Map集合的嵌套,Map中存储的还是Map集合<br>     *  要求:<br>     *    传智播客<br>     *      Java基础班<br>     *        001  张三<br>     *        002  李四<br>     *<br>     *      Java就业班<br>     *        001  王五<br>     *        002  赵六<br>     *  对以上数据进行对象的存储<br>     *   001 张三  键值对<br>     *   Java基础班: 存储学号和姓名的键值对<br>     *   Java就业班:<br>     *   传智播客: 存储的是班级<br>     *<br>     *   基础班Map   &lt;学号,姓名&gt;<br>     *   传智播客Map  &lt;班级名字, 基础班Map&gt;<br>     */<br>    public class MapMapDemo {<br>        public static void main(String[] args) {<br>            //定义基础班集合<br>            HashMap&lt;String, String&gt; javase = new HashMap&lt;String, String&gt;();<br>            //定义就业班集合<br>            HashMap&lt;String, String&gt; javaee = new HashMap&lt;String, String&gt;();<br>            //向班级集合中,存储学生信息<br>            javase.put(“001”, “张三”);<br>            javase.put(“002”, “李四”);</p>
<pre><code>    javaee.put(&quot;001&quot;, &quot;王五&quot;);
    javaee.put(&quot;002&quot;, &quot;赵六&quot;);
    //定义传智播客集合容器,键是班级名字,值是两个班级容器
    HashMap&lt;String, HashMap&lt;String,String&gt;&gt; czbk =
            new HashMap&lt;String, HashMap&lt;String,String&gt;&gt;();
    czbk.put(&quot;基础班&quot;, javase);
    czbk.put(&quot;就业班&quot;, javaee);

    entrySet(czbk);
}

public static void entrySet(HashMap&lt;String,HashMap&lt;String,String&gt;&gt; czbk){
    //调用czbk集合方法entrySet方法,将czbk集合的键值对关系对象,存储到Set集合
    Set&lt;Map.Entry&lt;String, HashMap&lt;String,String&gt;&gt;&gt; 
                             classNameSet = czbk.entrySet();
    //迭代器迭代Set集合
    Iterator&lt;Map.Entry&lt;String, HashMap&lt;String,String&gt;&gt;&gt; classNameIt = classNameSet.iterator();
    while(classNameIt.hasNext()){
        //classNameIt.next方法,取出的是czbk集合的键值对关系对象
        Map.Entry&lt;String, HashMap&lt;String,String&gt;&gt; classNameEntry =  classNameIt.next();
        //classNameEntry方法 getKey,getValue
        String classNameKey = classNameEntry.getKey();
        //获取值,值是一个Map集合
        HashMap&lt;String,String&gt; classMap = classNameEntry.getValue();
        //调用班级集合classMap方法entrySet,键值对关系对象存储Set集合
        Set&lt;Map.Entry&lt;String, String&gt;&gt; studentSet = classMap.entrySet();
        //迭代Set集合
        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; studentIt = studentSet.iterator();
        while(studentIt.hasNext()){
            //studentIt方法next获取出的是班级集合的键值对关系对象
            Map.Entry&lt;String, String&gt; studentEntry = studentIt.next();
            //studentEntry方法 getKey getValue
            String numKey = studentEntry.getKey();
            String nameValue = studentEntry.getValue();
            System.out.println(classNameKey+&quot;..&quot;+numKey+&quot;..&quot;+nameValue);
        }
    }
     System.out.println(&quot;==================================&quot;);

    for (Map.Entry&lt;String, HashMap&lt;String, String&gt;&gt; me : czbk.entrySet()) {
        String classNameKey = me.getKey();
        HashMap&lt;String, String&gt; numNameMapValue = me.getValue();
        for (Map.Entry&lt;String, String&gt; nameMapEntry : numNameMapValue.entrySet()) {
            String numKey = nameMapEntry.getKey();
            String nameValue = nameMapEntry.getValue();
            System.out.println(classNameKey + &quot;..&quot; + numKey + &quot;..&quot; + nameValue);
        }
    }
}</code></pre><p>​<br>    }</p>
<p>=======================第四节课开始=============================================</p>
<p>###17斗地主的功能分析<br>   A:斗地主的功能分析<br>       a:具体规则：<br>               1. 组装54张扑克牌<br>            2. 将54张牌顺序打乱<br>               3. 三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。<br>               4. 查看三人各自手中的牌（按照牌的大小排序）、底牌<br>       b:分析:<br>          1.准备牌：<br>           完成数字与纸牌的映射关系：<br>           使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。<br>          2.洗牌：<br>           通过数字完成洗牌发牌<br>          3.发牌：<br>           将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。<br>           存放的过程中要求数字大小与斗地主规则的大小对应。<br>           将代表不同纸牌的数字分配给不同的玩家与底牌。<br>          4.看牌：<br>           通过Map集合找到对应字符展示。<br>           通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</String></p>
<p>###18斗地主的准备牌<br>   A:斗地主的准备牌<br>     /*<br>      *  实现模拟斗地主的功能<br>      *   1. 组合牌<br>      *   2. 洗牌<br>      *   3. 发牌<br>      *   4. 看牌<br>      */<br>     public class DouDiZhu {<br>         public static void main(String[] args) {<br>             //1. 组合牌<br>             //创建Map集合,键是编号,值是牌<br>             HashMap&lt;Integer,String&gt; pooker = new HashMap&lt;Integer, String&gt;();<br>             //创建List集合,存储编号<br>             ArrayList<Integer> pookerNumber = new ArrayList<Integer>();<br>             //定义出13个点数的数组<br>             String[] numbers = {“2”,”A”,”K”,”Q”,”J”,”10”,”9”,”8”,”7”,”6”,”5”,”4”,”3”};<br>             //定义4个花色数组<br>             String[] colors = {“♠”,”♥”,”♣”,”♦”};<br>             //定义整数变量,作为键出现<br>             int index = 2;<br>             //遍历数组,花色+点数的组合,存储到Map集合<br>             for(String number : numbers){<br>                 for(String color : colors){<br>                     pooker.put(index, color+number);<br>                     pookerNumber.add(index);<br>                     index++;<br>                 }<br>             }<br>             //存储大王,和小王,索引是从0~54,对应大王,小王,…3(牌的顺序从大到小)<br>             pooker.put(0, “大王”);<br>             pookerNumber.add(0);<br>             pooker.put(1, “小王”);<br>             pookerNumber.add(1);</Integer></Integer></p>
<pre><code>}</code></pre><p>###19斗地主的洗牌<br>    A:斗地主的洗牌<br>      /*<br>       *  实现模拟斗地主的功能<br>       *   1. 组合牌<br>       *   2. 洗牌<br>       *   3. 发牌<br>       *   4. 看牌<br>       */<br>      public class DouDiZhu {<br>          public static void main(String[] args) {<br>              //1. 组合牌<br>              //创建Map集合,键是编号,值是牌<br>              HashMap&lt;Integer,String&gt; pooker = new HashMap&lt;Integer, String&gt;();<br>              //创建List集合,存储编号<br>              ArrayList<Integer> pookerNumber = new ArrayList<Integer>();<br>              //定义出13个点数的数组<br>              String[] numbers = {“2”,”A”,”K”,”Q”,”J”,”10”,”9”,”8”,”7”,”6”,”5”,”4”,”3”};<br>              //定义4个花色数组<br>              String[] colors = {“♠”,”♥”,”♣”,”♦”};<br>              //定义整数变量,作为键出现<br>              int index = 2;<br>              //遍历数组,花色+点数的组合,存储到Map集合<br>              for(String number : numbers){<br>                  for(String color : colors){<br>                      pooker.put(index, color+number);<br>                      pookerNumber.add(index);<br>                      index++;<br>                  }<br>              }<br>              //存储大王,和小王<br>              pooker.put(0, “大王”);<br>              pookerNumber.add(0);<br>              pooker.put(1, “小王”);<br>              pookerNumber.add(1);</Integer></Integer></p>
<pre><code>//洗牌,将牌的编号打乱
Collections.shuffle(pookerNumber);</code></pre><p>​<br>          }</p>
<pre><code>}</code></pre><p>###20斗地主的发牌<br>  A:斗地主的发牌<br>    /*<br>     *  实现模拟斗地主的功能<br>     *   1. 组合牌<br>     *   2. 洗牌<br>     *   3. 发牌<br>     *   4. 看牌<br>     */<br>    public class DouDiZhu {<br>        public static void main(String[] args) {<br>            //1. 组合牌<br>            //创建Map集合,键是编号,值是牌<br>            HashMap&lt;Integer,String&gt; pooker = new HashMap&lt;Integer, String&gt;();<br>            //创建List集合,存储编号<br>            ArrayList<Integer> pookerNumber = new ArrayList<Integer>();<br>            //定义出13个点数的数组<br>            String[] numbers = {“2”,”A”,”K”,”Q”,”J”,”10”,”9”,”8”,”7”,”6”,”5”,”4”,”3”};<br>            //定义4个花色数组<br>            String[] colors = {“♠”,”♥”,”♣”,”♦”};<br>            //定义整数变量,作为键出现<br>            int index = 2;<br>            //遍历数组,花色+点数的组合,存储到Map集合<br>            for(String number : numbers){<br>                for(String color : colors){<br>                    pooker.put(index, color+number);<br>                    pookerNumber.add(index);<br>                    index++;<br>                }<br>            }<br>            //存储大王,和小王<br>            pooker.put(0, “大王”);<br>            pookerNumber.add(0);<br>            pooker.put(1, “小王”);<br>            pookerNumber.add(1);</Integer></Integer></p>
<pre><code>        //洗牌,将牌的编号打乱
        Collections.shuffle(pookerNumber);

        //发牌功能,将牌编号,发给玩家集合,底牌集合
        ArrayList&lt;Integer&gt; player1 = new ArrayList&lt;Integer&gt;();
        ArrayList&lt;Integer&gt; player2 = new ArrayList&lt;Integer&gt;();
        ArrayList&lt;Integer&gt; player3 = new ArrayList&lt;Integer&gt;();
        ArrayList&lt;Integer&gt; bottom = new ArrayList&lt;Integer&gt;();

        //发牌采用的是集合索引%3
        for(int i = 0 ; i &lt; pookerNumber.size() ; i++){
            //先将底牌做好
            if(i &lt; 3){
                //存到底牌去
                bottom.add( pookerNumber.get(i));
               //对索引%3判断
            }else if(i % 3 == 0){
                //索引上的编号,发给玩家1
                player1.add( pookerNumber.get(i) );
            }else if( i % 3 == 1){
                //索引上的编号,发给玩家2
                player2.add( pookerNumber.get(i) );
            }else if( i % 3 == 2){
                //索引上的编号,发给玩家3
                player3.add( pookerNumber.get(i) );
            }
        }

    }

}</code></pre><p>###21斗地主的看牌<br>  A:斗地主的看牌<br>     /*<br>      *  实现模拟斗地主的功能<br>      *   1. 组合牌<br>      *   2. 洗牌<br>      *   3. 发牌<br>      *   4. 看牌<br>      */<br>     public class DouDiZhu {<br>         public static void main(String[] args) {<br>             //1. 组合牌<br>             //创建Map集合,键是编号,值是牌<br>             HashMap&lt;Integer,String&gt; pooker = new HashMap&lt;Integer, String&gt;();<br>             //创建List集合,存储编号<br>             ArrayList<Integer> pookerNumber = new ArrayList<Integer>();<br>             //定义出13个点数的数组<br>             String[] numbers = {“2”,”A”,”K”,”Q”,”J”,”10”,”9”,”8”,”7”,”6”,”5”,”4”,”3”};<br>             //定义4个花色数组<br>             String[] colors = {“♠”,”♥”,”♣”,”♦”};<br>             //定义整数变量,作为键出现<br>             int index = 2;<br>             //遍历数组,花色+点数的组合,存储到Map集合<br>             for(String number : numbers){<br>                 for(String color : colors){<br>                     pooker.put(index, color+number);<br>                     pookerNumber.add(index);<br>                     index++;<br>                 }<br>             }<br>             //存储大王,和小王<br>             pooker.put(0, “大王”);<br>             pookerNumber.add(0);<br>             pooker.put(1, “小王”);<br>             pookerNumber.add(1);</Integer></Integer></p>
<pre><code>        //洗牌,将牌的编号打乱
        Collections.shuffle(pookerNumber);

        //发牌功能,将牌编号,发给玩家集合,底牌集合
        ArrayList&lt;Integer&gt; player1 = new ArrayList&lt;Integer&gt;();
        ArrayList&lt;Integer&gt; player2 = new ArrayList&lt;Integer&gt;();
        ArrayList&lt;Integer&gt; player3 = new ArrayList&lt;Integer&gt;();
        ArrayList&lt;Integer&gt; bottom = new ArrayList&lt;Integer&gt;();

        //发牌采用的是集合索引%3
        for(int i = 0 ; i &lt; pookerNumber.size() ; i++){
            //先将底牌做好
            if(i &lt; 3){
                //存到底牌去
                bottom.add( pookerNumber.get(i));
               //对索引%3判断
            }else if(i % 3 == 0){
                //索引上的编号,发给玩家1
                player1.add( pookerNumber.get(i) );
            }else if( i % 3 == 1){
                //索引上的编号,发给玩家2
                player2.add( pookerNumber.get(i) );
            }else if( i % 3 == 2){
                //索引上的编号,发给玩家3
                player3.add( pookerNumber.get(i) );
            }
        }
        //对玩家手中的编号排序
        Collections.sort(player1);
        Collections.sort(player2);
        Collections.sort(player3);
        //看牌,将玩家手中的编号,到Map集合中查找,根据键找值
        //定义方法实现
        look(&quot;刘德华&quot;,player1,pooker);
        look(&quot;张曼玉&quot;,player2,pooker);
        look(&quot;林青霞&quot;,player3,pooker);
        look(&quot;底牌&quot;,bottom,pooker);
    }
    public static void look(String name,ArrayList&lt;Integer&gt; player,HashMap&lt;Integer,String&gt; pooker){
        //遍历ArrayList集合,获取元素,作为键,到集合Map中找值
        System.out.print(name+&quot; &quot;);
        for(Integer key : player){
            String value = pooker.get(key);
            System.out.print(value+&quot; &quot;);
        }
        System.out.println();
    }
}</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/36/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/36/">36</a><span class="page-number current">37</span><a class="page-number" href="/page/38/">38</a><span class="space">&hellip;</span><a class="page-number" href="/page/48/">48</a><a class="extend next" rel="next" href="/page/38/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">匡俊桦</p>
  <div class="site-description" itemprop="description">回忆的沙漏将曾经屈指可数的日子渐渐淡去</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">238</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">匡俊桦</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">29:11</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
