<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:type" content="website">
<meta property="og:title" content="KJHの博客">
<meta property="og:url" content="http://yoursite.com/page/26/index.html">
<meta property="og:site_name" content="KJHの博客">
<meta property="og:description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="匡俊桦">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/26/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>KJHの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KJHの博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录&回忆</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/" class="post-title-link" itemprop="url">C++运算符重载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-27 15:22:33 / 修改时间：15:23:22" itemprop="dateCreated datePublished" datetime="2020-12-27T15:22:33+08:00">2020-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一、运算符的定义</p>
<p>运算符重载就是运算符的“一符多用”。重载运算符是具有特殊名称的函数：保留字 operator 后接需定义的操作符符号。像任意其他函数一样，重载操作符具有返回类型和形参表，每个操作符用于内置类型都有关联的定义，当内置操作符和类型上的操作存在逻辑对应关系时，操作符重载最有用，最直观，使用重载操作符并不是创造命名操作。</p>
<p>二、在哪种情况下使用哪种重载运算符的方式合适？</p>
<p>C++ 提供了两种重载运算符的方式，在大多数情况下：</p>
<ul>
<li>只有一个操作数的运算符（一目）使用类运算符重载方式为好；</li>
<li>一般地说，如果运算符要修改操作数（类对象）的状态（值），则应使用类运算符（成员形式）。（在计算中可能改变操作数的值得运算符被称为有副作用的运算符，诸如：=、+=、-=、*=、/=、%=、++、– 等）；</li>
<li>C++规定，运算符=、()、[ ]、-&gt; 只能采用类运算符形式重载；</li>
<li>有两个操作数的运算符（二目）使用友元运算符重载方式为好；</li>
<li>友元运算符重载方式在操作数的数据类型自动转换方面更为宽容，尤其是第一个操作数希望能够隐式类型转换时，则应采用友元形式；</li>
<li>不允许重载的运算符有：&amp;&amp;、||、. 、:: 、 * 、?: 。</li>
</ul>
<p>三、运算符重载具体讨论（返回值和参数，这里讨论几个常用的运算符）</p>
<p>默认地，重载运算符必须与内置操作符保持一致，也就是说重载后的运算符必须与本来内置操作符保持特性一致。函数最主要的两个就是返回值和形参。</p>
<p>3.1、前缀++类运算符重载函数（前缀–类似）</p>
<p>自增（自减）操作符的前置式定义：累加（递减）而后取出；后置式定义：取出而后累加（递减）。</p>
<p>我们知道，在C语言里整型变量是允许连续前缀++两次的，也叫链式操作。这样为了保证重载运算符与内置操作符++类型一致，就要求前缀++类运算符重载函数也支持连续操作（链式操作），所以前缀++类运算符重载函数的返回值必须是类名的引用。上面第二点也说了，++作为单目运算符，并且会修改操作数的值，则应定义为类运算符，这样重载函数无形参。我们就可申明该前缀++类运算符重载函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zoo</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Zoo(<span class="keyword">int</span> lion_n = <span class="number">0</span>, <span class="keyword">int</span> tiger_n = <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		lion = lion_n; tiger = tiger_n; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	~Zoo()&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Zoo&amp; <span class="keyword">operator</span>++();<span class="comment">//无参，返回值为类名的引用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> lion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> tiger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面就是前缀++类运算符重载函数的实现了</p>
<p>内置类型前缀++操作符是直接修改了操作数，然后返回修改后的操作数本身（唯一地址），不存在复制的情况，所以重载函数也应遵循这一点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Zoo&amp; Zoo::<span class="keyword">operator</span>++()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++lion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++tiger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>由于函数的返回值类型被定义为引用，所以不会发生复制，返回的是操作数本身，完全符合内置前缀++的语法定义。</p>
<p>我们再来考虑错误情况：如果前缀++类运算符重载函数的返回值是类型，也就是返回一个对象，其对应实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Zoo Zoo::<span class="keyword">operator</span>++()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++lion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++tiger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>咋一看上面的也实现了前缀++的功能，但是返回值是对象，在函数返回时会发生复制，虽然该函数成功将操作类对象的成员修改了，但是函数返回的是一个复制品，然后再执行++链式操作时，修改的会是这个复制品的值（相当于这个复制品调用前缀++类运算符重载函数），本尊并没有修改，也就是不能成功实现链式操作，不符合内置++的语法定义（ C++中，前缀++是可以连续前缀两次以上的，但后缀++则不可以）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Zoo zoo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">++(++zoo);</span><br></pre></td></tr></table></figure>

<p>上面执行后，zoo.lion = 1，zoo.tiger = 1 。并不是期望的2。</p>
<p>至于返回其余类型那就更加错误了。</p>
<p>3.2、后缀++类运算符重载函数（后缀–类似）</p>
<p>与前缀++操作符一样，后缀++也是单目操作符，也会修改操作书本身，所以二者的形参数目和类型相同，为了区别函数，后缀++操作符接受一个额外的（即，无用的）int 型形参。使用后缀++操作符时，编译器提供0作为这个形参的实参。</p>
<p>与前缀++类运算符截然相反的是，后缀++返回值的类型恰恰不能是类的引用，其目的是在返回值时引起复制，即让一个并未自增的替身对象去参加表达式的后续运算，另外C/C++在语法上不允许后缀++连续运算两次以上，也就不要求返回引用，并且必须返回 const 对象。我们看看内置后缀++操作符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j = i++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i++++;  <span class="comment">//违法</span></span><br></pre></td></tr></table></figure>

<p>内置后缀++操作符，操作数 i 本身已经完成了自增，但是后续的赋值操作并不是将自增后的 i 赋值给j，而是将并未自增的替身参与赋值运算。所以在重载后缀++类运算符的时候，我们应该考虑这点，另外必须返回一个 const 对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Zoo Zoo::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">Zoo <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;<span class="comment">//拷贝构造函数，构造复制品</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++lion;<span class="comment">//本尊自增</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++tiger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;<span class="comment">//返回复制品</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在已经定义了前缀++类运算符重载函数的情况下，后缀++类运算符重载函数一般这样实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Zoo Zoo::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">Zoo <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;<span class="comment">//拷贝构造函数，构造复制品</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++(*<span class="keyword">this</span>);<span class="comment">//本尊自增</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;<span class="comment">//返回复制品</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.3、二目运算符重载（+=，-=，+，-） </p>
<p>先说复合赋值操作符，上面“+=”，“-=”也可认为是赋值操作符。内置+=、-=、%= 是允许进行链式操作的（如果不确定是否允许，可以写一个测试程序判断），所以为了与内置类型的操作一致，重载函数毫无疑问是返回一个引用，也避免了创建和撤销结果的临时副本。</p>
<p>但是“+”“-” 等是返回一个新的结果，这就要求算术运算符的重载不能返回一个引用，另外+的表达式也不能作为左值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = i + j + j;<span class="comment">//可以连续+，但是右边的i,j还是原值，(i+j) = i + i;错误！</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       i += (i += j);<span class="comment">//复合了赋值操作符，这样是允许的</span></span><br></pre></td></tr></table></figure>

<p>有了前面分析，不难写出上面的重载函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Zoo&amp; Zoo::<span class="keyword">operator</span>+=(Zoo &amp;rhs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	lion += rhs.lion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	tiger += rhs.tiger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继而过来讨论“+”“-”：</p>
<p><strong>返回值是一个右值</strong></p>
<p>前面说到了，“+”“-”是返回一个新的结果，算术运算符通常产生一个新值，该值是两个操作数的计算结果，它不同于任一操作数且在一个局部变量中计算，返回对那个变量的引用是一个运行时错误。通俗一点，假如算术运算符重载函数返回一个对象的引用，这个引用是两个操作的计算结果，它的本体就会是一个局部变量（对象），返回一个局部变量的引用，是错误的。所以对于类算术运算符的重载，只能返回一个右值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Zoo <span class="keyword">operator</span>+(Zoo &amp;first, Zoo &amp;second)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">Zoo <span class="title">ret</span><span class="params">(first)</span></span>;<span class="comment">//拷贝构造函数，构造一个局部变量，用于返回值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ret += second;<span class="comment">//运算操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;<span class="comment">//返回一个值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二目算术运算符重载通常使用友元运算符重载方式。</p>
<p>从上面也可以看出，类运算符的重载最好与内置运算符保持一致，虽然没硬性规定，但这俨然成了一个默认规定。</p>
<p>另外 !（逻辑反）、~（按位与）、-（负号）等与二目算术运算符有类似之处，那就他们都不会修改原对象数据成员，而是将运算结果交给一个新值，所以在重载时，需要构造一个临时对象作为返回值，返回值也就同样不能是引用。</p>
<p>3.4、输入输出操作符重载</p>
<p>支持I/O操作的类所提供的I/O操作接口，一般应该与标准库iostream为内置类型定义的接口相同。</p>
<p>1、输出操作符 &lt;&lt; 的重载</p>
<p>为了与I/O标准库一致，操作符应接受 ostream&amp; 作为第一个形参，对类类型 const 对象的引用作为第二个形参，并返回对 ostream 形参的引用。</p>
<p>重载输出操作符可能相对于比较难理解，这里简单的说下，我们只能以自定义类的友元函数的形式重载这两个运算符，这是因为如果我们用成员函数的形式来重载的话，就要改动系统的流类 istream 和 ostream 定义，这是C++不允许的，如果不定义为友元函数的话，将无法调用类对象成员数据输出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; stream, <span class="keyword">const</span> Zoo &amp;object)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//对object所引用的对象的数据进行的输出操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	stream &lt;&lt; object.lion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	stream &lt;&lt; object.tiger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> stream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看上面这个输出操作符重载函数，第一个参数是 ostream 类的引用，而函数的返回值也是 ostream 类的引用。毫无疑问，我们调用这个运算符重载函数时。实参肯定是 cout，这样就造成了这样一种情况：实参 stream 引用 cout，而函数的返回值又引用 stream，等于函数返回值引用的实体还是 cout。这样做的目的是实现了连续的输出操作。当执行下面语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; zoo_a &lt;&lt; zoo_b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面 cout &lt;&lt; zoo_a 实质就是调用 operator&lt;&lt;(cout, zoo_a),然后返回 cout</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下一个 &lt;&lt; 就相当于执行 cout &lt;&lt; zoo_b, 同上</span></span><br></pre></td></tr></table></figure>

<p>我们不能将该操作符重载函数定义为类的成员函数，否则，左操作数将只能是该类类型的对象。IO操作符通常要对非公用数据成员进行读写，因此，类通常将IO操作符（输入输出）设为友元。</p>
<p>2、输入操作符 &gt;&gt; 的重载</p>
<p>为了与IO标准库一致，操作符应接受 istream&amp; 作为第一个形参，指向它要读的流，并且返回的也是对同一个流的引用（链式操作）。它的第二个形参是对要读入的对象的非 const 引用，该形参必须为非 const，因为输入操作符的目的是将数据读到这个对象中。</p>
<p>更重要但通常重视不够的是，输入和输出操作符有如下区别：输入操作符必须处理错误和文件结束的可能性。</p>
<p>输入期间的错误：任何读操作都可能因为提供的值不正确而失败；任何读入都可能碰到输入流中的文件结束或其他一些错误。也就需要对输入进行附加检查，发现有这些错误就需要我们进行处理。</p>
<p>3.5、不能重载的运算符 &amp;&amp;、|| 和 , 操作符</p>
<p>和 C 一样，C++ 对于真假值表达式采用所谓骤死式评估方式。意思是一旦该表达式的真假值去顶，纵使表达式中还有部分尚未检验，整个评估工作仍告结束。比如下面这种情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((p != <span class="literal">NULL</span>) &amp;&amp; (<span class="built_in">strlen</span>(p) &gt; <span class="number">10</span>) ……</span><br></pre></td></tr></table></figure>

<p>你无需担心调用 strlen 时 p 是否为 NULL 指针，因为如果 p 是否为NULL 的测试结果是否定的，strlen 就绝不会被调用。事实上，对一个 NULL 指针调用 strlen，结果未可预期。</p>
<p>回到重载，C++ 允许我们为用户定制型别量身定做各类操作符，包括 &amp;&amp; 和 ||，操作符重载语义上是允许的，但是我们要考虑重载会不会改变对应内置操作符的规则。拿 &amp;&amp; 和 || 来说，重载则是对 operator &amp;&amp; 和 operator || 两函数进行重载工作，值得注意的是，函数调用语义将会取代骤死式语义，也就是说，如果你将operator &amp;&amp; 重载，下面这个虱子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression1 &amp;&amp; expression2) ……</span><br></pre></td></tr></table></figure>

<p>会被编译器视为以下两者之一：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression1.<span class="keyword">operator</span>&amp;&amp;(expression2)) ……</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设 operator&amp;&amp; 是个 member function</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">operator</span>&amp;&amp;(expression1, expression2)) ……</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设 operator&amp;&amp; 是个全局函数</span></span><br></pre></td></tr></table></figure>

<p>上面函数调用语义和所谓骤死式语义有两个重大的不同。第一，当函数调用动作被执行起来，所有参数值都必须评估完成，所以当我们调用 operator&amp;&amp; 和 operator|| 时，两个参数都已评估完成，没有什么骤死式语义。第二，C++ 语言规格并未明定函数调用动作中各参数的评估次序，所以没办法知道 expression1 和 expression2 哪个会先被评估，而内置的真假值表达式，则总是由左向右评估其自变量。</p>
<p>C++ 中，运算符重载的一个重要参考就是：不能修改运算符的内置语义。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Amalloc%E3%80%81calloc%E3%80%81free%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Amalloc%E3%80%81calloc%E3%80%81free%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">C语言内存管理：malloc、calloc、free的实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-27 15:20:44 / 修改时间：15:22:09" itemprop="dateCreated datePublished" datetime="2020-12-27T15:20:44+08:00">2020-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>任何一个对C稍稍有了解的人都知道malloc、calloc、free。前面两个是用户态在堆上分配一段连续（虚拟地址）的内存空间，然后可以通过free释放，但是，同时也会有很多人对其背后的实现机制不了解。<br>这篇文章则是通过介绍这三个函数，并简单的予以实现，对比现有C的标准库实现（glibc等）相比，并不是特别高效，我们重在阐述背后的基本原理。</p>
<p><strong>一、C程序的存储空间布局</strong></p>
<p>图1<br><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Amalloc%E3%80%81calloc%E3%80%81free%E7%9A%84%E5%AE%9E%E7%8E%B0/20160103134018703" alt="这里写图片描述"></p>
<ul>
<li>text：整个用户空间的最低地址部分，存放的是指令（程序所编译成的可执行机器码）。可共享，即使是频繁操作执行的程序，在存储器中也只需有一个副本，通常是只读的。</li>
<li>initialized data(data)：存放初始化过的全局变量，包含了程序中需明确地赋初值的变量。</li>
<li>uninitialized data(bss)：存放的是未初始化过的全局变量，在程序开始执行之前，内核将此段中的数据初始化为0或者NULL。</li>
<li>heap：堆，自低地址向高地址增长，后面重点剖析</li>
<li>stack：栈，自高地址向低地址增长，自动变量以及每次函数调用时所需保存的信息都存放在此段中。</li>
</ul>
<p><strong>二、Heap 内存模型</strong></p>
<p>一般来说，malloc所申请的内存主要从heap区域分配的。<br><a href="http://blog.csdn.net/wenqian1991/article/details/25159545" target="_blank" rel="noopener">linux内存管理</a>，从这里可以了解到linux下虚拟地址与物理地址。</p>
<p>linux对堆的管理如下：<br>图2<br><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Amalloc%E3%80%81calloc%E3%80%81free%E7%9A%84%E5%AE%9E%E7%8E%B0/20160103142123394" alt="这里写图片描述"></p>
<p>linux 内核维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址（Heap’s Start）到break之间的地址空间为映射好的（虚拟地址与物理地址的映射，通过MMU实现），可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。</p>
<p>所以，如果Mapped Region 空间不够时，会调整break指针，扩大映射空间，重新分配内存。</p>
<p><strong>三、调整break：brk()和sbrk()</strong></p>
<p>最初break的位置正好位于bss端末尾之后，看图1，在break指针的位置升高时，程序可以访问新分配区域内的任何内存地址，而此时物理内存页尚未分配，内存会在京城首次试图访问这些虚拟内存地址时自动分配新的物理内存页。</p>
<p>linux通过brk和sbrk系统调用操作break指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> increment)</span></span>;<span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>brk() 将break指针设置为 addr 所指定的位置，由于虚拟内存以页为单位进行分配，addr实际会四舍五入到下一个内存也的边界处。<br>由于brk是直接指定一个地址，所以一旦这个值取得过低，有可能导致不可预知的行为，对照图1，brk只能在指定的区域内调整break。</p>
<p>sbrk() 将break指针在原有地址增加从参数 increment 传入的大小（linux中，sbrk是基于brk基础上实现的一个库函数），用于声明increment 的intptr_t 类型属于整数数据类型。<br>若调用成功，sbrk() 返回前一个break 的地址，换言之，如果break 增加，那么返回值是指向这块新分配内存起始位置的指针。<br>sbrk(0) 将得到当前break指针的位置。</p>
<p>系统对每一个进程所分配的资源不是无限的，包括可映射的内存空间，图2，未映射内存的尾端有个rlimit表示当前进程可用的资源上限。</p>
<p><strong>三、malloc</strong></p>
<p>根据标准C库函数的定义，malloc 具有如下模型：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这个函数要实现的功能是在系统中分配一段连续的可用的内存，具体有如下要求：<br>- malloc分配的内存大小至少为size参数所指定的字节数<br>- malloc的返回值是一个指针，指向一段可用内存的起始地址<br>- 多次调用malloc所分配的地址不能有重叠部分，除非该地址已经被释放掉<br>- malloc应该尽快完成内存分配并返回（不能使用<a href="https://en.wikipedia.org/wiki/NP-hardness" target="_blank" rel="noopener">NP-hard</a>的内存分配算法）<br>- 实现malloc时，应该同时实现内存大小调整和内存释放函数（calloc和free）<br>- malloc分配失败时必须返回NULL</p>
<p>malloc 返回内存块所采用的字节对齐方式，总是适宜于高效访问任何类型的C语言数据结构。</p>
<p><strong>四、初探实现malloc：</strong></p>
<p>我们假定整个内存处于初始状态，即break指针位于bss段的单位，整个heap都是 Unmapped Region。（图2）<br>基于此，我们可以实现一个简单但毫无实际价值的malloc：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*一个糟糕的仿制malloc*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#incldue <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line">    p = sbrk(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*如果sbrk失败，返回NULL*/</span></span><br><span class="line">    <span class="keyword">if</span>(sbrk(<span class="built_in">size</span>) == (<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;<span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<p>这个malloc就是从未映射区域直接划出一块，但是malloc对这块已分配的内存缺乏记录，不便于内存释放。</p>
<p><strong>五、正式实现malloc</strong></p>
<p>上面说到分配的内存没有记录，一旦调用free释放，free不知道它到底要释放多大的内存，所以我们需要额外一个数据结构来记录这些信息。</p>
<p><strong>5.1、数据结构</strong><br>一个简单可行方案是将堆内存以块的形式组织起来，每个块（block）由meta区和数据区组成，meta去记录数据块的元信息（数据块大小、空闲标志位、指针等），数据区则是真实分配的内存区域，并且数据区的第一个字节地址即为malloc返回的地址。</p>
<p>可用如下结构体定义一个block：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> *<span class="title">t_block</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_block</span>&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span>   <span class="built_in">size</span>;<span class="comment">//数据区大小</span></span><br><span class="line">    t_block  next;<span class="comment">//指向下个块的指针</span></span><br><span class="line">    <span class="keyword">int</span>      <span class="built_in">free</span>;<span class="comment">//是否是空闲块</span></span><br><span class="line">    <span class="keyword">char</span>     data[<span class="number">1</span>];<span class="comment">//虚拟字段，表示数据块的第一个字节，长度不计入meta</span></span><br><span class="line">&#125;;<span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p>图3<br><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Amalloc%E3%80%81calloc%E3%80%81free%E7%9A%84%E5%AE%9E%E7%8E%B0/20160103160120434" alt="这里写图片描述"></p>
<p>那么用这个结构体来分配内存，而不用malloc则是下面一番场景：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t_block  <span class="keyword">b;</span></span><br><span class="line"><span class="keyword">b </span>= <span class="keyword">sbrk(0);</span></span><br><span class="line"><span class="keyword">sbrk(sizeof(struct </span>s_block) + size);</span><br><span class="line"><span class="keyword">b-&gt;size </span>= size<span class="comment">;//size 为要分配的内存大小1234</span></span><br></pre></td></tr></table></figure>

<p><strong>5.2、寻找合适的block</strong><br>我们从堆的起始地址开始查找第一个符合要求的block，并返回block起始地址，如果找不到就返回NULL；</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">t_block</span> find_block(t_block *last, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    t_block <span class="keyword">b </span>= <span class="keyword">base;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="meta">while</span>(<span class="keyword">b </span>&amp;&amp; !(<span class="keyword">b-&gt;free </span>&amp;&amp; <span class="keyword">b-&gt;size </span>&gt;= size))</span><br><span class="line">    &#123;</span><br><span class="line">        *last = <span class="keyword">b;</span></span><br><span class="line"><span class="keyword"> </span>       <span class="keyword">b </span>= <span class="keyword">b-&gt;next;</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line"><span class="symbol">return</span> <span class="keyword">b;</span></span><br><span class="line"><span class="keyword">&#125;12345678910</span></span><br></pre></td></tr></table></figure>

<p>这里base是一个全局变量，维护整个堆的起始地址。另外，这里在遍历时会更新一个last指针，这个指针始终指向当前遍历的block，如果找不到合适的block，那么malloc将很容易的开辟新的block使用。</p>
<p><strong>5.3、开辟新的block</strong><br>如果现有block都不能满足需求，则需要在链表最后开辟一个新的block。最简单的方式就是利用sbrk升高break位置然后对其初始化，然后更新对应block指针，将其add到链表最后。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">t_block <span class="title">extend_heap</span><span class="params">(t_block last, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t_block b;</span><br><span class="line">    b = sbrk(<span class="number">0</span>);<span class="comment">//定位到当前break位置</span></span><br><span class="line">    <span class="keyword">if</span>(sbrk(<span class="keyword">sizeof</span>(struct s_block) + <span class="built_in">size</span>) == (<span class="keyword">void</span>*)<span class="number">-1</span>)<span class="comment">//调整break位置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    b-&gt;<span class="built_in">size</span> = <span class="built_in">size</span>;</span><br><span class="line">    b-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(last)<span class="comment">//这个last是指向extend之前最后一个block</span></span><br><span class="line">        last-&gt;next = b;<span class="comment">//新开辟的block挂载在链表中</span></span><br><span class="line">    b-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;<span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<p><strong>5.4、分裂block</strong><br>看前面 find_block() 的实现，如果我们申请的 size 远小于查找到的 block。（这种情况是可能，它是查到第一个满足条件（大小，可用）的block），这样会导致较大内部碎片的产生。<br>所以，应该在剩余数据区足够大的情况下，将其分裂成一个新的block：</p>
<p>图4<br><img src="/2020/12/27/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9Amalloc%E3%80%81calloc%E3%80%81free%E7%9A%84%E5%AE%9E%E7%8E%B0/20160103165244021" alt="这里写图片描述"></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//b是要分裂的block，size是申请的内存大小</span></span><br><span class="line"><span class="comment">//分裂后b成了分配后的block</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split_block</span><span class="params">(t_block b, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t_block <span class="keyword">new</span>;<span class="comment">//新的空闲block = 要分裂的block - 申请分配出去的内存</span></span><br><span class="line">    <span class="keyword">new</span> = b-&gt;data + <span class="built_in">size</span>;<span class="comment">//将new定位到剩下的数据块区域</span></span><br><span class="line">    <span class="comment">//分裂的原block-分配出去的内存大小-block结构体本身大小</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;<span class="built_in">size</span> = b-&gt;<span class="built_in">size</span> - <span class="built_in">size</span> - BLOCK_SIZE;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = b-&gt;next;<span class="comment">//链表插入</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;<span class="built_in">free</span> = <span class="number">1</span>;<span class="comment">//空闲标记可用</span></span><br><span class="line">    b-&gt;<span class="built_in">size</span> = <span class="built_in">size</span>;</span><br><span class="line">    b-&gt;next = <span class="keyword">new</span>;<span class="comment">//链表插入</span></span><br><span class="line">&#125;<span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<p>看了上面一大串，是不是跟伙伴算法很像。但是这里的分裂block函数，得视情况调用，如果申请的size &lt; block-&gt;size，但是又不是小太多，如果分裂block的话，会导致分裂后剩余未分配出去的数据块过小，无法满足其余需求，很容易形成内存碎片。</p>
<p>所以，伙伴算法有更高效的处理（实际上伙伴算法也会产生内部碎片）。</p>
<p><strong>5.5、malloc 的实现</strong><br>铺垫做了那么多，我们可以利用它们整合成一个简单可用的malloc。<br>首先定义一个block链表的头指针，初始化为NULL，另外，我们需要剩余空间至少有 BLOCK_SIZE + 4 才执行分离操作。</p>
<p>此外，一开始我们讲到，malloc对分配的内存大小也有要求，是按4字节对齐，所以申请的size不为4的倍数时，我们需要将其调整为大于size的最小的4的倍数。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> align4(x) (((((x)-1)&gt;&gt;2)&lt;&lt;2)+4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_SIZE 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    t_block b, last;</span><br><span class="line">    <span class="keyword">size_t</span> s;</span><br><span class="line"></span><br><span class="line">    s = align4(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">if</span>(base)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//first find a block</span></span><br><span class="line">        last = base;</span><br><span class="line">        b = find_block(&amp;last, s);</span><br><span class="line">        <span class="keyword">if</span>(b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//can we split</span></span><br><span class="line">            <span class="keyword">if</span>((b-&gt;<span class="built_in">size</span> - s) &gt;= (BLOCK_SIZE + <span class="number">8</span>))</span><br><span class="line">                split_block(b, s);</span><br><span class="line">            b-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//no fitting block, extend the heap</span></span><br><span class="line">            b = extend_heap(last, s);</span><br><span class="line">            <span class="keyword">if</span>(!b)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//first time</span></span><br><span class="line">        b = extend_heap(<span class="literal">NULL</span>, s);</span><br><span class="line">        <span class="keyword">if</span>(!b)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        base = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b-&gt;data;</span><br><span class="line">&#125;<span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041</span></span><br></pre></td></tr></table></figure>

<p>实现思路很简单：首先往链表中查找合适的block，如果找到了，看是否可以分裂，如果可以就分裂；如果没有找到合适的，就开辟一个新的block；如果是第一次分配，即整个内存链表不存在，则一开始就得新开辟一个block。</p>
<p><strong>六、calloc 的实现</strong></p>
<p>先看calloc的标准库语义：函数 calloc() 用于给一组相同对象分配内存。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> numitems, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span>1</span></span><br></pre></td></tr></table></figure>

<p>参数numitems指定分配对象的数量，size指定每个对象的大小。</p>
<p>calloc 与之malloc 不同之处在于，calloc 会将分配后的内存空间初始化，而malloc 申请的是一块未初始化的内存。<br>所以，实现calloc，只需两步：</p>
<ol>
<li>malloc 一块内存</li>
<li>将数据区内容初始化为0</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> numitems, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> *<span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">size_t</span> s, i;</span><br><span class="line">    <span class="keyword">new</span> = <span class="built_in">malloc</span>(numitems * <span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//因为申请的内存总是4的倍数，所以这里我们以4字节为单位初始化</span></span><br><span class="line">        s = align4(numitems * <span class="built_in">size</span>) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; s; ++i)</span><br><span class="line">            <span class="keyword">new</span>[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line">&#125;<span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>

<p><strong>七、free 的实现</strong></p>
<p>free 的实现并不像看上去那么简单，需要解决两个关键问题：</p>
<ol>
<li>如何验证所传入的地址是有效地址（malloc方式分配的）</li>
<li>如何解决碎片问题</li>
</ol>
<p><strong>7.1、先看如何解决碎片问题</strong>，就是把相邻的空闲内存合并为大的（伙伴算法类似）：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并相邻空闲的内存块，参数决定合并的是上一个还是下一个</span></span><br><span class="line">t_block fusion(t_block b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(b-&gt;</span><span class="function"><span class="title">next</span> &amp;&amp; b-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>free)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">b</span>-&gt;</span><span class="function"><span class="title">size</span> += BLOCK_SIZE + b-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>size;</span><br><span class="line">        <span class="function"><span class="title">b</span>-&gt;</span><span class="function"><span class="title">next</span> = b-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>next;</span><br><span class="line">        <span class="function"><span class="title">if</span>(b-&gt;</span>next)</span><br><span class="line">            <span class="function"><span class="title">b</span>-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>prev = b;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;<span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<p>再看如何验证所传入的地址是有效的，位于heap内。<br>一个解决方法是，在block结构体中添加一个 ptr 指针，用于指向数据块区域，如果 b-&gt;ptr == b-&gt;data，则表示 b 极有可能是一个有效block。<br>所以我们对block数据结构进行了扩展：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_block</span>&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span>   <span class="built_in">size</span>;<span class="comment">//数据区大小</span></span><br><span class="line">    t_block  next;<span class="comment">//指向下个块的指针</span></span><br><span class="line">    <span class="keyword">int</span>      <span class="built_in">free</span>;<span class="comment">//是否是空闲块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="keyword">void</span>     *ptr;</span><br><span class="line">    <span class="keyword">char</span>     data[<span class="number">1</span>];</span><br><span class="line">&#125;;<span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p><strong>7.2、根据给定地址得到对应的block</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意，这个函数最后通过偏移量得到的block可能是有效的，可能不是有效的</span></span><br><span class="line"><span class="function">t_block <span class="title">get_block</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *tmp;</span><br><span class="line">    tmp = p;</span><br><span class="line">    <span class="keyword">return</span> (p = tmp -= BLOCK_SIZE);</span><br><span class="line">&#125;<span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p><strong>7.3、下面则验证是不是有效的block：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> valid_addr(<span class="built_in">void</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(base)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p &gt; base &amp;&amp; p &lt; sbrk(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> (p == (get_block(p))-&gt;ptr);</span><br><span class="line">        <span class="comment">//如果两个字段地址一样，表示是一个有效block</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p><strong>7.4、下面就实现free</strong></p>
<p>这里我们采用的合并策略是这样的：先合并相邻的空闲内存块，合并之后，再检查是否还有空闲的相邻内存块，如果有则继续合并，直到最后，该内存块是最大的连续内存块。<br>另外，对于break指针的调整（降低），必须保证在该释放的block与 Unmapped Region之间是空闲的，没有被占。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void free(void *p)</span><br><span class="line">&#123;</span><br><span class="line">    t_block b;</span><br><span class="line">    <span class="keyword">if</span>(valid_addr(p))<span class="comment">//地址的有效性验证</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = get_block(p);<span class="comment">//得到对应的block</span></span><br><span class="line">        <span class="function"><span class="title">b</span>-&gt;</span>free = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果相邻的上一块内存是空闲的就合并,</span></span><br><span class="line"><span class="comment">//合并之后的上一块还是空闲的就继续合并，直到不能合并为止</span></span><br><span class="line">        <span class="function"><span class="title">while</span>(b-&gt;</span><span class="function"><span class="title">prev</span> &amp;&amp; b-&gt;</span><span class="function"><span class="title">prev</span>-&gt;</span>free)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">b</span> = fusion(b-&gt;</span>prev);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同理去合并后面的空闲block</span></span><br><span class="line">        <span class="function"><span class="title">while</span>(b-&gt;</span>next)</span><br><span class="line">            fusion(b);<span class="comment">//内部会判断是否空闲</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果当前block是最后面的那个block，此时可以调整break指针了</span></span><br><span class="line">        <span class="function"><span class="title">if</span>(NULL == b-&gt;</span>next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span>(b-&gt;</span>prev)<span class="comment">//当前block前面还有占用的block</span></span><br><span class="line">                <span class="function"><span class="title">b</span>-&gt;</span><span class="function"><span class="title">prev</span>-&gt;</span>next = NULL;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//当前block就是整个heap仅存的</span></span><br><span class="line">                base = NULL;<span class="comment">//则重置base</span></span><br><span class="line">            brk(b);<span class="comment">//调整break指针到b地址位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则不能调整break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="number">12345678910111213141516171819202122232425262728293031</span></span><br></pre></td></tr></table></figure>

<p><strong>八、realloc的实现</strong></p>
<p>同样先看标准库中realloc的语义：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span>1</span></span><br></pre></td></tr></table></figure>

<p>ptr 是指向需要调整大小的内存块的指针，参数 size 指定所需调整大小的期望值。</p>
<p>realloc() 用来调整（通常是增加）一块内存的大小，而此块内存应是之前由malloc函数分配的。若 realloc 增加了已分配内存块的大小，则不会对额外分配的内存进行初始化。</p>
<p><strong>8.1、内存块复制</strong><br>看了realloc的语义，我们首先得实现一个内存复制方法。如同calloc一样，我们以4字节为单位进行复制：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void copy_block(t_block src, t_block dst)</span><br><span class="line">&#123;</span><br><span class="line">    int *sdata, *dtata;</span><br><span class="line">    size_t <span class="built_in">i</span>;</span><br><span class="line">    sdata = src-&gt;ptr;</span><br><span class="line">    ddata = dst-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span>*<span class="number">4</span> &lt; src-&gt;<span class="built_in">size</span> &amp;&amp; <span class="built_in">i</span>*<span class="number">4</span> &lt; dst-&gt;<span class="built_in">size</span>; ++<span class="built_in">i</span>)</span><br><span class="line">        ddata[<span class="built_in">i</span>] = sdata[<span class="built_in">i</span>];</span><br><span class="line">&#125;<span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p><strong>8.2、实现realloc</strong><br>为了更高效，我们考虑以下几个方面：</p>
<ol>
<li>如果当前block的数据区大于等于realloc要求的size，则考虑能不能split，然后直接返回</li>
<li>如果新的size变小了，考虑split</li>
<li>如果当前block的数据区不能满足size，但是其后继block是free，并且合并后可以满足size，则考虑合并，然后再考虑能不能split</li>
<li>如果以上都不行，则调用malloc重新分配size大小内存，然后内存复制</li>
</ol>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void *realloc(<span class="name">void</span> *p, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    size_t s;</span><br><span class="line">    t_block b, new;</span><br><span class="line">    void *newp<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    if(!p)</span><br><span class="line">        return malloc(<span class="name">size</span>)<span class="comment">;</span></span><br><span class="line">    if(<span class="name">valid_addr</span>(<span class="name">p</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        s = align4(<span class="name">size</span>)<span class="comment">;</span></span><br><span class="line">        b = get_block(<span class="name">p</span>)<span class="comment">;//得到对应的block</span></span><br><span class="line">        if(<span class="name">b-&gt;size</span> &gt;= s)//如果size变小了，考虑split</span><br><span class="line">        &#123;</span><br><span class="line">            if(<span class="name">b-&gt;size</span> - s &gt;= (<span class="name">BLOCK_SIZE</span> + <span class="number">4</span>))</span><br><span class="line">                split_block(<span class="name">b</span>, s)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        else//如果当前block的数据区不能满足size</span><br><span class="line">        &#123;</span><br><span class="line">//如果后继block是free的，并且合并后大小满足size，考虑合并</span><br><span class="line">            if(<span class="name">b-&gt;next</span> <span class="symbol">&amp;&amp;</span> b-&gt;next-&gt;free</span><br><span class="line">                <span class="symbol">&amp;&amp;</span> (<span class="name">b-&gt;size</span> + BLOCK_SIZE + b-&gt;next-&gt;size) &gt;= s)</span><br><span class="line">            &#123;</span><br><span class="line">                fusion(<span class="name">b</span>)<span class="comment">;</span></span><br><span class="line">            //合并后满足size，再看能不能split</span><br><span class="line">                if(<span class="name">b-&gt;size</span> - s &gt;= (<span class="name">BLOCK_SIZE</span> + <span class="number">4</span>))</span><br><span class="line">                    split_block(<span class="name">b</span>, s)<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">            else//以上都不满足，则malloc新区域</span><br><span class="line">            &#123;</span><br><span class="line">                newp = malloc(<span class="name">s</span>)<span class="comment">;</span></span><br><span class="line">                if(!newp)</span><br><span class="line">                    return NULL<span class="comment">;</span></span><br><span class="line">            //内存复制</span><br><span class="line">                new = get_block(<span class="name">newp</span>)<span class="comment">;</span></span><br><span class="line">                copy_block(<span class="name">b</span>, new)<span class="comment">;</span></span><br><span class="line">                free(<span class="name">p</span>)<span class="comment">;//释放old </span></span><br><span class="line">                return newp<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return p<span class="comment">;//当前block数据区大于size时</span></span><br><span class="line">    &#125;</span><br><span class="line">    return NULL<span class="comment">;</span></span><br><span class="line">&#125;<span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041424344</span></span><br></pre></td></tr></table></figure>

<p><strong>九、总结</strong></p>
<p>以上是一个比较简陋，存在很大的优化空间，但大致阐述了malloc的机制，这也是本篇博文的目的。<br>对于更好的优化读者可以参考<a href="http://blog.csdn.net/wenqian1991/article/details/27968779" target="_blank" rel="noopener">linux内核伙伴算法</a>、以及<a href="http://blog.csdn.net/wenqian1991/article/details/19605727" target="_blank" rel="noopener">STL空间配置器</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E8%B5%8B%E5%80%BC%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E8%B5%8B%E5%80%BC%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">C++拷贝构造函数与赋值函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-27 15:18:11" itemprop="dateCreated datePublished" datetime="2020-12-27T15:18:11+08:00">2020-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-02 20:31:26" itemprop="dateModified" datetime="2021-03-02T20:31:26+08:00">2021-03-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这里我们用类String 来介绍这两个函数：</p>
<p>拷贝构造函数是一种特殊构造函数，具有单个形参，该形参（常用const修饰）是对该类类型的引用。当定义一个新对象并用一个同类型的对象对它进行初始化时，将显式使用拷贝构造函数。为啥形参必须是对该类型的引用呢？试想一下，假如形参是该类的一个实例，由于是传值参数，我们把形参复制到实参会调用拷贝构造函数，如果允许拷贝构造函数传值，就会在拷贝构造函数内调用拷贝构造函数，从而形成无休止的递归调用导致栈溢出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s);</span><br><span class="line"><span class="comment">//类成员，无返回值</span></span><br></pre></td></tr></table></figure>

<p>赋值函数，也是赋值操作符重载，因为赋值必须作为类成员，那么它的第一个操作数隐式绑定到 this 指针，也就是 this 绑定到指向左操作数的指针。因此，赋值操作符接受单个形参，且该形参是同一类类型的对象。右操作数一般作为const 引用传递。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>&amp;	<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s);</span><br><span class="line"><span class="comment">//类成员，返回对同一类类型(左操作数)的引用</span></span><br></pre></td></tr></table></figure>


<p>拷贝构造函数和赋值函数并非每个对象都会使用，另外如果不主动编写的话，编译器将以“位拷贝”的方式自动生成缺省的函数。在类的设计当中，“位拷贝”是应当防止的。倘若类中含有指针变量，那么这两个缺省的函数就会发生错误。这就涉及到深复制和浅复制的问题了。</p>
<p>拷贝有两种：深拷贝，浅拷贝<br>当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。<br>但当数据成员中有指针时，如果采用简单的浅拷贝，则<strong>两类中的两个指针将指向同一个地址</strong>，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。所以，这时，必须采用深拷贝。<br>深拷贝与浅拷贝的区别就在于<strong><em>\</em>深拷贝会在堆内存中另外申请空间来储存数据**</strong>，从而也就解决了指针悬挂的问题。指向不同的内存空间，但内容是一样的<br>简而言之，<strong><em>\</em>当数据成员中有指针时，必须要用深拷贝**</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> * c;</span><br><span class="line">&#125;a, b;</span><br><span class="line"><span class="comment">//浅复制不会重新分配内存</span></span><br><span class="line"><span class="comment">//将a 赋给 b，缺省赋值函数的“位拷贝”意味着执行</span></span><br><span class="line">a.c = b.c;</span><br><span class="line"><span class="comment">//从这行代码可以看出</span></span><br><span class="line"><span class="comment">//b.c 原有的内存没有释放</span></span><br><span class="line"><span class="comment">//a.c 和 b.c 指向同一块内存，任何一方的变动都会影响到另一方</span></span><br><span class="line"><span class="comment">//对象析构的时候，c 被释放了两次（a.c == b.c 指针一样）</span></span><br><span class="line"><span class="comment">//深复制需要自己处理里面的指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> *c;</span><br><span class="line">	A&amp; <span class="keyword">operator</span> =(<span class="keyword">const</span> A &amp;b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//隐含 this 指针</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;b)</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">delete</span> c;<span class="comment">//释放原有内存资源</span></span><br><span class="line">		<span class="comment">//分配新的内存资源</span></span><br><span class="line">		<span class="keyword">int</span> length = <span class="built_in">strlen</span>(b.c);</span><br><span class="line">		c = <span class="keyword">new</span> <span class="keyword">char</span>[length + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(c, b.c);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;a, b;</span><br><span class="line"><span class="comment">//这个是深复制，它有自定义的复制函数，赋值时，对指针动态分配了内存</span></span><br></pre></td></tr></table></figure>

<p>这里再总结一下深复制和浅复制的具体区别：</p>
<ol>
<li>当拷贝对象状态中包含其他对象的引用时，如果需要复制的是引用对象指向的内容，而不是引用内存地址，则是深复制，否则是浅复制。</li>
<li>浅复制就是成员数据之间的赋值，当值拷贝时，两个对象就有共同的资源。而深拷贝是先将资源复制一份，是对象拥有不同的资源（内存区域），但资源内容（内存里面的数据）是相同的。</li>
<li>与浅复制不同，深复制在处理引用时，如果改变新对象内容将不会影响到原对象内容</li>
<li>与深复制不同，浅复制资源后释放资源时可能会产生资源归属不清楚的情况（含指针时，释放一方的资源，其实另一方的资源也随之释放了），从而导致程序运行出错</li>
</ol>
<p>深复制和浅复制还有个区别就是执行的时候，浅复制是直接复制内存地址的，而深复制需要重新开辟同样大小的内存区域，然后复制整个资源。</p>
<p>好，有了前面的铺垫，下面开始讲讲拷贝构造函数和赋值函数，其实前面第一部分也已经介绍了许多</p>
<p>这里以string 类为例来进行说明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	String(<span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="literal">NULL</span>);</span><br><span class="line">	String(<span class="keyword">const</span> String &amp;rhs);</span><br><span class="line">	String&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String &amp;rhs);</span><br><span class="line">	~String(<span class="keyword">void</span>)&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] m_data;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> *m_data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">String::String(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == str)</span><br><span class="line">	&#123;</span><br><span class="line">		m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">		*m_data = <span class="string">'\0'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(m_data, str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数，无需检验参数的有效性</span></span><br><span class="line">String::String(<span class="keyword">const</span> String &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.m_data) + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(m_data, rhs.m_data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值函数</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">delete</span>[] m_data; m_data = <span class="literal">NULL</span>;</span><br><span class="line">	m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.m_data) + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(m_data, rhs.m_data);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类String 拷贝构造函数与普通构造函数的区别是：在函数入口处无需与 NULL 进行比较，这是因为“引用”不可能是NULL，而“指针”可以为NULL。（这是引用与指针的一个重要区别）。然后需要注意的就是深复制了。</p>
<p>相比而言，对于类String 的赋值函数则要复杂的多：</p>
<p>1、首先需要执行检查自赋值</p>
<p>这是防止自复制以及间接复制，如 b = a; c = b; a = c;之类，如果不进行自检的话，那么后面的 delete 将会进行自杀操作，后面随之的拷贝操作也会出错，所以这是关键的一步。还需要注意的是，自检是检查地址，而不是内容，内存地址是唯一的。必须是 if(this == &amp;rhs)</p>
<p>2、释放原有的内存资源</p>
<p>必须要用 delete 释放掉原有的内存资源，如果此时不释放，该变量指向的内存地址将不再是原有内存地址，也就无法进行内存释放，造成内存泄露。</p>
<p>3、分配新的内存资源，并复制资源</p>
<p>这样变量指向的内存地址变了，但是里面的资源是一样的</p>
<p>4、返回本对象的引用</p>
<p>这样的目的是为了实现像 a = b = c; 这样的链式表达，注意返回的是 *this 。</p>
<p>但仔细一想，上面的程序没有考虑到异常安全性，我们在分配内存之前用delete 释放了原有实例的内存，如果后面new 出现内存不足抛出异常，那么之前delete 的 m_data 将是一个空指针，这样很容易引起程序崩溃，所以我们可以调换下顺序，即先 new 一个实例内存，成功后再用 delete 释放原有内存空间，最后用 m_data 赋值为new后的指针。</p>
<p>接下来说说拷贝构造函数和赋值函数之间的区别。</p>
<p>拷贝构造函数和赋值函数非常容易混淆，常导致错写、错用。拷贝构造函数是在对象被创建是调用的，而赋值函数只能在已经存在了的对象调用。看下面代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">a</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">b</span><span class="params">(<span class="string">"world"</span>)</span></span>;</span><br><span class="line">	String c = a;<span class="comment">//这里c对象被创建调用的是拷贝构造函数</span></span><br><span class="line">             <span class="comment">//一般是写成 c(a);这里是与后面比较</span></span><br><span class="line">	c = b;<span class="comment">//前面c对象已经创建，所以这里是赋值函数</span></span><br></pre></td></tr></table></figure>

<p>上面说明出现“=”的地方未必调用的都是赋值函数（算术符重载函数），也有可能拷贝构造函数，那么什么时候是调用拷贝构造函数，什么时候是调用赋值函数你？ 判断的标准其实很简单：如果临时变量是第一次出现，那么调用的只能是拷贝构造函数，反之如果变量已经存在，那么调用的就是赋值函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C++%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%92%8CC%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84static/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C++%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%92%8CC%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84static/" class="post-title-link" itemprop="url">C++类的静态成员和C语言中的static</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-27 15:16:30" itemprop="dateCreated datePublished" datetime="2020-12-27T15:16:30+08:00">2020-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-02 21:46:25" itemprop="dateModified" datetime="2021-03-02T21:46:25+08:00">2021-03-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一、C++类的静态成员</p>
<p>学过C++的都知道，静态成员是属于整个类而不是某个对象的，静态成员变量在内存中只存储一份共所有对象共用，在所有对象中都可以共享它。</p>
<p>静态成员的定义或声明需要加个关键字 static。因为属于整个类，所以可以通过 &lt;类名&gt;::&lt;静态成员名&gt;来使用。</p>
<p>比较容易混淆和出错的地方在于类的静态成员变量和静态成员函数的使用，这两者都属于静态成员。</p>
<p>需要注意的是：静态成员属于整个类，在类对象实例化前，静态成员就已经分配空间了，而非静态成员无需初始化，必须在类实例化对象后才有内存空间，所以就有了个先后顺序：静态成员先于非静态成员存在。</p>
<p>下面我们来看看如下几个情况： </p>
<p>1、通过类名调用静态成员函数和非静态成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base::fun1();</span><br><span class="line">	Base::fun2();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>编译错误：“Base::fun1”: 非静态成员函数的非法调用<br>结论1：不能通过类名来调用类的非静态成员函数。<br>原因：类没有实例化对象，非静态成员函数不存在</p>
<p>2、通过类的对象静态成员函数和非静态成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base obj;</span><br><span class="line">	obj.fun1();</span><br><span class="line">	obj.fun2();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译通过<br>结论2：可以通过类的对象调用静态成员函数和非静态成员函数<br>原因：类实例化对象，非静态成员函数已分配内存，静态成员函数为类各对象共享</p>
<p>3、在类的静态成员函数中使用类的非静态成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base obj;</span><br><span class="line">	obj.fun2();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译出错：对非静态成员“Base::x”的非法引用<br>结论3：类的静态成员函数不能使用类的非静态成员<br>原因：在编译阶段，静态成员函数已分配内存，但非静态成员并没有分配内存，就好比提前使用一个不存在的东西</p>
<p>4、在类的非静态成员函数中使用类的静态成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		fun2();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base obj;</span><br><span class="line">	obj.fun1();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译通过<br>结论4：类的非静态成员函数可以调用静态成员，反之则不能<br>理由同前</p>
<p>5、使用类的静态成员变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//int Base::x = 0;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Base::x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链接出错：无法解析的外部符号 “private: static int Base::x” (?x@Base@@0HA)<br>结论5：类的静态成员变量必须初始化，并且静态成员变量的初始化必须在类外初始化，且不能带static关键字<br>原因：静态成员变量属于类作用域，不属于类对象，程序一运行就分配内存并初始化，生命周期和程序一致，在类的构造函数内初始化显然是不合理的。另外在类外初始化时，还必须指定类型，否则编译器不知道该为变量分配多大内存。</p>
<p><strong>但是，静态成员也并非不能再类中初始化。对于静态常量成员是可以在类中初始化的。</strong></p>
<p>总结：<br>1.静态成员存在于内存，非静态成员需要实例化才会分配内存<br>2.非静态成员的生存期取决于该类的生存期，而静态成员则不存在生存期的概念<br>3.类的静态成员函数不能调用非静态成员，存在的先后顺序，反之可以<br>4.类的静态成员变量必须初始化，且必须在类外初始化（静态常量成员除外），不能带static关键字，必须带类型。</p>
<p>二、C语言中的static</p>
<p>下面介绍在C语言中，static的作用：</p>
<p>1、隐藏</p>
<p>当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。比如，同时编译两个源文件，一个是a.c，另一个是main.c</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.c</span></span><br><span class="line"><span class="keyword">char</span> a = <span class="string">'A'</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">char</span> a;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%c"</span>, a);</span><br><span class="line">	(<span class="keyword">void</span>)msg();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output:A Hello</span></span><br></pre></td></tr></table></figure>

<p>由于a.c 中的所有成员（变量和函数）都未加static，所有都具有全局可见性，其他的源文件也能访问。如果加了static，那么其余源文件就不能访问了，利用这一特性，可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。</p>
<p>2、static还能保持变量内容的持久</p>
<p>对于函数而言，static的作用仅限于隐藏，对于变量，static还有两个作用，其一就是保持变量内容的持久。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化，事实上，全局变量和静态变量都存储在静态存储区。与全局变量不同的是，static可以控制变量的可见范围。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>;<span class="comment">//事实上此赋值语句从来没执行过,调试一进入函数，count=10</span></span><br><span class="line">	<span class="keyword">return</span> count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>3、static第三个作用则是默认初始化为0，事实上存储在静态存储区的变量都具有这样的特性，所有全局变量也能初始化为0. </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C++%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E8%99%9A%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C++%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E8%99%9A%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">C++深入分析虚函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-27 15:14:15" itemprop="dateCreated datePublished" datetime="2020-12-27T15:14:15+08:00">2020-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-22 22:19:10" itemprop="dateModified" datetime="2021-01-22T22:19:10+08:00">2021-01-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面探索了<a href="http://blog.csdn.net/wenqian1991/article/details/41047957" target="_blank" rel="noopener">C++对象的内存模型</a>，其中简单的涉及到了虚函数，作为C++实现其多态的一个重要机制，这里进一步探索下虚函数机制，以前也看过网络上关于虚函数机制的一些精彩的文章，但现在决定自己再分析这个虚函数机制以加深理解，看与自己动手探索还是有区别的。</p>
<p><strong><em>\</em>一、异质链表**</strong></p>
<p>1、“is-a” 原理</p>
<p>在公有派生方式下，对派生类的对象里的基类子对象的水平访问与基类单独生成的对象的访问是一样的。也就是说，我们完全可以把public 继承方式的派生类的对象当做基类的一个对象来使用。反过来则不行。这就是“is-a”原理</p>
<p>在公有派生方式下，基于“is-a”原理，我们可以得出以下几点：</p>
<ol>
<li>一个派生类的对象可以赋给基类对象；</li>
<li>派生类对象可以初始化基类对象；</li>
<li>派生类的对象可以初始化基类的引用；</li>
<li>派生类的对象的地址可以赋给指向基类对象的指针。</li>
</ol>
<p>前面三条都是一个性质，派生类对象赋给基类对象的时候，都是调用基类的赋值构造函数，这样赋值的时候，只会将派生类对象中继承的基类成员赋值给基类对象成员，不会发生内存越界的情况。下面是一段截取的反汇编代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">60</span>: 	base_obj = derived_obj;</span><br><span class="line"><span class="number">00</span>DD442C  lea         eax,[derived_obj]  </span><br><span class="line"><span class="number">00</span>DD442F  push        eax  </span><br><span class="line"><span class="number">00</span>DD4430  lea         ecx,[base_obj]  </span><br><span class="line"><span class="number">00</span>DD4433  call        Base::<span class="keyword">operator</span>= (<span class="number">0</span>DD16AEh)</span><br></pre></td></tr></table></figure>

<p>最重要的是第四条，对于这个基类的不同派生类的对象，我们可以使用指向基类的指针把它们（派生类对象）穿成一个链表，这个链表对于我们实现C++的多态性有很大的价值，被称之为异质链表。</p>
<p>   <img src="/2020/12/27/C++%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E8%99%9A%E5%87%BD%E6%95%B0/20141122122521379" alt="img"></p>
<p>通过基类指针将这个基类的不同子对象串联起来。一个充分必要条件就是，这几个子类都有一个公共的基类，且都与这个基类有“is-a”关系。</p>
<p>对于这我们可以这么理解：派生类的对象所占的存储空间要比基类的对象大，因为派生类继承了基类非私有成员函数和数据，再加上本身的成员数据，实例化的对象自然会比基类对象大，自然，派生类指针的寻址空间要比基类指针的寻址空间大。但由于对象的头部分是一样的，所以即使有超出基类指针所寻址的部分也能根据偏移量正确寻址，相反，如果派生类指针指向基类对象，则会把一部分不属于该基类对象的内存也包括进来，那么当派生类指针指向基类对象来使用派生类的函数的时候可能会发生严重的错误。</p>
<p><strong><em>\</em>二、虚函数机制前奏**</strong></p>
<p>1、静态联编</p>
<p>计算机应用程序对它的变量、对象的访问，以及对函数的调用实际上都是通过地址，而不是像源程序那样通过名字。程序中的变量名、对象名和函数名都是在编译的时候被编译器变换成了地址，这个地址是逻辑地址，在程序运行的时候再转换为物理地址。总之，程序最终运行的时候对各类变量的访问都是通过地址。</p>
<p>函数名字也会被编译器转换为地址，这样对这个函数的调用，就编译成了去执行这个地址里的指令（汇编语言更清晰的表达出这点），函数的调用关系就变成了对某个地址的连接。而这是编译器在编译时做成的连接，在运行的时候是不可能改变的，这种连接我们称之为静态联编。</p>
<p>2、动态联编</p>
<p>先说下多态。多态性实质就是“一个接口，多种方法”。就是基于“is-a”原理，把不同子类的对象都当做父类来看待，可以屏蔽不同子类对象之间的差异，写出通用的代码，增加代码的适用性。赋值之后，父对象就可以根据赋值给它的子对象的特性以不同的方式运作。多态最常用的就是上面“is-a”原理引申出来的第四点。通过基类对象指针去操作子类对象的函数，来实现多态性。当然基类中也要定义这个函数接口。这样的话问题就来了，像第一点所说的，函数名在编译的时候就被换算成了一个固定地址，那么当基类指针去操作同一个函数接口时，最终都会跳转到同一个地址，那就无法实现多态了。针对这个问题就引入了虚函数机制，虚函数机制是基于动态联编的，动态联编是相对静态联编来的，它的函数名对应的地址是在运行的时候才决定的，在编译时并不能确定各个函数的对应地址（这里是说编译器不确定，函数本身地址肯定是定了的），只有在运行的时候根据是隶属于哪个对象才去调用这个对象的同名函数。</p>
<p>默认状态下都是静态联编，为了引入动态联编，我们引入了虚函数机制，在对应的函数名前加上 virtual 关键字即可。然后剩下的工作就交给编译器去完成了，编译器才是实现多态性的真正幕后英雄。</p>
<p><strong>三、虚函数机制</strong></p>
<p>有了前面的异质链表和动态联编，我们开始解开虚函数的神秘面纱。</p>
<p>1、单一继承</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	Base(<span class="keyword">int</span> i = <span class="number">1</span>) :a(i)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	Derived(<span class="keyword">int</span> j = <span class="number">2</span>) :Base(j), b(j)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span><span class="comment">//覆盖的情况</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base* ptr = <span class="keyword">new</span> Derived(<span class="number">10</span>);</span><br><span class="line">	ptr-&gt;fun_a();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出就不用多说了。 </p>
<p>我们看看 ptr 指向的对象的布局：</p>
<p><img src="/2020/12/27/C++%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E8%99%9A%E5%87%BD%E6%95%B0/20141122215133793" alt="img"></p>
<p>看到虚表指针指向的虚函数表中第一个位置存放的是子类对象的函数，显然子类的虚函数已经覆盖了父类的同名同类型虚函数。</p>
<p>父类和子类都定义有虚函数，且存在不同类型的，情况就会如下所示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	Base(<span class="keyword">int</span> i = <span class="number">1</span>) :a(i)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_b</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::b"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	Derived(<span class="keyword">int</span> j = <span class="number">2</span>) :Base(j), b(j)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_c</span><span class="params">()</span><span class="comment">//无覆盖</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::c"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun_b</span><span class="params">()</span><span class="comment">//覆盖</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::b"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base* ptr = <span class="keyword">new</span> Derived(<span class="number">10</span>);</span><br><span class="line">	fun pFun = <span class="literal">NULL</span>;</span><br><span class="line">	pFun = (fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(ptr)+<span class="number">2</span>);</span><br><span class="line">	pFun();</span><br><span class="line">	<span class="comment">//ptr-&gt;fun_a();</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有意思的是调试的时候，Visual Studio 窗口中居然没有显示虚函数表的第三个函数指针，所以上面额外测试了一下。子类实际的虚表如下：</p>
<p>虚函数表：虚函数指针都在位于同一个函数指针数组中，很容易寻址到。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  Derived::$vftable@:</span><br><span class="line">1&gt;  	| &amp;Derived_meta</span><br><span class="line">1&gt;  	|  0</span><br><span class="line">1&gt;   0	| &amp;Base::fun_a </span><br><span class="line">1&gt;   1	| &amp;Derived::fun_b </span><br><span class="line">1&gt;   2	| &amp;Derived::fun_c</span><br></pre></td></tr></table></figure>

<p>可以得出的是， 没有覆盖的情况下，基类的虚函数指针放在虚表的前面，然后再是派生类的虚函数指针，其中覆盖的放在自身的没有不覆盖基类的前面。多个覆盖自然就是按顺序来。<br>上面派生类只会有一张虚函数表，基类和派生类的虚函数指针都放置在其中。<br>那么虚函数的调用过程是怎么样的呢？这里修改了上面的程序，把基类的 fun_b() 函数退化为一般函数，然后分别调用一个虚函数和这个一般函数，看看它们的反汇编代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">66</span>: 	ptr-&gt;fun_a();</span><br><span class="line"><span class="number">00405998</span>  mov         eax,dword ptr [ptr]  </span><br><span class="line"><span class="number">0040599B</span>  mov         edx,dword ptr [eax]  </span><br><span class="line"><span class="number">0040599</span>D  mov         esi,esp  </span><br><span class="line"><span class="number">0040599F</span>  mov         ecx,dword ptr [ptr]  </span><br><span class="line"><span class="number">004059</span>A2  mov         eax,dword ptr [edx]  </span><br><span class="line"><span class="number">004059</span>A4  call        eax  </span><br><span class="line"><span class="number">004059</span>A6  cmp         esi,esp  </span><br><span class="line"><span class="number">004059</span>A8  call        __RTC_CheckEsp (<span class="number">0401343</span>h)  </span><br><span class="line">    <span class="number">67</span>: 	ptr-&gt;fun_b();</span><br><span class="line"><span class="number">004059</span>AD  mov         ecx,dword ptr [ptr]  </span><br><span class="line"><span class="number">004059B</span>0  <span class="function">call        <span class="title">Base::fun_b</span> <span class="params">(<span class="number">04016F</span>Eh)</span></span></span><br></pre></td></tr></table></figure>

<p>上面fun_a() 是虚函数，fun_b() 是一般函数，通过汇编代码看看这两个函数的调用过程，可以看出一般函数是通过类直接调用，没什么特殊之处。重点看看虚函数的调用：</p>
<p>第二行代码（第一行汇编 mov  eax,dword ptr [ptr] ），取基类指针指向的数据（虚表指针）；后面的 mov  edx,dword ptr [eax]，定位到了虚函数表首位置；第六行 mov  eax,dword ptr [edx]，即得到对应位置（首位置）的虚函数指针（如果调用的虚函数指针不是首位置，那么这里会是edx+x），后面 call  eax 则是通过虚函数指针调用该虚函数。</p>
<p>总的说来，虚函数的调用是先定位到对应类的虚函数表，然后再去找对应位置的虚函数指针，继而调用该虚函数。</p>
<p>单一继承下，即只继承一个基类，那么派生类都只会产生一个虚函数表，<a href="http://blog.csdn.net/wenqian1991/article/details/41047957" target="_blank" rel="noopener">前面</a>已经说过了。然后所有的虚函数指针都放在这一张虚表中，派生类同类型虚函数会覆盖基类虚函数。虚函数机制下，编译器并不是简单的把基类指针类型编译成对应基类，而是按照这个基类指针去找到它指向的对象，换句话说不是看它的指针类型而是看它指向什么对象，对象下面有虚表指针，然后就是按照上面说的层层解引用调用对应的函数。</p>
<p>上面就是动态联编的过程，很显然效率要比静态联编低。</p>
<p>这虚函数指针的放置简单的说就是：先基类，然后派生类，派生类有覆盖的则直接对应覆盖。</p>
<p>2、多重继承</p>
<p>前面博文说到，多重继承（非虚拟继承）的情况下，继承多少个含虚函数基类（自身带虚函数表），派生类中就会生成多少个虚函数表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	Base1(<span class="keyword">int</span> i = <span class="number">1</span>) :a(i)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::a"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	Base2(<span class="keyword">int</span> i = <span class="number">2</span>) :b(i)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_b</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::b"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	Child(<span class="keyword">int</span> i = <span class="number">3</span>) :Base1(i), Base2(i), c(i)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span><span class="comment">//覆盖基类Base1</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Child::a"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun_b</span><span class="params">()</span><span class="comment">//覆盖基类Base2</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Child::b"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun_c</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"child"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Child <span class="title">c</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">	c.fun_a();<span class="comment">//静态联编</span></span><br><span class="line">	Base1 &amp;ptr = c;</span><br><span class="line">	ptr.fun_a();<span class="comment">//动态联编</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的派生类公共继承了两个含有虚表的基类，自然地派生类中会产生两张虚表。</p>
<p>在讨论虚函数表前，先看看main函数，这里分别用了两个不同的手法调用函数 fun_a，第一个是静态联编，直接通过对象的名字来调用该对象的虚函数，无需额外的去定位对象了，而后面的动态联编，则要通过引用或指针先找到对应的对象，再去调用该对象的虚函数。</p>
<p>派生类中的虚函数表：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  Child::$vftable@Base1@:</span><br><span class="line">1&gt; | &amp;Child_meta</span><br><span class="line">1&gt; | 0</span><br><span class="line">1&gt;   0 | &amp;Child::fun_a</span><br><span class="line">1&gt;   1 | &amp;Child::fun_c</span><br><span class="line">1&gt;</span><br><span class="line">1&gt;  Child::$vftable@Base2@:</span><br><span class="line">1&gt; | -8</span><br><span class="line">1&gt;   0 | &amp;Child::fun_b</span><br></pre></td></tr></table></figure>

<p>这样 当不同基类类型的指针指向同一个派生类对象时，都能够调用到实际的函数。改一下main函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Child <span class="title">c</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">	Base1 &amp;ptr1 = c;</span><br><span class="line">	ptr1.fun_a();</span><br><span class="line">	Base2 &amp;ptr2 = c;</span><br><span class="line">	ptr2.fun_b();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面两次调用的局部汇编code：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">77</span>: 	Base1 &amp;ptr1 = c;</span><br><span class="line"><span class="number">00</span>AA5E02  lea         eax,[c]  </span><br><span class="line"><span class="number">00</span>AA5E05  mov         dword ptr [ptr1],eax  </span><br><span class="line">    <span class="number">78</span>: 	ptr1.fun_a();<span class="comment">//动态联编</span></span><br><span class="line"><span class="number">00</span>AA5E08  mov         eax,dword ptr [ptr1]  </span><br><span class="line"><span class="number">00</span>AA5E0B  mov         edx,dword ptr [eax]  </span><br><span class="line"><span class="number">00</span>AA5E0D  mov         esi,esp  </span><br><span class="line"><span class="number">00</span>AA5E0F  mov         ecx,dword ptr [ptr1]  </span><br><span class="line"><span class="number">00</span>AA5E12  mov         eax,dword ptr [edx]  </span><br><span class="line"><span class="number">00</span>AA5E14  call        eax  </span><br><span class="line">    <span class="number">80</span>: 	Base2 &amp;ptr2 = c;</span><br><span class="line"><span class="number">00</span>AA5E1D  lea         eax,[c]  </span><br><span class="line"><span class="number">00</span>AA5E20  test        eax,eax  </span><br><span class="line"><span class="number">00</span>AA5E22  je          main+<span class="number">62</span>h (<span class="number">0</span>AA5E32h)  </span><br><span class="line"><span class="number">00</span>AA5E24  lea         ecx,[c]  </span><br><span class="line"><span class="number">00</span>AA5E27  add         ecx,<span class="number">8</span>  <span class="comment">//指针位置调整</span></span><br><span class="line"><span class="number">00</span>AA5E2A  mov         dword ptr [ebp<span class="number">-0F</span>Ch],ecx  </span><br><span class="line"><span class="number">00</span>AA5E30  jmp         main+<span class="number">6</span>Ch (<span class="number">0</span>AA5E3Ch)  </span><br><span class="line"><span class="number">00</span>AA5E32  mov         dword ptr [ebp<span class="number">-0F</span>Ch],<span class="number">0</span>  </span><br><span class="line"><span class="number">00</span>AA5E3C  mov         edx,dword ptr [ebp<span class="number">-0F</span>Ch]  </span><br><span class="line"><span class="number">00</span>AA5E42  mov         dword ptr [ptr2],edx  </span><br><span class="line">    <span class="number">81</span>: 	ptr2.fun_b();</span><br><span class="line"><span class="number">00</span>AA5E45  mov         eax,dword ptr [ptr2]  </span><br><span class="line"><span class="number">00</span>AA5E48  mov         edx,dword ptr [eax]  </span><br><span class="line">    <span class="number">81</span>: 	ptr2.fun_b();</span><br><span class="line"><span class="number">00</span>AA5E4A  mov         esi,esp  </span><br><span class="line"><span class="number">00</span>AA5E4C  mov         ecx,dword ptr [ptr2]  </span><br><span class="line"><span class="number">00</span>AA5E4F  mov         eax,dword ptr [edx]  </span><br><span class="line"><span class="number">00</span>AA5E51  call        eax</span><br></pre></td></tr></table></figure>

<p>后面调用的指针位置调整，就是根据由哪个基类指针指向来调整的（继承的基类在派生类中的位置）。这样不管继承多少个带虚表的基类，最终都能准确的调用到对应的虚函数。</p>
<p>也可以看出派生类中的两张虚表指针并不是全部在内存的首位置，而是等继承的第一个基类“放置”后再处理第二个。。<br>上面这一切都是编译器的功劳，我们只是通过基类指针简单的调用虚函数，然后内部的各类转移都是编译器的功劳。</p>
<p><strong>号外：</strong>构造函数，静态函数，内联函数，普通函数(非成员函数)、友元函数不能作为虚函数，成员模板函数也不能：虚函数仅适用于有继承关系的类对象。</p>
<p>虚函数是基于虚函数表的（内存空间），构造函数如果是虚函数，调用时也需要根据虚表寻找，但是虚表的产生依赖于构造函数（看下面的虚表指针的初始化），不能本末倒置，另外构造函数不能被继承（重写），静态函数是属于 class 自己的，必须有实体，其也不能被继承，内联函数在编译时展开，跟虚函数完全不是一个调调，水火不容的关系，至于普通函数，友元函数等，这两者是类外函数，不能被继承。</p>
<p><strong><em>\</em>四、虚表指针的初始化**</strong></p>
<p>没有虚函数的类对象自然不会产生虚表指针，而有虚函数的类对象就会产生虚表指针，那么虚表指针是什么时候安插在对象中的呢？答案就是构造函数。</p>
<p>我们可以在构造child实例处设置断点，然后反汇编跟踪编译，进入child的构造函数下的Base1构造函数，我们会发现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">35</span>: 	Base1(<span class="keyword">int</span> i = <span class="number">1</span>) :a(i)&#123;&#125;</span><br><span class="line">…… <span class="comment">//debug初始化环境略</span></span><br><span class="line"><span class="number">0008383F</span>  pop         ecx  <span class="comment">//还原this指针</span></span><br><span class="line"><span class="number">00083840</span>  mov         dword ptr [<span class="keyword">this</span>],ecx  <span class="comment">//存储this指针  </span></span><br><span class="line"><span class="number">00083843</span>  mov         eax,dword ptr [<span class="keyword">this</span>]  <span class="comment">//取出this指针并保存在eax中</span></span><br><span class="line"></span><br><span class="line"><span class="number">00083846</span>  mov         dword ptr [eax],<span class="number">8</span>DCB0h  <span class="comment">//后面的8DCB0h实际是虚函数表的偏移地址，也就是虚表指针安插在对象的前面（this指针内容）</span></span><br><span class="line"><span class="number">0008384</span>C  mov         eax,dword ptr [<span class="keyword">this</span>]    <span class="comment">//返回对象</span></span><br></pre></td></tr></table></figure>

<p>可以看出， 虚表指针是通过编译器在构造函数内安插在对象的前面的。另外也可以看到虚表指针的初始化都是基于this指针的，只有成员函数才有this指针，这就是为什么虚函数必须作为成员函数是用的原因。 </p>
<p>在虚表指针的初始化过程中，对象执行了构造函数后，就得到了虚表指针，当其余代码访问这个对象虚函数时，会根据对象的首地址，取出对应的虚表函数，当函数被调用时，会间接访问虚表，得到对应的虚函数首地址，然后调用执行。说白了就是地址转移来转移去的。</p>
<p>这种通过虚表间接寻址的情况只有在使用对象的指针或引用来调用虚函数时候才会出现，当直接使用对象调用自身的虚函数时，无需查表访问。就是前面代码中的静态联编方式访问。</p>
<p><strong>五、多态性</strong></p>
<p>前面说了动态联编和虚函数机制，就不能不说说这个C++中很重要的一个特性：多态性</p>
<p>多态性，简单地说就是“一个接口，多种实现”，就是不同的对象对应同一消息产生不同行为。一般而言，用同一个接口函数，去执行不同的函数体。执行哪个函数体看关联的是哪个对象。</p>
<p>下面直接通过一个简单例子来演示这个多态性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Course</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Choose</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span> :</span><span class="keyword">public</span> Course</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Choose</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Choose a Computer course"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Literature</span> :</span><span class="keyword">public</span> Course</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Choose</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Choose a Literature course"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DigitalImage</span> :</span><span class="keyword">public</span> Course</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Choose</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Choose a DigitalImage course"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection</span><span class="params">(Course *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ptr-&gt;Choose();<span class="comment">//动态联编，对不同的对象发送同一消息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Computer ObjCom;</span><br><span class="line">	Literature ObjLit;</span><br><span class="line">	DigitalImage ObjDig;</span><br><span class="line">	selection(&amp;ObjCom);</span><br><span class="line">	selection(&amp;ObjLit);</span><br><span class="line">	selection(&amp;ObjDig);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序中不同的课程，通过同一个消息来选择，选择的结果却由课程对象自身决定。</p>
<p>虚函数机制是这个实现的内在基石。多态性是外在的现象。</p>
<p>最后再补充一下：C++明白指出，当 derived class 对象经由一个 base class 指针被删除，而该base class 带着一个 non-virtual 析构函数，其结果是未有定义——实际执行时通常发生的是对象的 derived 成分没被销毁，而其base 成分通常会被销毁，造成一个诡异的“局部销毁”的对象。</p>
<p>如下面一个例子，如果base class 是带着一个 non-virtual 析构函数，那么下面程序，派生类将不会进行析构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Base() &#123;&#125;;</span><br><span class="line">	<span class="keyword">virtual</span> <span class="comment">/*尝试注释掉这个关键字，看输出结果*/</span> ~Base() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Output from the destructor of class Base"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Do something in class Base"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Derived() &#123;&#125;;</span><br><span class="line">	~Derived() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Output from the destructor of class Derived"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Do something in class Derived"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base *pT = <span class="keyword">new</span> Derived;</span><br><span class="line">	pT-&gt;DoSomething();</span><br><span class="line">	<span class="keyword">delete</span> pT;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使 base class 中不含虚函数（注释掉Dosomgthing函数前的virtual），如果不定义虚析构函数，那么派生类的析构函数将不会被调用，所以如果base class 是作为基类使用，其析构函数也应该定义为虚函数。 </p>
<p>虚析构函数与虚函数是相伴而生的。Scott Meyers 在《Effective C++》中建议：如果class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数。理由很简单，我们希望所自动调用的析构函数，能够通过动态联编方式去调用所关联的实际对象的析构函数，而不是简单的指针的基类型对应的基类对象的析构函数。</p>
<p>盲目的添加虚函数会增大对象内存空间，我们的心得是：除了上述情况，如果该 class 作为基类使用，那么它就应该声明一个 virtual 析构函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/25/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><span class="page-number current">26</span><a class="page-number" href="/page/27/">27</a><span class="space">&hellip;</span><a class="page-number" href="/page/48/">48</a><a class="extend next" rel="next" href="/page/27/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">匡俊桦</p>
  <div class="site-description" itemprop="description">回忆的沙漏将曾经屈指可数的日子渐渐淡去</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">238</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">匡俊桦</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">29:11</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
