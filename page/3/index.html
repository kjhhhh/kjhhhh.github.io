<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="KJH">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/%E5%B8%B8%E7%94%A8%20Linux%20%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/%E5%B8%B8%E7%94%A8%20Linux%20%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">常用 Linux 命令的基本使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 20:21:22" itemprop="dateCreated datePublished" datetime="2020-12-22T20:21:22+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2017-05-18 19:57:42" itemprop="dateModified" datetime="2017-05-18T19:57:42+08:00">2017-05-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="常用-Linux-命令的基本使用"><a href="#常用-Linux-命令的基本使用" class="headerlink" title="常用 Linux 命令的基本使用"></a>常用 Linux 命令的基本使用</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>理解学习 Linux 终端命令的原因</li>
<li>常用 Linux 命令体验</li>
</ul>
<h2 id="01-学习-Linux-终端命令的原因"><a href="#01-学习-Linux-终端命令的原因" class="headerlink" title="01. 学习 Linux 终端命令的原因"></a>01. 学习 Linux 终端命令的原因</h2><ul>
<li>Linux 刚面世时并没有图形界面，所有的操作全靠命令完成，如 <strong>磁盘操作</strong>、<strong>文件存取</strong>、<strong>目录操作</strong>、<strong>进程管理</strong>、<strong>文件权限</strong> 设定等</li>
<li>在职场中，大量的 <strong>服务器维护工作</strong> 都是在 <strong>远程</strong> 通过 <strong>SSH 客户端</strong> 来完成的，并没有图形界面，所有的维护工作都需要通过命令来完成</li>
<li>在职场中，作为后端程序员，必须要或多或少的掌握一些 Linux 常用的终端命令</li>
<li>Linux 发行版本的命令大概有 200 多个，但是常用的命令只有 10 多个而已</li>
</ul>
<blockquote>
<p>学习终端命令的技巧：</p>
<ul>
<li>不需要死记硬背，对于常用命令，用的多了，自然就记住了</li>
<li>不要尝试一次学会所有的命令，有些命令是非常不常用的，临时遇到，临时百度就可以</li>
</ul>
</blockquote>
<h2 id="02-常用-Linux-命令的基本使用"><a href="#02-常用-Linux-命令的基本使用" class="headerlink" title="02. 常用 Linux 命令的基本使用"></a>02. 常用 Linux 命令的基本使用</h2><table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>对应英文</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>01</td>
<td>ls</td>
<td>list</td>
<td>查看当前文件夹下的内容</td>
</tr>
<tr>
<td>02</td>
<td>pwd</td>
<td>print work directory</td>
<td>查看当前所在文件夹</td>
</tr>
<tr>
<td>03</td>
<td>cd [目录名]</td>
<td>change directory</td>
<td>切换文件夹</td>
</tr>
<tr>
<td>04</td>
<td>touch [文件名]</td>
<td>touch</td>
<td>如果文件不存在，新建文件</td>
</tr>
<tr>
<td>05</td>
<td>mkdir [目录名]</td>
<td>make directory</td>
<td>创建目录</td>
</tr>
<tr>
<td>06</td>
<td>rm [文件名]</td>
<td>remove</td>
<td>删除指定的文件名</td>
</tr>
<tr>
<td>07</td>
<td>clear</td>
<td>clear</td>
<td>清屏</td>
</tr>
</tbody></table>
<blockquote>
<p>小技巧</p>
<ul>
<li><code>ctrl + shift + =</code> <strong>放大</strong>终端窗口的字体显示</li>
<li><code>ctrl + -</code> <strong>缩小</strong>终端窗口的字体显示</li>
</ul>
</blockquote>
<h3 id="03-自动补全"><a href="#03-自动补全" class="headerlink" title="03. 自动补全"></a>03. 自动补全</h3><ul>
<li>在敲出 <code>文件</code>／<code>目录</code>／<code>命令</code> 的前几个字母之后，按下 <code>tab</code> 键<ul>
<li>如果输入的没有歧义，系统会自动补全</li>
<li>如果还存在其他 <code>文件</code>／<code>目录</code>／<code>命令</code>，再按一下 <code>tab</code> 键，系统会提示可能存在的命令</li>
</ul>
</li>
</ul>
<blockquote>
<p>小技巧</p>
<ul>
<li>按 <code>上</code>／<code>下</code> 光标键可以在曾经使用过的命令之间来回切换</li>
<li>如果想要退出选择，并且不想执行当前选中的命令，可以按 <code>ctrl + c</code></li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%EF%BC%88%E7%A7%91%E6%99%AE%E7%AB%A0%E8%8A%82%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%EF%BC%88%E7%A7%91%E6%99%AE%E7%AB%A0%E8%8A%82%EF%BC%89/" class="post-title-link" itemprop="url">操作系统的发展史（科普章节）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-22 20:21:22 / 修改时间：20:26:02" itemprop="dateCreated datePublished" datetime="2020-12-22T20:21:22+08:00">2020-12-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统的发展史（科普章节）"><a href="#操作系统的发展史（科普章节）" class="headerlink" title="操作系统的发展史（科普章节）"></a>操作系统的发展史（科普章节）</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>了解操作系统的发展历史</li>
<li>知道 Linux 内核及发行版的区别</li>
<li>知道 Linux 的应用领域</li>
</ul>
<h2 id="01-操作系统的发展历史"><a href="#01-操作系统的发展历史" class="headerlink" title="01. 操作系统的发展历史"></a>01. 操作系统的发展历史</h2><h3 id="1-1-Unix"><a href="#1-1-Unix" class="headerlink" title="1.1 Unix"></a>1.1 Unix</h3><p>1965 年之前的时候，电脑并不像现在一样普遍，它可不是一般人能碰的起的，除非是军事或者学院的研究机构，而且当时大型主机至多能提供30台终端（30个键盘、显示器)，连接一台电脑</p>
<p><img src="/2020/12/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%EF%BC%88%E7%A7%91%E6%99%AE%E7%AB%A0%E8%8A%82%EF%BC%89/001_%E5%A4%A7%E5%9E%8B%E6%9C%BA.png" alt><br><strong>为了解决数量不够用的问题</strong></p>
<ul>
<li>1965 年左后由 <strong>贝尔实验室</strong> 加入了 <strong>麻省理工学院</strong> 以及 <strong>通用电气</strong> 合作的计划 —— 该计划要建立一套 <strong>多使用者(multi－user)</strong>、<strong>多任务(multi－processor)</strong>、<strong>多层次(multi－level)</strong> 的 <strong>MULTICS</strong> 操作系统，想让大型主机支持 300 台终端</li>
<li>1969 年前后这个项目进度缓慢，资金短缺，贝尔实验室退出了研究</li>
<li>1969 年从这个项目中退出的 <strong>Ken Thompson</strong> 当时在实验室无聊时，为了让一台空闲的电脑上能够运行 “星际旅行（Space Travel）” 游戏，在 8 月份左右趁着其妻子探亲的时间，<strong>用了 1 个月的时间</strong>，使用汇编写出了 Unix 操作系统的原型</li>
<li>1970 年，美国贝尔实验室的 <strong>Ken Thompson</strong>，以 <strong>BCPL</strong> 语言为基础，设计出很简单且很接近硬件的 <strong>B 语言</strong>（取BCPL的首字母），并且他用 <strong>B 语言</strong> 写了第一个 UNIX 操作系统</li>
<li>1971 年，同样酷爱 “星际旅行（Space Travel）” 的 <strong>Dennis M.Ritchie</strong> 为了能早点儿玩上游戏，加入了 <strong>Thompson</strong> 的开发项目，合作开发 UNIX，他的主要工作是改造 <strong>B 语言</strong>，因为<strong>B 语言</strong> 的跨平台性较差</li>
<li>1972 年，<strong>Dennis M.Ritchie</strong> 在 <strong>B 语言</strong> 的基础上最终设计出了一种新的语言，他取了 <strong>BCPL</strong> 的第二个字母作为这种语言的名字，这就是 <strong>C 语言</strong></li>
<li>1973 年初，<strong>C 语言</strong>的主体完成，<strong>Thompson</strong> 和 <strong>Ritchie</strong> 迫不及待地开始用它完全重写了现在大名鼎鼎的 <strong>Unix 操作系统</strong></li>
</ul>
<p><img src="/2020/12/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%EF%BC%88%E7%A7%91%E6%99%AE%E7%AB%A0%E8%8A%82%EF%BC%89/002_unix%E4%B9%8B%E7%88%B6.png" alt></p>
<p>肯·汤普逊（左）和丹尼斯·里奇（右）</p>
<h4 id="C-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h4><ul>
<li>在把 <strong>UNIX</strong> 移植到其他类型的计算机上使用时，<strong>C 语言</strong>强大的移植性（Portability）在此显现<ul>
<li>机器语言和汇编语言都不具有移植性，为 x86 开发的程序，不可能在 Alpha，SPARC 和 ARM 等机器上运行</li>
</ul>
</li>
<li>而 <strong>C 语言</strong>程序则可以使用在任意架构的处理器上，只要那种架构的处理器<strong>具有对应的 C 语言编译器和库</strong>，然后将 C 源代码编译、连接成目标二进制文件之后即可运行 </li>
</ul>
<h4 id="Unix-家谱"><a href="#Unix-家谱" class="headerlink" title="Unix 家谱"></a>Unix 家谱</h4><p><img src="/2020/12/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%EF%BC%88%E7%A7%91%E6%99%AE%E7%AB%A0%E8%8A%82%EF%BC%89/003_unix%E5%AE%B6%E8%B0%B1.jpg" alt></p>
<h3 id="1-2-Minix"><a href="#1-2-Minix" class="headerlink" title="1.2 Minix"></a>1.2 Minix</h3><ul>
<li>因为 <strong>AT&amp;T（通用电气）</strong> 的政策改变，在 Version 7 Unix 推出之后，发布新的使用条款，将 UNIX 源代码私有化，在大学中不再能使用 UNIX 源代码</li>
<li><strong>Andrew S. Tanenbaum（塔能鲍姆）</strong> 教授为了能 <strong>在课堂上教授学生操作系统运作的细节</strong>，决定在不使用任何 AT&amp;T 的源代码前提下，自行开发与 UNIX 兼容的操作系统，以避免版权上的争议</li>
<li>以 <strong>小型 UNIX（mini-UNIX）</strong>之意，将它称为 <strong>MINIX</strong></li>
</ul>
<h3 id="1-3-Linux"><a href="#1-3-Linux" class="headerlink" title="1.3 Linux"></a>1.3 Linux</h3><ul>
<li>1991 年 <strong>林纳斯（Linus）</strong> 就读于赫尔辛基大学期间，对 Unix 产生浓厚兴趣，尝试着在Minix 上做一些开发工作</li>
<li>因为 <strong>Minix</strong> 只是教学使用，因此功能并不强，<strong>林纳斯</strong> 经常要用他的终端 <strong>仿真器（Terminal Emulator）</strong> 去访问大学主机上的新闻组和邮件，为了方便读写和下载文件，他自己编写了磁盘驱动程序和文件系统，这些在后来成为了 Linux 第一个内核的雏形，当时，他年仅 21 岁！</li>
<li><strong>林纳斯</strong> 利用 GNU 的 bash 当做开发环境，gcc 当做编译工具，编写了 Linux 内核，一开始 Linux 并不能兼容 Unix<ul>
<li>即 Unix 上跑的应用程序不能在 Linux 上跑，即应用程序与内核之间的接口不一致</li>
<li>一开始 Linux 只适用于 386，后来经过全世界的网友的帮助，最终能够兼容多种硬件</li>
</ul>
</li>
</ul>
<p><img src="/2020/12/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%EF%BC%88%E7%A7%91%E6%99%AE%E7%AB%A0%E8%8A%82%EF%BC%89/004_%E6%9E%97%E7%BA%B3%E6%96%AF.jpg" alt></p>
<h2 id="02-Linux-内核及发行版"><a href="#02-Linux-内核及发行版" class="headerlink" title="02. Linux 内核及发行版"></a>02. Linux 内核及发行版</h2><h3 id="2-1-Linux-内核版本"><a href="#2-1-Linux-内核版本" class="headerlink" title="2.1 Linux 内核版本"></a>2.1 Linux 内核版本</h3><ul>
<li><strong>内核（kernel）</strong>是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序，它提供了一个在裸设备与应用程序间的抽象层</li>
<li>Linux 内核版本又分为 <strong>稳定版</strong> 和 <strong>开发版</strong>，两种版本是相互关联，相互循环<ul>
<li><strong>稳定版</strong>：具有工业级强度，可以广泛地应用和部署。新的稳定版相对于较旧的只是修正一些 bug 或加入一些新的驱动程序</li>
<li><strong>开发版</strong>：由于要试验各种解决方案，所以变化很快</li>
</ul>
</li>
<li>内核源码网址：<a href="http://www.kernel.org" target="_blank" rel="noopener">http://www.kernel.org</a></li>
</ul>
<blockquote>
<p>所有来自全世界的对 Linux 源码的修改最终都会汇总到这个网站，由 Linus 领导的开源社区对其进行甄别和修改最终决定是否进入到 Linux 主线内核源码中</p>
</blockquote>
<h3 id="2-2-Linux-发行版本"><a href="#2-2-Linux-发行版本" class="headerlink" title="2.2 Linux 发行版本"></a>2.2 Linux 发行版本</h3><ul>
<li><p><strong>Linux 发行版（也被叫做 GNU/Linux 发行版）</strong>通常包含了包括桌面环境、办公套件、媒体播放器、数据库等应用软件</p>
</li>
<li><p>常见的发行版本如下：</p>
<ul>
<li>Ubuntu</li>
<li>Redhat</li>
<li>Fedora</li>
<li>openSUSE</li>
<li>Linux Mint</li>
<li>Debian</li>
<li>Manjaro</li>
<li>Mageia</li>
<li>CentOS</li>
<li>Arch</li>
</ul>
</li>
<li><p>十大 Linux 服务器发行版排行榜：<a href="http://os.51cto.com/art/201612/526126.htm" target="_blank" rel="noopener">http://os.51cto.com/art/201612/526126.htm</a></p>
</li>
</ul>
<blockquote>
<p>在几乎每一份与 Linux 有关的榜单上，基于 Debian 的 Ubuntu 都占有一席之位。Canonical 的Ubuntu 胜过其他所有的 Linux 服务器发行版 ―― 从简单安装、出色的硬件发现，到世界级的商业支持，Ubuntu确立了难以企及的严格标准</p>
</blockquote>
<h2 id="03-Linux-的应用领域"><a href="#03-Linux-的应用领域" class="headerlink" title="03. Linux 的应用领域"></a>03. Linux 的应用领域</h2><h3 id="3-1-服务器领域"><a href="#3-1-服务器领域" class="headerlink" title="3.1 服务器领域"></a>3.1 服务器领域</h3><ul>
<li>Linux 在服务器领域的应用是其重要分支</li>
<li>Linux 免费、稳定、高效等特点在这里得到了很好的体现<ul>
<li>早期因为维护、运行等原因同样受到了很大的限制</li>
<li>近些年来 Linux 服务器市场得到了飞速的提升，尤其在一些高端领域尤为广泛</li>
</ul>
</li>
</ul>
<h3 id="3-2-嵌入式领域"><a href="#3-2-嵌入式领域" class="headerlink" title="3.2 嵌入式领域"></a>3.2 嵌入式领域</h3><ul>
<li>近些年来 Linux 在嵌入式领域的应用得到了飞速的提高</li>
<li>Linux 运行稳定、对网络的良好支持性、低成本，且可以根据需要进行软件裁剪，内核最小可以达到几百 KB 等特点，使其近些年来在嵌入式领域的应用得到非常大的提高</li>
</ul>
<blockquote>
<p>主要应用：<strong>机顶盒</strong>、<strong>数字电视</strong>、<strong>网络电话</strong>、<strong>程控交换机</strong>、<strong>手机</strong>、<strong>PDA</strong>、等都是其应用领域，得到了 Google、三星、摩托罗拉、NEC 等公司的大力推广</p>
</blockquote>
<h3 id="3-3-个人桌面领域"><a href="#3-3-个人桌面领域" class="headerlink" title="3.3 个人桌面领域"></a>3.3 个人桌面领域</h3><ul>
<li>此领域是传统 Linux 应用最薄弱的环节</li>
<li>传统 Linux 由于界面简单、操作复杂、应用软件少的缺点，一直被 Windows 所压制</li>
<li>近些年来随着 <strong>Ubuntu</strong>、<strong>Fedora</strong> 等优秀桌面环境的兴起，同时各大硬件厂商对其支持的加大，Linux 在个人桌面领域的占有率在逐渐的提高</li>
</ul>
<blockquote>
<p>在 Ubuntu 中玩 QQ</p>
</blockquote>
<p><img src="/2020/12/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%EF%BC%88%E7%A7%91%E6%99%AE%E7%AB%A0%E8%8A%82%EF%BC%89/005_ubuntu_qq.jpg" alt></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%A7%91%E6%99%AE%E7%AB%A0%E8%8A%82%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%A7%91%E6%99%AE%E7%AB%A0%E8%8A%82%EF%BC%89/" class="post-title-link" itemprop="url">操作系统（科普章节）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-22 20:21:22 / 修改时间：20:24:25" itemprop="dateCreated datePublished" datetime="2020-12-22T20:21:22+08:00">2020-12-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统（科普章节）"><a href="#操作系统（科普章节）" class="headerlink" title="操作系统（科普章节）"></a>操作系统（科普章节）</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>了解<strong>操作系统</strong>及作用</li>
</ul>
<h2 id="1-操作系统（Operation-System，OS）"><a href="#1-操作系统（Operation-System，OS）" class="headerlink" title="1. 操作系统（Operation System，OS）"></a>1. 操作系统（Operation System，OS）</h2><blockquote>
<p>操作系统作为接口的示意图</p>
</blockquote>
<p><img src="/2020/12/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%A7%91%E6%99%AE%E7%AB%A0%E8%8A%82%EF%BC%89/001_OS%E4%BD%9C%E4%B8%BA%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt></p>
<blockquote>
<p>没有安装操作系统的计算机，通常被称为 <strong>裸机</strong></p>
<ul>
<li>如果想在 <strong>裸机</strong> 上运行自己所编写的程序，就必须用机器语言书写程序</li>
<li>如果计算机上安装了操作系统，就可以在操作系统上安装支持的高级语言环境，用高级语言开发程序</li>
</ul>
</blockquote>
<h3 id="1-1-操作系统的作用"><a href="#1-1-操作系统的作用" class="headerlink" title="1.1 操作系统的作用"></a>1.1 操作系统的作用</h3><ul>
<li>是现代计算机系统中 <strong>最基本和最重要</strong> 的系统软件</li>
<li>是 <strong>配置在计算机硬件上的第一层软件</strong>，是对硬件系统的首次扩展</li>
<li>主要作用是<strong>管理好硬件设备</strong>，并为用户和应用程序提供一个简单的接口，以便于使用</li>
<li>而其他的诸如编译程序、数据库管理系统，以及大量的应用软件，都直接依赖于操作系统的支持</li>
</ul>
<h3 id="1-2-不同应用领域的主流操作系统"><a href="#1-2-不同应用领域的主流操作系统" class="headerlink" title="1.2 不同应用领域的主流操作系统"></a>1.2 不同应用领域的主流操作系统</h3><ul>
<li>桌面操作系统</li>
<li>服务器操作系统</li>
<li>嵌入式操作系统</li>
<li>移动设备操作系统</li>
</ul>
<h4 id="1-gt-桌面操作系统"><a href="#1-gt-桌面操作系统" class="headerlink" title="1&gt; 桌面操作系统"></a>1&gt; 桌面操作系统</h4><ul>
<li>Windows 系列<ul>
<li>用户群体大</li>
</ul>
</li>
<li>macOS<ul>
<li>适合于开发人员</li>
</ul>
</li>
<li>Linux<ul>
<li>应用软件少</li>
</ul>
</li>
</ul>
<h4 id="2-gt-服务器操作系统"><a href="#2-gt-服务器操作系统" class="headerlink" title="2&gt; 服务器操作系统"></a>2&gt; 服务器操作系统</h4><ul>
<li>Linux<ul>
<li>安全、稳定、免费</li>
<li>占有率高</li>
</ul>
</li>
<li>Windows Server<ul>
<li>付费</li>
<li>占有率低</li>
</ul>
</li>
</ul>
<p><img src="/2020/12/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%A7%91%E6%99%AE%E7%AB%A0%E8%8A%82%EF%BC%89/002_%E6%9C%BA%E6%88%BF%E7%85%A7%E7%89%87.jpg" alt></p>
<h4 id="3-gt-嵌入式操作系统"><a href="#3-gt-嵌入式操作系统" class="headerlink" title="3&gt; 嵌入式操作系统"></a>3&gt; 嵌入式操作系统</h4><ul>
<li>Linux</li>
</ul>
<h4 id="4-gt-移动设备操作系统"><a href="#4-gt-移动设备操作系统" class="headerlink" title="4&gt; 移动设备操作系统"></a>4&gt; 移动设备操作系统</h4><ul>
<li>iOS</li>
<li>Android（基于 <code>Linux</code>）</li>
</ul>
<h3 id="1-3-虚拟机"><a href="#1-3-虚拟机" class="headerlink" title="1.3 虚拟机"></a>1.3 虚拟机</h3><p>虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统</p>
<ul>
<li>虚拟系统通过生成现有操作系统的全新虚拟镜像，具有真实操作系统完全一样的功能</li>
<li>进入虚拟系统后，所有操作都是在这个全新的独立的虚拟系统里面进行，可以独立安装运行软件，保存数据，拥有自己的独立桌面，不会对真正的系统产生任何影响</li>
<li>而且能够在现有系统与虚拟镜像之间灵活切换的一类操作系统</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/Ubuntu%20%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/Ubuntu%20%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">Ubuntu 图形界面入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-22 20:21:22 / 修改时间：20:23:25" itemprop="dateCreated datePublished" datetime="2020-12-22T20:21:22+08:00">2020-12-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Ubuntu-图形界面入门"><a href="#Ubuntu-图形界面入门" class="headerlink" title="Ubuntu 图形界面入门"></a>Ubuntu 图形界面入门</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>熟悉 Ubuntu 图形界面的基本使用</li>
</ul>
<h2 id="01-Ubuntu-的任务栏"><a href="#01-Ubuntu-的任务栏" class="headerlink" title="01. Ubuntu 的任务栏"></a>01. Ubuntu 的任务栏</h2><p><img src="/2020/12/22/Ubuntu%20%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%85%A5%E9%97%A8/14928329271228.jpg" alt></p>
<h2 id="02-窗口操作按钮"><a href="#02-窗口操作按钮" class="headerlink" title="02. 窗口操作按钮"></a>02. 窗口操作按钮</h2><p><img src="/2020/12/22/Ubuntu%20%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%85%A5%E9%97%A8/14928325424356.jpg" alt></p>
<h2 id="03-窗口菜单条"><a href="#03-窗口菜单条" class="headerlink" title="03. 窗口菜单条"></a>03. 窗口菜单条</h2><p><img src="/2020/12/22/Ubuntu%20%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%85%A5%E9%97%A8/14928327078409.jpg" alt></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/Linux%20%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/Linux%20%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F/" class="post-title-link" itemprop="url">Linux 终端命令格式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 20:21:22" itemprop="dateCreated datePublished" datetime="2020-12-22T20:21:22+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2017-05-17 18:58:20" itemprop="dateModified" datetime="2017-05-17T18:58:20+08:00">2017-05-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux-终端命令格式"><a href="#Linux-终端命令格式" class="headerlink" title="Linux 终端命令格式"></a>Linux 终端命令格式</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>了解终端命令格式</li>
<li>知道如何查阅终端命令帮助信息</li>
</ul>
<h2 id="01-终端命令格式"><a href="#01-终端命令格式" class="headerlink" title="01. 终端命令格式"></a>01. 终端命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> [-options] [parameter]</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><code>command</code>：命令名，相应功能的英文单词或单词的缩写</li>
<li><code>[-options]</code>：选项，可用来对命令进行控制，也可以省略</li>
<li><code>parameter</code>：传给命令的参数，可以是 <strong>零个</strong>、<strong>一个</strong> 或者 <strong>多个</strong></li>
</ul>
<blockquote>
<p><code>[]</code> 代表可选 </p>
</blockquote>
<h2 id="02-查阅命令帮助信息（知道）"><a href="#02-查阅命令帮助信息（知道）" class="headerlink" title="02. 查阅命令帮助信息（知道）"></a>02. 查阅命令帮助信息（知道）</h2><blockquote>
<p>提示</p>
<ul>
<li>现阶段只需要 <strong>知道</strong> 通过以下两种方式可以查询命令的帮助信息</li>
<li>先学习<strong>常用命令</strong>及<strong>常用选项</strong>的使用即可，工作中如果遇到问题可以借助 <strong>网络搜索</strong></li>
</ul>
</blockquote>
<h3 id="2-1-help"><a href="#2-1-help" class="headerlink" title="2.1 --help"></a>2.1 <code>--help</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>显示 <code>command</code> 命令的帮助信息</li>
</ul>
<h3 id="2-2-man"><a href="#2-2-man" class="headerlink" title="2.2 man"></a>2.2 man</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man <span class="built_in">command</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>查阅 <code>command</code> 命令的使用手册</li>
</ul>
<blockquote>
<p><code>man</code> 是 <strong>manual</strong> 的缩写，是 Linux 提供的一个 <strong>手册</strong>，包含了绝大部分的命令、函数的详细使用说明</p>
</blockquote>
<p>使用 <code>man</code> 时的操作键：</p>
<table>
<thead>
<tr>
<th>操作键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>空格键</td>
<td>显示手册页的下一屏</td>
</tr>
<tr>
<td>Enter 键</td>
<td>一次滚动手册页的一行</td>
</tr>
<tr>
<td>b</td>
<td>回滚一屏</td>
</tr>
<tr>
<td>f</td>
<td>前滚一屏</td>
</tr>
<tr>
<td>q</td>
<td>退出</td>
</tr>
<tr>
<td>/word</td>
<td>搜索 <strong>word</strong> 字符串</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/install_ubuntu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/install_ubuntu/" class="post-title-link" itemprop="url">install_ubuntu</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-22 20:17:55 / 修改时间：20:20:29" itemprop="dateCreated datePublished" datetime="2020-12-22T20:17:55+08:00">2020-12-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="在虚拟机中安装-Ubuntu"><a href="#在虚拟机中安装-Ubuntu" class="headerlink" title="在虚拟机中安装 Ubuntu"></a>在虚拟机中安装 Ubuntu</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>安装前的准备和基本安装</li>
<li>设置语言环境</li>
<li>安装常用软件</li>
</ol>
<h2 id="1-安装前的准备和基本安装"><a href="#1-安装前的准备和基本安装" class="headerlink" title="1. 安装前的准备和基本安装"></a>1. 安装前的准备和基本安装</h2><h3 id="1-1-安装前的准备"><a href="#1-1-安装前的准备" class="headerlink" title="1.1 安装前的准备"></a>1.1 安装前的准备</h3><ul>
<li>访问 <a href="http://cn.ubuntu.com/download/" target="_blank" rel="noopener">http://cn.ubuntu.com/download/</a> 下载 Ubuntu 16.04 版本</li>
<li>在操作系统上安装 <code>VMWare</code> 虚拟机软件</li>
</ul>
<blockquote>
<p>为什么要使用虚拟机？</p>
<ol>
<li>不需要准备 <strong>额外的电脑</strong></li>
<li>在虚拟机中可以 <strong>大胆尝试任何操作</strong>，不用担心造成不可逆转的破坏</li>
</ol>
</blockquote>
<h3 id="1-2-基本安装"><a href="#1-2-基本安装" class="headerlink" title="1.2 基本安装"></a>1.2 基本安装</h3><ul>
<li>有了映像文件之后，只需要按照提示一步一步操作即可安装 Ubuntu 了</li>
<li><strong>提示</strong>，在开始安装之前，请确认勾选了 <strong>在虚拟机中访问个人文件夹</strong>，</li>
</ul>
<blockquote>
<p>该选项可以方便地实现在 <strong>虚拟机</strong> 和 <strong>个人电脑</strong> 之间共享文件</p>
</blockquote>
<ul>
<li>安装结束后，登录并且进入系统，可以看到以下画面：</li>
</ul>
<p><img src="/2020/12/22/install_ubuntu/002_%E9%BB%98%E8%AE%A4%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90.png" alt></p>
<h2 id="2-设置语言环境"><a href="#2-设置语言环境" class="headerlink" title="2. 设置语言环境"></a>2. 设置语言环境</h2><p>按照以下步骤操作可以修改 ubuntu 的语言环境</p>
<ul>
<li>1) 进入 <strong>系统设置 System Settings</strong></li>
<li>2) 打开 <strong>语言支持 Language Support</strong></li>
<li>3) 通过 <strong>安装/删除语言 Install/Remove Languages</strong> 添加 <strong>简体中文 Chinese(simplified)</strong></li>
<li>4) 将 <strong>汉语</strong> 拖拽到 <strong>顶部</strong>，如下图所示：</li>
</ul>
<p><img src="/2020/12/22/install_ubuntu/003_%E5%B0%86%E6%B1%89%E8%AF%AD%E6%8B%96%E6%8B%BD%E5%88%B0%E9%A1%B6%E9%83%A8.png" alt></p>
<ul>
<li>5) <strong>重新启动系统</strong></li>
<li>6) <strong>不</strong> 修改文件夹的名称，如下图所示：</li>
</ul>
<p><img src="/2020/12/22/install_ubuntu/004_%E4%B8%8D%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8D%E7%A7%B0.png" alt></p>
<h2 id="3-安装常用软件"><a href="#3-安装常用软件" class="headerlink" title="3. 安装常用软件"></a>3. 安装常用软件</h2><ul>
<li>3.1 设置服务器镜像源</li>
<li>3.2 在启动栏添加 <strong>终端</strong> 图标</li>
<li>3.3 <strong>apt</strong> 终端命令</li>
<li>3.4 谷歌浏览器 chrome</li>
<li>3.5 搜狗输入法</li>
</ul>
<h3 id="3-1-设置服务器镜像源"><a href="#3-1-设置服务器镜像源" class="headerlink" title="3.1 设置服务器镜像源"></a>3.1 设置服务器镜像源</h3><ul>
<li>Ubuntu 中 <strong>大部分</strong> 的软件 <strong>安装/更新</strong> 都是利用 <code>apt</code> 命令，从 <strong>ubuntu 的服务器</strong> 直接安装的</li>
<li>Ubuntu <strong>官方的服务器在国外</strong>，为了提高软件 <strong>安装/更新速度</strong>，<strong>ubuntu</strong> 提供了 <strong>选择最佳服务器</strong> 的功能，可以帮助我们方便的找到一个速度最快的 <strong>镜像服务器</strong>！</li>
</ul>
<blockquote>
<p>所谓 <strong>镜像服务器</strong>，就是 <strong>所有服务器的内容是相同的（镜像）</strong>，但是根据所在位置不同，速度不同，通常国内阿里云服务器速度会更快一些！</p>
</blockquote>
<p>按照以下步骤操作可以设置 ubuntu 的服务器</p>
<ul>
<li>1) 进入 <strong>系统设置</strong></li>
<li>2) 打开 <strong>软件和更新</strong></li>
<li>3) 设置 <strong>下载自…</strong> <strong>其他站点</strong></li>
<li>4) 通过 <strong>选择最佳服务器</strong> 选择速度最快的 <strong>镜像源</strong>，如下图所示：</li>
</ul>
<p><img src="/2020/12/22/install_ubuntu/005_%E8%87%AA%E5%8A%A8%E9%80%89%E6%8B%A9%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt></p>
<p><strong>提示</strong>：更换服务器之后，需要一个相对比较长时间的更新过程，需要耐心等待。更新完成后，再安装软件都会从新设置的服务器下载软件了</p>
<h3 id="3-2-在启动栏添加-终端-图标"><a href="#3-2-在启动栏添加-终端-图标" class="headerlink" title="3.2 在启动栏添加 终端 图标"></a>3.2 在启动栏添加 <strong>终端</strong> 图标</h3><ul>
<li>Ubuntu 的 <strong>启动栏</strong> 类似于 Windows 的 <strong>任务栏</strong>，可以显示 <strong>常用软件图标</strong> 和 <strong>正在运行的软件图标</strong></li>
<li>通常 Linux 的用户使用 <strong>终端命令</strong> 的频率非常高，所以会把 <strong>终端</strong> 添加到 <strong>启动栏</strong></li>
<li>通过最上方的 <strong>搜索</strong> 按钮可以 <strong>搜索并启动</strong> 需要使用的程序</li>
<li><strong>点击右键</strong> 可以 <strong>保留</strong>、<strong>删除</strong> 或者 <strong>移动</strong> 启动栏中图标</li>
<li>可以把最常用的软件图标，<strong>保留</strong> 在启动栏，可以方便快速启动程序</li>
</ul>
<h3 id="3-3-apt-终端命令"><a href="#3-3-apt-终端命令" class="headerlink" title="3.3 apt 终端命令"></a>3.3 apt 终端命令</h3><ul>
<li><code>apt</code> 是 <code>Advanced Packaging Tool</code>，是 Ubuntu 下的 <strong>安装包管理工具</strong></li>
<li><strong>大部分</strong> 的软件 <strong>安装/更新/卸载</strong> 都是利用 <code>apt</code> 命令来实现的</li>
<li>直接在终端中输入 <code>apt</code> 即可以查阅命令的帮助信息</li>
<li>常用命令如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 安装软件</span></span><br><span class="line">$ sudo apt install 软件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 卸载软件</span></span><br><span class="line">$ sudo apt remove 软件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 更新可用软件包列表</span></span><br><span class="line">$ sudo apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 更新已安装的包</span></span><br><span class="line">$ sudo apt upgrade</span><br></pre></td></tr></table></figure>

<h4 id="1-软件更新和升级"><a href="#1-软件更新和升级" class="headerlink" title="1) 软件更新和升级"></a>1) 软件更新和升级</h4><ul>
<li>通常安装完 ubuntu 之后，可以先使用 <code>upgrade</code> 更新一下当前系统中可以升级的的软件包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line"></span><br><span class="line">$ sudo apt upgrade</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>提示</strong> 如果增加、更换了软件源，通常需要使用 <code>update</code> 更新一下本地缓存</li>
</ul>
<h4 id="2-安装常用工具"><a href="#2-安装常用工具" class="headerlink" title="2) 安装常用工具"></a>2) 安装常用工具</h4><p><strong>提示</strong> apt 安装命令的格式是不需要记忆的，如果在终端中输入的软件没有安装，系统会提示 <strong>apt 命令</strong> 的使用格式</p>
<h5 id="python-程序员"><a href="#python-程序员" class="headerlink" title="python 程序员"></a>python 程序员</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install ipython</span><br><span class="line">$ sudo apt install ipython3</span><br><span class="line">$ sudo apt install python-pip</span><br><span class="line">$ sudo apt install python3-pip</span><br></pre></td></tr></table></figure>

<h5 id="C-程序员"><a href="#C-程序员" class="headerlink" title="C++ 程序员"></a>C++ 程序员</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install cmake</span><br><span class="line">$ sudo apt install qtcreator</span><br></pre></td></tr></table></figure>

<h5 id="ruby-程序员"><a href="#ruby-程序员" class="headerlink" title="ruby 程序员"></a>ruby 程序员</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install ruby</span><br></pre></td></tr></table></figure>

<h5 id="安装-ssh-服务器"><a href="#安装-ssh-服务器" class="headerlink" title="安装 ssh 服务器"></a>安装 ssh 服务器</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openssh-server</span><br></pre></td></tr></table></figure>

<p>安装之后，才可以在其他系统中，通过 ssh 工具远程登陆</p>
<h4 id="3-删除不使用的软件"><a href="#3-删除不使用的软件" class="headerlink" title="3) 删除不使用的软件"></a>3) 删除不使用的软件</h4><p><strong>libreoffice</strong></p>
<ul>
<li><code>libreoffice</code> 是一套类似于 <code>微软 Office</code> 的 <strong>免费的</strong> 办公套件</li>
<li>不过无论是界面交互还是执行性能都还有很大的提升空间</li>
<li>卸载 libreoffice 可以释放大概 <strong>300M</strong> 的磁盘空间</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt remove libreoffice-common</span><br></pre></td></tr></table></figure>

<p><strong>Amazon</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt remove unity-webapps-common</span><br></pre></td></tr></table></figure>

<h4 id="4-扩展：apt-和-apt-get"><a href="#4-扩展：apt-和-apt-get" class="headerlink" title="4) 扩展：apt 和 apt-get"></a>4) 扩展：<code>apt</code> 和 <code>apt-get</code></h4><ul>
<li><code>apt</code> 和 <code>apt-get</code> 都是 ubuntu 下常用的安装软件的命令</li>
<li><strong>早期</strong> 使用 <code>apt-get</code>，从 ununtu 16 开始，官方建议使用 <code>apt</code></li>
<li>这两个命令的 <strong>使用方式非常类似</strong></li>
</ul>
<h3 id="3-4-deb-安装格式"><a href="#3-4-deb-安装格式" class="headerlink" title="3.4 deb 安装格式"></a>3.4 deb 安装格式</h3><p><strong>deb</strong> 是 Debian Linux 的安装格式，在 ubuntu 中同样可以使用。要安装 deb 安装包，需要使用 <code>dpkg</code> 这个终端命令，命令格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dpkg -i &lt;package.deb&gt;</span><br></pre></td></tr></table></figure>

<h4 id="1-谷歌浏览器"><a href="#1-谷歌浏览器" class="headerlink" title="1) 谷歌浏览器"></a>1) 谷歌浏览器</h4><ol>
<li>从 <a href="https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb" target="_blank" rel="noopener">https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</a> 下载最新版本的安装文件</li>
<li>在终端中执行以下命令：</li>
</ol>
<!--sudo apt-get install libappindicator1 libindicator7 -->

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install libappindicator1 libindicator7</span><br><span class="line">$ sudo dpkg -i google-chrome-stable_current_amd64.deb   </span><br><span class="line">$ sudo apt -f install</span><br></pre></td></tr></table></figure>

<h4 id="2-搜狗输入法"><a href="#2-搜狗输入法" class="headerlink" title="2) 搜狗输入法"></a>2) 搜狗输入法</h4><p><strong>fcitx</strong> 被称为 <strong>小企鹅输入法</strong>，是一个以 GPL 方式发布的 <strong>输入法平台</strong>，可以通过安装引擎支持多种输入法。它的优点是，短小精悍、跟程序的兼容性比较好！</p>
<ol>
<li>打开 <strong>系统设置</strong> <strong>语言支持</strong><ul>
<li>将 <strong>键盘输入法系统</strong> 修改为 <strong>fcitx</strong></li>
</ul>
</li>
<li>访问网站 <a href="http://pinyin.sogou.com/linux/" target="_blank" rel="noopener">http://pinyin.sogou.com/linux/</a> 下载最新版本的安装文件</li>
<li>在终端中执行以下命令：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ sudo dpkg -i sogoupinyin_2.1.0.0086_amd64.deb</span><br><span class="line">$ sudo apt -f install</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示，安装输入法之后，需要重新启动系统</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/C++%E6%98%93%E9%94%99%E9%A2%981/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/C++%E6%98%93%E9%94%99%E9%A2%981/" class="post-title-link" itemprop="url">C++易错题1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:46:12" itemprop="dateCreated datePublished" datetime="2020-12-22T19:46:12+08:00">2020-12-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84ifndef%E3%80%81define%E3%80%81endif%E7%9A%84%E4%BD%9C%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84ifndef%E3%80%81define%E3%80%81endif%E7%9A%84%E4%BD%9C%E7%94%A8/" class="post-title-link" itemprop="url">头文件中的ifndef、define、endif的作用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-22 19:41:35 / 修改时间：19:43:44" itemprop="dateCreated datePublished" datetime="2020-12-22T19:41:35+08:00">2020-12-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在一个大的软件工程里面，可能会有多个文件同时包含一个头文件，当这些文件编译链接成一个可执行文件时，就会出现大量重定义的错误。<strong>在头文件中实用#ifndef #define #endif能避免头文件的重定义。</strong><br>方法：例如要编写头文件test.h<br>在头文件开头写上两行：<br>#ifndef <em>TEST_H<br>#define _TEST_H//一般是文件名的大写<br>头文件结尾写上一行：#endif</em></p>
<p>_这样一个工程文件里同时包含两个test.h时，就不会出现重定义的错误了。<br>分析：当第一次包含test.h时，由于没有定义_TEST_H，条件为真，这样就会包含（执行）#ifndef _TEST_H和#endif之间的代码，当第二次包含test.h时前面一次已经定义了_TEST_H，条件为假，#ifndef _TEST_H和#endif之间的代码也就不会再次被包含，这样就避免了重定义了。主要用于防止重复定义宏和重复包含头文件</p>
<blockquote>
<p>ifndef/define/endif 的含义：如果未定义 / 那么定义 / 完成假设</p>
<p>一般是用来防止头文件被重复包含，提高编译效率的。]</p>
</blockquote>
<blockquote>
<p>这是C++预编译头文件保护符，保证即使文件被多次包含，头文件也只定义一次。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day01%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day01%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">day01笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:14" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:14+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-11 09:22:43" itemprop="dateModified" datetime="2019-01-11T09:22:43+08:00">2019-01-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、Java开发环境搭建<br>2、HelloWorld案例<br>3、注释、关键字、标识符<br>4、数据（数据类型、常量）</p>
<p>###01java语言概述<br>    * A: java语言概述<br>        * a: Java是sun公司开发的一门编程语言,目前被Oracle公司收购，编程语言就是用来编写软件的。<br>        * b: Java的应用<br>            * 开发QQ、迅雷程序(桌面应用软件)<br>            * 淘宝、京东(互联网应用软件)<br>        * c: Java的擅长<br>            * 互联网：电商、P2P等等<br>            * 企业级应用：ERP、CRM、BOS、OA等等<br>        * d: Java语言平台<br>            * JavaSE（标准版）部分,基础班学习JavaSE,JavaSE并不能开发大型项目。<br>            * JavaEE（企业版）部分,就业班学习JavaEE,学习完JavaEE部分就可以开发各种大型项目了。</p>
<p>###02常用的DOS命令<br>    * A: 常用的DOS命令<br>        * a: 打开Dos控制台<br>            * win+r–cmd–回车<br>        * b: 常用dos命令<br>            * cd.. : 退回到上一级目录<br>            * cd\  : 退回到根目录<br>            * cd tools: 进入tools文件夹<br>            * d:   : 回车    盘符切换<br>            * cd d:\234 :进入d盘的234文件夹,再切换盘符(d:)才能进入d:\234<br>            * dir  : 列出当前目录下的文件以及文件夹<br>            * cls  : 清除屏幕<br>            * ipconfig: 查看本机的相关网络配置<br>        * c: dos控制台运行记事本程序<br>            * D:&gt;C:\windows\notepad.exe<br>            * 还可以省略“.exe”后缀，例如：D:&gt;C:\windows\notepad</p>
<p>###03java语言开发环境JDK<br>    * A: java语言开发环境JDK<br>        * a: JDK是Java开发环境<br>        * b: 课程中使用的JDK版本是JDK7，当前最新版本是JDK8</p>
<p>###04JDK的下载和安装<br>    * A: JDK的下载<br>        * a: 官网 <a href="http://www.oracle.com/cn/index.html" target="_blank" rel="noopener">http://www.oracle.com/cn/index.html</a><br>        * b: 演示下载流程<br>    * B: JDK的安装<br>        * a: 傻瓜式安装<br>            * 双击安装程序，然后一路next即可(但是不建议)<br>        * b: 安装的推荐方式<br>            * 安装路径不要有中文或者特殊符号如空格等。<br>            * 所有和开发相关的软件最好安装目录统一。<br>                * 举例：我的JDK安装路径<br>                    * D:\develop\Java\jdk1.7.0_72<br>            * 当提示安装JRE时，可以选择不安装。建议还是安装上。<br>                    * D:\develop\Java\jre<br>            * 安装路径中没有的文件夹,会自动创建</p>
<pre><code>* C: 验证安装是否成功
    * a:通过DOS命令，切换到JDK安装的bin目录下。
        * D:\develop\Java\jdk1.7.0_72\bin
    * b:然后分别输入javac和java，如果正常显示一些内容，说明安装成功</code></pre><p>###05JDK和JRE跨平台<br>    * A: JDK与JRE的关系<br>        * a: JDK：它是Java开发运行环境，在程序员的电脑上当然要安装JDK；<br>        * b: JRE：Java Runtime Environment它是Java运行环境，如果你不需要开发只需要运行Java程序，那么你可以安装JRE。例如程序员开发出的程序最终卖给了用户，用户不用开发，只需要运行程序，所以用户在电脑上安装JRE即可。<br>        * c: JDK包含了JRE。<br>    * B: 跨平台特性<br>        * a: 平台指的是操作系统 （Windows，Linux，Mac）。<br>        * b: Java程序可以在任意操作系统上运行，一次编写到处运行<br>        * c: 实现跨平台需要依赖Java的虚拟机 JVM （Java Virtual Machine）</p>
<p>###06编写HelloWorld程序<br>    * A: 编写步骤(初学者)<br>        * a: 创建一个普通文本文件，将其修改为.java文件。<br>        * b: 完成模板代码：<br>            public class HelloWorld{<br>                public static void main(String[] args) {<br>                        System.out.println(“Hello World!”);<br>                }<br>            }<br>    * B: 实际开发步骤<br>        * a: 定义类<br>        * b: 写main方法<br>        * c: 写输出语句(注意：下面的代码是原代码，是不能运行的)<br>            public class HelloWorld {<br>                public static void main(String[] args) {<br>                    System.out.println(“HelloWorld”);<br>                }<br>            }<br>        * d：注意：<br>            * 不要隐藏文件的扩展名<br>            * 类名和文件名要保持一致<br>    * C: Java代码的编写执行过程<br>        * a: 源文件：编写Java源文件（我们也称之为源代码文件），它的扩展名为.java；<br>        * b: 编译：然后通过编译器把源文件编译成字节码文件，字节码文件扩展名为.class；<br>        * c: 运行：最后使用解释器来运行字节码文件。</p>
<p>###07编译Java程序<br>    * A：程序编译<br>        * 作用：将程序员写的java源代码生成可以运行的Java程序(.class文件)<br>        * 过程：<br>            * a:开启DOS窗口并切换到.java文件所在的目录 比如HelloWord.java存放于d:\234\day01\code 中<br>            * b:切换到HelloWorld.java所在目录,但是此目录中没有javac命令,所以在编译时要写出javac命令的全路径<br>            * c: d:\234\day01\code&gt;d:\develop\java\jdk1.7.0_72\bin\javac HelloWorld.java 回车<br>            * d:在d:\234\day01\code文件夹中多了个HelloWorld.class文件(又叫做字节码文件)</p>
<p>###08运行Java程序<br>    * A：运行程序<br>        * a: 开启DOS窗口并切换到.class文件所在的目录<br>        * b: 此目录中没有java命令,所以在运行时也要写出java命令的全路径<br>        * c: d:\234\day01\code&gt;d:\develop\java\jdk1.7.0_72\bin\java HelloWorld 回车(注意:运行时不用后缀名.class)<br>        * d: 控制台打印显示结果”HelloWorld”</p>
<p>###09环境变量的配置<br>    * A: Path环境变量配置方式一<br>        * a: 安装高级文本编辑器notepad++<br>        * b: 配置Windows的path环境变量<br>            * 环境变量的作用：让Java的bin目录下的javac命令可以在任意目录下执行<br>            * 配置方法：<br>                * 右键点击计算机  →  选择属性  →  更改设置  →  点击高级  →  点击环境变量  →  找到系统变量中的path  →  将java安装目录下javac所在的bin目录路径配置到path变量中，用；(英文)与其他变量分隔<br>            * 注意：<br>                * 配置path后文件的访问顺序：先访问当前路径，如果当前路径没有该文件，则再访问path配置的路径<br>    * B:配置过程(建议使用这种方式配置)<br>        * a：右键点击计算机  →  选择属性  →  更改设置  →  点击高级  →  点击环境变量  →  创建名为JAVA_HOME的环境变量  →  将jdk所在的目录路径(bin所在的路径)配置到JAVA_HOME变量中<br>        * b: 用;与其他变量分隔  →  在path环境变量中添加%JAVA_HOME%\bin</p>
<p>###10notepad软件安装<br>    * A: 安装<br>        * 双击.exe文件安装 即可</p>
<p>###11注释<br>    * A: 注释<br>        * a: 定义：用来解释和说明程序的文字，注释是不会被执行的<br>        * b: 分类：<br>            * 1：单行注释    //注释内容<br>            * 2：多行注释    /<em>注释内容</em>/<br>            * 3：文档注释    /<em>*注释内容</em>/<br>        * c: 注意：<br>            * 1：对于单行和多行注释，被注释的文字，不会被JVM解释执行<br>            * 2：对于文档注释，可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档<br>            * 3：单行注释可以嵌套使用，多行注释不能嵌套使用<br>        * d: 案例代码<br>            /*<br>                 实现了一个Java的HelloWorld程序<br>                 实现步骤：<br>                   1. 定义类<br>                   2. 定义主方法<br>                   3. 一条命令，控制台输出了HelloWorld<br>            */<br>            public class HelloWorld{<br>                //main主方法，固定格式，程序的入口点<br>                public static void main(String[] args){<br>                    //系统 输出 打印    打印的内容<br>                    System.out.println(“HelloWorld”);<br>                }<br>            }<br>###12关键字<br>    * A: 关键字<br>        * a: 定义<br>            * 是被Java语言赋予特殊含义，具有专门用途的单词，比如之前接触的class，int，double均为Java已经预设好的<br>        * b: 特点<br>            * 组成关键字的字母全部小写(代码中的蓝色部分) ,注意String不是关键字<br>        * c: 常见关键字<br>            * public static void class等<br>        * d: 注意事项<br>            * goto与const是Java中的保留字，即没有赋予特殊含义却仍被Java占用的单词,类似Editplus这样的高级记事本,针对关键字有特殊的颜色标记，非常直观 </p>
<p>###13标识符<br>    * A: 标识符<br>        * a: 定义<br>            * 就是给类,接口,方法,变量等起名字时使用的字符序列<br>        * b: 组成规则(只能包含下面的内容,不能有其它内容)<br>            * 1: 英文大小写字母<br>            * 2：数字字符<br>            * 3：$和_<br>        * c: 注意事项<br>            * 1：数字不能开头<br>            * 2：不可以使用关键字<br>            * 3：严格区分大小写，不限制长度<br>            * 4：起名时，尽量达到见名知意<br>    * B：标识符中常见的命名规则(这些规定是不受语法约束的)<br>        * a: 包名：多单词组成时所有字母均小写，使用.连接  aaa.bbb.ccc<br>        * b: 类名&amp;接口名：大驼峰式   AaaBbbCcc<br>        * c: 变量名&amp;方法名：小驼峰式   aaaBbbCcc<br>        * d: 常量名：多单词组成是所有字母均大写，使用_连接AAA_BBB_CCC<br>    * C: 案例代码<br>        /*<br>           标识符<br>           Java中，自己定义的内容<br>           自定义类的名字，上一个案例 HelloWorld<br>           标识符的规则：<br>             组成： 字母52个A-Z a-z 数字0-9 _ 下划线 $ 美元符</p>
<pre><code>     注意： 不能数字开头，不能是关键字

     定义名字：
        _abc  0a  a0  a#a  a$a   void
         YES  NO  YES NO   YES   NO

     类的名字： 首字母大写，第二个单词首字母大写
      BeiJingShiHaiDianQuYiYuan
      MeiGuoJiaLiFuNiYa

     方法的名字：首字母小写，每个单词首字母大写
       addStudent  
*/
public class Demo{

}</code></pre><p>###14Java中的数据类型<br>    * A:为什么有数据类型<br>        * Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型<br>    * B:Java中数据类型的分类<br>        * 基本数据类型: 基本数据类型是Java语言中内置的类型，分别是整数类型、小数类型、字符类型、布尔类型。<br>            这四类基本类型是最简单、最基础的类型。<br>            * 整数(byte、short、int、long)、小数(float、double)、字符类型(char)、布尔类型(boolean)<br>        * 引用数据类型: 是强大的数据类型，它是基于基本数据类型创建的。JavaSE中提供了一个超级类库，类库中包含了近万种引用数据类型。<br>            不过现在我们先要学习的是基本类型！<br>            * 数组、类、接口</p>
<p>###15Java中的常量<br>    * A: 常量的定义<br>        * 常量就是不变的数据量, 在程序执行的过程中其值不可以发生改变<br>    * B: 常量分类<br>        * a: 整数类型<br>            * 十进制表示方式：正常数字   如 13、25等<br>            * 二进制表示方式：以0b(0B)开头    如0b1011 、0B1001<br>            * 十六进制表示方式：以0x(0X)开头   数字以0-9及A-F组成  如0x23A2、0xa、0x10<br>            * 八进制表示方式：以0开头   如01、07、0721<br>        * b: 小数类型<br>            * 如1.0、-3.15、3.168等<br>        * c: 布尔类型<br>            * true、false<br>        * d: 字符类型<br>            * 如’a’，’A’, ‘0’, ‘家’<br>            * 字符必须使用’’ 包裹，并且其中只能且仅能包含一个字符。<br>        * e: 字符串类型<br>            * 字符串String类型是一种引用类型，我们先了解作为常量类型的使用方式<br>            * 如“我爱Java”，“0123”，“”，“null”<br>            * 字符串必须使用“”包裹，其中可以包含0~N个字符。</p>
<p>###16程序中输出Java中的常量<br>    * A: 案例代码<br>        /*<br>           Demo_1类，演示Java中的所有类型的常量<br>           程序当中输出：<br>             输出整数常量<br>             小数常量<br>             布尔常量<br>             字符常量<br>             字符串常量<br>        */<br>        public class Demo_1{<br>            public static void main(String[] args){<br>                //输出整数 十进制<br>                System.out.println(50);</p>
<pre><code>        //输出整数，二进制, 数字开头0B
        System.out.println(0B11);

        //输出整数，八进制，数字开头0
        System.out.println(051);

        //输出整数，十六进制，数组开头0X  0-9 A-F
        System.out.println(0XE);

        //输出浮点数据
        System.out.println(5.0);

        //输出布尔数据，只有2个值，true，false 关键字
        System.out.println(true);
        System.out.println(false);

        //输出字符常量，单引号包裹，只能写1个字符
        System.out.println(&apos;a&apos;);

        //输出字符串常量，双引号包裹，可以写0-n个字符
        System.out.println(&quot;HelloWorld&quot;);
    }
}</code></pre><p>###17总结</p>
<ul>
<li>把今天的知识点总结一遍。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/day33%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KJH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/day33%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">day33笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 19:21:14" itemprop="dateCreated datePublished" datetime="2020-12-22T19:21:14+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-11 09:22:54" itemprop="dateModified" datetime="2019-01-11T09:22:54+08:00">2019-01-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日内容介绍<br>1、类加载器<br>2、反射构造方法<br>3、反射成员变量<br>4、反射成员方法<br>5、反射配置文件运行类中的方法</p>
<p>第一节课 类加载器<br>###01类的加载.avi(11:08)<br>###02类的加载时机.avi(06:19)<br>###03三种类的加载器.avi(05:14)</p>
<p>第二节课 反射<br>###01反射的概念以及作用.avi(09:23)<br>###02class文件的产生过程.avi(05:27)</p>
<p>###03获取class文件对象三种方式.avi(11:57)<br>###04反射获取空参数构造方法并运行.avi(15:55)<br>###05反射获取有参数的构造方法并运行.avi(06:27)<br>###06反射获取构造方法并运行的快速的方式.avi(06:14)</p>
<p>###07反射获取私有构造方法并运行.avi(09:41)<br>###08反射获取成员变量并改值.avi(09:22)<br>###09反射获取空参数成员方法并运行.avi(11:23)<br>###10反射获取有参数的成员方法并运行.avi(03:43)</p>
<p>###11反射泛型擦除.avi(10:29)<br>###12反射通过配置文件运行的步骤.avi(07:05)<br>###13反射通过配置文件运行功能实现.avi(09:12)</p>
<p>============上面的内容,方便我们只做ppt,word教案以及书写下面的简要的笔记=================</p>
<p>###01类加载器<br>    * A.类的加载<br>        当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。<br>        * a 加载<br>            * 就是指将class文件读入内存，并为之创建一个Class对象。<br>            * 任何类被使用时系统都会建立一个Class对象<br>        * b 连接<br>            * 验证 是否有正确的内部结构，并和其他类协调一致<br>            * 准备 负责为类的静态成员分配内存，并设置默认初始化值<br>            * 解析 将类的二进制数据中的符号引用替换为直接引用<br>        * c 初始化<br>            * 就是我们以前讲过的初始化步骤（new 对象）<br>        * 注：简单的说就是：把.class文件加载到内存里，并把这个.class文件封装成一个Class类型的对象。<br>    * B.类的加载时机<br>        以下的情况，会加载这个类。<br>        * a. 创建类的实例<br>        * b. 类的静态变量，或者为静态变量赋值<br>        * c. 类的静态方法<br>        * d. 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象<br>        * e. 初始化某个类的子类<br>        * f. 直接使用java.exe命令来运行某个主类</p>
<pre><code>* C: 类加载器(了解)
    负责将.class文件加载到内在中，并为之生成对应的Class对象。
    * a. Bootstrap ClassLoader 根类加载器
        * 也被称为引导类加载器，负责Java核心类的加载
        * 比如System,String等。在JDK中JRE的lib目录下rt.jar文件中</code></pre><p>        * b. Extension ClassLoader 扩展类加载器<br>            * 负责JRE的扩展目录中jar包的加载。<br>            * 在JDK中JRE的lib目录下ext目录<br>        * c. System ClassLoader 系统类加载器<br>            * 负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径。<br>            * 我们用的是System ClassLoader 系统类加载器</p>
<p>###02反射<br>    * A. 反射定义<br>        * a. JAVA反射机制是在运行状态中，<br>                对于任意一个类，都能够知道这个类的所有属性和方法；<br>                对于任意一个对象，都能够调用它的任意一个方法和属性；<br>            这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<pre><code>    * b.反射技术
        条件：运行状态
        已知：一个类或一个对象(根本是已知.class文件)
        结果：得到这个类或对象的所有方法和属性

    * 注: 要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象。
* B. Class类
    * a. Class类及Class对象的了解
        要想解剖一个类，必须先了解Class对象。
        阅读API的Class类得知，Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的。
    * b. 得到Class对象
        * 1. 有三个方法
            方式一: 通过Object类中的getClass()方法
                Person person = new Person();
                Class clazz = person.getClass();
            方式二: 通过 类名.class 获取到字节码文件对象（任意数据类型都具备一个class静态属性,看上去要比第一种方式简单）。
                Class clazz = Person.class;
            方式三: 通过Class类中的方法（将类名作为字符串传递给Class类中的静态方法forName即可）。
                Class c3 = Class.forName(&quot;Person&quot;);
            注：第三种和前两种的区别是：
                    前两种你必须明确Person类型.
                    后面是指定这种类型的字符串就行.这种扩展更强.我不需要知道你的类.我只提供字符串,按照配置文件加载就可以了

        * 2. 得到Class对象的三个方法代码演示：
            代码演示
            /*
             * 获取.class字节码文件对象的方式
             *         1：通过Object类中的getObject()方法
             *         2: 通过 类名.class 获取到字节码文件对象
             *         3: 反射中的方法,
             *             public static Class&lt;?&gt; forName(String className) throws ClassNotFoundException
             *             返回与带有给定字符串名的类或接口相关联的 Class 对象 
             */
            public class ReflectDemo {
                public static void main(String[] args) throws ClassNotFoundException {
                    // 1： 通过Object类中的getObject()方法
                    // Person p1 = new Person();
                    // Class c1 = p1.getClass();
                    // System.out.println(&quot;c1 = &quot;+ c1);

                    // 2: 通过 类名.class 获取到字节码文件对象
                    // Class c2 = Person.class;
                    // System.out.println(&quot;c2 = &quot;+ c2);

                    // 3: 反射中的方法
                    Class c3 = Class.forName(&quot;cn.itcast_01_Reflect.Person&quot;);// 包名.类名
                    System.out.println(&quot;c3 = &quot; + c3);
                }
            }</code></pre><p>                Person类<br>                package cn.itcast_01_Reflect;<br>                public class Person {<br>                    //成员变量<br>                    public String name;<br>                    public int age;<br>                    private String address;</p>
<pre><code>                //构造方法
                public Person() {
                    System.out.println(&quot;空参数构造方法&quot;);
                }

                public Person(String name) {
                    this.name = name;
                    System.out.println(&quot;带有String的构造方法&quot;);
                }
                //私有的构造方法
                private Person(String name, int age){
                    this.name = name;
                    this.age = age;
                    System.out.println(&quot;带有String，int的构造方法&quot;);
                }

                public Person(String name, int age, String address){
                    this.name = name;
                    this.age = age;
                    this.address = address;
                    System.out.println(&quot;带有String, int, String的构造方法&quot;);
                }

                //成员方法
                //没有返回值没有参数的方法
                public void method1(){
                    System.out.println(&quot;没有返回值没有参数的方法&quot;);
                }
                //没有返回值，有参数的方法
                public void method2(String name){
                    System.out.println(&quot;没有返回值，有参数的方法 name= &quot;+ name);
                }
                //有返回值，没有参数
                public int method3(){
                    System.out.println(&quot;有返回值，没有参数的方法&quot;);
                    return 123;
                }
                //有返回值，有参数的方法
                public String method4(String name){
                    System.out.println(&quot;有返回值，有参数的方法&quot;);
                    return &quot;哈哈&quot; + name;
                }
                //私有方法
                private void method5(){
                    System.out.println(&quot;私有方法&quot;);
                }

                @Override
                public String toString() {
                    return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;, address=&quot; + address+ &quot;]&quot;;
                }
            }
        * 注: Class类型的唯一性
            因为一个.class文件在内存里只生成一个Class对象，所以无论那一种方法得到Class对象，得到的都是同一个对象。
* C.通过反射获取无参构造方法并使用
    * a. 得到无参构造方法
        public Constructor&lt;?&gt;[] getConstructors() 
            获取所有的public 修饰的构造方法。
            选择无参构造方法，不建议使用。
        public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) 
            获取public修饰, 指定参数类型所对应的构造方法。
            不传参数得到无参构造方法。
    * b. 运行无参构造方法
        public T newInstance(Object... initargs) 
            使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。 
            因为是无参构造，所以不传参数。
    * c. 通过反射获取无参构造方法并使用的代码演示：
            package cn.itcast.demo1;

            import java.lang.reflect.Constructor;

            /*
             *  通过反射获取class文件中的构造方法,运行构造方法
             *  运行构造方法,创建对象
             *    获取class文件对象
             *    从class文件对象中,获取需要的成员
             *    
             *  Constructor 描述构造方法对象类
             */
            public class ReflectDemo1 {
                public static void main(String[] args) throws Exception {

                    Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);
                    //使用class文件对象,获取类中的构造方法
                    //  Constructor[]  getConstructors() 获取class文件对象中的所有公共的构造方法
                    /*Constructor[] cons = c.getConstructors();
                    for(Constructor con : cons){
                        System.out.println(con);
                    }*/
                    //获取指定的构造方法,空参数的构造方法
                    Constructor con =  c.getConstructor();
                    //运行空参数构造方法,Constructor类方法 newInstance()运行获取到的构造方法
                    Object obj = con.newInstance();
                    System.out.println(obj.toString());
                }
            }
* D. 通过反射获取有参构造方法并使用
    * a. 得到有参的构造方法
        public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) 
            获取public修饰, 指定参数类型所对应的构造方法。
            传相应的参数类型得到有参构造方法。
    * b. 运行无参构造方法
        public T newInstance(Object... initargs) 
            使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。 
            因为是有参构造，所以传相应的参数值。
    * c. 通过反射获取有参构造方法并使用的代码演示：
        package cn.itcast.demo1;

        import java.lang.reflect.Constructor;

        /*
         *  通过反射,获取有参数的构造方法并运行
         *  方法getConstructor,传递可以构造方法相对应的参数列表即可
         */
        public class ReflectDemo2 {
            public static void main(String[] args)throws Exception {
                Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);
                //获取带有,String和int参数的构造方法
                //Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)  
                //Class&lt;?&gt;... parameterTypes 传递要获取的构造方法的参数列表
                Constructor con = c.getConstructor(String.class,int.class);
                //运行构造方法
                // T newInstance(Object... initargs)  
                //Object... initargs 运行构造方法后,传递的实际参数
                Object obj = con.newInstance(&quot;张三&quot;,20);
                System.out.println(obj);
            }
        }
* E. 通过反射获取有参构造方法并使用快捷方式
    * a. 使用的前提
        类有空参的公共构造方法。（如果是同包，默认权限也可以）
    * b. 使用的基础
        Class类的 public T newInstance() 方法
             创建此 Class 对象所表示的类的一个新实例。
    * c. 通过反射获取有参构造方法并使用快捷方式的代码演示：
        package cn.itcast.demo1;
        /*
         * 反射获取构造方法并运行,有快捷点的方式
         * 有前提:
         *   被反射的类,必须具有空参数构造方法
         *   构造方法权限必须public
         */
        public class ReflectDemo3 {
            public static void main(String[] args) throws Exception {
                Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);
                // Class类中定义方法, T newInstance() 直接创建被反射类的对象实例
                Object obj = c.newInstance();
                System.out.println(obj);
            }
        }
* F. 通过反射获取私有构造方法并使用
    * a. 得到私有的构造方法
        public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) 
            获取指定参数类型所对应的构造方法(包含私有的)。
        public Constructor&lt;?&gt;[] getDeclaredConstructors() 
            获取所有的构造方法(包含私有的)。
    * b. 运行私有构造方法
        public void setAccessible(boolean flag)
            将此对象的 accessible 标志设置为指示的布尔值。
            设置为true,这个方法保证我们得到的私有构造方法的运行。（取消运行时期的权限检查。）
        public T newInstance(Object... initargs) 
            使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。 
    * c. 通过反射获取私有构造方法并使用的代码演示：
        package cn.itcast.demo1;

        import java.lang.reflect.Constructor;

        /*
         *  反射获取私有的构造方法运行
         *  不推荐,破坏了程序的封装性,安全性
         *  暴力反射
         */
        public class ReflectDemo4 {
            public static void main(String[] args) throws Exception{
                Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);
                //Constructor[] getDeclaredConstructors()获取所有的构造方法,包括私有的
                /*Constructor[] cons = c.getDeclaredConstructors();
                for(Constructor con : cons){
                    System.out.println(con);
                }*/
                //Constructor getDeclaredConstructor(Class...c)获取到指定参数列表的构造方法
                Constructor con = c.getDeclaredConstructor(int.class,String.class);

                //Constructor类,父类AccessibleObject,定义方法setAccessible(boolean b)
                con.setAccessible(true);

                Object obj = con.newInstance(18,&quot;lisi&quot;);
                System.out.println(obj);
            }
        }
    * 注：不推荐，破坏了程序的封装性,安全性。
* G. 反射获取成员变量并改值
    * a. 获取成员变量
        * 得到公共的成员变量
            public Field getField(String name) 
                返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定公共成员字段。 
            public Field[] getFields() 
                返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问公共字段。 
        * 得到所有的成员变量(包括私有的，如果要进行修改私有成员变量，要先进行public void setAccessible(boolean flag) 设置。)
            public Field getDeclaredField(String name) 
                返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段。 
            public Field[] getDeclaredFields() 
                返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段。 
    * b. 修改成员变量(Field)的值
        * 修改公共的成员变量
            public void set(Object obj, Object value) 
                将指定对象变量上此 Field 对象表示的字段设置为指定的新值。 
                obj指的是修改的是那个对象的这个成员变量值。
    * c. 反射获取成员变量并改值的代码演示
        package cn.itcast.demo1;
        import java.lang.reflect.Field;
        /*
         *  反射获取成员变量,并修改值
         *  Person类中的成员String name
         */
        public class ReflectDemo5 {
            public static void main(String[] args) throws Exception{
                Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);
                Object obj = c.newInstance();
                //获取成员变量 Class类的方法 getFields() class文件中的所有公共的成员变量
                //返回值是Field[]    Field类描述成员变量对象的类
                /*Field[] fields = c.getFields();
                for(Field f : fields){
                    System.out.println(f);
                }*/

                //获取指定的成员变量 String name
                //Class类的方法  Field getField(传递字符串类型的变量名) 获取指定的成员变量
                Field field = c.getField(&quot;name&quot;);

                //Field类的方法 void set(Object obj, Object value) ,修改成员变量的值
                //Object obj 必须有对象的支持,  Object value 修改后的值
                field.set(obj,&quot;王五&quot;);
                System.out.println(obj);

            }
        }
* H. 反射获取空参数成员方法并运行
    * a. 获取空参数成员方法
        * 得到公共的成员方法
            public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 
                返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。 
            public Method[] getMethods()
                返回一个包含某些 Method 对象的数组，这些对象反映此 Class对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。
        * 得到全部的成员方法(包括私有的，如果要使用私有成员方法，要先进行public void setAccessible(boolean flag) 设置。)
            public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) 
                返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。 
            public Method[] getDeclaredMethods() 
                返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 
    * b. 使用Method方法对象
        public Object invoke(Object obj, Object... args) 
            对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。 
            obj 指的是调这个方法的对象。
            args 指的是调用这个方法所要用到的参数列表。
            返回值Object就是方法的返回对象。如果方法没有返回值 ，返回的是null.
    * c. 反射获取空参数成员方法并运行代码演示
        package cn.itcast.demo1;

        import java.lang.reflect.Method;

        /*
         *  反射获取成员方法并运行
         *  public void eat(){}
         */
        public class ReflectDemo6 {
            public static void main(String[] args) throws Exception{
                Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);
                Object obj = c.newInstance();
                //获取class对象中的成员方法
                // Method[] getMethods()获取的是class文件中的所有公共成员方法,包括继承的
                // Method类是描述成员方法的对象
                /*Method[] methods = c.getMethods();
                for(Method m : methods){
                    System.out.println(m);
                }*/

                //获取指定的方法eat运行
                // Method getMethod(String methodName,Class...c)
                // methodName获取的方法名  c 方法的参数列表
                Method method = c.getMethod(&quot;eat&quot;);
                //使用Method类中的方法,运行获取到的方法eat
                //Object invoke(Object obj, Object...o)
                method.invoke(obj);
            }
        }

* I. 反射获取有参数成员方法并运行
    * a. 获取有参数成员方法
        * 得到公共的成员方法
            public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 
                返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。 
            public Method[] getMethods()
                返回一个包含某些 Method 对象的数组，这些对象反映此 Class对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。
        * 得到全部的成员方法(包括私有的，如果要使用私有成员方法，要先进行public void setAccessible(boolean flag) 设置。)
            public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) 
                返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。 
            public Method[] getDeclaredMethods() 
                返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 
    * b. 使用Method方法对象
        public Object invoke(Object obj, Object... args) 
            对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。 
            obj 指的是调这个方法的对象。
            args 指的是调用这个方法所要用到的参数列表。
            返回值Object就是方法的返回对象。如果方法没有返回值 ，返回的是null.
    * c. 反射获取有参数成员方法并运行代码演示
        package cn.itcast.demo1;
        import java.lang.reflect.Method;

        /*
         *  反射获取有参数的成员方法并执行
         *  public void sleep(String,int,double){}
         */
        public class ReflectDemo7 {
            public static void main(String[] args) throws Exception{
                Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);
                Object obj = c.newInstance();
                //调用Class类的方法getMethod获取指定的方法sleep
                Method method = c.getMethod(&quot;sleep&quot;, String.class,int.class,double.class);
                //调用Method类的方法invoke运行sleep方法
                method.invoke(obj, &quot;休眠&quot;,100,888.99);
            }
        }
* J. 反射泛型擦除
    * a. 使用情况
        例如：在泛型为String的集合里，添加Integer的数据
        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(100);
    * b. 能用泛型擦除的理论
        伪泛型：在编译后的.class文件里面是没有泛型的。类型为Object。
        用反射的方法绕过编译，得到Class文件对象，直接调用add方法。
    * c. 反射泛型擦除的代码演示
        package cn.itcast.demo2;
        import java.lang.reflect.Method;
        import java.util.ArrayList;

        /*
         *   定义集合类,泛型String
         *   要求向集合中添加Integer类型
         *   
         *   反射方式,获取出集合ArrayList类的class文件对象
         *   通过class文件对象,调用add方法
         *   
         *   对反射调用方法是否理解
         */
        public class ReflectTest {
            public static void main(String[] args)throws Exception {
                ArrayList&lt;String&gt; array  = new ArrayList&lt;String&gt;();
                array.add(&quot;a&quot;);
                //反射方式,获取出集合ArrayList类的class文件对象
                Class c = array.getClass();
                //获取ArrayList.class文件中的方法add
                Method method = c.getMethod(&quot;add&quot;,Object.class);
                //使用invoke运行ArrayList方法add
                method.invoke(array, 150);
                method.invoke(array, 1500);
                method.invoke(array, 15000);
                System.out.println(array);


            }
        }
* K. 反射通过配置文件来决定运行的步骤
    * a. 操作依据
            通过配置文件得到类名和要运行的方法名,用反射的操作类名得到对象和调用方法
    * b. 实现步骤:
         *    1. 准备配置文件,键值对
         *    2. IO流读取配置文件  Reader
         *    3. 文件中的键值对存储到集合中 Properties
         *        集合保存的键值对,就是类名和方法名
         *    4. 反射获取指定类的class文件对象
         *    5. class文件对象,获取指定的方法
         *    6. 运行方法
    * c. 代码演示
        代码：
        package cn.itcast.demo3;

        import java.io.FileReader;
        import java.lang.reflect.Method;
        import java.util.Properties;

        /*
         *  调用Person方法,调用Student方法,调用Worker方法
         *  类不清楚,方法也不清楚
         *  通过配置文件实现此功能
         *    运行的类名和方法名字,以键值对的形式,写在文本中
         *    运行哪个类,读取配置文件即可
         *  实现步骤:
         *    1. 准备配置文件,键值对
         *    2. IO流读取配置文件  Reader
         *    3. 文件中的键值对存储到集合中 Properties
         *        集合保存的键值对,就是类名和方法名
         *    4. 反射获取指定类的class文件对象
         *    5. class文件对象,获取指定的方法
         *    6. 运行方法
         */
        public class Test {
            public static void main(String[] args) throws Exception{
                //IO流读取配置文件
                FileReader r = new FileReader(&quot;config.properties&quot;);
                //创建集合对象
                Properties pro = new Properties();
                //调用集合方法load,传递流对象
                pro.load(r);
                r.close();
                //通过键获取值
                String className = pro.getProperty(&quot;className&quot;);
                String methodName = pro.getProperty(&quot;methodName&quot;);
                //反射获取指定类的class文件对象
                Class c = Class.forName(className);
                Object obj = c.newInstance();
                //获取指定的方法名
                Method method = c.getMethod(methodName);
                method.invoke(obj);
            }
        }
        配置文件：
        #className=cn.itcast.demo3.Student
        #methodName=study
        className=cn.itcast.demo3.Person
        methodName=eat
        #className=cn.itcast.demo3.Worker
        #methodName=job</code></pre><p>###3总结</p>
<ul>
<li>把今天的知识点总结一遍。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">KJH</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">96</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KJH</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
