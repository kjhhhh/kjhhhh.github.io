<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:type" content="website">
<meta property="og:title" content="KJHの博客">
<meta property="og:url" content="http://yoursite.com/page/9/index.html">
<meta property="og:site_name" content="KJHの博客">
<meta property="og:description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="匡俊桦">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>KJHの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KJHの博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录&回忆</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8(%E4%B8%89)%20%E7%AC%AC%E4%BA%8C%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8(%E4%B8%89)%20%E7%AC%AC%E4%BA%8C%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8/" class="post-title-link" itemprop="url">STL第二级配置器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-27 15:32:21" itemprop="dateCreated datePublished" datetime="2020-12-27T15:32:21+08:00">2020-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-04 15:20:44" itemprop="dateModified" datetime="2021-03-04T15:20:44+08:00">2021-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>考虑到小型区块所可能造成的内存破碎问题，SGI 设计了双层级配置器，这里则学习第二级配置器，第二级配置器的设计思想为：</p>
<ol>
<li>如果配置区块超过128 bytes，则移交给第一级配置器处理；</li>
<li>如果配置区块小于128 bytes，则采用内存池管理（memory pool）。每次配置一大块内存，则维护对应的自由链表（free-list），下次若再有相同大小的内存需求，就直接从 free-list 中拨出（没有就继续配置内存，具体后面讲述），如果客端释换小额区块，就有配置器回收到 free-list 中。</li>
</ol>
<p>需要说明的是：本系列引用的STL源码版本为 v3.3，对比版本 v2.03 风格上有了些许变化，但设计思想还是不变的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* part of stl source code v3.3 */</span></span><br><span class="line"><span class="keyword">enum</span> &#123; _ALIGN = <span class="number">8</span> &#125;;                <span class="comment">//小型区块的上调边界</span></span><br><span class="line"><span class="keyword">enum</span> &#123; _MAX_BYTES = <span class="number">128</span> &#125;;          <span class="comment">//小型区块的上限</span></span><br><span class="line"><span class="keyword">enum</span> &#123; _NFREELISTS = <span class="number">16</span> &#125;; <span class="comment">// _MAX_BYTES/_ALIGN   //free-list 编号数</span></span><br><span class="line"><span class="comment">//配置内存后，维护对应内存块的空闲链表节点结构</span></span><br><span class="line"><span class="keyword">union</span> _Obj &#123;</span><br><span class="line">	<span class="keyword">union</span> _Obj* _M_free_list_link;   <span class="comment">//空闲链表</span></span><br><span class="line">	<span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this. 用户使用的*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>考虑内存对其等因素，SGI 第二级配置器会主动将任何小额区块的内存需求量上调至 8 的倍数。并维护 16 个 free-list，各自管理大小分别为 8，16，24，32，40，48，56，64，72，80，88，96，104，112，120，128 bytes 的小额区块。</p>
<p>union _Obj 中的 <em>M</em>client_data 是C/C++中常见的变长数组实现方式（如果编译器支持 0 长度的数组，还可以声明为 <em>M</em>client_data[0] 达到更节省的目的），所以 union _Obj 的大小就是一个指针大小（<em>M</em>free_list_link 指针的大小）。union 实现一物二用，这个free-list 有两个作用：一个是指向下一块空白内存（当存在于 free-list 中时），一个就是供用户使用的一块内存（不存在于 free-list）。</p>
<p>回顾第二级配置器的设计思想的第 2 点，内存空间的分配大致是这样的：<strong><em>\</em>配置器分配空间时，先从 free-list 中拨出，如果有，就直接拨出，该需求大小的区块位于 free-list 对应编号的第一位置，然后从该链表中拨出，这样该区块就不位于 free-list 中对应编号内，第一位置向后移动指向，仅此一区块(刚已经拨出去)，则指向 0 ，表示 free-list 中没有该大小的区块；如果没有则需要向 free-list 填补区块，继而转向内存块分配函数，然后分配所需大小的新区块(一次性缺省分配20个，不够就分配小于20的，至少一个)，分配成功后，第一个区块直接划给客端，然后后面的（如果有）就填进 free-list，这样下次再有相同大小的内存需求时，可直接从 free-list 中拨出，如果一个区块都分配不出，就转向调用第一级配置器里的内存分配异常处理例程。 配置器还可以回收释放的内存，释还的小额内存区块划进 free-list 中（其实是关联到 free-list 对应编号区域）。<br>**</strong></p>
<p>SGI 缺省的 free-list 中都是0值，也就是说该链表中没有可用的小额区块，因为不可能 SGI STL 一开始就自动的给你分配出来（它知道你要多少呀）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*源码看上去相当绕口，这里精简下*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_Obj* <span class="keyword">volatile</span></span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt; ::_S_free_list[_NFREELISTS] = </span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#125;;         <span class="comment">//一一对应大小为 8,16 ... 128 bytes 大小的区块</span></span><br></pre></td></tr></table></figure>

<p>最开始只要需求小额区块内存，就会转到内存块分配函数。这样一来，相当于 free-list 是用来分配内存的，底层分配内存时，一次性分配一定数量的该额度区块（实际上是一次性分配大块内存，然后“分割”成小块），这样下次需求的时候直接从 free-list 中获取，而不用频繁的分配小额内存块，减少了内存碎片的产生，也提高了效率。</p>
<p>下面我们跟踪源码，来看看其内部是如何来实现这种机制的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将 __bytes 上调至最邻近的 8 的倍数*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">_S_round_up(<span class="keyword">size_t</span> __bytes)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (((__bytes)+(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) &amp; ~((<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*返回 __bytes 大小的小额区块位于 free-list 中的编号*/</span></span><br><span class="line"><span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) &#123;</span><br><span class="line">	<span class="keyword">return</span> (((__bytes)+(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) / (<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看 allocate()，然后穿针引线。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span>   <span class="comment">//分配大小为 __n 的区块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span>* __ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>)_MAX_BYTES) &#123;</span><br><span class="line">		__ret = malloc_alloc::allocate(__n);    <span class="comment">//大于128 bytes 就调用第一级配置器</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="comment">//__n 大小区块对应的位置：free-lists 首地址 + __n 位于free-lists 中的编号</span></span><br><span class="line">		_Obj* __STL_VOLATILE* __my_free_list    <span class="comment">//这里是二级指针，便于调整 free-lists </span></span><br><span class="line">			= _S_free_list + _S_freelist_index(__n);  		</span><br><span class="line"><span class="meta">#     <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">		_Lock __lock_instance;</span><br><span class="line"><span class="meta">#     <span class="meta-keyword">endif</span></span></span><br><span class="line">		_Obj* __RESTRICT __result = *__my_free_list; <span class="comment">//将对应位置的区块拨出(第一个)</span></span><br><span class="line">		<span class="keyword">if</span> (__result == <span class="number">0</span>)                       <span class="comment">//如果 free-lists 中没有对应大小的区块</span></span><br><span class="line">			__ret = _S_refill(_S_round_up(__n)); <span class="comment">//调用 _S_refill()</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			*__my_free_list = __result-&gt;_M_free_list_link;<span class="comment">//这个结构有点类似链式哈希表结构，这里是指向下一块空闲内存块  </span></span><br><span class="line">			<span class="comment">//二级指针调整 free-lists，拨出去的区块就不属于该链表了</span></span><br><span class="line">			__ret = __result;                               </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> __ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>区块自 free-list 拨出的操作（下面这个数据结构类似于链式哈希表），如下图所示（图片源自《STL源码剖析》）<br><img src="/2020/12/27/STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8(%E4%B8%89)%20%E7%AC%AC%E4%BA%8C%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8/20140221155259531" alt="img"></p>
<p>如果 free-list 中没有对应大小的区块，就转去调用 <em>S</em>refill()。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>*           <span class="comment">//重新填充__n大小的区块进 free-list</span></span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_refill(<span class="keyword">size_t</span> __n)  </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> __nobjs = <span class="number">20</span>;      <span class="comment">//缺省取得 20 个新区块</span></span><br><span class="line">	<span class="keyword">char</span>* __chunk = _S_chunk_alloc(__n, __nobjs);  <span class="comment">//调用_S_chunk_alloc()</span></span><br><span class="line">	_Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">	_Obj* __result;</span><br><span class="line">	_Obj* __current_obj;</span><br><span class="line">	_Obj* __next_obj;</span><br><span class="line">	<span class="keyword">int</span> __i;</span><br><span class="line">	<span class="comment">/*如果只获得一个新区块，直接划给用户，free-list 仍然无新节点*/</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == __nobjs) <span class="keyword">return</span>(__chunk);  </span><br><span class="line">	__my_free_list = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">	__result = (_Obj*)__chunk;   <span class="comment">//这一块返回给客端(分配出来的第一块)</span></span><br><span class="line">	*__my_free_list = __next_obj = (_Obj*)(__chunk + __n); </span><br><span class="line">	<span class="comment">/*接下来的区块(拨出去了__n大小给用户)填补进 free-list*/</span></span><br><span class="line">	<span class="keyword">for</span> (__i = <span class="number">1</span>;; __i++) &#123;</span><br><span class="line">		__current_obj = __next_obj; </span><br><span class="line">		__next_obj = (_Obj*)((<span class="keyword">char</span>*)__next_obj + __n); </span><br><span class="line">		<span class="comment">/*将分配的连续大块"分割"成__n bytes大小的区块*/</span></span><br><span class="line">		<span class="keyword">if</span> (__nobjs - <span class="number">1</span> == __i) &#123;  <span class="comment">//如果新区块填补完毕</span></span><br><span class="line">			__current_obj-&gt;_M_free_list_link = <span class="number">0</span>;  <span class="comment">//free-list 最后位置指向0</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="comment">//把_M_free_list_link当做链表的 next 指针理解</span></span><br><span class="line">			__current_obj-&gt;_M_free_list_link = __next_obj; <span class="comment">//将各节点串联起来填进空闲链表</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(__result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样将把第一块返回给客端的剩余 “大块”内存 “分割” 成指定大小的区块，并填进 free-list 中。新的区块取自内存池，由 <em>S</em>chunk_alloc() 完成。</p>
<p>这个函数的具体实现思想为：</p>
<p>1、内存池剩余空间完全满足 20 个区块的需求量，则直接取出对应大小的空间；<br>2、内存池剩余空间不能完全满足 20 个区块的需求量，但可以提供一个及以上的区块，<br>  则取出能够满足需求区块的最大个数的空间；<br>3、内存池剩余空间不能满足一个需求区块的大小，则进行以下处理：<br>    \1. 首先判池中是否存在残余零头的内存空间，如果有则进行回收，将其划入 free-list 中的适当位置；<br>    \2. 然后向 system heap 申请空间，补充内存池。<br>     2.1 若 heap 空间充足，则空间分配成功；<br>     2.2 若 heap 空间不足，出现 malloc() 调用失败。<br>      则搜寻适当的 free-list （适当是指 “尚有未有区块，且区块较大” 的 free-list ），<br>      即搜寻 free-list 大于等于需求块的区块，将其编入内存池，然后递归调用 <em>S</em>chunk_alloc()<br>      函数从内存池中取空间重复上述过程。如果很不幸，free-list 中没有合适的内存空间可用了，<br>      这时候则调用第一级配置器，利用 out-of-memory 机制尝试解决内存不足问题，<br>      结果要么内存不足的情况获得改善，要么抛出 bad_alloc 异常。 </p>
<p>接下来直接看源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_start_free;   <span class="comment">//内存池起始位置</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_end_free;     <span class="comment">//内存池末端位置</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;   <span class="comment">//堆空间容量</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>*__default_alloc_template&lt;__threads, __inst&gt;::_S_chunk_alloc(<span class="keyword">size_t</span> __size,</span><br><span class="line"><span class="keyword">int</span>&amp; __nobjs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span>* __result;</span><br><span class="line">	<span class="keyword">size_t</span> __total_bytes = __size * __nobjs;       <span class="comment">//需要内存的总额大小</span></span><br><span class="line">	<span class="keyword">size_t</span> __bytes_left = _S_end_free - _S_start_free;  <span class="comment">//内存池中还剩余多少可用内存</span></span><br><span class="line">	<span class="keyword">if</span> (__bytes_left &gt;= __total_bytes) &#123;    <span class="comment">//剩余可用量大于需求量，直接划分出去</span></span><br><span class="line">		__result = _S_start_free;           <span class="comment">//内存池的首地址</span></span><br><span class="line">        _S_start_free += __total_bytes;     <span class="comment">//调整内存池位置							return(__result);  </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//内存池剩余空间不能完全满足需求，但至少可供应一个及以上的区块</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (__bytes_left &gt;= __size) &#123;      </span><br><span class="line">		__nobjs = (<span class="keyword">int</span>)(__bytes_left / __size);  <span class="comment">//调整划分个数，划分出去最大量</span></span><br><span class="line">		__total_bytes = __size * __nobjs;        <span class="comment">//同上</span></span><br><span class="line">		__result = _S_start_free;</span><br><span class="line">		_S_start_free += __total_bytes;</span><br><span class="line">		<span class="keyword">return</span>(__result);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;    <span class="comment">//内存池剩余空间连一个区块都无法提供</span></span><br><span class="line">		<span class="keyword">size_t</span> __bytes_to_get =<span class="comment">//配置大小为总需求量的两倍再加上一个随配置次数逐渐增加的附加量</span></span><br><span class="line">			<span class="number">2</span> * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="number">4</span>); /</span><br><span class="line">		<span class="keyword">if</span> (__bytes_left &gt; <span class="number">0</span>) &#123;   <span class="comment">//充分利用内存池中的剩余空间</span></span><br><span class="line">			_Obj* __STL_VOLATILE* __my_free_list =   <span class="comment">//剩余空间寻找适当的free-list</span></span><br><span class="line">				_S_free_list + _S_freelist_index(__bytes_left);   </span><br><span class="line">         <span class="comment">//调整 free-list，将内存池中残余空间编入 free-list 对应位置中</span></span><br><span class="line">			((_Obj*)_S_start_free)-&gt;_M_free_list_link = *__my_free_list;</span><br><span class="line">			*__my_free_list = (_Obj*)_S_start_free;</span><br><span class="line">		&#125;</span><br><span class="line">		_S_start_free = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(__bytes_to_get);  <span class="comment">//配置heap空间，用来补充内存池</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == _S_start_free) &#123;         <span class="comment">//system heap 空间不足，分配失败</span></span><br><span class="line">			<span class="keyword">size_t</span> __i;</span><br><span class="line">			_Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">			_Obj* __p;</span><br><span class="line">			<span class="keyword">for</span> (__i = __size;                 <span class="comment">//起始大小为需求区块大小</span></span><br><span class="line">				__i &lt;= (<span class="keyword">size_t</span>)_MAX_BYTES;      </span><br><span class="line">				__i += (<span class="keyword">size_t</span>)_ALIGN) &#123;       <span class="comment">//以 8 为步长搜寻整个 free-list</span></span><br><span class="line">				__my_free_list = _S_free_list + _S_freelist_index(__i);  <span class="comment">//找到 __i大小区块在free-list 中的位置</span></span><br><span class="line">				__p = *__my_free_list;</span><br><span class="line">				<span class="keyword">if</span> (<span class="number">0</span> != __p) &#123;               <span class="comment">//如果 free-list 中该区块未使用</span></span><br><span class="line">					*__my_free_list = __p-&gt;_M_free_list_link;   <span class="comment">//调整 free-list，释放第一位置块</span></span><br><span class="line">					_S_start_free = (<span class="keyword">char</span>*)__p;              <span class="comment">//编入内存池</span></span><br><span class="line">					_S_end_free = _S_start_free + __i;       </span><br><span class="line">					<span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));    <span class="comment">//递归调用</span></span><br><span class="line">        <span class="comment">/*该for循环的作用就是从 free-list 中划出大于需求区块(单个）的未用空间区块到内存池，然后再从内存池中取出。</span></span><br><span class="line"><span class="comment">		由于从大于__size 的区块开始搜寻，所以如果 free-list 中搜寻到，那么只需动用该搜寻区块的第一位置区块即可，</span></span><br><span class="line"><span class="comment">		最后取出的空间也可能是单个区块，也可能是多个区块(取决于 free-list 未用区块的最小区块(大于__size)的大小)*/</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			_S_end_free = <span class="number">0</span>;	<span class="comment">//表示到处无内存可用，for循环中free-list没有搜寻到适当的未用空间</span></span><br><span class="line">			_S_start_free = (<span class="keyword">char</span>*)malloc_alloc::allocate(__bytes_to_get); <span class="comment">//调用第一级配置器</span></span><br><span class="line">			<span class="comment">/*要么内存不足的问题获得改善，要么抛出 bad_alloc 异常*/</span></span><br><span class="line">		&#125;</span><br><span class="line">		_S_heap_size += __bytes_to_get;   <span class="comment">//调用第一级配置器后，内存不足问题获得改善，调整堆空间</span></span><br><span class="line">		_S_end_free = _S_start_free + __bytes_to_get;    <span class="comment">//编入内存池</span></span><br><span class="line">		<span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));   <span class="comment">//重新调用 _S_chunk_alloc()</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里补充一下内存池的概念：内存池是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存。这样，内存池允许在运行期以常数时间规划内存块，并且尽量避免了内存破碎的情况产生，使得内存分配的效率得到提升。<br>内存池实际操练结果如下图：</p>
<p><img src="/2020/12/27/STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8(%E4%B8%89)%20%E7%AC%AC%E4%BA%8C%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8/20140221191442375" alt="img"></p>
<p>如上图，加入程序一开始，客端就调用 <em>S</em>chunk_alloc(32, 20)，于是 malloc() 配置 40 个 32 bytes 区块，其中第 1 个返回给客端，另 19 个交给 <em>S</em>free_list [3] 维护，余 20 个留给内存池。接下来客端调用 <em>S</em>chunk_alloc(64, 20)，此时 <em>S</em>free_list [7] 是空的，必须向内存池要求空间，内存池只够供应 (32 * 20) / 64 = 10 个 64 bytes 区块，就把这 10 个区块返回，第 1 个交给客端，余 9 个由 <em>S</em>free_list [7] 维护，此时内存池全空，接下来再调用 <em>S</em>chunk_alloc(96, 20)，此时 <em>S</em>free_list [11] 空空如也，必须向内存池要求支持，而内存池此时也是空的，于是以 malloc() 配置 40 + n（附加量）个 96 bytes 区块，其中第 1 个交出，另 19 个交给 <em>S</em>free_list [11] 维护，余 20 + n 个区块留给内存池……</p>
<p>如果到最后，整个 system heap 空间都不够了，malloc() 分配失败，<em>S</em>chunk_alloc() 就四处寻找有无 “尚有未用区块，且足够大” 的 free-list。找到了就挖一块交出，找不到就调用第一级配置器，第一级其实也是调用 malloc() 来配置内存，但它有 out-of-memory 处理机制，或许有机会释放其它的内存拿来此处使用。如果可以，就成功，否则发出 bad_alloc 异常。 </p>
<p>配置器自然也有释放空间的能力，这里再学习空间释放函数 deallocate()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*空间释放后被编入 free-list*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>)_MAX_BYTES)  <span class="comment">//大于 128 就调用第一级配置器</span></span><br><span class="line">		malloc_alloc::deallocate(__p, __n);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		_Obj* __STL_VOLATILE*  __my_free_list  <span class="comment">//定位到对应的 free-list</span></span><br><span class="line">			= _S_free_list + _S_freelist_index(__n);</span><br><span class="line">		_Obj* __q = (_Obj*)__p;       </span><br><span class="line"><span class="meta">#       <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">		_Lock __lock_instance;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">endif</span> </span></span><br><span class="line">		__q-&gt;_M_free_list_link = *__my_free_list;  <span class="comment">//调整 free-list 回收区块</span></span><br><span class="line">		*__my_free_list = __q;        <span class="comment">//回收的区块是挂接到free-list 对应区块的第一位置，而不是添加到尾端</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区块回收纳入 free-list 的操作（序号对应顺序），如下图所示</p>
<p><img src="/2020/12/27/STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8(%E4%B8%89)%20%E7%AC%AC%E4%BA%8C%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8/20140221201652625" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8(%E4%BA%8C)%20%E7%AC%AC%E4%B8%80%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8(%E4%BA%8C)%20%E7%AC%AC%E4%B8%80%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8/" class="post-title-link" itemprop="url">STL第一级配置器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-27 15:31:55" itemprop="dateCreated datePublished" datetime="2020-12-27T15:31:55+08:00">2020-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-04 15:11:57" itemprop="dateModified" datetime="2021-03-04T15:11:57+08:00">2021-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们再来学习内存的配置与释放（定义在头文件 &lt;stl_alloc.h&gt; 中）。其设计思想为：</p>
<ul>
<li>向 system heap 要求空间；</li>
<li>考虑多线程 (multi-threads) 状态；</li>
<li>考虑内存不足时的应变措施；</li>
<li>考虑过多 “小型区块” 可能造成的内存碎片 (fragment) 问题。</li>
</ul>
<p>我们后面将通过分析源码来了解这设计思想是如何在设计中体现的。SGI 设计了双层级配置器，第一级配置器直接使用 malloc() 和 free()，第二级则视情况采用不同策略，并采用了复杂的内存池(memory pool) 整理方式。<br>整个设计究竟只开放第一级配置器，或是同时开放第二级配置器，取决于宏 __USE_MALLOC 是否被定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __USE_MALLOC</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/*__malloc_alloc_template 就是第一级配置器*/</span></span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;    </span><br><span class="line"><span class="keyword">typedef</span> malloc_alloc alloc;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/*__default_alloc_template 就是第二级配置器*/</span></span><br><span class="line"><span class="keyword">typedef</span> __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, <span class="number">0</span>&gt; alloc;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p>最后都定位于 alloc，因为通常我们使用缺省的空间配置器，而 SGI STL 的每个容器都已经指定其缺省的空间配置器 alloc。<br>无论 alloc 被定义为第一级或第二级配置器，SGI 还为它再封装一个接口如下，使配置器的接口能够符合STL规格：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">simple_alloc</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> _Tp* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span> == __n ? <span class="number">0</span> : (_Tp*)_Alloc::allocate(__n * <span class="keyword">sizeof</span> (_Tp));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> _Tp* <span class="title">allocate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (_Tp*)_Alloc::allocate(<span class="keyword">sizeof</span> (_Tp));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(_Tp* __p, <span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> != __n) _Alloc::deallocate(__p, __n * <span class="keyword">sizeof</span> (_Tp));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(_Tp* __p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_Alloc::deallocate(__p, <span class="keyword">sizeof</span> (_Tp));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这内部四个成员函数其实都是单纯的转调用，调用传递给配置器的成员函数。SGI STL 容器全部使用这个simple_alloc 接口。</p>
<p>本文就着重分析<strong>第一级配置器 __malloc_alloc_template</strong></p>
<p>先学习 allocate()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __THROW_BAD_ALLOC fprintf(stderr, <span class="meta-string">"out of memory\n"</span>); exit(1)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span>* __result = <span class="built_in">malloc</span>(__n);      <span class="comment">//调用malloc()分配内存，向 system heap 要求空间</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_malloc(__n);     <span class="comment">//malloc分配失败，调用_S_oom_malloc()</span></span><br><span class="line">	<span class="keyword">return</span> __result;                                      <span class="comment">//oom means "out of memory"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>(*__malloc_alloc_template&lt;__inst&gt;::__malloc_alloc_oom_handler)() = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>                     </span></span><br><span class="line"><span class="comment">//内存不足处理例程，初值为0，待用户自定义，考虑内存不足时的应变措施。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>*</span><br><span class="line">__malloc_alloc_template&lt;__inst&gt;::_S_oom_malloc(<span class="keyword">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span>(*__my_malloc_handler)();    <span class="comment">//函数指针</span></span><br><span class="line">	<span class="keyword">void</span>* __result;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;   <span class="comment">//不断的尝试释放、配置、再释放、再配置……</span></span><br><span class="line">		__my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">		<span class="comment">/*由于初值设定为0，如果用户没有自定义相应的内存不足处理例程，那么还是抛出异常*/</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == __my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;  </span><br><span class="line">		(*__my_malloc_handler)();          <span class="comment">//用户有自定义(释放内存)，则进入相应的处理程序</span></span><br><span class="line">		__result = <span class="built_in">malloc</span>(__n);            </span><br><span class="line">		<span class="keyword">if</span> (__result) <span class="keyword">return</span>(__result);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//不断的尝试释放和配置是因为用户不知道还需要释放多少内存来满足分配需求，只能逐步的释放配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面并非死循环，它有两个退出条件：1.用户没有定义相应的内存不足处理例程，即没有通过释放内存来解决现有内存分配不足的问题，结果抛出异常，直接退出(宏定义)；2.在用户定义了释放内存程序例程后，成功分配指定大小内存，返回指向该内存区域的首地址。</p>
<p>再学习 reallocate()，与allocate() 类似，就直接贴源码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> __new_sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span>* __result = <span class="built_in">realloc</span>(__p, __new_sz);</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_realloc(__p, __new_sz);</span><br><span class="line">	<span class="keyword">return</span> __result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>* __malloc_alloc_template&lt;__inst&gt;::_S_oom_realloc(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> (* __my_malloc_handler)();</span><br><span class="line">    <span class="keyword">void</span>* __result;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == __my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;</span><br><span class="line">        (*__my_malloc_handler)();</span><br><span class="line">        __result = <span class="built_in">realloc</span>(__p, __n);</span><br><span class="line">        <span class="keyword">if</span> (__result) <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一级空间配置器释放内存就更简单了 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* __n */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">free</span>(__p);        <span class="comment">//第一级配置器直接使用free()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以很清楚的看出，第一级配置器以 malloc()，free()，realloc() 等 C 函数执行实际的内存配置、释放、重配置操作，因此，SGI 不能直接使用 C++ 的 set_new_handler()，必须仿真一个类似的 set_malloc_handler()。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*该函数接收一个返回值为空，参数为空的函数指针作为参数，最后返回一个返回值和参数均为空的函数指针*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __set_malloc_handler(<span class="keyword">void</span> (*__f)()))</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (* __old)() = __malloc_alloc_oom_handler;       <span class="comment">//保存原有处理例程</span></span><br><span class="line">    __malloc_alloc_oom_handler = __f;                    <span class="comment">//重新指定异常处理例程</span></span><br><span class="line">    <span class="keyword">return</span>(__old);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数重新指定了内存分配异常处理函数，并返回原有的内存分配异常处理函数，即设置新处理例程的同时也保存了原有的处理例程。</p>
<p>回看源码中的 allocate() 和 reallocate() 函数中的用户定义内存不足异常处理例程正是通过这里来指定的。</p>
<p>通过上面的剥洋葱我们可以发现，SGI 第一级配置器的 allocate() 和 reallocate() 都是在调用 malloc() 和 realloc() 不成功后，改调用 <em>S</em>oom_malloc() 和 <em>S</em>oom_realloc()。后两者都有内循环，不断调用 “内存不足处理例程”，期望在某次调用之后，可以获得足够的内存来完成所需求的内存分配，如果 “内存不足处理例程” 并未被客端设定，<em>S</em>oom_malloc() 和 <em>S</em>oom_realloc() 便会调用 __THROW_BAD_ALLOC，丢出 bad_alloc 异常信息，而后直接利用 exit(1) 中止程序。</p>
<p>所以可以看出，设计 “内存不足处理例程” 是客端的责任，设定 “内存不足处理例程” 也是客端的责任。也就是说 SGI STL 不为你设定。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8(%E4%B8%80)%20%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8(%E4%B8%80)%20%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84/" class="post-title-link" itemprop="url">STL构造和析构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-27 15:31:31" itemprop="dateCreated datePublished" datetime="2020-12-27T15:31:31+08:00">2020-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-04 15:34:48" itemprop="dateModified" datetime="2021-03-04T15:34:48+08:00">2021-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>以STL运用的角度而言，空间配置器总是隐藏在一切组件的背后，但就STL 的实现角度而言，我们需要了解空间配置器，因为整个STL 的操作对象(所有数值，“value”语意)都存放在容器之内，而容器一定需要配置空间以置放数据。</p>
<p>一般而言，我们所习惯的C++ 内存配置操作和释放操作是这样的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span> ... &#125;;</span><br><span class="line">Foo* pObj = <span class="keyword">new</span> Foo;</span><br><span class="line"><span class="keyword">delete</span> pObj;</span><br></pre></td></tr></table></figure>

<p>其中new 运算包含两阶段操作：1. 调用 ::operator new 配置内存，2. 调用构造函数 Foo() 构造对象。 delete 运算也包含两个阶段：1. 调用析构函数 ~Foo() 将对象析构， 2. 调用 ::operator delete 释放内存。</p>
<p>STL 为了提高效率则把二者分开，对象的构造和析构由::construct() 和::destory() 完成，内存的配置则是由 std::alloc 完成。<br>先介绍构造和析构基本工具：construct() 和 destroy()    下载源码：<a href="http://www.sgi.com/tech/stl/download.html" target="_blank" rel="noopener">http://www.sgi.com/tech/stl/download.html</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*from stl source code v3.3 http://www.sgi.com/tech/stl/download.html</span></span><br><span class="line"><span class="comment">part of &lt;stl_construct.h&gt;*/</span></span><br><span class="line"><span class="comment">//为了便于理清，这里针对源码进行了修改</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new.h&gt;   //欲使用 placement new，需先包含此文件</span></span></span><br><span class="line"><span class="comment">//construct()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="title">class</span> _<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">construct</span>(_<span class="title">T1</span>* __<span class="title">p</span>, <span class="title">const</span> _<span class="title">T2</span>&amp; __<span class="title">value</span>) &#123;</span></span><br><span class="line">    <span class="keyword">new</span> ((<span class="keyword">void</span>*)__p) _T1(__value);           <span class="comment">// placement new; 调用 _T1::_T1(__value),构造新对象到预分配的内存上</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">construct</span>(_<span class="title">T1</span>* __<span class="title">p</span>) &#123;</span></span><br><span class="line">	<span class="keyword">new</span> ((<span class="keyword">void</span>*)__p) _T1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//destroy()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(_<span class="title">Tp</span>* __<span class="title">pointer</span>) &#123;</span></span><br><span class="line">	__pointer-&gt;~_Tp();    <span class="comment">//调用~_Tp()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>placement new 允许你在一个已经分配好的内存中(栈或堆)构造一个新的对象，原型中 (void*) __p 实际上就是指向一个已经分配好的内存缓冲区的首地址。STL 借助C++中的 placement new 来提高效率，因为使用 new 操作符分配内存需要在堆中查找足够大的剩余空间，这个操作速度是很慢的，而且有可能出现无法分配内存的异常。借助 placement new 就可以解决这个问题，我们构造对象都是在一个预先准备好了的内存缓冲区中进行，不需要查找内存，内存分配的时间是常数，而且不会出现在程序运行中途出现内存不足的异常。</p>
<p>上面的析构函数是接受一个指针，STL 另外提供一个版本用来析构两个迭代器所指范围内的所有对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这里对比源码调整了顺序*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(_<span class="title">ForwardIterator</span> __<span class="title">first</span>, _<span class="title">ForwardIterator</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">	_Destroy(__first, __last);                        <span class="comment">//调用_Destroy()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数内部调用的函数__destroy()多了个参数，__VALUE_TYPE(__first)，用于找出元素的数值型别</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">Destroy</span>(_<span class="title">ForwardIterator</span> __<span class="title">first</span>, _<span class="title">ForwardIterator</span> __<span class="title">last</span>) &#123;</span></span><br><span class="line">	__destroy(__first, __last, __VALUE_TYPE(__first));    <span class="comment">//调用__destroy()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断元素的数值型别是否有无用的析构函数(trivial_destructor)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span></span></span><br><span class="line"><span class="class">__<span class="title">destroy</span>(_<span class="title">ForwardIterator</span> __<span class="title">first</span>, _<span class="title">ForwardIterator</span> __<span class="title">last</span>, _<span class="title">Tp</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;_Tp&gt;::has_trivial_destructor</span><br><span class="line">		_Trivial_destructor;</span><br><span class="line">	__destroy_aux(__first, __last, _Trivial_destructor());  <span class="comment">//调用__destroy_aux()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果元素的数值型别具备的是有用的析构函数，那么函数内部调用destroy()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">destroy_aux</span>(_<span class="title">ForwardIterator</span> __<span class="title">first</span>, _<span class="title">ForwardIterator</span> __<span class="title">last</span>, __<span class="title">false_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">for</span> (; __first != __last; ++__first)</span><br><span class="line">		destroy(&amp;*__first);    <span class="comment">//调用destroy()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果元素的数值型别有无用的析构函数，函数体无操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">destroy_aux</span>(_<span class="title">ForwardIterator</span>, _<span class="title">ForwardIterator</span>, __<span class="title">true_type</span>) &#123;</span>&#125;</span><br><span class="line"><span class="comment">//迭代器版本destroy() -&gt; _Destroy() -&gt; __destroy() -&gt; __destroy_aux() -&gt; destroy() 指针版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以实际上是逐个析构，只是中间为了效率，引入了判断元素的数值型别，来确定对象是否具备有用的析构函数</span></span><br></pre></td></tr></table></figure>

<p>上面可以看出，对于迭代器版本的destroy() 实际最后都落脚到了单一对象指针版本的 destroy()。那么为什么要绕一大圈呢？因为这里接受的参数是两个迭代器，目的就是将这两个迭代器范围内的所有对象都析构掉，如果范围很大，并且对象的析构函数都是无关紧要的，那么一次次的调用这些个无用的析构函数，势必会对效率产生大的影响，所以先利用<strong>VALUE(</strong>first) 获得迭代器所指对象的型别，再利用 __type_traits&lt;_Tp&gt; 判断该型别的析构函数是否无关痛痒，如果是则什么也不做，如果不是则循环逐个析构范围内的对象。</p>
<p>所以对象的构造实际是通过 placement new 完成的(缓存提前分配然后进行对象的分配)；对象的析构则通过调用外在的析构函数(~_Tp())。注意的是，这里的析构只是析构对象，分配好的缓存并没有释放，所以可以反复利用缓存并给它分配对象。不打算再次使用这个缓存时，你可以delete 将其释放掉。</p>
<p>另外destroy() 第二版本还针对迭代器类型为 char* 和 wchar_t* 定义了特化版本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">char</span>*, <span class="keyword">char</span>*)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">wchar_t</span>*, <span class="keyword">wchar_t</span>*)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>下面插图来源于《STL 源码剖析》，有利于从全局把握destroy()。 </p>
<p><img src="/2020/12/27/STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8(%E4%B8%80)%20%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84/20140220144810421" alt="img"></p>
<p>后面将陆续学习STL 内存的配置和释放。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E6%98%AF%E6%80%8E%E4%B9%88%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E6%98%AF%E6%80%8E%E4%B9%88%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84/" class="post-title-link" itemprop="url">内联函数是怎么提高效率的</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-27 15:30:01 / 修改时间：15:30:40" itemprop="dateCreated datePublished" datetime="2020-12-27T15:30:01+08:00">2020-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>C++和C99均支持内联函数inline，按这个名称的意思应该是“在字里行间展开”，内联函数会在它被调用的位置展开 。</p>
<p>讨论之前，我们先来看一个故事：实验室搬至六楼，小件器件特别多，一同学正一件一件地往六楼搬，老师借给他一个大袋子，这同学一次就把这些小物件搬上了六楼，虽然增加了一个大袋子的重量，却省去了上下六楼100多趟之苦。这个大袋子就充当了内联函数的功能。</p>
<p>我们都知道，一个函数的调用要付出时间上的代价，其大致过程为：</p>
<p>\1. 保护现场，就是先将主调函数里的函数调用返回后要执行的指令的地址压入栈中保存；</p>
<p>\2. 把被调函数的形参和auto存储类型的变量压入栈区保存，这一步压入的所有变量所占有的存储我们称之为被调函数的数据现场；</p>
<p>\3. 执行完被调函数之后，把被调函数数据现场释放(出栈)；</p>
<p>\4. 把第1步压入的指令地址出栈，即恢复现场，然后找到这个地址继续执行。</p>
<p>要是一个函数被调用了许多次，那么编译系统需要来来回回的往返许多趟，存在栈内存创建和释放的开销，于是C++(C99)的编译系统提供了一个大袋子。在被调函数的定义前加一个标志(inline)告诉编译系统，编译系统看到这个标志后，实际编译出的可执行程序，就如同用函数体合理地置换了函数被调用处一样，我们称之为内联机制。</p>
<p>内联机制可以消除函数调用和返回带来的开销(寄存器存储和恢复)，另外，编译器也会把调用函数的代码和函数本身放在一起进行优化，那么，是不是干脆把所有的函数都定义称内联函数呢，天底下没有免费的午餐，在计算机科学中，空间和时间永远是个矛盾体。内联是以代码膨胀(复制)为代价，仅仅省去了函数调用的开销，需要占用更多的内存空间或者更多的指令缓存，最终生成的可执行程序的体积会有膨胀，这是典型的以空间换时间的做法。</p>
<p>这是对于函数体比较短小的情况，但如果函数体比较大，执行函数体内代码的时间，相比于函数调用的开销比较大，那么效率的收获会很少，而且，每一处内联函数的调用都要拷贝一份代码，将使程序的总代码量增大，消耗更多的内存空间，这样就不值得了。</p>
<p>一般来说，具有以下特征的函数适宜定义成内联函数：</p>
<p>\1. 函数体内的语句数量较少，如果函数体内代码比较长，使用内联将导致内存消耗代价较高；</p>
<p>\2. 函数体内没有循环，递归等。出现循环，执行函数体内代码的时间要比函数调用的开销大；</p>
<p>\3. 在满足上面两个前提下，函数实际调用次数却很多的情况。就可以考虑将函数定义为内联来提高效率。</p>
<p>那么内联函数究竟是如何工作的呢？</p>
<p>当我们定义了一个函数之后，编译器会将其编译成一个指令集合。这个指令集合在程序运行的时候会出现在内存的代码区里，并且在调用此函数时程序执行的地址会跳转到这个指令集合的入口地址，当指令集合执行完后，再跳回到主调函数。换句话说，任何时候内存中只有一个指令集，如果该函数被调用10次，则运行时就会跳转到同一入口地址10次。</p>
<p>如果定义为inline函数，编译器并不创建真实函数，内联函数不仅同普通函数一样经过检查后保存函数名称、参数类型和返回值类型，还会把内联函数的本体也一并存入符号表中，在之后的编译过程中一旦遇到该函数被调用时会首先检查调用是否合法，然后编译器会将inline函数的指令集合(函数代码)复制嵌入到主调函数中的调用位置，内联函数的代码就会直接替换函数调用，这样就不需要函数调用的跳转开销了。如果函数被调用了10次，就相当于内存中就包含10个相同指令集合的拷贝，没有一次调用。</p>
<p>了解了内联函数是怎么工作的，那么内联机制的优劣就好理解了。需要清楚的是，我们定义为inline函数只是建议编译器进行内联，而不是命令编译器进行内联，所以最后是不是内联函数取决于编译器。还有关键字inline必须与函数定义放在一起才能使函数成为内联(最后由编译器决定)，仅放在函数声明前面不起作用。因为inline是在编译时展开，必须有实体，在编译阶段，编译器看到inline标志就会根据该函数体情况去判断是否应该将该函数体定义为内联。没看到本体怎么判断勒。</p>
<p>inline是一种“用于实现的关键字”，内联函数不能带有virtual关键字。常把inline函数定义为static类型，可以在不同文件中定义同名文件，而不必担心命名冲突，所有未加static前缀的函数都具有全局可见性，其他源文件也能访问。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">单例设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-27 15:28:55 / 修改时间：15:29:44" itemprop="dateCreated datePublished" datetime="2020-12-27T15:28:55+08:00">2020-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>单例模式（singleton）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>如何保证一个类只有一个实例并且这个实例易于被访问呢？一个全局变量使得一个对象可以被访问，但它不能防止你实例化多个对象。一个更好的办法是，让类自身负责保存它的唯一实例，这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法，这就是 Singleton 模式。</p>
<p>Singleton 类UML图</p>
<p>​                        <img src="/2020/12/27/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20150720215641458" alt="img"></p>
<p>Singleton 类，定义一个 GetInstance 操作，允许客户访问它的唯一实例。GetInstance 是一个静态方法，主要负责创建自己的唯一实例。</p>
<p>Singleton 模式使得这个唯一实例是类的一般实例，但该类被写成只有一个实例能被创建。做到这一点的一个常用方法是将创建这个实例的操作隐藏在一个类操作（即一个静态成员函数或者一个类方法）后面，由它保证只有一个实例被创建。这个操作可以访问保存唯一实例的变量，而且它可以保证这个变量在返回值之前用这个唯一实例初始化。</p>
<p><strong>懒汉模式</strong>：单例模式处理方式要在第一次被引用时，才会将自己实例化，其返回值直到被第一次访问时才创建和保存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> Singleton *instance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Singleton()<span class="comment">//让其private，这样外部程序不能通过其实例化。Singleton obj;错误</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span><span class="comment">//类操作，即一个静态成员函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">NULL</span>)<span class="comment">//没有实例化的情况下在去实例</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			instance = <span class="keyword">new</span> Singleton;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DestroyInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (instance != <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">delete</span> instance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			instance = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">NULL</span>;<span class="comment">//静态成员变量类外初始化</span></span><br></pre></td></tr></table></figure>





<p>客户端代码：</p>
<p>客户端不再考虑是否需要去实例化的问题了，而把责任给了应该负责的类去处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Singleton *s1 = Singleton::GetInstance();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Singleton *s2 = Singleton::GetInstance();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Singleton *s2 = s1-&gt;GetInstance();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s1 == s2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"两个对象是相同的实例"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑到多线程安全。在多线程的程序中，多个线程同时访问 Singleton 类，调用 GetInstance() 方法，会有可能造成创建多个实例的情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> Singleton *instance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Singleton()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span><span class="comment">//类操作，即一个静态成员函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//双重锁定</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> == instance)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			lock();<span class="comment">//实例未创建的情况下加锁，借用其他类实现</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="literal">NULL</span> == instance)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				instance = <span class="keyword">new</span> Singleton;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			unlock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DestroyInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (instance != <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">delete</span> instance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			instance = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">NULL</span>;<span class="comment">//静态成员变量类外初始化</span></span><br></pre></td></tr></table></figure>


<p><strong>饿汉模式</strong>：静态初始化实例方式，在自己被加载时就将自己实例化，提前占用系统资源。</p>
<p>其可以保证线程安全性，因为静态实例初始化在程序开始进入主函数之前就由主线程以单线程方式完成了初始化，不必担心多线程问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> Singleton *instance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Singleton()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">const</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DestroyInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (instance != <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">delete</span> instance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			instance = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//进入主函数之前就完成了实例初始化，是线程安全的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Singleton* Singleton::instance = <span class="keyword">new</span> Singleton;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> Singleton *s1 = Singleton::GetInstance();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> Singleton *s2 = Singleton::GetInstance();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//const Singleton *s2 = s1-&gt;GetInstance();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s1 == s2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"两个对象是相同的实例"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Singleton::DestroyInstance();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B01/" class="post-title-link" itemprop="url">C语言笔记1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-27 15:27:33 / 修改时间：15:28:15" itemprop="dateCreated datePublished" datetime="2020-12-27T15:27:33+08:00">2020-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1、定义申明最重要的区别：定义创建了对象并为这个对象分配了内存，声明没有分配内存。</p>
<p>即一个需要建立存储空间，如 int i; 这是定义；而 extern int i; 是声明，并没有建立存储空间，只是告诉编译器该变量已经在别处定义过了。对于函数的定义和声明也同样如此，这就为什么内联 inline 函数只能在放在函数定义的前面，而不能放在声明之前。</p>
<p>2、在 union 中所有的数据成员共用一个空间，同一时间只能存储其中一个数据成员，所有的数据成员具有相同的起始地址。可以根据这一特性来测试电脑存储模式（大端OR小端），参见代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span> MyUnion</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span> MyUnion mu;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	mu.i = <span class="number">1</span>;   <span class="comment">//0x0001</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == mu.c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"little-endian"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == mu.c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"big-endian"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>术语”大端”和“小端”表示多字节值得哪一端(大端OR小端)存储在该值的起始地址。</p>
<p>3、typedef 的真正意思是给一个已经存在的数据类型(不是变量)取一个别名，而非定义一个新的数据类型。</p>
<p>4、“贪心法”：C语言有这样一个规则：每一个符号应该包含尽可能多的字符。也就是说，编译器将程序分解成符号的方法是，从左到右一个一个字符地读入，如果该字符可能组成一个符号，那么再读入下一个字符，判断已经读入的两个字符组成的字符串是否可能是一个符号的组成部分，如果是，继续读入下一个字符，重复上述判断，直到读入的字符组成的字符串已不再可能组成一个有意义的符号。注意，除了字符串和字符常量，符号的中间不能嵌有空白。</p>
<p>5、关键字 sizeof 求值是在编译的时候，根据类型确定其值。即 sizeof 只能计算在该系统该编译器环境下，数据类型的大小。</p>
<p>6、对指针进行加 1 操作，得到的是下一个元素的地址，而不是原有地址值直接加 1。所以，一个类型为 T 的指针的移动，以 sizeof(T)为移动单位。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> c[] = &#123; <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; &amp;c &lt;&lt; <span class="built_in">endl</span>;                 <span class="comment">//数组C的首地址 ox002afb04</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>*)&amp;c[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">//数组C中字符‘c’的地址 ox002afb06</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; &amp;c + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;             <span class="comment">//ox002afb07 = ox002afb04 + sizeof(c)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; c + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;              <span class="comment">//ox002afb05 = ox002afb04 + sizeof(char)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7、C语言中，当一维数组作为函数参数的时候，编译器总是把它解析成一个指向其首元素首地址的指针，一维数组作为形参传递时是不需要指定大小的，因为函数并不为数组参数分配内存空间，形参只是一个指针，指向其他地方已经分配好的内存空间，所以函数是无法知道数组的长度的，除非显式的把数组长度传递给函数。但是多维数组就需要指定了，因为多维数组的每个元素本身是另外一个数组，编译器需要知道它的维数，以便为函数形参的下标表达式进行求值。</p>
<p>在C语言中，所有非数组形式的数据实参均以传值形式调用，即对实参做一份拷贝并传递给被调用的函数，函数只能修改传递给它的那份拷贝。实际上指针也是传值形式调用，只不过函数内则通过解引用操作实际变量，就习惯把它认作是传址调用传递。编译器总是要为函数的每个参数制作临时副本(位于栈中)。</p>
<p>8、sizeof 与 strlen：sizeof 第5点讲了一部分，sizeof 操作符的结果类型是 size_t ，它在头文件中 typedef 为 unsigned int 类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*无输出结果*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-1</span>; i &lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>); ++i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"csdn"</span> &lt;&lt; <span class="built_in">endl</span>;      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*输出5个csdn*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-1</span>; i &lt; (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(<span class="keyword">int</span>); ++i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"csdn"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个 for 循环，i 与 sizeof(int) 比较时，先将 i 转换为 unsigned int，那就是一个很大的数(VC 4294967295)。</p>
<p>sizeof 是关键字，是算符， strlen 是函数。sizeof 可以用类型作参数，strlen 只能用 char * 做参数，且必须是以‘\0’结尾的。数组作 sizeof 的参数不退化，传递给strlen 就退化为指针。strlen 是在运行期确定，计算的是实际长度。</p>
<p>当适用于一个结构类型或变量，sizeof 返回实际的大小；当适用一静态的空间数组，sizeof 返回全部数组的尺寸，但是 sizeof 操作符不能返回动态的被分配了的数组或外部的数组的尺寸。</p>
<p>sizeof(express) ，其中的 express 在编译过程中是不会被编译的，而是被替代为类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(a = <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//output：4 = sizeof(int)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;                <span class="comment">//output：1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对函数使用 sizeof，在编译阶段会被替换为函数的返回值的类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="string">'c'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(fun()) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//output:1 = sizeof(char)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果函数为 void fun() {} 那么 sizeof(fun()) 编译过程中会出现错误，因为替换之后的sizeof(void) 编译无法通过。</p>
<p>清楚一点，sizeof 是在编译期计算大小的。</p>
<p>9、声明一个指针并不会自动分配任何内存。在对指针执行间接访问前，指针必须执行初始化，使它指向现有的内存，或者给它分配动态内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *p1 = &amp;c;  <span class="comment">//指向现有的内存  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *p2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));  <span class="comment">//分配动态内存</span></span><br></pre></td></tr></table></figure>

<p>10、一个表达式能作为左值，表明该表达式标识了一个特定的内存位置。马克思告诉我们，世界是物质的。计算机科学中，任何数据的存储都需要一个物质性的地址空间。不然数据搁哪？ </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/const%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/const%E7%9A%84%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">const的使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-27 15:26:30 / 修改时间：15:27:04" itemprop="dateCreated datePublished" datetime="2020-12-27T15:26:30+08:00">2020-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对于const，最为熟悉的就是，它允许你指定一个语义约束，也就是指定一个不该被改动的对象，而编译器会强制实施这项约束。const 修饰的值是只读的变量，而不是常量，其值在编译时不能被使用，因为编译器在编译时不知道其存储的内容。下面程序说明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .c file , c project</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Size = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> arr[Size];  <span class="comment">//编译出错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C语言中，编译出错，表明 const 修饰的值不是常量(C语言)。但在C++中同样的代码却不会出现编译错误，因为C++扩展了const 的含义，所以C++和C在某些细节上还是有区别的，不过const在C++中更多的是应用在类中，这里主要讨论C++中的const 。</p>
<p>含指针情况下，const 到底修饰谁？先忽略类型名，const 离谁近，就修饰谁。或者，如果关键字 const 出现在 * 左边，表示被指的对象不可改；如果出现在 * 右边，则表示指针自身不可改，如果两边都有，那就是指针和指针所指的对象不可改。</p>
<p>下面就重点探讨C++类中的 const。</p>
<p>一、const 数据成员</p>
<p>const 数据成员只在某个对象生存期内是只读变量，而对于整个类而言是可变的，因为类可以创建多个对象，不同的对象其 const 数据成员可以是不同值，const 数据成员必须被初始化，且必须使用初始化列表，不能在构造函数的函数体中初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*错误初始化方式*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Test()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		i = <span class="number">5</span>;   <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*正确初始化方式*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Test():i(<span class="number">5</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为定义是在类本身定义的时候进行的(class {}范围)，调用构造函数的时候，首先是给该实例(类的具体对象)分配空间，使用初始化列表就是在分配空间的时候，同时将其空间初始化，而在构造函数的函数体内，所有变量(常量)的空间都已经分配好了，对于const成员变量本身是不能改变其值的，构造函数的函数体{}内的操作只能是赋值，对const 成员变量赋值操作，自然是非法操作。所以const 数据成员的初始化只能在类构造函数的初始化表中进行。</p>
<p>二、const 函数</p>
<p>重头戏来了，const 最具威力的用法是面对函数声明时的应用，在一个函数声明式内，const 可以和函数返回值、各参数、函数本身(成员函数)产生关联。</p>
<p>1、const 函数返回值，即令函数返回一个const 类型，最突出的应用就是运算符重载时保证与内置类型运算符兼容，这样在某些运算符重载时，就不会自创出一些没意义的自定义类型运算符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span> ... &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs);</span><br></pre></td></tr></table></figure>

<p>这样当指向下列操作时就会编译出错。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rational a, b, c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(a * b) = c;    <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<p>如果函数返回值不为const 类型，那么上面的操作是不会出错的，但是这与内置类型不兼容，内置类型不允许对两个数值的乘积再做一次赋值。只要const 了函数返回至，那么这个函数调用就别想作左值。</p>
<p>2、const 参数，保证函数内部不会修改该值，const 作为形参自然伴随着引用或指针，不然就没有实际意义，常用的是 const 引用形参，这样既确保了被调函数不会改变主调函数的数据，又不会像非指针、非引用的参数那样要发生复制，提高效率，虽然传值形式的函数调用也不会修改主调函数的数据，但函数调用时需要额外开辟栈空间拷贝一份副本。需要注意的是形参为const 时，最好实参也为const。如果主函数里面定义了一个const 变量，那么操作该变量的函数的对应形参就必须是const。</p>
<p>3、const 成员函数，将const 实施于成员函数的目的，是为了确认该成员函数可作用于const 对象身上。成员函数声明为const 类型，就意味着该函数不允许修改类中的成员数据(除非成员数据标记为 mutable)，这样编译器看到函数定义为const ，就知道并认为该函数不会去修改类成员数据。</p>
<p>const 成员函数的定义(声明)方式怪怪的，const 放在函数名后面，函数体前面</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> random_arg)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//code</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实际上上面的函数可理解为以下形式 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> Test* <span class="keyword">this</span>, <span class="keyword">int</span> random_arg)</span> <span class="keyword">const</span> </span>&#123;	<span class="comment">/*code*/</span>  &#125;</span><br></pre></td></tr></table></figure>

<p>修饰符const 的作用是限制指针this 指向的对象(const 在 * 左边)只读，也就是调用该函数的对象是只读，该函数不可修改该对象，一旦发现函数体内有修改该对象数据的行为就报错。C++中，this指针是隐藏的，所以就有了前面的const 成员函数声明方式。</p>
<p>C++规定，const 对象只能与const 成员函数连用，目的是为了保护const 对象数据不被改写。另外const成员函数的声明与定义形式需保持一致性，否则编译器将不认为二者是同一个函数。</p>
<p>总结：</p>
<p>1）const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；</p>
<p>2）非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；</p>
<p>3）作为一种良好的编程风格，在声明一个成员函数时，若该成员函数并不对数据成员进行修改操作，应心可能将该成员函数声明为const 成员函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C%E5%90%84%E7%B1%BB%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C%E5%90%84%E7%B1%BB%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">C各类库函数的实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-27 15:25:19 / 修改时间：15:26:08" itemprop="dateCreated datePublished" datetime="2020-12-27T15:25:19+08:00">2020-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这里讨论C语言标准库中各类常用函数，以及它们的高危情况。</p>
<p><strong>1、atoi 函数</strong></p>
<p>这个函数是转换输入字符串转换为整型数。</p>
<p>对于该函数的实现需要考虑以下几个方面：</p>
<ol>
<li>输入字符串为NULL；</li>
<li>输入的字符包含前导的空格；</li>
<li>输入开始是否包含符号‘+’、‘-’；</li>
<li>输入的字符是否合法（对于十进制‘0’~‘9’为合法的输入）；</li>
<li>计算出的数值为 long int，足够判断溢出；</li>
<li>数据溢出的处理（上溢出时，返回最大正数；下溢出时，返回最大负数）；</li>
</ol>
<p>上面的实现比较棘手的就是数据溢出的处理：这里我们用计算出的数值与最大值（最小值的无符号型）/10 进行比较，小于自然不会溢出，由于负数的最大值是-2147483648，最大值是2147483647，个位数不是9，所以还需考虑等于的情况下，个位数的比较。</p>
<p>将计算出的数值与最大值（最小值的无符号型）/10 比较而不是计算出数值<em>10 与最大值比较，是因为计算出的数值</em>10 有可能本身就溢出了。比如输入字符串为”314748364“，计算出的数值为314748364，然后其*10，必然会溢出出错，所以只能进行最大值 /10 操作。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_UINT ((unsigned)~0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_INT  ((int)(MAX_UINT &gt;&gt; 1))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_INT  ((int)~MAX_INT)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atoi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	assert(str != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> minus = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (*str == <span class="string">' '</span>)<span class="comment">//跳过开头空格</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		++str;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*正负判断*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*str == <span class="string">'+'</span> || *str == <span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (*str == <span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			minus = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		++str;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*只针对数字*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (*str &gt;= <span class="string">'0'</span> &amp;&amp; *str &lt;= <span class="string">'9'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		c = *str - <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*正数溢出判断，溢出则返回相应上限值*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!minus &amp;&amp; (res &gt; MAX_INT / <span class="number">10</span> || (res == MAX_INT / <span class="number">10</span> &amp;&amp; c &gt; MAX_INT % <span class="number">10</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			res = MAX_INT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*负数溢出判断，这里的比较转换为无符号，大于则溢出*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (minus &amp;&amp; (res &gt; (<span class="keyword">unsigned</span>)MIN_INT / <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			|| (res == (<span class="keyword">unsigned</span>)MIN_INT / <span class="number">10</span> &amp;&amp; c &gt; (<span class="keyword">unsigned</span>)MIN_INT % <span class="number">10</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			res = MIN_INT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		res = res * <span class="number">10</span> + c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		++str;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> minus ? -res : res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><em>\</em>2、strcpy 函数和 memcpy 函数**</strong></p>
<p>strcpy 函数可以复制以null 为退出字符的存储器区块到另一个存储器区块内，只用于字符串的复制，字符串在存储器内以连续的字节区块组成，strcpy 可以有效复制两个配置在存储器以指针回传的字符串（也就是字符指针或字符串指针）。</p>
<p>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> * dst, <span class="keyword">const</span> <span class="keyword">char</span> * src)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把src的内容复制到dst，然后目的字符串dst指针*/</span></span><br></pre></td></tr></table></figure>

<p>先下面看看微软的写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * __cdecl <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> * dst, <span class="keyword">const</span> <span class="keyword">char</span> * src)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> * cp = dst;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (*cp++ = *src++)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		;               <span class="comment">/* Copy src over dst */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(dst);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个写法为了提高性能，减去了那些安全检查，其余漏洞后面讨论。</p>
<p>除去安全性检查，strcpy 还不允许 src 与 dst 两内存块有重叠。只要有重叠势必会写入修改src 只读区域，这是不允许的，另外有重叠区域，当dst 在高地址时，复制过来的可能就是dst 前面部分的字符了。鉴于上面分析，我们写出下面实现代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> * dst, <span class="keyword">const</span> <span class="keyword">char</span> * src)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *ret = dst;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    assert((dst != <span class="literal">NULL</span>) &amp;&amp; (src != <span class="literal">NULL</span>));<span class="comment">//检查指针的有效性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    count = <span class="built_in">strlen</span>(src);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    assert((src + count &lt; dst) || (dst + count &lt; src));<span class="comment">//检查内存是否存在重叠区域，此处非最优方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*ret++ = *src++)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面的程序最后返回 char* 类型，是为了使函数能够支持链式表达式，增加了函数的“附加值”。</p>
<p>实际上上面对于地址重叠还有一个更好的解决方法，那就是判断地址是哪部分重叠，如果dst 地址位于 src 前面，按照正常的赋值操作是没问题的，如果dst地址位于src后面，那么则从src尾部开始复制，这样可以解决地址重叠问题。代码就不贴出来了，可自行画一个示意图，一目了然。</p>
<p>另外值得注意的是：上面那个函数一样，这是strcpy 的硬伤，就是必须为目标字串分配足够的空间，如果目标字串的长度小于源字串的长度，那么在复制操作的时候会出现缓存溢出。在拷贝字符串的时候没有越界检查，这使得 strcpy 成为一个高危函数。</p>
<p>从strcpy 函数的参数就可以看出，strcpy 只能复制字符串，也不需要指定复制长度（strncpy 需要指定长度）</p>
<p>下面顺带看看memcpy 函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> * dst, <span class="keyword">const</span> <span class="keyword">void</span> * src, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *ret = dst;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    assert((dst != <span class="literal">NULL</span>) &amp;&amp; (src != <span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count--)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        *(<span class="keyword">char</span>*)dst = *(<span class="keyword">char</span>*)src; <span class="comment">//强制转换为char*，因为char占一个字节</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dst = (<span class="keyword">char</span> *)dst + <span class="number">1</span>;     <span class="comment">//这样，地址增加一个字节位移，可以全部复制</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        src = (<span class="keyword">char</span> *)src + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>memcpy 接受void* 类型的形参，这使得memcpy 函数可以复制任意内容。strcpy 拷贝是遇到‘\0’ 就停止，而memcpy 并不是遇到‘\0’ 就结束，而是一定拷贝 count 个字符。一般而言，在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy。</p>
<p><strong>3、strcat 函数</strong></p>
<p>函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strcat</span><span class="params">(<span class="keyword">char</span> * dst, <span class="keyword">const</span> <span class="keyword">char</span> * src)</span></span></span><br></pre></td></tr></table></figure>

<p>功能是把 src 所指字符串添加到 dst 结尾处（覆盖dst 结尾处的’\0’）并添加’\0’，最终返回指向 dst 的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strcat</span><span class="params">(<span class="keyword">char</span> * dst, <span class="keyword">const</span> <span class="keyword">char</span> * src)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	assert(dst != <span class="literal">NULL</span> &amp;&amp; src != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> count = <span class="built_in">strlen</span>(src);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	assert((src + count &lt; dst) || (dst + count &lt; src)); <span class="comment">/*检查是否重叠*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> * cp = dst;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (*cp)                 <span class="comment">/*先判断，再指针增加*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		cp++;                   <span class="comment">/* dst末位置 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (*cp++ = *src++);       <span class="comment">/* 拷贝 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(dst);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>src 和 dst 所指的内存区域不可以重叠且 dst 必须保证有足够的空间来容纳 src 的字符串，否则会出错。C 语言标准库中strcat 函数同 strcpy 函数一样，没有保证dst 有足够的空间容纳操作后的字符串，也使得strcat 成为一个高危函数。</p>
<p><strong>4、strcmp 函数</strong></p>
<p>该函数用于比较两个字符串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * src, <span class="keyword">const</span> <span class="keyword">char</span> * dst)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	assert((src != <span class="literal">NULL</span>) &amp;&amp; (dst != <span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*两个字符串自左向右逐个比较(ASCII值)，直到出现不同字符或dst遇'\0'为止*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*如果前面字符相同，dst的'\0'最后会参与比较*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!(ret = *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)src - *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)dst) &amp;&amp; *dst)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		++src, ++dst;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*不同返回值对应不同比较结果*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(ret);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C++%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C++%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">C++指针与引用的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-27 15:23:56" itemprop="dateCreated datePublished" datetime="2020-12-27T15:23:56+08:00">2020-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-02 21:49:34" itemprop="dateModified" datetime="2021-03-02T21:49:34+08:00">2021-03-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>先写出两者的3点区别，后面再具体分析：</p>
<ol>
<li>当引用被创建时，它必须被初始化，而指针则可以在任何时候被初始化</li>
<li>一旦一个引用被初始化为指向一个对象，它就不能被改变为对另一个对象的引用，而指针可以在任何时候指向另一个对象</li>
<li>不可能有NULL引用，必须确保引用是和一块合法的存储单元关联，而指针可以初始化为NULL</li>
</ol>
<p>从概念上讲，指针(pointers)从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变，这点后面再详细叙述。</p>
<p>而引用(references)是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的，自始至终只能依附于同一个变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"sunburn"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"saltwater"</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> &amp;rs = s1;        <span class="comment">//引用，rs代表s1</span></span><br><span class="line"><span class="built_in">string</span> *ps = &amp;s1;       <span class="comment">//指针，ps指向s1</span></span><br><span class="line">rs = s2;                <span class="comment">//rs仍然是代表s1，但是s1的值现在变成了"saltwater"</span></span><br><span class="line">                        <span class="comment">//rs一直依附于s1，rs的值就是s1的值</span></span><br><span class="line"></span><br><span class="line">*ps = <span class="string">"owl city"</span>;       <span class="comment">//修改ps指向的地址中所存放的数据，也就是s1变成了"owl city"</span></span><br><span class="line">						<span class="comment">//rs依附于s1，那么这里rs也会变成"owl city"</span></span><br><span class="line">ps = &amp;s2;               <span class="comment">//修改ps所指向的地址，ps现在指向s2，s1没有变化</span></span><br></pre></td></tr></table></figure>

<p>从上面可以得知，指针可以被重新赋值，指向另一个对象，引用却总是代表它最初获得的那个对象。</p>
<p>一般而言，当你需要不指向任何对象时，或是需要在不同时间指向不同对象时，你就应该采用指针，前一种情况你可以将指针设为NULL，后一种情况你可以改变指针所指对象（地址）。而当你确定总是会代表某个对象，而且一旦代表了该对象就不再改变，就应该选用引用。</p>
<p>有一点最基本的，那就是没有所谓的空引用（NULL references），一个引用必须总是代表一个对象，所以如果你有一个变量，其目的是用来指向(代表)另一个对象，但是也可能它不指向任何对象，那么你就应该使用指针，如果这个变量必须总是代表一个对象，并且不允许这个变量为NULL，那么就应该选用引用。说白了，就是C++允许空指针，但不允许空引用。</p>
<p>引用一定得代表某个对象，因此要求引用必须有初值，但是对指针则没有这样的要求</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"sunburn"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"saltwater"</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> &amp;rs = s1;        <span class="comment">//初始化</span></span><br><span class="line"><span class="built_in">string</span> &amp;rs;             <span class="comment">//未初始化，error</span></span><br><span class="line"><span class="built_in">string</span> *ps;             <span class="comment">//未初始化的指针，有效，但是风险高，</span></span><br><span class="line">                        <span class="comment">//实际上，在应用中是不允许的</span></span><br></pre></td></tr></table></figure>

<p>没有所谓的空引用，这就意味着当使用引用传递形参参数时，则不需要测试其参数的有效性，相反如果使用指针，通常就得测试它是否为NULL。</p>
<p>下面看看在C++中，指针和引用在函数参数传递中的区别：</p>
<p>说到指针传递，以前在C中经常同值传递进行区别，其实指针传递本质上也是值传递的方式，只不过传递的是一个地址值，值传递过程中，被调函数的形参作为被调函数的局部变量处理，即在栈中开辟内存空间存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形参的任何操作都是作为局部变量处理的，其值都存放在栈中，随着被调函数的结束而消亡，不会影响主调函数中实参变量的值，指针传递过程中的实参变量指的则是实参指针，指针传递的目的是通过被调函数去修改实参变量，那么被调函数内部的操作肯定是解指针操作，也就是透过传过来的指针的副本来操作其指向的变量（实参变量）。</p>
<p>而在引用传递过程中，被调函数的形式参数自然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址，然后被调函数对形参的任何操作都被处理成间接寻址，通过栈中存放的地址访问主调函数中的实参变量。这个和前面的说到的指针传递就相同了，都是通过栈中的地址访问主调函数的实参变量，只不过引用传递则不需要指针的解引用操作，直接对形参的操作都会被内部解析为通过地址访问实参变量，从而去影响主调函数中的实参变量。但从这点来看，引用传递其实也是指针传递，只不过这一切实现都隐藏在内部，由编译器完成。</p>
<p>我们对比看下指针传递和引用传递的反汇编代码：</p>
<p><img src="/2020/12/27/C++%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/20140826213733671" alt="img"></p>
<p>上面这两个简单的被调函数都是实现相同的功能，代码的实现上存在本质区别，一个是指针传递一个是引用传递，但是内部的操作，从其反汇编代码来看（红色框框内），两者的汇编代码是一模一样的。但是从代码的实现上来看，引用传递显得更为高效和简洁，无需检查传入参数的有效性，并且不会带入指针这个易错量。</p>
<p>注意的是上面说的一模一样是针对指针传递是以透过指针变量来操作实参变量的目的。当然，如果单一的操作指针变量，没有解引用操作，也就是只改变被调函数中的指针地址，那么它将影响不到主调函数中的相关变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1 = str2;    <span class="comment">//这里指针变量作为局部变量，不会影响到主调函数的实参变量</span></span><br></pre></td></tr></table></figure>

<p>当然，如果实际上应用指针传递形参的话，是不会这样去操作的。</p>
<p>其实二者都是地址的概念。指针指向一块内存，它的内容是所指内存的地址，而引用则是某块内存的别名，既然是别名，那么在参数传递时，引用并不会产生对象的副本，对象无需复制，效率更高，以及在函数的返回值上，返回一个对象的引用有时也是必须的，尤其在某些运算符的重载上。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/27/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/" class="post-title-link" itemprop="url">C++运算符重载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-27 15:22:33 / 修改时间：15:23:22" itemprop="dateCreated datePublished" datetime="2020-12-27T15:22:33+08:00">2020-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一、运算符的定义</p>
<p>运算符重载就是运算符的“一符多用”。重载运算符是具有特殊名称的函数：保留字 operator 后接需定义的操作符符号。像任意其他函数一样，重载操作符具有返回类型和形参表，每个操作符用于内置类型都有关联的定义，当内置操作符和类型上的操作存在逻辑对应关系时，操作符重载最有用，最直观，使用重载操作符并不是创造命名操作。</p>
<p>二、在哪种情况下使用哪种重载运算符的方式合适？</p>
<p>C++ 提供了两种重载运算符的方式，在大多数情况下：</p>
<ul>
<li>只有一个操作数的运算符（一目）使用类运算符重载方式为好；</li>
<li>一般地说，如果运算符要修改操作数（类对象）的状态（值），则应使用类运算符（成员形式）。（在计算中可能改变操作数的值得运算符被称为有副作用的运算符，诸如：=、+=、-=、*=、/=、%=、++、– 等）；</li>
<li>C++规定，运算符=、()、[ ]、-&gt; 只能采用类运算符形式重载；</li>
<li>有两个操作数的运算符（二目）使用友元运算符重载方式为好；</li>
<li>友元运算符重载方式在操作数的数据类型自动转换方面更为宽容，尤其是第一个操作数希望能够隐式类型转换时，则应采用友元形式；</li>
<li>不允许重载的运算符有：&amp;&amp;、||、. 、:: 、 * 、?: 。</li>
</ul>
<p>三、运算符重载具体讨论（返回值和参数，这里讨论几个常用的运算符）</p>
<p>默认地，重载运算符必须与内置操作符保持一致，也就是说重载后的运算符必须与本来内置操作符保持特性一致。函数最主要的两个就是返回值和形参。</p>
<p>3.1、前缀++类运算符重载函数（前缀–类似）</p>
<p>自增（自减）操作符的前置式定义：累加（递减）而后取出；后置式定义：取出而后累加（递减）。</p>
<p>我们知道，在C语言里整型变量是允许连续前缀++两次的，也叫链式操作。这样为了保证重载运算符与内置操作符++类型一致，就要求前缀++类运算符重载函数也支持连续操作（链式操作），所以前缀++类运算符重载函数的返回值必须是类名的引用。上面第二点也说了，++作为单目运算符，并且会修改操作数的值，则应定义为类运算符，这样重载函数无形参。我们就可申明该前缀++类运算符重载函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zoo</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Zoo(<span class="keyword">int</span> lion_n = <span class="number">0</span>, <span class="keyword">int</span> tiger_n = <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		lion = lion_n; tiger = tiger_n; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	~Zoo()&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Zoo&amp; <span class="keyword">operator</span>++();<span class="comment">//无参，返回值为类名的引用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> lion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> tiger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面就是前缀++类运算符重载函数的实现了</p>
<p>内置类型前缀++操作符是直接修改了操作数，然后返回修改后的操作数本身（唯一地址），不存在复制的情况，所以重载函数也应遵循这一点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Zoo&amp; Zoo::<span class="keyword">operator</span>++()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++lion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++tiger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>由于函数的返回值类型被定义为引用，所以不会发生复制，返回的是操作数本身，完全符合内置前缀++的语法定义。</p>
<p>我们再来考虑错误情况：如果前缀++类运算符重载函数的返回值是类型，也就是返回一个对象，其对应实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Zoo Zoo::<span class="keyword">operator</span>++()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++lion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++tiger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>咋一看上面的也实现了前缀++的功能，但是返回值是对象，在函数返回时会发生复制，虽然该函数成功将操作类对象的成员修改了，但是函数返回的是一个复制品，然后再执行++链式操作时，修改的会是这个复制品的值（相当于这个复制品调用前缀++类运算符重载函数），本尊并没有修改，也就是不能成功实现链式操作，不符合内置++的语法定义（ C++中，前缀++是可以连续前缀两次以上的，但后缀++则不可以）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Zoo zoo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">++(++zoo);</span><br></pre></td></tr></table></figure>

<p>上面执行后，zoo.lion = 1，zoo.tiger = 1 。并不是期望的2。</p>
<p>至于返回其余类型那就更加错误了。</p>
<p>3.2、后缀++类运算符重载函数（后缀–类似）</p>
<p>与前缀++操作符一样，后缀++也是单目操作符，也会修改操作书本身，所以二者的形参数目和类型相同，为了区别函数，后缀++操作符接受一个额外的（即，无用的）int 型形参。使用后缀++操作符时，编译器提供0作为这个形参的实参。</p>
<p>与前缀++类运算符截然相反的是，后缀++返回值的类型恰恰不能是类的引用，其目的是在返回值时引起复制，即让一个并未自增的替身对象去参加表达式的后续运算，另外C/C++在语法上不允许后缀++连续运算两次以上，也就不要求返回引用，并且必须返回 const 对象。我们看看内置后缀++操作符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j = i++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i++++;  <span class="comment">//违法</span></span><br></pre></td></tr></table></figure>

<p>内置后缀++操作符，操作数 i 本身已经完成了自增，但是后续的赋值操作并不是将自增后的 i 赋值给j，而是将并未自增的替身参与赋值运算。所以在重载后缀++类运算符的时候，我们应该考虑这点，另外必须返回一个 const 对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Zoo Zoo::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">Zoo <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;<span class="comment">//拷贝构造函数，构造复制品</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++lion;<span class="comment">//本尊自增</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++tiger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;<span class="comment">//返回复制品</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在已经定义了前缀++类运算符重载函数的情况下，后缀++类运算符重载函数一般这样实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Zoo Zoo::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">Zoo <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;<span class="comment">//拷贝构造函数，构造复制品</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	++(*<span class="keyword">this</span>);<span class="comment">//本尊自增</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;<span class="comment">//返回复制品</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.3、二目运算符重载（+=，-=，+，-） </p>
<p>先说复合赋值操作符，上面“+=”，“-=”也可认为是赋值操作符。内置+=、-=、%= 是允许进行链式操作的（如果不确定是否允许，可以写一个测试程序判断），所以为了与内置类型的操作一致，重载函数毫无疑问是返回一个引用，也避免了创建和撤销结果的临时副本。</p>
<p>但是“+”“-” 等是返回一个新的结果，这就要求算术运算符的重载不能返回一个引用，另外+的表达式也不能作为左值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = i + j + j;<span class="comment">//可以连续+，但是右边的i,j还是原值，(i+j) = i + i;错误！</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       i += (i += j);<span class="comment">//复合了赋值操作符，这样是允许的</span></span><br></pre></td></tr></table></figure>

<p>有了前面分析，不难写出上面的重载函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Zoo&amp; Zoo::<span class="keyword">operator</span>+=(Zoo &amp;rhs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	lion += rhs.lion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	tiger += rhs.tiger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继而过来讨论“+”“-”：</p>
<p><strong>返回值是一个右值</strong></p>
<p>前面说到了，“+”“-”是返回一个新的结果，算术运算符通常产生一个新值，该值是两个操作数的计算结果，它不同于任一操作数且在一个局部变量中计算，返回对那个变量的引用是一个运行时错误。通俗一点，假如算术运算符重载函数返回一个对象的引用，这个引用是两个操作的计算结果，它的本体就会是一个局部变量（对象），返回一个局部变量的引用，是错误的。所以对于类算术运算符的重载，只能返回一个右值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Zoo <span class="keyword">operator</span>+(Zoo &amp;first, Zoo &amp;second)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">Zoo <span class="title">ret</span><span class="params">(first)</span></span>;<span class="comment">//拷贝构造函数，构造一个局部变量，用于返回值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ret += second;<span class="comment">//运算操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;<span class="comment">//返回一个值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二目算术运算符重载通常使用友元运算符重载方式。</p>
<p>从上面也可以看出，类运算符的重载最好与内置运算符保持一致，虽然没硬性规定，但这俨然成了一个默认规定。</p>
<p>另外 !（逻辑反）、~（按位与）、-（负号）等与二目算术运算符有类似之处，那就他们都不会修改原对象数据成员，而是将运算结果交给一个新值，所以在重载时，需要构造一个临时对象作为返回值，返回值也就同样不能是引用。</p>
<p>3.4、输入输出操作符重载</p>
<p>支持I/O操作的类所提供的I/O操作接口，一般应该与标准库iostream为内置类型定义的接口相同。</p>
<p>1、输出操作符 &lt;&lt; 的重载</p>
<p>为了与I/O标准库一致，操作符应接受 ostream&amp; 作为第一个形参，对类类型 const 对象的引用作为第二个形参，并返回对 ostream 形参的引用。</p>
<p>重载输出操作符可能相对于比较难理解，这里简单的说下，我们只能以自定义类的友元函数的形式重载这两个运算符，这是因为如果我们用成员函数的形式来重载的话，就要改动系统的流类 istream 和 ostream 定义，这是C++不允许的，如果不定义为友元函数的话，将无法调用类对象成员数据输出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; stream, <span class="keyword">const</span> Zoo &amp;object)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//对object所引用的对象的数据进行的输出操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	stream &lt;&lt; object.lion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	stream &lt;&lt; object.tiger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> stream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看上面这个输出操作符重载函数，第一个参数是 ostream 类的引用，而函数的返回值也是 ostream 类的引用。毫无疑问，我们调用这个运算符重载函数时。实参肯定是 cout，这样就造成了这样一种情况：实参 stream 引用 cout，而函数的返回值又引用 stream，等于函数返回值引用的实体还是 cout。这样做的目的是实现了连续的输出操作。当执行下面语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; zoo_a &lt;&lt; zoo_b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面 cout &lt;&lt; zoo_a 实质就是调用 operator&lt;&lt;(cout, zoo_a),然后返回 cout</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下一个 &lt;&lt; 就相当于执行 cout &lt;&lt; zoo_b, 同上</span></span><br></pre></td></tr></table></figure>

<p>我们不能将该操作符重载函数定义为类的成员函数，否则，左操作数将只能是该类类型的对象。IO操作符通常要对非公用数据成员进行读写，因此，类通常将IO操作符（输入输出）设为友元。</p>
<p>2、输入操作符 &gt;&gt; 的重载</p>
<p>为了与IO标准库一致，操作符应接受 istream&amp; 作为第一个形参，指向它要读的流，并且返回的也是对同一个流的引用（链式操作）。它的第二个形参是对要读入的对象的非 const 引用，该形参必须为非 const，因为输入操作符的目的是将数据读到这个对象中。</p>
<p>更重要但通常重视不够的是，输入和输出操作符有如下区别：输入操作符必须处理错误和文件结束的可能性。</p>
<p>输入期间的错误：任何读操作都可能因为提供的值不正确而失败；任何读入都可能碰到输入流中的文件结束或其他一些错误。也就需要对输入进行附加检查，发现有这些错误就需要我们进行处理。</p>
<p>3.5、不能重载的运算符 &amp;&amp;、|| 和 , 操作符</p>
<p>和 C 一样，C++ 对于真假值表达式采用所谓骤死式评估方式。意思是一旦该表达式的真假值去顶，纵使表达式中还有部分尚未检验，整个评估工作仍告结束。比如下面这种情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((p != <span class="literal">NULL</span>) &amp;&amp; (<span class="built_in">strlen</span>(p) &gt; <span class="number">10</span>) ……</span><br></pre></td></tr></table></figure>

<p>你无需担心调用 strlen 时 p 是否为 NULL 指针，因为如果 p 是否为NULL 的测试结果是否定的，strlen 就绝不会被调用。事实上，对一个 NULL 指针调用 strlen，结果未可预期。</p>
<p>回到重载，C++ 允许我们为用户定制型别量身定做各类操作符，包括 &amp;&amp; 和 ||，操作符重载语义上是允许的，但是我们要考虑重载会不会改变对应内置操作符的规则。拿 &amp;&amp; 和 || 来说，重载则是对 operator &amp;&amp; 和 operator || 两函数进行重载工作，值得注意的是，函数调用语义将会取代骤死式语义，也就是说，如果你将operator &amp;&amp; 重载，下面这个虱子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression1 &amp;&amp; expression2) ……</span><br></pre></td></tr></table></figure>

<p>会被编译器视为以下两者之一：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression1.<span class="keyword">operator</span>&amp;&amp;(expression2)) ……</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设 operator&amp;&amp; 是个 member function</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">operator</span>&amp;&amp;(expression1, expression2)) ……</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设 operator&amp;&amp; 是个全局函数</span></span><br></pre></td></tr></table></figure>

<p>上面函数调用语义和所谓骤死式语义有两个重大的不同。第一，当函数调用动作被执行起来，所有参数值都必须评估完成，所以当我们调用 operator&amp;&amp; 和 operator|| 时，两个参数都已评估完成，没有什么骤死式语义。第二，C++ 语言规格并未明定函数调用动作中各参数的评估次序，所以没办法知道 expression1 和 expression2 哪个会先被评估，而内置的真假值表达式，则总是由左向右评估其自变量。</p>
<p>C++ 中，运算符重载的一个重要参考就是：不能修改运算符的内置语义。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">匡俊桦</p>
  <div class="site-description" itemprop="description">回忆的沙漏将曾经屈指可数的日子渐渐淡去</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">202</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">匡俊桦</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
