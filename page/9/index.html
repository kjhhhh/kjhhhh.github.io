<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:type" content="website">
<meta property="og:title" content="KJHの博客">
<meta property="og:url" content="http://yoursite.com/page/9/index.html">
<meta property="og:site_name" content="KJHの博客">
<meta property="og:description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="匡俊桦">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>KJHの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KJHの博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录&回忆</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/04/Filter&Listener%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/04/Filter&Listener%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Filter&Listener</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-04 19:14:40 / 修改时间：19:15:32" itemprop="dateCreated datePublished" datetime="2021-11-04T19:14:40+08:00">2021-11-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h2><pre><code>1. Filter：过滤器
2. Listener：监听器</code></pre><h1 id="Filter：过滤器"><a href="#Filter：过滤器" class="headerlink" title="Filter：过滤器"></a>Filter：过滤器</h1>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/11/04/Filter&Listener%E7%AC%94%E8%AE%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/" class="post-title-link" itemprop="url">穿越线程的迷宫</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-04 19:12:47 / 修改时间：19:13:29" itemprop="dateCreated datePublished" datetime="2021-11-04T19:12:47+08:00">2021-11-04</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>32k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>29 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="穿越线程的迷宫"><a href="#穿越线程的迷宫" class="headerlink" title="穿越线程的迷宫"></a>穿越线程的迷宫</h1><ol>
<li>底层知识，从根上开始 - 计算机的发展史</li>
<li>不懂硬件，就不懂软件 - CPU的电路原理</li>
<li>没有压迫，就没有性能 - 谈谈进程与线程</li>
<li>有多线程，就会有同步（1） - 缓存的一致性协议</li>
<li>有多线程，就会有同步（2） - 编译器屏障与指令屏障</li>
<li>有多线程，就会有同步（3）关中断、总线锁、缓存锁</li>
<li>加餐 在硬件的基础之上 - 操作系统级别的并发控制</li>
<li>超脱于语言之外，扎根于语言之内 - 底层同步与语言的关系</li>
<li>JAVA多线程起步</li>
<li>JVM如何启动线程（聊聊Hotspot线程管理）</li>
<li>解析可见性</li>
<li>解析有序性</li>
<li>解析原子性 - 深度解析synchronized</li>
<li>解析JUC - AQS源码</li>
<li>解析线程池</li>
<li>解析协程/纤程</li>
<li>JAVA多线程大课<ol>
<li>启动线程的5种方法</li>
<li>常见线程方法</li>
<li>线程的状态</li>
<li>线程打断</li>
<li>优雅的结束线程</li>
<li>线程组</li>
<li>并发线程的特性</li>
<li>JUC的新锁</li>
<li>并发容器</li>
<li>线程池</li>
</ol>
</li>
<li>JMH线程性能</li>
<li>Disruptor高性能框架</li>
</ol>
<h2 id="计算机的历史"><a href="#计算机的历史" class="headerlink" title="计算机的历史"></a>计算机的历史</h2><h3 id="算盘和机械计算机"><a href="#算盘和机械计算机" class="headerlink" title="算盘和机械计算机"></a>算盘和机械计算机</h3><p>有很多民族自豪感爆棚的兄弟会把算盘当成计算机的起源，还有爆破天的兄弟会把阴阳当成二进制0和1的起源，我觉得这件事儿就有点儿不靠谱了</p>
<p>如果非要追究计算机的鼻祖，那就得讲讲17世纪前欧洲的故事，最早的计算机其实是计算器，就是算数用的，在欧洲工业工业革命的时候，大量的工业模具需要计算，欧洲又没有中国传统的计算器 - 算盘，就催生了很多科学家发明自己的计算器（对，就是计算器，就是以前菜市场还在使用的那种，还不能称之为现在的计算机），这其中有个NB的人物，这个人叫布莱士帕斯卡，我们的压强单位（帕，千帕，百帕，兆帕）等等，就是以这哥们儿的名字命名，还有，计算机语言里面有一种叫做Pascal，就是为了纪念他。</p>
<p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/101123110023393.jpg" alt="布莱士·帕斯卡"></p>
<p>就是这么个NB的人物，发明了最早的机械计算器，长这样儿：</p>
<p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/444cbb40e22e417e9ffab508724818a4.jpg" alt="img"></p>
<p>经过后人的逐步改进，机械计算机的最后发展堪称精美，有长这样儿的：</p>
<p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/52e9f4dfda744a46892344a9087bafc6.jpg" alt="img"></p>
<p>还有长这样儿的：</p>
<p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/5e291b9d8dea4779978467df7ed25c40.jpg" alt="img"></p>
<p>还有更NB的：</p>
<p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/bb7c6a9e88dd4a78aa69a0aa5f02b1f7.jpg" alt="img"></p>
<p>机械计算机改进者中有个人值得一提，他就是德国百科全书式的天才，17世纪的亚里士多德 – 莱布尼茨！</p>
<p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/v2-81dce436811f07318d7b027f8228a608_qhd.jpg" alt="img"></p>
<p>莱伯尼兹这个人又是个大牛，他既懂物理又懂数学（物理数学不分家），著名的微积分基本定理，牛顿莱布尼茨公式，就是莱布尼茨发明的，当然这里面是牛顿跟莱布尼茨或者说英国跟欧洲大陆的恩怨情仇。简单说，莱布尼茨发表论文创立微积分公式，牛顿当时是英国皇家学会的老大，话语权影响力比较大。牛顿说莱布尼茨发表的公式是参考了牛顿三年前的笔记，莱布尼茨嗓门不够响，争不过牛顿，所以没有办法，后人就把这个公式称为牛顿莱布尼茨公式。</p>
<p>一个人想在社会取得回报或者想发挥巨大作用，就必须要明白这个社会的运行机制，通过这件事儿，大家应该明白话语权的（传媒、笔杆子）重要性，如果还不能理解，参考美国把上个世纪的美国病毒命名为西班牙病毒这件事儿，当然最近又想把新冠病毒扣在我们脑袋上，就是因为他把控了话语权。衍生出来你应该明白的是，历史是个任人打扮的小姑娘，你看到的，你听到的，都是别人想让你看到和听到的，所以你要进行深度的思考，他是谁？为什么这么说？他说的是真的吗？对我有没有什么企图？多问自己几个为什么，你会慢慢从白痴成为智者。</p>
<p>扯远了，还说回来莱布尼茨，他除了改进机械计算机以外，还有一个重要的发明，那就是大名鼎鼎的二进制！（这里终于跟现代IT技术关联起来了）据说二进制的发明是参考中国古代的阴阳太极图而创作出来的，对此，我觉得倒是真的有可能。因为莱布尼茨有一本著名的著作，叫做《论中国人的自然哲学》，说明这个人对中国是有研究的。而且，他发明了二进制以后，还通知了当时的康熙大帝，因为他认为康熙大帝是个数学迷（对此我深表怀疑）。</p>
<p>当然，机械计算机又大又笨重，早就被现代的电子计算机所取代，不过说句题外话，机械计算机也有电子计算机所不具备的优点，就是结实耐用，几百年都不坏，而且，还不用电 😄，谁要是大学食堂里面打饭收费做计算的时候来这么一台，那绝对是学妹眼中最酷的仔！</p>
<p>顺便也来一张现代电子计算机的鼻祖（当然，第一台电子计算机这件事儿也是见仁见智，美国嗓门大，所以现在资料大多认为1946诞生于美国宾夕法尼亚大学的“ENIAC”是世界上第一台电子计算机），它长这样儿：</p>
<p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/e5ead1a6e96945298e46b8038643ffa5.png" alt="image.png"></p>
<p>这是个庞然大物，它大概占地一个别墅，跟一辆前苏联虎式坦克一样重，每个小时耗电150度，但是，每秒钟的计算量仅区区的5000次，要知道现在手机上的芯片的计算速度可以达到每秒10 0000 0000 0000次。不过就是这样一台还比上菜市场计算器的东西，开启了20世纪最NB的数字化革命！从此之后，计算机行业飞速发展，造就了现在所谓的信息化大革命。</p>
<p>严格讲，这台机器应该称作电子管计算机，因为，这里面用的零件全部都是电子管，电子管如果开关的速度太快，很容易就会坏掉，据说这台机器每天都会有电子管冒烟儿，工程师在寻找和修复每一个电子管中疲于奔命，想象一天24小时，计算时间仅有半小时，剩下的23个半小时都是在寻找和修复坏掉的点，这是多么让人抓狂的一件事。如果你不能理解这件事儿，想象一下一个灯泡每秒不停的开关5000次，它会不会坏掉。而且，电子管还有很严重的发热问题，需要把风扇进行紧密的排布，这也是一个工艺难题。</p>
<p>不过，幸运的是，在这台又笨重毛病又多的计算机问世的第二年，也就是1947年，美国贝尔实验室研究发明了晶体管，和电子管相比，晶体管体积又小，耗电还低，最重要每秒开关几十万上亿次都不带坏的，从这一刻开始，计算机革命才真正的进入了突飞猛进的时代。</p>
<p>这堂课，我们要讲的就是计算机的原理。</p>
<h2 id="CPU的原理"><a href="#CPU的原理" class="headerlink" title="CPU的原理"></a>CPU的原理</h2><p><strong>为什么讲线程要讲CPU？因为线程和CPU有一对一的对应关系！（超线程除外）</strong></p>
<p>当然，现代的计算机的核心，也就是芯片，是由10 0000 0000 个零件构成，我没有办法带你走遍这里面的每一个细节，不过，作为高级语言的程序员，我会带你走到足够深的深度，让你能够深入理解你写的每一行代码到底在计算机内部是怎么转换成电信号，从而被精密执行的。这一点很重要，因为这会给你带来“通透感”（原谅我找不到更好的形容词，现在很多程序员是没有经过科班训练的，是根据业务进行速成的，对这样的小伙伴儿来说，你写的代码虽然可以工作，但是它对你是一个黑盒子，你看不到代码背后的一切，从而也就无法进行更深入的理解和更准确的调优，总之，我个人非常喜欢这种通透感，我不喜欢一个技术对我来说是黑盒，是秘密，希望你也能理解和享受这种通透感）</p>
<p>好吧，让我们揭开代码背后的神秘世界。</p>
<p>还要从一个故事谈起。</p>
<p>我小时候最喜欢的女同学叫小芳，长的好看又善良，我们俩情投意合，每天放学后都约会共同进步，童年的时候山青水白，鸟语花香，环境特别好，我们的年纪都很小，我爱谈天她爱笑，有一回并肩坐在桃树下，风在林梢鸟在叫，不知怎么就睡着了，梦里花落知多少…</p>
<p>不要打断我，让我陷在美好的回忆中不可自拔一会儿。</p>
<p>只不过后来大人发现了我们的联系，用他们自带的污秽的思想，认为我们的关系是污秽的，是不纯洁的，我们当时还没有罗密欧与朱丽叶，梁山伯与祝英台这样的觉悟，不懂得以死相争，所以就被双方家长棒打鸳鸯，各自关了禁闭。</p>
<p>不过这个难不倒刚刚学了电学的我，我们就设立了这样入门级别的电路：</p>
<p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/19d88abf0173431ba20e7671b2231276.png" alt="image.png"></p>
<p>我还发明了灯泡语言：</p>
<ul>
<li>亮亮 = 放</li>
<li>亮灭 = 学</li>
<li>灭亮 = 等</li>
<li>灭灭 = 我</li>
</ul>
<p>当然你会发现如果只有两个信号的组合，就最多表示四个字，如果想沟通更顺畅，我只要增加信号的组合长度就可以了，比如三个信号，我就可以表示八个字</p>
<ul>
<li>亮亮亮 = 放</li>
<li>亮亮灭 = 学</li>
<li>亮灭亮 = 等</li>
<li>亮灭灭 = 我</li>
<li>灭灭亮 = 一</li>
<li>灭灭灭 = 起</li>
<li>灭亮灭 = 电</li>
<li>灭亮亮 = 影</li>
</ul>
<p>如果想交流的更加复杂，我可以增加更长的信号组合，比如我如果用16个长度的信号，就可以表示2^16个汉字，这个数字是65536，要知道，我们日常的汉字常用的话也就4000个左右，整个康熙字典的总字数也仅仅47000个，我用灯泡信号的长度仅需要16个信号长，就足矣涵盖中文的交流了。</p>
<p>思考题：如果仅需要覆盖日常交流（4000个汉字），我需要的信号组合的长度至少是多少？</p>
<p>灯泡语言有些复杂，我结合莱布尼茨的二进制，用1来代表灯泡亮（通电），用0来代表灯泡灭（断电），这样我和小芳就有了自己的通信语言，比如下面这句话，你猜我说了什么？</p>
<p>111 110 001 000 = (? )把答案写到括号里。</p>
<p>话说到这里，不知道大家有没有发现，我发明了一种汉字编码，就是把特定的汉字用0和1的组合表示出来，注意，汉字的编码并不是只有一种方式，完全有可能发生的是，在一种的编码方式中，111代表’我’，而在另外一种编码方式中111代表’中’，如果我们在解析一段编码的用错了编码格式，就会出现平时经常遇见的’乱码’问题。</p>
<p>思考题：A编码中，111 = 我 110 = 你，B编码中 111 = 沙 110 = 雕，那么下面这段话究竟代表什么呢？<br>110 111 110</p>
<p>再有了第一个电路的基础之上，我有设计了下面的电路：</p>
<p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/f61654b6c67143bd9b8bc28ed749a16d" alt="图解 | 你管这破玩意叫计算机？"></p>
<p>这里就有了输入和输出的概念了</p>
<table>
<thead>
<tr>
<th>输入1</th>
<th>输入2</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>可以用这样的符号表示：</p>
<p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/9d893a0b94d040a4b61857ac8439839e" alt="图解 | 你管这破玩意叫计算机？"></p>
<p>也可以有这样的电路：</p>
<p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/f4938c4bfadd427898d739b523de32be" alt="图解 | 你管这破玩意叫计算机？"></p>
<p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/2b3c36a6522d4633b7762edde1c588a0" alt="图解 | 你管这破玩意叫计算机？"></p>
<p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/384e719b58254e55bb092e9493dc7421" alt="图解 | 你管这破玩意叫计算机？"></p>
<h3 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h3><table>
<thead>
<tr>
<th>输入1</th>
<th>输入2</th>
<th>加和输出</th>
<th>进位输出</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/2be81616637145c695c751d9921e8815" alt="图解 | 你管这破玩意叫计算机？"></p>
<p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/a0f2dad9da0048b5894cefcf140d4440" alt="图解 | 你管这破玩意叫计算机？"></p>
<p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/3e00029bb4a548a68dc44ce8c3560e86" alt="图解 | 你管这破玩意叫计算机？"></p>
<p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/961f8e2755e14a5793bdb69881ba7511" alt="图解 | 你管这破玩意叫计算机？"></p>
<p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/331a30cb576a4811a1a67aedb8c079cc" alt="图解 | 你管这破玩意叫计算机？"></p>
<p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/c59d28c946cd47b880daa53d47350b47" alt="图解 | 你管这破玩意叫计算机？"></p>
<h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/8fbd3c9b03f54fa5b7a367a62a55da52" alt="图解 | 你管这破玩意叫计算机？"></p>
<h3 id="ram-保存信号"><a href="#ram-保存信号" class="headerlink" title="ram 保存信号"></a>ram 保存信号</h3><p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/15f2fd8a089742d394b1605acef992d1" alt="图解 | 你管这破玩意叫计算机？"></p>
<p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/e17f9177a1d7442598941926c82efe3f" alt="图解 | 你管这破玩意叫计算机？"></p>
<p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/400a0a4909dd474fa421ad919e0aac70" alt="图解 | 你管这破玩意叫计算机？"></p>
<p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/3c79d7bf4fc946328e17a34f570f5b49" alt="图解 | 你管这破玩意叫计算机？"></p>
<p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/b51aaf1d8008469db5bf89c6f2e5b17e" alt="图解 | 你管这破玩意叫计算机？"></p>
<h3 id="程序-自动化（时钟信号"><a href="#程序-自动化（时钟信号" class="headerlink" title="程序 - 自动化（时钟信号 +"></a>程序 - 自动化（时钟信号 +</h3><p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/9248fe21ffde4be7b07f66a51ebc226b" alt="图解 | 你管这破玩意叫计算机？"></p>
<h3 id="荐书"><a href="#荐书" class="headerlink" title="荐书"></a>荐书</h3><p>《编码 隐匿在计算机软硬件背后的语言》《Code: The Hidden Language of Computer Hardware and Software》</p>
<h2 id="程序的执行"><a href="#程序的执行" class="headerlink" title="程序的执行"></a>程序的执行</h2><p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/3b60e700c1cf4992bf24e77e57be12e2.png" alt="image.png"></p>
<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>一个程序，读入内存，全是0和1构成</p>
<p>从内存读入到CPU计算，这个时候要通过总线</p>
<p>怎么区分一段01的数据到底是数据还是指令？</p>
<p>总线分类为三种：控制线 地址线 数据线</p>
<p>一个程序的执行，首先把可执行文件放到内存，找到起始（main)的地址，逐步读出指令和数据，进行计算并写回到内存。</p>
<p>什么是进程？什么是线程？</p>
<p>一个程序进入内存，被称之为进程？一个QQ.exe可以运行多份儿吗？</p>
<p>同一个进程内部：有多个任务并发执行的需求（比如，一边计算，一边接收网络数据，一边刷新界面）</p>
<p>能不能用多进程？可以，但是毛病多，最严重的毛病是，我可以很轻易的搞死别的进程</p>
<p>线程的概念横空出世：共享空间，不共享计算</p>
<p>进程是静态的概念：程序进入内存，分配对应资源：内存空间，进程进入内存，同时产生一个主线程</p>
<p>线程是动态的概念：是可执行的计算单元（任务）</p>
<p>一个ALU同一个时间只能执行一个线程</p>
<p>同一段代码为什么可以被多个线程执行？</p>
<h3 id="线程的切换"><a href="#线程的切换" class="headerlink" title="线程的切换"></a>线程的切换</h3><p>保存上下文，保存现场</p>
<p>问题：是不是线程数量越多，执行效率越高？（初级）<br>展开：调度算法怎么选？（难）</p>
<p>问题：单核CPU多线程执行有没有意义？（初级）</p>
<p>问题：对于一个程序，设置多少个线程合适？（线程池设定多少核心线程？）（中高级）</p>
<p>线程调度器算法（平均时间片、CFS（考虑权重））</p>
<p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/870f14ef9a3d45f6b3ae0dba945be176.png" alt="image.png"></p>
<h2 id="CPU的并发控制"><a href="#CPU的并发控制" class="headerlink" title="CPU的并发控制"></a>CPU的并发控制</h2><h3 id="关中断"><a href="#关中断" class="headerlink" title="关中断"></a>关中断</h3><h3 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h3><p>CPU的速度和内存的速度（100 ：1）</p>
<p>这里的速度值得是ALU访问寄存器的速度比访问内存的速度快100倍</p>
<p>为了充分利用CPU的计算能力，在CPU和内存中间引入缓存的概念（工业上的妥协，考虑性价比）</p>
<p>现在的工业实践，多采用三级缓存的架构</p>
<p>缓存行：一次性读取的数据块</p>
<p>程序的局部性原理：空间局部性 时间局部性</p>
<p>如果缓存行大：命中率高，但读取效率低。如果缓存行小：命中率低，但读取效率高。</p>
<p>工业实践的妥协结果，目前(2021）的计算机多采用64bytes （64 * 8bit）为一行</p>
<p>由于缓存行的存在，我们必须有一种机制，来保证缓存数据的一致性，这种机制被称为缓存一致性协议。</p>
<h3 id="系统屏障"><a href="#系统屏障" class="headerlink" title="系统屏障"></a>系统屏障</h3><p>程序真的是按照“顺序”执行的吗？</p>
<h4 id="CPU的乱序执行"><a href="#CPU的乱序执行" class="headerlink" title="CPU的乱序执行"></a>CPU的乱序执行</h4><p>Disorder这个程序，证明乱序执行的确存在</p>
<p>为什么会乱序？主要是为了提高效率（在等待费时的指令执行的时候，优先执行后面的指令）</p>
<h4 id="线程的as-if-serial"><a href="#线程的as-if-serial" class="headerlink" title="线程的as-if-serial"></a>线程的as-if-serial</h4><p>单个线程，两条语句，未必是按顺序执行</p>
<p>单线程的重排序，必须保证<em>最终一致性</em></p>
<p>as-if-serial：看上去像是序列化（单线程）</p>
<h4 id="会产生的后果"><a href="#会产生的后果" class="headerlink" title="会产生的后果"></a>会产生的后果</h4><p>多线程会产生不希望看到的结果</p>
<p>ThisEscape（this 溢出问题）</p>
<p>推荐《Effective Java》- 不要在构造方法中启动线程！</p>
<h4 id="哪些指令可以互换顺序"><a href="#哪些指令可以互换顺序" class="headerlink" title="哪些指令可以互换顺序"></a>哪些指令可以互换顺序</h4><p>hanppens-before原则（JVM规定重排序必须遵守的规则）</p>
<p>JLS17.4.5 （不需要记住）</p>
<p>•程序次序规则：同一个线程内，按照代码出现的顺序，前面的代码先行于后面的代码，准确的说是控制流顺序，因为要考虑到分支和循环结构。</p>
<p>•管程锁定规则：一个unlock操作先行发生于后面（时间上）对同一个锁的lock操作。</p>
<p>•<strong>volatile变量规则：对一个volatile变量的写操作先行发生于后面（时间上）对这个变量的读操作。</strong></p>
<p>•线程启动规则：Thread的start( )方法先行发生于这个线程的每一个操作。</p>
<p>•线程终止规则：线程的所有操作都先行于此线程的终止检测。可以通过Thread.join( )方法结束、Thread.isAlive( )的返回值等手段检测线程的终止。</p>
<p>•线程中断规则：对线程interrupt( )方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupt( )方法检测线程是否中断</p>
<p>•对象终结规则：一个对象的初始化完成先行于发生它的finalize()方法的开始。</p>
<p>•传递性：如果操作A先行于操作B，操作B先行于操作C，那么操作A先行于操作C</p>
<h4 id="禁止编译器乱序"><a href="#禁止编译器乱序" class="headerlink" title="禁止编译器乱序"></a>禁止编译器乱序</h4><h4 id="使用内存屏障阻止指令乱序执行"><a href="#使用内存屏障阻止指令乱序执行" class="headerlink" title="使用内存屏障阻止指令乱序执行"></a>使用内存屏障阻止指令乱序执行</h4><p>内存屏障是特殊指令：看到这种指令，前面的必须执行完，后面的才能执行</p>
<p>intel : lfence sfence mfence(CPU特有指令)</p>
<h4 id="JVM中的内存屏障"><a href="#JVM中的内存屏障" class="headerlink" title="JVM中的内存屏障"></a>JVM中的内存屏障</h4><p>所有实现JVM规范的虚拟机，必须实现四个屏障</p>
<p>LoadLoadBarrier LoadStore SL SS</p>
<h4 id="volatile的底层实现"><a href="#volatile的底层实现" class="headerlink" title="volatile的底层实现"></a>volatile的底层实现</h4><p>volatile修饰的内存，不可以重排序，对volatile修饰变量的读写访问，都不可以换顺序</p>
<p>1: volatile i</p>
<p>2: ACC_VOLATILE</p>
<p>3: JVM的内存屏障</p>
<p>屏障两边的指令不可以重排！保障有序！</p>
<p>happends-before</p>
<p>as - if - serial<br>4：hotspot实现</p>
<p>bytecodeinterpreter.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> field_offset = cache-&gt;f2_as_index();</span><br><span class="line">           <span class="keyword">if</span> (cache-&gt;is_volatile()) &#123;</span><br><span class="line">             <span class="keyword">if</span> (support_IRIW_for_not_multiple_copy_atomic_cpu) &#123;</span><br><span class="line">               OrderAccess::fence();</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure>

<p>orderaccess_linux_x86.inline.hpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::fence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (os::is_MP()) &#123;</span><br><span class="line">     <span class="comment">// always use locked addl since mfence is sometimes expensive</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">ifdef</span> AMD64</span></span><br><span class="line">     <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"lock; addl $0,0(%%rsp)"</span> : : : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">     <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"lock; addl $0,0(%%esp)"</span> : : : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>LOCK 用于在多处理器中执行指令时对共享内存的独占使用。<br>它的作用是能够将当前处理器对应缓存的内容刷新到内存，并使其他处理器对应的缓存失效。</strong><br><strong>另外还提供了有序的指令无法越过这个内存屏障的作用。</strong></p>
</blockquote>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p>DCL单例要不要加volatile？（难）</p>
<h3 id="总线-缓存锁"><a href="#总线-缓存锁" class="headerlink" title="总线/缓存锁"></a>总线/缓存锁</h3><p>lock;</p>
<h3 id="荐书-黄俊老师的书《深入理解JAVA并发原理》（出版中）"><a href="#荐书-黄俊老师的书《深入理解JAVA并发原理》（出版中）" class="headerlink" title="荐书 黄俊老师的书《深入理解JAVA并发原理》（出版中）"></a>荐书 黄俊老师的书《深入理解JAVA并发原理》（出版中）</h3><h2 id="操作系统的并发控制"><a href="#操作系统的并发控制" class="headerlink" title="操作系统的并发控制"></a>操作系统的并发控制</h2><h3 id="信号量与P-V原语"><a href="#信号量与P-V原语" class="headerlink" title="信号量与P-V原语"></a>信号量与P-V原语</h3><h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><h3 id="中断控制与内核抢占"><a href="#中断控制与内核抢占" class="headerlink" title="中断控制与内核抢占"></a>中断控制与内核抢占</h3><h3 id="顺序锁"><a href="#顺序锁" class="headerlink" title="顺序锁"></a>顺序锁</h3><h3 id="rcu锁"><a href="#rcu锁" class="headerlink" title="rcu锁"></a>rcu锁</h3><h2 id="JAVA启动线程的5种方法"><a href="#JAVA启动线程的5种方法" class="headerlink" title="JAVA启动线程的5种方法"></a>JAVA启动线程的5种方法</h2><ol>
<li>new MyThread().start()</li>
<li>new Thread(r).start()</li>
<li>new Thread(lamda).start()</li>
<li>ThreadPool</li>
<li>Future Callable and FutureTask</li>
</ol>
<h2 id="常见的线程方法"><a href="#常见的线程方法" class="headerlink" title="常见的线程方法"></a>常见的线程方法</h2><p><strong>我们来认识几个线程的方法</strong></p>
<p>sleep() yield() join()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_000;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T03_Sleep_Yield_Join</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">					<span class="comment">//testSleep();</span></span><br><span class="line">					<span class="comment">//testYield();</span></span><br><span class="line">        testJoin();</span><br><span class="line">    &#125; </span><br><span class="line">		<span class="comment">/*Sleep,意思就是睡眠，当前线程暂停一段时间让给别的线程去运行。Sleep是怎么复活的？由你的睡眠时间而定，等睡眠到规定的时间自动复活*/</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"A"</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    <span class="comment">//TimeUnit.Milliseconds.sleep(500)</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">/*Yield,就是当前线程正在执行的时候停止下来进入等待队列（就绪状态，CPU依然有可能把这个线程拿出来运行），回到等待队列里在系统的调度算法里头呢还是依然有可能把你刚回去的这个线程拿回来继续执行，当然，更大的可能性是把原来等待的那些拿出一个来执行，所以yield的意思是我让出一下CPU，后面你们能不能抢到那我不管*/</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testYield</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"A"</span> + i);</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">10</span> == <span class="number">0</span>) Thread.yield();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"------------B"</span> + i);</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">10</span> == <span class="number">0</span>) Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">/*join， 意思就是在自己当前线程加入你调用Join的线程（），本线程等待。等调用的线程运行完了，自己再去执行。t1和t2两个线程，在t1的某个点上调用了t2.join,它会跑到t2去运行，t1等待t2运行完毕继续t1运行（自己join自己没有意义） */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"A"</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    <span class="comment">//TimeUnit.Milliseconds.sleep(500)</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t1.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"A"</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    <span class="comment">//TimeUnit.Milliseconds.sleep(500)</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><strong>小节说明：</strong></p>
<ul>
<li>本节重要程度：中 （帮助理解线程问题，保障知识完整性，面试很少考）</li>
<li>本节难度：低</li>
</ul>
<p><strong>JAVA的6中线程状态:</strong></p>
<ol>
<li>NEW ： 线程刚刚创建，还没有启动</li>
<li>RUNNABLE ： 可运行状态，由线程调度器可以安排执行<ul>
<li>包括READY和RUNNING两种细分状态</li>
</ul>
</li>
<li>WAITING： 等待被唤醒</li>
<li>TIMED WAITING： 隔一段时间后自动唤醒</li>
<li>BLOCKED： 被阻塞，正在等待锁</li>
<li>TERMINATED： 线程结束</li>
</ol>
<p><strong>如下图：</strong></p>
<p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/42671f644ccc44b08fbd5a2c46418e64.png" alt="image.png"></p>
<p>线程状态测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_000_threadbasic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mashibing.util.SleepHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * title:$&#123;file_name&#125;</span></span><br><span class="line"><span class="comment"> * 关于线程状态的实验</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 马士兵 http://www.mashibing.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> $&#123;date&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T04_ThreadState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"2: "</span> + <span class="keyword">this</span>.getState());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        System.out.println(<span class="string">"1: "</span> + t1.getState());</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        System.out.println(<span class="string">"3: "</span> + t1.getState());</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                System.out.println(<span class="string">"t2 go on!"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t2.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"4: "</span> + t2.getState());</span><br><span class="line"></span><br><span class="line">        LockSupport.unpark(t2);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"5: "</span> + t2.getState());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                System.out.println(<span class="string">"t3 得到了锁 o"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                SleepHelper.sleepSeconds(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        SleepHelper.sleepSeconds(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        t3.start();</span><br><span class="line">        SleepHelper.sleepSeconds(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"6: "</span> + t3.getState());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程的打断"><a href="#线程的打断" class="headerlink" title="线程的打断"></a>线程的打断</h2><p><strong>小节说明：</strong></p>
<p>重要程度：中（面试不多）</p>
<p>小节难度：低</p>
<h3 id="interrupt相关的三个方法："><a href="#interrupt相关的三个方法：" class="headerlink" title="interrupt相关的三个方法："></a>interrupt相关的三个方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Thread.java  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span>            <span class="comment">//t.interrupt() 打断t线程（设置t线程某给标志位f=true，并不是打断线程的运行）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span>     <span class="comment">//t.isInterrupted() 查询打断标志位是否被设置（是不是曾经被打断过）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span><span class="comment">//Thread.interrupted() 查看“当前”线程是否被打断，如果被打断，恢复标志位</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li>interrupt() ：实例方法，设置线程中断标志（打扰一下，你该处理一下中断）</li>
<li>isInterrupted()：实例方法，有没有人打扰我？</li>
<li>interrupted()：静态方法，有没有人打扰我（当前线程）？复位！</li>
</ol>
<h3 id="interrupt和sleep-wait-join"><a href="#interrupt和sleep-wait-join" class="headerlink" title="interrupt和sleep() wait() join()"></a>interrupt和sleep() wait() join()</h3><p>sleep()方法在睡眠的时候，不到时间是没有办法叫醒的，这个时候可以用interrupt设置标志位，然后呢必须得catch InterruptedException来进行处理，决定继续睡或者是别的逻辑，（自动进行中断标志复位）</p>
<h3 id="interrupt是否能中断正在竞争锁的线程"><a href="#interrupt是否能中断正在竞争锁的线程" class="headerlink" title="interrupt是否能中断正在竞争锁的线程"></a>interrupt是否能中断正在竞争锁的线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_000_threadbasic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mashibing.util.SleepHelper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * interrupt与sleep() wait() join()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T09_Interrupt_and_sync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                SleepHelper.sleepSeconds(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        SleepHelper.sleepSeconds(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"t2 end!"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>interrupt()不能打断正在竞争锁的线程synchronized()</p>
<h3 id="如果想打断正在竞争锁的线程，使用ReentrantLock的lockInterruptibly"><a href="#如果想打断正在竞争锁的线程，使用ReentrantLock的lockInterruptibly" class="headerlink" title="如果想打断正在竞争锁的线程，使用ReentrantLock的lockInterruptibly()"></a>如果想打断正在竞争锁的线程，使用ReentrantLock的lockInterruptibly()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_000_threadbasic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mashibing.util.SleepHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * interrupt与lockInterruptibly()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T11_Interrupt_and_lockInterruptibly</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SleepHelper.sleepSeconds(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"t1 end!"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        SleepHelper.sleepSeconds(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"t2 start!"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lockInterruptibly();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"t2 end!"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        SleepHelper.sleepSeconds(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">        t2.interrupt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优雅的结束线程"><a href="#优雅的结束线程" class="headerlink" title="优雅的结束线程"></a>优雅的结束线程</h2><p><strong>小节说明：</strong></p>
<p>本节内容的重要程度：中（面试有可能被问）</p>
<p>小节难度：低</p>
<p>结束线程的方法：</p>
<ol>
<li>自然结束（能自然结束就尽量自然结束）</li>
<li>stop() suspend() resume()</li>
<li>volatile标志<ol>
<li>不适合某些场景（比如还没有同步的时候，线程做了阻塞操作，没有办法循环回去）</li>
<li>打断时间也不是特别精确，比如一个阻塞容器，容量为5的时候结束生产者，<br>但是，由于volatile同步线程标志位的时间控制不是很精确，有可能生产者还继续生产一段儿时间</li>
</ol>
</li>
<li>interrupt() and isInterrupted（比较优雅）</li>
</ol>
<h2 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h2><p>（不重要，暂忽略。）</p>
<p>ThreadGroups - Thread groups are best viewed as an unsuccessful experiment , and you may simply ignore their existence! - Joshua Bloch one of JDK designers</p>
<h2 id="并发编程的特性"><a href="#并发编程的特性" class="headerlink" title="并发编程的特性"></a>并发编程的特性</h2><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><h4 id="线程的原子性"><a href="#线程的原子性" class="headerlink" title="线程的原子性"></a>线程的原子性</h4><p>从一个简单的小程序谈起：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_001_sync_basics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T00_IPlusPlus</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> n = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">100</span>];</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(threads.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    <span class="comment">//synchronized (T00_IPlusPlus.class) &#123;</span></span><br><span class="line">                    n++;</span><br><span class="line">                    <span class="comment">//&#125;</span></span><br><span class="line">                &#125;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(n);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一些基本概念</strong></p>
<p>race condition =&gt; 竞争条件 ， 指的是多个线程访问共享数据的时候产生竞争</p>
<p>数据的不一致（unconsistency)，并发访问之下产生的不期望出现的结果</p>
<p>如何保障数据一致呢？–&gt; 线程同步（线程执行的顺序安排好），</p>
<p>monitor （管程） —&gt; 锁</p>
<p>critical section -&gt; 临界区</p>
<p>如果临界区执行时间长，语句多，叫做 锁的粒度比较粗，反之，就是锁的粒度比较细</p>
<p>具体： 保障操作的原子性（Atomicity)</p>
<ol>
<li><p>悲观锁：悲观的认为这个操作会被别的线程打断（悲观锁）synchronized（上一个小程序）</p>
</li>
<li><p>乐观锁：乐观的认为这个做不会被别的线程打断（乐观锁 自旋锁 无锁）cas操作<br>CAS = Compare And Set/Swap/Exchange</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决同样的问题的更高效的方法，使用AtomXXX类</span></span><br><span class="line"><span class="comment"> * AtomXXX类本身方法都是原子性的，但不能保证多个方法连续调用是原子性的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_018_00_AtomicXXX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_AtomicInteger</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*volatile*/</span> <span class="comment">//int count1 = 0;</span></span><br><span class="line"></span><br><span class="line">	AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* synchronized */</span><span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">			<span class="comment">//if count1.get() &lt; 1000</span></span><br><span class="line">			count.incrementAndGet(); <span class="comment">//count1++</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		T01_AtomicInteger t = <span class="keyword">new</span> T01_AtomicInteger();</span><br><span class="line"></span><br><span class="line">		List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			threads.add(<span class="keyword">new</span> Thread(t::m, <span class="string">"thread-"</span> + i));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		threads.forEach((o) -&gt; o.start());</span><br><span class="line"></span><br><span class="line">		threads.forEach((o) -&gt; &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				o.join();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		System.out.println(t.count);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>我们平时所说的”上锁”，一般指的是悲观锁</p>
<h4 id="上锁的本质"><a href="#上锁的本质" class="headerlink" title="上锁的本质"></a>上锁的本质</h4><p>上锁的本质是把并发编程序列化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_001_sync_basics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mashibing.util.SleepHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T00_01_WhatIsLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            <span class="comment">//synchronized (o) &#123; //打开注释试试看，对比结果</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" start!"</span>);</span><br><span class="line">                SleepHelper.sleepSeconds(<span class="number">2</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" end!"</span>);</span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时保障可见性</p>
<p>注意序列化并非其他程序一直没机会执行，而是有可能会被调度，但是抢不到锁，又回到Blocked或者Waiting状态（sync锁升级）</p>
<p>一定是锁定同一把锁（抢一个坑位）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_001_sync_basics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mashibing.util.SleepHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T00_02_SingleLockVSMultiLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object o3 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r1 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" start!"</span>);</span><br><span class="line">                SleepHelper.sleepSeconds(<span class="number">2</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" end!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable r2 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" start!"</span>);</span><br><span class="line">                SleepHelper.sleepSeconds(<span class="number">2</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" end!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable r3 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o3) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" start!"</span>);</span><br><span class="line">                SleepHelper.sleepSeconds(<span class="number">2</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" end!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(r1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r2).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r3).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="什么样的语句（指令）具备原子性？"><a href="#什么样的语句（指令）具备原子性？" class="headerlink" title="什么样的语句（指令）具备原子性？"></a>什么样的语句（指令）具备原子性？</h4><p>CPU级别汇编，需要查询汇编手册！</p>
<p>Java中的8大原子操作：（了解即可，无需背过）</p>
<ol>
<li>lock：主内存，标识变量为线程独占</li>
<li>unlock：主内存，解锁线程独占变量</li>
<li>read：主内存，读取内存到线程缓存（工作内存）</li>
<li>load：工作内存，read后的值放入线程本地变量副本</li>
<li>use：工作内存，传值给执行引擎</li>
<li>assign：工作内存，执行引擎结果赋值给线程本地变量</li>
<li>store：工作内存，存值到主内存给write备用</li>
<li>write：主内存，写变量值</li>
</ol>
<h4 id="JVM中的两中锁"><a href="#JVM中的两中锁" class="headerlink" title="JVM中的两中锁"></a>JVM中的两中锁</h4><p>重量级锁（经过操作系统的调度）synchronized早期都是这种锁（目前的实现中升级到最后也是这种锁）</p>
<p>轻量级锁（CAS的实现，不经过OS调度）(无锁 - 自旋锁 - 乐观锁)</p>
<h4 id="CAS深度剖析"><a href="#CAS深度剖析" class="headerlink" title="CAS深度剖析"></a>CAS深度剖析</h4><p>CAS的ABA问题解决方案 - Version</p>
<p>CAS操作本身的原子性保障</p>
<p>AtomicInteger:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = get();</span><br><span class="line">            <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Unsafe:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure>

<p>运用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.jol;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_TestUnsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T02_TestUnsafe t = <span class="keyword">new</span> T02_TestUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Unsafe unsafe = Unsafe.getUnsafe();</span></span><br><span class="line"></span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Field f = T02_TestUnsafe.class.getDeclaredField("i");</span><br><span class="line">        <span class="keyword">long</span> offset = unsafe.objectFieldOffset(f);</span><br><span class="line">        System.out.println(offset);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> success = unsafe.compareAndSwapInt(t, offset, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(success);</span><br><span class="line">        System.out.println(t.i);</span><br><span class="line">        <span class="comment">//unsafe.compareAndSwapInt()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdk8u: unsafe.cpp:</p>
<p>cmpxchg = compare and exchange set swap</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>

<p>jdk8u: atomic_linux_x86.inline.hpp <strong>93行</strong></p>
<p>is_MP = Multi Processors</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> jint     <span class="title">Atomic::cmpxchg</span>    <span class="params">(jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">"cmpxchgl %1,(%3)"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"=a"</span> (exchange_value)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"r"</span> (exchange_value), <span class="string">"a"</span> (compare_value), <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdk8u: os.hpp is_MP()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_MP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// During bootstrap if _processor_count is not yet initialized</span></span><br><span class="line">    <span class="comment">// we claim to be MP as that is safest. If any platform has a</span></span><br><span class="line">    <span class="comment">// stub generator that might be triggered in this phase and for</span></span><br><span class="line">    <span class="comment">// which being declared MP when in fact not, is a problem - then</span></span><br><span class="line">    <span class="comment">// the bootstrap routine for the stub generator needs to check</span></span><br><span class="line">    <span class="comment">// the processor count directly and leave the bootstrap routine</span></span><br><span class="line">    <span class="comment">// in place until called after initialization has ocurred.</span></span><br><span class="line">    <span class="keyword">return</span> (_processor_count != <span class="number">1</span>) || AssumeMP;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>jdk8u: atomic_linux_x86.inline.hpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) <span class="meta-string">"cmp $0, "</span> #mp <span class="meta-string">"; je 1f; lock; 1: "</span></span></span><br></pre></td></tr></table></figure>

<p>最终实现：</p>
<p>cmpxchg = cas修改变量值</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock</span> <span class="keyword">cmpxchg</span> 指令</span><br></pre></td></tr></table></figure>

<p>硬件：</p>
<p>lock指令在执行的时候视情况采用缓存锁或者总线锁</p>
<h4 id="两种锁的效率"><a href="#两种锁的效率" class="headerlink" title="两种锁的效率"></a>两种锁的效率</h4><p>不同的场景：</p>
<p>临界区执行时间比较长 ， 等的人很多 -&gt; 重量级</p>
<p>时间短，等的人少 -&gt; 自旋锁</p>
<h4 id="synchronized如何保障可见性"><a href="#synchronized如何保障可见性" class="headerlink" title="synchronized如何保障可见性"></a>synchronized如何保障可见性</h4><p><img src="/2021/11/04/%E7%A9%BF%E8%B6%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%B7%E5%AE%AB/Git/myBlog/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20(2)/b746c022dcdc401bac19835adc5fc650.png" alt="image.png"></p>
<h4 id="JVM中的线程和OS线程对应关系"><a href="#JVM中的线程和OS线程对应关系" class="headerlink" title="JVM中的线程和OS线程对应关系"></a>JVM中的线程和OS线程对应关系</h4><p>JVM 1:1 -&gt; LOOM -&gt; M:N (golang)</p>
<h4 id="synchronized锁升级过程"><a href="#synchronized锁升级过程" class="headerlink" title="synchronized锁升级过程"></a>synchronized锁升级过程</h4><p>（内容太多，见另一篇文档）</p>
<h4 id="常见的锁类型"><a href="#常见的锁类型" class="headerlink" title="常见的锁类型"></a>常见的锁类型</h4><ol>
<li>悲观锁 乐观锁</li>
<li>自旋锁（CAS)</li>
<li>读写锁</li>
<li>排他锁 共享锁</li>
<li>分段锁</li>
<li>死锁 活锁</li>
<li>数据库的行锁 表锁 间隙锁 …</li>
<li>偏向锁</li>
<li>可重入锁</li>
</ol>
<h2 id="题外话：有没有程序天生就是线程安全的？"><a href="#题外话：有没有程序天生就是线程安全的？" class="headerlink" title="题外话：有没有程序天生就是线程安全的？"></a>题外话：有没有程序天生就是线程安全的？</h2><p>有没有一门编程语言天生安全，目前有一门RUST，但是由于语言难度较大，同时缺乏强有力的团队推广，目前并不是很流行，对RUST有了解兴趣的，参考马士兵老师《RUST》</p>
<h2 id="一些大厂难题"><a href="#一些大厂难题" class="headerlink" title="一些大厂难题"></a>一些大厂难题</h2><h3 id="线程唤醒问题（阿里）"><a href="#线程唤醒问题（阿里）" class="headerlink" title="线程唤醒问题（阿里）"></a>线程唤醒问题（阿里）</h3><h4 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 有三个线程 A,B,C</span></span><br><span class="line"><span class="comment">      * A为什么总是在C前面抢到锁？？？</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startThreadA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">             <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                 System.out.println(Thread.currentThread().getName() + <span class="string">": get lock"</span>);</span><br><span class="line">                 <span class="comment">//启动线程b</span></span><br><span class="line">                 startThreadB();</span><br><span class="line">                 System.out.println(Thread.currentThread().getName() + <span class="string">": start wait"</span>);</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     <span class="comment">//线程a wait</span></span><br><span class="line">                     LOCK.wait();</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">                 System.out.println(Thread.currentThread().getName() + <span class="string">": get lock after wait"</span>);</span><br><span class="line">                 System.out.println(Thread.currentThread().getName() + <span class="string">": release lock"</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;, <span class="string">"thread-A"</span>).start();</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThreadB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">             <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                 System.out.println(Thread.currentThread().getName() + <span class="string">": get lock"</span>);</span><br><span class="line">                 <span class="comment">//启动线程c</span></span><br><span class="line">                 startThreadC();</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">                 System.out.println(Thread.currentThread().getName() + <span class="string">": start notify"</span>);</span><br><span class="line">                 <span class="comment">//线程b唤醒其他线程</span></span><br><span class="line">                 LOCK.notify();</span><br><span class="line">                 System.out.println(Thread.currentThread().getName() + <span class="string">": release lock"</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;, <span class="string">"thread-B"</span>).start();</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThreadC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">             System.out.println(Thread.currentThread().getName() + <span class="string">": thread c start"</span>);</span><br><span class="line">             <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                 System.out.println(Thread.currentThread().getName() + <span class="string">": get lock"</span>);</span><br><span class="line">                 System.out.println(Thread.currentThread().getName() + <span class="string">": release lock"</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;, <span class="string">"thread-C"</span>).start();</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">new</span> Test().startThreadA();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果:"></a>输出结果:</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">thread-A: get <span class="keyword">lock</span></span><br><span class="line"> <span class="keyword">thread</span>-A: <span class="keyword">start</span> <span class="keyword">wait</span></span><br><span class="line"> <span class="keyword">thread</span>-B: <span class="keyword">get</span> <span class="keyword">lock</span></span><br><span class="line"> <span class="keyword">thread</span>-C: <span class="keyword">thread</span> c <span class="keyword">start</span></span><br><span class="line"> <span class="keyword">thread</span>-B: <span class="keyword">start</span> notify</span><br><span class="line"> <span class="keyword">thread</span>-B: <span class="keyword">release</span> <span class="keyword">lock</span></span><br><span class="line"> <span class="keyword">thread</span>-A: <span class="keyword">get</span> <span class="keyword">lock</span> <span class="keyword">after</span> <span class="keyword">wait</span></span><br><span class="line"> <span class="keyword">thread</span>-A: <span class="keyword">release</span> <span class="keyword">lock</span></span><br><span class="line"> <span class="keyword">thread</span>-C: <span class="keyword">get</span> <span class="keyword">lock</span></span><br><span class="line"> <span class="keyword">thread</span>-C: <span class="keyword">release</span> <span class="keyword">lock</span></span><br></pre></td></tr></table></figure>

<h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>为什么每次运行，线程A总是优先于线程C获取锁</p>
<h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>在Hotspot源码中，我们知道synchronized关键字是通过monitor_enter和monitor_exit字节来实现的，最终用于阻塞线程的对象为ObjectMonitor对象，该对象包含三个关键字段：<em>WaitSet、</em>cxq、<em>EntryList。</em>WaitSet用于保存使用wait方法释放获得的synchronized锁对象的线程，也即我们调用wait函数，那么当前线程将会释放锁，并将自身放入等待集中。而cxq队列用于存放竞争ObjectMonitor锁对象失败的线程，而_EntryList用于也用于存放竞争锁失败的线程。那么它们之间有何区别呢？这是由于我们需要频繁的释放和获取锁，当我们获取锁失败那么将需要把线程放入竞争列表中，当唤醒时需要从竞争列表中获取线程唤醒获取锁，而如果我们只用一个列表来完成这件事，那么将会导致锁争用导致CPU资源浪费且影响性能，这时我们独立出两个列表，其中cxq列表用于竞争放入线程，而entrylist用于单线程唤醒操作。具体策略是这样的：</p>
<ol>
<li>线程竞争锁失败后CAS放入cxq列表中</li>
<li>线程释放锁后将根据策略来唤醒cxq或者entrylist中的线程（我们这里只讨论默认策略）</li>
<li>默认策略下优先唤醒entrylist列表中的线程，因为唤醒线程对象的操作是单线程的，也即只有获取锁并且释放锁的线程可以操作，所以操作entrylist是线程安全的</li>
<li>如果entrylist列表为空，那么将会CAS将cxq中的等待线程一次性获取到entrylist中并开始逐个唤醒</li>
</ol>
<p>在hotspot中我们称这种算法为电梯算法，也即将需要唤醒的线程一次性从竞争队列中放入entrylist唤醒队列。</p>
<p>那么这时我们就可以分析以上代码为何总是唤醒线程A了，我们先看线程执行顺序，首先启动线程A，随后线程A启动线程B，B线程需要获取对象锁从而创建线程C，我们看到当线程A调用wait方法将自己放入等待集中后，将会唤醒线程B，随后线程B创建并启动了线程C，然后等待C开始执行，由于此时对象锁由线程B持有，所以线程C需要放入cxq竞争队列，随后B从睡眠中醒来，执行notify方法，该方法总是唤醒了线程A而不是C，也即优先处理等待集中的线程而不是cxq竞争队列的线程。那么我们通过notify方法来看看实现原理。Notify便是Wait操作的反向操作，所以这里很简单，无非就是将线程从等待集中移出并且唤醒。源码如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>， JVM_MonitorNotify(JNIEnv* env， jobject handle))</span><br><span class="line">     <span class="function">Handle <span class="title">obj</span><span class="params">(THREAD， JNIHandles：：resolve_non_null(handle))</span></span>;</span><br><span class="line"> <span class="comment">// 直接调用ObjectSynchronizer：：notify</span></span><br><span class="line"> ObjectSynchronizer：：notify(obj， CHECK); </span><br><span class="line"> JVM_END</span><br></pre></td></tr></table></figure>

<p>这里直接跟进ObjectSynchronizer：：notify。源码如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectSynchronizer：：notify(Handle obj， TRAPS) &#123;</span><br><span class="line">     <span class="keyword">if</span> (UseBiasedLocking) &#123; </span><br><span class="line">         <span class="comment">// 如果使用偏向锁，那么取消偏向锁</span></span><br><span class="line">         BiasedLocking：：revoke_and_rebias(obj， <span class="literal">false</span>， THREAD);</span><br><span class="line">     &#125;</span><br><span class="line">     markOop mark = obj-&gt;mark();</span><br><span class="line">     <span class="keyword">if</span> (mark-&gt;has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) &#123; </span><br><span class="line">         <span class="comment">// 如果是轻量级锁，那么直接返回，因为wait操作需要通过对象监视器来做</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     ObjectSynchronizer：：inflate(THREAD， obj())-&gt;notify(THREAD);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最终调用了ObjectSynchronizer的notify方法来唤醒。源码如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectMonitor：：notify(TRAPS) &#123;</span><br><span class="line">     CHECK_OWNER();</span><br><span class="line">     <span class="keyword">if</span> (_WaitSet == <span class="literal">NULL</span>) &#123; </span><br><span class="line">         <span class="comment">// 如果等待集为空，直接返回</span></span><br><span class="line">         <span class="keyword">return</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> Policy = Knob_MoveNotifyee ;        <span class="comment">// 移动策略，这里默认是2</span></span><br><span class="line">     Thread：：SpinAcquire (&amp;_WaitSetLock， <span class="string">"WaitSet - notify"</span>) ;   <span class="comment">// 首先对等待集上自旋锁</span></span><br><span class="line">     <span class="comment">// 调用DequeueWaiter将一个等待线程从等待集中拿出来</span></span><br><span class="line">     ObjectWaiter * iterator = DequeueWaiter() ; </span><br><span class="line">     <span class="keyword">if</span> (iterator != <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (Policy != <span class="number">4</span>) &#123;      <span class="comment">// 如果策略不等于4那么将线程的状态修改为TS_ENTER</span></span><br><span class="line">             iterator-&gt;TState = ObjectWaiter：：TS_ENTER ;</span><br><span class="line">         &#125;</span><br><span class="line">         iterator-&gt;_notified = <span class="number">1</span> ;   <span class="comment">// 唤醒计数器</span></span><br><span class="line">         Thread * Self = THREAD;</span><br><span class="line">         iterator-&gt;_notifier_tid = Self-&gt;osthread()-&gt;thread_id();</span><br><span class="line">         ObjectWaiter * List = _EntryList ;</span><br><span class="line">         <span class="keyword">if</span> (Policy == <span class="number">0</span>) &#123;          <span class="comment">// 如果策略为0，那么头插入到entrylist中</span></span><br><span class="line">             <span class="keyword">if</span> (List == <span class="literal">NULL</span>) &#123;     <span class="comment">// 如果entrylist为空，那么将当前监视器直接作为_EntryList 头结点</span></span><br><span class="line">                 iterator-&gt;_next = iterator-&gt;_prev = <span class="literal">NULL</span> ;</span><br><span class="line">                 _EntryList = iterator ;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;            <span class="comment">// 否则头插</span></span><br><span class="line">                 List-&gt;_prev = iterator ;</span><br><span class="line">                 iterator-&gt;_next = List ;</span><br><span class="line">                 iterator-&gt;_prev = <span class="literal">NULL</span> ;</span><br><span class="line">                 _EntryList = iterator ;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Policy == <span class="number">1</span>) &#123;   <span class="comment">// 如果策略为1，那么插入entrylist的尾部</span></span><br><span class="line">             <span class="keyword">if</span> (List == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                 iterator-&gt;_next = iterator-&gt;_prev = <span class="literal">NULL</span> ;</span><br><span class="line">                 _EntryList = iterator ;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 ObjectWaiter * Tail ;</span><br><span class="line">                 <span class="keyword">for</span> (Tail = List ; Tail-&gt;_next != <span class="literal">NULL</span> ; Tail = Tail-&gt;_next) ;</span><br><span class="line">                 Tail-&gt;_next = iterator ;</span><br><span class="line">                 iterator-&gt;_prev = Tail ;</span><br><span class="line">                 iterator-&gt;_next = <span class="literal">NULL</span> ;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Policy == <span class="number">2</span>) &#123;</span><br><span class="line">             <span class="comment">// 如果策略为2，那么如果entrylist为空，那么插入entrylist，否则插入cxq队列</span></span><br><span class="line">             <span class="keyword">if</span> (List == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                 iterator-&gt;_next = iterator-&gt;_prev = <span class="literal">NULL</span> ;</span><br><span class="line">                 _EntryList = iterator ;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 iterator-&gt;TState = ObjectWaiter：：TS_CXQ ;</span><br><span class="line">                 <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                     ObjectWaiter * Front = _cxq ;</span><br><span class="line">                     iterator-&gt;_next = Front ;</span><br><span class="line">                     <span class="keyword">if</span> (Atomic：：cmpxchg_ptr (iterator， &amp;_cxq， Front) == Front) &#123;</span><br><span class="line">                         <span class="keyword">break</span> ;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span></span><br><span class="line">             <span class="keyword">if</span> (Policy == <span class="number">3</span>) &#123;      <span class="comment">// 如果策略为3，那么直接插入cxq</span></span><br><span class="line">                 iterator-&gt;TState = ObjectWaiter：：TS_CXQ ;</span><br><span class="line">                 <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                     ObjectWaiter * Tail ;</span><br><span class="line">                     Tail = _cxq ;</span><br><span class="line">                     <span class="keyword">if</span> (Tail == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                         iterator-&gt;_next = <span class="literal">NULL</span> ;</span><br><span class="line">                         <span class="keyword">if</span> (Atomic：：cmpxchg_ptr (iterator， &amp;_cxq， <span class="literal">NULL</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                             <span class="keyword">break</span> ;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         <span class="keyword">while</span> (Tail-&gt;_next != <span class="literal">NULL</span>) Tail = Tail-&gt;_next ;</span><br><span class="line">                         Tail-&gt;_next = iterator ;</span><br><span class="line">                         iterator-&gt;_prev = Tail ;</span><br><span class="line">                         iterator-&gt;_next = <span class="literal">NULL</span> ;</span><br><span class="line">                         <span class="keyword">break</span> ;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                 <span class="comment">// 否则直接唤醒线程，让线程自己去调用enterI进入监视器</span></span><br><span class="line">                 ParkEvent * ev = iterator-&gt;_event ;</span><br><span class="line">                 iterator-&gt;TState = ObjectWaiter：：TS_RUN ;</span><br><span class="line">                 OrderAccess：：fence() ;</span><br><span class="line">                 ev-&gt;unpark() ;</span><br><span class="line">             &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     Thread：：SpinRelease (&amp;_WaitSetLock) ; <span class="comment">// 释放等待集自旋锁</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个方法DequeueWaiter() 将线程从等待集中取出来，这里的notify读者都知唤醒一个，很多人都说随机唤醒一个，那么我们这里来看看唤醒算法是什么。源码如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> ObjectWaiter* ObjectMonitor：：DequeueWaiter() &#123;</span><br><span class="line">     ObjectWaiter* waiter = _WaitSet;        <span class="comment">// 很简单对吧，直接从头部拿</span></span><br><span class="line">     <span class="keyword">if</span> (waiter) &#123;                       <span class="comment">// 如果waiter不为空，那么从等待集中断链</span></span><br><span class="line">         DequeueSpecificWaiter(waiter);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> waiter;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">inline</span> <span class="keyword">void</span> ObjectMonitor：：DequeueSpecificWaiter(ObjectWaiter* node) &#123;</span><br><span class="line">     ObjectWaiter* next = node-&gt;_next;</span><br><span class="line">     <span class="keyword">if</span> (next == node) &#123;                 <span class="comment">// 如果只有一个节点，那么直接将等待集清空即可</span></span><br><span class="line">         _WaitSet = <span class="literal">NULL</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// 否则双向链表的断链基础操作</span></span><br><span class="line">         ObjectWaiter* prev = node-&gt;_prev;</span><br><span class="line">         next-&gt;_prev = prev;</span><br><span class="line">         prev-&gt;_next = next;</span><br><span class="line">         <span class="keyword">if</span> (_WaitSet == node) &#123;</span><br><span class="line">             _WaitSet = next;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 断开连接后，也需要把断下来的节点，next和prev指针清空</span></span><br><span class="line">     node-&gt;_next = <span class="literal">NULL</span>;</span><br><span class="line">     node-&gt;_prev = <span class="literal">NULL</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>那么读者应该可以明显的看到，底层对于唤醒操作是从等待集的头部选择线程唤醒。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过源码我们看到，为何总是唤醒线程A，这是用于当线程C竞争不到锁时，被放入了cxq队列，而此时entrylist为null，线程A在等待集waitset中，当我们调用notify方法时，由于移动策略默认是2，这时会从等待集的头部将线程A取下，放入到entrylist中，当notify执行完毕后，在执行后面的monitor_exit字节码时将会优先从entrylist中唤醒线程，这就导致了A线程总是被优先执行。</p>
<h3 id="线程执行完isAlive方法返回true问题（谷歌）"><a href="#线程执行完isAlive方法返回true问题（谷歌）" class="headerlink" title="线程执行完isAlive方法返回true问题（谷歌）"></a>线程执行完isAlive方法返回true问题（谷歌）</h3><h4 id="样例代码："><a href="#样例代码：" class="headerlink" title="样例代码："></a>样例代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadAliveTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> </span><br><span class="line">         Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">             System.out.println(<span class="string">"t1 start"</span>);</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">             System.out.println(<span class="string">"t1 end"</span>);</span><br><span class="line">         &#125;);</span><br><span class="line">         t1.start();</span><br><span class="line">         Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">             <span class="keyword">synchronized</span> (t1) &#123;</span><br><span class="line">                 System.out.println(<span class="string">"t2 start"</span>);</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">                 System.out.println(<span class="string">"t1 isAlive:"</span> + t1.isAlive());</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">         t2.start();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">t1</span> start</span><br><span class="line"> <span class="built_in">t2</span> start</span><br><span class="line"> <span class="built_in">t1</span> end</span><br><span class="line"> <span class="built_in">t1</span> isAlive:true</span><br></pre></td></tr></table></figure>

<h4 id="问题：-1"><a href="#问题：-1" class="headerlink" title="问题："></a>问题：</h4><p>为什么线程结束了，isAlive方法还返回true</p>
<h4 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h4><p>我们首先看看执行流程，线程T1启动后将会睡眠2秒，随后2秒后执行结束，随后线程T2启动，T2首先获取到T1的对象锁，然后睡眠5秒，随后调用T1的isAlive方法判定线程是否存活，那么为什么会输出true呢？我们还得先看看isAlive方法如何实现的。我们来看源码。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>首先看到isAlive方法由JNI方法实现。我们来看Hotspot源码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(jboolean, JVM_IsThreadAlive(JNIEnv* env, jobject jthread))</span><br><span class="line">   JVMWrapper(<span class="string">"JVM_IsThreadAlive"</span>);</span><br><span class="line">   oop thread_oop = JNIHandles::resolve_non_null(jthread);</span><br><span class="line">   <span class="keyword">return</span> java_lang_Thread::is_alive(thread_oop);</span><br><span class="line"> JVM_END</span><br></pre></td></tr></table></figure>

<p>我们看到首先通过resolve_non_null方法将jthread转为oop对象thread_oop，随后调用java_lang_Thread的is_alive方法来判断是否存活，我们继续跟进。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">java_lang_Thread::is_alive</span><span class="params">(oop java_thread)</span> </span>&#123;</span><br><span class="line">   JavaThread* thr = java_lang_Thread::thread(java_thread);</span><br><span class="line">   <span class="keyword">return</span> (thr != <span class="literal">NULL</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function">JavaThread* <span class="title">java_lang_Thread::thread</span><span class="params">(oop java_thread)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (JavaThread*)java_thread-&gt;address_field(_eetop_offset);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们看到最后是通过获取java thread对象，也即java的Thread类中的eetop属性，如果该属性为null，那么表明线程已经销毁，也即返回false，如果eetop还在那么返回true，表明线程存活。那么什么是eetop呢？我们还得从线程创建方法入手。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>， JVM_StartThread(JNIEnv* env， jobject jthread))</span><br><span class="line">   JVMWrapper(<span class="string">"JVM_StartThread"</span>);</span><br><span class="line">   JavaThread *native_thread = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">bool</span> throw_illegal_thread_state = <span class="literal">false</span>;      <span class="comment">// 非法线程状态标识</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="comment">// Threads_lock上锁，保证C++的线程对象和操作系统原生线程不会被清除。当前方法执行完，也就是栈帧释放时，会释放这里的锁，当然肯定会调用析构函数，而这个对象的析构函数中调用unlock方法释放锁</span></span><br><span class="line">     <span class="function">MutexLocker <span class="title">mu</span><span class="params">(Threads_lock)</span></span>; </span><br><span class="line"> <span class="keyword">if</span> (java_lang_Thread：：thread(JNIHandles：：resolve_non_null(jthread)) != <span class="literal">NULL</span>) &#123; <span class="comment">// 如果线程不为空，则表明线程已经启动，则为非法状态      </span></span><br><span class="line"> throw_illegal_thread_state = <span class="literal">true</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 本来这里可以检测一下stillborn标记来看看线程是否已经停止，但是由于历史原因，就让线程自己玩了，这里就不玩了</span></span><br><span class="line">      <span class="comment">// 取得线程对象的stackSize的大小</span></span><br><span class="line">       jlong size = java_lang_Thread：：stackSize(JNIHandles：：resolve_non_null(jthread)); </span><br><span class="line">       <span class="comment">// 开始创建C++ Thread对象和原生线程对象，使用无符号的线程栈大小，所以这里不会出现负数</span></span><br><span class="line">       <span class="keyword">size_t</span> sz = size &gt; <span class="number">0</span> ? (<span class="keyword">size_t</span>) size ： <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 创建JavaThread，这里的thread_entry为传入的运行地址，也就是启动线程，需要一个入口执行点，这个函数地址便是入口执行点</span></span><br><span class="line">       native_thread = <span class="keyword">new</span> JavaThread(&amp;thread_entry， sz); </span><br><span class="line">      <span class="comment">// 如果osthread不为空，则标记当前线程还没有被使用</span></span><br><span class="line">       <span class="keyword">if</span> (native_thread-&gt;osthread() != <span class="literal">NULL</span>) &#123; </span><br><span class="line">         native_thread-&gt;prepare(jthread);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果throw_illegal_thread_state不为0，那么直接抛出异常</span></span><br><span class="line"> <span class="keyword">if</span> (throw_illegal_thread_state) &#123; </span><br><span class="line">     THROW(vmSymbols：：java_lang_IllegalThreadStateException());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 原生线程必然不能为空，因为线程是由操作系统创建的，所以没有OS线程，空有个JavaThread类有啥用0.0</span></span><br><span class="line">   <span class="keyword">if</span> (native_thread-&gt;osthread() == <span class="literal">NULL</span>) &#123; </span><br><span class="line">     <span class="keyword">delete</span> native_thread;       <span class="comment">// 直接用C++的delete释放内存</span></span><br><span class="line">     THROW_MSG(vmSymbols：：java_lang_OutOfMemoryError()，<span class="string">"unable to create new native thread"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   Thread：：start(native_thread);     <span class="comment">// 一切准备妥当，开始启动线程</span></span><br><span class="line"> JVM_END</span><br></pre></td></tr></table></figure>

<p>我们看到首先创建了JavaThread对象，该对象内部创建了OSThread对象，我们这么理解：JavaThread代表了C++层面的Java线程，而OSThread代表了操作系统层面的线程对象。随后调用了native_thread-&gt;prepare(jthread)方法为启动线程做准备。我们关注该方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JavaThread::prepare</span><span class="params">(jobject jni_thread, ThreadPriority prio)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 包装当前Java线程对象</span></span><br><span class="line">     <span class="function">Handle <span class="title">thread_oop</span><span class="params">(Thread::current(),</span></span></span><br><span class="line"><span class="function"><span class="params">                       JNIHandles::resolve_non_null(jni_thread))</span></span>;</span><br><span class="line">     <span class="comment">// 将Java层面的线程Oop对象与JavaThread C++层面的对象关联</span></span><br><span class="line">     set_threadObj(thread_oop());</span><br><span class="line">     java_lang_Thread::set_thread(thread_oop(), <span class="keyword">this</span>);</span><br><span class="line">     <span class="comment">// 设置优先级</span></span><br><span class="line">     <span class="keyword">if</span> (prio == NoPriority) &#123;</span><br><span class="line">         prio = java_lang_Thread::priority(thread_oop());</span><br><span class="line">     &#125;</span><br><span class="line">     Thread::set_priority(<span class="keyword">this</span>, prio);</span><br><span class="line">     <span class="comment">// 将JavaThread类放入到全局线程列表中</span></span><br><span class="line">     Threads::add(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们注意看 java_lang_Thread::set_thread方法。我们跟进它的源码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">java_lang_Thread::set_thread</span><span class="params">(oop java_thread, JavaThread* thread)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 将JavaThread C++层面的线程对象设置为Java层面的Thread oop对象的eetop变量</span></span><br><span class="line">     java_thread-&gt;address_field_put(_eetop_offset, (address)thread);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这下我们知道了eetop变量即使JavaThread对象的地址信息。在了解完eetop如何被设置之后我们得继续看，eetop什么时候被取消。当Java线程执行完Runnable接口的run方法最后一个字节码后，将会调用exit方法。该方法完成线程对象的退出和清理操作，我们重点看ensure_join方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JavaThread::exit</span><span class="params">(<span class="keyword">bool</span> destroy_vm, ExitType exit_type)</span> </span>&#123;</span><br><span class="line">     ...</span><br><span class="line">     ensure_join(<span class="keyword">this</span>);</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们继续跟进ensure_join的源码实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ensure_join</span><span class="params">(JavaThread* thread)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 封装Java Thread线程oop对象</span></span><br><span class="line">     <span class="function">Handle <span class="title">threadObj</span><span class="params">(thread, thread-&gt;threadObj())</span></span>;</span><br><span class="line">     <span class="comment">// 获取Java Thread线程oop对象锁</span></span><br><span class="line">     <span class="function">ObjectLocker <span class="title">lock</span><span class="params">(threadObj, thread)</span></span>;</span><br><span class="line">     <span class="comment">// 清除未处理的异常信息</span></span><br><span class="line">     thread-&gt;clear_pending_exception();</span><br><span class="line">     <span class="comment">// 将状态修改为TERMINATED</span></span><br><span class="line">     java_lang_Thread::set_thread_status(threadObj(), java_lang_Thread::TERMINATED);</span><br><span class="line">     <span class="comment">// 将Java Thread线程oop对象与JavaThread C++对象解绑</span></span><br><span class="line">     java_lang_Thread::set_thread(threadObj(), <span class="literal">NULL</span>);</span><br><span class="line">     <span class="comment">// 唤醒所有阻塞在线程对象的线程</span></span><br><span class="line">     lock.notify_all(thread);</span><br><span class="line">     <span class="comment">// 如果以上代码期间发生异常，那么清理挂起的异常</span></span><br><span class="line">     thread-&gt;clear_pending_exception();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们看到最终由ensure_join方法中的java_lang_Thread::set_thread(threadObj(), NULL)，将eetop变量设置为null，当执行完这一步时，我们再通过isAlive方法判断线程是否存活时，将返回false，否则返回true。而我们看到在操作该变量时需要获取线程对象锁。我们来看ObjectLocker的构造函数和析构函数的实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ObjectLocker::ObjectLocker(Handle obj, Thread* thread, <span class="keyword">bool</span> doLock) &#123;</span><br><span class="line">     _dolock = doLock;</span><br><span class="line">     _thread = thread;</span><br><span class="line">     <span class="keyword">if</span> (_dolock) &#123;</span><br><span class="line">         <span class="comment">// 获取Java Thread线程oop对象锁</span></span><br><span class="line">         ObjectSynchronizer::fast_enter(_obj, &amp;_lock, <span class="literal">false</span>, _thread);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ObjectLocker::~ObjectLocker() &#123;</span><br><span class="line">     <span class="keyword">if</span> (_dolock) &#123;</span><br><span class="line">         <span class="comment">// 释放Java Thread线程oop对象锁</span></span><br><span class="line">         ObjectSynchronizer::fast_exit(_obj(), &amp;_lock, _thread);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们看到当我们创建ObjectLocker对象时，会在构造函数中获取到线程对象锁，而当ensure_join方法执行完毕后，将会调用ObjectLocker的析构函数，在该函数中释放线程对象锁。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>这下我们就可以通过以上知识来分析为何isAlive方法在线程执行完毕后仍然返回true了，这是用于isAlive方法通过判断Java线程对象的eetop变量来判定线程是否存活，而当我们线程执行完毕后将会调用exit方法，该方法将会调用ensure_join方法，在该方法中将eetop甚至为null，但是由于赋值前需要获取到Java线程的对象锁，而该对象的对象锁已经由线程T2持有，这时当前线程将会阻塞，从而造成eetop变量没有被清除，从而导致isAlive方法在T1线程执行完毕后仍然返回true。读者也可以看看java Thread的源码，join函数也是通过对Thread对象获取锁然后调用isAlive来判定线程是否结束的，这就意味着如果我们用别的线程持有了Java Thread的对象锁，那么这时调用join方法的线程也是会被阻塞的。</p>
<p>结论：不要用Thread对象作为同步锁对象！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/26/JavaScript%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/26/JavaScript%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">JS基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-10-26 21:22:00 / 修改时间：21:49:49" itemprop="dateCreated datePublished" datetime="2021-10-26T21:22:00+08:00">2021-10-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. JavaScript基础</code></pre><h2 id="JavaScript："><a href="#JavaScript：" class="headerlink" title="JavaScript："></a>JavaScript：</h2>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/10/26/JavaScript%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/26/JavaScript%E9%AB%98%E7%BA%A7%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/26/JavaScript%E9%AB%98%E7%BA%A7%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">ECMAScipt|BOM|DOM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-10-26 21:22:00 / 修改时间：21:49:31" itemprop="dateCreated datePublished" datetime="2021-10-26T21:22:00+08:00">2021-10-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="今日内容："><a href="#今日内容：" class="headerlink" title="今日内容："></a>今日内容：</h1><pre><code>1. JavaScript：
    1. ECMAScript：
    2. BOM：
    3. DOM：
        1. 事件</code></pre><h2 id="DOM简单学习：为了满足案例要求"><a href="#DOM简单学习：为了满足案例要求" class="headerlink" title="DOM简单学习：为了满足案例要求"></a>DOM简单学习：为了满足案例要求</h2><pre><code>* 功能：控制html文档的内容
* 获取页面标签(元素)对象：Element
    * document.getElementById(&quot;id值&quot;):通过元素的id获取元素对象

* 操作Element对象：
    1. 修改属性值：
        1. 明确获取的对象是哪一个？
        2. 查看API文档，找其中有哪些属性可以设置
    2. 修改标签体内容：
        * 属性：innerHTML
        1. 获取元素对象
        2. 使用innerHTML属性修改标签体内容</code></pre><h2 id="事件简单学习"><a href="#事件简单学习" class="headerlink" title="事件简单学习"></a>事件简单学习</h2>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/10/26/JavaScript%E9%AB%98%E7%BA%A7%E7%AC%94%E8%AE%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/26/HTML%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="匡俊桦">
      <meta itemprop="description" content="回忆的沙漏将曾经屈指可数的日子渐渐淡去">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KJHの博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/26/HTML%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Web概述|HTML</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-10-26 21:22:00 / 修改时间：21:49:16" itemprop="dateCreated datePublished" datetime="2021-10-26T21:22:00+08:00">2021-10-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. web概念概述
2. HTML</code></pre><h2 id="web概念概述"><a href="#web概念概述" class="headerlink" title="web概念概述"></a>web概念概述</h2><pre><code>* JavaWeb：
    * 使用Java语言开发基于互联网的项目

* 软件架构：
    1. C/S: Client/Server 客户端/服务器端
        * 在用户本地有一个客户端程序，在远程有一个服务器端程序
        * 如：QQ，迅雷...
        * 优点：
            1. 用户体验好
        * 缺点：
            1. 开发、安装，部署，维护 麻烦
    2. B/S: Browser/Server 浏览器/服务器端
        * 只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序
        * 优点：
            1. 开发、安装，部署，维护 简单
        * 缺点：
            1. 如果应用过大，用户的体验可能会受到影响
            2. 对硬件要求过高

* B/S架构详解
    * 资源分类：
        1. 静态资源：
            * 使用静态网页开发技术发布的资源。
            * 特点：
                * 所有用户访问，得到的结果是一样的。
                * 如：文本，图片，音频、视频, HTML,CSS,JavaScript
                * 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源
        2. 动态资源：
            * 使用动态网页及时发布的资源。
            * 特点：
                * 所有用户访问，得到的结果可能不一样。
                * 如：jsp/servlet,php,asp...
                * 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器


    * 我们要学习动态资源，必须先学习静态资源！

    * 静态资源：
        * HTML：用于搭建基础网页，展示页面的内容
        * CSS：用于美化页面，布局页面
        * JavaScript：控制页面的元素，让页面有一些动态的效果</code></pre><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/10/26/HTML%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/64/">64</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">匡俊桦</p>
  <div class="site-description" itemprop="description">回忆的沙漏将曾经屈指可数的日子渐渐淡去</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">318</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">匡俊桦</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">2.4m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">36:33</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
